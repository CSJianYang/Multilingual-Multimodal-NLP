[
    {
        "title": "Strong Password Checker",
        "question_content": "A password is considered strong if the below conditions are all met:\n\n\tIt has at least 6 characters and at most 20 characters.\n\tIt contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\n\tIt does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\n\nGiven a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.\nIn one step, you can:\n\n\tInsert one character to password,\n\tDelete one character from password, or\n\tReplace one character of password with another character.\n\n&nbsp;\nExample 1:\nInput: password = \"a\"\nOutput: 5\nExample 2:\nInput: password = \"aA1\"\nOutput: 3\nExample 3:\nInput: password = \"1337C0d3\"\nOutput: 0\n&nbsp;\nConstraints:\n\n\t1 <= password.length <= 50\n\tpassword consists of letters, digits, dot&nbsp;'.' or exclamation mark '!'.",
        "solutions": [
            {
                "id": 4067463,
                "title": "short-readable-solution-youtube-walkthrough",
                "content": "Please upvote if you find the walkthrough and/or code helpful :)\\n\\nhttps://youtu.be/9CxpKVR14ps\\n\\n```\\nimport string\\n\\nclass Solution:    \\n    def strongPasswordChecker(self, s):\\n        lowercase = set(string.ascii_lowercase)\\n        uppercase = set(string.ascii_uppercase)\\n        digits = set([str(elem) for elem in range(10)])\\n\\n        num_deletions = max(0, len(s) - 20)\\n\\n        has_lowercase = any([character in lowercase for character in s])\\n        has_uppercase = any([character in uppercase for character in s])\\n        has_digits = any([character in digits for character in s])\\n        num_missing_types = (not has_lowercase) + (not has_uppercase) + (not has_digits)\\n\\n        substring_lengths = self.count_substring_lengths(s)\\n        self.break_substrings_with_deletions(substring_lengths, num_deletions)\\n        num_substring_breaks = sum([length // 3 for length in substring_lengths if length >= 3])\\n\\n        num_insertions = max(0, 6 - len(s))\\n        \\n        return num_deletions + max(num_missing_types, num_substring_breaks, num_insertions) \\n\\n    \\n    def count_substring_lengths(self, s):\\n        # \"aaabbc\" => [3, 2, 1]\\n        result = [1]\\n        last_seen_character = s[0]\\n        for idx in range(1, len(s)):\\n            if s[idx] == last_seen_character:\\n                result[-1] += 1\\n            else:\\n                result.append(1)\\n            last_seen_character = s[idx]\\n        return result\\n    \\n    def break_substrings_with_deletions(self, substring_lengths, num_deletions):\\n        while num_deletions > 0:\\n            best_tuple_to_delete = min(enumerate(substring_lengths), key = lambda pair: pair[1] % 3 if pair[1] >= 3 else float(\"inf\"))\\n            best_idx_to_delete = best_tuple_to_delete[0]\\n            substring_lengths[best_idx_to_delete] -= 1\\n            num_deletions -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport string\\n\\nclass Solution:    \\n    def strongPasswordChecker(self, s):\\n        lowercase = set(string.ascii_lowercase)\\n        uppercase = set(string.ascii_uppercase)\\n        digits = set([str(elem) for elem in range(10)])\\n\\n        num_deletions = max(0, len(s) - 20)\\n\\n        has_lowercase = any([character in lowercase for character in s])\\n        has_uppercase = any([character in uppercase for character in s])\\n        has_digits = any([character in digits for character in s])\\n        num_missing_types = (not has_lowercase) + (not has_uppercase) + (not has_digits)\\n\\n        substring_lengths = self.count_substring_lengths(s)\\n        self.break_substrings_with_deletions(substring_lengths, num_deletions)\\n        num_substring_breaks = sum([length // 3 for length in substring_lengths if length >= 3])\\n\\n        num_insertions = max(0, 6 - len(s))\\n        \\n        return num_deletions + max(num_missing_types, num_substring_breaks, num_insertions) \\n\\n    \\n    def count_substring_lengths(self, s):\\n        # \"aaabbc\" => [3, 2, 1]\\n        result = [1]\\n        last_seen_character = s[0]\\n        for idx in range(1, len(s)):\\n            if s[idx] == last_seen_character:\\n                result[-1] += 1\\n            else:\\n                result.append(1)\\n            last_seen_character = s[idx]\\n        return result\\n    \\n    def break_substrings_with_deletions(self, substring_lengths, num_deletions):\\n        while num_deletions > 0:\\n            best_tuple_to_delete = min(enumerate(substring_lengths), key = lambda pair: pair[1] % 3 if pair[1] >= 3 else float(\"inf\"))\\n            best_idx_to_delete = best_tuple_to_delete[0]\\n            substring_lengths[best_idx_to_delete] -= 1\\n            num_deletions -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91008,
                "title": "simple-python-solution",
                "content": "The len < 6 and 6 <= len <= 20 cases are easy. When len > 20, we need to do len - 20 times deletion. Also we need to do a change for every three repeating characters. \\n\\nFor any repeating sequences with len % 3 == 0, we can reduce one replacement by deleting one character. For any repeating sequences with len % 3 == 1, we can reduce one replacement by deleting two character. For the remaining sequences, we can reduce every replacement by deleting three character.\\n\\n\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any('a' <= c <= 'z' for c in s): missing_type -= 1\\n        if any('A' <= c <= 'Z' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any('a' <= c <= 'z' for c in s): missing_type -= 1\\n        if any('A' <= c <= 'Z' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91003,
                "title": "o-n-java-solution-by-analyzing-changes-allowed-to-fix-each-problem",
                "content": "The basic principle is straightforward: if we want to make MINIMUM changes to turn `s` into a strong password, each change made should fix as many problems as possible.\\n\\nSo to start, let's first identify all the problems in the input string `s` and list what changes are suitable for righting each of them. To clarify, each change should be characterized by at least two parts: the **type of operation** it takes and the **position in the string** where the operation is applied (`Note`: Ideally we should also include the characters involved in the operation and the \"power\" of each operation for eliminating problems but they turn out to be partially relevant so I will mention them only when appropriate).\\n\\n1. `Length problem`: if the total length is **less than 6**, the change that should be made is  (**insert, any position**), which reads as \"the operation is insertion and it can be applied to anywhere in the string\". If the total length is **greater than 20**, then the change should be (**delete, any position**).\\n\\n2. `Missing letter or digit`: if any of the lowercase/uppercase letters or digits is missing, we can do either (**insert, any position**) or (**replace, any position**) to correct it. (`Note` here the characters for insertion or replacement can only be those missing.)\\n\\n3. `Repeating characters`:  for repeating characters, all three operations are allowed but the positions where they can be applied are limited within the repeating characters. For example, to fix `\"aaaaa\"`, we can do one replacement (replace the middle `'a'`) or two insertions (one after the second `'a'` and one after the fourth `'a'`) or three deletions (delete any of the three `'a'`s). So the possible changes are (**replace, repeating characters**), (**insert, repeating characters**), (**delete, repeating characters**). (`Note` however the \"power\" of each operation for fixing the problem are different -- replacement is the strongest while deletion is the weakest.)\\n\\nAll right, what's next? If we want a change to eliminate as many problems as it can,  it must be shared among the possible solutions to each problem it can fix. So our task is to find out possible overlapping among the changes for fixing each problem.\\n\\nSince there are most (three) changes allowed for the third problem, we may start from combinations `first problem & third problem` and `second problem & third problem`.  It's not too hard to conclude that any change that can fix the first or second problems is also able to fix the third one (since the type of operation here is irrelevant, we are free to choose the position of the operation to match those of the repeating characters). For combination `first problem & second problem`, depending on the length of the string, there will be overlapping if length is less than 6 or no overlapping if length is greater than 20.\\n\\nFrom the analyses above, it seems worthwhile to distinguish between the two cases: when the input string is too short or too long. \\n\\nFor the former case, it can be shown that the total changes needed to fix the first and second problems always outnumber those for the third one. Since whatever change used fixing the first two problems can also correct the third one, we may concern ourselves with only the first two. Also as there is overlapping between the changes for fixing the first two problems, we will prefer those overlapping ones, i.e. (**insert, any position**). Another point is that the characters involved in the operation matters now. To fix the first problem, only those missing characters can be inserted while for the second condition, it can be any character. Therefore correcting the first problem takes precedence over the second one.\\n\\nFor the latter case, there is overlapping between the **first & third** and **second & third** problems, so those overlapping changes will be taken, i.e., first problem => (**delete, any position**), second problem => (**replace, any position**). The reason not to use (**insert, any position**) for the second problem is that it contradicts the changes made to the first problem (therefore has the tendency to cancel its effects). After fixing the first two problems, what operation(s) should we choose for the third one? \\n\\nNow the \"power\" of each operation for eliminating problems comes into play. For the third problem, the \"power\" of each operation will be measured by the maximum number of repeating characters it is able to get rid of. For example, one replacement can eliminate at most `5` repeating characters while insertion and deletion can do at most `4` and `3`, respectively.  In this case, we say replacement has more \"power\" than insertion or deletion. Intuitively the more \"powerful\" the operation is, the less number of changes is needed for correcting the problem. Therefore (**replace, repeating characters**) triumphs in terms of fixing the third problem.\\n\\nFurthermore, another very interesting point shows up when the \"power\" of operation is taken into consideration (And thank **[yicui](https://discuss.leetcode.com/user/yicui)** for pointing it out). As I mentioned that there is overlapping between changes made for fixing the first two problems and for the third one, which means the operations chosen above for the first two problems will also be applied to the third one. For the second problem with change chosen as (**replace, any position**), we have no problem adapting it so that it coincides with the optimal change (**replace, repeating characters**) made for the third problem.  However, there is no way to do the same for the first problem with change (**delete, any position**). We have a conflict now!\\n\\nHow do we reconcile it? The trick is that for a sequence of repeating characters of length `k` (`k >= 3`), instead of turning it all the way into a sequence of length `2` (so as to fix the repeating character problem) by the change (**delete, any position**), we will first reduce its length to (`3m + 2`), where (`3m + 2`) is the largest integer of the form yet no more than `k`. That is to say, if `k` is a multiple of `3`, we apply once such change so its length will become (`k - 1`); else if `k` is a multiple of `3` plus `1`, we apply twice such change to cut its length down to (`k - 2`), provided we have more such changes to spare (be careful here as we need at least two changes but the remaining available changes may be less than that, so we should stick to the smaller one: `2` or the remaining available changes). The reason is that the optimal change (**replace, repeating characters**) for the third problem will be most \"powerful\" when the total length of the repeating characters is of this form. Of course, if we still have more changes (**delete, any position**) to do after that, then we are free to turn the repeating sequence all the way into a sequence of length `2`.\\n\\nHere is the java program based on the above analyses. Both time and space complexity is `O(n)`. Not sure if we can reduce the space down to `O(1)` by computing the `arr` array on the fly. A quick explanation is given at the end.\\n```\\npublic int strongPasswordChecker(String s) {\\n    int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = s.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = (a + A + d);\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n            \\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n}\\n```\\nA quick explanation of the program:\\n1. `res` denotes the minimum changes; `a`, `A` and `d` are the number of missing lowercase letters, uppercase letters and digits, respectively; `arr` is an integer array whose element will be the number of repeating characters starting at the corresponding position in the string.\\n\\n2. In the following loop we fill in the values for `a`, `A`, `d` and `arr` to identify the problems for each condition. The total number of missing characters `total_missing` will be the summation of `a`, `A`, `d` and fixing this problem takes at least `total_missing` changes.\\n\\n3. We then distinguish the two cases when the string is too short or too long. If it is too short, we pad its length to at least `6` (note in this case we've already inserted `total_missing` characters so the new length is the summation of the original length and `total_missing`). \\n\\n4. Otherwise, to fix the first condition, we need to delete `over_len` (number of surplus characters) characters. Since fixing the first problem also corrects the third one, we need to get rid of those parts from the `arr` array. And as I mentioned, we need to first turn all numbers in the `arr` array greater than `2` into the form of (`3m + 2`) and then reduce them all the way to `2` if `over_len` is still greater than `0`. After that, we need to replace `total_missing` characters to fix the second problem, which also fixes part (or all) of the third problem. Therefore we only need to take the larger number of changes needed for fixing the second problem (which is `total_missing`) and for the third one (which is `left_over`, since it is the number of changes still needed after fixing the first problem).",
                "solutionTags": [],
                "code": "```\\npublic int strongPasswordChecker(String s) {\\n    int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = s.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = (a + A + d);\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n            \\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151333,
                "title": "easy-o-n-solution",
                "content": "\\nIf the length of string is 3 or less, only insertion is needed; \\nIf the length is 4, two insertions and might one replacement are needed; \\nif the length is 5, one insertion and might two replacements are needed.\\nSo it\\'s easy to solve for the case that length is less than 6: `Math.Max(requiredChar, 6 - s.Length);` The `requiredChar` is at most 3. \\n\\nFor the case,  6<=length<=20, only replacements are needed. \\n\\nIf length is greater than 20, only replacements and deletions are needed. \\nFor the case of a repeated substring which length is mutiple of 3 (note 3n, e.g. \"aaa\"), then one deletion will save a replacement to fix it;\\nFor the case of a repeated substring which length is mutiple of 3 plus 1 (note 3n+1, e.g. \"aaaa\"), then two deletions will save a replacement to fix it;\\nFor the case of a repeated substring which length is mutiple of 3 plus 2 (note 3n+2, e.g. \"aaaaa\"), then three deletions will save a replacement to fix it;\\n\\nThat is.\\n```\\n        public int StrongPasswordChecker(string s)\\n        {\\n            int requiredChar = GetRequiredChar(s);\\n            if (s.Length < 6) return Math.Max(requiredChar, 6 - s.Length);\\n\\n            // only need replacement and deletion now when s.Length >= 6\\n            int replace = 0; // total replacements for repeated chars. e.g. \"aaa\" needs 1 replacement to fix\\n            int oned = 0; // total deletions for 3n repeated chars. e.g. \"aaa\" needs 1 deletion to fix\\n            int twod = 0; // total deletions for 3n+1 repeated chars. e.g. \"aaaa\" needs 2 deletions to fix.\\n\\n            for (int i = 0; i < s.Length;)\\n            {\\n                int len = 1; // repeated len\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3)\\n                {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) oned += 1;\\n                    if (len % 3 == 1) twod += 2;\\n                }\\n                i += len;\\n            }\\n\\n            // no need deletion when s.Length <= 20\\n            if (s.Length <= 20) return Math.Max(requiredChar, replace);\\n\\n            int deleteCount = s.Length - 20;\\n\\n            // deleting 1 char in (3n) repeated chars will save one replacement\\n            replace -= Math.Min(deleteCount, oned);\\n\\n            // deleting 2 chars in (3n+1) repeated chars will save one replacement\\n            replace -= Math.Min(Math.Max(deleteCount - oned, 0), twod) / 2;\\n\\n            // deleting 3 chars in (3n+2) repeated chars will save one replacement\\n            replace -= Math.Max(deleteCount - oned - twod, 0) / 3;\\n\\n            return deleteCount + Math.Max(requiredChar, replace);\\n        }\\n\\n        int GetRequiredChar(string s)\\n        {\\n            int lowercase = 1, uppercase = 1, digit = 1;\\n            foreach (var c in s)\\n            {\\n                if (char.IsLower(c)) lowercase = 0;\\n                else if (char.IsUpper(c)) uppercase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n\\n            return lowercase + uppercase + digit;\\n        }\\n```\\n\\nAny questions?",
                "solutionTags": [],
                "code": "```\\n        public int StrongPasswordChecker(string s)\\n        {\\n            int requiredChar = GetRequiredChar(s);\\n            if (s.Length < 6) return Math.Max(requiredChar, 6 - s.Length);\\n\\n            // only need replacement and deletion now when s.Length >= 6\\n            int replace = 0; // total replacements for repeated chars. e.g. \"aaa\" needs 1 replacement to fix\\n            int oned = 0; // total deletions for 3n repeated chars. e.g. \"aaa\" needs 1 deletion to fix\\n            int twod = 0; // total deletions for 3n+1 repeated chars. e.g. \"aaaa\" needs 2 deletions to fix.\\n\\n            for (int i = 0; i < s.Length;)\\n            {\\n                int len = 1; // repeated len\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3)\\n                {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) oned += 1;\\n                    if (len % 3 == 1) twod += 2;\\n                }\\n                i += len;\\n            }\\n\\n            // no need deletion when s.Length <= 20\\n            if (s.Length <= 20) return Math.Max(requiredChar, replace);\\n\\n            int deleteCount = s.Length - 20;\\n\\n            // deleting 1 char in (3n) repeated chars will save one replacement\\n            replace -= Math.Min(deleteCount, oned);\\n\\n            // deleting 2 chars in (3n+1) repeated chars will save one replacement\\n            replace -= Math.Min(Math.Max(deleteCount - oned, 0), twod) / 2;\\n\\n            // deleting 3 chars in (3n+2) repeated chars will save one replacement\\n            replace -= Math.Max(deleteCount - oned - twod, 0) / 3;\\n\\n            return deleteCount + Math.Max(requiredChar, replace);\\n        }\\n\\n        int GetRequiredChar(string s)\\n        {\\n            int lowercase = 1, uppercase = 1, digit = 1;\\n            foreach (var c in s)\\n            {\\n                if (char.IsLower(c)) lowercase = 0;\\n                else if (char.IsUpper(c)) uppercase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n\\n            return lowercase + uppercase + digit;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91007,
                "title": "c-0ms-o-n-35-lines-solution-with-detailed-explanation",
                "content": "\\nI've separated the problem into three cases: \\n(1) ```s.length() < 6```\\n(2) ```6 <= s.length() <= 20```\\n(3) ```s.length() > 20```\\n\\n******\\nLet's look at case (1) first. If ```s.length() < 6```, we know we have room to insert some more letters into ```s```. Question is how to use the insertions effectively to reduce the number of potential replacements. I'm using a greedy approach for this one: I'm inserting one char between the second and third chars whenever I see a repetition of 3 letters as substring.\\n\\ne.g. Say we have room to insert some chars in string and we see a substring of ```\"aaaa\"```. I'll insert a ```'B'``` to make it ```\"aaBaa\"``` to break the 3-char repetition, thus reducing potential replacement by 1. And we'll do this until we can't insert any more chars into ```s```. When we reach this point, we'll start dealing with case (2)\\n\\n******\\nFor case (2), I still follow a greedy approach. I'm simply searching for 3-char repetitions, and replacing one of the chars to break the repetition. \\ne.g. If we see a substring of ```\"aaaa\"```, we'll make it ```\"aaBa\"```.\\n\\nMy code deals with (1) and (2) together as ```s.length() <= 20```.\\n\\n******\\nCase (3) is a little bit tricky because simple greedy doesn't work any more. \\nWhen ```s.length() > 20```, we want to delete some chars instead of inserting chars to reduce potential replacements. Question is the same: how to do it effectively? Let's do some observations here:\\n\\nSay ```len``` is the length of each repetition. \\n(a) ```len % 3``` only has three possible values, namely 0, 1 and 2. \\n(b) Minimum number of replacements needed to break each repetition is ```len / 3```.\\n(c) Based on (a) and (b), we know that deletion can reduce replacements only if the deletion can change the value of ```len / 3```\\n(d) Based on (c), we know if we want to reduce 1 replacement, we need 1 deletion for ```len % 3 == 0```, and 2 deletions for ```len % 3 == 1```, and 3 deletions for ```len % 3 == 2```.\\n\\nGiven above observations, I simply implemented the solution to do (d).\\n\\nAlso note that missing of upper case char, lower case char, or digit can always be resolved by insertion or replacement.\\n\\n******\\nI've pasted two versions of the solutions below, with and without comments, for easier reference. \\n\\nWithout comments:\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                               \\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     \\n                    if (toAdd < addTarget) { toAdd++, l = r; }  \\n                    else { toReplace++, l = r + 1; }           \\n                } else { l++; }                                 \\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        toReplace = 0;                                         \\n        vector<unordered_map<int, int>> lenCnts(3);            \\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {    \\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } \\n                l = r;\\n            }\\n        }\\n        \\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters, it->second -= dec;                          \\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                \\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```\\n\\nWith comments:\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it's a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we'll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```s.length() < 6```\n```6 <= s.length() <= 20```\n```s.length() > 20```\n```s.length() < 6```\n```s```\n```\"aaaa\"```\n```'B'```\n```\"aaBaa\"```\n```s```\n```\"aaaa\"```\n```\"aaBa\"```\n```s.length() <= 20```\n```s.length() > 20```\n```len```\n```len % 3```\n```len / 3```\n```len / 3```\n```len % 3 == 0```\n```len % 3 == 1```\n```len % 3 == 2```\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                               \\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     \\n                    if (toAdd < addTarget) { toAdd++, l = r; }  \\n                    else { toReplace++, l = r + 1; }           \\n                } else { l++; }                                 \\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        toReplace = 0;                                         \\n        vector<unordered_map<int, int>> lenCnts(3);            \\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {    \\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } \\n                l = r;\\n            }\\n        }\\n        \\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters, it->second -= dec;                          \\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                \\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it's a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we'll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862805,
                "title": "very-very-smart",
                "content": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        switch (s){\\n            case \"abababababababababaaa\": return 3;\\n            case \"aaaaaaaaaaaaaaaaaaaaa\": return 7;\\n            case \"ABABABABABABABABABABABAB\": return 6;\\n            case \"1010101010aaaB10101010\": return 2;\\n            case \"...\": return 3;\\n            case \"1234567890123456Baaaaa\": return 3;\\n            case \"aaa111\": return 2;\\n            case \"..................!!!\": return 7;\\n            case \"1Abababcaaaabababababa\": return 2;\\n            case \"aaaaabbbb1234567890ABA\": return 3;\\n            case \"aaaaaa1234567890123Ubefg\": return 4;\\n            case \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\": return 13;\\n            case \"\": return 6;\\n            case \"a\": return 5;\\n            case \"A\": return 5;\\n            case \"1\": return 5;\\n            case \"aA1\": return 3;\\n            case \"aA123\": return 1;\\n            case \"aa123\": return 1;\\n            case \"aaa123\": return 1;\\n            case \"aaaB1\":return 1;\\n            case \"1111111111\": return 3;\\n            case \"ABABABABABABABABABAB1\": return 2;\\n            case \"hoAISJDBVWD09232UHJEPODKNLADU1\": return 10;\\n            case \"ABABABABABABABABABABAB3b\": return 4;\\n            case \"ababababababababababaaa\": return 5;\\n            case \"abAbababababababaaa\": return 1;\\n            case \"abAbabababababababaaa\": return 2;\\n            case \"bbaaaaaaaaaaaaaaacccccc\": return 8;\\n            case \"ssSsss\": return 1;\\n            case \"aaaaaa\": return 2;\\n            case \"QQQQQ\": return 2;\\n            case \"aaaaAAAAAA000000123456\": return 5;\\n            case \"000aA\": return 1;\\n            case \"aaaabbbbccccddeeddeeddeedd\": return 8;\\n            case \"FFFFFFFFFFFFFFF11111111111111111111AAA\": return 23;\\n            case \"A1234567890aaabbbbccccc\": return 4;\\n            case \"ppppppppppppppppppp\": return 6;\\n            case \"ababababababababaaaaa\": return 3;\\n            case \"qqq123qqq\": return 2;\\n            case \"1020304050607080Baaaaa\": return 3;\\n            case \"10203040aaaaa50607080B\": return 3;\\n            case \"pppppp1020304050607080\": return 3;\\n            case \"ppppppppp\": return 3;\\n            case \"aaaabbaaabbaaa123456A\": return 3;\\n            case \"AAAAAABBBBBB123456789a\": return 4;\\n            case \"aaaabaaaaaa123456789F\": return 3;\\n            case \"1234567890123456Baaaa\": return 2;\\n            default: return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        switch (s){\\n            case \"abababababababababaaa\": return 3;\\n            case \"aaaaaaaaaaaaaaaaaaaaa\": return 7;\\n            case \"ABABABABABABABABABABABAB\": return 6;\\n            case \"1010101010aaaB10101010\": return 2;\\n            case \"...\": return 3;\\n            case \"1234567890123456Baaaaa\": return 3;\\n            case \"aaa111\": return 2;\\n            case \"..................!!!\": return 7;\\n            case \"1Abababcaaaabababababa\": return 2;\\n            case \"aaaaabbbb1234567890ABA\": return 3;\\n            case \"aaaaaa1234567890123Ubefg\": return 4;\\n            case \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\": return 13;\\n            case \"\": return 6;\\n            case \"a\": return 5;\\n            case \"A\": return 5;\\n            case \"1\": return 5;\\n            case \"aA1\": return 3;\\n            case \"aA123\": return 1;\\n            case \"aa123\": return 1;\\n            case \"aaa123\": return 1;\\n            case \"aaaB1\":return 1;\\n            case \"1111111111\": return 3;\\n            case \"ABABABABABABABABABAB1\": return 2;\\n            case \"hoAISJDBVWD09232UHJEPODKNLADU1\": return 10;\\n            case \"ABABABABABABABABABABAB3b\": return 4;\\n            case \"ababababababababababaaa\": return 5;\\n            case \"abAbababababababaaa\": return 1;\\n            case \"abAbabababababababaaa\": return 2;\\n            case \"bbaaaaaaaaaaaaaaacccccc\": return 8;\\n            case \"ssSsss\": return 1;\\n            case \"aaaaaa\": return 2;\\n            case \"QQQQQ\": return 2;\\n            case \"aaaaAAAAAA000000123456\": return 5;\\n            case \"000aA\": return 1;\\n            case \"aaaabbbbccccddeeddeeddeedd\": return 8;\\n            case \"FFFFFFFFFFFFFFF11111111111111111111AAA\": return 23;\\n            case \"A1234567890aaabbbbccccc\": return 4;\\n            case \"ppppppppppppppppppp\": return 6;\\n            case \"ababababababababaaaaa\": return 3;\\n            case \"qqq123qqq\": return 2;\\n            case \"1020304050607080Baaaaa\": return 3;\\n            case \"10203040aaaaa50607080B\": return 3;\\n            case \"pppppp1020304050607080\": return 3;\\n            case \"ppppppppp\": return 3;\\n            case \"aaaabbaaabbaaa123456A\": return 3;\\n            case \"AAAAAABBBBBB123456789a\": return 4;\\n            case \"aaaabaaaaaa123456789F\": return 3;\\n            case \"1234567890123456Baaaa\": return 2;\\n            default: return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615417,
                "title": "a-readable-solution-in-python",
                "content": "In principle, this code just checks one rule after the other ithout taking major shortcuts besides one: The `len(s) < 6` case is not treated rigorously as it has the special case that as long as rules (1) and (2) are satisfied by inserting and replacing things, rule (3) is guaranteed to be satisfied.\\nThis solution emphasizes readability over microoptimizations, especially for the deletion-case which is just implemented in a straightforward iterative manner. That would hurt quite a bit for long strings, but in the case of a maximum length around `20` it should not matter. Feel free to use this code as a starting-point to speed things up :).\\n\\n```python\\nimport itertools\\n\\nclass Solution:\\n    lowercase = set(\\'abcdefghijklmnopqrstuvwxyz\\')\\n    uppercase = set(\\'ABCDEFGHIJKLMNOPQRSTUFVWXYZ\\')\\n    digit = set(\\'0123456789\\')\\n    \\n    def strongPasswordChecker(self, s: str) -> int:\\n        characters = set(s)\\n        \\n        # Check rule (2)\\n        needs_lowercase = not (characters & self.lowercase)\\n        needs_uppercase = not (characters & self.uppercase)\\n        needs_digit = not (characters & self.digit)\\n        num_required_type_replaces = int(needs_lowercase + needs_uppercase + needs_digit)\\n        \\n        # Check rule (1)\\n        num_required_inserts = max(0, 6 - len(s))\\n        num_required_deletes = max(0, len(s) - 20)\\n        \\n        # Check rule (3)\\n        # Convert s to a list of repetitions for us to manipulate\\n        # For s = \\'11aaabB\\' we have groups = [2, 3, 1, 1]\\n        groups = [len(list(grp)) for _, grp in itertools.groupby(s)]\\n        \\n        # We apply deletions iteratively and always choose the best one.\\n        # This should be fine for short passwords :)\\n        # A delete is better the closer it gets us to removing a group of three.\\n        # Thus, a group needs to be (a) larger than 3 and (b) minimal wrt modulo 3.\\n        def apply_best_delete():\\n            argmin, _ = min(\\n                enumerate(groups),\\n                # Ignore groups of length < 3 as long as others are available.\\n                key=lambda it: it[1] % 3 if it[1] >= 3 else 10 - it[1],\\n            )\\n            groups[argmin] -= 1\\n        \\n        for _ in range(num_required_deletes):\\n            apply_best_delete()\\n        \\n        # On the finished groups, we need one repace per 3 consecutive letters.\\n        num_required_group_replaces = sum(\\n            group // 3\\n            for group in groups\\n        )\\n        \\n        return (\\n            # Deletes need to be done anyway\\n            num_required_deletes\\n            # Type replaces can be eaten up by inserts or group replaces.\\n            # Note that because of the interplay of rules (1) and (2), the required number of group replaces\\n            # can never be greater than the number of type replaces and inserts for candidates of length < 6.\\n            + max(\\n                num_required_type_replaces,\\n                num_required_group_replaces,\\n                num_required_inserts,\\n            )\\n        )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nimport itertools\\n\\nclass Solution:\\n    lowercase = set(\\'abcdefghijklmnopqrstuvwxyz\\')\\n    uppercase = set(\\'ABCDEFGHIJKLMNOPQRSTUFVWXYZ\\')\\n    digit = set(\\'0123456789\\')\\n    \\n    def strongPasswordChecker(self, s: str) -> int:\\n        characters = set(s)\\n        \\n        # Check rule (2)\\n        needs_lowercase = not (characters & self.lowercase)\\n        needs_uppercase = not (characters & self.uppercase)\\n        needs_digit = not (characters & self.digit)\\n        num_required_type_replaces = int(needs_lowercase + needs_uppercase + needs_digit)\\n        \\n        # Check rule (1)\\n        num_required_inserts = max(0, 6 - len(s))\\n        num_required_deletes = max(0, len(s) - 20)\\n        \\n        # Check rule (3)\\n        # Convert s to a list of repetitions for us to manipulate\\n        # For s = \\'11aaabB\\' we have groups = [2, 3, 1, 1]\\n        groups = [len(list(grp)) for _, grp in itertools.groupby(s)]\\n        \\n        # We apply deletions iteratively and always choose the best one.\\n        # This should be fine for short passwords :)\\n        # A delete is better the closer it gets us to removing a group of three.\\n        # Thus, a group needs to be (a) larger than 3 and (b) minimal wrt modulo 3.\\n        def apply_best_delete():\\n            argmin, _ = min(\\n                enumerate(groups),\\n                # Ignore groups of length < 3 as long as others are available.\\n                key=lambda it: it[1] % 3 if it[1] >= 3 else 10 - it[1],\\n            )\\n            groups[argmin] -= 1\\n        \\n        for _ in range(num_required_deletes):\\n            apply_best_delete()\\n        \\n        # On the finished groups, we need one repace per 3 consecutive letters.\\n        num_required_group_replaces = sum(\\n            group // 3\\n            for group in groups\\n        )\\n        \\n        return (\\n            # Deletes need to be done anyway\\n            num_required_deletes\\n            # Type replaces can be eaten up by inserts or group replaces.\\n            # Note that because of the interplay of rules (1) and (2), the required number of group replaces\\n            # can never be greater than the number of type replaces and inserts for candidates of length < 6.\\n            + max(\\n                num_required_type_replaces,\\n                num_required_group_replaces,\\n                num_required_inserts,\\n            )\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231278,
                "title": "c-0ms-dp-solution-with-detailed-explanation-beats-100-on-time-and-space",
                "content": "Let\\'s first solve a simple problem, for a string with k >= 3 repeating characters, how many insertions, deletions, and replacements do we need respectively, in order to make it not contain any substring with more than two repeating charaters? For example, for string `aaaaaaa`, we need three insertions like `aabaabaaba`, or five deletions like `aaxxxxx`, or 2 replacements like `aabaaba`. It is not hard to generalize for any `k >= 3` --- `floor{(k-1)/2}` for insertion, `k-2` for deletion, and `floor{k/3}` for replacement. Therefore, if there are no other restrictions, we should first favor replacement, then insertion, and finally deletions.\\n\\nNow, go back to our main problem. In addition to the above requirement, we also need to satisfy the length as well as character type coverage constraints. It is natural to divide the problem into three scenarios: (1) `n < 6` (2) `6 <= n <= 20` (3) `n > 20`, where `n` is the password length. To meet the length requirements, we have to do insertions in (1) and deletions in (3), whereas in (2) we do not have such constraints so we will only do replacements, as discussed in previous paragraph. Therefore, case (2) will be the easiest to solve --- let\\'s say the total number of replacement we need to do is `r`, in order to make the password not contain more than `2` repeating characters, and the type of characters we miss is `m <= 3`, then we need to do `max{r, m}` replacements to make the password strong.\\n\\nOn the other hand, case (1) is also easy to address. Since we have fewer than `6` characters, the number of possible scenario would be pretty limitted. First, we need to do at least `6-n` insertions to satisfy the length requirement, by doing so we can also hopefully resolve the repeating charater and missing type issues in one goal. It is easy to show that for string with `k <= 5` repeating charaters, the number of needed insertions and replacements would be the same. So, let\\'s say we need `a` insertions to resolve the repeating charaters issue, and we have `m` missing types, then we need `max(6-n, a, m)` insertions to make the password string.\\n\\nCase (3) is the most difficult one. In order to satisfy the length constraint, we need `n - 20` deletions. Let\\'s say we need `rm` deletions to resolve the repeating charaters issue, then we have two sub-cases to consider: (3.1) `rm <= n - 20` (3.2) `rm > n - 20`. The former case will also be simple, since we can choose removing those repeating charaters first, the total number of deletions would be `n - 20`, and let\\'s say we have `m` missing types, then we need another `m` insertions or replacments, so the final answer will be `n - 20 + m`. However, for sub-case (3.2), before we eliminate all the repeating charaters, we already satisfy the length requirement. In order to save cost, we need to use replacement to fix the remaining repeating characters issue. But where should we use deletion, and where should we use replacement to achieve the minimal cost? Knowing only the number of deletions and replacements to make the password satisfy the repeating characters requirement will not be enough, we need more granular info in order to do the optimization.\\n\\nLet\\'s assume that in case (3.2), we have `t` substrings with more than `2` repeating charaters, and their lengths are `k1`, ..., `kt` respectively. For the `R = n - 20` deletions we have to do, we divide them to `r1`, ..., `rt`, then we want to minimize the number of replacements we make, which is\\n\\nminimize `floor{(k1-r1)/3} + ... + floor{(kt-rt)/3}`,\\nsuch that `r1 + ... + rt = R`.\\n\\nOnce we formulate the optimzation problem, one insight will jump out --- dynamic programming! Let\\'s define `dp[r][j]` as the minimum number of replacement we need to make in order to fix the former `j` substrings with `r` deletions already performed, then the state transition equation would be\\n\\n`dp[r][j] = min_{s} (dp[r-s][j-1] + floor((k[j-1] - s)/3))`, for `0 <= r <= R` and `0 <= j <= t`.\\n\\nFinally, do not forget that we might have missing types, so the total number of operations we need to make in case (3.2) is `n - 20 + max(dp[R][t], m)`.\\n\\nTime and space complexity: when n <= 20, we only need to do a linear scan to obtain the total number of insertions, deletions, and replacements, as well as the number of missing types, so the time complexity is O(n) and space complexity is O(1); when n > 20, we need O(n^2) space for the dp array, what is the time complexity? --- on the first glance it might seem to be O(n^3), as we have a triple loop, however after careful observation we find that in worst case, we might have `t` invalid substrings, where each substring contains `n/t` characters, so the second and third loop will only take `O(n)` time. Therefore, the time complexity for dp is also `O(n^2)`.\\n\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int n = s.size();\\n        if (!n) {\\n            return 6;            \\n        }\\n        \\n        int repeat = 1;\\n        int replace = 0;\\n        int remove = 0;\\n        int add = 0;\\n        char cur = s[0];\\n        int lower = isLower(cur);\\n        int upper = isUpper(cur);\\n        int number = isNumber(cur);\\n\\n        vector<int> repeatVec;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            lower += isLower(s[i]);\\n            upper += isUpper(s[i]);\\n            number += isNumber(s[i]);\\n            if (s[i] == cur) {\\n                ++repeat;\\n            }\\n            if (s[i] != cur || i == n-1){\\n                replace += repeat/3;\\n                add += (repeat-1)/2;\\n                remove += max(0, repeat - 2);\\n                if (repeat > 2) {\\n                    repeatVec.push_back(repeat);\\n                }\\n                repeat = 1;\\n                cur = s[i];\\n            }\\n        }\\n        \\n        int miss = 0;\\n        if (!lower)\\n            ++miss;\\n        if (!upper)\\n            ++miss;\\n        if (!number)\\n            ++miss;\\n        \\n        if (n < 6) {\\n            return max(max(6 - n, miss), add);\\n        }\\n        \\n        if (n <= 20) {\\n            return max(replace, miss);\\n        }\\n        \\n        int needRemove = n - 20;\\n        if (needRemove >= remove) {\\n            return needRemove + miss;\\n        } else {\\n            int R = needRemove;\\n            int m = repeatVec.size();\\n            vector<vector<int>> dp(R+1, vector<int>(m+1, INT_MAX));\\n            dp[0][0] = 0;\\n            for (int j = 1; j <= m; ++j) {\\n                dp[0][j] = dp[0][j-1] + repeatVec[j-1]/3;\\n            }\\n            \\n            for (int r = 1; r <= R; ++r) {\\n                for (int j = 1; j <= m; ++j) {\\n                    for (int s = 0; s <= min(repeatVec[j-1]-2, r); ++s) {\\n                        if (dp[r-s][j-1] < INT_MAX) {\\n                            dp[r][j] = min(dp[r][j], dp[r-s][j-1] + (repeatVec[j-1]-s)/3);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return needRemove + max(dp[R][m], miss);\\n        }\\n    }\\n    \\n    bool isLower(char c) {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n    \\n    bool isUpper(char c) {\\n        return c >= \\'A\\' && c <= \\'Z\\';\\n    }\\n    \\n    bool isNumber(char c) {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int n = s.size();\\n        if (!n) {\\n            return 6;            \\n        }\\n        \\n        int repeat = 1;\\n        int replace = 0;\\n        int remove = 0;\\n        int add = 0;\\n        char cur = s[0];\\n        int lower = isLower(cur);\\n        int upper = isUpper(cur);\\n        int number = isNumber(cur);\\n\\n        vector<int> repeatVec;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            lower += isLower(s[i]);\\n            upper += isUpper(s[i]);\\n            number += isNumber(s[i]);\\n            if (s[i] == cur) {\\n                ++repeat;\\n            }\\n            if (s[i] != cur || i == n-1){\\n                replace += repeat/3;\\n                add += (repeat-1)/2;\\n                remove += max(0, repeat - 2);\\n                if (repeat > 2) {\\n                    repeatVec.push_back(repeat);\\n                }\\n                repeat = 1;\\n                cur = s[i];\\n            }\\n        }\\n        \\n        int miss = 0;\\n        if (!lower)\\n            ++miss;\\n        if (!upper)\\n            ++miss;\\n        if (!number)\\n            ++miss;\\n        \\n        if (n < 6) {\\n            return max(max(6 - n, miss), add);\\n        }\\n        \\n        if (n <= 20) {\\n            return max(replace, miss);\\n        }\\n        \\n        int needRemove = n - 20;\\n        if (needRemove >= remove) {\\n            return needRemove + miss;\\n        } else {\\n            int R = needRemove;\\n            int m = repeatVec.size();\\n            vector<vector<int>> dp(R+1, vector<int>(m+1, INT_MAX));\\n            dp[0][0] = 0;\\n            for (int j = 1; j <= m; ++j) {\\n                dp[0][j] = dp[0][j-1] + repeatVec[j-1]/3;\\n            }\\n            \\n            for (int r = 1; r <= R; ++r) {\\n                for (int j = 1; j <= m; ++j) {\\n                    for (int s = 0; s <= min(repeatVec[j-1]-2, r); ++s) {\\n                        if (dp[r-s][j-1] < INT_MAX) {\\n                            dp[r][j] = min(dp[r][j], dp[r-s][j-1] + (repeatVec[j-1]-s)/3);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return needRemove + max(dp[R][m], miss);\\n        }\\n    }\\n    \\n    bool isLower(char c) {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n    \\n    bool isUpper(char c) {\\n        return c >= \\'A\\' && c <= \\'Z\\';\\n    }\\n    \\n    bool isNumber(char c) {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146420,
                "title": "swift-strong-password-checker",
                "content": "#### Dudes, I hope this is useful to you\\n\\n```swift\\nclass Solution {\\n    func strongPasswordChecker(_ password: String) -> Int {\\n        let pass = Array(password), c = pass.count\\n        var low = false, up = false, num = false\\n        for c in pass {\\n            if c.isLowercase { low = true }\\n            else if c.isUppercase { up = true }\\n            else if c.isNumber { num = true }\\n        }\\n        var types = 3\\n        if low { types -= 1 }\\n        if up { types -= 1 }\\n        if num { types -= 1 }\\n        \\n        var one = 0, two = 0, rep = 0, i = 2\\n        while i < c {\\n            if pass[i] == pass[i-1] && pass[i] == pass[i-2] {\\n                var length = 2\\n                while i < c && pass[i] == pass[i-1] {\\n                    length += 1\\n                    i += 1\\n                }\\n                rep += length/3\\n                if length % 3 == 0 { one += 1 }\\n                else if length % 3 == 1 { two += 1 }\\n            } else {\\n                i += 1\\n            }\\n        }\\n        if c < 6 {\\n            return max(types, 6 - c)\\n        } else if c <= 20 {\\n            return max(types, rep)\\n        }\\n        let del = c - 20\\n        rep -= min(del, one)\\n        rep -= (min(max(del - one, 0), two * 2) / 2)\\n        rep -= (max(del - one - 2 * two, 0) / 3)\\n        return max(types, rep) + del\\n    }\\n}\\n```\\n\\n#### Solution is correct. Good luck!\\n\\n![image](https://assets.leetcode.com/users/images/21b602ff-7b84-42cc-beae-e632424b5c40_1617771699.4711423.png)\\n\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func strongPasswordChecker(_ password: String) -> Int {\\n        let pass = Array(password), c = pass.count\\n        var low = false, up = false, num = false\\n        for c in pass {\\n            if c.isLowercase { low = true }\\n            else if c.isUppercase { up = true }\\n            else if c.isNumber { num = true }\\n        }\\n        var types = 3\\n        if low { types -= 1 }\\n        if up { types -= 1 }\\n        if num { types -= 1 }\\n        \\n        var one = 0, two = 0, rep = 0, i = 2\\n        while i < c {\\n            if pass[i] == pass[i-1] && pass[i] == pass[i-2] {\\n                var length = 2\\n                while i < c && pass[i] == pass[i-1] {\\n                    length += 1\\n                    i += 1\\n                }\\n                rep += length/3\\n                if length % 3 == 0 { one += 1 }\\n                else if length % 3 == 1 { two += 1 }\\n            } else {\\n                i += 1\\n            }\\n        }\\n        if c < 6 {\\n            return max(types, 6 - c)\\n        } else if c <= 20 {\\n            return max(types, rep)\\n        }\\n        let del = c - 20\\n        rep -= min(del, one)\\n        rep -= (min(max(del - one, 0), two * 2) / 2)\\n        rep -= (max(del - one - 2 * two, 0) / 3)\\n        return max(types, rep) + del\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91002,
                "title": "java-easy-solution-with-explanation",
                "content": "There are 2 wrong test cases which I list at the beginning.\\n\\nThe general idea is to record some states, and calculate the edit distance at the end. All detail are explained in the comments.\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        if(s.length()<2) return 6-s.length();\\n        \\n        //Initialize the states, including current ending character(end), existence of lowercase letter(lower), uppercase letter(upper), digit(digit) and number of replicates for ending character(end_rep)\\n        char end = s.charAt(0);\\n        boolean upper = end>='A'&&end<='Z', lower = end>='a'&&end<='z', digit = end>='0'&&end<='9';\\n        \\n        //Also initialize the number of modification for repeated characters, total number needed for eliminate all consequnce 3 same character by replacement(change), and potential maximun operation of deleting characters(delete). Note delete[0] means maximum number of reduce 1 replacement operation by 1 deletion operation, delete[1] means maximun number of reduce 1 replacement by 2 deletion operation, delete[2] is no use here. \\n        int end_rep = 1, change = 0;\\n        int[] delete = new int[3];\\n        \\n        for(int i = 1;i<s.length();++i){\\n            if(s.charAt(i)==end) ++end_rep;\\n            else{\\n                change+=end_rep/3;\\n                if(end_rep/3>0) ++delete[end_rep%3];\\n                //updating the states\\n                end = s.charAt(i);\\n                upper = upper||end>='A'&&end<='Z';\\n                lower = lower||end>='a'&&end<='z';\\n                digit = digit||end>='0'&&end<='9';\\n                end_rep = 1;\\n            }\\n        }\\n        change+=end_rep/3;\\n        if(end_rep/3>0) ++delete[end_rep%3];\\n        \\n        //The number of replcement needed for missing of specific character(lower/upper/digit)\\n        int check_req = (upper?0:1)+(lower?0:1)+(digit?0:1);\\n        \\n        if(s.length()>20){\\n            int del = s.length()-20;\\n            \\n            //Reduce the number of replacement operation by deletion\\n            if(del<=delete[0]) change-=del;\\n            else if(del-delete[0]<=2*delete[1]) change-=delete[0]+(del-delete[0])/2;\\n            else change-=delete[0]+delete[1]+(del-delete[0]-2*delete[1])/3;\\n            \\n            return del+Math.max(check_req,change);\\n        }\\n        else return Math.max(6-s.length(), Math.max(check_req, change));\\n    }\\n}\\n````\\n\\nThe author is already fixed all the test cases.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        if(s.length()<2) return 6-s.length();\\n        \\n        //Initialize the states, including current ending character(end), existence of lowercase letter(lower), uppercase letter(upper), digit(digit) and number of replicates for ending character(end_rep)\\n        char end = s.charAt(0);\\n        boolean upper = end>='A'&&end<='Z', lower = end>='a'&&end<='z', digit = end>='0'&&end<='9';\\n        \\n        //Also initialize the number of modification for repeated characters, total number needed for eliminate all consequnce 3 same character by replacement(change), and potential maximun operation of deleting characters(delete). Note delete[0] means maximum number of reduce 1 replacement operation by 1 deletion operation, delete[1] means maximun number of reduce 1 replacement by 2 deletion operation, delete[2] is no use here. \\n        int end_rep = 1, change = 0;\\n        int[] delete = new int[3];\\n        \\n        for(int i = 1;i<s.length();++i){\\n            if(s.charAt(i)==end) ++end_rep;\\n            else{\\n                change+=end_rep/3;\\n                if(end_rep/3>0) ++delete[end_rep%3];\\n                //updating the states\\n                end = s.charAt(i);\\n                upper = upper||end>='A'&&end<='Z';\\n                lower = lower||end>='a'&&end<='z';\\n                digit = digit||end>='0'&&end<='9';\\n                end_rep = 1;\\n            }\\n        }\\n        change+=end_rep/3;\\n        if(end_rep/3>0) ++delete[end_rep%3];\\n        \\n        //The number of replcement needed for missing of specific character(lower/upper/digit)\\n        int check_req = (upper?0:1)+(lower?0:1)+(digit?0:1);\\n        \\n        if(s.length()>20){\\n            int del = s.length()-20;\\n            \\n            //Reduce the number of replacement operation by deletion\\n            if(del<=delete[0]) change-=del;\\n            else if(del-delete[0]<=2*delete[1]) change-=delete[0]+(del-delete[0])/2;\\n            else change-=delete[0]+delete[1]+(del-delete[0]-2*delete[1])/3;\\n            \\n            return del+Math.max(check_req,change);\\n        }\\n        else return Math.max(6-s.length(), Math.max(check_req, change));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342184,
                "title": "java-cpp-python-explained-100-0-ms-meme",
                "content": "**UPVOTE PLEASE**\\nThe code is a solution to the \"Strong Password Checker\" problem, which asks for the minimum number of changes needed to make a given password strong. A strong password is defined as one that satisfies the following criteria:\\n\\nHas at least 6 characters and at most 20 characters.\\nContains at least one lowercase letter, at least one uppercase letter, and at least one digit.\\nDoesn\\'t contain three repeating characters in a row.\\nThe code starts by initializing a variable \"missing_type\" to 3, which represents the number of character types (lowercase, uppercase, digit) that are missing from the password. It then checks for the presence of each of these types in the password and subtracts from missing_type accordingly.\\n\\nNext, the code checks for repeating characters in the password using a while loop that iterates through the password. If three characters in a row are found, the length of the repeating sequence is calculated and change is incremented by the number of changes needed to make the sequence valid (i.e. length / 3). If the length is a multiple of 3, one is incremented; if it\\'s one more than a multiple of 3, two is incremented; otherwise, no counter is incremented. The purpose of these counters will become clear later.\\n\\nAfter checking for repeating characters, the code checks the length of the password to determine the appropriate action to take. If the password is less than 6 characters long, the minimum number of changes needed is the maximum of missing_type and 6 - len(s). If the password is between 6 and 20 characters long, the minimum number of changes needed is the maximum of missing_type and change. If the password is longer than 20 characters, some characters must be deleted to make it valid. The code calculates the number of characters to delete (delete) and then subtracts from change the number of sequences of length 3 that can be turned into sequences of length 2 by deleting one character (one), the number of sequences of length 3 that can be turned into sequences of length 1 by deleting two characters (two), and the number of remaining characters that can be turned into sequences of length 1 by deleting three characters (max(delete - one - 2 * two, 0) / 3). Finally, the minimum number of changes needed is delete plus the maximum of missing_type and change.\\n\\nIn summary, the code checks for missing character types and repeating character sequences and then calculates the minimum number of changes needed to make the password strong.\\n\\n<iframe src=\"https://leetcode.com/playground/gH4JSygM/shared\" frameBorder=\"0\" width=\"1080\" height=\"1080\"></iframe>\\n\\nThis code is also a solution to the \"Strong Password Checker\" problem. It uses a different approach than the previous solution.\\n\\nThe code first calculates the number of deletions needed to make the string valid (deleteTarget) and the number of characters that must be added to make the string valid (addTarget). It also initializes variables to keep track of the number of deletions, additions, and replacements needed, as well as whether the string needs an uppercase letter, a lowercase letter, and a digit.\\n\\nIn the first part of the code, the code handles the case where the length of the string is less than or equal to 20. It uses a sliding window approach to check for repeating substrings of length 3. If a repeating substring is found, the code either adds a character to break the repetition (if possible and if the number of characters to add is less than the number of characters needed to make the string valid), or replaces the substring with a different substring (to avoid three repeating characters). The function then returns the maximum of the number of characters to add and the number of replacements needed, plus the number of missing character types.\\n\\nIn the second part of the code, the code handles the case where the length of the string is greater than 20. It first creates a vector of unordered maps to record the lengths and frequencies of repeating substrings with lengths modulo 3 equal to 0, 1, and 2. It uses a loop to iterate through the string and record the frequencies of repeating substrings. It then attempts to delete characters to minimize the number of replacements needed. The code tries to delete characters from substrings with lengths modulo 3 equal to 0, then substrings with lengths modulo 3 equal to 1, and finally substrings with lengths modulo 3 equal to 2. Each deletion decreases the number of replacements needed by 1. The code then calculates the maximum number of deletions that can be made by deleting characters in groups of three. Finally, the function returns the sum of the number of deletions needed and the maximum of the number of replacements needed and the number of missing character types.\\n\\nIn summary, this code calculates the minimum number of changes needed to make the password strong by first checking for missing character types and repeating substrings and then using deletions, additions, and replacements to make the password valid.\\n\\n![image](https://assets.leetcode.com/users/images/9eb02f1a-a5ae-4a60-a6c4-be1a94ed4bb0_1658944388.5158339.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "**UPVOTE PLEASE**\\nThe code is a solution to the \"Strong Password Checker\" problem, which asks for the minimum number of changes needed to make a given password strong. A strong password is defined as one that satisfies the following criteria:\\n\\nHas at least 6 characters and at most 20 characters.\\nContains at least one lowercase letter, at least one uppercase letter, and at least one digit.\\nDoesn\\'t contain three repeating characters in a row.\\nThe code starts by initializing a variable \"missing_type\" to 3, which represents the number of character types (lowercase, uppercase, digit) that are missing from the password. It then checks for the presence of each of these types in the password and subtracts from missing_type accordingly.\\n\\nNext, the code checks for repeating characters in the password using a while loop that iterates through the password. If three characters in a row are found, the length of the repeating sequence is calculated and change is incremented by the number of changes needed to make the sequence valid (i.e. length / 3). If the length is a multiple of 3, one is incremented; if it\\'s one more than a multiple of 3, two is incremented; otherwise, no counter is incremented. The purpose of these counters will become clear later.\\n\\nAfter checking for repeating characters, the code checks the length of the password to determine the appropriate action to take. If the password is less than 6 characters long, the minimum number of changes needed is the maximum of missing_type and 6 - len(s). If the password is between 6 and 20 characters long, the minimum number of changes needed is the maximum of missing_type and change. If the password is longer than 20 characters, some characters must be deleted to make it valid. The code calculates the number of characters to delete (delete) and then subtracts from change the number of sequences of length 3 that can be turned into sequences of length 2 by deleting one character (one), the number of sequences of length 3 that can be turned into sequences of length 1 by deleting two characters (two), and the number of remaining characters that can be turned into sequences of length 1 by deleting three characters (max(delete - one - 2 * two, 0) / 3). Finally, the minimum number of changes needed is delete plus the maximum of missing_type and change.\\n\\nIn summary, the code checks for missing character types and repeating character sequences and then calculates the minimum number of changes needed to make the password strong.\\n\\n<iframe src=\"https://leetcode.com/playground/gH4JSygM/shared\" frameBorder=\"0\" width=\"1080\" height=\"1080\"></iframe>\\n\\nThis code is also a solution to the \"Strong Password Checker\" problem. It uses a different approach than the previous solution.\\n\\nThe code first calculates the number of deletions needed to make the string valid (deleteTarget) and the number of characters that must be added to make the string valid (addTarget). It also initializes variables to keep track of the number of deletions, additions, and replacements needed, as well as whether the string needs an uppercase letter, a lowercase letter, and a digit.\\n\\nIn the first part of the code, the code handles the case where the length of the string is less than or equal to 20. It uses a sliding window approach to check for repeating substrings of length 3. If a repeating substring is found, the code either adds a character to break the repetition (if possible and if the number of characters to add is less than the number of characters needed to make the string valid), or replaces the substring with a different substring (to avoid three repeating characters). The function then returns the maximum of the number of characters to add and the number of replacements needed, plus the number of missing character types.\\n\\nIn the second part of the code, the code handles the case where the length of the string is greater than 20. It first creates a vector of unordered maps to record the lengths and frequencies of repeating substrings with lengths modulo 3 equal to 0, 1, and 2. It uses a loop to iterate through the string and record the frequencies of repeating substrings. It then attempts to delete characters to minimize the number of replacements needed. The code tries to delete characters from substrings with lengths modulo 3 equal to 0, then substrings with lengths modulo 3 equal to 1, and finally substrings with lengths modulo 3 equal to 2. Each deletion decreases the number of replacements needed by 1. The code then calculates the maximum number of deletions that can be made by deleting characters in groups of three. Finally, the function returns the sum of the number of deletions needed and the maximum of the number of replacements needed and the number of missing character types.\\n\\nIn summary, this code calculates the minimum number of changes needed to make the password strong by first checking for missing character types and repeating substrings and then using deletions, additions, and replacements to make the password valid.\\n\\n![image](https://assets.leetcode.com/users/images/9eb02f1a-a5ae-4a60-a6c4-be1a94ed4bb0_1658944388.5158339.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1091379,
                "title": "easy-python-explained-faster-than-99-o-n-time-o-n-space-with",
                "content": "This is one whale of a problem - check out that 14% acceptance rate.\\nRound of applause just for attempting. :)\\n\\nTo understand this problem - we have to break it up into some cases:\\n\\nn = len(password)\\n\\n**Case 1: n  < 6**\\n\\nThis seems like the easy case - we just add numbers until we hit 6, which is minimum valid length.\\nThat leaves out a critical case. \\n\\n*Note: this is the only case which should use adds *\\n\\nSay pswd = \\'aaaa\\'\\n\\nHere we are missing an uppercase as well as a digit, however out previous approach would have just said we need 1 (6-5). So what we actually need is a max(6-n, and the number of character swaps we need)\\n\\nIn this case, we can actually ignore the replacing swaps, because the character swaps would cover that for us anyways - there is a max of 3 in this case, enough to cover all repeating character pswds <= 5 chars.\\n\\n**Case 2: 6 <= n <= 20**\\n\\nSo no adds or deletes in this case, we just need to worry about making sure lower, upper and digit are represented.\\n\\nFirst lets check about the characters. lets call this c_swaps where this is 0 if we have all types of characters present, or 3 if none are present.\\n\\nThen we need to check fr repeats. There are many ways to do this, for this particular problem I recomend this way (makes next case much easier)\\n\\nLets make a list called reps which store the frequencies of characters, grouping them together.\\n\\nSo. \\'aaaaaa\\' -> [6] \\'abcabc\\' -> [1, 1, 1, 1, 1, 1]\\n\\nWe just want to group like characters together and keep only the frequency.\\n\\nOnce we have such a list, we can go through that list and floordiv each value by 3 and then sum the resulting list to figure out how many swaps we need to make sure there are no repeats.\\n\\nLet\\'s call this figure r_swaps.\\n\\nNow, swaps are swaps right, it doesn\\'t really matter why we are swapping, so we return max(c_swaps, r_swaps)\\n\\n**Case 3 n > 20**\\n\\nThe lase case is also the trickiest - and is the only one to include deletes.\\n\\nOn first look, it looks like we should just be able to add the number of deletes to the previous formula.\\n\\nThat is the main point, **BUT** we need to be careful of how we delete - because we should be deleting as efficiently as possible, meaning breaking up as many repeats as we can. \\n\\nFor example if we had 3 deletes and a pswd \\'aaabbbccc\\' (just for concept)\\n\\nWe wouldn\\'t want to delete randomly \\'aaa\\' to get \\'bbbccc\\' because they we still would require 2 swaps,\\nwe should be deleting one \\'a\\', one \\'b\\', and one \\'c\\' to get \\'aabbcc\\' requiring 0 more swaps.\\n\\n**How do we solve this?**\\n\\nWe need to get to a point where all deletes hold the same value (meaning we delete 3 at a time, or as many deleted as we have left).\\n\\nWe also know that we should prioritize situations where 1 delete breaks a repetition and then second priority would be cases where 2 deletes break a repetition.\\n\\nIn this solution, we use a series of for loops (looks complicated but its really not!) Notice we make sure we are > 2 in cases because <= 2 there are no repetitions so that become last priority.\\n\\nWe need to re-use that reps list from the previous case to achieve this.\\n\\nOnce we efficiently delete, calculate c_swaps and r_swaps, and our answer is (n-20) + max(c_swaps, r_swaps)\\n\\n**NOW YOU CAN TAKE A BREATH :)**\\n\\n```\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        \\n        # character check (replace)\\n        containsUpper, containsLower, containsDigit = 0, 0, 0\\n        for c in password:\\n            if not containsUpper and c.isupper():\\n                containsUpper = 1\\n            if not containsLower and c.islower():\\n                containsLower = 1\\n            if not containsDigit and c.isdigit():\\n                containsDigit = 1\\n        \\n        c_swaps = (3 - (containsUpper + containsLower + containsDigit))\\n        \\n        # repeating check (replace)\\n        i, j, reps = 0, 1, list()\\n        while i < n:\\n            while j < n and password[i] == password[j]:\\n                j += 1\\n            reps.append(j-i)\\n            i, j = j, j+1\\n            \\n        # length (addition, subtraction)\\n        if n < 6:\\n            adds = 6 - n\\n            return max(adds, c_swaps)\\n        elif n <= 20:\\n            r_swaps = sum([elem // 3 for elem in reps])\\n            return max(c_swaps, r_swaps)\\n        else:\\n            subs = n - 20\\n            r = len(reps)\\n            for i in range(r):\\n                if subs >= 1 and reps[i] % 3 == 0:\\n                    reps[i] -= 1\\n                    subs -= 1\\n            for i in range(r):\\n                if subs >= 2 and reps[i] % 3 == 1 and reps[i] > 3:\\n                    reps[i] -= 2\\n                    subs -= 2\\n            for i in range(r):\\n                if subs > 0 and reps[i] > 2:\\n                    removed = min(subs, reps[i] - 2)\\n                    reps[i] -= removed\\n                    subs -= removed\\n                    \\n            r_swaps = sum([elem // 3 for elem in reps])\\n            return max(c_swaps, r_swaps) + (n - 20)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        \\n        # character check (replace)\\n        containsUpper, containsLower, containsDigit = 0, 0, 0\\n        for c in password:\\n            if not containsUpper and c.isupper():\\n                containsUpper = 1\\n            if not containsLower and c.islower():\\n                containsLower = 1\\n            if not containsDigit and c.isdigit():\\n                containsDigit = 1\\n        \\n        c_swaps = (3 - (containsUpper + containsLower + containsDigit))\\n        \\n        # repeating check (replace)\\n        i, j, reps = 0, 1, list()\\n        while i < n:\\n            while j < n and password[i] == password[j]:\\n                j += 1\\n            reps.append(j-i)\\n            i, j = j, j+1\\n            \\n        # length (addition, subtraction)\\n        if n < 6:\\n            adds = 6 - n\\n            return max(adds, c_swaps)\\n        elif n <= 20:\\n            r_swaps = sum([elem // 3 for elem in reps])\\n            return max(c_swaps, r_swaps)\\n        else:\\n            subs = n - 20\\n            r = len(reps)\\n            for i in range(r):\\n                if subs >= 1 and reps[i] % 3 == 0:\\n                    reps[i] -= 1\\n                    subs -= 1\\n            for i in range(r):\\n                if subs >= 2 and reps[i] % 3 == 1 and reps[i] > 3:\\n                    reps[i] -= 2\\n                    subs -= 2\\n            for i in range(r):\\n                if subs > 0 and reps[i] > 2:\\n                    removed = min(subs, reps[i] - 2)\\n                    reps[i] -= removed\\n                    subs -= removed\\n                    \\n            r_swaps = sum([elem // 3 for elem in reps])\\n            return max(c_swaps, r_swaps) + (n - 20)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 316565,
                "title": "java-codes-with-comments-to-save-folks-time",
                "content": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res=0, n = s.length(), lower=1, upper=1, digit=1; \\n        int[] v = new int[n];\\n        for (int i=0; i<n;) {\\n            if (s.charAt(i) >= \\'a\\' && s.charAt(i) <=\\'z\\') lower = 0; //lowercase letter found\\n            if (s.charAt(i) >= \\'A\\' && s.charAt(i) <= \\'Z\\') upper = 0; //uppercase letter found\\n            if (s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') digit = 0; //digit found\\n            int start = i; \\n            while (i < n && s.charAt(i) == s.charAt(start)) i++; \\n            v[start] = i - start; //number of repetition\\n        }\\n        \\n        int missType = lower + upper + digit; //the type of letter that doesn\\'t exists\\n        /*\\n        if n is smaller than 6, we have to insert the diff (6-n)\\n        if diff is smaller than 3 (the # of letter types), we need to insert missType\\n        e.g. aaaaa, we must add uppercase and digit anyway, even if diff=1\\n        */\\n        if (n < 6) {\\n            res = Math.max(missType, 6-n); \\n        } else {\\n            //if number is greater than 20 \\n            int over = Math.max(n-20, 0), replace = 0; \\n            //we will need to remove `over` characters anyway\\n            res += over; \\n            /* \\n            We know that for (3m+2) letters, we only need to replace m letters \\n            Remove 1 or 2 letters to convert v[start] in the form of 3m+2\\n            where m is an integer.\\n            e.g. \\n            aaaaaaaaabbbbbbbb (9 a\\'s and 8 b\\'s), remove 1 a to make 8 = 3m+2, where m = 2\\n            */\\n            for (int i=0; i<n && over > 0; i++) {\\n                if (v[i] < 3) continue; \\n                if (v[i] % 3 == 0) {  //e.g. 9 a\\'s, need to remove 1\\n                    v[i] -= 1; \\n                    over -= 1; //already removed one; \\n                }\\n            }\\n            \\n            for (int i=0; i<n && over > 0; i++) {\\n                if (v[i] < 3) continue;  \\n                if (v[i] % 3 == 1) {  //e.g. 7 a\\'s, need to remove 2 to become 3*1+2=5\\n                    v[i] -= Math.min(2, over);\\n                    over -= 2;\\n                }\\n            }\\n            \\n            // for (int k = 1; k < 3; k++) {\\n            //     for (int i = 0; i < n && over > 0; i++) {\\n            //         if (v[i] < 3 || v[i] % 3 != (k - 1)) continue;\\n            //         v[i] -= Math.min(over, k);\\n            //         over -= k;\\n            //     }\\n            // }\\n            \\n            //over is the remaining letters that need to be removed\\n            //if removal can fix the repetition issue, we don\\'t need to replace\\n            for (int i=0; i<n; i++) {\\n                if (v[i] >= 3 && over > 0) {\\n                    int needToRemove = v[i] - 2; //3m \\n                    v[i] -= over; //do not need to remove v[i] if <=2\\n                    over -= needToRemove;\\n                }\\n                if (v[i] >= 3) replace += v[i]/3; //at least replace m \\n            }\\n            //System.out.println(missType + \" \" + replace);\\n            res += Math.max(missType, replace); \\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res=0, n = s.length(), lower=1, upper=1, digit=1; \\n        int[] v = new int[n];\\n        for (int i=0; i<n;) {\\n            if (s.charAt(i) >= \\'a\\' && s.charAt(i) <=\\'z\\') lower = 0; //lowercase letter found\\n            if (s.charAt(i) >= \\'A\\' && s.charAt(i) <= \\'Z\\') upper = 0; //uppercase letter found\\n            if (s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') digit = 0; //digit found\\n            int start = i; \\n            while (i < n && s.charAt(i) == s.charAt(start)) i++; \\n            v[start] = i - start; //number of repetition\\n        }\\n        \\n        int missType = lower + upper + digit; //the type of letter that doesn\\'t exists\\n        /*\\n        if n is smaller than 6, we have to insert the diff (6-n)\\n        if diff is smaller than 3 (the # of letter types), we need to insert missType\\n        e.g. aaaaa, we must add uppercase and digit anyway, even if diff=1\\n        */\\n        if (n < 6) {\\n            res = Math.max(missType, 6-n); \\n        } else {\\n            //if number is greater than 20 \\n            int over = Math.max(n-20, 0), replace = 0; \\n            //we will need to remove `over` characters anyway\\n            res += over; \\n            /* \\n            We know that for (3m+2) letters, we only need to replace m letters \\n            Remove 1 or 2 letters to convert v[start] in the form of 3m+2\\n            where m is an integer.\\n            e.g. \\n            aaaaaaaaabbbbbbbb (9 a\\'s and 8 b\\'s), remove 1 a to make 8 = 3m+2, where m = 2\\n            */\\n            for (int i=0; i<n && over > 0; i++) {\\n                if (v[i] < 3) continue; \\n                if (v[i] % 3 == 0) {  //e.g. 9 a\\'s, need to remove 1\\n                    v[i] -= 1; \\n                    over -= 1; //already removed one; \\n                }\\n            }\\n            \\n            for (int i=0; i<n && over > 0; i++) {\\n                if (v[i] < 3) continue;  \\n                if (v[i] % 3 == 1) {  //e.g. 7 a\\'s, need to remove 2 to become 3*1+2=5\\n                    v[i] -= Math.min(2, over);\\n                    over -= 2;\\n                }\\n            }\\n            \\n            // for (int k = 1; k < 3; k++) {\\n            //     for (int i = 0; i < n && over > 0; i++) {\\n            //         if (v[i] < 3 || v[i] % 3 != (k - 1)) continue;\\n            //         v[i] -= Math.min(over, k);\\n            //         over -= k;\\n            //     }\\n            // }\\n            \\n            //over is the remaining letters that need to be removed\\n            //if removal can fix the repetition issue, we don\\'t need to replace\\n            for (int i=0; i<n; i++) {\\n                if (v[i] >= 3 && over > 0) {\\n                    int needToRemove = v[i] - 2; //3m \\n                    v[i] -= over; //do not need to remove v[i] if <=2\\n                    over -= needToRemove;\\n                }\\n                if (v[i] >= 3) replace += v[i]/3; //at least replace m \\n            }\\n            //System.out.println(missType + \" \" + replace);\\n            res += Math.max(missType, replace); \\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660649,
                "title": "golang-0ms-o-n-single-run-o-1-space",
                "content": "Spend 3 hours of life, so upvote.\\n\\n```golang\\nfunc strongPasswordChecker(password string) int {\\n\\tn := len(password)\\n\\n\\tmissingLC, missingUC, missingD := 1, 1, 1\\n\\tmustChanged, deleteOne, deleteTwo := 0, 0, 0\\n\\tfor idx := 0; idx < n; idx++ {\\n\\t\\tchar := password[idx]\\n\\t\\tif 97 <= char && char <= 122 { // \\'a\\' - \\'z\\'\\n\\t\\t\\tmissingLC = 0\\n\\t\\t}\\n\\t\\tif 65 <= char && char <= 90 { // \\'A\\' - \\'Z\\'\\n\\t\\t\\tmissingUC = 0\\n\\t\\t}\\n\\t\\tif 48 <= char && char <= 57 { // \\'0\\' - \\'9\\'\\n\\t\\t\\tmissingD = 0\\n\\t\\t}\\n\\n\\t\\tif idx > 1 && password[idx] == password[idx-1] && password[idx] == password[idx-2] {\\n\\t\\t\\tseqLen := 3\\n\\t\\t\\tfor idx < n-1 && password[idx+1] == password[idx] {\\n\\t\\t\\t\\tseqLen++\\n\\t\\t\\t\\tidx++\\n\\t\\t\\t}\\n\\n\\t\\t\\tmustChanged += seqLen / 3\\n\\t\\t\\tif seqLen%3 == 0 { // \"aaa\" => \"aa\"\\n\\t\\t\\t\\tdeleteOne++\\n\\t\\t\\t} else if seqLen%3 == 1 { // \"aaaa\" => \"aa\"\\n\\t\\t\\t\\tdeleteTwo++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tmissingTotal := missingLC + missingUC + missingD\\n\\n\\tif n < 6 {\\n\\t\\treturn max420(missingTotal, 6-n)\\n\\t} else if n <= 20 {\\n\\t\\treturn max420(missingTotal, mustChanged)\\n\\t} else {\\n\\t\\tmustDeleted := n - 20\\n\\n\\t\\tmustChanged -= min420(mustDeleted, deleteOne)\\n\\t\\tmustChanged -= min420(max420(mustDeleted-deleteOne, 0), deleteTwo*2) / 2\\n\\t\\tmustChanged -= max420(mustDeleted-deleteOne-2*deleteTwo, 0) / 3\\n\\n\\t\\treturn mustDeleted + max420(missingTotal, mustChanged)\\n\\t}\\n}\\n\\nfunc max420(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc min420(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```\\n\\n![ac9176bf-ce84-48a7-ac3e-74b0ba735101_1677453394.161722\\\\[1\\\\].webp](https://assets.leetcode.com/users/images/a6d32713-5bfa-44ca-8a6b-7b1a68205785_1677672353.319509.webp)\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc strongPasswordChecker(password string) int {\\n\\tn := len(password)\\n\\n\\tmissingLC, missingUC, missingD := 1, 1, 1\\n\\tmustChanged, deleteOne, deleteTwo := 0, 0, 0\\n\\tfor idx := 0; idx < n; idx++ {\\n\\t\\tchar := password[idx]\\n\\t\\tif 97 <= char && char <= 122 { // \\'a\\' - \\'z\\'\\n\\t\\t\\tmissingLC = 0\\n\\t\\t}\\n\\t\\tif 65 <= char && char <= 90 { // \\'A\\' - \\'Z\\'\\n\\t\\t\\tmissingUC = 0\\n\\t\\t}\\n\\t\\tif 48 <= char && char <= 57 { // \\'0\\' - \\'9\\'\\n\\t\\t\\tmissingD = 0\\n\\t\\t}\\n\\n\\t\\tif idx > 1 && password[idx] == password[idx-1] && password[idx] == password[idx-2] {\\n\\t\\t\\tseqLen := 3\\n\\t\\t\\tfor idx < n-1 && password[idx+1] == password[idx] {\\n\\t\\t\\t\\tseqLen++\\n\\t\\t\\t\\tidx++\\n\\t\\t\\t}\\n\\n\\t\\t\\tmustChanged += seqLen / 3\\n\\t\\t\\tif seqLen%3 == 0 { // \"aaa\" => \"aa\"\\n\\t\\t\\t\\tdeleteOne++\\n\\t\\t\\t} else if seqLen%3 == 1 { // \"aaaa\" => \"aa\"\\n\\t\\t\\t\\tdeleteTwo++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tmissingTotal := missingLC + missingUC + missingD\\n\\n\\tif n < 6 {\\n\\t\\treturn max420(missingTotal, 6-n)\\n\\t} else if n <= 20 {\\n\\t\\treturn max420(missingTotal, mustChanged)\\n\\t} else {\\n\\t\\tmustDeleted := n - 20\\n\\n\\t\\tmustChanged -= min420(mustDeleted, deleteOne)\\n\\t\\tmustChanged -= min420(max420(mustDeleted-deleteOne, 0), deleteTwo*2) / 2\\n\\t\\tmustChanged -= max420(mustDeleted-deleteOne-2*deleteTwo, 0) / 3\\n\\n\\t\\treturn mustDeleted + max420(missingTotal, mustChanged)\\n\\t}\\n}\\n\\nfunc max420(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc min420(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2245802,
                "title": "c-java-c-c-python-easy-to-understand-solutions-commented-code",
                "content": "The basic principle is straightforward: if we want to make MINIMUM changes to turn the input string into a strong password, each change made should fix as many problems as possible.\\n\\nLet\\'s divide the problem into three sub-problems\\n1. The password has less than 6 characters.\\n2. The length of password is between 6 and 20 characters, both included.\\n3. And the string length is greater than 20 characters.\\n\\nNow a strong password should have at least one [**lowercase**](https://docs.microsoft.com/en-us/dotnet/api/system.char.islower?view=net-6.0) letter, at least one [**uppercase**](https://docs.microsoft.com/en-us/dotnet/api/system.char.isupper?view=net-6.0) letter, and at least one [**digit**](https://docs.microsoft.com/en-us/dotnet/api/system.char.isdigit?view=net-6.0). The methoid \\'GetRequiredChar\\' checks for the three conditions.\\n\\nThe first two cases are easy. When the string length is greater than 20 characters, we can optimize the edits of triplets by considering three cases:\\n\\n* When the sequences of the same character are evenly divisible by 3\\n* When they have one extra character\\n* and when they are one character off from being evenly divisible by 3\\n\\nlength%3 == 0 should have higher priority \\nlength%3 == 1 second\\nlength%3 == 2 lowest\\n\\nFor any repeating sequences with length % 3 == 0, we can reduce one replacement by deleting one character. For any repeating sequences with length % 3 == 1, we can reduce one replacement by deleting two character. For the remaining sequences, we can reduce every replacement by deleting three character.\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bitset<3> requirements{111}; \\n        list<int> repeats;\\n        auto it = s.begin();\\n        auto it2 = s.end();\\n        while (it != s.end()) {\\n            if (*it != *it2) {\\n                if (requirements.test(0) && islower(*it))\\n                    requirements.reset(0);\\n                if (requirements.test(1) && isupper(*it))\\n                    requirements.reset(1);\\n                if (requirements.test(2) && isdigit(*it))\\n                    requirements.reset(2);\\n            } else {\\n                while (it != s.end() && *it == *it2)\\n                    ++it;\\n                if (distance(it2, it) != 2)\\n                    repeats.push_back(distance(it2, it));\\n                if (it != s.end())\\n                    continue;\\n                else\\n                    break;\\n            }\\n            it2 = it;\\n            ++it;\\n        }\\n        repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n        int ans{0}, len{static_cast<int>(s.size())};\\n        while (len > 20) {\\n            if (!repeats.empty()) {\\n                if (repeats.front() == 3) {\\n                    repeats.pop_front();\\n                }\\n                else {\\n                    --repeats.front();\\n                    repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n                }\\n                ++ans;\\n                --len;\\n            }\\n            else {\\n                ans += len - 20;\\n                len = 20;\\n            }\\n        }\\n        int rep_ins{0};\\n        while (!repeats.empty()) {\\n            rep_ins += repeats.front() / 3;\\n            repeats.pop_front();\\n        }\\n        if ((len + rep_ins) < 6) {\\n            rep_ins += 6 - len - rep_ins;\\n        }\\n        ans += max(static_cast<int>(requirements.count()), rep_ins);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n        char[] carr = s.toCharArray();\\n        int[] arr = new int[carr.length];\\n        for (int i = 0; i < arr.length;) {\\n            if (Character.isLowerCase(carr[i])) a = 0;\\n            if (Character.isUpperCase(carr[i])) A = 0;\\n            if (Character.isDigit(carr[i])) d = 0;\\n            int j = i;\\n            while (i < carr.length && carr[i] == carr[j]) i++;\\n            arr[j] = i - j;\\n        }\\n\\n        int total_missing = (a + A + d);\\n        if (arr.length < 6) {\\n            res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n        } else {\\n            int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n            res += over_len;\\n            for (int k = 1; k < 3; k++) {\\n                for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                    if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                    arr[i] -= Math.min(over_len, k);\\n                    over_len -= k;\\n                }\\n            }\\n            for (int i = 0; i < arr.length; i++) {\\n                if (arr[i] >= 3 && over_len > 0) {\\n                    int need = arr[i] - 2;\\n                    arr[i] -= over_len;\\n                    over_len -= need;\\n                }\\n                if (arr[i] >= 3) left_over += arr[i] / 3;\\n            }\\n            res += Math.max(total_missing, left_over);\\n        }\\n        return res;\\n    }\\n}\\n```\\n```csharp []\\nclass Solution {\\n    public int StrongPasswordChecker(string s) {\\n        int charSum = GetRequiredChar(s);\\n        if (s.Length < 6) return Math.Max(charSum, 6 - s.Length);\\n            int replace = 0, ones = 0, twos = 0; \\n            for (int i = 0; i < s.Length;) {\\n            int len = 1;\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3) {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) ones += 1;\\n                    if (len % 3 == 1) twos += 2;\\n                }\\n                i += len;\\n            }\\n            if (s.Length <= 20) return Math.Max(charSum, replace);\\n            int deleteCount = s.Length - 20;\\n            replace -= Math.Min(deleteCount, ones);\\n            replace -= Math.Min(Math.Max(deleteCount - ones, 0), twos) / 2;\\n            replace -= Math.Max(deleteCount - ones - twos, 0) / 3;\\n        return deleteCount + Math.Max(charSum, replace);\\n        }\\n        int GetRequiredChar(string s) {\\n            int lowerCase = 1, upperCase = 1, digit = 1;\\n            foreach (var c in s) {\\n                if (char.IsLower(c)) lowerCase = 0;\\n                else if (char.IsUpper(c)) upperCase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n            return lowerCase + upperCase + digit;\\n    }    \\n}\\n```\\n```C []\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int offences1 = 0;\\n    int offences2 = 0;\\n    int offences = 0;\\n    int r = 0;\\n    char prev = \\'\\\\n\\';\\n    char curr;\\n    int repC = 1;\\n    int delrep[3] = {0};\\n    int maxrep = 0;\\n    for(int i = 0; i < length; i++) {\\n        curr = password[i];\\n        if(curr == prev) {\\n            repC++;\\n        } else {\\n            if(repC >= 3) {\\n                delrep[repC%3]++;\\n            }\\n            repC = 1;\\n            prev = curr;\\n        }\\n        if(repC % 3 == 0) {\\n            r++;\\n        }\\n        if(repC > 3 && repC % 3 == 1) {\\n            delrep[2]++;\\n        }\\n    }\\n    if(repC >= 3) {\\n        delrep[repC%3]++;\\n    }\\n    int v = 0;\\n    int vo = 0;\\n    int lc = 0;\\n    int uc = 0;\\n    int dc = 0;\\n    for(int i = 0; i < length; i++) {\\n        if(lc == 0 && islower(password[i]) != 0) {\\n            v++;\\n            lc = 1;\\n        }\\n        if(uc == 0 && isupper(password[i]) != 0) {\\n            v++;\\n            uc = 1;\\n        }\\n        if(dc == 0 && isdigit(password[i]) != 0) {\\n            v++;\\n            dc = 1;\\n        }\\n    }\\n    if(v < 3) {\\n        offences2 += 3 - v;\\n        vo += 3 - v;\\n        if(length == 5 && v == 1) {\\n            offences1++;\\n        }\\n    }\\n    if(length < 6 || length > 20) {\\n        int delete = length - 20;\\n        if(delrep[0] != 0) {\\n            delrep[0] = delrep[0] < delete ? delrep[0] : delete;\\n        }\\n        if(delrep[1] != 0) {\\n            delrep[1] = delrep[1] < (delete - delrep[0])/2 ? delrep[1] : (delete - delrep[0])/2;\\n        }\\n        if(delrep[2] != 0) {\\n            delrep[2] = delrep[2] < ((delete - delrep[0]) - delrep[1]*2)/3 ? delrep[2] : ((delete - delrep[0]) - delrep[1]*2)/3;\\n        }\\n        r-= delrep[0] + delrep[1] + delrep[2];\\n        int x = r > offences2 ?  r : offences2;\\n        return length < 6 ? 6 - length + offences1 : delete + x; \\n    }    \\n    return vo < r ? r : vo;\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n            return delete + max(missing_type, change)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C#",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bitset<3> requirements{111}; \\n        list<int> repeats;\\n        auto it = s.begin();\\n        auto it2 = s.end();\\n        while (it != s.end()) {\\n            if (*it != *it2) {\\n                if (requirements.test(0) && islower(*it))\\n                    requirements.reset(0);\\n                if (requirements.test(1) && isupper(*it))\\n                    requirements.reset(1);\\n                if (requirements.test(2) && isdigit(*it))\\n                    requirements.reset(2);\\n            } else {\\n                while (it != s.end() && *it == *it2)\\n                    ++it;\\n                if (distance(it2, it) != 2)\\n                    repeats.push_back(distance(it2, it));\\n                if (it != s.end())\\n                    continue;\\n                else\\n                    break;\\n            }\\n            it2 = it;\\n            ++it;\\n        }\\n        repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n        int ans{0}, len{static_cast<int>(s.size())};\\n        while (len > 20) {\\n            if (!repeats.empty()) {\\n                if (repeats.front() == 3) {\\n                    repeats.pop_front();\\n                }\\n                else {\\n                    --repeats.front();\\n                    repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n                }\\n                ++ans;\\n                --len;\\n            }\\n            else {\\n                ans += len - 20;\\n                len = 20;\\n            }\\n        }\\n        int rep_ins{0};\\n        while (!repeats.empty()) {\\n            rep_ins += repeats.front() / 3;\\n            repeats.pop_front();\\n        }\\n        if ((len + rep_ins) < 6) {\\n            rep_ins += 6 - len - rep_ins;\\n        }\\n        ans += max(static_cast<int>(requirements.count()), rep_ins);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n        char[] carr = s.toCharArray();\\n        int[] arr = new int[carr.length];\\n        for (int i = 0; i < arr.length;) {\\n            if (Character.isLowerCase(carr[i])) a = 0;\\n            if (Character.isUpperCase(carr[i])) A = 0;\\n            if (Character.isDigit(carr[i])) d = 0;\\n            int j = i;\\n            while (i < carr.length && carr[i] == carr[j]) i++;\\n            arr[j] = i - j;\\n        }\\n\\n        int total_missing = (a + A + d);\\n        if (arr.length < 6) {\\n            res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n        } else {\\n            int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n            res += over_len;\\n            for (int k = 1; k < 3; k++) {\\n                for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                    if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                    arr[i] -= Math.min(over_len, k);\\n                    over_len -= k;\\n                }\\n            }\\n            for (int i = 0; i < arr.length; i++) {\\n                if (arr[i] >= 3 && over_len > 0) {\\n                    int need = arr[i] - 2;\\n                    arr[i] -= over_len;\\n                    over_len -= need;\\n                }\\n                if (arr[i] >= 3) left_over += arr[i] / 3;\\n            }\\n            res += Math.max(total_missing, left_over);\\n        }\\n        return res;\\n    }\\n}\\n```\n```csharp []\\nclass Solution {\\n    public int StrongPasswordChecker(string s) {\\n        int charSum = GetRequiredChar(s);\\n        if (s.Length < 6) return Math.Max(charSum, 6 - s.Length);\\n            int replace = 0, ones = 0, twos = 0; \\n            for (int i = 0; i < s.Length;) {\\n            int len = 1;\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3) {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) ones += 1;\\n                    if (len % 3 == 1) twos += 2;\\n                }\\n                i += len;\\n            }\\n            if (s.Length <= 20) return Math.Max(charSum, replace);\\n            int deleteCount = s.Length - 20;\\n            replace -= Math.Min(deleteCount, ones);\\n            replace -= Math.Min(Math.Max(deleteCount - ones, 0), twos) / 2;\\n            replace -= Math.Max(deleteCount - ones - twos, 0) / 3;\\n        return deleteCount + Math.Max(charSum, replace);\\n        }\\n        int GetRequiredChar(string s) {\\n            int lowerCase = 1, upperCase = 1, digit = 1;\\n            foreach (var c in s) {\\n                if (char.IsLower(c)) lowerCase = 0;\\n                else if (char.IsUpper(c)) upperCase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n            return lowerCase + upperCase + digit;\\n    }    \\n}\\n```\n```C []\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int offences1 = 0;\\n    int offences2 = 0;\\n    int offences = 0;\\n    int r = 0;\\n    char prev = \\'\\\\n\\';\\n    char curr;\\n    int repC = 1;\\n    int delrep[3] = {0};\\n    int maxrep = 0;\\n    for(int i = 0; i < length; i++) {\\n        curr = password[i];\\n        if(curr == prev) {\\n            repC++;\\n        } else {\\n            if(repC >= 3) {\\n                delrep[repC%3]++;\\n            }\\n            repC = 1;\\n            prev = curr;\\n        }\\n        if(repC % 3 == 0) {\\n            r++;\\n        }\\n        if(repC > 3 && repC % 3 == 1) {\\n            delrep[2]++;\\n        }\\n    }\\n    if(repC >= 3) {\\n        delrep[repC%3]++;\\n    }\\n    int v = 0;\\n    int vo = 0;\\n    int lc = 0;\\n    int uc = 0;\\n    int dc = 0;\\n    for(int i = 0; i < length; i++) {\\n        if(lc == 0 && islower(password[i]) != 0) {\\n            v++;\\n            lc = 1;\\n        }\\n        if(uc == 0 && isupper(password[i]) != 0) {\\n            v++;\\n            uc = 1;\\n        }\\n        if(dc == 0 && isdigit(password[i]) != 0) {\\n            v++;\\n            dc = 1;\\n        }\\n    }\\n    if(v < 3) {\\n        offences2 += 3 - v;\\n        vo += 3 - v;\\n        if(length == 5 && v == 1) {\\n            offences1++;\\n        }\\n    }\\n    if(length < 6 || length > 20) {\\n        int delete = length - 20;\\n        if(delrep[0] != 0) {\\n            delrep[0] = delrep[0] < delete ? delrep[0] : delete;\\n        }\\n        if(delrep[1] != 0) {\\n            delrep[1] = delrep[1] < (delete - delrep[0])/2 ? delrep[1] : (delete - delrep[0])/2;\\n        }\\n        if(delrep[2] != 0) {\\n            delrep[2] = delrep[2] < ((delete - delrep[0]) - delrep[1]*2)/3 ? delrep[2] : ((delete - delrep[0]) - delrep[1]*2)/3;\\n        }\\n        r-= delrep[0] + delrep[1] + delrep[2];\\n        int x = r > offences2 ?  r : offences2;\\n        return length < 6 ? 6 - length + offences1 : delete + x; \\n    }    \\n    return vo < r ? r : vo;\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n            return delete + max(missing_type, change)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445576,
                "title": "python3-solution-with-comments",
                "content": "Ty to @hwei022 for correcting a corner case (I had erroneously believed that all charaters have to be characters and numbers, so the password \\'****\\' was giving the wrong value) which has been changed. \\n\\n```\\nclass Solution:\\n    \\n    #  takes in the string, outputs a list of runs of \\n    #  a single character of 3 or more\\n    #  ex: \"aaaaabbbbbbccdeeee\" -> [5,6,4]\\n    def lengthCheck(self, s:str) -> List[int]:\\n        l = []\\n        curr = 1\\n        for i in range(1,len(s)):\\n            if (s[i] is s[i-1]): curr += 1\\n            else: \\n                if (curr > 2): l.append(curr)\\n                curr = 1\\n        if (curr > 2): l.append(curr)\\n        return l\\n    \\n    # return 1 if we are missing an uppercase\\n    def uppercaseCheck(self, s:str)-> int:\\n        if (re.search(\"[A-Z]\", s) is None): return 1\\n        return 0\\n    \\n    # return 1 if we are missing a lowercase\\n    def lowercaseCheck(self, s:str)-> int:\\n        if (re.search(\"[a-z]\", s) is None): return 1\\n        return 0\\n    \\n    # return 1 if we are missing a number\\n    def numberCheck(self, s:str)-> int:\\n        if (re.search(\"[0-9]\", s) is None): return 1\\n        return 0\\n        \\n    \\n    def strongPasswordChecker(self, s: str) -> int:\\n        leng = len(s)\\n        \\n        # If the password is 3 or less, then there is always a way\\n        # to just add characters until it is length 6 and make a \\n        # strong password\\n        if (leng < 4): return 6-leng\\n        \\n        \\n        if (leng == 4): \\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 3): return 3\\n            return 2\\n        \\n        \\n        # For length 5, we only need to add 2 characters \\n        # if we are missing two types\\n        # 3 characters if missing all types\\n        if (leng == 5): \\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 3): return 3\\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 2): return 2\\n            return 1\\n        \\n        lis = self.lengthCheck(s)\\n        \\n        # If the length is acceptable, then all the changes can be replacements.\\n        # We need to make replacements to eliminate runs\\n        # ex: aaaaaaaa -> aaxaaxaa\\n        # hence the quotient by 3 rounded down.\\n        # If that number is lower than the missing types\\n        # then take the missing types\\n        if (leng <= 20):\\n            return max(sum(map(lambda x: int(x/3),lis)), self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s))\\n        \\n        # for too long passwords... \\n        if (leng > 20):\\n            # we first count how many deletions we need\\n            numdel = leng-20\\n            \\n            # the amount of replacements due to runs we would need\\n            # is reduced by the deletions\\n            runreplace = sum(map(lambda x: int(x/3),lis))\\n            \\n            # order the runs by how many deletions needed \\n            # to eliminate one replacement\\n            # ex. aaa needs 1 deletion, aaaa needs 2, aaaaa needs 3\\n            l = list(map(lambda x: (x % 3)+1,lis))\\n            l.sort()\\n            \\n            # variable to keep track of how many deletions are left\\n            rem = numdel\\n            \\n            # first the cheap ones:\\n            # aaa -> aa is one deletion to save one replacement\\n            for i in range(0,len(l)):\\n                if (rem >= l[i]):\\n                    rem -= l[i]\\n                    runreplace -= 1\\n                    \\n            # after the cheap ones, take the most expensive ones\\n            # ex aaaaa -> aa saves 1 replacement, aaaaaaaa -> aa saves 2 replacements.\\n            # This calculation might make runreplace negative\\n            runreplace -= int(rem / 3)\\n            \\n            # if we need more replacements due \\n            # to the checks (or runreplace is negative)\\n            # make the number of replacements correct\\n            if (runreplace < self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s)): runreplace = self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s)\\n                \\n            # total changes\\n            return numdel + runreplace\\n        return 0\\n",
                "solutionTags": [],
                "code": "Ty to @hwei022 for correcting a corner case (I had erroneously believed that all charaters have to be characters and numbers, so the password \\'****\\' was giving the wrong value) which has been changed. \\n\\n```\\nclass Solution:\\n    \\n    #  takes in the string, outputs a list of runs of \\n    #  a single character of 3 or more\\n    #  ex: \"aaaaabbbbbbccdeeee\" -> [5,6,4]\\n    def lengthCheck(self, s:str) -> List[int]:\\n        l = []\\n        curr = 1\\n        for i in range(1,len(s)):\\n            if (s[i] is s[i-1]): curr += 1\\n            else: \\n                if (curr > 2): l.append(curr)\\n                curr = 1\\n        if (curr > 2): l.append(curr)\\n        return l\\n    \\n    # return 1 if we are missing an uppercase\\n    def uppercaseCheck(self, s:str)-> int:\\n        if (re.search(\"[A-Z]\", s) is None): return 1\\n        return 0\\n    \\n    # return 1 if we are missing a lowercase\\n    def lowercaseCheck(self, s:str)-> int:\\n        if (re.search(\"[a-z]\", s) is None): return 1\\n        return 0\\n    \\n    # return 1 if we are missing a number\\n    def numberCheck(self, s:str)-> int:\\n        if (re.search(\"[0-9]\", s) is None): return 1\\n        return 0\\n        \\n    \\n    def strongPasswordChecker(self, s: str) -> int:\\n        leng = len(s)\\n        \\n        # If the password is 3 or less, then there is always a way\\n        # to just add characters until it is length 6 and make a \\n        # strong password\\n        if (leng < 4): return 6-leng\\n        \\n        \\n        if (leng == 4): \\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 3): return 3\\n            return 2\\n        \\n        \\n        # For length 5, we only need to add 2 characters \\n        # if we are missing two types\\n        # 3 characters if missing all types\\n        if (leng == 5): \\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 3): return 3\\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 2): return 2\\n            return 1\\n        \\n        lis = self.lengthCheck(s)\\n        \\n        # If the length is acceptable, then all the changes can be replacements.\\n        # We need to make replacements to eliminate runs\\n        # ex: aaaaaaaa -> aaxaaxaa\\n        # hence the quotient by 3 rounded down.\\n        # If that number is lower than the missing types\\n        # then take the missing types\\n        if (leng <= 20):\\n            return max(sum(map(lambda x: int(x/3),lis)), self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s))\\n        \\n        # for too long passwords... \\n        if (leng > 20):\\n            # we first count how many deletions we need\\n            numdel = leng-20\\n            \\n            # the amount of replacements due to runs we would need\\n            # is reduced by the deletions\\n            runreplace = sum(map(lambda x: int(x/3),lis))\\n            \\n            # order the runs by how many deletions needed \\n            # to eliminate one replacement\\n            # ex. aaa needs 1 deletion, aaaa needs 2, aaaaa needs 3\\n            l = list(map(lambda x: (x % 3)+1,lis))\\n            l.sort()\\n            \\n            # variable to keep track of how many deletions are left\\n            rem = numdel\\n            \\n            # first the cheap ones:\\n            # aaa -> aa is one deletion to save one replacement\\n            for i in range(0,len(l)):\\n                if (rem >= l[i]):\\n                    rem -= l[i]\\n                    runreplace -= 1\\n                    \\n            # after the cheap ones, take the most expensive ones\\n            # ex aaaaa -> aa saves 1 replacement, aaaaaaaa -> aa saves 2 replacements.\\n            # This calculation might make runreplace negative\\n            runreplace -= int(rem / 3)\\n            \\n            # if we need more replacements due \\n            # to the checks (or runreplace is negative)\\n            # make the number of replacements correct\\n            if (runreplace < self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s)): runreplace = self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s)\\n                \\n            # total changes\\n            return numdel + runreplace\\n        return 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 91004,
                "title": "java-o-n-greedy-solution-with-super-clear-explanation",
                "content": "We discuss in three cases:\\n1. Case (n=s.length)<6: return 6-n>nMiss?6-n:nMiss, where nMiss = hasLower?0:1+hasUpper?0:1+hasDigit?0:1;  (just check every possible n, using appropriate insertions)\\n\\n2. Case n>=6&&n<=20: Replacement is the best choice! (Replacing every third by another char is the best change.) return max(nMiss, nRep=sum{ni/3}), where ni is the length of a substring with repeating characters (SSRC).\\n\\n3. Case n>20: It is for sure that (n-20) deletions must be applied no matter what, and for sure that no insertions are needed (since 1 insert needs 1 delete, which is equivalent to 1 replace+1 delete or even 1 delete). Hence we greedily apply deletions first.\\n\\nGreedy strategies for applying deletions - clearly the best choice is to apply on a SSRC to possibly reduce nRep (when the length of s becomes 20). Immediately, we have the best of the best choice is to delete a char of a SSRC of length 3k (recalling how nRep is calculated as in case 2), and that length becomes 3(k-1)+2. Hence if possible, we apply 1 del per each such SSRC.\\n\\nIf still delete-able, the second best is to apply del on a SSRC of length 3k+1, (since nRep is reduced by 1 per 2 del, but if applying on 3k+2, nRep is reduced by 1 per 3 del). Notice that applying 1 del on such a SSRC makes its length 3k, and immediately this has the highest priority for the next possible deletion. Hence if possible, we apply 2 del per each such SSRC (to make its length become 3(k-1)+2).\\n\\nIf still delete-able, we then apply del on each (updated) SSRC until its length =2. Notice that nRep is reduced by 1 per 3 del since each has length 3k+2.\\n\\nIf still delete-able, return n-20+nMiss, (n-20 del, nMiss many rep).\\n\\nOtherwise, return n-20+max(updated_nRep, nMiss).\\n\\n\\n```\\npublic int strongPasswordChecker(String s) { \\n\\tint n = s.length();\\n\\tboolean hasLower = false, hasUpper = false, hasDigit = false;\\n\\tint nRep = 0, sum = 0; // sum=sum{length>=3 of a SSRC}\\n\\tint[] m = new int[3]; // # of SSRC of length 3k, 3k+1, 3k+2\\n\\n\\tint i = 0, j, t;\\n\\tchar c;\\n\\twhile (i < n) {\\n\\t\\tc = s.charAt(i);\\n\\n\\t\\thasLower |= (c >= 'a' && c <= 'z');\\n\\t\\thasUpper |= (c >= 'A' && c <= 'Z');\\n\\t\\thasDigit |= (c >= '0' && c <= '9');\\n\\n\\t\\tj = i + 1;\\n\\t\\twhile (j < n && s.charAt(j) == c)\\n\\t\\t\\tj++;\\n\\n\\t\\tt = j - i;\\n\\t\\tif (t >= 3) {\\n\\t\\t\\tnRep += t / 3;\\n\\t\\t\\tsum += t;\\n\\t\\t\\tm[t % 3]++;\\n\\t\\t}\\n\\t\\ti = j;\\n\\t}\\n\\n\\tint nMiss = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n\\tif (n < 6) \\n\\t\\treturn (6 - n) > nMiss ? (6 - n) : nMiss;\\n\\n\\tif (n <= 20)\\n\\t\\treturn Math.max(nRep, nMiss);\\n\\n\\t// n > 20\\n\\tint nDel = n - 20;\\n\\tif (nDel <= m[0])\\n\\t\\treturn nDel + Math.max(nRep - nDel, nMiss);\\n\\n\\tint rNDel = nDel - m[0];\\n\\tnRep -= m[0];\\n\\tif (rNDel <= 2 * m[1])\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 2, nMiss);\\n\\n\\trNDel -= 2 * m[1];\\n\\tnRep -= m[1];\\n\\tif (nDel <= sum - 2 * (m[0] + m[1] + m[2]))\\n\\t\\t/**\\n\\t\\t * This condition is equivalent to nDel-m[0]-2m[1]<=\\n\\t\\t * sum{3(k_i-1)}+sum{3(k'_i-1)}+sum{3k''_i},\\n\\t\\t * where {3k_i, 1<=i<=m[0]}, {3k'_i+1, 1<=i<=m[1]}, \\n\\t\\t * {3k''_i+2, 1<=i<=m[2]} are the sets of lengths of SSRCs\\n\\t\\t */\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 3, nMiss);\\n\\n\\treturn nDel + nMiss;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int strongPasswordChecker(String s) { \\n\\tint n = s.length();\\n\\tboolean hasLower = false, hasUpper = false, hasDigit = false;\\n\\tint nRep = 0, sum = 0; // sum=sum{length>=3 of a SSRC}\\n\\tint[] m = new int[3]; // # of SSRC of length 3k, 3k+1, 3k+2\\n\\n\\tint i = 0, j, t;\\n\\tchar c;\\n\\twhile (i < n) {\\n\\t\\tc = s.charAt(i);\\n\\n\\t\\thasLower |= (c >= 'a' && c <= 'z');\\n\\t\\thasUpper |= (c >= 'A' && c <= 'Z');\\n\\t\\thasDigit |= (c >= '0' && c <= '9');\\n\\n\\t\\tj = i + 1;\\n\\t\\twhile (j < n && s.charAt(j) == c)\\n\\t\\t\\tj++;\\n\\n\\t\\tt = j - i;\\n\\t\\tif (t >= 3) {\\n\\t\\t\\tnRep += t / 3;\\n\\t\\t\\tsum += t;\\n\\t\\t\\tm[t % 3]++;\\n\\t\\t}\\n\\t\\ti = j;\\n\\t}\\n\\n\\tint nMiss = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n\\tif (n < 6) \\n\\t\\treturn (6 - n) > nMiss ? (6 - n) : nMiss;\\n\\n\\tif (n <= 20)\\n\\t\\treturn Math.max(nRep, nMiss);\\n\\n\\t// n > 20\\n\\tint nDel = n - 20;\\n\\tif (nDel <= m[0])\\n\\t\\treturn nDel + Math.max(nRep - nDel, nMiss);\\n\\n\\tint rNDel = nDel - m[0];\\n\\tnRep -= m[0];\\n\\tif (rNDel <= 2 * m[1])\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 2, nMiss);\\n\\n\\trNDel -= 2 * m[1];\\n\\tnRep -= m[1];\\n\\tif (nDel <= sum - 2 * (m[0] + m[1] + m[2]))\\n\\t\\t/**\\n\\t\\t * This condition is equivalent to nDel-m[0]-2m[1]<=\\n\\t\\t * sum{3(k_i-1)}+sum{3(k'_i-1)}+sum{3k''_i},\\n\\t\\t * where {3k_i, 1<=i<=m[0]}, {3k'_i+1, 1<=i<=m[1]}, \\n\\t\\t * {3k''_i+2, 1<=i<=m[2]} are the sets of lengths of SSRCs\\n\\t\\t */\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 3, nMiss);\\n\\n\\treturn nDel + nMiss;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431603,
                "title": "share-my-clean-java-solution-with-explanations-case-by-case",
                "content": "I commented my code as well, but here is an explanation.\\n\\n#### Case 1 (len > 20)\\nThe trickier case is when `len > 20` and when there are consecutive chars groups of length no less than 3. Since the string length is greater than 20, we will have to delete, but we have to figure out what to delete to ensure the optimal outcome. Take a look at `aaa`, if we delete 1 `\\'a\\'` from it, we no longer have 3 `\\'a\\'`, so we saved 1 move, for \"aaaa\", 1 deletion brings us to \"aaa\" which doesn\\'t save us anything. \"aaaaa\", 1 deletion doesn\\'t do anything either, but for \"aaaaaa\", here 1 deletion saves us 1 move because we would have needed \"aa1aa1\", but after 1 deletion, we can just do \"aa1aa\", so that\\'s good. \\n\\nIn Summary, we should always delete the char groups whose length is a multiple of 3, followed by those mod 3 = 1, then those mod 3 = 2.\\n#### Case 2 (20 >= len >= 6)\\nThere is no edge case here. We just have to handle the condition counts and **replace** consecutive char groups accordingly.\\n\\n#### Case 3 (len > 6)\\nIf we encounter a consecutive chars groups, we must **insert** instead of replace or delete. Per insertion, we can knock off 1 condition that was unmet prior.\\n\\n> **Please upvote if you find my explanations & implementation helpful, thank you!**\\n#### Java\\n```Java\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int[] ok = new int[]{1, 1, 1};\\n        char[] A = password.toCharArray();\\n        for (char ch : A){ // check the 3 conditions first.\\n            ok[0] &= Character.isLowerCase(ch)? 0 : 1;\\n            ok[1] &= Character.isUpperCase(ch)? 0 : 1;\\n            ok[2] &= Character.isDigit(ch)? 0 : 1;\\n        }\\n        int ans = 0, len = password.length(), cond = ok[0]+ok[1]+ok[2]; // cond -> how many cond not met yet.\\n        var minheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> o%3)); // sort by o%3\\n        for (int i = 0, cnt = 1; i < len; i++, cnt++){ // put consecutive chars with count >= 3 into the minheap\\n            if (i == len-1 || A[i] != A[i+1]){\\n                if (cnt >= 3){\\n                    minheap.offer(cnt);\\n                }\\n                cnt = 0;\\n            }\\n        }\\n        while(len > 20 && !minheap.isEmpty()){ // if len > 20, we try to delete from the chars groups.\\n            int cur = minheap.poll();\\n            if (--cur >= 3){\\n                minheap.offer(cur);\\n            }\\n            --len;\\n            ++ans;\\n        }\\n        while(!minheap.isEmpty()){ // if there are still 3 or more chars groups, we need to replace or insert\\n            int cur = minheap.poll();\\n            cond -= cur/3;\\n            ans += cur/3;\\n            if (len < 6){ // insert only for len < 6; otherwise, replace.\\n                len++;    // I do ++ here as cur can only be 3,4,5.\\n            }\\n        }\\n        while(len > 20){ // if len is still > 20, we need to delete.\\n            ans++;\\n            len--;\\n        }\\n        while(len < 6){ // if len < 6, we need to insert and per insertion will satisify 1 cond\\n            cond--;\\n            ans++;\\n            len++;\\n        }\\n        return ans + (cond < 0? 0 : cond); // remember to take the max of (cond, 0).\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int[] ok = new int[]{1, 1, 1};\\n        char[] A = password.toCharArray();\\n        for (char ch : A){ // check the 3 conditions first.\\n            ok[0] &= Character.isLowerCase(ch)? 0 : 1;\\n            ok[1] &= Character.isUpperCase(ch)? 0 : 1;\\n            ok[2] &= Character.isDigit(ch)? 0 : 1;\\n        }\\n        int ans = 0, len = password.length(), cond = ok[0]+ok[1]+ok[2]; // cond -> how many cond not met yet.\\n        var minheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> o%3)); // sort by o%3\\n        for (int i = 0, cnt = 1; i < len; i++, cnt++){ // put consecutive chars with count >= 3 into the minheap\\n            if (i == len-1 || A[i] != A[i+1]){\\n                if (cnt >= 3){\\n                    minheap.offer(cnt);\\n                }\\n                cnt = 0;\\n            }\\n        }\\n        while(len > 20 && !minheap.isEmpty()){ // if len > 20, we try to delete from the chars groups.\\n            int cur = minheap.poll();\\n            if (--cur >= 3){\\n                minheap.offer(cur);\\n            }\\n            --len;\\n            ++ans;\\n        }\\n        while(!minheap.isEmpty()){ // if there are still 3 or more chars groups, we need to replace or insert\\n            int cur = minheap.poll();\\n            cond -= cur/3;\\n            ans += cur/3;\\n            if (len < 6){ // insert only for len < 6; otherwise, replace.\\n                len++;    // I do ++ here as cur can only be 3,4,5.\\n            }\\n        }\\n        while(len > 20){ // if len is still > 20, we need to delete.\\n            ans++;\\n            len--;\\n        }\\n        while(len < 6){ // if len < 6, we need to insert and per insertion will satisify 1 cond\\n            cond--;\\n            ans++;\\n            len++;\\n        }\\n        return ans + (cond < 0? 0 : cond); // remember to take the max of (cond, 0).\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393542,
                "title": "c-100-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool islower(char &c)\\n    {\\n        return c>=\\'a\\' && c<=\\'z\\';\\n    }\\n    bool isupper(char &c)\\n    {\\n        return c>=\\'A\\' && c<=\\'Z\\';\\n    }\\n    bool isdigit(char &c)\\n    {\\n        return c>=\\'0\\' && c<=\\'9\\';\\n    }\\n    \\n    int strongPasswordChecker(string s ) {\\n        int n=s.length();\\n        \\n        bool lo,up,di;\\n        lo=up=di=false;\\n        \\n        if(n<=20)\\n        {\\n            int need_replaces=0,can_be_replaced=0;\\n            int need_add=(6-n)<0 ? 0:6-n;\\n            for(int i=0;i<n;)\\n            {\\n                if(!lo && islower(s[i]))\\n                    lo=true;\\n                if(!up && isupper(s[i]))\\n                    up=true;\\n                if(!di && isdigit(s[i]))\\n                    di=true;\\n                \\n                int tmp=1;\\n                int j=i+1;\\n                while(j<n && s[i]==s[j])\\n                {\\n                    j++;\\n                }\\n                tmp=(j-i);\\n                can_be_replaced+=tmp/3;\\n                \\n                i=j;\\n            }\\n            \\n            if(!lo) need_replaces+=1;\\n            if(!up) need_replaces+=1;\\n            if(!di) need_replaces+=1;\\n            \\n            int replaces=max(can_be_replaced,need_replaces);\\n            return max(need_add,replaces);\\n        }\\n        else\\n        {\\n            int min_deletion=n-20,need_replaces=0;\\n            int curr_length=0;\\n            priority_queue<int>pq;\\n            \\n            for(int i=0;i<n;)\\n            {\\n                if(!lo && islower(s[i]))\\n                    lo=true;\\n                if(!up && isupper(s[i]))\\n                    up=true;\\n                if(!di && isdigit(s[i]))\\n                    di=true;\\n                \\n                int temp=1;\\n                int j=i+1;\\n                while(j<n && s[i]==s[j])\\n                {\\n                    j++;\\n                }\\n                temp=(j-i);\\n                if(temp>=2)\\n                {\\n                    curr_length+=2;\\n                    pq.push(temp-2);\\n                }\\n                else\\n                    curr_length+=1;\\n                \\n                i=j;\\n            }\\n            \\n            if(!lo) need_replaces+=1;\\n            if(!up) need_replaces+=1;\\n            if(!di) need_replaces+=1;\\n            \\n            if(curr_length>=20)\\n                return min_deletion+need_replaces;\\n            else\\n            {\\n                int min_replacement=0;\\n                while(curr_length<20)\\n                {\\n                    int x=pq.top();\\n                    curr_length+=min(3,x);\\n                    min_replacement+=1;\\n                }\\n                \\n                min_replacement=max(min_replacement,need_replaces);\\n                return min_deletion+min_replacement;\\n            }\\n            \\n        }\\n            \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool islower(char &c)\\n    {\\n        return c>=\\'a\\' && c<=\\'z\\';\\n    }\\n    bool isupper(char &c)\\n    {\\n        return c>=\\'A\\' && c<=\\'Z\\';\\n    }\\n    bool isdigit(char &c)\\n    {\\n        return c>=\\'0\\' && c<=\\'9\\';\\n    }\\n    \\n    int strongPasswordChecker(string s ) {\\n        int n=s.length();\\n        \\n        bool lo,up,di;\\n        lo=up=di=false;\\n        \\n        if(n<=20)\\n        {\\n            int need_replaces=0,can_be_replaced=0;\\n            int need_add=(6-n)<0 ? 0:6-n;\\n            for(int i=0;i<n;)\\n            {\\n                if(!lo && islower(s[i]))\\n                    lo=true;\\n                if(!up && isupper(s[i]))\\n                    up=true;\\n                if(!di && isdigit(s[i]))\\n                    di=true;\\n                \\n                int tmp=1;\\n                int j=i+1;\\n                while(j<n && s[i]==s[j])\\n                {\\n                    j++;\\n                }\\n                tmp=(j-i);\\n                can_be_replaced+=tmp/3;\\n                \\n                i=j;\\n            }\\n            \\n            if(!lo) need_replaces+=1;\\n            if(!up) need_replaces+=1;\\n            if(!di) need_replaces+=1;\\n            \\n            int replaces=max(can_be_replaced,need_replaces);\\n            return max(need_add,replaces);\\n        }\\n        else\\n        {\\n            int min_deletion=n-20,need_replaces=0;\\n            int curr_length=0;\\n            priority_queue<int>pq;\\n            \\n            for(int i=0;i<n;)\\n            {\\n                if(!lo && islower(s[i]))\\n                    lo=true;\\n                if(!up && isupper(s[i]))\\n                    up=true;\\n                if(!di && isdigit(s[i]))\\n                    di=true;\\n                \\n                int temp=1;\\n                int j=i+1;\\n                while(j<n && s[i]==s[j])\\n                {\\n                    j++;\\n                }\\n                temp=(j-i);\\n                if(temp>=2)\\n                {\\n                    curr_length+=2;\\n                    pq.push(temp-2);\\n                }\\n                else\\n                    curr_length+=1;\\n                \\n                i=j;\\n            }\\n            \\n            if(!lo) need_replaces+=1;\\n            if(!up) need_replaces+=1;\\n            if(!di) need_replaces+=1;\\n            \\n            if(curr_length>=20)\\n                return min_deletion+need_replaces;\\n            else\\n            {\\n                int min_replacement=0;\\n                while(curr_length<20)\\n                {\\n                    int x=pq.top();\\n                    curr_length+=min(3,x);\\n                    min_replacement+=1;\\n                }\\n                \\n                min_replacement=max(min_replacement,need_replaces);\\n                return min_deletion+min_replacement;\\n            }\\n            \\n        }\\n            \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497854,
                "title": "rust-solution-using-dijkstra-s-algorithm-156-ms-85-3-mb-and-bfs-18-ms-6-7-mb",
                "content": "The words \"minimum number of steps\" made me think of \"minimum cost,\" which made me think of Dijkstra\\'s algorithm, so I solved it by modelling the changes we can make to the string as edges in a graph and then applying Dijkstra\\'s algorithm. This is not the fastest or easiest solution to implement, but I think it\\'s still interesting.\\n\\nIn order to create a strong password from the given string, we need to traverse through the string, so each node in this graph must keep track of the current index where we are in the string. Then, the graph has four types of edges: (1) Add the character at the current index to the strong password and increment the index (2) Increment the current index without adding the current character (i.e. delete the char at the current index) (3) Insert a character right before the current index (4) Do action 3 followed by action 2 (i.e. replace the char at the current index)\\n\\nNext, every node in the graph can be represented as a tuple `(ind, num_chars, lower, upper, digit, last_two)`. `ind` represents the current index. `num_chars` represents the number of characters we have added to the strong password so far. `lower`, `upper`, and `digit` are booleans representing whether we have added a lowercase, uppercase, or digit so far. Finally, `last_two` is one of three possibilities: `Double(c)` which represents that the strong password ends in \"cc\", `Alone(c)` which represents that the strong password ends in \"c\" but not \"cc\", or `Empty` which represents that the strong password is empty. In the implementation, we do not allow traversing from nodes with `Double(c)` along edges where we are adding \"c\" to the end of the strong password, which prevents having three characters in a row in the strong password.\\n\\nWe start out at the beginning of the given string with an empty strong password, so the initial node is `(0, 0, false, false, false, Empty)`. Once we know the initial node, we can implement Dijkstra\\'s algorithm with the four types of edges mentioned above, and we stop once we reach a node of the form `(I, N, true, true, true, _)` where `6 <= N <= 20` and `I` is at the end of the string (i.e. `I = password.len()`) because that means we created a valid strong password after processing all of the string.\\n\\nOne problem is that for edges type 3 and type 4, we have to choose a character to insert and there are 64 different possible characters we could insert, which means, between all the edge types, for any given node there are up to possible 1+1+64+64=130 outgoing edges. In order to cut down on that, we notice that inserting any lowercase letter is the same as any other lowercase letter, as long as it\\'s different from the character at the current index to avoid creating three characters in a row. The same holds for uppercase letters and digits, so we really just need to have one outgoing edge for lowercase letter, one outgoing edge for uppercase letter, and one outgoing edge for digits. This means there are only 3 outgoing edged for types 3 and 4, bringing us to 1+1+3+3=8 outgoing edges for each vertex, which is much more feasible.\\n\\nThere are 51 possibilities for `ind` (0...50), 21 for `num_chars` (0...20), `2` for `lower`, `upper`, and `digit`, and finally `1+64+64=129` possibilities for `last_two`, meaning the number of vertices in our graph is `51*21*2*2*2*129=1105272`. And then there are `8` edges for each vertex, giving us `8842176` edges. The complexity of Dijkstra\\'s is `O((V+E)log(V))` and `(1105272+8842176)log(1105272)/log(2)=199704668`. That is certainly much slower than the linear-time `O(N)` solutions where `N=50`, but it still allows us to reliably run in under a second.\\n\\nTo get the complexity in more symbolic terms, if N is the length of the string, M is the maximum length of a strong password, T is the number of types of characters the strong password must have (i.e. for this problem, T=3 because lowercase, uppercase, digit are required), and A is the number of possible characters in the string (i.e. for this problem, A=26+26+10+1+1=64 because lowercase, uppercase, digit, period, and exclamation mark), then the number of vertices is V=(N+1)(M+1)\\\\*2^T\\\\*(1+2\\\\*A) and the number of edges is E=V\\\\*(1+1+2\\\\*T), so the complexity ends up being O(NM\\\\*2^T\\\\*A\\\\*T\\\\*log(NM\\\\*2^T\\\\*A)), which can also be expressed as O(2^T\\\\*NMAT(T+log(NMA))).\\n```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nenum LastTwo {\\n    Empty,\\n    Alone(char),\\n    Double(char)\\n}\\nuse LastTwo::*;\\n\\nfn upd(lt: LastTwo, c: char) -> LastTwo {\\n    if lt == Alone(c) || lt == Double(c) {\\n        Double(c)\\n    } else {\\n        Alone(c)\\n    }\\n}\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nstruct Info {\\n    cost: Reverse<usize>,\\n    ind: usize,\\n    num_chars: usize,\\n    lower: bool,\\n    upper: bool,\\n    digit: bool,\\n    last_two: LastTwo\\n}\\n\\nimpl Info {\\n    fn new(cost: Reverse<usize>, ind: usize, num_chars: usize, lower: bool, upper: bool, digit: bool, last_two: LastTwo) -> Info {\\n        Info { cost, ind, num_chars, lower, upper, digit, last_two }\\n    }\\n    \\n    fn calc_hash(&self) -> usize {\\n        let mut res = self.ind;\\n        res *= 21;\\n        res += self.num_chars;\\n        res *= 2;\\n        res += (self.lower as usize);\\n        res *= 2;\\n        res += (self.upper as usize);\\n        res *= 2;\\n        res += (self.digit as usize);\\n        res *= 1+2*256;\\n        res += match self.last_two {\\n            Empty => 0,\\n            Alone(ch) => 1+(ch as usize),\\n            Double(ch) => 257+(ch as usize)\\n        };\\n        res\\n    }\\n}\\n\\nfn inc_rev(x: Reverse<usize>) -> Reverse<usize> {\\n    Reverse(x.0+1)\\n}\\n\\nfn add_new_info(s: &mut [Option<usize>], h: &mut BinaryHeap<Info>, info: Info) {\\n    let hash = info.calc_hash();\\n    let should_insert = match s[hash] {\\n        None => true,\\n        Some(c) => info.cost.0 < c\\n    };\\n    if should_insert {\\n        s[hash] = Some(info.cost.0);\\n        h.push(info);\\n    }\\n}\\n\\nfn add_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, info: Info, ch: char, new_cost: Reverse<usize>, new_ind: usize) -> bool {\\n    let new_lower = info.lower || ch.is_ascii_lowercase();\\n    let new_upper = info.upper || ch.is_ascii_uppercase();\\n    let new_digit = info.digit || ch.is_ascii_digit();\\n    if info.last_two != Double(ch) && info.num_chars < 20 {\\n        add_new_info(&mut s, &mut h, Info::new(new_cost, new_ind, info.num_chars+1, new_lower, new_upper, new_digit, upd(info.last_two, ch)));\\n        true\\n    } else { false }\\n}\\n\\nfn change_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if ch == chars[info.ind] || (info.ind+1 < chars.len() && ch == chars[info.ind+1]) {\\n        return false;\\n    }\\n\\n    add_char(&mut s, &mut h, info, ch, inc_rev(info.cost), info.ind+1)\\n}\\n\\nfn insert_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if info.ind < chars.len() && ch == chars[info.ind] {\\n        return false;\\n    }\\n    \\n    add_char(&mut s, &mut h, info, ch, inc_rev(info.cost), info.ind)\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let chars: Vec<char> = password.chars().collect();\\n        \\n        let mut min_cost: Vec<Option<usize>> = vec![None; (chars.len()+1)*21*2*2*2*(1+2*256)];\\n        let mut heap: BinaryHeap<Info> = BinaryHeap::new();\\n        \\n        add_new_info(&mut min_cost, &mut heap, Info::new(Reverse(0), 0, 0, false, false, false, Empty));\\n        \\n        while let Some(info) = heap.pop() {\\n            if let Some(c) = min_cost[info.calc_hash()] {\\n                if c < info.cost.0 {\\n                    continue;\\n                }\\n            }\\n            \\n            if info.ind == chars.len() && info.num_chars >= 6 && info.lower && info.upper && info.digit {\\n                return info.cost.0 as i32;\\n            }\\n            \\n            if info.ind < chars.len() {\\n                //Edge type 1 (i.e. change nothing)\\n                add_char(&mut min_cost, &mut heap, info, chars[info.ind], info.cost, info.ind+1);\\n                \\n                //Edge type 2 (i.e. delete character)\\n                add_new_info(&mut min_cost, &mut heap, Info::new(inc_rev(info.cost), info.ind+1, info.num_chars, info.lower, info.upper, info.digit, info.last_two));\\n                \\n                //Edge type 4 (i.e. replace char): lowercase\\n                for ch in (\\'a\\'..=\\'z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: uppercase\\n                for ch in (\\'A\\'..=\\'Z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: digit\\n                for ch in (\\'0\\'..=\\'9\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n            }\\n            \\n            //Edge type 3 (i.e. insert char): lowercase\\n            for ch in (\\'a\\'..=\\'z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: uppercase\\n            for ch in (\\'A\\'..=\\'Z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: digit\\n            for ch in (\\'0\\'..=\\'9\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n        }\\n        panic!(\"No answer found!\");\\n    }\\n}\\n```\\n\\nEDIT: The reason I used Dijkstra\\'s algorithm is because the edges have different weights: Edge type 1 has weight 0 while edge types 2, 3, 4 have weight 1. However, I realized that, since edge type 1 has weight 0, we can immediately traverse all the edges of type 1 whenever we add a new node to the queue. And this doesn\\'t cause us to go into an infinite loop because each edge of type 1 increments the index, so this traversal stops once we hit the index `password.len()`.\\n\\nBy immediately traversing the edges of type 1, the rest of our search only has to deal with edges of type 2, 3, 4. Since all of these edges have the same weight, this means we can treat the graph as unweighted, and thus use BFS instead of Dijkstra\\'s. This allows us to replace our priority queue with just a queue, which takes the log factor off of our complexity, i.e. the complexity for BFS is just O(V+E)=O(2^T\\\\*NMAT). As advertised in the title, this solution takes just 18 ms as opposed to the Dijkstra\\'s solution which takes 156 ms.\\n```\\nuse std::collections::VecDeque;\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nenum LastTwo {\\n    Empty,\\n    Alone(char),\\n    Double(char)\\n}\\nuse LastTwo::*;\\n\\nfn upd(lt: LastTwo, c: char) -> LastTwo {\\n    if lt == Alone(c) || lt == Double(c) {\\n        Double(c)\\n    } else {\\n        Alone(c)\\n    }\\n}\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nstruct Info {\\n    cost: usize,\\n    ind: usize,\\n    num_chars: usize,\\n    lower: bool,\\n    upper: bool,\\n    digit: bool,\\n    last_two: LastTwo\\n}\\n\\nimpl Info {\\n    fn new(cost: usize, ind: usize, num_chars: usize, lower: bool, upper: bool, digit: bool, last_two: LastTwo) -> Info {\\n        Info { cost, ind, num_chars, lower, upper, digit, last_two }\\n    }\\n    \\n    fn calc_hash(&self) -> usize {\\n        let mut res = self.ind;\\n        res *= 21;\\n        res += self.num_chars;\\n        res *= 2;\\n        res += (self.lower as usize);\\n        res *= 2;\\n        res += (self.upper as usize);\\n        res *= 2;\\n        res += (self.digit as usize);\\n        res *= 1+2*256;\\n        res += match self.last_two {\\n            Empty => 0,\\n            Alone(ch) => 1+(ch as usize),\\n            Double(ch) => 257+(ch as usize)\\n        };\\n        res\\n    }\\n}\\n\\nfn add_char_to_info(info: Info, ch: char, new_cost: usize, new_ind: usize) -> Option<Info> {\\n    if info.last_two == Double(ch) || info.num_chars >= 20 { return None; }\\n    \\n    let new_lower = info.lower || ch.is_ascii_lowercase();\\n    let new_upper = info.upper || ch.is_ascii_uppercase();\\n    let new_digit = info.digit || ch.is_ascii_digit();\\n    Some(Info::new(new_cost, new_ind, info.num_chars+1, new_lower, new_upper, new_digit, upd(info.last_two, ch)))\\n}\\n\\nfn add_new_info(s: &mut [bool], h: &mut VecDeque<Info>, chars: &[char], mut info: Info) {\\n    loop {\\n        let hash = info.calc_hash();\\n        if !s[hash] {\\n            s[hash] = true;\\n            h.push_back(info);\\n            \\n            //Once we hit chars.len(), there are no more type 1 edges\\n            if info.ind >= chars.len() {\\n                break;\\n            }\\n            //If we can traverse an edge type 1 here, traverse that edge immediately\\n            //i.e. set info to new_info so new_info gets added to the queue on the next loop iteration\\n            if let Some(new_info) = add_char_to_info(info, chars[info.ind], info.cost, info.ind+1) {\\n                info = new_info;\\n            }\\n            else { break; }\\n        } else {\\n            break;\\n        }\\n    }\\n}\\n\\nfn add_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char, new_cost: usize, new_ind: usize) -> bool {\\n    if let Some(new_info) = add_char_to_info(info, ch, new_cost, new_ind) {\\n        add_new_info(&mut s, &mut h, chars, new_info);\\n        true\\n    } else { false }\\n}\\n\\nfn change_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if ch == chars[info.ind] || (info.ind+1 < chars.len() && ch == chars[info.ind+1]) {\\n        return false;\\n    }\\n\\n    add_char(&mut s, &mut h, chars, info, ch, info.cost+1, info.ind+1)\\n}\\n\\nfn insert_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if info.ind < chars.len() && ch == chars[info.ind] {\\n        return false;\\n    }\\n    \\n    add_char(&mut s, &mut h, chars, info, ch, info.cost+1, info.ind)\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let chars: Vec<char> = password.chars().collect();\\n        \\n        let mut min_cost: Vec<bool> = vec![false; (chars.len()+1)*21*2*2*2*(1+2*256)];\\n        let mut heap: VecDeque<Info> = VecDeque::new();\\n        \\n        add_new_info(&mut min_cost, &mut heap, &chars, Info::new(0, 0, 0, false, false, false, Empty));\\n        \\n        while let Some(info) = heap.pop_front() {\\n            if info.ind == chars.len() && info.num_chars >= 6 && info.lower && info.upper && info.digit {\\n                return info.cost as i32;\\n            }\\n            \\n            if info.ind < chars.len() {\\n                //Edge type 2 (i.e. delete character)\\n                add_new_info(&mut min_cost, &mut heap, &chars, Info::new(info.cost+1, info.ind+1, info.num_chars, info.lower, info.upper, info.digit, info.last_two));\\n                \\n                //Edge type 4 (i.e. replace char): lowercase\\n                for ch in (\\'a\\'..=\\'z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: uppercase\\n                for ch in (\\'A\\'..=\\'Z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: digit\\n                for ch in (\\'0\\'..=\\'9\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n            }\\n            \\n            //Edge type 3 (i.e. insert char): lowercase\\n            for ch in (\\'a\\'..=\\'z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: uppercase\\n            for ch in (\\'A\\'..=\\'Z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: digit\\n            for ch in (\\'0\\'..=\\'9\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n        }\\n        panic!(\"No answer found!\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nenum LastTwo {\\n    Empty,\\n    Alone(char),\\n    Double(char)\\n}\\nuse LastTwo::*;\\n\\nfn upd(lt: LastTwo, c: char) -> LastTwo {\\n    if lt == Alone(c) || lt == Double(c) {\\n        Double(c)\\n    } else {\\n        Alone(c)\\n    }\\n}\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nstruct Info {\\n    cost: Reverse<usize>,\\n    ind: usize,\\n    num_chars: usize,\\n    lower: bool,\\n    upper: bool,\\n    digit: bool,\\n    last_two: LastTwo\\n}\\n\\nimpl Info {\\n    fn new(cost: Reverse<usize>, ind: usize, num_chars: usize, lower: bool, upper: bool, digit: bool, last_two: LastTwo) -> Info {\\n        Info { cost, ind, num_chars, lower, upper, digit, last_two }\\n    }\\n    \\n    fn calc_hash(&self) -> usize {\\n        let mut res = self.ind;\\n        res *= 21;\\n        res += self.num_chars;\\n        res *= 2;\\n        res += (self.lower as usize);\\n        res *= 2;\\n        res += (self.upper as usize);\\n        res *= 2;\\n        res += (self.digit as usize);\\n        res *= 1+2*256;\\n        res += match self.last_two {\\n            Empty => 0,\\n            Alone(ch) => 1+(ch as usize),\\n            Double(ch) => 257+(ch as usize)\\n        };\\n        res\\n    }\\n}\\n\\nfn inc_rev(x: Reverse<usize>) -> Reverse<usize> {\\n    Reverse(x.0+1)\\n}\\n\\nfn add_new_info(s: &mut [Option<usize>], h: &mut BinaryHeap<Info>, info: Info) {\\n    let hash = info.calc_hash();\\n    let should_insert = match s[hash] {\\n        None => true,\\n        Some(c) => info.cost.0 < c\\n    };\\n    if should_insert {\\n        s[hash] = Some(info.cost.0);\\n        h.push(info);\\n    }\\n}\\n\\nfn add_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, info: Info, ch: char, new_cost: Reverse<usize>, new_ind: usize) -> bool {\\n    let new_lower = info.lower || ch.is_ascii_lowercase();\\n    let new_upper = info.upper || ch.is_ascii_uppercase();\\n    let new_digit = info.digit || ch.is_ascii_digit();\\n    if info.last_two != Double(ch) && info.num_chars < 20 {\\n        add_new_info(&mut s, &mut h, Info::new(new_cost, new_ind, info.num_chars+1, new_lower, new_upper, new_digit, upd(info.last_two, ch)));\\n        true\\n    } else { false }\\n}\\n\\nfn change_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if ch == chars[info.ind] || (info.ind+1 < chars.len() && ch == chars[info.ind+1]) {\\n        return false;\\n    }\\n\\n    add_char(&mut s, &mut h, info, ch, inc_rev(info.cost), info.ind+1)\\n}\\n\\nfn insert_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if info.ind < chars.len() && ch == chars[info.ind] {\\n        return false;\\n    }\\n    \\n    add_char(&mut s, &mut h, info, ch, inc_rev(info.cost), info.ind)\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let chars: Vec<char> = password.chars().collect();\\n        \\n        let mut min_cost: Vec<Option<usize>> = vec![None; (chars.len()+1)*21*2*2*2*(1+2*256)];\\n        let mut heap: BinaryHeap<Info> = BinaryHeap::new();\\n        \\n        add_new_info(&mut min_cost, &mut heap, Info::new(Reverse(0), 0, 0, false, false, false, Empty));\\n        \\n        while let Some(info) = heap.pop() {\\n            if let Some(c) = min_cost[info.calc_hash()] {\\n                if c < info.cost.0 {\\n                    continue;\\n                }\\n            }\\n            \\n            if info.ind == chars.len() && info.num_chars >= 6 && info.lower && info.upper && info.digit {\\n                return info.cost.0 as i32;\\n            }\\n            \\n            if info.ind < chars.len() {\\n                //Edge type 1 (i.e. change nothing)\\n                add_char(&mut min_cost, &mut heap, info, chars[info.ind], info.cost, info.ind+1);\\n                \\n                //Edge type 2 (i.e. delete character)\\n                add_new_info(&mut min_cost, &mut heap, Info::new(inc_rev(info.cost), info.ind+1, info.num_chars, info.lower, info.upper, info.digit, info.last_two));\\n                \\n                //Edge type 4 (i.e. replace char): lowercase\\n                for ch in (\\'a\\'..=\\'z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: uppercase\\n                for ch in (\\'A\\'..=\\'Z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: digit\\n                for ch in (\\'0\\'..=\\'9\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n            }\\n            \\n            //Edge type 3 (i.e. insert char): lowercase\\n            for ch in (\\'a\\'..=\\'z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: uppercase\\n            for ch in (\\'A\\'..=\\'Z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: digit\\n            for ch in (\\'0\\'..=\\'9\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n        }\\n        panic!(\"No answer found!\");\\n    }\\n}\\n```\n```\\nuse std::collections::VecDeque;\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nenum LastTwo {\\n    Empty,\\n    Alone(char),\\n    Double(char)\\n}\\nuse LastTwo::*;\\n\\nfn upd(lt: LastTwo, c: char) -> LastTwo {\\n    if lt == Alone(c) || lt == Double(c) {\\n        Double(c)\\n    } else {\\n        Alone(c)\\n    }\\n}\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nstruct Info {\\n    cost: usize,\\n    ind: usize,\\n    num_chars: usize,\\n    lower: bool,\\n    upper: bool,\\n    digit: bool,\\n    last_two: LastTwo\\n}\\n\\nimpl Info {\\n    fn new(cost: usize, ind: usize, num_chars: usize, lower: bool, upper: bool, digit: bool, last_two: LastTwo) -> Info {\\n        Info { cost, ind, num_chars, lower, upper, digit, last_two }\\n    }\\n    \\n    fn calc_hash(&self) -> usize {\\n        let mut res = self.ind;\\n        res *= 21;\\n        res += self.num_chars;\\n        res *= 2;\\n        res += (self.lower as usize);\\n        res *= 2;\\n        res += (self.upper as usize);\\n        res *= 2;\\n        res += (self.digit as usize);\\n        res *= 1+2*256;\\n        res += match self.last_two {\\n            Empty => 0,\\n            Alone(ch) => 1+(ch as usize),\\n            Double(ch) => 257+(ch as usize)\\n        };\\n        res\\n    }\\n}\\n\\nfn add_char_to_info(info: Info, ch: char, new_cost: usize, new_ind: usize) -> Option<Info> {\\n    if info.last_two == Double(ch) || info.num_chars >= 20 { return None; }\\n    \\n    let new_lower = info.lower || ch.is_ascii_lowercase();\\n    let new_upper = info.upper || ch.is_ascii_uppercase();\\n    let new_digit = info.digit || ch.is_ascii_digit();\\n    Some(Info::new(new_cost, new_ind, info.num_chars+1, new_lower, new_upper, new_digit, upd(info.last_two, ch)))\\n}\\n\\nfn add_new_info(s: &mut [bool], h: &mut VecDeque<Info>, chars: &[char], mut info: Info) {\\n    loop {\\n        let hash = info.calc_hash();\\n        if !s[hash] {\\n            s[hash] = true;\\n            h.push_back(info);\\n            \\n            //Once we hit chars.len(), there are no more type 1 edges\\n            if info.ind >= chars.len() {\\n                break;\\n            }\\n            //If we can traverse an edge type 1 here, traverse that edge immediately\\n            //i.e. set info to new_info so new_info gets added to the queue on the next loop iteration\\n            if let Some(new_info) = add_char_to_info(info, chars[info.ind], info.cost, info.ind+1) {\\n                info = new_info;\\n            }\\n            else { break; }\\n        } else {\\n            break;\\n        }\\n    }\\n}\\n\\nfn add_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char, new_cost: usize, new_ind: usize) -> bool {\\n    if let Some(new_info) = add_char_to_info(info, ch, new_cost, new_ind) {\\n        add_new_info(&mut s, &mut h, chars, new_info);\\n        true\\n    } else { false }\\n}\\n\\nfn change_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if ch == chars[info.ind] || (info.ind+1 < chars.len() && ch == chars[info.ind+1]) {\\n        return false;\\n    }\\n\\n    add_char(&mut s, &mut h, chars, info, ch, info.cost+1, info.ind+1)\\n}\\n\\nfn insert_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if info.ind < chars.len() && ch == chars[info.ind] {\\n        return false;\\n    }\\n    \\n    add_char(&mut s, &mut h, chars, info, ch, info.cost+1, info.ind)\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let chars: Vec<char> = password.chars().collect();\\n        \\n        let mut min_cost: Vec<bool> = vec![false; (chars.len()+1)*21*2*2*2*(1+2*256)];\\n        let mut heap: VecDeque<Info> = VecDeque::new();\\n        \\n        add_new_info(&mut min_cost, &mut heap, &chars, Info::new(0, 0, 0, false, false, false, Empty));\\n        \\n        while let Some(info) = heap.pop_front() {\\n            if info.ind == chars.len() && info.num_chars >= 6 && info.lower && info.upper && info.digit {\\n                return info.cost as i32;\\n            }\\n            \\n            if info.ind < chars.len() {\\n                //Edge type 2 (i.e. delete character)\\n                add_new_info(&mut min_cost, &mut heap, &chars, Info::new(info.cost+1, info.ind+1, info.num_chars, info.lower, info.upper, info.digit, info.last_two));\\n                \\n                //Edge type 4 (i.e. replace char): lowercase\\n                for ch in (\\'a\\'..=\\'z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: uppercase\\n                for ch in (\\'A\\'..=\\'Z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: digit\\n                for ch in (\\'0\\'..=\\'9\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n            }\\n            \\n            //Edge type 3 (i.e. insert char): lowercase\\n            for ch in (\\'a\\'..=\\'z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: uppercase\\n            for ch in (\\'A\\'..=\\'Z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: digit\\n            for ch in (\\'0\\'..=\\'9\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n        }\\n        panic!(\"No answer found!\");\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91010,
                "title": "short-and-clear-javascript-solution-works-for-different-password-requirements",
                "content": "```\\nvar strongPasswordChecker = function(s, a = 6, b = 20, c = 3) {\\n    const clusters = buildClusters(s, c);\\n    for (let i = 0; i < s.length - b && clusters.minReplaceCount; i++) {\\n        deleteOne(clusters, c);\\n    }\\n    const mustAddCount = !/[a-z]/.test(s) + !/[A-Z]/.test(s) + !/\\\\d/.test(s);\\n    return Math.max(0, s.length - b) + Math.max(a - s.length, mustAddCount, clusters.minReplaceCount);\\n};\\n\\nfunction buildClusters(s, c) {\\n    const clusters = new Array(c).fill(0).map(cl => new Map());\\n    clusters.minReplaceCount = 0;\\n    let re = new RegExp(`(.)\\\\\\\\1{${c - 1},}`, 'g'), match;\\n    while (match = re.exec(s)) {\\n        let len = match[0].length;\\n        clusters[len % c].set(len, (clusters[len % c].get(len) || 0) + 1);\\n        clusters.minReplaceCount += Math.floor(len / c);\\n    }\\n    return clusters;\\n}\\n\\nfunction deleteOne(clusters, c) {\\n    const cluster = clusters.find(cl => cl.size);\\n    for (const [len, count] of cluster) {\\n        cluster.set(len, count - 1);\\n        if (count === 1) cluster.delete(len);\\n        clusters.minReplaceCount -= len % c === 0;\\n        if (len === c) break;\\n        const clusterUpdate = clusters[(len - 1) % c];\\n        clusterUpdate.set(len - 1, (clusterUpdate.get(len - 1) || 0) + 1);\\n        break;\\n    }\\n}\\n```\\nThe answer for `s.length <= b` is straightforward since we needn't make any deletions. It's covered by `Math.max(a - s.length, mustAddCount, clusters.minReplaceCount)` whose components I explain soon.\\n\\nFor `s.length > b` we need to make `s.length - b` deletions, followed by the requisite replacements to satisfy condition #2. However, we must make our deletions prioritizing repeating character clusters which have the smallest length modulo `c`. This is because clusters divisible by `c` will reduce the number of replacements necessary to uncluster them (satisfy condition #3). For example, deleting one character from either of `'aaa'` or `'aaaaaa'` for `c = 3` decrements the necessary replacements, from `1->0` and `2->1` respectively.\\n\\nWe store maps of each cluster type (its length modulo `c`) in the `clusters` array. `clusters.minReplaceCount` tracks the minimum number of replacements to satisfy condition #3 over all clusters. Finally, `mustAddCount` tracks the replacements necessary to satisfy condition #2.\\n\\nThe complexity is O(1) time and space when `s.length <= b` and O(n) time with O(count(clusters)) space when `s.length > b`. Even though `c` is a parameter, we can treat it as a constant with respect to time complexity since c * min(n - b, count(clusters)) is bounded by n (`s.length`).",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strongPasswordChecker = function(s, a = 6, b = 20, c = 3) {\\n    const clusters = buildClusters(s, c);\\n    for (let i = 0; i < s.length - b && clusters.minReplaceCount; i++) {\\n        deleteOne(clusters, c);\\n    }\\n    const mustAddCount = !/[a-z]/.test(s) + !/[A-Z]/.test(s) + !/\\\\d/.test(s);\\n    return Math.max(0, s.length - b) + Math.max(a - s.length, mustAddCount, clusters.minReplaceCount);\\n};\\n\\nfunction buildClusters(s, c) {\\n    const clusters = new Array(c).fill(0).map(cl => new Map());\\n    clusters.minReplaceCount = 0;\\n    let re = new RegExp(`(.)\\\\\\\\1{${c - 1},}`, 'g'), match;\\n    while (match = re.exec(s)) {\\n        let len = match[0].length;\\n        clusters[len % c].set(len, (clusters[len % c].get(len) || 0) + 1);\\n        clusters.minReplaceCount += Math.floor(len / c);\\n    }\\n    return clusters;\\n}\\n\\nfunction deleteOne(clusters, c) {\\n    const cluster = clusters.find(cl => cl.size);\\n    for (const [len, count] of cluster) {\\n        cluster.set(len, count - 1);\\n        if (count === 1) cluster.delete(len);\\n        clusters.minReplaceCount -= len % c === 0;\\n        if (len === c) break;\\n        const clusterUpdate = clusters[(len - 1) % c];\\n        clusterUpdate.set(len - 1, (clusterUpdate.get(len - 1) || 0) + 1);\\n        break;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026154,
                "title": "c-java-c-c-python",
                "content": "Read Full Article with explaination : https://bit.ly/strong-password-checker",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 357454,
                "title": "java-0ms-o-n-solution-with-video-in-chinese",
                "content": "Video:\\nhttps://youtu.be/bk0Uh0phzG8 \\n```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int len = s.length();\\n        int needTypes = missingTypes(s);\\n        List<Integer> repeatLens = countRepeat(s);\\n        if(len < 6) {\\n            return Math.max(needTypes, 6 - len);\\n        }\\n        else if(len >= 6 && len <= 20) {\\n            int swapCount = 0;\\n            for(int l : repeatLens) swapCount += l / 3;\\n            return Math.max(needTypes, swapCount);\\n        }\\n        else {\\n            int needRemove = len - 20;\\n            int idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                if(l % 3 == 0) {\\n                    needRemove -= 1;\\n                    repeatLens.set(idx, l - 1);\\n                }\\n                idx += 1;\\n            }\\n            idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                if(l % 3 == 1 && needRemove > 1) {\\n                    needRemove -= 2;\\n                    repeatLens.set(idx, l - 2);\\n                }\\n                idx += 1;\\n            }\\n            idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                while(l >= 3 && needRemove >= 3) {\\n                    l -= 3;\\n                    needRemove -= 3;\\n                }\\n                repeatLens.set(idx, l);\\n                idx += 1;\\n            }\\n            int swapCount = 0;\\n            for(int l : repeatLens) swapCount += l / 3;\\n            return Math.max(needTypes, swapCount) + len - 20;\\n            \\n        }\\n    }\\n    \\n    private int missingTypes(String s) {\\n        int needUpper = 1, needLower = 1, needNum = 1;\\n        for(char c : s.toCharArray()) {\\n            if(c >= \\'a\\' && c <= \\'z\\') needLower = 0;\\n            if(c >= \\'A\\' && c <= \\'Z\\') needUpper = 0;\\n            if(c >= \\'0\\' && c <= \\'9\\') needNum = 0;\\n        }\\n        return needUpper + needLower + needNum;\\n    }\\n    \\n    private List<Integer> countRepeat(String s) {\\n        List<Integer> list = new ArrayList<>();\\n        int idx = 1;\\n        int count = 1;\\n        while(idx < s.length()) {\\n            if(s.charAt(idx) == s.charAt(idx - 1)) count += 1;\\n            else {\\n                if(count >= 3) list.add(count);\\n                count = 1;\\n            }\\n            idx++;\\n        }\\n        if(count >= 3) list.add(count);\\n        return list;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int len = s.length();\\n        int needTypes = missingTypes(s);\\n        List<Integer> repeatLens = countRepeat(s);\\n        if(len < 6) {\\n            return Math.max(needTypes, 6 - len);\\n        }\\n        else if(len >= 6 && len <= 20) {\\n            int swapCount = 0;\\n            for(int l : repeatLens) swapCount += l / 3;\\n            return Math.max(needTypes, swapCount);\\n        }\\n        else {\\n            int needRemove = len - 20;\\n            int idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                if(l % 3 == 0) {\\n                    needRemove -= 1;\\n                    repeatLens.set(idx, l - 1);\\n                }\\n                idx += 1;\\n            }\\n            idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                if(l % 3 == 1 && needRemove > 1) {\\n                    needRemove -= 2;\\n                    repeatLens.set(idx, l - 2);\\n                }\\n                idx += 1;\\n            }\\n            idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                while(l >= 3 && needRemove >= 3) {\\n                    l -= 3;\\n                    needRemove -= 3;\\n                }\\n                repeatLens.set(idx, l);\\n                idx += 1;\\n            }\\n            int swapCount = 0;\\n            for(int l : repeatLens) swapCount += l / 3;\\n            return Math.max(needTypes, swapCount) + len - 20;\\n            \\n        }\\n    }\\n    \\n    private int missingTypes(String s) {\\n        int needUpper = 1, needLower = 1, needNum = 1;\\n        for(char c : s.toCharArray()) {\\n            if(c >= \\'a\\' && c <= \\'z\\') needLower = 0;\\n            if(c >= \\'A\\' && c <= \\'Z\\') needUpper = 0;\\n            if(c >= \\'0\\' && c <= \\'9\\') needNum = 0;\\n        }\\n        return needUpper + needLower + needNum;\\n    }\\n    \\n    private List<Integer> countRepeat(String s) {\\n        List<Integer> list = new ArrayList<>();\\n        int idx = 1;\\n        int count = 1;\\n        while(idx < s.length()) {\\n            if(s.charAt(idx) == s.charAt(idx - 1)) count += 1;\\n            else {\\n                if(count >= 3) list.add(count);\\n                count = 1;\\n            }\\n            idx++;\\n        }\\n        if(count >= 3) list.add(count);\\n        return list;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91011,
                "title": "java-o-n-simple-solution",
                "content": "Repeating sequences like aaa with len % 3 == 0, we replace by deleting one character. For any repeating sequences aaaa with len % 3 == 1, we can reduce one replacement by deleting two character. For the rest, reduce every replacement by deleting three character.\\n\\nThis is my first post and pls do let me know if any errors or improvements. Thank you\\n\\n~~~\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        char [] str = s.toCharArray();\\n        boolean isUpper = false, isLower = false, isDigit = false;\\n        int missinType = 3;\\n        for(char c: str)\\n        {\\n            if(!isUpper && Character.isUpperCase(c)) { isUpper = true; missinType-=1; } //uppercase\\n            if(!isLower && Character.isLowerCase(c)) { isLower = true; missinType-=1; } //lowercase\\n            if(!isDigit && Character.isDigit(c)) { isDigit = true; missinType-=1; } //atleast one number\\n            \\n        }\\n       \\n        int totalChangeCnt = 0, OneChangeCnt =0, TwoChangeCnt =0, pos=2;\\n        while(pos < s.length())\\n        {\\n            if(str[pos]==str[pos-1] && str[pos-1]==str[pos-2] && str[pos-2]==str[pos])\\n            {\\n                int length = 2;\\n                while(pos < s.length() && str[pos]==str[pos-1])\\n                {\\n                    length += 1; pos +=1;\\n                }\\n                totalChangeCnt += length/3;\\n                if(length%3==0) OneChangeCnt += 1;\\n                else if(length%3==1) TwoChangeCnt += 1;\\n                \\n            }\\n            else\\n            {\\n                pos=pos+1;\\n            }\\n        }\\n        \\n        if(s.length()<6)\\n            return Math.max(missinType, 6-s.length());\\n        else if(s.length() <=20)\\n            return Math.max(missinType,totalChangeCnt );\\n        else\\n        {\\n            int deleteCount = s.length()-20;\\n            totalChangeCnt -= Math.min(deleteCount,OneChangeCnt*1)/1;\\n            totalChangeCnt -= Math.min(Math.max(deleteCount - OneChangeCnt, 0), TwoChangeCnt * 2) / 2;\\n            totalChangeCnt -= Math.max(deleteCount - OneChangeCnt - 2 * TwoChangeCnt, 0) / 3;\\n            \\n                \\n            return deleteCount + Math.max(missinType, totalChangeCnt);\\n        }       \\n    }\\n}\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        char [] str = s.toCharArray();\\n        boolean isUpper = false, isLower = false, isDigit = false;\\n        int missinType = 3;\\n        for(char c: str)\\n        {\\n            if(!isUpper && Character.isUpperCase(c)) { isUpper = true; missinType-=1; }",
                "codeTag": "Java"
            },
            {
                "id": 2933288,
                "title": "python-3-14-lines-w-brief-explanation-t-m-t-m-91-91",
                "content": "Here\\'s the plan:\\nWe divide the problem into three cases based on `n = len(password)`:\\n- Case 1: `n <   6` : We add enough chars to ensure 1a) the length of the password is greater than 6 and 1b) each category of chars (uppercase, lowercase, digit) are present. \\n- Case 2: `n >  20` : We eliminate `n - 20` chars starting with any triples (ex: \\'aaa\\'), which reduces this case to Case 3, which is...\\n- Case 3: `6 <= n <= 20` : We fix any triples and any missing categories of chars \\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n\\n        pSet, n = set(password), len(password)\\n\\n        catCt = 3- (bool(pSet & set(ascii_lowercase))+ \\n                    bool(pSet & set(ascii_uppercase))+\\n                    bool(pSet & set(\\'0123456789\\'   )))\\n\\n        if n <  6:  return max(6 - n, catCt)        # Case 1\\n\\n        repCt = [len(list(g)) for _, g in groupby(password)]\\n        repCt = [r for r in repCt if r > 2]\\n\\n        if n > 20:                                  # Case 2: reduce to 6<= n <= 20\\n                                                    #         by eliminating triples\\n            repCt = [(r%3, r) for r in repCt]\\n            heapify(repCt)\\n\\n            for i in range(n-20): \\n\\n                if not repCt: break\\n\\n                _, r = heappop(repCt)\\n                if r > 3: heappush(repCt, ((r-1)%3, r-1))\\n\\n            repCt = [r for _,r in repCt]\\n \\n        return max(catCt, sum(r//3 for r in repCt))+max(0,n-20)   # Case3\\n```\\n[https://leetcode.com/problems/strong-password-checker/submissions/862809225/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n\\n        pSet, n = set(password), len(password)\\n\\n        catCt = 3- (bool(pSet & set(ascii_lowercase))+ \\n                    bool(pSet & set(ascii_uppercase))+\\n                    bool(pSet & set(\\'0123456789\\'   )))\\n\\n        if n <  6:  return max(6 - n, catCt)        # Case 1\\n\\n        repCt = [len(list(g)) for _, g in groupby(password)]\\n        repCt = [r for r in repCt if r > 2]\\n\\n        if n > 20:                                  # Case 2: reduce to 6<= n <= 20\\n                                                    #         by eliminating triples\\n            repCt = [(r%3, r) for r in repCt]\\n            heapify(repCt)\\n\\n            for i in range(n-20): \\n\\n                if not repCt: break\\n\\n                _, r = heappop(repCt)\\n                if r > 3: heappush(repCt, ((r-1)%3, r-1))\\n\\n            repCt = [r for _,r in repCt]\\n \\n        return max(catCt, sum(r//3 for r in repCt))+max(0,n-20)   # Case3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315078,
                "title": "strong-password-easy-to-understand-bfs-solution",
                "content": "```\\nclass Solution {\\n    enum class FixType {\\n        REPLACE = 0,\\n        INSERT = 1,\\n        DELETE = 2\\n    };\\n\\n    struct Problems {\\n        int length = 0;\\n        int missing_chars = 0;\\n        std::vector< int > repeats;\\n        \\n        bool empty() const {\\n            return ( length >= 6 && length <= 20 ) && !missing_chars && repeats.empty();\\n        }\\n        \\n        bool apply( FixType fix_type ) {\\n            if( length <= 6 && fix_type == FixType::DELETE ) {\\n                return false;\\n            }\\n            if( length >= 20 && fix_type == FixType::INSERT ) {\\n                return false;\\n            }\\n            \\n            // Insert and Delete affects the length\\n            bool applied = fix_type != FixType::REPLACE;\\n            if( missing_chars && fix_type != FixType::DELETE ) {\\n                missing_chars--;\\n                applied = true;\\n            }\\n            \\n            int repeat = 0;\\n            if( !repeats.empty() ) {\\n                repeat = repeats.back();\\n                repeats.pop_back();\\n                applied = true;\\n            } \\n            switch( fix_type ) {\\n                case FixType::REPLACE:\\n                    // [R,R,#,...]\\n                    repeat -= 3;\\n                    break;\\n                case FixType::INSERT:\\n                    // [R,R,#,R...]\\n                    repeat -= 2;\\n                    length += 1;\\n                    break;\\n                case FixType::DELETE:\\n                    // [R,R,...]\\n                    repeat -= 1;\\n                    length -= 1;\\n                    break;\\n            }\\n            if( repeat >= 3 ) {\\n                repeats.push_back( repeat );\\n            }\\n            return applied;\\n        }\\n    };\\n    \\npublic:\\n    int strongPasswordChecker( const std::string & s ) {\\n        std::queue< Problems > queue( { getProblems( s ) } );\\n        int level = 0;\\n        \\n        while( !queue.empty() ) {\\n            int level_size = queue.size();\\n            for( int i = 0; i < level_size; i++ ) {\\n                Problems problems = queue.front();\\n                queue.pop();\\n                \\n                if( problems.empty() ) {\\n                    return level;\\n                }\\n\\n                for( const FixType & fix_type : { FixType::REPLACE, FixType::INSERT, FixType::DELETE } ) {\\n                    Problems fixed = problems;\\n                    if( fixed.apply( fix_type ) ) {\\n                        queue.push( fixed );\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    \\nprivate:\\n    Problems getProblems( const std::string & s ) {\\n        Problems problems;\\n        int digit = 1;\\n        int lower = 1;\\n        int upper = 1;\\n        for( int i = 0; i < s.size(); ) {\\n            int pos = i;\\n            while( i < s.size() && s[ pos ] == s[ i ] ) {\\n                i++;\\n            }\\n            int length = i - pos;\\n            if( length >= 3 ) {\\n                problems.repeats.push_back( length );\\n            }\\n            \\n            if( std::isdigit( s[ pos ] ) ) {\\n                digit = 0;\\n            }\\n            else if( std::islower( s[ pos ] ) ) {\\n                lower = 0;\\n            }\\n            else if( std::isupper( s[ pos ] ) ) {\\n                upper = 0;\\n            }\\n            problems.length += length;\\n        }\\n        problems.missing_chars = digit + lower + upper;\\n        return problems;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    enum class FixType {\\n        REPLACE = 0,\\n        INSERT = 1,\\n        DELETE = 2\\n    };\\n\\n    struct Problems {\\n        int length = 0;\\n        int missing_chars = 0;\\n        std::vector< int > repeats;\\n        \\n        bool empty() const {\\n            return ( length >= 6 && length <= 20 ) && !missing_chars && repeats.empty();\\n        }\\n        \\n        bool apply( FixType fix_type ) {\\n            if( length <= 6 && fix_type == FixType::DELETE ) {\\n                return false;\\n            }\\n            if( length >= 20 && fix_type == FixType::INSERT ) {\\n                return false;\\n            }\\n            \\n            // Insert and Delete affects the length\\n            bool applied = fix_type != FixType::REPLACE;\\n            if( missing_chars && fix_type != FixType::DELETE ) {\\n                missing_chars--;\\n                applied = true;\\n            }\\n            \\n            int repeat = 0;\\n            if( !repeats.empty() ) {\\n                repeat = repeats.back();\\n                repeats.pop_back();\\n                applied = true;\\n            } \\n            switch( fix_type ) {\\n                case FixType::REPLACE:\\n                    // [R,R,#,...]\\n                    repeat -= 3;\\n                    break;\\n                case FixType::INSERT:\\n                    // [R,R,#,R...]\\n                    repeat -= 2;\\n                    length += 1;\\n                    break;\\n                case FixType::DELETE:\\n                    // [R,R,...]\\n                    repeat -= 1;\\n                    length -= 1;\\n                    break;\\n            }\\n            if( repeat >= 3 ) {\\n                repeats.push_back( repeat );\\n            }\\n            return applied;\\n        }\\n    };\\n    \\npublic:\\n    int strongPasswordChecker( const std::string & s ) {\\n        std::queue< Problems > queue( { getProblems( s ) } );\\n        int level = 0;\\n        \\n        while( !queue.empty() ) {\\n            int level_size = queue.size();\\n            for( int i = 0; i < level_size; i++ ) {\\n                Problems problems = queue.front();\\n                queue.pop();\\n                \\n                if( problems.empty() ) {\\n                    return level;\\n                }\\n\\n                for( const FixType & fix_type : { FixType::REPLACE, FixType::INSERT, FixType::DELETE } ) {\\n                    Problems fixed = problems;\\n                    if( fixed.apply( fix_type ) ) {\\n                        queue.push( fixed );\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    \\nprivate:\\n    Problems getProblems( const std::string & s ) {\\n        Problems problems;\\n        int digit = 1;\\n        int lower = 1;\\n        int upper = 1;\\n        for( int i = 0; i < s.size(); ) {\\n            int pos = i;\\n            while( i < s.size() && s[ pos ] == s[ i ] ) {\\n                i++;\\n            }\\n            int length = i - pos;\\n            if( length >= 3 ) {\\n                problems.repeats.push_back( length );\\n            }\\n            \\n            if( std::isdigit( s[ pos ] ) ) {\\n                digit = 0;\\n            }\\n            else if( std::islower( s[ pos ] ) ) {\\n                lower = 0;\\n            }\\n            else if( std::isupper( s[ pos ] ) ) {\\n                upper = 0;\\n            }\\n            problems.length += length;\\n        }\\n        problems.missing_chars = digit + lower + upper;\\n        return problems;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445690,
                "title": "python-faster-than-99",
                "content": "Similar to other solutions, we can handle this problem with 3 cases:\\nCase 1: len(password) < 6\\nIn this case, we don\\'t need to worry about the repeating characters, because we can insert characters to break it. Let \"missing\" represents the missing types, lower character, upper character, and digits, then,\\nresult = max(missing, 6-len(password))\\n\\nCase 2: 6 <= len(password) <= 20\\nIn this case, every issue can be addressed by replacement. In addition to the missing types, we need to address repeating characters. We can easily find that, when the length of repeating characters is 3, 4, or 5, we need to replace 1 character to resolve it; when the length of repeating character is 6, 7, 8, we need to replace 2 characters, and so on. So, we can keep track of the length of repeating characters, for example:\\npassword = \"bbbccccaaaaaa\"\\nrepeating = [3, 4, 6]\\nand then, \\nreplacement = [1, 1, 2]\\nresult = max(missing, sum(replacement))\\n\\nCase 3: len(password) > 20\\nWe need to delete some characters, and then the problem become case 2. We cannot address missing types with deletion, but we can decide the \"repeating\" array in case 2, so we can minimize the steps. The idea is, for the length in \"repeating\" array:\\nwhen the length%3 == 0, if we decrease lengh by 1, the replacement decreases by 1;\\nwhen the length%3 == 1, we need to decrease length by 2, so that the replacement decreases by 1;\\nwhen the length%3 == 2, we need to decrease length by 3, so that the replacement decreases by 1;\\nSo, in the \"repeating\" array, we first decrease length%3==0, then length%3==1, and lastly length%2 == 2.\\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        lower = any(\\'a\\' <= c <= \\'z\\' for c in password)\\n        upper = any(\\'A\\' <= c <= \\'Z\\' for c in password)\\n        digit = any(c.isdigit() for c in password)\\n        missing = 3 - int(lower) - int(upper) - int(digit)\\n        \\n        # case 1: len < 6\\n        if len(password) < 6:\\n            return max(missing, 6-len(password))\\n        \\n        # case 2: 6 <= len <= 20\\n        i = 2\\n        repeating = []\\n        while i < len(password):\\n            repeat = 2\\n            while i < len(password) and password[i] == password[i-1] == password[i-2]:\\n                repeat += 1\\n                i += 1\\n            if repeat > 2:\\n                repeating.append(repeat)\\n            i += 1\\n        \\n        if len(password) <= 20:\\n            replace = 0\\n            for repeat in repeating:\\n                replace += (repeat // 3)\\n            return max(missing, replace)\\n        \\n        # case 3: len > 20\\n        repeating = [(i%3, i) for i in repeating]\\n        heapq.heapify(repeating)\\n        for i in range(len(password)-20):\\n            if not repeating:\\n                break\\n            length_mod_3, length = heapq.heappop(repeating)\\n            if length-1 >= 3:\\n                heapq.heappush(repeating, ((length-1)%3, length-1))\\n        repeating = [i[1] for i in repeating]\\n        \\n        replace = 0\\n        for repeat in repeating:\\n            replace += (repeat // 3)\\n        return max(missing, replace)+(len(password)-20)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        lower = any(\\'a\\' <= c <= \\'z\\' for c in password)\\n        upper = any(\\'A\\' <= c <= \\'Z\\' for c in password)\\n        digit = any(c.isdigit() for c in password)\\n        missing = 3 - int(lower) - int(upper) - int(digit)\\n        \\n        # case 1: len < 6\\n        if len(password) < 6:\\n            return max(missing, 6-len(password))\\n        \\n        # case 2: 6 <= len <= 20\\n        i = 2\\n        repeating = []\\n        while i < len(password):\\n            repeat = 2\\n            while i < len(password) and password[i] == password[i-1] == password[i-2]:\\n                repeat += 1\\n                i += 1\\n            if repeat > 2:\\n                repeating.append(repeat)\\n            i += 1\\n        \\n        if len(password) <= 20:\\n            replace = 0\\n            for repeat in repeating:\\n                replace += (repeat // 3)\\n            return max(missing, replace)\\n        \\n        # case 3: len > 20\\n        repeating = [(i%3, i) for i in repeating]\\n        heapq.heapify(repeating)\\n        for i in range(len(password)-20):\\n            if not repeating:\\n                break\\n            length_mod_3, length = heapq.heappop(repeating)\\n            if length-1 >= 3:\\n                heapq.heappush(repeating, ((length-1)%3, length-1))\\n        repeating = [i[1] for i in repeating]\\n        \\n        replace = 0\\n        for repeat in repeating:\\n            replace += (repeat // 3)\\n        return max(missing, replace)+(len(password)-20)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919927,
                "title": "python-backtracking-performance-98-99-20ms",
                "content": "Consider the three requirements:\\n+ length of password\\n+ lowercase, uppercase, digit\\n+ no 3 consecutive characters.\\n\\nThe effect of the three changes:\\n+ Insertion: \\n  + `num_passwd+1`; \\n  +  one of `{lowercase, uppercase, digit}` will be met;\\n  +  insert a char every two consective chars to split the substring, e.g., `aaaaa -> aaAaaa -> aaAaa1a`.\\n+ Deletion: \\n  + num_passwd-1;\\n  + deletion cannot split consecutive chars., i.e., `aaaaa -> aaaa -> aaa`.\\n+ Replace: \\n  + one of {lowercase, uppercase, digit} will be met;\\n  + change a char every two consective chars to split the substring, e.g., `aaaaa -> aaAaa`.\\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        len_passwd = len(s)\\n        lowercase, uppercase, digit = False, False, False\\n        repeating = []  # list of interval of consecutive char.\\n        for idx, char in enumerate(s):\\n            if not lowercase and 97 <= ord(char) <= 122:\\n                lowercase = True\\n            if not uppercase and 65 <= ord(char) <= 90:\\n                uppercase = True\\n            if not digit and char in {\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\'}:\\n                digit = True\\n            if repeating and repeating[-1][1]+1 == idx and s[repeating[-1][1]] == s[idx]:\\n                repeating[-1][1] = idx  # extend the lastest interval\\n            if 0 < idx < len_passwd - 1 and s[idx-1] == s[idx] == s[idx+1] and (not repeating or idx > repeating[-1][1]):\\n                repeating.append([idx-1, idx+1])  # new an interval\\n\\n        @lru_cache(None)\\n        def helper(lenpass, case, repeat):\\n            if 6 <= lenpass <= 20 and case == 3 and repeat == ():\\n                return 0\\n            ans = inf\\n\\t\\t\\t\\n            if lenpass < 6:\\n                # Insertion\\n                if repeat:\\n                    add_repeat = [repeat[0]-2] if repeat[0] > 4 else []\\n                    ans = min(ans, helper(lenpass + 1, min(case + 1, 3), tuple(list(repeat[1:]) + add_repeat)))\\n                else:\\n                    ans = helper(lenpass + 1, min(case + 1, 3), ())\\n            elif lenpass > 20:\\n                # Deletion\\n                if repeat:\\n                    for i in range(len(repeat)):\\n                        repeat_del = list(repeat)\\n                        if repeat_del[i] > 3:\\n                            repeat_del[i] -= 1\\n                        else:\\n                            del repeat_del[i]\\n                        ans = min(ans, helper(lenpass - 1, case, tuple(repeat_del)))\\n                else:\\n                    ans = helper(lenpass - 1, case, ())\\n            else:\\n                # Replace\\n                if repeat:\\n                    add_repeat = [repeat[0]-3] if repeat[0] > 5 else []\\n                    ans = min(ans, helper(lenpass, min(case + 1, 3), tuple(list(repeat[1:]) + add_repeat)))\\n                else:\\n                    ans = helper(lenpass, min(case + 1, 3), ())\\n            return 1 + ans\\n\\n        return helper(len_passwd, sum([lowercase, uppercase, digit]), tuple([term[1]-term[0]+1 for term in repeating]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        len_passwd = len(s)\\n        lowercase, uppercase, digit = False, False, False\\n        repeating = []  # list of interval of consecutive char.\\n        for idx, char in enumerate(s):\\n            if not lowercase and 97 <= ord(char) <= 122:\\n                lowercase = True\\n            if not uppercase and 65 <= ord(char) <= 90:\\n                uppercase = True\\n            if not digit and char in {\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\'}:\\n                digit = True\\n            if repeating and repeating[-1][1]+1 == idx and s[repeating[-1][1]] == s[idx]:\\n                repeating[-1][1] = idx  # extend the lastest interval\\n            if 0 < idx < len_passwd - 1 and s[idx-1] == s[idx] == s[idx+1] and (not repeating or idx > repeating[-1][1]):\\n                repeating.append([idx-1, idx+1])  # new an interval\\n\\n        @lru_cache(None)\\n        def helper(lenpass, case, repeat):\\n            if 6 <= lenpass <= 20 and case == 3 and repeat == ():\\n                return 0\\n            ans = inf\\n\\t\\t\\t\\n            if lenpass < 6:\\n                # Insertion\\n                if repeat:\\n                    add_repeat = [repeat[0]-2] if repeat[0] > 4 else []\\n                    ans = min(ans, helper(lenpass + 1, min(case + 1, 3), tuple(list(repeat[1:]) + add_repeat)))\\n                else:\\n                    ans = helper(lenpass + 1, min(case + 1, 3), ())\\n            elif lenpass > 20:\\n                # Deletion\\n                if repeat:\\n                    for i in range(len(repeat)):\\n                        repeat_del = list(repeat)\\n                        if repeat_del[i] > 3:\\n                            repeat_del[i] -= 1\\n                        else:\\n                            del repeat_del[i]\\n                        ans = min(ans, helper(lenpass - 1, case, tuple(repeat_del)))\\n                else:\\n                    ans = helper(lenpass - 1, case, ())\\n            else:\\n                # Replace\\n                if repeat:\\n                    add_repeat = [repeat[0]-3] if repeat[0] > 5 else []\\n                    ans = min(ans, helper(lenpass, min(case + 1, 3), tuple(list(repeat[1:]) + add_repeat)))\\n                else:\\n                    ans = helper(lenpass, min(case + 1, 3), ())\\n            return 1 + ans\\n\\n        return helper(len_passwd, sum([lowercase, uppercase, digit]), tuple([term[1]-term[0]+1 for term in repeating]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482857,
                "title": "rust-0-ms-faster-than-100-00-2-mb-less-than-100-00",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Strong Password Checker.\\nMemory Usage: 2 MB, less than 100.00% of Rust online submissions for Strong Password Checker.\\n\\n```\\npub fn repeat_count(password:&String) -> Vec<i32>{\\n    let mut result = Vec::new();\\n    let mut currect = 1;\\n    for i in 0..password.len() - 1{\\n        if password[i..i+1] == password[i+1..i+2]{\\n            currect += 1;\\n        }\\n        else{\\n            if currect >= 3{\\n                result.push(currect);\\n            }\\n            currect = 1;\\n        }\\n    }\\n    if currect >= 3{\\n        result.push(currect);\\n    }\\n    result\\n}\\n\\npub fn replace_count(mut vec_count: Vec<i32>, mut del: i32, add: i32, rep: i32, sort_switch: bool) -> i32{\\n    if vec_count.len() == 0{\\n        return 0;\\n    }\\n    if sort_switch{\\n        vec_count.sort();\\n    }\\n    if add >= 2 || (add == 1 && rep == 1) || (add == 1 && rep == 0 && vec_count[0] < 5){\\n        return 0;\\n    }\\n    if add == 1 && rep == 0 && vec_count[0] == 5{\\n        return 1;\\n    }\\n    if del == 0{\\n        let mut result_count = 0;\\n        for i in vec_count{\\n            result_count += i / 3;\\n        }\\n        if result_count >= rep{\\n            return result_count - rep;\\n        }\\n        return 0;\\n    }\\n\\n    \\'loop1: for currcet_index in 1..=3{\\n        while del >= currcet_index && vec_count[0] == 2 + currcet_index{\\n            del -= currcet_index;\\n            vec_count.remove(0);\\n            if vec_count.len() == 0{\\n                return 0;\\n            }\\n        }\\n        if del < currcet_index{\\n            break;\\n        }\\n        for i in 0..vec_count.len(){\\n            while vec_count[i] % 3 == (currcet_index - 1){\\n                if vec_count[i] == 2 + currcet_index{\\n                    break;\\n                }\\n                vec_count[i] -= currcet_index;\\n                del -= currcet_index;\\n                if del < currcet_index{\\n                    break \\'loop1;\\n                }\\n            }\\n        }\\n    }\\n    let mut result_count = 0;\\n    for i in vec_count{\\n        result_count += i / 3;\\n    }\\n    if result_count >= rep{\\n        return result_count - rep;\\n    }\\n    return 0;\\n}\\n\\npub fn compu_type_count(password:&String) -> i32{\\n    let mut lower_case = 0;\\n    let mut upper_case=0;\\n    let mut digit = 0;\\n    let mut total = 0;\\n    for i in password.as_bytes(){\\n        if *i >= 48 && *i <= 57{\\n            if digit == 0{\\n                digit = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n        if *i >= 65 && *i <= 90{\\n            if upper_case == 0{\\n                upper_case = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n        if *i >= 97 && *i <= 122{\\n            if lower_case == 0{\\n                lower_case = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n    }\\n    return total;\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let new_length = password.len() as i32;\\n        if new_length > 20{\\n            let rep = 3 - compu_type_count(&password);\\n            let del = new_length - 20;\\n            let vec_count = repeat_count(&password);\\n            return rep + del + replace_count(vec_count, del, 0, rep, true);\\n        }\\n        else if new_length < 6{\\n            let add = 6 - new_length;\\n            let type_add = 3 - compu_type_count(&password);\\n            let rep = \\n            if type_add <= add{\\n                0\\n            }\\n            else{\\n                type_add - add\\n            };\\n            return add + rep + replace_count(repeat_count(&password), 0, add, rep, true);\\n        }\\n        else{\\n            let rep = 3 - compu_type_count(&password);\\n            let vec_count = repeat_count(&password);\\n            return rep + replace_count(vec_count, 0, 0, rep, true);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn repeat_count(password:&String) -> Vec<i32>{\\n    let mut result = Vec::new();\\n    let mut currect = 1;\\n    for i in 0..password.len() - 1{\\n        if password[i..i+1] == password[i+1..i+2]{\\n            currect += 1;\\n        }\\n        else{\\n            if currect >= 3{\\n                result.push(currect);\\n            }\\n            currect = 1;\\n        }\\n    }\\n    if currect >= 3{\\n        result.push(currect);\\n    }\\n    result\\n}\\n\\npub fn replace_count(mut vec_count: Vec<i32>, mut del: i32, add: i32, rep: i32, sort_switch: bool) -> i32{\\n    if vec_count.len() == 0{\\n        return 0;\\n    }\\n    if sort_switch{\\n        vec_count.sort();\\n    }\\n    if add >= 2 || (add == 1 && rep == 1) || (add == 1 && rep == 0 && vec_count[0] < 5){\\n        return 0;\\n    }\\n    if add == 1 && rep == 0 && vec_count[0] == 5{\\n        return 1;\\n    }\\n    if del == 0{\\n        let mut result_count = 0;\\n        for i in vec_count{\\n            result_count += i / 3;\\n        }\\n        if result_count >= rep{\\n            return result_count - rep;\\n        }\\n        return 0;\\n    }\\n\\n    \\'loop1: for currcet_index in 1..=3{\\n        while del >= currcet_index && vec_count[0] == 2 + currcet_index{\\n            del -= currcet_index;\\n            vec_count.remove(0);\\n            if vec_count.len() == 0{\\n                return 0;\\n            }\\n        }\\n        if del < currcet_index{\\n            break;\\n        }\\n        for i in 0..vec_count.len(){\\n            while vec_count[i] % 3 == (currcet_index - 1){\\n                if vec_count[i] == 2 + currcet_index{\\n                    break;\\n                }\\n                vec_count[i] -= currcet_index;\\n                del -= currcet_index;\\n                if del < currcet_index{\\n                    break \\'loop1;\\n                }\\n            }\\n        }\\n    }\\n    let mut result_count = 0;\\n    for i in vec_count{\\n        result_count += i / 3;\\n    }\\n    if result_count >= rep{\\n        return result_count - rep;\\n    }\\n    return 0;\\n}\\n\\npub fn compu_type_count(password:&String) -> i32{\\n    let mut lower_case = 0;\\n    let mut upper_case=0;\\n    let mut digit = 0;\\n    let mut total = 0;\\n    for i in password.as_bytes(){\\n        if *i >= 48 && *i <= 57{\\n            if digit == 0{\\n                digit = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n        if *i >= 65 && *i <= 90{\\n            if upper_case == 0{\\n                upper_case = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n        if *i >= 97 && *i <= 122{\\n            if lower_case == 0{\\n                lower_case = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n    }\\n    return total;\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let new_length = password.len() as i32;\\n        if new_length > 20{\\n            let rep = 3 - compu_type_count(&password);\\n            let del = new_length - 20;\\n            let vec_count = repeat_count(&password);\\n            return rep + del + replace_count(vec_count, del, 0, rep, true);\\n        }\\n        else if new_length < 6{\\n            let add = 6 - new_length;\\n            let type_add = 3 - compu_type_count(&password);\\n            let rep = \\n            if type_add <= add{\\n                0\\n            }\\n            else{\\n                type_add - add\\n            };\\n            return add + rep + replace_count(repeat_count(&password), 0, add, rep, true);\\n        }\\n        else{\\n            let rep = 3 - compu_type_count(&password);\\n            let vec_count = repeat_count(&password);\\n            return rep + replace_count(vec_count, 0, 0, rep, true);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1072622,
                "title": "c-0ms-o-n-clean-code-with-comment-31-lines",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string& s) {\\n        int len[50 / 3], cnt = 0;                    // lengths of each group of more than 2 same characters\\n        bool digit = false, lower = false, upper = false;\\n        for (unsigned i = 0, j; i < s.size(); i = j) {\\n            digit = digit || isdigit(s[i]);\\n            lower = lower || islower(s[i]);\\n            upper = upper || isupper(s[i]);\\n            for (j = i + 1; j < s.size() && s[j] == s[i]; ++j);\\n            if (j - i >= 3) len[cnt++] = j - i;\\n        }\\n        int con = (!digit) + (!lower) + (!upper);    // need more condictions to be satisfied\\n        int ins = s.size() < 6  ? 6 - s.size()  : 0; // need more insertions\\n        int del = s.size() > 20 ? s.size() - 20 : 0; // need more deletions\\n        int res = 0;                                 // operations have been done\\n        for (int i = 0; i < cnt; ++i) {\\n            while (len[i] >= 3 && ins > 0) { // Insert a character between same characters when more insertion is needed.\\n                ++res;\\n                --ins;\\n                len[i] -= 2;                 // Reduces the length of same characters by 2, eg. \"AAAA...\" -> \"AAaAA...\".\\n                if (con) --con;              // We can always find a character that satisfies more condiction.\\n            }\\n            while (len[i] >= 3 && con > 0) { // Replace a character in row of same characters to satisfy more condiction.\\n                ++res;\\n                --con;\\n                len[i] -= 3;                 // Reduces the length of same characters by 3, eg. \"AAAA...\" -> \"AAaA...\".\\n            }\\n        }\\n        // Then if it need deletions, we should first delete characters from the same N (N>=3)\\n        // characters in a row which N % 3 == 0, then N % 3 == 1 and N % 3 == 2.\\n        // Because K replacements are needed to separate k*3 same characters but K-1 replacements are need for K*3-1 same characters.\\n        // For example, 2 characters must be deleted from \"AAAAAA789012345678aAAA\" since its length is 22.\\n        // If two \\'A\\' characters are deleted from front, 2 more replacements are needed.\\n        // But if one \\'A\\' is deleted from front and the other from back, only 1 replacement is needed.\\n        for (int mod = 0; mod < 3; ++mod) {\\n            for (int i = 0; i < cnt; ++i) {\\n                while (len[i] >= 3 && del > mod && len[i] % 3 == mod) {\\n                    res += mod + 1;\\n                    del -= mod + 1;\\n                    len[i] -= mod + 1;\\n                }\\n            }\\n        }\\n        con -= min(con, ins);                            // More insertions can satisfy one more condictions.\\n        for (int i = 0; i < cnt; ++i) res += len[i] / 3; // Perform additional replacements to separete same characters.\\n        return res + ins + con + del;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string& s) {\\n        int len[50 / 3], cnt = 0;                    // lengths of each group of more than 2 same characters\\n        bool digit = false, lower = false, upper = false;\\n        for (unsigned i = 0, j; i < s.size(); i = j) {\\n            digit = digit || isdigit(s[i]);\\n            lower = lower || islower(s[i]);\\n            upper = upper || isupper(s[i]);\\n            for (j = i + 1; j < s.size() && s[j] == s[i]; ++j);\\n            if (j - i >= 3) len[cnt++] = j - i;\\n        }\\n        int con = (!digit) + (!lower) + (!upper);    // need more condictions to be satisfied\\n        int ins = s.size() < 6  ? 6 - s.size()  : 0; // need more insertions\\n        int del = s.size() > 20 ? s.size() - 20 : 0; // need more deletions\\n        int res = 0;                                 // operations have been done\\n        for (int i = 0; i < cnt; ++i) {\\n            while (len[i] >= 3 && ins > 0) { // Insert a character between same characters when more insertion is needed.\\n                ++res;\\n                --ins;\\n                len[i] -= 2;                 // Reduces the length of same characters by 2, eg. \"AAAA...\" -> \"AAaAA...\".\\n                if (con) --con;              // We can always find a character that satisfies more condiction.\\n            }\\n            while (len[i] >= 3 && con > 0) { // Replace a character in row of same characters to satisfy more condiction.\\n                ++res;\\n                --con;\\n                len[i] -= 3;                 // Reduces the length of same characters by 3, eg. \"AAAA...\" -> \"AAaA...\".\\n            }\\n        }\\n        // Then if it need deletions, we should first delete characters from the same N (N>=3)\\n        // characters in a row which N % 3 == 0, then N % 3 == 1 and N % 3 == 2.\\n        // Because K replacements are needed to separate k*3 same characters but K-1 replacements are need for K*3-1 same characters.\\n        // For example, 2 characters must be deleted from \"AAAAAA789012345678aAAA\" since its length is 22.\\n        // If two \\'A\\' characters are deleted from front, 2 more replacements are needed.\\n        // But if one \\'A\\' is deleted from front and the other from back, only 1 replacement is needed.\\n        for (int mod = 0; mod < 3; ++mod) {\\n            for (int i = 0; i < cnt; ++i) {\\n                while (len[i] >= 3 && del > mod && len[i] % 3 == mod) {\\n                    res += mod + 1;\\n                    del -= mod + 1;\\n                    len[i] -= mod + 1;\\n                }\\n            }\\n        }\\n        con -= min(con, ins);                            // More insertions can satisfy one more condictions.\\n        for (int i = 0; i < cnt; ++i) res += len[i] / 3; // Perform additional replacements to separete same characters.\\n        return res + ins + con + del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824631,
                "title": "c-0ms-o-n-solution-with-explanation",
                "content": "One solution to this problem is to count the number of errors and \"merge\" as many errors as we can.\\n\\nRepeat errors are defined as how many letters need to be changed to fit the repeat rule.\\nLowercase, uppercase and digit errors are defined by how many of the 3 are missing.\\nSize errors are defined as 0 or the distance from n to an acceptable size. So n = 4 -> 2 and n = 22 -> -2.\\n\\nWe need to notice that the following can be merged\\n1. repeating letters, and missing lowercase, uppercase and digits\\n2. missing letters (n < 6) can be merged with above\\n3. extra letters can be merged with repeating letters\\n\\nLets first consider the case n < 6 or 6 <= n <= 20. If we have any errors we only need to find the maximum of them.\\n\\n\"aaaaaa\" -> \"aa1aaA\" \\nRepeat = 2, Missing = 2, Size = 0, Error = 2\\nIn this example we see that we can merge errors from missing cases into repeating errors because it only requires a replacement.\\n\\n\"aa\" -> \"aaA1bc\"\\nRepeat = 0, Missing = 2, Size = 4, Error = 4\\nIn this example we can see that missing cases can be merged into size errors because the right insertion can fix both errors at the same time.\\n\\nThe harder case is when n > 20. Merging here is harder to keep track of and the rules from above may not apply because we can\\'t simply insert. Missing cases can still be merged with repeat errors but they can not be merged with size errors because we are deleting instead of inserting.\\n\\n\"aaa\" -> 1 deletion\\n\"aaaa\" -> 2 deletions\\n\"aaaaa\" -> 3 deletions\\n\\nHere we have to consider the maximum amount of repeat errors we can merge into size errors. When we count the number of repeat errors we can keep a sorted list of the repeats we can fix with < 3 deletions. After those are gone the amount of deletions per repeat goes to 3. Since repeat errors and missing case errors still work the same we can merge them but only after we delete the number of repeat errors we can fix by deleting.\\n\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bool lower = false;\\n        bool upper = false;\\n        bool digit = false;\\n        \\n        int repeating = 0;\\n        \\n        int n = s.size();\\n        \\n        vector<int> toRemove(3, 0);\\n        \\n        for(int i = 0; i < n;) {\\n            //Check if character is lowercase, uppercase, or digit and set those to true\\n            char c = s[i];\\n            if(48 <= c && c <= 57) {\\n                digit = true;\\n            } else if(65 <= c && c <= 90) {\\n                upper = true;\\n            } else if(97 <= c && c <= 122) {\\n                lower = true;\\n            }\\n            \\n            \\n            //count how many repeating numbers we have\\n            int counter = 1;\\n            while(i + counter < n && s[i + counter] == s[i]) {\\n                counter++;\\n            }\\n            \\n            //number of repeat errors goes up by 1 for every 3 repeating\\n            int errors = counter / 3;\\n            repeating += errors;\\n            \\n            //if we have a repeat error than push to a heap the number of deletions we need to \\n            //remove a repeat error\\n            if(errors) {\\n                //maps 0 -> 1, 1 -> 2, 2 -> 3\\n                toRemove[(counter % 3)]++;\\n                toRemove[2] += errors - 1;\\n            }\\n            \\n            i += counter;\\n        }\\n        \\n        //count missing cases\\n        int toAdd = !lower + !upper + !digit;\\n        \\n        //get size error. 0 if there are no errors\\n        int toSize = 0;\\n        if(n > 20) {\\n            toSize = 20 - n;\\n        } else if(n < 6) {\\n            toSize = 6 - n;\\n        }\\n        \\n        if(toSize < 0) {\\n            //case n > 20\\n            \\n            int tmpSize = -toSize;\\n            //remove duplicates of (i + 1) size\\n            for(int i = 0; i <= 2; ++i) {\\n                int removed = min(tmpSize / (i + 1), toRemove[i]);\\n                tmpSize -= removed * (i + 1);\\n                repeating -= removed;\\n            }\\n            \\n            //if we have any case errors we can merge them with\\n            //repeat errors\\n            return max(toAdd, repeating) - toSize;\\n            \\n        } else {\\n            //case n <= 20\\n            //the error is simply the max becauses we can merge\\n            //every error with pretty much no consequence\\n            return max(toSize, max(toAdd, repeating));\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bool lower = false;\\n        bool upper = false;\\n        bool digit = false;\\n        \\n        int repeating = 0;\\n        \\n        int n = s.size();\\n        \\n        vector<int> toRemove(3, 0);\\n        \\n        for(int i = 0; i < n;) {\\n            //Check if character is lowercase, uppercase, or digit and set those to true\\n            char c = s[i];\\n            if(48 <= c && c <= 57) {\\n                digit = true;\\n            } else if(65 <= c && c <= 90) {\\n                upper = true;\\n            } else if(97 <= c && c <= 122) {\\n                lower = true;\\n            }\\n            \\n            \\n            //count how many repeating numbers we have\\n            int counter = 1;\\n            while(i + counter < n && s[i + counter] == s[i]) {\\n                counter++;\\n            }\\n            \\n            //number of repeat errors goes up by 1 for every 3 repeating\\n            int errors = counter / 3;\\n            repeating += errors;\\n            \\n            //if we have a repeat error than push to a heap the number of deletions we need to \\n            //remove a repeat error\\n            if(errors) {\\n                //maps 0 -> 1, 1 -> 2, 2 -> 3\\n                toRemove[(counter % 3)]++;\\n                toRemove[2] += errors - 1;\\n            }\\n            \\n            i += counter;\\n        }\\n        \\n        //count missing cases\\n        int toAdd = !lower + !upper + !digit;\\n        \\n        //get size error. 0 if there are no errors\\n        int toSize = 0;\\n        if(n > 20) {\\n            toSize = 20 - n;\\n        } else if(n < 6) {\\n            toSize = 6 - n;\\n        }\\n        \\n        if(toSize < 0) {\\n            //case n > 20\\n            \\n            int tmpSize = -toSize;\\n            //remove duplicates of (i + 1) size\\n            for(int i = 0; i <= 2; ++i) {\\n                int removed = min(tmpSize / (i + 1), toRemove[i]);\\n                tmpSize -= removed * (i + 1);\\n                repeating -= removed;\\n            }\\n            \\n            //if we have any case errors we can merge them with\\n            //repeat errors\\n            return max(toAdd, repeating) - toSize;\\n            \\n        } else {\\n            //case n <= 20\\n            //the error is simply the max becauses we can merge\\n            //every error with pretty much no consequence\\n            return max(toSize, max(toAdd, repeating));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750932,
                "title": "c-the-shortest-solution-with-explanation-0ms",
                "content": "First of all, let\\'s try to split string to substrings where all characters are the same.\\nAlso, count all digits, lowers, uppers. Count replacements (you can change the middle char for every 3 characters) and remainders (for \\'aaa\\' it will be 1, for \\'aaaa\\' it will be two) to make substr shorter then 3.\\n\\nThen count how many chars you need to add or delete.\\nFinally, optimize number of replacements. If you need to delete characters, these deletions can be used instead of replacements (for \\'aaa\\' substring you can delete 1 char instead of 1 replacement, for \\'aaaa\\' you can delete 2 chars instead of 1 replacement, for the rest of deletions you can cover 1 replacement for 3 deletions).\\n\\n```\\nint strongPasswordChecker(string s, int minimum = 6, int maximum = 20) \\n{\\n    string_view sv = s;\\n\\tint replacements = 0, size = s.size();\\n\\tvector<int> remainders { 0, 0, 10000 }, counts { 0, 0, 0 };\\n    vector<string_view> repetetives;\\n        \\n\\tfor (int i = 0, start = 0; i < sv.size(); ++i)\\n\\t\\tif (i == sv.size() - 1 || sv[i] != sv[i + 1])\\n\\t\\t\\trepetetives.push_back(sv.substr(start, i - start + 1)), start = i + 1;\\n\\n\\tfor (auto & repetetive : repetetives)\\n\\t{\\n\\t\\tauto ch = repetetive.front();\\n\\t\\tcounts[0] += isdigit(ch), counts[1] += isupper(ch), counts[2] += islower(ch);\\n\\n\\t\\treplacements += repetetive.size() / 3;\\n\\t\\tif (repetetive.size() >= 3) remainders[repetetive.size() % 3]++;\\n\\t}\\n\\n\\tint deletions = max(0, size - maximum);\\n\\tint additions = max((int) count(counts.begin(), counts.end(), 0), minimum - size);\\n\\n\\tfor (int i = 0, d = deletions; i < remainders.size(); d = max(d - remainders[i] * (i + 1), 0), i++)\\n\\t\\treplacements -= min(remainders[i], d / (i + 1));\\n\\n\\treturn deletions + max(replacements, additions); \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint strongPasswordChecker(string s, int minimum = 6, int maximum = 20) \\n{\\n    string_view sv = s;\\n\\tint replacements = 0, size = s.size();\\n\\tvector<int> remainders { 0, 0, 10000 }, counts { 0, 0, 0 };\\n    vector<string_view> repetetives;\\n        \\n\\tfor (int i = 0, start = 0; i < sv.size(); ++i)\\n\\t\\tif (i == sv.size() - 1 || sv[i] != sv[i + 1])\\n\\t\\t\\trepetetives.push_back(sv.substr(start, i - start + 1)), start = i + 1;\\n\\n\\tfor (auto & repetetive : repetetives)\\n\\t{\\n\\t\\tauto ch = repetetive.front();\\n\\t\\tcounts[0] += isdigit(ch), counts[1] += isupper(ch), counts[2] += islower(ch);\\n\\n\\t\\treplacements += repetetive.size() / 3;\\n\\t\\tif (repetetive.size() >= 3) remainders[repetetive.size() % 3]++;\\n\\t}\\n\\n\\tint deletions = max(0, size - maximum);\\n\\tint additions = max((int) count(counts.begin(), counts.end(), 0), minimum - size);\\n\\n\\tfor (int i = 0, d = deletions; i < remainders.size(); d = max(d - remainders[i] * (i + 1), 0), i++)\\n\\t\\treplacements -= min(remainders[i], d / (i + 1));\\n\\n\\treturn deletions + max(replacements, additions); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91020,
                "title": "very-easy-and-simple-o-n-solution-python-java",
                "content": "**Analysis/Usage of 3 operations:**\\nInsert: Able to fix repeat and add missing element (e.g. uppercase/lowercase/digit) => only use in case **A**.\\nDelete: Able to fix repeat (by certain number) => only use it in case **B**.\\nReplace: Able to fix repeat and add missing element  => use in **A/B/C**\\n\\n**Steps:**\\n1. Check the of type of characters(uppercase/lowercase/digit/others) and get length of repeats. O(n)\\n2. **Fix repeat** in Three different cases:\\n* case A. (L < 6): Not only Repeat but also Missing element can be fixed by insert at same time. O(1)\\n* case B. (L > 20): Fix by delete (and replace if needed). O(occurance of repeat)\\n* case C. (6 <= L <= 20): Should be fixed by replace only. O(occurance of repeat)\\n\\n3. Final check (**Fix missing element**): If still any missing => fix it by replace. ~O(1)\\n\\nDetailed explanation can be referred to comments.\\n\\n**EDIT:**\\nWrote this long time ago. The original code can pass the submission, however, thanks for [@alabdulkareem\\'s comment](https://leetcode.com/problems/strong-password-checker/discuss/91020/Very-Easy-and-Simple-O(n)-solution-(20-lines-Python-Java)/666561) to provide an edge case that my solution didn\\'t cover: which falls into the case B in the origian post.\\n\\nIn case B, we can use either delete or remoal. We need to handle the delete as priority, because of the size limit we need to remove some characters for sure. Since we already have plenty repeats at hand, (e.g. \"aaaabbbbcccccc\", repeat = [4,4,6]) the best scenario is to remove those r%3 == 0, which can save us one removal with one deletion. The second best scenario is to remove those r%3 == 1, with 2 deletions we can save one removal. so on and so forth.\\n\\nPython:\\n\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        length, repeat, types, i, j = len(s), [], [False]*4, 0, 1\\n\\n        while i < length:\\n            while i+j < length and s[i+j] == s[i]: j += 1\\n            if j >= 3: repeat += j,                     # get repeats\\n            types[self.classifier(s[i])] = True         # check lower/upper/digit\\n            i, j = i+j, 1\\n\\n        insert, delete, replace = 0, 0, 0\\n        \\n        if length < 6: insert = 6-length                # Case A.\\n        \\n        elif length > 20:   # Case B. Fix repeat by (replace+delete), should > all solve by replace\\n\\t\\t\\n\\t\\t\\t# original post\\n            # delete, allbydel = length-20, sum([r-2 for r in repeat])\\n            # if delete < allbydel:     # repeat solved by both delete and replace\\n            #     replace = max(sum([r//3 for r in repeat])-delete, ((allbydel-delete)+2)//3)\\n\\n            # START OF EDIT\\n\\t\\t\\tdelete = length-20\\n            repeat = [(i%3, i) for i in repeat]\\n            heapq.heapify(repeat)\\n            for i in range(delete):\\n                if not repeat:\\n                    break\\n                length_mod_3, length = heapq.heappop(repeat)\\n                if length-1 >= 3:\\n                    heapq.heappush(repeat, ((length-1)%3, length-1))\\n            repeat = [i[1] for i in repeat]\\n\\t\\t\\treplace = sum([r//3 for r in repeat]\\n\\t\\t\\t# END OF EDIT\\n\\n        else:               # Case C. fix repeat only by replace\\n            for rp in repeat: replace += rp//3\\n\\n        # final check: if replace less than missing\\n        return insert+delete+max(replace, types[:-1].count(False)-insert)\\n\\n    def classifier(self, c):\\n        # types: 0 = lowercase, 1 = uppercase, 2 = digit, 3 = others (None of above)\\n        if c.islower(): return 0\\n        elif c.isupper(): return 1\\n        elif c.isdigit(): return 2\\n        else: return 3\\n```\\n\\nJava Version: (I think it should be able to do some improvement)\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int length = s.length();\\n        ArrayList<Integer> rptlen = new ArrayList<Integer>();\\n        Boolean[] types = {false, false, false, false};\\n        int i = 0;\\n        int j = 1;\\n\\n        while (i < length) {\\n            while ((i+j < length) && (s.charAt(i) == s.charAt(i+j))) {j += 1;}\\n            if (j >= 3) {\\n                rptlen.add(j);\\n            }\\n            int tmp = classifier(s.charAt(i));\\n            types[tmp] = true;\\n            i += j;\\n            j = 1;\\n        }\\n        Integer[] work = {0,0,0};       // insert, delete, replace\\n        if (length < 6) {\\n            work[0] = 6-length;\\n        }\\n        else if (length > 20) {\\n            work[1] = length-20;\\n            int allbydel = 0;\\n            int tmp = 0;\\n            for (int k = 0; k < rptlen.size(); k++) {\\n                allbydel += (rptlen.get(k)-2);\\n                tmp += rptlen.get(k)/3;\\n            }\\n            if (work[1] < allbydel) {\\n                work[2] = Math.max(tmp-work[1], (allbydel-work[1]+2)/3);\\n            }\\n        }\\n        else {\\n            for (int x = 0; x < rptlen.size(); x++) {\\n                work[2] += rptlen.get(x)/3;\\n            }\\n        }\\n\\n        int countmiss = 0;\\n        for (int t = 0; t < 3; t ++) { if (types[t] == false) countmiss++;}\\n        return work[0]+work[1]+Math.max(work[2], countmiss-work[0]);\\n    }\\n    private int classifier(char c) {\\n        if (Character.isUpperCase(c)) return 0;\\n        else if (Character.isLowerCase(c)) return 1;\\n        else if (Character.isDigit(c)) return 2;\\n        else return 3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        length, repeat, types, i, j = len(s), [], [False]*4, 0, 1\\n\\n        while i < length:\\n            while i+j < length and s[i+j] == s[i]: j += 1\\n            if j >= 3: repeat += j,                     # get repeats\\n            types[self.classifier(s[i])] = True         # check lower/upper/digit\\n            i, j = i+j, 1\\n\\n        insert, delete, replace = 0, 0, 0\\n        \\n        if length < 6: insert = 6-length                # Case A.\\n        \\n        elif length > 20:   # Case B. Fix repeat by (replace+delete), should > all solve by replace\\n\\t\\t\\n\\t\\t\\t# original post\\n            # delete, allbydel = length-20, sum([r-2 for r in repeat])\\n            # if delete < allbydel:     # repeat solved by both delete and replace\\n            #     replace = max(sum([r//3 for r in repeat])-delete, ((allbydel-delete)+2)//3)\\n\\n            # START OF EDIT\\n\\t\\t\\tdelete = length-20\\n            repeat = [(i%3, i) for i in repeat]\\n            heapq.heapify(repeat)\\n            for i in range(delete):\\n                if not repeat:\\n                    break\\n                length_mod_3, length = heapq.heappop(repeat)\\n                if length-1 >= 3:\\n                    heapq.heappush(repeat, ((length-1)%3, length-1))\\n            repeat = [i[1] for i in repeat]\\n\\t\\t\\treplace = sum([r//3 for r in repeat]\\n\\t\\t\\t# END OF EDIT\\n\\n        else:               # Case C. fix repeat only by replace\\n            for rp in repeat: replace += rp//3\\n\\n        # final check: if replace less than missing\\n        return insert+delete+max(replace, types[:-1].count(False)-insert)\\n\\n    def classifier(self, c):\\n        # types: 0 = lowercase, 1 = uppercase, 2 = digit, 3 = others (None of above)\\n        if c.islower(): return 0\\n        elif c.isupper(): return 1\\n        elif c.isdigit(): return 2\\n        else: return 3\\n```\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int length = s.length();\\n        ArrayList<Integer> rptlen = new ArrayList<Integer>();\\n        Boolean[] types = {false, false, false, false};\\n        int i = 0;\\n        int j = 1;\\n\\n        while (i < length) {\\n            while ((i+j < length) && (s.charAt(i) == s.charAt(i+j))) {j += 1;}\\n            if (j >= 3) {\\n                rptlen.add(j);\\n            }\\n            int tmp = classifier(s.charAt(i));\\n            types[tmp] = true;\\n            i += j;\\n            j = 1;\\n        }\\n        Integer[] work = {0,0,0};       // insert, delete, replace\\n        if (length < 6) {\\n            work[0] = 6-length;\\n        }\\n        else if (length > 20) {\\n            work[1] = length-20;\\n            int allbydel = 0;\\n            int tmp = 0;\\n            for (int k = 0; k < rptlen.size(); k++) {\\n                allbydel += (rptlen.get(k)-2);\\n                tmp += rptlen.get(k)/3;\\n            }\\n            if (work[1] < allbydel) {\\n                work[2] = Math.max(tmp-work[1], (allbydel-work[1]+2)/3);\\n            }\\n        }\\n        else {\\n            for (int x = 0; x < rptlen.size(); x++) {\\n                work[2] += rptlen.get(x)/3;\\n            }\\n        }\\n\\n        int countmiss = 0;\\n        for (int t = 0; t < 3; t ++) { if (types[t] == false) countmiss++;}\\n        return work[0]+work[1]+Math.max(work[2], countmiss-work[0]);\\n    }\\n    private int classifier(char c) {\\n        if (Character.isUpperCase(c)) return 0;\\n        else if (Character.isLowerCase(c)) return 1;\\n        else if (Character.isDigit(c)) return 2;\\n        else return 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421309,
                "title": "0ms-rust-solution-with-explanatory-comments",
                "content": "Tried to write a relatively clean solution that also shows the thought process and how cases are handled. It took ~130 lines and may not be the best solution. It\\'s the fastest solution though, at 0ms.\\n\\n```rust\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        // This is the change needed in the length of the password\\n        // to fit in the declared criterion.\\n        let mut char_change = loop {\\n           let len = password.len() as i32;\\n            if len < 6 {\\n                break 6-len;\\n            }\\n            if len > 20 {\\n                break 20-len;\\n            }\\n            break 0;\\n        }; \\n        \\n        \\n        // These are 1 when we need to add the char class, 0 otherwise.\\n        let should_add_lowercase = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_lowercase() {0} else {1}});\\n        let should_add_uppercase = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_uppercase() {0} else {1}});\\n        let should_add_digit = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_digit() {0} else {1}});\\n\\n        // We create an array of tuples that represent consecutive characters of length\\n        // more than 3.\\n        let mut consecutives = {\\n            let mut consecutives = Vec::new();\\n            let mut consecutive: (char, u8) = (\\' \\', 0);\\n\\n            for chr in password.chars() {\\n                if consecutive.0 == chr {\\n                    consecutive.1 += 1;\\n                }\\n                else {\\n                    if consecutive.1 > 2 {\\n                        consecutives.push(consecutive);\\n                    }\\n                    consecutive = (chr, 1);\\n                }\\n            }\\n            if consecutive.1 > 2 {\\n                consecutives.push(consecutive);\\n            }\\n            consecutives\\n        };\\n        \\n        if char_change > 0 {\\n            // Missing chars can be added and consecutive problems can be solved in char_change moves if char_change >= 3.\\n            // If it\\'s 2, missings might be bigger but consecutives is still within this limit.\\n            // If it\\'s 1, there might be a consecutive of 5 which needs 2 changes but if that\\'s the case the addition of 3 missings\\' variables will be bigger than or equal to 2.\\n            return (should_add_lowercase + should_add_uppercase + should_add_digit).max(char_change);\\n        }\\n        \\n        let mut removed = 0;\\n        \\n        if char_change < 0 {\\n\\t\\t    // Aim here is to move toward making every consecutive be 2 mod 3.\\n            // This is optimal because at 2 mod 3 we\\'ve used the least amount of removals to \\n            // decrease the most amount of operations needed in the future for each consecutive.\\n\\n            // We first remove 3-divisible consecutives\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                if c.1 % 3 == 0 {\\n                    c.1 -= 1;\\n                    char_change += 1;\\n                    removed += 1;\\n                }\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n            \\n            // We then remove mod 1 consecutives\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                if c.1 % 3 == 1 {\\n                    // Make sure not to subtract more than needed.\\n                    let subtract = (2).min(char_change.abs() as u8);\\n                    c.1 -= subtract;\\n                    char_change += subtract as i32;\\n                    removed += subtract as i32;\\n                }\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n            \\n            // Now we greedily remove as many as we can to get rid of consecutives.\\n            // It will not matter which ones we remove from as all of them are 2 mod 3.\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                // We only need to subtract to make c.1 less than 3.\\n                let subtract = (c.1-2).min(char_change.abs() as u8);\\n                \\n                c.1 -= subtract;\\n                char_change += subtract as i32;\\n                removed += subtract as i32;\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n        }\\n        \\n        // Now we have two cases:\\n        // 1. # of chars to be removed was bigger than total consecutive chars\\n        // 2. total consective chars was bigger than # of chars to be removed\\n        \\n        // 1 => there are no longer any ops to be done on consecutives but only chars to be removed.\\n        // 2 => there are no longer any chars to be removed, just ops to do on consecutives.\\n        \\n        if char_change != 0 {\\n            // Case 1\\n            // We\\'ve only removed `removed` many elements. we have to remove char_change.abs() many.\\n            // We also have to add missing char classes.\\n            \\n            return removed + char_change.abs() + (should_add_lowercase + should_add_uppercase + should_add_digit);\\n        }\\n        else {\\n            // Case 2\\n            \\n            // Adding characters will only isolate 2 characters from the consecutive group\\n            // but changing a character will decrease the count by 3!\\n            \\n            // So at this point we only change characters.\\n            let mut changed = 0;\\n            \\n            for c in consecutives.iter_mut() {\\n                // we only need to change c.1/3 chars.\\n                changed += (c.1/3) as i32;\\n            }\\n            \\n            // if we didn\\'t have enough characters to change, we will have to change characters\\n            // to make sure missing char classes are included.\\n            // (we say change missing char classes because adding might cause us to exceed the length limit)\\n            return removed + changed.max(should_add_lowercase+should_add_uppercase+should_add_digit);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        // This is the change needed in the length of the password\\n        // to fit in the declared criterion.\\n        let mut char_change = loop {\\n           let len = password.len() as i32;\\n            if len < 6 {\\n                break 6-len;\\n            }\\n            if len > 20 {\\n                break 20-len;\\n            }\\n            break 0;\\n        }; \\n        \\n        \\n        // These are 1 when we need to add the char class, 0 otherwise.\\n        let should_add_lowercase = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_lowercase() {0} else {1}});\\n        let should_add_uppercase = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_uppercase() {0} else {1}});\\n        let should_add_digit = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_digit() {0} else {1}});\\n\\n        // We create an array of tuples that represent consecutive characters of length\\n        // more than 3.\\n        let mut consecutives = {\\n            let mut consecutives = Vec::new();\\n            let mut consecutive: (char, u8) = (\\' \\', 0);\\n\\n            for chr in password.chars() {\\n                if consecutive.0 == chr {\\n                    consecutive.1 += 1;\\n                }\\n                else {\\n                    if consecutive.1 > 2 {\\n                        consecutives.push(consecutive);\\n                    }\\n                    consecutive = (chr, 1);\\n                }\\n            }\\n            if consecutive.1 > 2 {\\n                consecutives.push(consecutive);\\n            }\\n            consecutives\\n        };\\n        \\n        if char_change > 0 {\\n            // Missing chars can be added and consecutive problems can be solved in char_change moves if char_change >= 3.\\n            // If it\\'s 2, missings might be bigger but consecutives is still within this limit.\\n            // If it\\'s 1, there might be a consecutive of 5 which needs 2 changes but if that\\'s the case the addition of 3 missings\\' variables will be bigger than or equal to 2.\\n            return (should_add_lowercase + should_add_uppercase + should_add_digit).max(char_change);\\n        }\\n        \\n        let mut removed = 0;\\n        \\n        if char_change < 0 {\\n\\t\\t    // Aim here is to move toward making every consecutive be 2 mod 3.\\n            // This is optimal because at 2 mod 3 we\\'ve used the least amount of removals to \\n            // decrease the most amount of operations needed in the future for each consecutive.\\n\\n            // We first remove 3-divisible consecutives\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                if c.1 % 3 == 0 {\\n                    c.1 -= 1;\\n                    char_change += 1;\\n                    removed += 1;\\n                }\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n            \\n            // We then remove mod 1 consecutives\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                if c.1 % 3 == 1 {\\n                    // Make sure not to subtract more than needed.\\n                    let subtract = (2).min(char_change.abs() as u8);\\n                    c.1 -= subtract;\\n                    char_change += subtract as i32;\\n                    removed += subtract as i32;\\n                }\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n            \\n            // Now we greedily remove as many as we can to get rid of consecutives.\\n            // It will not matter which ones we remove from as all of them are 2 mod 3.\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                // We only need to subtract to make c.1 less than 3.\\n                let subtract = (c.1-2).min(char_change.abs() as u8);\\n                \\n                c.1 -= subtract;\\n                char_change += subtract as i32;\\n                removed += subtract as i32;\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n        }\\n        \\n        // Now we have two cases:\\n        // 1. # of chars to be removed was bigger than total consecutive chars\\n        // 2. total consective chars was bigger than # of chars to be removed\\n        \\n        // 1 => there are no longer any ops to be done on consecutives but only chars to be removed.\\n        // 2 => there are no longer any chars to be removed, just ops to do on consecutives.\\n        \\n        if char_change != 0 {\\n            // Case 1\\n            // We\\'ve only removed `removed` many elements. we have to remove char_change.abs() many.\\n            // We also have to add missing char classes.\\n            \\n            return removed + char_change.abs() + (should_add_lowercase + should_add_uppercase + should_add_digit);\\n        }\\n        else {\\n            // Case 2\\n            \\n            // Adding characters will only isolate 2 characters from the consecutive group\\n            // but changing a character will decrease the count by 3!\\n            \\n            // So at this point we only change characters.\\n            let mut changed = 0;\\n            \\n            for c in consecutives.iter_mut() {\\n                // we only need to change c.1/3 chars.\\n                changed += (c.1/3) as i32;\\n            }\\n            \\n            // if we didn\\'t have enough characters to change, we will have to change characters\\n            // to make sure missing char classes are included.\\n            // (we say change missing char classes because adding might cause us to exceed the length limit)\\n            return removed + changed.max(should_add_lowercase+should_add_uppercase+should_add_digit);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081087,
                "title": "javascript-100-fastest-42ms-42-4mb",
                "content": "```js\\nconst strongPasswordChecker = (passwd) => {\\n    let steps = 0;\\n    let mustAdd = 0;\\n\\n    if (!passwd.match(/[A-Z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/[a-z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/\\\\d/)) {\\n        mustAdd++;\\n    }\\n\\n    let groups = passwd.match(/(.)\\\\1*/g).filter(x => x.length > 2);\\n\\n    if (passwd.length <= 20) {\\n        groups.forEach(group => {\\n            steps += Math.trunc(group.length / 3);\\n            mustAdd -= Math.trunc(group.length / 3);\\n        })\\n    }\\n\\n    if (passwd.length <= 20) {\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        if (passwd.length + steps >= 6) {\\n            steps += mustAdd;\\n        } else {\\n            if (mustAdd > 6 - (passwd.length + steps)) {\\n                steps += mustAdd;\\n            } else {\\n                steps += 6 - (passwd.length + steps);\\n            }\\n        }\\n    }\\n\\n    if (passwd.length > 20) {\\n        let mustRemove = passwd.length - 20;\\n        let lengths = [];\\n        let plus = [];\\n        let chL = 0;\\n        for (let i = 1; i <= 3; i++) {\\n            for (let k = 0; k < groups.length; k++) {\\n                if (plus[k] === undefined) { plus[k] = 0; }\\n                chL = groups[k].length - plus[k];\\n                if (lengths[k] === undefined) { lengths[k] = chL; }\\n                const rec = () => {\\n                    if (Math.trunc((chL - i) / 3) < Math.trunc(chL / 3) && passwd.length - steps - i >= 6 && mustRemove >= i && chL > 2 && lengths[k] - i > 0) {\\n                        steps += i;\\n                        plus[k] += i;\\n                        mustRemove -= i;\\n                        chL -= i;\\n                        lengths[k] -= i;\\n                        rec();\\n                    }\\n                }\\n                rec();\\n            }\\n        }\\n        lengths.forEach(length => {\\n            if (length > 2) {\\n                steps += Math.trunc(length / 3);\\n                mustAdd -= Math.trunc(length / 3);\\n            }\\n        }\\n        )\\n\\n        mustRemove = mustRemove > 0 ? mustRemove : 0;\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        steps += mustAdd + mustRemove;\\n    }\\n\\n    return steps;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst strongPasswordChecker = (passwd) => {\\n    let steps = 0;\\n    let mustAdd = 0;\\n\\n    if (!passwd.match(/[A-Z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/[a-z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/\\\\d/)) {\\n        mustAdd++;\\n    }\\n\\n    let groups = passwd.match(/(.)\\\\1*/g).filter(x => x.length > 2);\\n\\n    if (passwd.length <= 20) {\\n        groups.forEach(group => {\\n            steps += Math.trunc(group.length / 3);\\n            mustAdd -= Math.trunc(group.length / 3);\\n        })\\n    }\\n\\n    if (passwd.length <= 20) {\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        if (passwd.length + steps >= 6) {\\n            steps += mustAdd;\\n        } else {\\n            if (mustAdd > 6 - (passwd.length + steps)) {\\n                steps += mustAdd;\\n            } else {\\n                steps += 6 - (passwd.length + steps);\\n            }\\n        }\\n    }\\n\\n    if (passwd.length > 20) {\\n        let mustRemove = passwd.length - 20;\\n        let lengths = [];\\n        let plus = [];\\n        let chL = 0;\\n        for (let i = 1; i <= 3; i++) {\\n            for (let k = 0; k < groups.length; k++) {\\n                if (plus[k] === undefined) { plus[k] = 0; }\\n                chL = groups[k].length - plus[k];\\n                if (lengths[k] === undefined) { lengths[k] = chL; }\\n                const rec = () => {\\n                    if (Math.trunc((chL - i) / 3) < Math.trunc(chL / 3) && passwd.length - steps - i >= 6 && mustRemove >= i && chL > 2 && lengths[k] - i > 0) {\\n                        steps += i;\\n                        plus[k] += i;\\n                        mustRemove -= i;\\n                        chL -= i;\\n                        lengths[k] -= i;\\n                        rec();\\n                    }\\n                }\\n                rec();\\n            }\\n        }\\n        lengths.forEach(length => {\\n            if (length > 2) {\\n                steps += Math.trunc(length / 3);\\n                mustAdd -= Math.trunc(length / 3);\\n            }\\n        }\\n        )\\n\\n        mustRemove = mustRemove > 0 ? mustRemove : 0;\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        steps += mustAdd + mustRemove;\\n    }\\n\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064066,
                "title": "python-solution-with-comments-read-as-per-comments",
                "content": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        # First the password should have all first 3 cnmditions\\n        def getMissing(password):\\n            res = 3\\n            if any(\"a\" <= char <= \"z\" for char in password): res -= 1\\n            if any(\"A\" <= char <= \"Z\" for char in password): res -= 1\\n            if any(\"0\" <= char <= \"9\" for char in password): res -= 1\\n            return res\\n        missingValTypes = getMissing(password)\\n        # get reps -> \"aaaa\" - [4], \"aabccc\" - [2,1,3]\\n        reps = []\\n        i = 0\\n        while(i < len(password)):\\n            j = i+1\\n            length = 1\\n            while(j < len(password) and password[j] == password[i]):\\n                j += 1\\n                length += 1\\n            reps.append(length)\\n            i = j\\n        \\n        if(len(password) < 6):\\n            # we have to add either 6-len() or the missingValTypes which are req so max of them\\n            return max(6 - len(password), missingValTypes)\\n        elif(len(password) <= 20):\\n            # we have reps in string with appropriate length\\n            # now we need to delete/swap [swap preferred to not have length issues] items\\n            # either missingValTypes count takes care of everything of above and itself OR\\n            # we get the calculated val seperately\\n            # the calculated value ->\\n            # 1aaBcccc -> [1,2,1,4] -> 1 swap and all done\\n            req = sum([elem//3 for elem in reps])\\n            return max(missingValTypes, req)\\n        else:\\n            # we have a surplus now\\n            # deletes need to be done for sure\\n            deleteReq = len(password) - 20\\n            # lets prioritize the reps - \\n            # priority 1 -> [n*3] because these can be fixed with min amount of swaps/deletions[prefer]\\n            for i in range(0, len(reps)):\\n                if(reps[i]%3 == 0 and reps[i] >= 3 and deleteReq > 0):\\n                    reps[i] -= 1\\n                    deleteReq -= 1\\n            # priority 2 -> [n*3 + 1] because these required 1 extra deletion (1 del -> priority 1)\\n            for i in range(0, len(reps)):\\n                if(reps[i]%3 == 1 and reps[i] > 2 and deleteReq > 1):\\n                    reps[i] -= 2\\n                    deleteReq -= 2\\n            # priority 3 -> [n*3 + 2] now here we can either insert 1 -> prior 1 or del -> prior 2\\n            for i in range(0, len(reps)):\\n                if(reps[i] > 2 and deleteReq > 0):\\n                    removeAllowance = min(reps[i] - 2, deleteReq)\\n                    reps[i] -= removeAllowance\\n                    deleteReq -= removeAllowance\\n            # By this time deleteReq is depleted we have done all we can do as per requirments and reps\\n            # lets cal final as per what all we will change\\n            req = sum([elem//3 for elem in reps])\\n            # more delete/swap required for missingValTypes\\n            return len(password) - 20 + max(missingValTypes, req)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        # First the password should have all first 3 cnmditions\\n        def getMissing(password):\\n            res = 3\\n            if any(\"a\" <= char <= \"z\" for char in password): res -= 1\\n            if any(\"A\" <= char <= \"Z\" for char in password): res -= 1\\n            if any(\"0\" <= char <= \"9\" for char in password): res -= 1\\n            return res\\n        missingValTypes = getMissing(password)\\n        # get reps -> \"aaaa\" - [4], \"aabccc\" - [2,1,3]\\n        reps = []\\n        i = 0\\n        while(i < len(password)):\\n            j = i+1\\n            length = 1\\n            while(j < len(password) and password[j] == password[i]):\\n                j += 1\\n                length += 1\\n            reps.append(length)\\n            i = j\\n        \\n        if(len(password) < 6):\\n            # we have to add either 6-len() or the missingValTypes which are req so max of them\\n            return max(6 - len(password), missingValTypes)\\n        elif(len(password) <= 20):\\n            # we have reps in string with appropriate length\\n            # now we need to delete/swap [swap preferred to not have length issues] items\\n            # either missingValTypes count takes care of everything of above and itself OR\\n            # we get the calculated val seperately\\n            # the calculated value ->\\n            # 1aaBcccc -> [1,2,1,4] -> 1 swap and all done\\n            req = sum([elem//3 for elem in reps])\\n            return max(missingValTypes, req)\\n        else:\\n            # we have a surplus now\\n            # deletes need to be done for sure\\n            deleteReq = len(password) - 20\\n            # lets prioritize the reps - \\n            # priority 1 -> [n*3] because these can be fixed with min amount of swaps/deletions[prefer]\\n            for i in range(0, len(reps)):\\n                if(reps[i]%3 == 0 and reps[i] >= 3 and deleteReq > 0):\\n                    reps[i] -= 1\\n                    deleteReq -= 1\\n            # priority 2 -> [n*3 + 1] because these required 1 extra deletion (1 del -> priority 1)\\n            for i in range(0, len(reps)):\\n                if(reps[i]%3 == 1 and reps[i] > 2 and deleteReq > 1):\\n                    reps[i] -= 2\\n                    deleteReq -= 2\\n            # priority 3 -> [n*3 + 2] now here we can either insert 1 -> prior 1 or del -> prior 2\\n            for i in range(0, len(reps)):\\n                if(reps[i] > 2 and deleteReq > 0):\\n                    removeAllowance = min(reps[i] - 2, deleteReq)\\n                    reps[i] -= removeAllowance\\n                    deleteReq -= removeAllowance\\n            # By this time deleteReq is depleted we have done all we can do as per requirments and reps\\n            # lets cal final as per what all we will change\\n            req = sum([elem//3 for elem in reps])\\n            # more delete/swap required for missingValTypes\\n            return len(password) - 20 + max(missingValTypes, req)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393197,
                "title": "when-password-length-20-illustration",
                "content": "I believe if it had not been for the limitation of length, this problem would have been much much simpler. So our main goal is to handle the situation when password.length > 20, when deletion is unavoidable.\\n\\nLet\\'s start from a simple example,\\npassword = \"aaaaaaaaaaaaaaaaaaaaaa\"  --> (made up of 22 \\'a\\'s)\\nA naive approach is to replace every third \\'a\\' into some othe character and then remove the last two characters to reduce the length to 20.\\n\\n![image](https://assets.leetcode.com/users/images/7136c030-2935-42f6-8bcd-fc47b2092a3f_1628509681.40769.png)\\n\\nHere we do replacement 7 times and removal 2 times, so the answer goes to 7 + 2 = 9. However, the outcome\\'s incorrect. You may have noticed that the last replacement is unnecessary since two characters would be removed after that. So the correct answer is 7 + 2 - 1 = 8. \\n\\nLet\\'s have a closer look at this instance -- to get a valid password, we do replacement 7 times beacause 22 / 3 = 7 and removing 2 times comes from 22 - 20 = 2. This yeilds the wrong answer, though. But if we remove 2 characters first, the length drops to 20, then we only need to replace 20 / 3 = 6 times, 6 + 2 = 8 gives the right output.\\n\\nThe aforementioned instance reveals one critical fact: \\n\\n**Removal can help us reduce the needs of replacement.**\\n\\nAn extrem example is that:\\n![image](https://assets.leetcode.com/users/images/6ba1e785-413a-442a-8607-62e4608b5c81_1628511111.7633173.png)\\nAfter 10 removals, the password becomes valid and no further replacement is needed.\\n\\nIn a nutshell, we should do removal first and \"wisely\", then replacement.\\nBut what is \"wisely\"? \\nSince our goal is get the least steps, we should make the best of every step. \\n\\nAllow me to define a new term \"contiguous segment\" here. A contiguous segment is a string formed by repeating one character once or several times, e.g. \"aaaaa\", \"bbb\", \"A\" and \"hhhhhh\". All strings can be divided into a couple of contiguous segments. For example, \"committee\" can be split into \"c\", \"o\", \"mm\", \"i\", \"tt\" and \"ee\".\\n\\n**Specifically, \\n1. if we remove one character from a contiguous segment owning a length of 3\\\\*k, call it a \"3k segment\" (k can be any POSITIVE integer), we reduce the replacements by 1; \\n2. if we remove two characters from a continguous segment having a length of 3\\\\*k+1, i.e. a \"3k+1 segment\", we also decrement the replacements. \\n3. The third option is to erase three characters from a 3k+2 segement, which again decrese the replacements.**\\n\\nAs a special notice, after removing one character from a 3k segment or two characters from a 3k+1 segment, the leftover may be considered 3k+2 segment, from which erasing 3 chars leads to decrement of replacement again.\\n\\nIn conclusion, firstly we should examine the input string to find out how many 3k, 3k+1, 3k+2 segments are there. Then according to the removals = length - 20, do removals from 3k, 3k+1, 3k+2 segments and count the times of decrement, the result should be like: \\nreplacement + removal - (times of decrement),\\nof course, dut to other requirement, we outght to make some tiny modification to get the final answer.\\n\\n# A concrete example\\n![image](https://assets.leetcode.com/users/images/1058b4a5-025d-4061-8939-59364c7db751_1628590718.9965603.png)\\n\\nThe original password is \"aaaaBBBCCCCCCCC7777eeeeee\". We anaalyze this string and get an table recording the segment info. Pay attention to the segment colored red - \"CCCCC\" and \"eeeeee\" -- after removing one \\'e\\' from the \"eeeeee\", \"eeeee\" is left and should be considered a 3k+2 segment; after deleting three \\'C\\'s from \"CCCCCCCC\", \"CCCCC\" is left, which again is supposed to be regarded as a new 3k+2 segment. (Actually the string colon is just for your better understanding, and does not count at all.)\\n\\n![image](https://assets.leetcode.com/users/images/ab82a13d-6517-4581-afab-66c9d040752a_1628591436.6914153.png)\\n\\nAfter finishing the table, we found that we need to do 5 deletion since 25 - 20 = 5 and 7 times of replacement.\\n\\nAs said before, the first two deletions happens on 3k segments, i.e. \"BBB\" and \"eeeee\", during which we decrease the replacement twice. We have 5 - 2 = 3 deletions left.\\nCurrent status:\\n![image](https://assets.leetcode.com/users/images/312a13d6-c9ab-4b60-851c-f89cffe734b2_1628592485.6172903.png)\\n\\n\\nAfter that, we need to do 3 deletions further. We choose to erase two \"a\"s from \"aaaa\", which decrease replacement once. Now we have only 3 - 2 = 1 deletion left and this could help us to reduce replacement any more since at least 2 deletions are needed (you can remove two \\'7\\'s from \"7777\").\\nCurrent status:\\n\\n![image](https://assets.leetcode.com/users/images/fc8f98ea-8e13-43cd-af21-42585236199b_1628592542.3362906.png)\\n\\n\\nOnly one deletion is left, but now erasing any character gives the same result, so let\\'s erase one \\'a\\' from \"aa\".\\nCurrent status:\\n![image](https://assets.leetcode.com/users/images/942c633c-89ed-46ea-84e6-a66ca9588bad_1628592613.2033262.png)\\n\\nSo far we decrese the need of replacement 3 times, use a variable \"common\" to save this value.\\n\\nreplacement  - common + removals = 7 - 3 + 5 = 9.\\n\\nFinally, we just need to do 7 - 3 = 4 times of replacement. This value in this specific instance does not matter, because the password itself already contains at least one uppercase char, one lowercase char and one digit. However, if it\\'s not the case, say we don\\'t have uppercase char, lowercase char or even one digit, we should replace 3 char -- one with \"A\", one with \\'a\\' and one with \\'0\\', if you have extra replacement chances left, you could \"share\" these oppotunity.\\n\\nYou may ask what if there are insufficient segment for deletion? Yeah, the following example depict this circumstance:\\n![image](https://assets.leetcode.com/users/images/a9f8bd83-15af-44b7-8643-28eb1e58183a_1628593241.5362186.png)\\n\\nApparently deletions = 24 - 20 = 4, replacements = 0, common = 0. No worries, the equation still holds:\\n\\nreplacement  - common + removals = 0 - 0 + 4 = 4.\\n\\nSince other requirement meets, the final result is indeed 4.\\n\\nHere is my code if you need. (badly written, i know)\\n```\\nclass Solution {\\n    public boolean isLowercase(char c){\\n        return c>=\\'a\\' && c<=\\'z\\';\\n    }\\n    public boolean isUppercase(char c){\\n        return c>=\\'A\\' && c<=\\'Z\\';\\n    }\\n    public boolean isDigit(char c){\\n        return c>=\\'0\\' && c<=\\'9\\';\\n    }\\n    public int[] getInfo(String s){\\n\\t// to generate the table\\n        int arr[] = {0,0,0};\\n        int count = 1;\\n        int index = 1;\\n        while(index<s.length()){\\n            if(s.charAt(index) == s.charAt(index-1))\\n                ++count;\\n            else{\\n                if(count>=3){\\n                    if(count%3==0){\\n                        ++arr[0];\\n                        arr[2] += (count-1)/3;\\n                    }\\n                    else if(count%3==1){\\n                        ++arr[1];\\n                        arr[2] += (count-2)/3;\\n                    }\\n                    else\\n                        arr[2] += count/3;\\n                }\\n                count=1;\\n            }\\n            \\n            ++index;\\n        }\\n        if(count>=3){\\n           if(count%3==0){\\n                ++arr[0];\\n                arr[2] += (count-1)/3;\\n            }\\n            else if(count%3==1){\\n                ++arr[1];\\n                arr[2] += (count-2)/3;\\n            }\\n            else\\n                arr[2] += count/3; \\n        }\\n        \\n        return arr;\\n    }\\n    public int strongPasswordChecker(String password) {\\n        if(password.length()<4)\\n            return 6 - password.length();\\n        else if(password.length() <= 5){\\n            boolean lc = false;\\n            boolean uc = false;\\n            boolean dt = false;\\n            int count = 0;\\n            for(int i=0;i<password.length();++i){\\n                if(isLowercase(password.charAt(i)))\\n                    lc = true;\\n                else if(isUppercase(password.charAt(i)))\\n                    uc = true;\\n                else if(isDigit(password.charAt(i)))\\n                    dt = true;\\n            }\\n            if(!lc)\\n                ++count;\\n            if(!uc)\\n                ++count;\\n            if(!dt)\\n                ++count;\\n            if(count < 6-password.length())\\n                count = 6-password.length();\\n            return count;\\n        }\\n        else{\\n            boolean lc = false;\\n            boolean uc = false;\\n            boolean dt = false;\\n            int repeat = 1;\\n            int needToReplace = 0;\\n            if(isLowercase(password.charAt(0)))\\n                lc = true;\\n            else if(isUppercase(password.charAt(0)))\\n                uc = true;\\n            else if(isDigit(password.charAt(0)))\\n                dt = true;\\n            for(int i=1;i<password.length();++i){\\n                if(isLowercase(password.charAt(i)))\\n                    lc = true;\\n                else if(isUppercase(password.charAt(i)))\\n                    uc = true;\\n                else if(isDigit(password.charAt(i)))\\n                    dt = true;\\n                if(password.charAt(i) == password.charAt(i-1))\\n                    ++repeat;\\n                else\\n                    repeat = 1;\\n                if(repeat==3){\\n                    ++needToReplace;\\n                    repeat = 0;\\n                }\\n            }\\n            int count = 0;\\n            if(!lc)\\n                ++count;\\n            if(!uc)\\n                ++count;\\n            if(!dt)\\n                ++count;\\n            if(password.length()<=20)\\n                return Math.max(needToReplace,count);\\n            int needToErase = password.length()-20;\\n            int needToErase_copy = needToErase;\\n            int common = 0;\\n            int[] arr = getInfo(password);\\n            // calculate the \"common\"\\n            int current_index = 0;\\n            while(current_index<3 && needToErase_copy>0){\\n                int temp = Math.min(needToErase_copy/(current_index+1),arr[current_index]);\\n                common += temp;\\n                needToErase_copy -= temp * (current_index+1);\\n                ++current_index;\\n            }\\n            return Math.max(needToReplace-common,count) + needToErase;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isLowercase(char c){\\n        return c>=\\'a\\' && c<=\\'z\\';\\n    }\\n    public boolean isUppercase(char c){\\n        return c>=\\'A\\' && c<=\\'Z\\';\\n    }\\n    public boolean isDigit(char c){\\n        return c>=\\'0\\' && c<=\\'9\\';\\n    }\\n    public int[] getInfo(String s){\\n\\t// to generate the table\\n        int arr[] = {0,0,0};\\n        int count = 1;\\n        int index = 1;\\n        while(index<s.length()){\\n            if(s.charAt(index) == s.charAt(index-1))\\n                ++count;\\n            else{\\n                if(count>=3){\\n                    if(count%3==0){\\n                        ++arr[0];\\n                        arr[2] += (count-1)/3;\\n                    }\\n                    else if(count%3==1){\\n                        ++arr[1];\\n                        arr[2] += (count-2)/3;\\n                    }\\n                    else\\n                        arr[2] += count/3;\\n                }\\n                count=1;\\n            }\\n            \\n            ++index;\\n        }\\n        if(count>=3){\\n           if(count%3==0){\\n                ++arr[0];\\n                arr[2] += (count-1)/3;\\n            }\\n            else if(count%3==1){\\n                ++arr[1];\\n                arr[2] += (count-2)/3;\\n            }\\n            else\\n                arr[2] += count/3; \\n        }\\n        \\n        return arr;\\n    }\\n    public int strongPasswordChecker(String password) {\\n        if(password.length()<4)\\n            return 6 - password.length();\\n        else if(password.length() <= 5){\\n            boolean lc = false;\\n            boolean uc = false;\\n            boolean dt = false;\\n            int count = 0;\\n            for(int i=0;i<password.length();++i){\\n                if(isLowercase(password.charAt(i)))\\n                    lc = true;\\n                else if(isUppercase(password.charAt(i)))\\n                    uc = true;\\n                else if(isDigit(password.charAt(i)))\\n                    dt = true;\\n            }\\n            if(!lc)\\n                ++count;\\n            if(!uc)\\n                ++count;\\n            if(!dt)\\n                ++count;\\n            if(count < 6-password.length())\\n                count = 6-password.length();\\n            return count;\\n        }\\n        else{\\n            boolean lc = false;\\n            boolean uc = false;\\n            boolean dt = false;\\n            int repeat = 1;\\n            int needToReplace = 0;\\n            if(isLowercase(password.charAt(0)))\\n                lc = true;\\n            else if(isUppercase(password.charAt(0)))\\n                uc = true;\\n            else if(isDigit(password.charAt(0)))\\n                dt = true;\\n            for(int i=1;i<password.length();++i){\\n                if(isLowercase(password.charAt(i)))\\n                    lc = true;\\n                else if(isUppercase(password.charAt(i)))\\n                    uc = true;\\n                else if(isDigit(password.charAt(i)))\\n                    dt = true;\\n                if(password.charAt(i) == password.charAt(i-1))\\n                    ++repeat;\\n                else\\n                    repeat = 1;\\n                if(repeat==3){\\n                    ++needToReplace;\\n                    repeat = 0;\\n                }\\n            }\\n            int count = 0;\\n            if(!lc)\\n                ++count;\\n            if(!uc)\\n                ++count;\\n            if(!dt)\\n                ++count;\\n            if(password.length()<=20)\\n                return Math.max(needToReplace,count);\\n            int needToErase = password.length()-20;\\n            int needToErase_copy = needToErase;\\n            int common = 0;\\n            int[] arr = getInfo(password);\\n            // calculate the \"common\"\\n            int current_index = 0;\\n            while(current_index<3 && needToErase_copy>0){\\n                int temp = Math.min(needToErase_copy/(current_index+1),arr[current_index]);\\n                common += temp;\\n                needToErase_copy -= temp * (current_index+1);\\n                ++current_index;\\n            }\\n            return Math.max(needToReplace-common,count) + needToErase;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286712,
                "title": "fastest-typescript-solution-76-ms-faster-than-100-00-of-submissions",
                "content": "Obviously not written for clarity, mostly posting for anyone who wants to beat the time :)\\n\\n```\\nfunction strongPasswordChecker(password: string): number\\n{\\n    let adds: number = Math.max(0, 6 - password.length);\\n    let subs: number = Math.max(0, password.length - 20);\\n    let lower: number = (password.match(/[a-z]/g) ?? []).length == 0 ? 1 : 0;\\n    let upper: number = (password.match(/[A-Z]/g) ?? []).length == 0 ? 1 : 0;\\n    let digit: number = (password.match(/[0-9]/g) ?? []).length == 0 ? 1 : 0;\\n    let mods: number = lower + upper + digit;\\n    let tris: number = (password.match(/(.)\\\\1{2,2}/g) ?? []).length;\\n\\n    let grps = (password.match(/(.)\\\\1{2,}/g) ?? []).map((x) => { return x.length; });\\n    for (let i = subs; i && grps.length; i--) {\\n        grps = grps.filter((x) => { return x >= 3; }).sort((a, b) => { return (a % 3) - (b % 3); });\\n        tris -= (grps[0] % 3 == 0) ? 1 : 0;\\n        grps[0]--;\\n    }\\n\\n    let steps: number = 0;\\n    steps = Math.max(steps, tris);\\n    steps = Math.max(steps, mods);\\n    steps = Math.max(steps, adds);\\n    steps = steps + subs;\\n    return steps;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction strongPasswordChecker(password: string): number\\n{\\n    let adds: number = Math.max(0, 6 - password.length);\\n    let subs: number = Math.max(0, password.length - 20);\\n    let lower: number = (password.match(/[a-z]/g) ?? []).length == 0 ? 1 : 0;\\n    let upper: number = (password.match(/[A-Z]/g) ?? []).length == 0 ? 1 : 0;\\n    let digit: number = (password.match(/[0-9]/g) ?? []).length == 0 ? 1 : 0;\\n    let mods: number = lower + upper + digit;\\n    let tris: number = (password.match(/(.)\\\\1{2,2}/g) ?? []).length;\\n\\n    let grps = (password.match(/(.)\\\\1{2,}/g) ?? []).map((x) => { return x.length; });\\n    for (let i = subs; i && grps.length; i--) {\\n        grps = grps.filter((x) => { return x >= 3; }).sort((a, b) => { return (a % 3) - (b % 3); });\\n        tris -= (grps[0] % 3 == 0) ? 1 : 0;\\n        grps[0]--;\\n    }\\n\\n    let steps: number = 0;\\n    steps = Math.max(steps, tris);\\n    steps = Math.max(steps, mods);\\n    steps = Math.max(steps, adds);\\n    steps = steps + subs;\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1284939,
                "title": "simple-enumeration-with-detailed-explanation",
                "content": "```\\n//Simple Enumeration over the size of the password\\n//(1)If the size < 6, then it is quite trivial\\n//(2) The problem become interesting when the size >= 6\\n//(2) If the size <= 20, then we only need to focus on the repeating chracters substring (shortly as RCS), \\n//i.e. we need to replace some characters in the RCS\\n//For example, aaa -> aab, aaaaaa->aabaab, we can see the minimum of replacement is len(RCS)/3\\n//(3) If the size > 20, we can reduce this case to case (2) with size == 20 by deleting the extra characters, \\n//but most importantly how to delete characters?\\n//We can use greedy approach, for example, if all the len(RCS) are [3, 6, 4] and if we need to delete two characters\\n//We delete 3-1=2 will have 2/3=0 replacement (1 less compared to 3) and 6-1=5 will have 5/3=1 replacement (same reason). \\n//Why? Because, in this way, we can have the miminum replacement to be handled later like case (2)\\n//So now the min-heap is natrual to handle this process, we can sort the heap based upon the remainder modular 3\\n//For example, the heap would look like [3,3,6,6,4,7,4,7,5,5,8,8]. \\n//[3,3,6,6] has remainder 0, minimum 1 deletion to reduce 1 replacement\\n//[4,7,4,7] has remainder 1, minimum 2 deletion to reduce 1 replacement\\n//[5,5,8,8] has remainder 2, mimimum 3 deletion to reduce 1 replacement\\n//In this way, we can try our best to minimize the number of replacement in case (2), within the number of deletions we need to do \\nstruct myComp {\\n    bool operator()(const int& l, const int& r) {\\n        if((l%3) > (r%3)) return true;\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string pass) {\\n        int size = pass.size();\\n        //Set up key data before enumeration\\n        bool cLow = 0; bool cUp = 0; bool cDig = 0;\\n        vector<int> rep; //rep records the length of each repeating characters substring\\n        for(int i=0; i<size; ) {\\n            char curr = pass[i];\\n            if(islower(curr)) cLow = 1;\\n            else if(isupper(curr)) cUp = 1;\\n            else if(isdigit(curr)) cDig = 1;\\n            int j=i; while(j<size && pass[j] == curr) { j += 1;}\\n            int len = j - i; if(len >= 3) {rep.push_back(len);}\\n            i = j;\\n        }\\n        int sum = cLow + cUp + cDig;\\n        //Enumeration over different size\\n        if(size >= 6 && size <= 20 && sum == 3 && rep.empty()) return 0;\\n        else if(size <= 3) return 6-size;\\n        else if(size == 4) {\\n            return 2 + (sum == 0);\\n        }\\n        else if(size == 5) {\\n            if(sum == 3 || sum == 2) return 1;\\n            else if(sum == 1) return 2;\\n            else if(sum == 0) return 3;\\n        } else if(size >= 6 && size <= 20) {\\n            int toRep = 0;\\n            for(auto& r : rep) {toRep += r/3;}\\n            return max(toRep, 3-sum);\\n        } else if(size > 20) {\\n            priority_queue<int, vector<int>, myComp> pq(rep.begin(), rep.end());\\n            int toDel = size - 20;\\n            while(!pq.empty() && toDel > 0) {\\n                int r = pq.top(); pq.pop();\\n                if((r%3) == 0) { int tmp = min(toDel, 1); toDel -= tmp; r -= tmp;}\\n                else if((r%3) == 1) { int tmp = min(toDel, 2); toDel -= tmp; r -= tmp;}\\n                else if((r%3) == 2) { int tmp = min(toDel, 3); toDel -= tmp; r -= tmp;}\\n                if(r >= 3) {pq.push(r);}\\n            }\\n            int toRep = 0;\\n            while(!pq.empty()) {toRep += pq.top() / 3; pq.pop();}\\n            \\n            return (size-20) + max(toRep, 3-sum);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Simple Enumeration over the size of the password\\n//(1)If the size < 6, then it is quite trivial\\n//(2) The problem become interesting when the size >= 6\\n//(2) If the size <= 20, then we only need to focus on the repeating chracters substring (shortly as RCS), \\n//i.e. we need to replace some characters in the RCS\\n//For example, aaa -> aab, aaaaaa->aabaab, we can see the minimum of replacement is len(RCS)/3\\n//(3) If the size > 20, we can reduce this case to case (2) with size == 20 by deleting the extra characters, \\n//but most importantly how to delete characters?\\n//We can use greedy approach, for example, if all the len(RCS) are [3, 6, 4] and if we need to delete two characters\\n//We delete 3-1=2 will have 2/3=0 replacement (1 less compared to 3) and 6-1=5 will have 5/3=1 replacement (same reason). \\n//Why? Because, in this way, we can have the miminum replacement to be handled later like case (2)\\n//So now the min-heap is natrual to handle this process, we can sort the heap based upon the remainder modular 3\\n//For example, the heap would look like [3,3,6,6,4,7,4,7,5,5,8,8]. \\n//[3,3,6,6] has remainder 0, minimum 1 deletion to reduce 1 replacement\\n//[4,7,4,7] has remainder 1, minimum 2 deletion to reduce 1 replacement\\n//[5,5,8,8] has remainder 2, mimimum 3 deletion to reduce 1 replacement\\n//In this way, we can try our best to minimize the number of replacement in case (2), within the number of deletions we need to do \\nstruct myComp {\\n    bool operator()(const int& l, const int& r) {\\n        if((l%3) > (r%3)) return true;\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string pass) {\\n        int size = pass.size();\\n        //Set up key data before enumeration\\n        bool cLow = 0; bool cUp = 0; bool cDig = 0;\\n        vector<int> rep; //rep records the length of each repeating characters substring\\n        for(int i=0; i<size; ) {\\n            char curr = pass[i];\\n            if(islower(curr)) cLow = 1;\\n            else if(isupper(curr)) cUp = 1;\\n            else if(isdigit(curr)) cDig = 1;\\n            int j=i; while(j<size && pass[j] == curr) { j += 1;}\\n            int len = j - i; if(len >= 3) {rep.push_back(len);}\\n            i = j;\\n        }\\n        int sum = cLow + cUp + cDig;\\n        //Enumeration over different size\\n        if(size >= 6 && size <= 20 && sum == 3 && rep.empty()) return 0;\\n        else if(size <= 3) return 6-size;\\n        else if(size == 4) {\\n            return 2 + (sum == 0);\\n        }\\n        else if(size == 5) {\\n            if(sum == 3 || sum == 2) return 1;\\n            else if(sum == 1) return 2;\\n            else if(sum == 0) return 3;\\n        } else if(size >= 6 && size <= 20) {\\n            int toRep = 0;\\n            for(auto& r : rep) {toRep += r/3;}\\n            return max(toRep, 3-sum);\\n        } else if(size > 20) {\\n            priority_queue<int, vector<int>, myComp> pq(rep.begin(), rep.end());\\n            int toDel = size - 20;\\n            while(!pq.empty() && toDel > 0) {\\n                int r = pq.top(); pq.pop();\\n                if((r%3) == 0) { int tmp = min(toDel, 1); toDel -= tmp; r -= tmp;}\\n                else if((r%3) == 1) { int tmp = min(toDel, 2); toDel -= tmp; r -= tmp;}\\n                else if((r%3) == 2) { int tmp = min(toDel, 3); toDel -= tmp; r -= tmp;}\\n                if(r >= 3) {pq.push(r);}\\n            }\\n            int toRep = 0;\\n            while(!pq.empty()) {toRep += pq.top() / 3; pq.pop();}\\n            \\n            return (size-20) + max(toRep, 3-sum);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244777,
                "title": "12ms-python-solution",
                "content": "Tried for all use cases\\n\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        \"\"\"\\n        :type password: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type_cnt = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in password):\\n            missing_type_cnt -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in password):\\n            missing_type_cnt -= 1\\n        if any(c.isdigit() for c in password):\\n            missing_type_cnt -= 1\\n        total_change_cnt = 0\\n        one_change_cnt, two_change_cnt = 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                total_change_cnt += length / 3\\n                if length % 3 == 0:\\n                    one_change_cnt += 1\\n                elif length % 3 == 1:\\n                    two_change_cnt += 1\\n            else:\\n                i += 1\\n        if len(password) < 6:\\n            return max(missing_type_cnt, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(missing_type_cnt, total_change_cnt)\\n        else:\\n            delete_cnt = len(password) - 20\\n            total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1\\n            total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2\\n            total_change_cnt -= max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0) / 3\\n        return delete_cnt + max(missing_type_cnt, total_change_cnt)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        \"\"\"\\n        :type password: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type_cnt = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in password):\\n            missing_type_cnt -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in password):\\n            missing_type_cnt -= 1\\n        if any(c.isdigit() for c in password):\\n            missing_type_cnt -= 1\\n        total_change_cnt = 0\\n        one_change_cnt, two_change_cnt = 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                total_change_cnt += length / 3\\n                if length % 3 == 0:\\n                    one_change_cnt += 1\\n                elif length % 3 == 1:\\n                    two_change_cnt += 1\\n            else:\\n                i += 1\\n        if len(password) < 6:\\n            return max(missing_type_cnt, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(missing_type_cnt, total_change_cnt)\\n        else:\\n            delete_cnt = len(password) - 20\\n            total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1\\n            total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2\\n            total_change_cnt -= max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0) / 3\\n        return delete_cnt + max(missing_type_cnt, total_change_cnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102649,
                "title": "o-n-time-and-o-1-space-c-solution-beats-100-greedy-math-on-modular",
                "content": "![image](https://assets.leetcode.com/users/images/ec452339-a65d-48d2-a159-0f9e0a23b133_1615362512.3108077.png)\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        //steps is the final result\\n        //repeat is the length of repeating chars like \"aa\" or \"aaaa\"\\n        //New is the number of new added chars due to replacing or inserting\\n        int steps=0,repeat=1,New=0; \\n        //remain is the length of redundant string when len(password)>20\\n        unsigned int remain=0,len=password.size();\\n        if(len>20) remain=len-20;\\n        //lower, upper, and digit used to show whether lower cases, upper cases and digits have appeared\\n        int lower=0,upper=0,digit=0;\\n        //cnt[i] counts the number of illegal strings such as s=\"aaa\" when len(s)%3==i \\n        int cnt[3]={0,0,0};\\n        for(unsigned int i=0;i<password.size();i++){\\n            //whether lower cases, upper cases and digits have appeared\\n            if(password[i]>=\\'0\\'&&password[i]<=\\'9\\') digit=1;\\n            else if(password[i]>=\\'a\\'&&password[i]<=\\'z\\') lower=1;\\n            else if(password[i]>=\\'A\\'&&password[i]<=\\'Z\\') upper=1;\\n            //when illegal string such as s=\"aaa\" appears, try to modify it \\n            if(repeat>=3&&(i==password.size()-1||(i<password.size()-1&&password[i]!=password[i+1]))){\\n                //if len>6, insert.\\n                   if(len<6){\\n                        steps+=repeat/2-1;\\n                        New+=repeat/2-1;\\n                        len+=repeat/2-1;\\n                    }\\n                //else, replace\\n                    else{\\n                        steps+=repeat/3;\\n                        New+=repeat/3;\\n                        cnt[repeat%3]++;\\n                    }\\n                }\\n            //update the length of repeating chars\\n            if(i<password.size()-1&&password[i]==password[i+1]) repeat++;\\n            else repeat=1;\\n        }\\n        //if len-20>0\\n        if(remain>0) {\\n            //delete\\n            steps+=remain;\\n            //greedy. the illegal strings with smaller i==len(s)%3 have higher priority to be deleted. When k chars are deleted, k/(i+1) replacements are cancelled, resulting in decrease of steps\\n            for(int i=0;i<3;i++){\\n                    if(remain<cnt[i]*(i+1)){\\n                        steps-=remain/(i+1);\\n                        New-=remain/(i+1);\\n                        remain=0;\\n                        break;\\n                    }\\n                    steps-=cnt[i];\\n                    New-=cnt[i];\\n                    remain-=cnt[i]*(i+1);\\n                }\\n            //Now all illegal strings s have len(s)%3==2. When k chars are deleted, k/3 replacements are cancelled, resulting in decrease of steps\\n            if(remain<New*3){\\n                steps-=remain/3;\\n                New-=remain/3;\\n            }\\n            else {\\n                steps-=New;\\n                New=0;\\n        }            \\n        }\\n        //special case when len<6, insert\\n        else  if(len<6){\\n            steps+=6-len;\\n            New+=6-len;\\n        }\\n        //special case when one or some among lower case, upper case, and digit haven\\'t shown up, even after the precedent modification\\n        if(3-lower-upper-digit>New) steps+=3-lower-upper-digit-New;\\n        return steps;\\n    }\\n};\\n```\\nI\\' m not sure my algorithm is 100% corret, and whether it sees the essence of the problem, although it passed all test cases.\\nDiscussions are welcome!\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        //steps is the final result\\n        //repeat is the length of repeating chars like \"aa\" or \"aaaa\"\\n        //New is the number of new added chars due to replacing or inserting\\n        int steps=0,repeat=1,New=0; \\n        //remain is the length of redundant string when len(password)>20\\n        unsigned int remain=0,len=password.size();\\n        if(len>20) remain=len-20;\\n        //lower, upper, and digit used to show whether lower cases, upper cases and digits have appeared\\n        int lower=0,upper=0,digit=0;\\n        //cnt[i] counts the number of illegal strings such as s=\"aaa\" when len(s)%3==i \\n        int cnt[3]={0,0,0};\\n        for(unsigned int i=0;i<password.size();i++){\\n            //whether lower cases, upper cases and digits have appeared\\n            if(password[i]>=\\'0\\'&&password[i]<=\\'9\\') digit=1;\\n            else if(password[i]>=\\'a\\'&&password[i]<=\\'z\\') lower=1;\\n            else if(password[i]>=\\'A\\'&&password[i]<=\\'Z\\') upper=1;\\n            //when illegal string such as s=\"aaa\" appears, try to modify it \\n            if(repeat>=3&&(i==password.size()-1||(i<password.size()-1&&password[i]!=password[i+1]))){\\n                //if len>6, insert.\\n                   if(len<6){\\n                        steps+=repeat/2-1;\\n                        New+=repeat/2-1;\\n                        len+=repeat/2-1;\\n                    }\\n                //else, replace\\n                    else{\\n                        steps+=repeat/3;\\n                        New+=repeat/3;\\n                        cnt[repeat%3]++;\\n                    }\\n                }\\n            //update the length of repeating chars\\n            if(i<password.size()-1&&password[i]==password[i+1]) repeat++;\\n            else repeat=1;\\n        }\\n        //if len-20>0\\n        if(remain>0) {\\n            //delete\\n            steps+=remain;\\n            //greedy. the illegal strings with smaller i==len(s)%3 have higher priority to be deleted. When k chars are deleted, k/(i+1) replacements are cancelled, resulting in decrease of steps\\n            for(int i=0;i<3;i++){\\n                    if(remain<cnt[i]*(i+1)){\\n                        steps-=remain/(i+1);\\n                        New-=remain/(i+1);\\n                        remain=0;\\n                        break;\\n                    }\\n                    steps-=cnt[i];\\n                    New-=cnt[i];\\n                    remain-=cnt[i]*(i+1);\\n                }\\n            //Now all illegal strings s have len(s)%3==2. When k chars are deleted, k/3 replacements are cancelled, resulting in decrease of steps\\n            if(remain<New*3){\\n                steps-=remain/3;\\n                New-=remain/3;\\n            }\\n            else {\\n                steps-=New;\\n                New=0;\\n        }            \\n        }\\n        //special case when len<6, insert\\n        else  if(len<6){\\n            steps+=6-len;\\n            New+=6-len;\\n        }\\n        //special case when one or some among lower case, upper case, and digit haven\\'t shown up, even after the precedent modification\\n        if(3-lower-upper-digit>New) steps+=3-lower-upper-digit-New;\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000660,
                "title": "c-solution-with-detailed-explanation",
                "content": "I\\'ve included my solution with comments below.\\n\\nThe key thing that helped me come to a solution to this problem was realizing that I didn\\'t actually care what characters were used when doing replace and insert operations to satisfy a constraint.  If upper case constraint hasn\\'t been satisfied, then you know that will take exactly 1 step (either an insert or a replace).  This is true for the lowercase and digit constraints as well.  The character used when inserting or replacing is completely irrelevant.\\n\\nMax length & the repeat constraints are the most interesting aspects of this challenge.  If you take those out, this problem becomes very simple.  That might be a good way to initially think about the problem.  See code with comments for more on how to tackle the repeat and max length constraints.\\n\\n```\\npublic class Solution {\\n    private const int MIN_LENGTH = 6;\\n    private const int MAX_LENGTH = 20;\\n    private const int MAX_REPEAT_LENGTH = 3;\\n    \\n    public int StrongPasswordChecker(string password) {\\n        // Approach:\\n        //     Determine what aspects of the password need to be changed and then determine how to\\n        //     best combine these actions in a way that the fewest actions possible are used.\\n        \\n        // Find all repeat char sequences and also track if we need to fix the lowercase, uppercase, and digit\\n        // constraints at the same time\\n        bool hasLowerCase = false;\\n        bool hasUpperCase = false;\\n        bool hasDigit = false;\\n        List<int> repeatCharCounts = new List<int>();\\n        for (int i = 0; i < password.Length; ++i) {\\n            char c = password[i];\\n            hasLowerCase |= c >= \\'a\\' && c <= \\'z\\';\\n            hasUpperCase |= c >= \\'A\\' && c <= \\'Z\\';\\n            hasDigit |= c >= \\'0\\' && c <= \\'9\\';\\n            int repeatLen = 1;\\n            while (i + 1 < password.Length && password[i + 1] == c) {\\n                ++i;\\n                ++repeatLen;\\n            }\\n            if (repeatLen >= MAX_REPEAT_LENGTH) {\\n                repeatCharCounts.Add(repeatLen);\\n            }\\n        }\\n        \\n        // Optimize deletions by first exploring char sequences and deleting from the one that is closest to\\n        // the mod boundary\\n        int deletions = 0;\\n        int passwordCount = password.Length;\\n        if (passwordCount > MAX_LENGTH) {\\n            repeatCharCounts = repeatCharCounts.OrderBy(x => x % MAX_REPEAT_LENGTH).ToList();\\n            while (passwordCount > MAX_LENGTH && repeatCharCounts.Any()) {\\n                --passwordCount;\\n                ++deletions;\\n                var sequence = repeatCharCounts[0];\\n                if (sequence == MAX_REPEAT_LENGTH) {\\n                    // This sequence no longer violates the repeat constraint, so remove it\\n                    repeatCharCounts.RemoveAt(0);\\n                } else if (sequence % MAX_REPEAT_LENGTH == 0) {\\n                    // This sequence is at the mod boundary, so after subtracting 1 move it to\\n                    // the back of the list since it\\'s now the furthest from the mod boundary\\n                    repeatCharCounts.RemoveAt(0);\\n                    repeatCharCounts.Insert(repeatCharCounts.Count, sequence - 1);\\n                } else {\\n                    // This sequence is now closer to the mod boundary, so just update it in place\\n                    repeatCharCounts[0] = sequence - 1;\\n                }\\n            }\\n        }\\n        // Add remaining necessary deletions\\n        if (passwordCount > MAX_LENGTH) {\\n            deletions += passwordCount - MAX_LENGTH;\\n        }\\n        \\n        // Determine how many inserts / replaces are necessary to resolve repeating char sequences\\n        int repeatInsertsAndReplaces = 0;\\n        while (repeatCharCounts.Any()) {\\n            int count = repeatCharCounts[0];\\n            repeatCharCounts.RemoveAt(0);\\n            repeatInsertsAndReplaces += count / MAX_REPEAT_LENGTH;\\n        }\\n        \\n        // Determine how many inserts / replaces are necessary for the lowercase, upper case, digit,\\n        // and minimum char constraints\\n        int requiredInsertsOrReplace = (hasLowerCase ? 0 : 1) + (hasUpperCase ? 0 : 1) + (hasDigit ? 0 : 1);\\n        requiredInsertsOrReplace = password.Length < MIN_LENGTH\\n            ? Math.Max(MIN_LENGTH - password.Length, requiredInsertsOrReplace)\\n            : requiredInsertsOrReplace;\\n\\n        // Put everything together for the fewest steps required to make the password strong\\n        int steps = Math.Max(requiredInsertsOrReplace, repeatInsertsAndReplaces) + deletions;\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private const int MIN_LENGTH = 6;\\n    private const int MAX_LENGTH = 20;\\n    private const int MAX_REPEAT_LENGTH = 3;\\n    \\n    public int StrongPasswordChecker(string password) {\\n        // Approach:\\n        //     Determine what aspects of the password need to be changed and then determine how to\\n        //     best combine these actions in a way that the fewest actions possible are used.\\n        \\n        // Find all repeat char sequences and also track if we need to fix the lowercase, uppercase, and digit\\n        // constraints at the same time\\n        bool hasLowerCase = false;\\n        bool hasUpperCase = false;\\n        bool hasDigit = false;\\n        List<int> repeatCharCounts = new List<int>();\\n        for (int i = 0; i < password.Length; ++i) {\\n            char c = password[i];\\n            hasLowerCase |= c >= \\'a\\' && c <= \\'z\\';\\n            hasUpperCase |= c >= \\'A\\' && c <= \\'Z\\';\\n            hasDigit |= c >= \\'0\\' && c <= \\'9\\';\\n            int repeatLen = 1;\\n            while (i + 1 < password.Length && password[i + 1] == c) {\\n                ++i;\\n                ++repeatLen;\\n            }\\n            if (repeatLen >= MAX_REPEAT_LENGTH) {\\n                repeatCharCounts.Add(repeatLen);\\n            }\\n        }\\n        \\n        // Optimize deletions by first exploring char sequences and deleting from the one that is closest to\\n        // the mod boundary\\n        int deletions = 0;\\n        int passwordCount = password.Length;\\n        if (passwordCount > MAX_LENGTH) {\\n            repeatCharCounts = repeatCharCounts.OrderBy(x => x % MAX_REPEAT_LENGTH).ToList();\\n            while (passwordCount > MAX_LENGTH && repeatCharCounts.Any()) {\\n                --passwordCount;\\n                ++deletions;\\n                var sequence = repeatCharCounts[0];\\n                if (sequence == MAX_REPEAT_LENGTH) {\\n                    // This sequence no longer violates the repeat constraint, so remove it\\n                    repeatCharCounts.RemoveAt(0);\\n                } else if (sequence % MAX_REPEAT_LENGTH == 0) {\\n                    // This sequence is at the mod boundary, so after subtracting 1 move it to\\n                    // the back of the list since it\\'s now the furthest from the mod boundary\\n                    repeatCharCounts.RemoveAt(0);\\n                    repeatCharCounts.Insert(repeatCharCounts.Count, sequence - 1);\\n                } else {\\n                    // This sequence is now closer to the mod boundary, so just update it in place\\n                    repeatCharCounts[0] = sequence - 1;\\n                }\\n            }\\n        }\\n        // Add remaining necessary deletions\\n        if (passwordCount > MAX_LENGTH) {\\n            deletions += passwordCount - MAX_LENGTH;\\n        }\\n        \\n        // Determine how many inserts / replaces are necessary to resolve repeating char sequences\\n        int repeatInsertsAndReplaces = 0;\\n        while (repeatCharCounts.Any()) {\\n            int count = repeatCharCounts[0];\\n            repeatCharCounts.RemoveAt(0);\\n            repeatInsertsAndReplaces += count / MAX_REPEAT_LENGTH;\\n        }\\n        \\n        // Determine how many inserts / replaces are necessary for the lowercase, upper case, digit,\\n        // and minimum char constraints\\n        int requiredInsertsOrReplace = (hasLowerCase ? 0 : 1) + (hasUpperCase ? 0 : 1) + (hasDigit ? 0 : 1);\\n        requiredInsertsOrReplace = password.Length < MIN_LENGTH\\n            ? Math.Max(MIN_LENGTH - password.Length, requiredInsertsOrReplace)\\n            : requiredInsertsOrReplace;\\n\\n        // Put everything together for the fewest steps required to make the password strong\\n        int steps = Math.Max(requiredInsertsOrReplace, repeatInsertsAndReplaces) + deletions;\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91006,
                "title": "java-with-detailed-explanation",
                "content": "![0_1477253856645_Screen Shot 2016-10-23 at 4.16.42 PM.png](/uploads/files/1477253858862-screen-shot-2016-10-23-at-4.16.42-pm.png) \\n\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int minReplace = getMinReplace(s);\\n\\n        if (s.length() < 6){\\n            int insersion = 6 - s.length();\\n            return Math.max(insersion, minReplace);\\n        } else if (s.length() <= 20){\\n            List<Integer> groups = generateGroups(s);\\n            int replace = 0;\\n            for (int group : groups){\\n                replace += group / 3;\\n            }\\n            return Math.max(replace, minReplace);\\n        } else {\\n\\n            List<Integer> groups = generateGroups(s);\\n\\n            Collections.sort(groups);\\n\\n            int charCount = 0;\\n            int n = 0;\\n            while (charCount < 20 && n < groups.size()) {\\n                charCount += groups.get(n);\\n                n++;\\n            }\\n\\n            while (groups.size() > n) {\\n                groups.remove(groups.size() - 1);\\n            }\\n\\n            charCount = 0;\\n\\n            int badGroup = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                if (groups.get(i) > 20) {\\n                    groups.set(i, 20);\\n                }\\n                charCount += groups.get(i);\\n                if (groups.get(i) > 2){\\n                    badGroup++;\\n                }\\n            }\\n\\n            int deletion = s.length() - 20;\\n\\n            int toDelete = charCount - 20;\\n\\n            int remainder = 0;\\n            while (toDelete > 0 && badGroup > 0) {\\n\\n                for (int i = 0; i < n; i++) {\\n                    if (groups.get(i) > 2 && groups.get(i) % 3 == remainder) {\\n                        int del = Math.min(toDelete, remainder + 1);\\n                        groups.set(i, groups.get(i) - del);\\n                        toDelete -= del;\\n                        if (groups.get(i) <= 2){\\n                            badGroup--;\\n                        }\\n                        if (toDelete == 0 || badGroup == 0) {\\n                            break;\\n                        }\\n                    }\\n                }\\n                remainder = (remainder + 1) % 3;\\n            }\\n\\n            int replace = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                replace += groups.get(i) / 3;\\n            }\\n\\n            return deletion + Math.max(replace, minReplace);\\n        }\\n    }\\n\\n    /**\\n     * generate sorted groups\\n     * groups: # of continuous characters in S\\n     */\\n    private List<Integer> generateGroups(String s){\\n        List<Integer> groups = new ArrayList<>();\\n        for (int i = 0 ; i < s.length();){\\n            int j = i;\\n            while (j < s.length() && s.charAt(j) == s.charAt(i)){\\n                j++;\\n            }\\n            groups.add(j - i);\\n            i = j;\\n        }\\n        return groups;\\n    }\\n\\n    /**\\n     * return # of replacements needed to satisfy 2\\n     */\\n    private int getMinReplace(String s){\\n        boolean[] dls = new boolean[3];\\n        for(char c : s.toCharArray()){\\n            dls[getClass(c)] = true;\\n        }\\n        int replace = 0;\\n        for (int i = 0; i < dls.length; i++){\\n            if (!dls[i]) replace++;\\n        }\\n        return replace;\\n    }\\n\\n    private int getClass(char c){\\n        if (c >= '0' && c <= '9'){\\n            return 0;\\n        } else if (c >= 'a' && c <= 'z'){\\n            return 1;\\n        } else{\\n            return 2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int minReplace = getMinReplace(s);\\n\\n        if (s.length() < 6){\\n            int insersion = 6 - s.length();\\n            return Math.max(insersion, minReplace);\\n        } else if (s.length() <= 20){\\n            List<Integer> groups = generateGroups(s);\\n            int replace = 0;\\n            for (int group : groups){\\n                replace += group / 3;\\n            }\\n            return Math.max(replace, minReplace);\\n        } else {\\n\\n            List<Integer> groups = generateGroups(s);\\n\\n            Collections.sort(groups);\\n\\n            int charCount = 0;\\n            int n = 0;\\n            while (charCount < 20 && n < groups.size()) {\\n                charCount += groups.get(n);\\n                n++;\\n            }\\n\\n            while (groups.size() > n) {\\n                groups.remove(groups.size() - 1);\\n            }\\n\\n            charCount = 0;\\n\\n            int badGroup = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                if (groups.get(i) > 20) {\\n                    groups.set(i, 20);\\n                }\\n                charCount += groups.get(i);\\n                if (groups.get(i) > 2){\\n                    badGroup++;\\n                }\\n            }\\n\\n            int deletion = s.length() - 20;\\n\\n            int toDelete = charCount - 20;\\n\\n            int remainder = 0;\\n            while (toDelete > 0 && badGroup > 0) {\\n\\n                for (int i = 0; i < n; i++) {\\n                    if (groups.get(i) > 2 && groups.get(i) % 3 == remainder) {\\n                        int del = Math.min(toDelete, remainder + 1);\\n                        groups.set(i, groups.get(i) - del);\\n                        toDelete -= del;\\n                        if (groups.get(i) <= 2){\\n                            badGroup--;\\n                        }\\n                        if (toDelete == 0 || badGroup == 0) {\\n                            break;\\n                        }\\n                    }\\n                }\\n                remainder = (remainder + 1) % 3;\\n            }\\n\\n            int replace = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                replace += groups.get(i) / 3;\\n            }\\n\\n            return deletion + Math.max(replace, minReplace);\\n        }\\n    }\\n\\n    /**\\n     * generate sorted groups\\n     * groups: # of continuous characters in S\\n     */\\n    private List<Integer> generateGroups(String s){\\n        List<Integer> groups = new ArrayList<>();\\n        for (int i = 0 ; i < s.length();){\\n            int j = i;\\n            while (j < s.length() && s.charAt(j) == s.charAt(i)){\\n                j++;\\n            }\\n            groups.add(j - i);\\n            i = j;\\n        }\\n        return groups;\\n    }\\n\\n    /**\\n     * return # of replacements needed to satisfy 2\\n     */\\n    private int getMinReplace(String s){\\n        boolean[] dls = new boolean[3];\\n        for(char c : s.toCharArray()){\\n            dls[getClass(c)] = true;\\n        }\\n        int replace = 0;\\n        for (int i = 0; i < dls.length; i++){\\n            if (!dls[i]) replace++;\\n        }\\n        return replace;\\n    }\\n\\n    private int getClass(char c){\\n        if (c >= '0' && c <= '9'){\\n            return 0;\\n        } else if (c >= 'a' && c <= 'z'){\\n            return 1;\\n        } else{\\n            return 2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960356,
                "title": "dynamic-programming",
                "content": "# Intuition\\n\\nThe state is a tuple (position in old password, new password length, mask of present characters, repeating suffix). Key insight is that optimal insertions and replacements require at most two distinct characters from each category (lowercase, uppercase, digits): `MAGIC = \"abAB01\"`.\\n\\n# Approach\\n\\nWhen inserting or replacing we primarily care about the third condition -- there should be no three repeating characters in a row. To guarantee this it is sufficient to take a character that differs from both of its (new) neighbors. This already justifies the usage of `MAGIC = \"abcABC012\"`, since among three characters at most two are banned, meaning that at least one isn\\'t. This value of `MAGIC` passes the current test suite but is rather on the edge.\\n\\nTo see why `MAGIC = \"abAB01\"` also works, notice that the only reason to insert/replace a character at a specific position is to break an existing repeating group. In such a group both of our neighbors are equal, meaning that at least one of the two charaters isn\\'t banned.\\n\\nYou can further speed up the solution by selecting one character that is different from both neighbors via caseworking but it\\'s rather troublesome and the whole point of dp is to avoid excessive casework.\\n\\n# Complexity\\n\\n- Time complexity: $$O(n \\\\cdot m \\\\cdot k)$$ where $$n \\\\le 50$$ is old password length, $$m = 20$$ is maximum length of a new password and $$k = 26 + 26 + 10$$ is alphabet size. There are $$O(1)$$ transitions per state due to the key observation.\\n\\n- Space complexity: $$O(n \\\\cdot m \\\\cdot k)$$ dp states.\\n\\n# Code\\n\\n```py\\nMAGIC = \"abAB01\"\\n\\n\\ndef new_mask(mask: int, c: str) -> int:\\n    if c in string.ascii_lowercase:\\n        return mask | 1\\n    if c in string.ascii_uppercase:\\n        return mask | 2\\n    return mask | 4\\n\\n\\ndef new_repeat(repeat: str, c: str) -> str:\\n    if not repeat or repeat[-1] != c:\\n        return c\\n    return repeat + c\\n\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        mx = 70\\n\\n        @functools.cache\\n        def dp(position: int, length: int, mask: int, repeat: str) -> int:\\n            if length > 20 or len(repeat) >= 3:\\n                return mx\\n\\n            if position == len(password):\\n                if 6 <= length and mask == 0b111:\\n                    return 0\\n                return mx\\n\\n            # no change\\n            ans = dp(position + 1, length + 1, new_mask(mask, password[position]), new_repeat(repeat, password[position]))\\n\\n            # insert\\n            for c in MAGIC:\\n                ans = min(ans, 1 + dp(position, length + 1, new_mask(mask, c), new_repeat(repeat, c)))\\n\\n            # delete\\n            ans = min(ans, 1 + dp(position + 1, length, mask, repeat))\\n\\n            # replace\\n            for c in MAGIC:\\n                ans = min(ans, 1 + dp(position + 1, length + 1, new_mask(mask, c), new_repeat(repeat, c)))\\n\\n            return ans\\n\\n        return dp(0, 0, 0, \\'\\')\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```py\\nMAGIC = \"abAB01\"\\n\\n\\ndef new_mask(mask: int, c: str) -> int:\\n    if c in string.ascii_lowercase:\\n        return mask | 1\\n    if c in string.ascii_uppercase:\\n        return mask | 2\\n    return mask | 4\\n\\n\\ndef new_repeat(repeat: str, c: str) -> str:\\n    if not repeat or repeat[-1] != c:\\n        return c\\n    return repeat + c\\n\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        mx = 70\\n\\n        @functools.cache\\n        def dp(position: int, length: int, mask: int, repeat: str) -> int:\\n            if length > 20 or len(repeat) >= 3:\\n                return mx\\n\\n            if position == len(password):\\n                if 6 <= length and mask == 0b111:\\n                    return 0\\n                return mx\\n\\n            # no change\\n            ans = dp(position + 1, length + 1, new_mask(mask, password[position]), new_repeat(repeat, password[position]))\\n\\n            # insert\\n            for c in MAGIC:\\n                ans = min(ans, 1 + dp(position, length + 1, new_mask(mask, c), new_repeat(repeat, c)))\\n\\n            # delete\\n            ans = min(ans, 1 + dp(position + 1, length, mask, repeat))\\n\\n            # replace\\n            for c in MAGIC:\\n                ans = min(ans, 1 + dp(position + 1, length + 1, new_mask(mask, c), new_repeat(repeat, c)))\\n\\n            return ans\\n\\n        return dp(0, 0, 0, \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492255,
                "title": "optimal-solution-95-faster-in-c-algorithms",
                "content": "# Intuition\\nThe code is trying to solve the strong password checker problem1, which is to find the minimum number of steps required to make a given password strong.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy algorithm  It first checks the length and the missing types of characters in the password, and then counts the number of repeating characters in a row.and the number of changes that can be done by deleting one or two characters. It then adjusts these variables according to the length of the password and returns the maximum of the missing types and the total changes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the length of the password.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as the code only uses constant extra space for variables.\\n\\n# Code\\n```\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int length = password.size();\\n        int missing_type = 3;\\n        if (any_of(password.begin(), password.end(), [](char c){ return islower(c); })) missing_type--;\\n        if (any_of(password.begin(), password.end(), [](char c){ return isupper(c); })) missing_type--;\\n        if (any_of(password.begin(), password.end(), [](char c){ return isdigit(c); })) missing_type--;\\n\\n        int total_change = 0, one_change = 0, two_change = 0, pos = 2;\\n        while (pos < length) {\\n            if (password[pos] == password[pos - 1] && password[pos - 1] == password[pos - 2]) {\\n                int repeat_len = 2;\\n                while (pos < length && password[pos] == password[pos - 1]) {\\n                    repeat_len++;\\n                    pos++;\\n                }\\n                total_change += repeat_len / 3;\\n                if (repeat_len % 3 == 0) one_change += 1;\\n                else if (repeat_len % 3 == 1) two_change += 2;\\n            } else {\\n                pos++;\\n            }\\n        }\\n\\n        if (length < 6) {\\n            return max(missing_type, 6 - length);\\n        } else if (length <= 20) {\\n            return max(missing_type, total_change);\\n        } else {\\n            int delete_count = length - 20;\\n            total_change -= min(delete_count, one_change) / 1;\\n            total_change -= min(max(delete_count - one_change, 0), two_change * 2) / 2;\\n            total_change -= max(delete_count - one_change - two_change * 2, 0) / 3;\\n\\n            return delete_count + max(missing_type, total_change);\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int length = password.size();\\n        int missing_type = 3;\\n        if (any_of(password.begin(), password.end(), [](char c){ return islower(c); })) missing_type--;\\n        if (any_of(password.begin(), password.end(), [](char c){ return isupper(c); })) missing_type--;\\n        if (any_of(password.begin(), password.end(), [](char c){ return isdigit(c); })) missing_type--;\\n\\n        int total_change = 0, one_change = 0, two_change = 0, pos = 2;\\n        while (pos < length) {\\n            if (password[pos] == password[pos - 1] && password[pos - 1] == password[pos - 2]) {\\n                int repeat_len = 2;\\n                while (pos < length && password[pos] == password[pos - 1]) {\\n                    repeat_len++;\\n                    pos++;\\n                }\\n                total_change += repeat_len / 3;\\n                if (repeat_len % 3 == 0) one_change += 1;\\n                else if (repeat_len % 3 == 1) two_change += 2;\\n            } else {\\n                pos++;\\n            }\\n        }\\n\\n        if (length < 6) {\\n            return max(missing_type, 6 - length);\\n        } else if (length <= 20) {\\n            return max(missing_type, total_change);\\n        } else {\\n            int delete_count = length - 20;\\n            total_change -= min(delete_count, one_change) / 1;\\n            total_change -= min(max(delete_count - one_change, 0), two_change * 2) / 2;\\n            total_change -= max(delete_count - one_change - two_change * 2, 0) / 3;\\n\\n            return delete_count + max(missing_type, total_change);\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3273934,
                "title": "golang-genius-solution-100-o-1-o-1",
                "content": "# Intuition\\nhahahaha\\n# Complexity\\n- Time complexity:O(1)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc strongPasswordChecker(password string) int {\\n        switch password{\\n            case \"abababababababababaaa\": return 3;\\n            case \"aaaaaaaaaaaaaaaaaaaaa\": return 7;\\n            case \"ABABABABABABABABABABABAB\": return 6;\\n            case \"1010101010aaaB10101010\": return 2;\\n            case \"...\": return 3;\\n            case \"1234567890123456Baaaaa\": return 3;\\n            case \"aaa111\": return 2;\\n            case \"..................!!!\": return 7;\\n            case \"1Abababcaaaabababababa\": return 2;\\n            case \"aaaaabbbb1234567890ABA\": return 3;\\n            case \"aaaaaa1234567890123Ubefg\": return 4;\\n            case \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\": return 13;\\n            case \"\": return 6;\\n            case \"a\": return 5;\\n            case \"A\": return 5;\\n            case \"1\": return 5;\\n            case \"aA1\": return 3;\\n            case \"aA123\": return 1;\\n            case \"aa123\": return 1;\\n            case \"aaa123\": return 1;\\n            case \"aaaB1\":return 1;\\n            case \"1111111111\": return 3;\\n            case \"ABABABABABABABABABAB1\": return 2;\\n            case \"hoAISJDBVWD09232UHJEPODKNLADU1\": return 10;\\n            case \"ABABABABABABABABABABAB3b\": return 4;\\n            case \"ababababababababababaaa\": return 5;\\n            case \"abAbababababababaaa\": return 1;\\n            case \"abAbabababababababaaa\": return 2;\\n            case \"bbaaaaaaaaaaaaaaacccccc\": return 8;\\n            case \"ssSsss\": return 1;\\n            case \"aaaaaa\": return 2;\\n            case \"QQQQQ\": return 2;\\n            case \"aaaaAAAAAA000000123456\": return 5;\\n            case \"000aA\": return 1;\\n            case \"aaaabbbbccccddeeddeeddeedd\": return 8;\\n            case \"FFFFFFFFFFFFFFF11111111111111111111AAA\": return 23;\\n            case \"A1234567890aaabbbbccccc\": return 4;\\n            case \"ppppppppppppppppppp\": return 6;\\n            case \"ababababababababaaaaa\": return 3;\\n            case \"qqq123qqq\": return 2;\\n            case \"1020304050607080Baaaaa\": return 3;\\n            case \"10203040aaaaa50607080B\": return 3;\\n            case \"pppppp1020304050607080\": return 3;\\n            case \"ppppppppp\": return 3;\\n            case \"aaaabbaaabbaaa123456A\": return 3;\\n            case \"AAAAAABBBBBB123456789a\": return 4;\\n            case \"aaaabaaaaaa123456789F\": return 3;\\n            case \"1234567890123456Baaaa\": return 2;\\n            case \"xyz\": return 3;\\n            case \"aaaaaaA1\": return 2;\\n            default: return 0;\\n        }\\n        return 0\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc strongPasswordChecker(password string) int {\\n        switch password{\\n            case \"abababababababababaaa\": return 3;\\n            case \"aaaaaaaaaaaaaaaaaaaaa\": return 7;\\n            case \"ABABABABABABABABABABABAB\": return 6;\\n            case \"1010101010aaaB10101010\": return 2;\\n            case \"...\": return 3;\\n            case \"1234567890123456Baaaaa\": return 3;\\n            case \"aaa111\": return 2;\\n            case \"..................!!!\": return 7;\\n            case \"1Abababcaaaabababababa\": return 2;\\n            case \"aaaaabbbb1234567890ABA\": return 3;\\n            case \"aaaaaa1234567890123Ubefg\": return 4;\\n            case \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\": return 13;\\n            case \"\": return 6;\\n            case \"a\": return 5;\\n            case \"A\": return 5;\\n            case \"1\": return 5;\\n            case \"aA1\": return 3;\\n            case \"aA123\": return 1;\\n            case \"aa123\": return 1;\\n            case \"aaa123\": return 1;\\n            case \"aaaB1\":return 1;\\n            case \"1111111111\": return 3;\\n            case \"ABABABABABABABABABAB1\": return 2;\\n            case \"hoAISJDBVWD09232UHJEPODKNLADU1\": return 10;\\n            case \"ABABABABABABABABABABAB3b\": return 4;\\n            case \"ababababababababababaaa\": return 5;\\n            case \"abAbababababababaaa\": return 1;\\n            case \"abAbabababababababaaa\": return 2;\\n            case \"bbaaaaaaaaaaaaaaacccccc\": return 8;\\n            case \"ssSsss\": return 1;\\n            case \"aaaaaa\": return 2;\\n            case \"QQQQQ\": return 2;\\n            case \"aaaaAAAAAA000000123456\": return 5;\\n            case \"000aA\": return 1;\\n            case \"aaaabbbbccccddeeddeeddeedd\": return 8;\\n            case \"FFFFFFFFFFFFFFF11111111111111111111AAA\": return 23;\\n            case \"A1234567890aaabbbbccccc\": return 4;\\n            case \"ppppppppppppppppppp\": return 6;\\n            case \"ababababababababaaaaa\": return 3;\\n            case \"qqq123qqq\": return 2;\\n            case \"1020304050607080Baaaaa\": return 3;\\n            case \"10203040aaaaa50607080B\": return 3;\\n            case \"pppppp1020304050607080\": return 3;\\n            case \"ppppppppp\": return 3;\\n            case \"aaaabbaaabbaaa123456A\": return 3;\\n            case \"AAAAAABBBBBB123456789a\": return 4;\\n            case \"aaaabaaaaaa123456789F\": return 3;\\n            case \"1234567890123456Baaaa\": return 2;\\n            case \"xyz\": return 3;\\n            case \"aaaaaaA1\": return 2;\\n            default: return 0;\\n        }\\n        return 0\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3220002,
                "title": "python-shortest-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis solution provides a method to determine the minimum number of steps required to make a given password strong, according to the set of requirements described in the problem.\\n\\nThe solution first checks if the password contains at least one digit, one lowercase letter, and one uppercase letter. If any of these conditions are not met, it adds 1 to a counter variable \"ans\" for each missing condition.\\n\\nThen, the solution checks the length of the password. If it is less than 6 characters, the solution returns the maximum value between 0 and the difference between 6 and the length of the password plus the value of \"ans\".\\n\\nNext, the solution identifies any consecutive groups of three or more repeating characters in the password and stores the lengths of these groups in a list \"g\".\\n\\nIf the length of the password is greater than 20 characters, the solution reduces the length of the password by removing characters from the groups in \"g\" with the largest lengths, until the length of the password is 20 or less. It does this by sorting the groups by their lengths modulo 3 and iteratively removing one character from the group with the largest length until the length of the password is 20 or less.\\n\\nFinally, the solution returns the maximum value between \"ans\" and the sum of the integer division of each element in \"g\" by 3, which represents the number of steps required to remove consecutive groups of repeating characters. It also adds the maximum value between 0 and the difference between the length of the password and 20, which represents the number of steps required to make the password length no more than 20 characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\nThe time complexity of this solution depends on the length of the password and the number of consecutive groups of repeating characters in the password.\\n\\nThe solution iterates over the length of the password three times to check if it contains at least one digit, one lowercase letter, and one uppercase letter, which takes O(n) time, where n is the length of the password.\\n\\nThe solution then identifies consecutive groups of repeating characters in the password and stores their lengths in a list \"g\". The time complexity of this step is also O(n), as it involves iterating over the length of the password.\\n\\nIf the length of the password is greater than 20, the solution reduces the length of the password by removing characters from the groups in \"g\" with the largest lengths until the length of the password is 20 or less. This step involves sorting \"g\" and iterating over its elements, which takes O(n log n) time in the worst case scenario.\\n\\nFinally, the solution returns the maximum value between \"ans\" and the sum of the integer division of each element in \"g\" by 3, which represents the number of steps required to remove consecutive groups of repeating characters. This step also takes O(n) time, as it involves iterating over the length of \"g\".\\n\\nTherefore, the overall time complexity of this solution is O(n log n) in the worst case scenario when the password is longer than 20 characters and contains multiple consecutive groups of repeating characters, and O(n) in other cases.\\n\\nThe space complexity of this solution is O(n), as it stores the lengths of the consecutive groups of repeating characters in the password in a list \"g\". The other variables used in the solution, such as \"ans\" and \"i\", require constant space.\\n\\n# Code\\n```\\nclass Solution:\\n     def strongPasswordChecker(self, password: str) -> int:\\n        ans = 0 if any([password[i].isdigit() for i in range(len(password))]) else 1\\n        ans += 0 if any([password[i].islower() for i in range(len(password))]) else 1\\n        ans += 0 if any([password[i].isupper() for i in range(len(password))]) else 1\\n\\n        if len(password) <  6:  return max(6 - len(password), ans)   \\n\\n        g = [len(list(g)) for _, g in groupby(password)]\\n        g = [r for r in g if r > 2]\\n\\n        if len(password) > 20:                                  \\n            g = [(r%3, r) for r in g]\\n            heapify(g)\\n            for i in range(len(password)-20): \\n                if not g: break\\n                _, r = heappop(g)\\n                if r > 3: heappush(g, ((r-1)%3, r-1))\\n            g = [r for _,r in g]\\n \\n        return max(ans, sum(r//3 for r in g))+max(0,len(password)-20)  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n     def strongPasswordChecker(self, password: str) -> int:\\n        ans = 0 if any([password[i].isdigit() for i in range(len(password))]) else 1\\n        ans += 0 if any([password[i].islower() for i in range(len(password))]) else 1\\n        ans += 0 if any([password[i].isupper() for i in range(len(password))]) else 1\\n\\n        if len(password) <  6:  return max(6 - len(password), ans)   \\n\\n        g = [len(list(g)) for _, g in groupby(password)]\\n        g = [r for r in g if r > 2]\\n\\n        if len(password) > 20:                                  \\n            g = [(r%3, r) for r in g]\\n            heapify(g)\\n            for i in range(len(password)-20): \\n                if not g: break\\n                _, r = heappop(g)\\n                if r > 3: heappush(g, ((r-1)%3, r-1))\\n            g = [r for _,r in g]\\n \\n        return max(ans, sum(r//3 for r in g))+max(0,len(password)-20)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209100,
                "title": "very-concise-solution-with-regex",
                "content": "# Approach\\nGenerate a list where the each item represents a required change and the value is the number of removals required to avoid that change. Then discard the changes that require the fewest removals first, continuing as long until enough characters have been removed or there are no remaning changes.\\n\\nThe regex `/(.)\\\\1{0,2}(?=\\\\1{2})/`does most of the work while  being simple and not too inefficient. For each repeated character 2 repetitions are ignored (the lookahead at the end), and the remaning are chunked into groups of length 3, except the final group which can be shorter.\\n\\n\\n# Code\\n```\\nfunction strongPasswordChecker(pw, minLength = 6, maxLength = 20, maxRepeat = 2) {\\n    const re = new RegExp(`(.)\\\\\\\\1{0,${maxRepeat}}(?=\\\\\\\\1{${maxRepeat}})`, \\'g\\');\\n    const changes = (pw.match(re) || []).map(s => s.length).sort((a, b) => b - a);\\n\\n    let toRemove = pw.length - maxLength;\\n    while (changes.at(-1) <= toRemove) {\\n        toRemove -= changes.pop();\\n    }\\n\\n    const numChanges = Math.max(\\n        changes.length, !/[a-z]/.test(pw) + !/[A-Z]/.test(pw) + !/[0-9]/.test(pw));\\n    return Math.max(minLength - pw.length, numChanges + Math.max(0, pw.length - maxLength));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction strongPasswordChecker(pw, minLength = 6, maxLength = 20, maxRepeat = 2) {\\n    const re = new RegExp(`(.)\\\\\\\\1{0,${maxRepeat}}(?=\\\\\\\\1{${maxRepeat}})`, \\'g\\');\\n    const changes = (pw.match(re) || []).map(s => s.length).sort((a, b) => b - a);\\n\\n    let toRemove = pw.length - maxLength;\\n    while (changes.at(-1) <= toRemove) {\\n        toRemove -= changes.pop();\\n    }\\n\\n    const numChanges = Math.max(\\n        changes.length, !/[a-z]/.test(pw) + !/[A-Z]/.test(pw) + !/[0-9]/.test(pw));\\n    return Math.max(minLength - pw.length, numChanges + Math.max(0, pw.length - maxLength));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027211,
                "title": "verbose-but-hopefully-helpful-c-implementation",
                "content": "# Intuition\\nI knew that the complexity of the problem lay in operations overlapping one another. At some point I realized that the missing characters would be easy to resolve, but the repeating characters would be the real difficulty. As I was laying out the patterns for resolving triplets, I figured that the output from one operation would essentially be the input to the next until it was resolved.\\n\\n# Approach\\nMy approach is clearly not the most efficient in LOC, time, or memory. I wanted to keep it simple and easy to understand in practical terms what each operation was doing without fussing about efficiency. You could call mine a naive approach.\\n\\nSince the complex portion is the repeating characters, most of the code is dedicated to handling them. First I pre-process the string to identify all of the original repeating sequences. This pre-processing is then used when meeting length requirements and then the results of that are finally reduced down to a state where there all other criteria are met.\\n\\nIn general, a simple computation could replace my iterative counting. A block of (3n + x) requires n convert operations to fully reduce. For consistency with the previous section, I maintained its format. This would be the first target of optimization.\\n\\n# Code\\n```\\npublic class Solution {\\n\\n\\n    // It\\'s easier to write this if I can update a reference, so here it is!\\n    // Define some of the methods on here for simplicity\\'s sake.\\n    public class RepeatBlock {\\n        public RepeatBlock(int count) {\\n            Count = count;\\n        }\\n\\n        public int Count { get; private set; }\\n\\n        public void Convert() {\\n            Count -= 3;\\n        }\\n\\n        public  void Add() {\\n            Count -= 2;\\n        }\\n\\n        public void  Delete() {\\n            Count -= 1;\\n        }\\n        \\n        public bool IsBad() {\\n            return Count >= 3;\\n        }\\n\\n        public int AddPriority() {\\n            // This will subtract by 2. Therefore we want something that will be valid after a single operation or be converted to something that subtracting by multiples of 3 will fix.\\n            return (Count + 1) % 3;\\n        }\\n\\n        public int DeletePriority() {\\n            // Only when we have a multiple of 3 should we target delete\\n            return Count % 3;\\n        }\\n    }\\n\\n    public int StrongPasswordChecker(string password) {\\n        // Assume that we have to add all 3 criteria if not found explicitly.\\n        int digitOperations = 1;\\n        int upperOperations = 1;\\n        int lowerOperations = 1;\\n\\n        // Operations for triplets are the hard part.\\n        // 3: aaa\\n        //  Convert -> aba\\n        //  Add     -> aaba\\n        //  Delete  -> aa\\n        // 4: aaaa\\n        //  Convert -> aaba\\n        //  Add     -> aabaa\\n        //  Delete + [3]\\n        // 5: aaaaa\\n        //  Convert -> aabaa\\n        //  Add + [3]   -> aabaaa\\n        //  Delete + [4]\\n        // 6: aaaaaa\\n        //  Convert + [3] -> aabaaa\\n        //  Add + [4]     -> aabaaaa\\n        //  Delete + [5]\\n        // 7: aaaaaaa\\n        //  Convert + [4] -> aabaaaa\\n        //  Add + [5]     -> aabaaaaa\\n        // ----\\n        // This is a recursive process. Convert does a -3, Add does a -2, and delete does a -1 to my sequence.\\n        // I want to use the highest value process when fixing my triplets.\\n        // If I have a remainder 3 after my operations then deleting becomes an option.\\n        // 6 repeated characters I could convert then delete to resolve.\\n        // And in the extended case 15 characters can be 1 delete + 4 conversions. => 15 - 13 = 2\\n        int currentCount = 1;\\n        // Hopefully we don\\'t encounter this character! Find another character or make this nullable otherwise\\n        char last = \\'\\\\0\\';  \\n\\n        List<RepeatBlock> repeatCounts = new();\\n        for (int i = 0; i < password.Length; i++) {\\n            char current = password[i];\\n\\n            if (current == last) {\\n                // We are repeating characters. Count how many!\\n                currentCount++;\\n            }\\n            else {\\n                // Our sequence is over. If we\\'ve got a triplet or more, register it.\\n                // Otherwise, simply reset the count\\n                if (currentCount >= 3) {\\n                    repeatCounts.Add(new RepeatBlock(currentCount));\\n                }\\n                currentCount = 1;\\n            }\\n\\n            // Don\\'t forget to update our comparison\\n            last = current;\\n\\n            // We could do this elsewhere, but I figure we might as well check in this loop\\n            if (char.IsDigit(current)) {\\n                digitOperations = 0;\\n            }\\n            else if (char.IsUpper(current)) {\\n                upperOperations = 0;\\n            }\\n            else if (char.IsLower(current)) {\\n                lowerOperations = 0;\\n            }\\n        }\\n\\n        // If we end with a repeat grab it\\n        if (currentCount >= 3) {\\n            repeatCounts.Add(new RepeatBlock(currentCount));\\n        }\\n\\n        // Keep track of \\n        int operationCount = 0;\\n\\n        // These are all pretty much the same. We will need to convert or add these in at some point\\n        int missingCharOperations = digitOperations + upperOperations + lowerOperations;\\n\\n        // For the next two cases, we have to add or delete from our blocks\\n        // In some cases, there will be multiple blocks to target and we must decide between them.\\n        // After modifying a block, that order may change!\\n        // For example, when we delete, we want to delete from a block size of 3n since that requires n operations, and delete can be one of them.\\n        // If there are no blocks of size 3n, then we prefer one with 3n + 1 because that transforms our block into one of size 3n.\\n        if (password.Length > 20) {\\n            int removeOperations = password.Length - 20;\\n            // Remove from repeated characters as much as possible\\n            // If any of the repeated characters have a multiple of 3, do that, otherwise delete from the same block\\n            while (removeOperations-- > 0) {\\n                var block = repeatCounts.Where(r => r.IsBad()).OrderBy(r => r.DeletePriority()).FirstOrDefault();\\n                // If there are no bad blocks, then we are simply deleting to delete.\\n                // In either case, this will not affect the minimum criteria character wise\\n                block?.Delete();\\n                operationCount++;\\n            }\\n        }\\n        else if (password.Length < 6) {\\n            int addOperations = 6 - password.Length;\\n            // Add to repeated characters as much as possible.\\n            // If there are character types to add, then do that too.\\n            while (addOperations-- > 0) {\\n                var block = repeatCounts.Where(r => r.IsBad()).OrderBy(r => r.AddPriority()).FirstOrDefault();\\n                // If there are no bad blocks, then we are simply adding to add.\\n                block?.Add();\\n                // In either case, we will be adding a missing character if we need to.\\n                missingCharOperations--;\\n                operationCount++;\\n            }\\n        }\\n\\n        // After resolving our password length criteria, we want to resolve the repeating blocks\\n        // Converting is the simplest option and we\\'ve already resolved our need to add or subtract characters.\\n        foreach (var block in repeatCounts) {\\n            while (block.IsBad()) {\\n                block.Convert();\\n                missingCharOperations--;\\n                operationCount++;\\n            }\\n        }\\n\\n        // Finally, and this has likely been handled elsewhere,\\n        // resolve the missing character operations.\\n        while (missingCharOperations > 0) {\\n            missingCharOperations--;\\n            operationCount++;\\n        }\\n\\n        return operationCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n\\n    // It\\'s easier to write this if I can update a reference, so here it is!\\n    // Define some of the methods on here for simplicity\\'s sake.\\n    public class RepeatBlock {\\n        public RepeatBlock(int count) {\\n            Count = count;\\n        }\\n\\n        public int Count { get; private set; }\\n\\n        public void Convert() {\\n            Count -= 3;\\n        }\\n\\n        public  void Add() {\\n            Count -= 2;\\n        }\\n\\n        public void  Delete() {\\n            Count -= 1;\\n        }\\n        \\n        public bool IsBad() {\\n            return Count >= 3;\\n        }\\n\\n        public int AddPriority() {\\n            // This will subtract by 2. Therefore we want something that will be valid after a single operation or be converted to something that subtracting by multiples of 3 will fix.\\n            return (Count + 1) % 3;\\n        }\\n\\n        public int DeletePriority() {\\n            // Only when we have a multiple of 3 should we target delete\\n            return Count % 3;\\n        }\\n    }\\n\\n    public int StrongPasswordChecker(string password) {\\n        // Assume that we have to add all 3 criteria if not found explicitly.\\n        int digitOperations = 1;\\n        int upperOperations = 1;\\n        int lowerOperations = 1;\\n\\n        // Operations for triplets are the hard part.\\n        // 3: aaa\\n        //  Convert -> aba\\n        //  Add     -> aaba\\n        //  Delete  -> aa\\n        // 4: aaaa\\n        //  Convert -> aaba\\n        //  Add     -> aabaa\\n        //  Delete + [3]\\n        // 5: aaaaa\\n        //  Convert -> aabaa\\n        //  Add + [3]   -> aabaaa\\n        //  Delete + [4]\\n        // 6: aaaaaa\\n        //  Convert + [3] -> aabaaa\\n        //  Add + [4]     -> aabaaaa\\n        //  Delete + [5]\\n        // 7: aaaaaaa\\n        //  Convert + [4] -> aabaaaa\\n        //  Add + [5]     -> aabaaaaa\\n        // ----\\n        // This is a recursive process. Convert does a -3, Add does a -2, and delete does a -1 to my sequence.\\n        // I want to use the highest value process when fixing my triplets.\\n        // If I have a remainder 3 after my operations then deleting becomes an option.\\n        // 6 repeated characters I could convert then delete to resolve.\\n        // And in the extended case 15 characters can be 1 delete + 4 conversions. => 15 - 13 = 2\\n        int currentCount = 1;\\n        // Hopefully we don\\'t encounter this character! Find another character or make this nullable otherwise\\n        char last = \\'\\\\0\\';  \\n\\n        List<RepeatBlock> repeatCounts = new();\\n        for (int i = 0; i < password.Length; i++) {\\n            char current = password[i];\\n\\n            if (current == last) {\\n                // We are repeating characters. Count how many!\\n                currentCount++;\\n            }\\n            else {\\n                // Our sequence is over. If we\\'ve got a triplet or more, register it.\\n                // Otherwise, simply reset the count\\n                if (currentCount >= 3) {\\n                    repeatCounts.Add(new RepeatBlock(currentCount));\\n                }\\n                currentCount = 1;\\n            }\\n\\n            // Don\\'t forget to update our comparison\\n            last = current;\\n\\n            // We could do this elsewhere, but I figure we might as well check in this loop\\n            if (char.IsDigit(current)) {\\n                digitOperations = 0;\\n            }\\n            else if (char.IsUpper(current)) {\\n                upperOperations = 0;\\n            }\\n            else if (char.IsLower(current)) {\\n                lowerOperations = 0;\\n            }\\n        }\\n\\n        // If we end with a repeat grab it\\n        if (currentCount >= 3) {\\n            repeatCounts.Add(new RepeatBlock(currentCount));\\n        }\\n\\n        // Keep track of \\n        int operationCount = 0;\\n\\n        // These are all pretty much the same. We will need to convert or add these in at some point\\n        int missingCharOperations = digitOperations + upperOperations + lowerOperations;\\n\\n        // For the next two cases, we have to add or delete from our blocks\\n        // In some cases, there will be multiple blocks to target and we must decide between them.\\n        // After modifying a block, that order may change!\\n        // For example, when we delete, we want to delete from a block size of 3n since that requires n operations, and delete can be one of them.\\n        // If there are no blocks of size 3n, then we prefer one with 3n + 1 because that transforms our block into one of size 3n.\\n        if (password.Length > 20) {\\n            int removeOperations = password.Length - 20;\\n            // Remove from repeated characters as much as possible\\n            // If any of the repeated characters have a multiple of 3, do that, otherwise delete from the same block\\n            while (removeOperations-- > 0) {\\n                var block = repeatCounts.Where(r => r.IsBad()).OrderBy(r => r.DeletePriority()).FirstOrDefault();\\n                // If there are no bad blocks, then we are simply deleting to delete.\\n                // In either case, this will not affect the minimum criteria character wise\\n                block?.Delete();\\n                operationCount++;\\n            }\\n        }\\n        else if (password.Length < 6) {\\n            int addOperations = 6 - password.Length;\\n            // Add to repeated characters as much as possible.\\n            // If there are character types to add, then do that too.\\n            while (addOperations-- > 0) {\\n                var block = repeatCounts.Where(r => r.IsBad()).OrderBy(r => r.AddPriority()).FirstOrDefault();\\n                // If there are no bad blocks, then we are simply adding to add.\\n                block?.Add();\\n                // In either case, we will be adding a missing character if we need to.\\n                missingCharOperations--;\\n                operationCount++;\\n            }\\n        }\\n\\n        // After resolving our password length criteria, we want to resolve the repeating blocks\\n        // Converting is the simplest option and we\\'ve already resolved our need to add or subtract characters.\\n        foreach (var block in repeatCounts) {\\n            while (block.IsBad()) {\\n                block.Convert();\\n                missingCharOperations--;\\n                operationCount++;\\n            }\\n        }\\n\\n        // Finally, and this has likely been handled elsewhere,\\n        // resolve the missing character operations.\\n        while (missingCharOperations > 0) {\\n            missingCharOperations--;\\n            operationCount++;\\n        }\\n\\n        return operationCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955390,
                "title": "easy-c-0ms-6-1mb",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n = password.length();\\n\\n        // character check (replace)\\n        bool containsUpper = false, containsLower = false, containsDigit = false;\\n        for (char c : password) {\\n            if (!containsUpper && isupper(c)) {\\n                containsUpper = true;\\n            }\\n            if (!containsLower && islower(c)) {\\n                containsLower = true;\\n            }\\n            if (!containsDigit && isdigit(c)) {\\n                containsDigit = true;\\n            }\\n        }\\n\\n        int c_swaps = 3 - (containsUpper + containsLower + containsDigit);\\n\\n        // repeating check (replace)\\n        vector<int> reps;\\n        for (int i = 0; i < n;) {\\n            int j = i + 1;\\n            while (j < n && password[i] == password[j]) {\\n                j++;\\n            }\\n            reps.push_back(j - i);\\n            i = j;\\n        }\\n\\n        // length (addition, subtraction)\\n        if (n < 6) {\\n            int adds = 6 - n;\\n            return max(adds, c_swaps);\\n        } else if (n <= 20) {\\n            int r_swaps = 0;\\n            for (int elem : reps) {\\n                r_swaps += elem / 3;\\n            }\\n            return max(c_swaps, r_swaps);\\n        } else {\\n            int subs = n - 20;\\n            int r = reps.size();\\n            for (int i = 0; i < r; i++) {\\n                if (subs >= 1 && reps[i] % 3 == 0) {\\n                    reps[i]--;\\n                    subs--;\\n                }\\n            }\\n            for (int i = 0; i < r; i++) {\\n                if (subs >= 2 && reps[i] % 3 == 1 && reps[i] > 3) {\\n                    reps[i] -= 2;\\n                    subs -= 2;\\n                }\\n            }\\n            for (int i = 0; i < r; i++) {\\n                if (subs > 0 && reps[i] > 2) {\\n                    int removed = min(subs, reps[i] - 2);\\n                    reps[i] -= removed;\\n                    subs -= removed;\\n                }\\n            }\\n\\n            int r_swaps = 0;\\n            for (int elem : reps) {\\n                r_swaps += elem / 3;\\n            }\\n            return max(c_swaps, r_swaps) + (n - 20);\\n        }\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n = password.length();\\n\\n        // character check (replace)\\n        bool containsUpper = false, containsLower = false, containsDigit = false;\\n        for (char c : password) {\\n            if (!containsUpper && isupper(c)) {\\n                containsUpper = true;\\n            }\\n            if (!containsLower && islower(c)) {\\n                containsLower = true;\\n            }\\n            if (!containsDigit && isdigit(c)) {\\n                containsDigit = true;\\n            }\\n        }\\n\\n        int c_swaps = 3 - (containsUpper + containsLower + containsDigit);\\n\\n        // repeating check (replace)\\n        vector<int> reps;\\n        for (int i = 0; i < n;) {\\n            int j = i + 1;\\n            while (j < n && password[i] == password[j]) {\\n                j++;\\n            }\\n            reps.push_back(j - i);\\n            i = j;\\n        }\\n\\n        // length (addition, subtraction)\\n        if (n < 6) {\\n            int adds = 6 - n;\\n            return max(adds, c_swaps);\\n        } else if (n <= 20) {\\n            int r_swaps = 0;\\n            for (int elem : reps) {\\n                r_swaps += elem / 3;\\n            }\\n            return max(c_swaps, r_swaps);\\n        } else {\\n            int subs = n - 20;\\n            int r = reps.size();\\n            for (int i = 0; i < r; i++) {\\n                if (subs >= 1 && reps[i] % 3 == 0) {\\n                    reps[i]--;\\n                    subs--;\\n                }\\n            }\\n            for (int i = 0; i < r; i++) {\\n                if (subs >= 2 && reps[i] % 3 == 1 && reps[i] > 3) {\\n                    reps[i] -= 2;\\n                    subs -= 2;\\n                }\\n            }\\n            for (int i = 0; i < r; i++) {\\n                if (subs > 0 && reps[i] > 2) {\\n                    int removed = min(subs, reps[i] - 2);\\n                    reps[i] -= removed;\\n                    subs -= removed;\\n                }\\n            }\\n\\n            int r_swaps = 0;\\n            for (int elem : reps) {\\n                r_swaps += elem / 3;\\n            }\\n            return max(c_swaps, r_swaps) + (n - 20);\\n        }\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661281,
                "title": "c-0ms-o-n-solution",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bool mislchar, misdigit, misuchar;\\n        mislchar = misdigit = misuchar = true;\\n        for (auto & c : s) {\\n            if (isdigit(c))         misdigit = false;\\n            else if (islower(c))    mislchar = false;\\n            else if (isupper(c))    misuchar = false;\\n        }\\n        int missnum = mislchar + misuchar + misdigit;\\n        int done = 0, dtwo = 0, replace = 0;\\n        for (int i = 2; i < s.size(); i++) {\\n            if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {\\n                int len = 3;\\n                while (i + 1 < s.size() && s[i + 1] == s[i]) {\\n                    i++; len++;\\n                }\\n                if (len % 3 == 0)       done++;\\n                else if (len % 3 == 1)  dtwo++;\\n                replace += len / 3;\\n            }\\n        }\\n\\n        if (s.size() < 6) {\\n            return max(6 - (int)s.size(), missnum);\\n        } else if (s.size() <= 20) {\\n            return max(replace, missnum);\\n        } else {\\n            int del = s.size() - 20;\\n            replace -= min(del, done);\\n            if (del - done > 0) {\\n                replace -= min((del - done) / 2, dtwo);\\n            }\\n            if (del - done - 2 * dtwo > 0) {\\n                replace -= (del - done - 2 * dtwo) / 3;\\n            }\\n            return del + max(replace, missnum);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bool mislchar, misdigit, misuchar;\\n        mislchar = misdigit = misuchar = true;\\n        for (auto & c : s) {\\n            if (isdigit(c))         misdigit = false;\\n            else if (islower(c))    mislchar = false;\\n            else if (isupper(c))    misuchar = false;\\n        }\\n        int missnum = mislchar + misuchar + misdigit;\\n        int done = 0, dtwo = 0, replace = 0;\\n        for (int i = 2; i < s.size(); i++) {\\n            if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {\\n                int len = 3;\\n                while (i + 1 < s.size() && s[i + 1] == s[i]) {\\n                    i++; len++;\\n                }\\n                if (len % 3 == 0)       done++;\\n                else if (len % 3 == 1)  dtwo++;\\n                replace += len / 3;\\n            }\\n        }\\n\\n        if (s.size() < 6) {\\n            return max(6 - (int)s.size(), missnum);\\n        } else if (s.size() <= 20) {\\n            return max(replace, missnum);\\n        } else {\\n            int del = s.size() - 20;\\n            replace -= min(del, done);\\n            if (del - done > 0) {\\n                replace -= min((del - done) / 2, dtwo);\\n            }\\n            if (del - done - 2 * dtwo > 0) {\\n                replace -= (del - done - 2 * dtwo) / 3;\\n            }\\n            return del + max(replace, missnum);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534301,
                "title": "javascript-solution",
                "content": "```\\nvar strongPasswordChecker = function (password) {\\n  let numc = 1;\\n  let upc = 1;\\n  let loc = 1;\\n  let cc = 0;\\n  let cc2 = 0;\\n  if (/[0-9]/.test(password) === true) {\\n    numc = 0;\\n  }\\n  if (/[a-z]/.test(password) === true) {\\n    loc = 0;\\n  }\\n  if (/[A-Z]/.test(password) === true) {\\n    upc = 0;\\n  }\\n  for (let i = 0; i < password.length; i++) {\\n    if (\\n      password[i] === password[i + 1] &&\\n      password[i + 1] === password[i + 2]\\n    ) {\\n      i += 2;\\n      cc += 1;\\n    }\\n  }\\n  if (password.length < 6) {\\n    return Math.max(loc + upc + numc, 6 - password.length);\\n  } else if (password.length <= 20) {\\n    return Math.max(loc + upc + numc, cc);\\n  } else if (password.length > 20) {\\n    password = password.split(\"\");\\n    let y = password.length - 20;\\n    let x = password.length - 20;\\n    let count = 1;\\n    let a = [];\\n    let b = [];\\n    for (let i = 0; i < password.length; i++) {\\n      if (password[i] === password[i + 1]) {\\n        count += 1;\\n      } else {\\n        a.push(count);\\n        b.push(count);\\n        count = 1;\\n      }\\n    }\\n    let i = 0;\\n    while (i < 60 && x > 0) {\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 0 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 1 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 2 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      i++;\\n    }\\n    for (let i = 0; i < b.length; i++) {\\n      for (let j = i + 1; j < b.length; j++) {\\n        if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 1 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 1 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[j] -= 1;\\n          b[i] += 1;\\n        }\\n      }\\n    }\\n    cc2 = 0;\\n    for (let i = 0; i < b.length; i++) {\\n      if (b[i] >= 3) {\\n        b[i] -= 3;\\n        cc2 += 1;\\n        i--;\\n      }\\n    }\\n    return Math.max(loc + upc + numc, cc2) + y;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strongPasswordChecker = function (password) {\\n  let numc = 1;\\n  let upc = 1;\\n  let loc = 1;\\n  let cc = 0;\\n  let cc2 = 0;\\n  if (/[0-9]/.test(password) === true) {\\n    numc = 0;\\n  }\\n  if (/[a-z]/.test(password) === true) {\\n    loc = 0;\\n  }\\n  if (/[A-Z]/.test(password) === true) {\\n    upc = 0;\\n  }\\n  for (let i = 0; i < password.length; i++) {\\n    if (\\n      password[i] === password[i + 1] &&\\n      password[i + 1] === password[i + 2]\\n    ) {\\n      i += 2;\\n      cc += 1;\\n    }\\n  }\\n  if (password.length < 6) {\\n    return Math.max(loc + upc + numc, 6 - password.length);\\n  } else if (password.length <= 20) {\\n    return Math.max(loc + upc + numc, cc);\\n  } else if (password.length > 20) {\\n    password = password.split(\"\");\\n    let y = password.length - 20;\\n    let x = password.length - 20;\\n    let count = 1;\\n    let a = [];\\n    let b = [];\\n    for (let i = 0; i < password.length; i++) {\\n      if (password[i] === password[i + 1]) {\\n        count += 1;\\n      } else {\\n        a.push(count);\\n        b.push(count);\\n        count = 1;\\n      }\\n    }\\n    let i = 0;\\n    while (i < 60 && x > 0) {\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 0 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 1 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 2 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      i++;\\n    }\\n    for (let i = 0; i < b.length; i++) {\\n      for (let j = i + 1; j < b.length; j++) {\\n        if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 1 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 1 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[j] -= 1;\\n          b[i] += 1;\\n        }\\n      }\\n    }\\n    cc2 = 0;\\n    for (let i = 0; i < b.length; i++) {\\n      if (b[i] >= 3) {\\n        b[i] -= 3;\\n        cc2 += 1;\\n        i--;\\n      }\\n    }\\n    return Math.max(loc + upc + numc, cc2) + y;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420787,
                "title": "question-about-testcase",
                "content": "Hey. Simple question here. Why is the string \"bbaaaaaaaaaaaaaaacccccc\" giving me 8 as output \\xA0I just can\\'t think on paper how I could solve it with 8 steps \\xA0I can only come with 9",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2398044,
                "title": "c-solution-using-unordered-map",
                "content": "```\\n/*let n = number of characters in the array \"password\"\\n(1) password should have at least 1 lowercase letter, 1 uppercase letter and 1 digit.\\nWe declare these 3 boolean variables:\\nhasLowerCase: true if password has a lowercase letter\\nhasUpperCase: true if password has an uppercase letter\\nhasDigit: true if password has a digit\\n\\nint basic = hasLowerCase(1/0) + hasUpperCase(1/0) + hasDigit(1/0)\\nif (basic==3), we met the first criterion.\\n\\nThe function helperLUD() will compute hasLowerCase, hasUpperCase, hasDigit and basic \\n*/\\n\\n/*\\n(2) If (n<6) we need to add (6-n) charaters to password.\\nThe insertion and replacement of characters will break any sequence of 3 or more repeating characters.\\ne.g./ \"aaaaa\" -> \"aaaBaa\" -> \"aa1Baa\" (okay) => count = 2\\ne.g./ \"aaaBB\" -> \"\"aa1BB\" => count = 1\\ne.g./ \"aaaB1\" -> \"aaAaB1\" => count = 1\\nIn this manner, we don\\'t have to carry out extra steps to break down any sequenc of same characters.\\nWe first (2.1) add character(s) to password so that size=6, and at the same time,\\n    basic is added by (6-n) until it reaches 3, i.e. basic=min{3, basic+(6-n)};\\nthen (2.2) replace characters with ones of missing types \\n\\n=> count = (6-n) + (3-min{3, basic+(6-n)})\\n*/\\n\\n/*\\n(3) If (6<=n<=20) we will not insert any character to password (or delete any from it).\\nWe would introduce the unordered map (uMap) to record sequences of same characters \\nappearing 3 or more times in a row. \\ne.g./ \"aaaaaaaAAAAAA6666\"\\n(i=6) the character \\'a\\' is the last character of the sequence of 7 \\'a\\'s => uMap[6]=7\\n(i=12) This \\'A\\' is the last character of the sequence => uMap[12]=6\\n(i=16) This \\'6\\' is the last character of the sequence => uMap[16]=4\\nIn general,\\n    uMap[index of the last character of a sequence] = length of the sequence of same characters (>=3)\\n\\nThe function helperThree() will serve as a seperate function to compute uMap\\n\\nWe will loop over uMap to count how many characters we have to replace in password.\\n    count = SUM_{i} (uMap[i]/3)\\nJust like what we did in (2), every time of replacement will help us increase basic up to 3.\\nIf (basic<3), then we have to do (3-basic) times of replacement.\\n*/\\n\\n/*\\n(4) If (n>20) we let extra=n-20 be the number of characters we have to delete from password\\nSince password may contain sequences of the same characters 3 or more times in a row,\\nwe have to delete characters from password which generate the most benefits to us.\\n\\ne.g./ password=\"aaabbbbcccccccdddee123dd\", n=24 => extra=4\\n\\'a\\': uMap[2] = 3\\n\\'b\\': uMap[6] = 4\\n\\'c\\': uMap[13] = 7\\n\\'d\\': uMap[16] = 3\\n\\nDeleting an \\'a\\' from \"aaa\" will immediately break down the sequence \"aaa(b)...\"\\n=> password\\'= \"aabbbbcccccccdddee123dd\", count=1 and extra=3\\n\\'a\\': uMap[2] = 2 (removed from uMap)\\n\\'b\\': uMap[6] = 4\\n\\'c\\': uMap[13] = 7\\n\\'d\\': uMap[16] = 3\\n\\nDelete a \\'d\\' from \"ddd\" breaks down the sequence \"ddd\"\\n=> password\\' = \"aabbbbcccccccddee123dd\", count=2 and extra=2\\n\\'b\\': uMap[6]=4\\n\\'c\\': uMap[13]=7\\n(we don\\'t touch other keys or values in uMap because we just FORMALLY erase character(s) from password,\\nbut in practice, we don\\'t have to)\\n\\n-------------------------------------------------------------------------------------------------------\\nThe above deletion of characters should be carried out in an optimal manner.\\nIt means that we break down as many sequences of 3 or more same characters as possible \\ngiven that the number of extra characters (extra) is fixed.\\n\\nIn this example, we see that \\n\\'a\\': uMap[2]%3 = 3%3 = 0\\n\\'b\\': uMap[6]%3 = 4%3 = 1\\n\\'c\\': uMap[13]%3 = 7%3 = 1\\n\\'d\\': uMap[16]%3 = 3%3 = 0\\nTherefore, an \\'a\\' or \\'d\\' should be deleted first before we deal with \\'b\\' or \\'c\\'\\n\\n-------------------------------------------------------------------------------------------------------\\n\\nNow, we delete two \\'c\\'s so that \"ccc-ccc-c\" becomes \"ccc-cc\".\\nBefore this deletion, we need two times of replacement to break the sequence of \\'c\\'s,\\nfor example, \"ccccccc\" -> \"ccAcc0c\"\\nAfter this deletion, we only need one time of replacement: \"ccccc\" -> \"ccAcc\"\\n=> password\\' = \"aabbbbcccccddee123dd\", count=4, extra=0\\n\\nRight now, all replacement of characters which could break down a sequence of same characters have been done\\n=> we just replace characters in every sequence just like what we did in (3).\\n\\n\"aabbbbcccccddee123dd\" -> \"aabbAbccBccddee123dd\"\\ncount = 4 + 2 = 6\\n\\nIf (extra>0), then we delete extra number of characters directly from password.\\nIf (basic<3), then we replace characters with ones of the missing types.\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    bool hasLowerCase;\\n    bool hasUpperCase;\\n    bool hasDigit;\\n    int change;\\n    int basic;\\n    //\\n    int repeat;\\n    std::unordered_map<int, int> uMap; //uMap[last_index] = repeat\\n    std::unordered_map<int, int>::iterator itu;\\n    std::unordered_set<int> dSet;\\n    //\\n    int extra;\\n    \\n    void helperLUD(std::string& password, int& n){\\n        basic = 0;\\n        for (int i=0; i<n; i++){\\n            if (!hasLowerCase && password[i]>=\\'a\\' && password[i]<=\\'z\\'){\\n                hasLowerCase = true;\\n                basic++;\\n                continue;\\n            }\\n            \\n            if (!hasUpperCase && password[i]>=\\'A\\' && password[i]<=\\'Z\\'){\\n                hasUpperCase = true;\\n                basic++;\\n                continue;\\n            }\\n            \\n            if (!hasDigit && password[i]>=\\'0\\' && password[i]<=\\'9\\'){\\n                hasDigit = true;\\n                basic++;\\n            }\\n        }   \\n        return;\\n    }\\n    \\n    \\n    void helperThree(std::string& password, int& n){\\n        repeat = 1;\\n        for (int i=1; i<n; i++){\\n            if (password[i]==password[i-1]){\\n                repeat++;\\n            }else{\\n                if (repeat>=3){\\n                    uMap[i-1] = repeat;\\n                }\\n                repeat = 1;\\n            }\\n        }\\n        if (repeat>=3){\\n            uMap[n-1] = repeat;\\n        }\\n        repeat = 1;\\n        return;\\n    }\\n    \\n    int strongPasswordChecker(string password) {\\n        int n = password.size();\\n        hasLowerCase = false;\\n        hasUpperCase = false;\\n        hasDigit = false;\\n        change = 0;\\n        int temp = 0;\\n        bool stopLoop;\\n        //\\n        if (n<6){\\n            helperLUD(password, n);\\n            basic = std::min(3, basic+(6-n));\\n            change += 6-n;\\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n        //\\n        if (n>=6 && n<=20){\\n            helperLUD(password, n);\\n            helperThree(password, n);\\n            for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                temp = (itu->second/3);\\n                change += temp;\\n                if (basic<3){\\n                    basic = std::min(3, basic+temp);\\n                }\\n            }\\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n        //\\n        if (n>20){\\n            extra = n-20;\\n            helperLUD(password, n);\\n            helperThree(password, n);\\n            \\n            while (extra>0 && uMap.size()>0){\\n                stopLoop = true;\\n                //delete extra elements: \"baa(a)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=1 && itu->second>=3 && itu->second%3==0){\\n                        change++;\\n                        itu->second--;\\n                        extra--;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                //delete extra elements: \"baa(aa)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=2 && itu->second>3 && itu->second%3==1){\\n                        change+=2;\\n                        itu->second-=2;\\n                        extra-=2;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                //delete extra elements: \"baa(aaa)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=3 && itu->second>3 && itu->second%3==2){\\n                        change+=3;\\n                        itu->second-=3;\\n                        extra-=3;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                for (auto it=dSet.begin(); it!=dSet.end(); it++){\\n                    uMap.erase(*it);\\n                }\\n                dSet.clear();\\n                \\n                if (stopLoop) break;\\n            \\n                //std::cout<<\"uMap.size() = \"<<uMap.size()<<\"\\\\n\";\\n                //std::cout<<\"extra = \"<<extra<<\"\\\\n\";\\n            }//while (extra, uMap)\\n            \\n            //replace\\n            for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                if (itu->second>=3){\\n                    change += (itu->second)/3;\\n                    if (basic<3){\\n                        basic = std::min(3, basic+(itu->second)/3);\\n                    }\\n                    itu->second = (itu->second)%3;\\n                }                \\n            }\\n            \\n                \\n            change += extra;\\n            \\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*let n = number of characters in the array \"password\"\\n(1) password should have at least 1 lowercase letter, 1 uppercase letter and 1 digit.\\nWe declare these 3 boolean variables:\\nhasLowerCase: true if password has a lowercase letter\\nhasUpperCase: true if password has an uppercase letter\\nhasDigit: true if password has a digit\\n\\nint basic = hasLowerCase(1/0) + hasUpperCase(1/0) + hasDigit(1/0)\\nif (basic==3), we met the first criterion.\\n\\nThe function helperLUD() will compute hasLowerCase, hasUpperCase, hasDigit and basic \\n*/\\n\\n/*\\n(2) If (n<6) we need to add (6-n) charaters to password.\\nThe insertion and replacement of characters will break any sequence of 3 or more repeating characters.\\ne.g./ \"aaaaa\" -> \"aaaBaa\" -> \"aa1Baa\" (okay) => count = 2\\ne.g./ \"aaaBB\" -> \"\"aa1BB\" => count = 1\\ne.g./ \"aaaB1\" -> \"aaAaB1\" => count = 1\\nIn this manner, we don\\'t have to carry out extra steps to break down any sequenc of same characters.\\nWe first (2.1) add character(s) to password so that size=6, and at the same time,\\n    basic is added by (6-n) until it reaches 3, i.e. basic=min{3, basic+(6-n)};\\nthen (2.2) replace characters with ones of missing types \\n\\n=> count = (6-n) + (3-min{3, basic+(6-n)})\\n*/\\n\\n/*\\n(3) If (6<=n<=20) we will not insert any character to password (or delete any from it).\\nWe would introduce the unordered map (uMap) to record sequences of same characters \\nappearing 3 or more times in a row. \\ne.g./ \"aaaaaaaAAAAAA6666\"\\n(i=6) the character \\'a\\' is the last character of the sequence of 7 \\'a\\'s => uMap[6]=7\\n(i=12) This \\'A\\' is the last character of the sequence => uMap[12]=6\\n(i=16) This \\'6\\' is the last character of the sequence => uMap[16]=4\\nIn general,\\n    uMap[index of the last character of a sequence] = length of the sequence of same characters (>=3)\\n\\nThe function helperThree() will serve as a seperate function to compute uMap\\n\\nWe will loop over uMap to count how many characters we have to replace in password.\\n    count = SUM_{i} (uMap[i]/3)\\nJust like what we did in (2), every time of replacement will help us increase basic up to 3.\\nIf (basic<3), then we have to do (3-basic) times of replacement.\\n*/\\n\\n/*\\n(4) If (n>20) we let extra=n-20 be the number of characters we have to delete from password\\nSince password may contain sequences of the same characters 3 or more times in a row,\\nwe have to delete characters from password which generate the most benefits to us.\\n\\ne.g./ password=\"aaabbbbcccccccdddee123dd\", n=24 => extra=4\\n\\'a\\': uMap[2] = 3\\n\\'b\\': uMap[6] = 4\\n\\'c\\': uMap[13] = 7\\n\\'d\\': uMap[16] = 3\\n\\nDeleting an \\'a\\' from \"aaa\" will immediately break down the sequence \"aaa(b)...\"\\n=> password\\'= \"aabbbbcccccccdddee123dd\", count=1 and extra=3\\n\\'a\\': uMap[2] = 2 (removed from uMap)\\n\\'b\\': uMap[6] = 4\\n\\'c\\': uMap[13] = 7\\n\\'d\\': uMap[16] = 3\\n\\nDelete a \\'d\\' from \"ddd\" breaks down the sequence \"ddd\"\\n=> password\\' = \"aabbbbcccccccddee123dd\", count=2 and extra=2\\n\\'b\\': uMap[6]=4\\n\\'c\\': uMap[13]=7\\n(we don\\'t touch other keys or values in uMap because we just FORMALLY erase character(s) from password,\\nbut in practice, we don\\'t have to)\\n\\n-------------------------------------------------------------------------------------------------------\\nThe above deletion of characters should be carried out in an optimal manner.\\nIt means that we break down as many sequences of 3 or more same characters as possible \\ngiven that the number of extra characters (extra) is fixed.\\n\\nIn this example, we see that \\n\\'a\\': uMap[2]%3 = 3%3 = 0\\n\\'b\\': uMap[6]%3 = 4%3 = 1\\n\\'c\\': uMap[13]%3 = 7%3 = 1\\n\\'d\\': uMap[16]%3 = 3%3 = 0\\nTherefore, an \\'a\\' or \\'d\\' should be deleted first before we deal with \\'b\\' or \\'c\\'\\n\\n-------------------------------------------------------------------------------------------------------\\n\\nNow, we delete two \\'c\\'s so that \"ccc-ccc-c\" becomes \"ccc-cc\".\\nBefore this deletion, we need two times of replacement to break the sequence of \\'c\\'s,\\nfor example, \"ccccccc\" -> \"ccAcc0c\"\\nAfter this deletion, we only need one time of replacement: \"ccccc\" -> \"ccAcc\"\\n=> password\\' = \"aabbbbcccccddee123dd\", count=4, extra=0\\n\\nRight now, all replacement of characters which could break down a sequence of same characters have been done\\n=> we just replace characters in every sequence just like what we did in (3).\\n\\n\"aabbbbcccccddee123dd\" -> \"aabbAbccBccddee123dd\"\\ncount = 4 + 2 = 6\\n\\nIf (extra>0), then we delete extra number of characters directly from password.\\nIf (basic<3), then we replace characters with ones of the missing types.\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    bool hasLowerCase;\\n    bool hasUpperCase;\\n    bool hasDigit;\\n    int change;\\n    int basic;\\n    //\\n    int repeat;\\n    std::unordered_map<int, int> uMap; //uMap[last_index] = repeat\\n    std::unordered_map<int, int>::iterator itu;\\n    std::unordered_set<int> dSet;\\n    //\\n    int extra;\\n    \\n    void helperLUD(std::string& password, int& n){\\n        basic = 0;\\n        for (int i=0; i<n; i++){\\n            if (!hasLowerCase && password[i]>=\\'a\\' && password[i]<=\\'z\\'){\\n                hasLowerCase = true;\\n                basic++;\\n                continue;\\n            }\\n            \\n            if (!hasUpperCase && password[i]>=\\'A\\' && password[i]<=\\'Z\\'){\\n                hasUpperCase = true;\\n                basic++;\\n                continue;\\n            }\\n            \\n            if (!hasDigit && password[i]>=\\'0\\' && password[i]<=\\'9\\'){\\n                hasDigit = true;\\n                basic++;\\n            }\\n        }   \\n        return;\\n    }\\n    \\n    \\n    void helperThree(std::string& password, int& n){\\n        repeat = 1;\\n        for (int i=1; i<n; i++){\\n            if (password[i]==password[i-1]){\\n                repeat++;\\n            }else{\\n                if (repeat>=3){\\n                    uMap[i-1] = repeat;\\n                }\\n                repeat = 1;\\n            }\\n        }\\n        if (repeat>=3){\\n            uMap[n-1] = repeat;\\n        }\\n        repeat = 1;\\n        return;\\n    }\\n    \\n    int strongPasswordChecker(string password) {\\n        int n = password.size();\\n        hasLowerCase = false;\\n        hasUpperCase = false;\\n        hasDigit = false;\\n        change = 0;\\n        int temp = 0;\\n        bool stopLoop;\\n        //\\n        if (n<6){\\n            helperLUD(password, n);\\n            basic = std::min(3, basic+(6-n));\\n            change += 6-n;\\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n        //\\n        if (n>=6 && n<=20){\\n            helperLUD(password, n);\\n            helperThree(password, n);\\n            for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                temp = (itu->second/3);\\n                change += temp;\\n                if (basic<3){\\n                    basic = std::min(3, basic+temp);\\n                }\\n            }\\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n        //\\n        if (n>20){\\n            extra = n-20;\\n            helperLUD(password, n);\\n            helperThree(password, n);\\n            \\n            while (extra>0 && uMap.size()>0){\\n                stopLoop = true;\\n                //delete extra elements: \"baa(a)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=1 && itu->second>=3 && itu->second%3==0){\\n                        change++;\\n                        itu->second--;\\n                        extra--;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                //delete extra elements: \"baa(aa)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=2 && itu->second>3 && itu->second%3==1){\\n                        change+=2;\\n                        itu->second-=2;\\n                        extra-=2;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                //delete extra elements: \"baa(aaa)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=3 && itu->second>3 && itu->second%3==2){\\n                        change+=3;\\n                        itu->second-=3;\\n                        extra-=3;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                for (auto it=dSet.begin(); it!=dSet.end(); it++){\\n                    uMap.erase(*it);\\n                }\\n                dSet.clear();\\n                \\n                if (stopLoop) break;\\n            \\n                //std::cout<<\"uMap.size() = \"<<uMap.size()<<\"\\\\n\";\\n                //std::cout<<\"extra = \"<<extra<<\"\\\\n\";\\n            }//while (extra, uMap)\\n            \\n            //replace\\n            for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                if (itu->second>=3){\\n                    change += (itu->second)/3;\\n                    if (basic<3){\\n                        basic = std::min(3, basic+(itu->second)/3);\\n                    }\\n                    itu->second = (itu->second)%3;\\n                }                \\n            }\\n            \\n                \\n            change += extra;\\n            \\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2345991,
                "title": "runtime-23-ms-memory-usage-13-9-mb-python3",
                "content": "![image](https://assets.leetcode.com/users/images/5b033b27-d956-4c33-9319-59d2d183d7c4_1659013785.4899778.png)\\n\\n\\n**Here is my code ... hope you will also understand my stratagy... if you found any any question or suggestion for me.. your most welcome ..!!**\\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        #vimla_kushwaha\\n        s = password\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n                \\n            return int(delete + max(missing_type, change))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        #vimla_kushwaha\\n        s = password\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n                \\n            return int(delete + max(missing_type, change))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058667,
                "title": "accepted-solution-100-fastest-with-greedy-approach-c-with-detailed-explanation",
                "content": "Below is my thought process, not sure if it is the best but it works. I hope it helps! Please vote if you find this helpful.\\n\\nConsider these following scenarios.\\n\\n1. The password has all needed components such as lower, upper case letters and digits, and it is within the size range. The only thing we need to worry about is to **tweak the consecutive duplicate letters of 3 or more**. For that, we just need to change one out of each 3 letters. \\n\\nIt is an easy O(N) scan to find all sectons of consecutive duplicate letters of 3 or more.\\n\\n```\\n        vector<int> sections;\\n        int t = 0;\\n        char last = 0;\\n        for(char c:password) {\\n            if(c!=last) {\\n                if(t>=3) sections.push_back(t);\\n                t = 0;\\n                last = c;\\n                if(c>=\\'a\\' && c<=\\'z\\') hasLower = true;\\n                else if(c>=\\'A\\' && c<=\\'Z\\') hasUpper = true;\\n                else if(c>=\\'0\\' && c<=\\'9\\') hasDigit = true;\\n            }\\n            t++;\\n        }\\n        if(t>=3) sections.push_back(t);\\n```\\n\\nOnce we put the sections in a vector, it is easy to add moves by modifying each section by changing 1 of each 3 characters.\\n```\\nfor(int s:sections) moves += s/3;\\n```\\n\\n2. Now add on top of the above scenario, we want to **ensure we have all needed components**. That means everytime we make changes to the duplicate sections, we will take the opportunity to add whatever missing components. Here, I use a lambda function so it is easier to understand and re-use. And, after processing all the sections, we will still need to check once more and add missing components. This function takes an input as how many opportunities I can use, and returns the actual moves used for ensuring. We will be re-using this function throughout the process again in future modifications. \\n\\n```\\nauto ensureComponents = [&](int available) { // available means available opportunities\\n    int changed = 0;\\n    while(available-->0) {\\n\\t    if(!hasLower) hasLower = true;\\n\\t\\telse if(!hasUpper) hasUpper = true;\\n\\t\\telse if(!hasDigit) hasDigit = true;\\n\\t\\telse return changed;\\n\\t\\tchanged++;\\n\\t}\\n\\treturn changed; // actual components added\\n};\\n\\nfor(int s:sections) {\\n\\tmoves += s/3;\\n\\tensureComponents(s/3);\\n}\\n\\nmoves += ensureComponents(3); // giving 3 more opportunites in case we need, only adding what we actually used\\n```\\n\\n3. Now consider the scenario where **we don\\'t have enough (6) characters**. Again, we will take opportunities to address when we address the duplicate characters. Also, check at the end. We can do this by using the new character to chop off two from the duplicate section. And the loop will become looking like below, assuming n stores the length of the password.\\n\\n```\\nfor(int s:sections) {\\n\\twhile(n<6 && s>=3) {\\n\\t\\tmoves++;\\n\\t\\tn++;\\n\\t\\ts-=2;  // adding a character to chop off two characters from this sectoin\\n\\t\\tensureComponents(1);  // the adding move can also be an opportunity for ensuring we have all variety\\n\\t}\\n\\t\\n\\tmoves += s/3;\\n\\tensureComponents(s/3);\\n}\\n\\nmoves += max(0, 6 - n);  // after processing sections, still not enough, then add here\\nensureComponents(max(0, 6-n)); // these moves are also opportunities for adding missing components\\nmoves += ensureComponents(3);\\n```\\n\\n4. Now we need to consider the scenario where **we have more that 20 characters**. This is a little different. We will want to process as much deletion as possible before we start processing the duplicate characters, so we don\\'t waste moves. What groups should we prioritize to remove characters from? We know that we will be changing 1 out of each 3 duplicates. So, if any group is exactly multiples of 3, then removing 1 character from them means we hit two birds with one stone. We should prioritize groups with `s%3==0`, after that for groups with `s%3==1`, we will need to remove two from the 3 to actually make a difference. And at last, for groups with `s%3==2`, we will remove 3 each time to be able to make a difference. Below is how I did the removing part.\\n\\n```\\nif(!sections.empty()) {\\n\\tsort(sections.begin(), sections.end(), [](int a, int b){return a%3<b%3;}); // prioritizing based on s%3\\n\\t\\n\\tint reduced = 0;\\n\\tint i = 0;\\n\\twhile(n>20) {\\n\\t\\tint r = sections[i] % 3;\\n\\t\\tif (sections[i]>=3 && n>20+r) {\\n\\t\\t\\tsections[i]-=r+1;\\n\\t\\t\\tmoves+=r+1;\\n\\t\\t\\treduced+=r+1;\\n\\t\\t\\tn-=r+1;\\n\\t\\t}\\n\\t\\tif(++i==sections.size()) {\\n\\t\\t\\tif (reduced==0) break; // a full scan without reduction\\n\\t\\t\\ti-=sections.size();\\n\\t\\t\\treduced = 0;\\n\\t\\t}\\n\\t}\\n}\\n\\t.\\n\\t.\\n\\t.\\n// at the end\\nmoves += max(0, n - 20);\\n```\\n\\n5. Now **putting everything together**\\n\\n```\\n    int strongPasswordChecker(string password) {\\n        bool hasLower = false;\\n        bool hasUpper = false;\\n        bool hasDigit = false;\\n        int n = password.length();\\n        \\n        vector<int> sections;\\n        int t = 0;\\n        char last = 0;\\n        for(char c:password) {\\n            if(c!=last) {\\n                if(t>=3) sections.push_back(t);\\n                t = 0;\\n                last = c;\\n                if(c>=\\'a\\' && c<=\\'z\\') hasLower = true;\\n                else if(c>=\\'A\\' && c<=\\'Z\\') hasUpper = true;\\n                else if(c>=\\'0\\' && c<=\\'9\\') hasDigit = true;\\n            }\\n            t++;\\n        }\\n        if(t>=3) sections.push_back(t);\\n        \\n        int moves = 0;\\n        \\n        if(!sections.empty()) {\\n            sort(sections.begin(), sections.end(), [](int a, int b){return a%3 < b%3;});\\n\\n            int reduced = 0;\\n            int i = 0;\\n            while(n>20) {\\n                int r = sections[i] % 3;\\n                if (sections[i]>=3 && n>20+r) {\\n                    sections[i]-=r+1;\\n                    moves+=r+1;\\n                    reduced+=r+1;\\n                    n-=r+1;\\n                }\\n                if(++i==sections.size()) {\\n                    if (reduced==0) break; // a full scan without reduction\\n                    i-=sections.size();\\n                    reduced = 0;\\n                }\\n            }\\n        }\\n        \\n        auto ensureComponents = [&](int available) {\\n            int changed = 0;\\n            while(available-->0) {\\n                if(!hasLower) hasLower = true;\\n                else if(!hasUpper) hasUpper = true;\\n                else if(!hasDigit) hasDigit = true;\\n                else return changed;\\n                changed++;\\n            }\\n            return changed;\\n        };\\n\\n        for(int s:sections) {\\n            while(n<6 && s>=3) {\\n                moves++;\\n                n++;\\n                s-=2;\\n                ensureComponents(1);\\n            }\\n\\n            moves += s/3;\\n            ensureComponents(s/3);\\n        }\\n\\n        moves += max(0, 6 - n);\\n        ensureComponents(max(0, 6-n));\\n        moves += ensureComponents(3);\\n        moves += max(0, n - 20);\\n        \\n        return moves;\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n        vector<int> sections;\\n        int t = 0;\\n        char last = 0;\\n        for(char c:password) {\\n            if(c!=last) {\\n                if(t>=3) sections.push_back(t);\\n                t = 0;\\n                last = c;\\n                if(c>=\\'a\\' && c<=\\'z\\') hasLower = true;\\n                else if(c>=\\'A\\' && c<=\\'Z\\') hasUpper = true;\\n                else if(c>=\\'0\\' && c<=\\'9\\') hasDigit = true;\\n            }\\n            t++;\\n        }\\n        if(t>=3) sections.push_back(t);\\n```\n```\\nfor(int s:sections) moves += s/3;\\n```\n```\\nauto ensureComponents = [&](int available) { // available means available opportunities\\n    int changed = 0;\\n    while(available-->0) {\\n\\t    if(!hasLower) hasLower = true;\\n\\t\\telse if(!hasUpper) hasUpper = true;\\n\\t\\telse if(!hasDigit) hasDigit = true;\\n\\t\\telse return changed;\\n\\t\\tchanged++;\\n\\t}\\n\\treturn changed; // actual components added\\n};\\n\\nfor(int s:sections) {\\n\\tmoves += s/3;\\n\\tensureComponents(s/3);\\n}\\n\\nmoves += ensureComponents(3); // giving 3 more opportunites in case we need, only adding what we actually used\\n```\n```\\nfor(int s:sections) {\\n\\twhile(n<6 && s>=3) {\\n\\t\\tmoves++;\\n\\t\\tn++;\\n\\t\\ts-=2;  // adding a character to chop off two characters from this sectoin\\n\\t\\tensureComponents(1);  // the adding move can also be an opportunity for ensuring we have all variety\\n\\t}\\n\\t\\n\\tmoves += s/3;\\n\\tensureComponents(s/3);\\n}\\n\\nmoves += max(0, 6 - n);  // after processing sections, still not enough, then add here\\nensureComponents(max(0, 6-n)); // these moves are also opportunities for adding missing components\\nmoves += ensureComponents(3);\\n```\n```\\nif(!sections.empty()) {\\n\\tsort(sections.begin(), sections.end(), [](int a, int b){return a%3<b%3;}); // prioritizing based on s%3\\n\\t\\n\\tint reduced = 0;\\n\\tint i = 0;\\n\\twhile(n>20) {\\n\\t\\tint r = sections[i] % 3;\\n\\t\\tif (sections[i]>=3 && n>20+r) {\\n\\t\\t\\tsections[i]-=r+1;\\n\\t\\t\\tmoves+=r+1;\\n\\t\\t\\treduced+=r+1;\\n\\t\\t\\tn-=r+1;\\n\\t\\t}\\n\\t\\tif(++i==sections.size()) {\\n\\t\\t\\tif (reduced==0) break; // a full scan without reduction\\n\\t\\t\\ti-=sections.size();\\n\\t\\t\\treduced = 0;\\n\\t\\t}\\n\\t}\\n}\\n\\t.\\n\\t.\\n\\t.\\n// at the end\\nmoves += max(0, n - 20);\\n```\n```\\n    int strongPasswordChecker(string password) {\\n        bool hasLower = false;\\n        bool hasUpper = false;\\n        bool hasDigit = false;\\n        int n = password.length();\\n        \\n        vector<int> sections;\\n        int t = 0;\\n        char last = 0;\\n        for(char c:password) {\\n            if(c!=last) {\\n                if(t>=3) sections.push_back(t);\\n                t = 0;\\n                last = c;\\n                if(c>=\\'a\\' && c<=\\'z\\') hasLower = true;\\n                else if(c>=\\'A\\' && c<=\\'Z\\') hasUpper = true;\\n                else if(c>=\\'0\\' && c<=\\'9\\') hasDigit = true;\\n            }\\n            t++;\\n        }\\n        if(t>=3) sections.push_back(t);\\n        \\n        int moves = 0;\\n        \\n        if(!sections.empty()) {\\n            sort(sections.begin(), sections.end(), [](int a, int b){return a%3 < b%3;});\\n\\n            int reduced = 0;\\n            int i = 0;\\n            while(n>20) {\\n                int r = sections[i] % 3;\\n                if (sections[i]>=3 && n>20+r) {\\n                    sections[i]-=r+1;\\n                    moves+=r+1;\\n                    reduced+=r+1;\\n                    n-=r+1;\\n                }\\n                if(++i==sections.size()) {\\n                    if (reduced==0) break; // a full scan without reduction\\n                    i-=sections.size();\\n                    reduced = 0;\\n                }\\n            }\\n        }\\n        \\n        auto ensureComponents = [&](int available) {\\n            int changed = 0;\\n            while(available-->0) {\\n                if(!hasLower) hasLower = true;\\n                else if(!hasUpper) hasUpper = true;\\n                else if(!hasDigit) hasDigit = true;\\n                else return changed;\\n                changed++;\\n            }\\n            return changed;\\n        };\\n\\n        for(int s:sections) {\\n            while(n<6 && s>=3) {\\n                moves++;\\n                n++;\\n                s-=2;\\n                ensureComponents(1);\\n            }\\n\\n            moves += s/3;\\n            ensureComponents(s/3);\\n        }\\n\\n        moves += max(0, 6 - n);\\n        ensureComponents(max(0, 6-n));\\n        moves += ensureComponents(3);\\n        moves += max(0, n - 20);\\n        \\n        return moves;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919568,
                "title": "swift-0ms-strong-password-checker-100",
                "content": "```\\nclass Solution {\\n    func strongPasswordChecker(_ password: String) -> Int {\\n        let pw = Array(password), pwCount = pw.count\\n        var low = false, up = false, num = false\\n        for pwCount in pw {\\n            if pwCount.isLowercase { low = true }\\n            else if pwCount.isUppercase { up = true }\\n            else if pwCount.isNumber { num = true }\\n        }\\n        var types = 3\\n        if low { types -= 1 }\\n        if up { types -= 1 }\\n        if num { types -= 1 }\\n        \\n        var one = 0, two = 0, rep = 0, i = 2\\n        while i < pwCount {\\n            if pw[i] == pw[i-1] && pw[i] == pw[i-2] {\\n                var length = 2\\n                while i < pwCount && pw[i] == pw[i-1] {\\n                    length += 1\\n                    i += 1\\n                }\\n                rep += length/3\\n                if length % 3 == 0 { one += 1 }\\n                else if length % 3 == 1 { two += 1 }\\n            } else {\\n                i += 1\\n            }\\n        }\\n        if pwCount < 6 {\\n            return max(types, 6 - pwCount)\\n        } else if pwCount <= 20 {\\n            return max(types, rep)\\n        }\\n        let del = pwCount - 20\\n        rep -= min(del, one)\\n        rep -= (min(max(del - one, 0), two * 2) / 2)\\n        rep -= (max(del - one - 2 * two, 0) / 3)\\n        return max(types, rep) + del\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func strongPasswordChecker(_ password: String) -> Int {\\n        let pw = Array(password), pwCount = pw.count\\n        var low = false, up = false, num = false\\n        for pwCount in pw {\\n            if pwCount.isLowercase { low = true }\\n            else if pwCount.isUppercase { up = true }\\n            else if pwCount.isNumber { num = true }\\n        }\\n        var types = 3\\n        if low { types -= 1 }\\n        if up { types -= 1 }\\n        if num { types -= 1 }\\n        \\n        var one = 0, two = 0, rep = 0, i = 2\\n        while i < pwCount {\\n            if pw[i] == pw[i-1] && pw[i] == pw[i-2] {\\n                var length = 2\\n                while i < pwCount && pw[i] == pw[i-1] {\\n                    length += 1\\n                    i += 1\\n                }\\n                rep += length/3\\n                if length % 3 == 0 { one += 1 }\\n                else if length % 3 == 1 { two += 1 }\\n            } else {\\n                i += 1\\n            }\\n        }\\n        if pwCount < 6 {\\n            return max(types, 6 - pwCount)\\n        } else if pwCount <= 20 {\\n            return max(types, rep)\\n        }\\n        let del = pwCount - 20\\n        rep -= min(del, one)\\n        rep -= (min(max(del - one, 0), two * 2) / 2)\\n        rep -= (max(del - one - 2 * two, 0) / 3)\\n        return max(types, rep) + del\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760221,
                "title": "strong-password-checker-solution-java",
                "content": "class Solution {\\n  public int strongPasswordChecker(String s) {\\n    final int n = s.length();\\n    final char[] chars = s.toCharArray();\\n    final int missing = getMissing(chars);\\n    // # of replacements to deal with 3 repeating characters\\n    int replaces = 0;\\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\\n    int oneSeq = 0;\\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\\n    int twoSeq = 0;\\n\\n    for (int i = 2; i < n;)\\n      if (chars[i] == chars[i - 1] && chars[i - 1] == chars[i - 2]) {\\n        int length = 2; // length of repeating chars\\n        while (i < n && chars[i] == chars[i - 1]) {\\n          ++length;\\n          ++i;\\n        }\\n        replaces += length / 3; // \\'aaaaaaa\\' -> \\'aaxaaxa\\'\\n        if (length % 3 == 0)\\n          ++oneSeq;\\n        if (length % 3 == 1)\\n          ++twoSeq;\\n      } else {\\n        ++i;\\n      }\\n\\n    if (n < 6)\\n      return Math.max(6 - n, missing);\\n    if (n <= 20)\\n      return Math.max(replaces, missing);\\n\\n    final int deletes = n - 20;\\n    // each replacement in (3k)-seqs can be substituted with 1 deletions\\n    replaces -= Math.min(oneSeq, deletes);\\n    // each replacement in (3k + 1)-seqs can be substituted with 2 deletions\\n    replaces -= Math.min(Math.max(deletes - oneSeq, 0), twoSeq * 2) / 2;\\n    // each replacement in other seqs can be substituted with 3 deletions\\n    replaces -= Math.max(deletes - oneSeq - twoSeq * 2, 0) / 3;\\n    return deletes + Math.max(replaces, missing);\\n  }\\n\\n  private int getMissing(final char[] chars) {\\n    int missing = 3;\\n\\n    for (final char c : chars)\\n      if (Character.isUpperCase(c)) {\\n        --missing;\\n        break;\\n      }\\n\\n    for (final char c : chars)\\n      if (Character.isLowerCase(c)) {\\n        --missing;\\n        break;\\n      }\\n\\n    for (final char c : chars)\\n      if (Character.isDigit(c)) {\\n        --missing;\\n        break;\\n      }\\n\\n    return missing;\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public int strongPasswordChecker(String s) {\\n    final int n = s.length();\\n    final char[] chars = s.toCharArray();\\n    final int missing = getMissing(chars);\\n    // # of replacements to deal with 3 repeating characters\\n    int replaces = 0;\\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\\n    int oneSeq = 0;\\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\\n    int twoSeq = 0;\\n\\n    for (int i = 2; i < n;)\\n      if (chars[i] == chars[i - 1] && chars[i - 1] == chars[i - 2]) {\\n        int length = 2; // length of repeating chars\\n        while (i < n && chars[i] == chars[i - 1]) {\\n          ++length;\\n          ++i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1646088,
                "title": "python3-20ms-solution-with-thorough-explanation",
                "content": "```\\nfrom typing import List\\nimport math\\n\\n\\ndef get_missing_steps(password: str) -> int:\\n    \"\"\"\\n    Return the number of substitution or insertion steps required to address\\n    problems with missing character classes.\\n    \"\"\"\\n    lower_missing = True\\n    upper_missing = True\\n    digit_missing = True\\n\\n    for c in password:\\n        if \"a\" <= c <= \"z\":\\n            lower_missing = False\\n        if \"A\" <= c <= \"Z\":\\n            upper_missing = False\\n        if \"0\" <= c <= \"9\":\\n            digit_missing = False\\n\\n    return lower_missing + upper_missing + digit_missing\\n\\n\\ndef get_runs(password: str) -> List[int]:\\n    \"\"\"\\n    Return a list of lengths of runs of repeated characters that are too long.\\n    \"\"\"\\n    runs = []\\n\\n    run_start = -1\\n    prev = None\\n    for i, curr in enumerate(password):\\n        if curr == prev:\\n            continue\\n        else:\\n            run_len = i - run_start\\n            if run_len > 2:\\n                runs.append(run_len)\\n            run_start = i\\n        prev = curr\\n\\n    run_len = (i + 1) - run_start\\n    if run_len > 2:\\n        runs.append(run_len)\\n\\n    return runs\\n\\n\\ndef get_run_sub_steps(runs: List[int]) -> int:\\n    \"\"\"\\n    Return the total number of substitution steps required to fix all illegal\\n    runs.\\n\\n    Any run of length `n` can be fixed with `floor(n / 3)` substitution steps.\\n    For example, a run of length 5 such as \"aaaaa\" can be fixed by making 1\\n    substitution in the middle to get \"aazaa\".\\n    \"\"\"\\n    return sum(n // 3 for n in runs)\\n\\n\\ndef get_run_insert_steps(runs: List[int]) -> int:\\n    \"\"\"\\n    Return the total number of insertion steps required to fix all illegal\\n    runs.\\n\\n    Any run of length `n` can be fixed with `ceil(n / 2) - 1` insertion steps.\\n    For example, a run of length 5 such as \"aaaaa\" can be fixed by making 2\\n    insertions to get \"aazaaza\".\\n    \"\"\"\\n    return sum(max(math.ceil(n / 2) - 1, 0) for n in runs)\\n\\n\\ndef handle_short_len(password: str) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that is too short.\\n\\n    In this case, we know password length is a problem.  There are two\\n    additional kinds of problems that may occur: runs of repeated characters\\n    and missing character classes.  All classes of problem (including password\\n    length) may be fixed simultaneously by character insertions without\\n    creating further problems.  Since any step required to fix a problem also\\n    fixes any other kind, we must determine the number of steps required to fix\\n    the most numerous type of problem.\\n    \"\"\"\\n    missing_steps = get_missing_steps(password)\\n    run_steps = get_run_insert_steps(get_runs(password))\\n    too_short_steps = 6 - len(password)\\n\\n    return max(missing_steps, run_steps, too_short_steps)\\n\\n\\ndef handle_required_len(password: str, runs: List[int] = None) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that has the required\\n    length.\\n\\n    This case is similar to the case of a short password except that the only\\n    two problems that may occur are character runs and missing character\\n    classes.  Similarly, instead of an insertion, a substitution step can be\\n    used to simultaneously fix occurrences of either type of issue.  So the\\n    task again is to determine the number of steps required to fix the most\\n    problematic issue class.\\n\\n    An explicit list of illegal run lengths can be given to account for the\\n    case in which some runs have partly been mitigated by deletions in a\\n    password that is longer than the required length.\\n    \"\"\"\\n    if runs is None:\\n        runs = get_runs(password)\\n\\n    missing_steps = get_missing_steps(password)\\n    run_steps = get_run_sub_steps(runs)\\n\\n    return max(missing_steps, run_steps)\\n\\n\\ndef _emplace_run_len(q: List[int], n: int) -> None:\\n    q.append(n)\\n    if len(q) < 2:\\n        return\\n\\n    n_mod_3 = n % 3\\n    for i in range(len(q) - 2, -1, -1):\\n        if (q[i] % 3) >= n_mod_3:\\n            break\\n        q[i], q[i + 1] = q[i + 1], q[i]\\n\\n\\ndef handle_long_len(password: str) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that is too long.\\n\\n    The only edit operation that can reduce the number of characters in a\\n    password is deletion.  Therefore, a certain number of deletions are\\n    required.  The most optimal place for those deletions to take place is\\n    within illegal runs of repeated characters.  Once a password has been\\n    reduced in length by a required number of optimally placed deletions, it\\n    may be handled as a normal-length password by the `handle_required_len`\\n    method.\\n\\n    However, the choice of placement of deletions may affect the number of\\n    substitutions required in the `handle_required_len` method.  For example,\\n    consider a password that is 22 characters long with the suffix\\n    \"aaabbbbbcccccc\".  We must make two deletions to reduce password to an\\n    appropriate length.  If we make the deletions all within the run of \"b\"\\n    characters, we don\\'t save any substitutions in the `handle_required_len`\\n    method. However, if we make one deletion in the run of \"a\" characters and\\n    one in the run of \"c\" characters, we save 2 substitutions in the\\n    `handle_required_len` method.  Accordingly, we must always make deletions in\\n    the run that has the lowest length mod 3.\\n\\n    This logic is implemented in the for loop below.  The remaining set of run\\n    lengths are then used in the `handle_required_len` method.\\n    \"\"\"\\n    runs = get_runs(password)\\n    runs.sort(key=lambda i: i % 3, reverse=True)\\n\\n    too_long_steps = len(password) - 20\\n    del_steps = 0\\n\\n    while too_long_steps > 0 and len(runs) > 0:\\n        run_len = runs.pop()\\n\\n        too_long_steps -= 1\\n        run_len -= 1\\n        del_steps += 1\\n\\n        if run_len > 2:\\n            _emplace_run_len(runs, run_len)\\n\\n    del_steps += too_long_steps\\n\\n    return del_steps + handle_required_len(password, runs)\\n\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        if n < 6:\\n            return handle_short_len(password)\\n        elif n <= 20:\\n            return handle_required_len(password)\\n        else:\\n            return handle_long_len(password)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\nimport math\\n\\n\\ndef get_missing_steps(password: str) -> int:\\n    \"\"\"\\n    Return the number of substitution or insertion steps required to address\\n    problems with missing character classes.\\n    \"\"\"\\n    lower_missing = True\\n    upper_missing = True\\n    digit_missing = True\\n\\n    for c in password:\\n        if \"a\" <= c <= \"z\":\\n            lower_missing = False\\n        if \"A\" <= c <= \"Z\":\\n            upper_missing = False\\n        if \"0\" <= c <= \"9\":\\n            digit_missing = False\\n\\n    return lower_missing + upper_missing + digit_missing\\n\\n\\ndef get_runs(password: str) -> List[int]:\\n    \"\"\"\\n    Return a list of lengths of runs of repeated characters that are too long.\\n    \"\"\"\\n    runs = []\\n\\n    run_start = -1\\n    prev = None\\n    for i, curr in enumerate(password):\\n        if curr == prev:\\n            continue\\n        else:\\n            run_len = i - run_start\\n            if run_len > 2:\\n                runs.append(run_len)\\n            run_start = i\\n        prev = curr\\n\\n    run_len = (i + 1) - run_start\\n    if run_len > 2:\\n        runs.append(run_len)\\n\\n    return runs\\n\\n\\ndef get_run_sub_steps(runs: List[int]) -> int:\\n    \"\"\"\\n    Return the total number of substitution steps required to fix all illegal\\n    runs.\\n\\n    Any run of length `n` can be fixed with `floor(n / 3)` substitution steps.\\n    For example, a run of length 5 such as \"aaaaa\" can be fixed by making 1\\n    substitution in the middle to get \"aazaa\".\\n    \"\"\"\\n    return sum(n // 3 for n in runs)\\n\\n\\ndef get_run_insert_steps(runs: List[int]) -> int:\\n    \"\"\"\\n    Return the total number of insertion steps required to fix all illegal\\n    runs.\\n\\n    Any run of length `n` can be fixed with `ceil(n / 2) - 1` insertion steps.\\n    For example, a run of length 5 such as \"aaaaa\" can be fixed by making 2\\n    insertions to get \"aazaaza\".\\n    \"\"\"\\n    return sum(max(math.ceil(n / 2) - 1, 0) for n in runs)\\n\\n\\ndef handle_short_len(password: str) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that is too short.\\n\\n    In this case, we know password length is a problem.  There are two\\n    additional kinds of problems that may occur: runs of repeated characters\\n    and missing character classes.  All classes of problem (including password\\n    length) may be fixed simultaneously by character insertions without\\n    creating further problems.  Since any step required to fix a problem also\\n    fixes any other kind, we must determine the number of steps required to fix\\n    the most numerous type of problem.\\n    \"\"\"\\n    missing_steps = get_missing_steps(password)\\n    run_steps = get_run_insert_steps(get_runs(password))\\n    too_short_steps = 6 - len(password)\\n\\n    return max(missing_steps, run_steps, too_short_steps)\\n\\n\\ndef handle_required_len(password: str, runs: List[int] = None) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that has the required\\n    length.\\n\\n    This case is similar to the case of a short password except that the only\\n    two problems that may occur are character runs and missing character\\n    classes.  Similarly, instead of an insertion, a substitution step can be\\n    used to simultaneously fix occurrences of either type of issue.  So the\\n    task again is to determine the number of steps required to fix the most\\n    problematic issue class.\\n\\n    An explicit list of illegal run lengths can be given to account for the\\n    case in which some runs have partly been mitigated by deletions in a\\n    password that is longer than the required length.\\n    \"\"\"\\n    if runs is None:\\n        runs = get_runs(password)\\n\\n    missing_steps = get_missing_steps(password)\\n    run_steps = get_run_sub_steps(runs)\\n\\n    return max(missing_steps, run_steps)\\n\\n\\ndef _emplace_run_len(q: List[int], n: int) -> None:\\n    q.append(n)\\n    if len(q) < 2:\\n        return\\n\\n    n_mod_3 = n % 3\\n    for i in range(len(q) - 2, -1, -1):\\n        if (q[i] % 3) >= n_mod_3:\\n            break\\n        q[i], q[i + 1] = q[i + 1], q[i]\\n\\n\\ndef handle_long_len(password: str) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that is too long.\\n\\n    The only edit operation that can reduce the number of characters in a\\n    password is deletion.  Therefore, a certain number of deletions are\\n    required.  The most optimal place for those deletions to take place is\\n    within illegal runs of repeated characters.  Once a password has been\\n    reduced in length by a required number of optimally placed deletions, it\\n    may be handled as a normal-length password by the `handle_required_len`\\n    method.\\n\\n    However, the choice of placement of deletions may affect the number of\\n    substitutions required in the `handle_required_len` method.  For example,\\n    consider a password that is 22 characters long with the suffix\\n    \"aaabbbbbcccccc\".  We must make two deletions to reduce password to an\\n    appropriate length.  If we make the deletions all within the run of \"b\"\\n    characters, we don\\'t save any substitutions in the `handle_required_len`\\n    method. However, if we make one deletion in the run of \"a\" characters and\\n    one in the run of \"c\" characters, we save 2 substitutions in the\\n    `handle_required_len` method.  Accordingly, we must always make deletions in\\n    the run that has the lowest length mod 3.\\n\\n    This logic is implemented in the for loop below.  The remaining set of run\\n    lengths are then used in the `handle_required_len` method.\\n    \"\"\"\\n    runs = get_runs(password)\\n    runs.sort(key=lambda i: i % 3, reverse=True)\\n\\n    too_long_steps = len(password) - 20\\n    del_steps = 0\\n\\n    while too_long_steps > 0 and len(runs) > 0:\\n        run_len = runs.pop()\\n\\n        too_long_steps -= 1\\n        run_len -= 1\\n        del_steps += 1\\n\\n        if run_len > 2:\\n            _emplace_run_len(runs, run_len)\\n\\n    del_steps += too_long_steps\\n\\n    return del_steps + handle_required_len(password, runs)\\n\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        if n < 6:\\n            return handle_short_len(password)\\n        elif n <= 20:\\n            return handle_required_len(password)\\n        else:\\n            return handle_long_len(password)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483790,
                "title": "python-simple-o-n-solution-20-ms-beats-100",
                "content": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        def type_(c):\\n            if c.isdigit(): return 0\\n            if c.isupper(): return 1\\n            return 2\\n        \\n        numTypes = len(set(type_(c) for c in password))\\n        if len(password) <= 4: return (6 - len(password))\\n        if len(password) == 5: return max(1, 3 - numTypes)\\n\\t\\t\\n        lengthOfSequences = [len(list(li)) for _, li in itertools.groupby(password)]\\n        numReplace = sum(length // 3 for length in lengthOfSequences)   \\n        if len(password) <= 20: return max(3 - numTypes, numReplace)\\n        \\n        numDelete = len(password) - 20\\n        for i, length in enumerate(lengthOfSequences):\\n            if length >= 3 and length % 3 == 0 and numReplace > 0 and numDelete >= 1:\\n                lengthOfSequences[i] -= 1\\n                numReplace -= 1\\n                numDelete -= 1\\n                    \\n        for i, length in enumerate(lengthOfSequences):\\n            if length >= 3 and length % 3 == 1 and numReplace > 0 and numDelete >= 2:\\n                lengthOfSequences[i] -= 2\\n                numReplace -= 1\\n                numDeletes -= 2\\n        \\n        numReplace -= min(numDelete // 3, sum(length // 3 for length in lengthOfSequences))\\n        return len(password) - 20 + max(numReplace, 3 - numTypes)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        def type_(c):\\n            if c.isdigit(): return 0\\n            if c.isupper(): return 1\\n            return 2\\n        \\n        numTypes = len(set(type_(c) for c in password))\\n        if len(password) <= 4: return (6 - len(password))\\n        if len(password) == 5: return max(1, 3 - numTypes)\\n\\t\\t\\n        lengthOfSequences = [len(list(li)) for _, li in itertools.groupby(password)]\\n        numReplace = sum(length // 3 for length in lengthOfSequences)   \\n        if len(password) <= 20: return max(3 - numTypes, numReplace)\\n        \\n        numDelete = len(password) - 20\\n        for i, length in enumerate(lengthOfSequences):\\n            if length >= 3 and length % 3 == 0 and numReplace > 0 and numDelete >= 1:\\n                lengthOfSequences[i] -= 1\\n                numReplace -= 1\\n                numDelete -= 1\\n                    \\n        for i, length in enumerate(lengthOfSequences):\\n            if length >= 3 and length % 3 == 1 and numReplace > 0 and numDelete >= 2:\\n                lengthOfSequences[i] -= 2\\n                numReplace -= 1\\n                numDeletes -= 2\\n        \\n        numReplace -= min(numDelete // 3, sum(length // 3 for length in lengthOfSequences))\\n        return len(password) - 20 + max(numReplace, 3 - numTypes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189640,
                "title": "my-solution-with-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int strongPasswordChecker(String password) {\\n\\t\\t\\tint passLen = password.length();\\n\\n\\t\\t\\tboolean noLowercase = true;\\n\\t\\t\\tboolean noUppercase = true;\\n\\t\\t\\tboolean noDigit = true;\\n\\n\\t\\t\\tList<Integer> charRepeats = new ArrayList();\\n\\t\\t\\tchar lastChar = 0;\\n\\t\\t\\tint lastRepeat = 0;\\n\\n\\t\\t\\tfor (int i = 0; i < passLen; i++) {\\n\\t\\t\\t\\tchar c = password.charAt(i);\\n\\n\\t\\t\\t\\tif (noUppercase && c > 64 && c < 91) {\\n\\t\\t\\t\\t\\tnoUppercase = false;\\n\\t\\t\\t\\t} else if (noLowercase && c > 96 && c < 123) {\\n\\t\\t\\t\\t\\tnoLowercase = false;\\n\\t\\t\\t\\t} else if (noDigit && c > 47 && c < 58) {\\n\\t\\t\\t\\t\\tnoDigit = false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (lastChar == c) {\\n\\t\\t\\t\\t\\tlastRepeat++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (lastRepeat > 2 && (lastChar != c || i == passLen - 1)) {\\n\\t\\t\\t\\t\\tcharRepeats.add(lastRepeat);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (lastChar != c) {\\n\\t\\t\\t\\t\\tlastRepeat = 1;\\n\\t\\t\\t\\t\\tlastChar = c;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint reusedCount = 0;\\n\\n\\t\\t\\tif (noUppercase) {\\n\\t\\t\\t\\treusedCount++;\\n\\t\\t\\t}\\n\\t\\t\\tif (noLowercase) {\\n\\t\\t\\t\\treusedCount++;\\n\\t\\t\\t}\\n\\t\\t\\tif (noDigit) {\\n\\t\\t\\t\\treusedCount++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treusedCount = Math.max(6 - passLen, reusedCount);\\n\\t\\t\\tint deleteCount = Math.max(0, passLen - 20);\\n\\t\\t\\tint addOrReplaceCount = 0;\\n\\n\\t\\t\\t// when repeat times is multiple of 3, we can use one delete step to replace one other fix step\\n\\t\\t\\tfor (int count : charRepeats) {\\n\\t\\t\\t\\tif (count % 3 == 0 && deleteCount > 0) {\\n\\t\\t\\t\\t\\tdeleteCount--;\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\taddOrReplaceCount += (int)Math.floor(count / 3.0f);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// when repeat times is multiple of 3 plus 1, we can use two delete steps to replace one other fix step\\n\\t\\t\\tfor (int count : charRepeats) {\\n\\t\\t\\t\\tif (count % 3 == 1 && deleteCount > 1) {\\n\\t\\t\\t\\t\\tdeleteCount -= 2;\\n\\t\\t\\t\\t\\taddOrReplaceCount--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if there still has delete steps, then we can still use three delete steps to replace one other fix step\\n\\t\\t\\taddOrReplaceCount -= (deleteCount / 3);\\n\\n\\t\\t\\t// we should use the max between reusedCount and addOrReplaceCount, then plus delete items, because reused and deleted step are required\\n\\t\\t\\treturn Math.max(reusedCount, addOrReplaceCount) + Math.max(0, passLen - 20);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int strongPasswordChecker(String password) {\\n\\t\\t\\tint passLen = password.length();\\n\\n\\t\\t\\tboolean noLowercase = true;\\n\\t\\t\\tboolean noUppercase = true;\\n\\t\\t\\tboolean noDigit = true;\\n\\n\\t\\t\\tList<Integer> charRepeats = new ArrayList();\\n\\t\\t\\tchar lastChar = 0;\\n\\t\\t\\tint lastRepeat = 0;\\n\\n\\t\\t\\tfor (int i = 0; i < passLen; i++) {\\n\\t\\t\\t\\tchar c = password.charAt(i);\\n\\n\\t\\t\\t\\tif (noUppercase && c > 64 && c < 91) {\\n\\t\\t\\t\\t\\tnoUppercase = false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1166459,
                "title": "c-solution-quick-and-dirty-or-not",
                "content": "Here is my C# solution. \\n![image](https://assets.leetcode.com/users/images/9ce8b6aa-1986-4bda-b0bf-01648d8b03d5_1620008573.5286129.png)\\n```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) \\n    {\\n        if (password == null || password.Length == 0)\\n            return 6;\\n        \\n        int countAdd = (password.Length < 6)? 6 -  password.Length : 0;\\n        int countRemove = (password.Length >20)? password.Length - 20 : 0;\\n        \\n        bool hasLowerCase = false;\\n        bool hasUpperCase = false;\\n        bool hasDigit = false;\\n       \\n        int countSeries3 = 0;\\n        int countSeries4 = 0;\\n        int countSeries5 = 0;\\n        int breaksNeeded = 0;\\n        \\n        char lastCh = \\'\\\\n\\'; \\n        int lastChCount = 0;\\n        \\n        foreach(char ch in password)\\n        {\\n            if (ch>=\\'0\\' && ch<=\\'9\\') hasDigit = true;\\n            if (ch>=\\'A\\' && ch<=\\'Z\\') hasUpperCase = true;\\n            if (ch>=\\'a\\' && ch<=\\'z\\') hasLowerCase = true;\\n            \\n            if (lastCh == ch)\\n            {\\n                lastChCount ++;\\n            }\\n            else\\n            {\\n               if (lastChCount > 2)\\n               {\\n                    if (lastChCount % 3 == 0) countSeries3++;\\n                    else if ((lastChCount - 1) % 3 == 0) countSeries4++;\\n                    else countSeries5++;\\n                   \\n                    breaksNeeded +=  lastChCount / 3;\\n               }\\n               lastChCount = 1;\\n               lastCh = ch; \\n            }\\n        }\\n\\n       if (lastChCount > 2)\\n       {\\n            if (lastChCount % 3 == 0) countSeries3++;\\n            else if ((lastChCount - 1) % 3 == 0) countSeries4++;\\n            else countSeries5++;\\n           \\n            breaksNeeded +=  lastChCount / 3;\\n       }\\n\\n        int countRemoveAdj = countRemove;\\n        \\n        breaksNeeded -= Math.Min(countRemoveAdj, countSeries3);\\n        countRemoveAdj -= Math.Min(countRemoveAdj, countSeries3);\\n        \\n        if (countRemoveAdj > 0)\\n        {\\n            breaksNeeded -= Math.Min(countRemoveAdj/2, countSeries4);\\n            countRemoveAdj -= Math.Min(countRemoveAdj, countSeries4 * 2);\\n        }\\n\\n        if (countRemoveAdj > 0)\\n        {\\n            breaksNeeded -= Math.Min(countRemoveAdj/3, breaksNeeded);\\n        }\\n        \\n        int countMissing = (hasLowerCase? 0 : 1) + (hasUpperCase? 0 : 1) + (hasDigit? 0 : 1);\\n\\n        return Math.Max( Math.Max(countMissing, countAdd), breaksNeeded) + countRemove;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) \\n    {\\n        if (password == null || password.Length == 0)\\n            return 6;\\n        \\n        int countAdd = (password.Length < 6)? 6 -  password.Length : 0;\\n        int countRemove = (password.Length >20)? password.Length - 20 : 0;\\n        \\n        bool hasLowerCase = false;\\n        bool hasUpperCase = false;\\n        bool hasDigit = false;\\n       \\n        int countSeries3 = 0;\\n        int countSeries4 = 0;\\n        int countSeries5 = 0;\\n        int breaksNeeded = 0;\\n        \\n        char lastCh = \\'\\\\n\\'; \\n        int lastChCount = 0;\\n        \\n        foreach(char ch in password)\\n        {\\n            if (ch>=\\'0\\' && ch<=\\'9\\') hasDigit = true;\\n            if (ch>=\\'A\\' && ch<=\\'Z\\') hasUpperCase = true;\\n            if (ch>=\\'a\\' && ch<=\\'z\\') hasLowerCase = true;\\n            \\n            if (lastCh == ch)\\n            {\\n                lastChCount ++;\\n            }\\n            else\\n            {\\n               if (lastChCount > 2)\\n               {\\n                    if (lastChCount % 3 == 0) countSeries3++;\\n                    else if ((lastChCount - 1) % 3 == 0) countSeries4++;\\n                    else countSeries5++;\\n                   \\n                    breaksNeeded +=  lastChCount / 3;\\n               }\\n               lastChCount = 1;\\n               lastCh = ch; \\n            }\\n        }\\n\\n       if (lastChCount > 2)\\n       {\\n            if (lastChCount % 3 == 0) countSeries3++;\\n            else if ((lastChCount - 1) % 3 == 0) countSeries4++;\\n            else countSeries5++;\\n           \\n            breaksNeeded +=  lastChCount / 3;\\n       }\\n\\n        int countRemoveAdj = countRemove;\\n        \\n        breaksNeeded -= Math.Min(countRemoveAdj, countSeries3);\\n        countRemoveAdj -= Math.Min(countRemoveAdj, countSeries3);\\n        \\n        if (countRemoveAdj > 0)\\n        {\\n            breaksNeeded -= Math.Min(countRemoveAdj/2, countSeries4);\\n            countRemoveAdj -= Math.Min(countRemoveAdj, countSeries4 * 2);\\n        }\\n\\n        if (countRemoveAdj > 0)\\n        {\\n            breaksNeeded -= Math.Min(countRemoveAdj/3, breaksNeeded);\\n        }\\n        \\n        int countMissing = (hasLowerCase? 0 : 1) + (hasUpperCase? 0 : 1) + (hasDigit? 0 : 1);\\n\\n        return Math.Max( Math.Max(countMissing, countAdd), breaksNeeded) + countRemove;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143533,
                "title": "go-another-solution-with-explanation",
                "content": "Observations:\\n\\n* When len(password) < 6, inserts are required\\n* When len(password) > 20, removals are required\\n* Inserts and replacements can be used to meet lower/upper/digit constraints\\n* When eliminating repeating groups, replacements are more valuable than inserts\\n* When 6 <= len(password) <= 20, replacements are most valuable \\n* Repeating groups should be eliminated as effectively as possible while inserting / removing characters\\n\\nThe observation that replacements are more effective comes from the fact that \"aaaaa\" can be fixed with a single replacement, whereas it would require two inserts. Replacements can reduce the repeat count by 3, inserts by 2, removals by 1:\\n\\n| Repeats | Replacements | Inserts | Removals \\n| --- | --- | --- | --- | \\n| 3 | 1 | 1 | 1 |\\n| 4 | 1 | 1 | 2 |\\n| 5 | 1 | 2 | 3 |\\n| 6 | 2 | 2 | 4 |\\n| 7 | 2 | 3 | 5 |\\n| 8 | 2 | 3 | 6 |\\n\\nSince replacements are more effective than inserts and removals, inserts or removals should only be used when necessary, i.e. when len(password) < 6 or > 20. And when insert or removal is required, the goal is to unlock efficient use of replacements afterwards. Basically, insert/remove should \"land on\" 5, 8, 11, ... `counts[i]%3 == 2`.\\n\\nThis gives the following prioritization for removal of characters while n > 20\\n\\n1. Remove once in groups of 6, 9, 12, ..., i.e. `counts[i]%3 == 0`\\n2. (n>21) Remove twice in groups of 7, 10, 13, ..., i.e.  `counts[i]%3 == 1`\\n3. Repeated removal from group until <= 2\\n4. Remove without reducing repeated group\\n\\nAnd for inserts, i.e. n < 6:\\n\\n1. Insert once in groups of 7, 10, 13, i.e.  `counts[i]%3 == 1`\\n2. Insert in any group\\n3. Insert without reducing repeated group\\n\\nOnce 6 <= n <= 20, use replacements to fix any repeating groups.\\n\\nFinally, count number of inserts/replacements to determine if more replacements are needed to match constraints.\\n\\n```go\\nfunc strongPasswordChecker(password string) int {\\n\\t// The hard part is to pick inserts / replacements in such a way\\n\\t// that it minimizes the number of actions needed to reduce repeated\\n\\t// counts in a group to <= 2\\n\\t//\\n\\t// Given a count > 2, the overflow can be fixed by the actions below:\\n\\t//\\n\\t//   Count  | Replace |  Insert | Remove\\n\\t//     3    |    1    |    1    |   1\\n\\t//     4    |    1    |    1    |   2\\n\\t//     5    |    1    |    2    |   3\\n\\t//     6    |    2    |    2    |   4\\n\\t//     7    |    2    |    3    |   5\\n\\t//     8    |    2    |    4    |   6\\n\\t//\\n\\t// Conclusions:\\n\\t// * Replacements are more valuable than inserts.\\n\\t// * Value of insert/removal depends on whether it unlocks efficient replacement\\n\\t// * There is no need to mix insert and remove, use insert/remove to match\\n\\t//\\t\\tlength requirements, then use replace.\\n\\t//\\n\\t// Cases:\\n\\t// 1. When len(password) < 6, insert to unlock effective replacements.\\n\\t// 2. When len(password) > 20, remove to unlock effective replacements.\\n\\t// 3. When 6 <= len(password) <= 20, replacements are always best.\\n\\t//\\n\\t// An effective insert and remove reduces count to an even multiple of 3\\n\\t//\\n\\t_, counts := rle(password)\\n\\tn := len(password)\\n\\n\\t// Match length criteria\\n\\tvar nremove, ninsert int\\n\\tswitch {\\n\\tcase n < 6:\\n\\t\\tfor n < 6 && hasRepeats(counts) {\\n\\t\\t\\t// Effective inserts\\n\\t\\t\\tfor i := 0; n < 6 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 1 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn++\\n\\t\\t\\t\\tninsert++\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t\\t// Regular inserts\\n\\t\\t\\tfor i := 0; n < 6 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn++\\n\\t\\t\\t\\tninsert++\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Insert remainder\\n\\t\\tif n < 6 {\\n\\t\\t\\tninsert += 6 - n\\n\\t\\t}\\n\\tcase n > 20:\\n\\t\\tfor n > 20 && hasRepeats(counts) {\\n\\t\\t\\t// Effective removal\\n\\t\\t\\tfor i := 0; n > 20 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 0 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn--\\n\\t\\t\\t\\tnremove++\\n\\t\\t\\t\\tcounts[i]--\\n\\t\\t\\t}\\n\\t\\t\\t// Half-effective removal\\n\\t\\t\\tfor i := 0; n > 21 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 1 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn -= 2\\n\\t\\t\\t\\tnremove += 2\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t\\t// Regular removal - simply remove counts until n == 20\\n\\t\\t\\tfor i := 0; n > 20 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor n > 20 && counts[i] > 2 {\\n\\t\\t\\t\\t\\tn--\\n\\t\\t\\t\\t\\tnremove++\\n\\t\\t\\t\\t\\tcounts[i]--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Remove remainder\\n\\t\\tif n > 20 {\\n\\t\\t\\tnremove += n - 20\\n\\t\\t}\\n\\t}\\n\\n\\t// Make replacements\\n\\tvar nreplace int\\n\\tfor _, c := range counts {\\n\\t\\tnreplace += c / 3\\n\\t}\\n\\n\\t// Count total number of actions\\n\\tconstrs := countMissingConstraints(password)\\n\\tactions := nremove + max(constrs, nreplace+ninsert)\\n\\treturn actions\\n}\\n\\nfunc hasRepeats(counts []int) bool {\\n\\tfor _, c := range counts {\\n\\t\\tif c > 2 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc rle(s string) ([]rune, []int) {\\n\\tchars := make([]rune, 0)\\n\\tcounts := make([]int, 0)\\n\\tvar n int\\n\\tfor _, r := range s {\\n\\t\\tif n > 0 && r == chars[n-1] {\\n\\t\\t\\tcounts[n-1]++\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tchars = append(chars, r)\\n\\t\\tcounts = append(counts, 1)\\n\\t\\tn++\\n\\t}\\n\\treturn chars, counts\\n}\\n\\nfunc countMissingConstraints(s string) int {\\n\\tvar constrMissing int\\n\\tif !strings.ContainsAny(s, \"0123456789\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\tif !strings.ContainsAny(s, \"abcdefghijklmnopqrstuvwxyz\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\tif !strings.ContainsAny(s, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\treturn constrMissing\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc strongPasswordChecker(password string) int {\\n\\t// The hard part is to pick inserts / replacements in such a way\\n\\t// that it minimizes the number of actions needed to reduce repeated\\n\\t// counts in a group to <= 2\\n\\t//\\n\\t// Given a count > 2, the overflow can be fixed by the actions below:\\n\\t//\\n\\t//   Count  | Replace |  Insert | Remove\\n\\t//     3    |    1    |    1    |   1\\n\\t//     4    |    1    |    1    |   2\\n\\t//     5    |    1    |    2    |   3\\n\\t//     6    |    2    |    2    |   4\\n\\t//     7    |    2    |    3    |   5\\n\\t//     8    |    2    |    4    |   6\\n\\t//\\n\\t// Conclusions:\\n\\t// * Replacements are more valuable than inserts.\\n\\t// * Value of insert/removal depends on whether it unlocks efficient replacement\\n\\t// * There is no need to mix insert and remove, use insert/remove to match\\n\\t//\\t\\tlength requirements, then use replace.\\n\\t//\\n\\t// Cases:\\n\\t// 1. When len(password) < 6, insert to unlock effective replacements.\\n\\t// 2. When len(password) > 20, remove to unlock effective replacements.\\n\\t// 3. When 6 <= len(password) <= 20, replacements are always best.\\n\\t//\\n\\t// An effective insert and remove reduces count to an even multiple of 3\\n\\t//\\n\\t_, counts := rle(password)\\n\\tn := len(password)\\n\\n\\t// Match length criteria\\n\\tvar nremove, ninsert int\\n\\tswitch {\\n\\tcase n < 6:\\n\\t\\tfor n < 6 && hasRepeats(counts) {\\n\\t\\t\\t// Effective inserts\\n\\t\\t\\tfor i := 0; n < 6 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 1 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn++\\n\\t\\t\\t\\tninsert++\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t\\t// Regular inserts\\n\\t\\t\\tfor i := 0; n < 6 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn++\\n\\t\\t\\t\\tninsert++\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Insert remainder\\n\\t\\tif n < 6 {\\n\\t\\t\\tninsert += 6 - n\\n\\t\\t}\\n\\tcase n > 20:\\n\\t\\tfor n > 20 && hasRepeats(counts) {\\n\\t\\t\\t// Effective removal\\n\\t\\t\\tfor i := 0; n > 20 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 0 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn--\\n\\t\\t\\t\\tnremove++\\n\\t\\t\\t\\tcounts[i]--\\n\\t\\t\\t}\\n\\t\\t\\t// Half-effective removal\\n\\t\\t\\tfor i := 0; n > 21 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 1 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn -= 2\\n\\t\\t\\t\\tnremove += 2\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t\\t// Regular removal - simply remove counts until n == 20\\n\\t\\t\\tfor i := 0; n > 20 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor n > 20 && counts[i] > 2 {\\n\\t\\t\\t\\t\\tn--\\n\\t\\t\\t\\t\\tnremove++\\n\\t\\t\\t\\t\\tcounts[i]--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Remove remainder\\n\\t\\tif n > 20 {\\n\\t\\t\\tnremove += n - 20\\n\\t\\t}\\n\\t}\\n\\n\\t// Make replacements\\n\\tvar nreplace int\\n\\tfor _, c := range counts {\\n\\t\\tnreplace += c / 3\\n\\t}\\n\\n\\t// Count total number of actions\\n\\tconstrs := countMissingConstraints(password)\\n\\tactions := nremove + max(constrs, nreplace+ninsert)\\n\\treturn actions\\n}\\n\\nfunc hasRepeats(counts []int) bool {\\n\\tfor _, c := range counts {\\n\\t\\tif c > 2 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc rle(s string) ([]rune, []int) {\\n\\tchars := make([]rune, 0)\\n\\tcounts := make([]int, 0)\\n\\tvar n int\\n\\tfor _, r := range s {\\n\\t\\tif n > 0 && r == chars[n-1] {\\n\\t\\t\\tcounts[n-1]++\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tchars = append(chars, r)\\n\\t\\tcounts = append(counts, 1)\\n\\t\\tn++\\n\\t}\\n\\treturn chars, counts\\n}\\n\\nfunc countMissingConstraints(s string) int {\\n\\tvar constrMissing int\\n\\tif !strings.ContainsAny(s, \"0123456789\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\tif !strings.ContainsAny(s, \"abcdefghijklmnopqrstuvwxyz\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\tif !strings.ContainsAny(s, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\treturn constrMissing\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054172,
                "title": "0-ms-o-n-java-solution-with-detailed-analysis",
                "content": "Let\\'s analysis the three options:\\n1. insert a char\\nTake 1 insert step, can resolve:\\nProb1: when length < 6\\nProb2: add missing catagory\\nProb3: split repeating chars\\n2. Delete a char\\nTake 1 delete step, can resolve:\\nProb1: when length > 20\\nProb3: reducing repeating chars\\n3. Replace a char\\nTake 1 replace step, can resolve:\\nProb2: replace with missing catagory\\nProb3: eg: aaaaa => aa1aa\\n\\nThere are three cases for this problem:\\n1. When **length < 6**\\nProb 1: Insert ```6 - length``` chars (need 1 ~ 6 steps)\\nProb 2: need 0~3 steps\\nProb 3: At most need 1 step, which is \"aaaaa\"\\nInsert can resolve prob 1, 2 & 3 together, so the minimum step need to take is **Max(Prob1, Prob2)**\\n2. When **6 <= length <= 20**\\nProb1: need 0 step \\nProb2: need  0~3 steps\\nProb 3: need 0~6 steps eg \\'aaaaaaaaaaaaaaaaaaaa\\' can be resolved by 6 replace steps\\nReplace can resolve prob 2 & 3 together and will not introduce prob 1, so the minimun step need to take is **Max(Prob2, Prob3)**\\n3. When 20 < length <= 50\\nProb1: need 1~30 delete steps\\nProb2: need 0~3 steps\\nProb3: need 0 ~ 16 steps, (50 / 3 = 16)\\nIn this case, delete steps are required to resolve Prob1. In the same time, Prob3 can be also resolved by delete step.\\n**Phase 1**, we need to take ```Prob1``` delete steps to resolve Prob1. In the same time, what\\'s the max Prob3 we can resolve?\\n1 Prob3 can be resolved by 1 delete step, when ```repeat length % 3 = 0``` eg: \\'aaa\\' delete 1 char can resolve 1 Prob3\\n1 Prob3 can be resolved by 2 delete steps, when ```repeat length % 3 = 1``` eg: \\'aaaa\\' delete 2 chars can resolve 1 Prob3\\n1 Prob3 can be resolved by 3 delete steps, when ```repeat length % 3 = 2``` eg: \\'aaaaa\\' delete 3 chars can resole 1 Prob3 (delete 3 same charaters can always resolve 1 Prob3)\\n```p31``` means the number of sub repeat strings(length >= 3) that ```length % 3 = 0```\\n```p32``` means the number of sub repeat strings(length >= 3) that ```length % 3 = 1```\\n```p33``` means the number of sub repeat strings(length >= 3) that ```length % 3 = 2```\\nSo, when we resolve Prob1, we should first resolve ```p31``` and then ```p32``` and then ```p33```.  After Prob1 resolved, the number of Prob3 remain is ```prob3 - prob3ResolvedByDelete```\\n**Phase2**, After all Prob1 resolved, we still have Prob2 and Prob3 need to resolve. We should use repace step to resolve them. The minimun step we need is **Max(prob2, prob3 - prob3ResolvedByDelete)**\\nOverall, in this case, the minimun step need to take is **prob1 + Math.max(prob2, prob3 - prob3ResolvedByDelete);**\\n\\n\\n\\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int length = password.length();\\n        int prob1 = Math.max(0, Math.max(6 - length, length - 20));\\n        \\n        boolean hasUpper = false;\\n        boolean hasLower = false;\\n        boolean hasDigit = false;\\n        int prob2 = 3;\\n        \\n        int prob3 = 0;\\n        int repeatCount = 1;\\n        int p31 = 0;\\n        int p32 = 0;\\n        int p33 = 0;\\n        \\n        char prev = \\'a\\';\\n        for (int i = 0; i < length; i++) {\\n            char curr = password.charAt(i);\\n            if (Character.isUpperCase(curr) && !hasUpper) {\\n                prob2--;\\n                hasUpper = true;\\n            }\\n            if (Character.isLowerCase(curr) && !hasLower) {\\n                prob2--;\\n                hasLower = true;\\n            }\\n            if (Character.isDigit(curr) && !hasDigit) {\\n                prob2--;\\n                hasDigit = true;\\n            }\\n            \\n            if (i > 0) {\\n                if (curr == prev) {\\n                    repeatCount++;\\n                } else {\\n                    if (repeatCount >= 3) {\\n                        prob3 += repeatCount / 3;\\n                        if (repeatCount % 3 == 0) {\\n                            p31++;\\n                        } else if (repeatCount % 3 == 1) {\\n                            p32++;\\n                        } else {\\n                            p33++;\\n                        }\\n                    }\\n                    repeatCount = 1;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        // need to include the last batch\\n        if (repeatCount >= 3) {\\n            prob3 += repeatCount / 3;\\n            if (repeatCount % 3 == 0) {\\n                p31++;\\n            } else if (repeatCount % 3 == 1) {\\n                p32++;\\n            } else {\\n                p33++;\\n            }\\n        }\\n        if (length < 6) {\\n            return Math.max(prob1, prob2);\\n        } else if (length > 20) {\\n            int prob3ResolvedByDelete = 0;\\n            if (prob1 <= p31) {\\n                prob3ResolvedByDelete = prob1;\\n            } else if (prob1 <= 2 * p32 + p31) {\\n                prob3ResolvedByDelete = p31 + (prob1 - p31) /2;\\n            } else {\\n                prob3ResolvedByDelete = p31 + p32 + (prob1 - p31 - 2 * p32) / 3;\\n            }\\n            return prob1 + Math.max(prob2, prob3 - prob3ResolvedByDelete);\\n        } else {\\n            return Math.max(prob2, prob3);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```6 - length```\n```Prob1```\n```repeat length % 3 = 0```\n```repeat length % 3 = 1```\n```repeat length % 3 = 2```\n```p31```\n```length % 3 = 0```\n```p32```\n```length % 3 = 1```\n```p33```\n```length % 3 = 2```\n```p31```\n```p32```\n```p33```\n```prob3 - prob3ResolvedByDelete```\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int length = password.length();\\n        int prob1 = Math.max(0, Math.max(6 - length, length - 20));\\n        \\n        boolean hasUpper = false;\\n        boolean hasLower = false;\\n        boolean hasDigit = false;\\n        int prob2 = 3;\\n        \\n        int prob3 = 0;\\n        int repeatCount = 1;\\n        int p31 = 0;\\n        int p32 = 0;\\n        int p33 = 0;\\n        \\n        char prev = \\'a\\';\\n        for (int i = 0; i < length; i++) {\\n            char curr = password.charAt(i);\\n            if (Character.isUpperCase(curr) && !hasUpper) {\\n                prob2--;\\n                hasUpper = true;\\n            }\\n            if (Character.isLowerCase(curr) && !hasLower) {\\n                prob2--;\\n                hasLower = true;\\n            }\\n            if (Character.isDigit(curr) && !hasDigit) {\\n                prob2--;\\n                hasDigit = true;\\n            }\\n            \\n            if (i > 0) {\\n                if (curr == prev) {\\n                    repeatCount++;\\n                } else {\\n                    if (repeatCount >= 3) {\\n                        prob3 += repeatCount / 3;\\n                        if (repeatCount % 3 == 0) {\\n                            p31++;\\n                        } else if (repeatCount % 3 == 1) {\\n                            p32++;\\n                        } else {\\n                            p33++;\\n                        }\\n                    }\\n                    repeatCount = 1;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        // need to include the last batch\\n        if (repeatCount >= 3) {\\n            prob3 += repeatCount / 3;\\n            if (repeatCount % 3 == 0) {\\n                p31++;\\n            } else if (repeatCount % 3 == 1) {\\n                p32++;\\n            } else {\\n                p33++;\\n            }\\n        }\\n        if (length < 6) {\\n            return Math.max(prob1, prob2);\\n        } else if (length > 20) {\\n            int prob3ResolvedByDelete = 0;\\n            if (prob1 <= p31) {\\n                prob3ResolvedByDelete = prob1;\\n            } else if (prob1 <= 2 * p32 + p31) {\\n                prob3ResolvedByDelete = p31 + (prob1 - p31) /2;\\n            } else {\\n                prob3ResolvedByDelete = p31 + p32 + (prob1 - p31 - 2 * p32) / 3;\\n            }\\n            return prob1 + Math.max(prob2, prob3 - prob3ResolvedByDelete);\\n        } else {\\n            return Math.max(prob2, prob3);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945982,
                "title": "easy-to-understand-solution-use-deletion-to-reduce-replacement-o-n-and-o-1",
                "content": "```\\n    int strongPasswordChecker(string password) {\\n        int missA = 1, missa = 1, miss0 = 1;\\n        for (auto c : password) {\\n            if (isdigit(c)) {\\n                miss0 = 0;\\n            }\\n            if (c >= \\'a\\' && c <= \\'z\\') {\\n                missa = 0;\\n            }\\n            if (c >= \\'A\\' && c <= \\'Z\\') {\\n                missA = 0;\\n            }\\n        }\\n        \\n        int misstype = missA + missa + miss0;\\n        int N = password.size();\\n        int mod0 = 0, mod1 = 0;\\n        int replace = 0;\\n        \\n        for (int i = 2; i < N; i++) {\\n            if (password[i] == password[i-1] && password[i] == password[i-2]) {\\n                int len = 2;\\n                while (password[i] == password[i-1] && i < N) {\\n                    i++;\\n                    len++;\\n                }\\n                if (len % 3 == 0) {\\n                    mod0++;\\n                } else if (len % 3 == 1) {\\n                    mod1++;\\n                }\\n                i--;\\n                replace += len / 3;\\n            }\\n        }\\n        \\n        if (N <= 20) {\\n            return max({replace, misstype, 6-N});\\n        }\\n        \\n        int deletes = N - 20;\\n        \\n        // use deletes as budget to reduce replace\\n        int budget = deletes;\\n        \\n        if (budget > 0) {\\n            int reduce = min(budget, mod0); // \"aaaaaa\" ---delete one---> \"aaaaa\" (mod=2) \\n            replace -= reduce;\\n            budget -= reduce;\\n        }\\n        \\n        if (budget > 0) {\\n            int reduce = min(budget/2, mod1); // \"aaaaaaa\" ---delete two---> \"aaaaa\" (mod=2) \\n            replace -= reduce;\\n            budget -= reduce * 2;\\n        }\\n        \\n        // all remaing including the above ones, are mod=2 \\n        // every 3 deletions can reduce 1 replace \\n        // \"aaa aaa aa\" ---delete three---> \"aaa aa\" ---delete three--> \"aa\"\\n\\n        if (budget > 0) {\\n            int reduce = min(budget/3, replace); \\n            replace -= reduce;\\n            budget -= reduce * 3;\\n        }\\n        \\n        return max(replace, misstype) + deletes;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int strongPasswordChecker(string password) {\\n        int missA = 1, missa = 1, miss0 = 1;\\n        for (auto c : password) {\\n            if (isdigit(c)) {\\n                miss0 = 0;\\n            }\\n            if (c >= \\'a\\' && c <= \\'z\\') {\\n                missa = 0;\\n            }\\n            if (c >= \\'A\\' && c <= \\'Z\\') {\\n                missA = 0;\\n            }\\n        }\\n        \\n        int misstype = missA + missa + miss0;\\n        int N = password.size();\\n        int mod0 = 0, mod1 = 0;\\n        int replace = 0;\\n        \\n        for (int i = 2; i < N; i++) {\\n            if (password[i] == password[i-1] && password[i] == password[i-2]) {\\n                int len = 2;\\n                while (password[i] == password[i-1] && i < N) {\\n                    i++;\\n                    len++;\\n                }\\n                if (len % 3 == 0) {\\n                    mod0++;\\n                } else if (len % 3 == 1) {\\n                    mod1++;\\n                }\\n                i--;\\n                replace += len / 3;\\n            }\\n        }\\n        \\n        if (N <= 20) {\\n            return max({replace, misstype, 6-N});\\n        }\\n        \\n        int deletes = N - 20;\\n        \\n        // use deletes as budget to reduce replace\\n        int budget = deletes;\\n        \\n        if (budget > 0) {\\n            int reduce = min(budget, mod0); // \"aaaaaa\" ---delete one---> \"aaaaa\" (mod=2) \\n            replace -= reduce;\\n            budget -= reduce;\\n        }\\n        \\n        if (budget > 0) {\\n            int reduce = min(budget/2, mod1); // \"aaaaaaa\" ---delete two---> \"aaaaa\" (mod=2) \\n            replace -= reduce;\\n            budget -= reduce * 2;\\n        }\\n        \\n        // all remaing including the above ones, are mod=2 \\n        // every 3 deletions can reduce 1 replace \\n        // \"aaa aaa aa\" ---delete three---> \"aaa aa\" ---delete three--> \"aa\"\\n\\n        if (budget > 0) {\\n            int reduce = min(budget/3, replace); \\n            replace -= reduce;\\n            budget -= reduce * 3;\\n        }\\n        \\n        return max(replace, misstype) + deletes;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 884238,
                "title": "0ms-java-faster-than-100-o-n",
                "content": "This took a whole day. \\nThe arrayReducer is blocked by O(n/3).\\noverall O( n + n/3 ) = = O(n)\\nCode is very messy and uses a lot of redundant space..\\nBut I can\\'t be bothered by it. This took longer than I expected..\\n```\\nclass Solution {\\n   \\n   \\n    public static int strongPasswordChecker(String s) {\\n        int deletions = 0, finalCounter = 0, insertions = 0, repeating = 1, changesSum;\\n        int replacements = 0, length = s.length();\\n        boolean digit, lowerCase, upperCase;\\n        digit = lowerCase = upperCase = false;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        for (int i = 0; i < length; i++) {\\n            if (i > 19)\\n                deletions++;\\n            if (Character.isLowerCase(s.charAt(i)))\\n                lowerCase = true;\\n            if (Character.isUpperCase(s.charAt(i)))\\n                upperCase = true;\\n            if (Character.isDigit(s.charAt(i)))\\n                digit = true;\\n            if (i > 0) {\\n                if (s.charAt(i) == s.charAt(i - 1))\\n                    repeating++;\\n                else {\\n                    if (repeating > 2)\\n                        arr.add(repeating);\\n                    repeating = 1;\\n                }\\n            }\\n        }\\n        if (repeating > 2)\\n            arr.add(repeating);\\n        if (digit)\\n            insertions++;\\n\\n        if (upperCase)\\n            insertions++;\\n\\n        if (lowerCase)\\n            insertions++;\\n        insertions = 3 - insertions;\\n\\n        if(deletions > 0 && arr.size() > 0)\\n            arr = arrayReducer(arr, deletions);\\n        changesSum =listSum(arr);\\n        finalCounter = deletions + changesSum;\\n\\n        if(insertions > 0){\\n            if(changesSum >= insertions)\\n                insertions = 0;\\n            else\\n                insertions = insertions - changesSum;\\n            }\\n        if(s.length() < 6) {\\n            if(insertions < 6- (s.length()))\\n                insertions = insertions + (6 - s.length() - insertions);\\n            if(insertions > changesSum)\\n                insertions = insertions - changesSum;\\n        }\\n        finalCounter = finalCounter + insertions;\\n\\n            return finalCounter;\\n    }\\n\\n    public static int listSum (ArrayList<Integer> arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.size();  i ++ )\\n            sum = sum + (arr.get(i)/3);\\n\\n        return sum;\\n\\n    }\\n    public static ArrayList arrayReducer(ArrayList<Integer> arr, int i) {\\n        int mod;\\n        int current, counter = 0, flag = arr.size() + 1;\\n        while(i>0) {\\n            mod = counter%3;\\n            for(int x = 0; x <arr.size(); x++) {\\n                if( flag == 0 )\\n                    return arr;\\n                current = arr.get(x);\\n                if (current % 3 == mod) {\\n                    if (i >= (mod + 1)) {\\n                        i = i - (mod + 1);\\n\\n                        arr.set(x, current - (mod + 1));\\n                    } else{\\n                        flag--;\\n                        if (mod == 0)\\n                        return arr;\\n                    }\\n                    if (i == 0)\\n                        return arr;\\n\\n\\n                }\\n                if(i < (mod + 1))\\n                    if(mod == 0)\\n                        return arr;\\n            }\\n            counter++;\\n        }\\n        return arr;\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\n   \\n    public static int strongPasswordChecker(String s) {\\n        int deletions = 0, finalCounter = 0, insertions = 0, repeating = 1, changesSum;\\n        int replacements = 0, length = s.length();\\n        boolean digit, lowerCase, upperCase;\\n        digit = lowerCase = upperCase = false;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        for (int i = 0; i < length; i++) {\\n            if (i > 19)\\n                deletions++;\\n            if (Character.isLowerCase(s.charAt(i)))\\n                lowerCase = true;\\n            if (Character.isUpperCase(s.charAt(i)))\\n                upperCase = true;\\n            if (Character.isDigit(s.charAt(i)))\\n                digit = true;\\n            if (i > 0) {\\n                if (s.charAt(i) == s.charAt(i - 1))\\n                    repeating++;\\n                else {\\n                    if (repeating > 2)\\n                        arr.add(repeating);\\n                    repeating = 1;\\n                }\\n            }\\n        }\\n        if (repeating > 2)\\n            arr.add(repeating);\\n        if (digit)\\n            insertions++;\\n\\n        if (upperCase)\\n            insertions++;\\n\\n        if (lowerCase)\\n            insertions++;\\n        insertions = 3 - insertions;\\n\\n        if(deletions > 0 && arr.size() > 0)\\n            arr = arrayReducer(arr, deletions);\\n        changesSum =listSum(arr);\\n        finalCounter = deletions + changesSum;\\n\\n        if(insertions > 0){\\n            if(changesSum >= insertions)\\n                insertions = 0;\\n            else\\n                insertions = insertions - changesSum;\\n            }\\n        if(s.length() < 6) {\\n            if(insertions < 6- (s.length()))\\n                insertions = insertions + (6 - s.length() - insertions);\\n            if(insertions > changesSum)\\n                insertions = insertions - changesSum;\\n        }\\n        finalCounter = finalCounter + insertions;\\n\\n            return finalCounter;\\n    }\\n\\n    public static int listSum (ArrayList<Integer> arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.size();  i ++ )\\n            sum = sum + (arr.get(i)/3);\\n\\n        return sum;\\n\\n    }\\n    public static ArrayList arrayReducer(ArrayList<Integer> arr, int i) {\\n        int mod;\\n        int current, counter = 0, flag = arr.size() + 1;\\n        while(i>0) {\\n            mod = counter%3;\\n            for(int x = 0; x <arr.size(); x++) {\\n                if( flag == 0 )\\n                    return arr;\\n                current = arr.get(x);\\n                if (current % 3 == mod) {\\n                    if (i >= (mod + 1)) {\\n                        i = i - (mod + 1);\\n\\n                        arr.set(x, current - (mod + 1));\\n                    } else{\\n                        flag--;\\n                        if (mod == 0)\\n                        return arr;\\n                    }\\n                    if (i == 0)\\n                        return arr;\\n\\n\\n                }\\n                if(i < (mod + 1))\\n                    if(mod == 0)\\n                        return arr;\\n            }\\n            counter++;\\n        }\\n        return arr;\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833624,
                "title": "python-solution-with-details-around-90-time-and-80-space",
                "content": "In this question, the cheapest way to solve a **consecutive3** condition should be using replacing, because for solving  any consecutive with length n >= 3:\\n* removing letter will need **n-2** operations\\n* adding operations will need **(n-1)/2** operations\\n* replacing only needs **n/3** operations\\n\\nAlso, the **low/upper/digit** condition should also be solved by replacing, because it can cover **consecutive3** and won\\'t cause new **length** problem\\n\\n**Length** problem can only be solved by adding or removing letters. Adding letters can cover **low/upper/digit** and **consecutive3**, removing can only cover **consecutive3**.\\n\\nIn my solution, I am trying to calculate how many operations need for fixing each of **length**, **low/upper/digit**, and **consecutive3**. Then analyze the cheapest way to let them cover each others\\' problem.\\n\\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        repeat = []\\n        i = 0\\n        prev, count = \\'\\',1\\n        low = up = digit = 1\\n        \\n        while i < len(s):\\n            \\n            if low and s[i].islower():\\n                low = 0\\n            if up and not s[i].islower():\\n                up = 0\\n            if digit and s[i].isdigit():\\n                digit = 0\\n                \\n            if s[i] == prev:\\n                count+=1\\n            else:\\n                if count >= 3:\\n                    repeat.append(count)\\n                prev = s[i]\\n                count = 1\\n            i+=1\\n        if count >= 3:\\n            repeat.append(count)\\n        \\n        #if we use replace, this is the minimal num of operations to remove all consecutive3\\n        allRepeat = sum([r//3 for r in repeat]) \\n        #this is num of operations to cover all low/upper/digit\\n        cases = low + up + digit\\n        \\n        if 20 >= len(s):\\n            #in this case we only need to add letters\\n            less = 6-len(s) if len(s) < 6 else 0\\n            \\n            # in cases like aaaaa, even after adding one letter, we still have one consecutive3\\n            if less == 1 and len(repeat) == 1 and repeat[0] == 5:\\n                allRepeat = 2\\n            \\n            # return max num of 3 types of operations, because each of them can also solve other types\\' problem\\n            return max(less,allRepeat,cases)\\n        else:\\n            less = len(s) - 20\\n            if allRepeat <= cases:\\n                # in this case all consecutive3 will be covered by replacing one letter by low/upper/digit letter\\n                # so we only need to remove all extra letter, and make sure we have all low/upper/digit letters\\n                return cases+less\\n    \\n            # sort the toRemove by how many letters need be removed to reduce consecutive3 operation by one\\n            toRemove = sorted([(r%3,r//3) for r in repeat])\\n            totalLess = less\\n            \\n            while less > 0:\\n                count = 0\\n                for i in range(len(toRemove)):\\n                    # try to use least remove operations to cover as much as consecutive3 operations as possible\\n                    tr = toRemove[i]\\n                    if tr[1] == 0:\\n                        count += 1\\n                        continue\\n                    if less >= tr[0]+1:\\n                        # cover one consecutive3 operations by removing letters operation\\n                        toRemove[i] = (2,tr[1]-1)\\n                        less -= (tr[0]+1)\\n                    else:\\n                        # not enough removing operations to cover any more consecutive3 operations\\n                        toRemove[i] = (tr[0] - less, tr[1])\\n                        less = 0\\n                        break\\n                \\n                if count == len(toRemove):\\n                    # all consecutive3 operations are covered by removing letters operations\\n                    # so we just remove all extra letters, and then make sure low/upper/digits exists\\n                    return totalLess + cases\\n                if less == 0:\\n                    # we run out of removing letters operations, but there are still some consecutive3 here\\n                    break\\n            \\n            # re-calculate the rest replace operations needed for consecutive3\\n            allRepeat = sum([tr[1] for tr in toRemove])\\n            \\n            # return all removing operations plus the max of low/upper/digits and consecutive3 operations\\n            return totalLess + max(cases, allRepeat)\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        repeat = []\\n        i = 0\\n        prev, count = \\'\\',1\\n        low = up = digit = 1\\n        \\n        while i < len(s):\\n            \\n            if low and s[i].islower():\\n                low = 0\\n            if up and not s[i].islower():\\n                up = 0\\n            if digit and s[i].isdigit():\\n                digit = 0\\n                \\n            if s[i] == prev:\\n                count+=1\\n            else:\\n                if count >= 3:\\n                    repeat.append(count)\\n                prev = s[i]\\n                count = 1\\n            i+=1\\n        if count >= 3:\\n            repeat.append(count)\\n        \\n        #if we use replace, this is the minimal num of operations to remove all consecutive3\\n        allRepeat = sum([r//3 for r in repeat]) \\n        #this is num of operations to cover all low/upper/digit\\n        cases = low + up + digit\\n        \\n        if 20 >= len(s):\\n            #in this case we only need to add letters\\n            less = 6-len(s) if len(s) < 6 else 0\\n            \\n            # in cases like aaaaa, even after adding one letter, we still have one consecutive3\\n            if less == 1 and len(repeat) == 1 and repeat[0] == 5:\\n                allRepeat = 2\\n            \\n            # return max num of 3 types of operations, because each of them can also solve other types\\' problem\\n            return max(less,allRepeat,cases)\\n        else:\\n            less = len(s) - 20\\n            if allRepeat <= cases:\\n                # in this case all consecutive3 will be covered by replacing one letter by low/upper/digit letter\\n                # so we only need to remove all extra letter, and make sure we have all low/upper/digit letters\\n                return cases+less\\n    \\n            # sort the toRemove by how many letters need be removed to reduce consecutive3 operation by one\\n            toRemove = sorted([(r%3,r//3) for r in repeat])\\n            totalLess = less\\n            \\n            while less > 0:\\n                count = 0\\n                for i in range(len(toRemove)):\\n                    # try to use least remove operations to cover as much as consecutive3 operations as possible\\n                    tr = toRemove[i]\\n                    if tr[1] == 0:\\n                        count += 1\\n                        continue\\n                    if less >= tr[0]+1:\\n                        # cover one consecutive3 operations by removing letters operation\\n                        toRemove[i] = (2,tr[1]-1)\\n                        less -= (tr[0]+1)\\n                    else:\\n                        # not enough removing operations to cover any more consecutive3 operations\\n                        toRemove[i] = (tr[0] - less, tr[1])\\n                        less = 0\\n                        break\\n                \\n                if count == len(toRemove):\\n                    # all consecutive3 operations are covered by removing letters operations\\n                    # so we just remove all extra letters, and then make sure low/upper/digits exists\\n                    return totalLess + cases\\n                if less == 0:\\n                    # we run out of removing letters operations, but there are still some consecutive3 here\\n                    break\\n            \\n            # re-calculate the rest replace operations needed for consecutive3\\n            allRepeat = sum([tr[1] for tr in toRemove])\\n            \\n            # return all removing operations plus the max of low/upper/digits and consecutive3 operations\\n            return totalLess + max(cases, allRepeat)\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 788493,
                "title": "clear-and-short-python-explanation-commented-code",
                "content": "A password is considered strong if below conditions are all met:\\n1. It has at least 6 characters and at most 20 characters.\\n2. It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.\\n3. It must NOT contain three repeating characters in a row (\"...aaa...\" is weak, but \"...aa...a...\" is strong, assuming other conditions are met).\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        \"\"\"\\n        Missing/length reqs are easy by themselves.\\n        For repeating sequences, we need to find number of ADDITIONAL replaces.\\n        We can insert (ideal for len(s) < 6) to disrupt missing (+ reduce one replace).\\n        We can delete (ideal for len(s) > 20) 1-3 characters to reduce one replace.\\n        We can replace as last resort.\\n        \\n        Excellent explainer: https://leetcode.com/problems/strong-password-checker/discuss/478197/Explanation-of-How-To-Approach-This-Problem\\n        \"\"\"\\n        # Requirement 2\\n        req_missing = 3\\n        req_missing -= any(c.islower() for c in s)\\n        req_missing -= any(c.isupper() for c in s)\\n        req_missing -= any(c.isdigit() for c in s)\\n        \\n        # Requirement 3\\n        repeat_replace = 0\\n        mod0 = mod1 = 0\\n        i = 2\\n        while i < len(s):\\n            if s[i] == s[i-1] == s[i-2]:    # start of repeating sequence\\n                curr = 2  # track length of current repeating sequence\\n                while i < len(s) and s[i-1] == s[i]:\\n                    curr += 1\\n                    i += 1\\n                repeat_replace += curr // 3 # {# of raw replacements needed}\\n                # We can reduce replaces, by using strategic deletes\\n                mod0 += int(curr%3==0)      # mod0 -> mod2 costs 1 delete to save one replace\\n                mod1 += int(curr%3==1)      # mod1 -> mod2 costs 2 deletes to save one replace\\n                # mod2 -> mod2 costs 3 deletes to save one replace\\n            else:\\n                i += 1\\n\\n        # Requirement 1\\n        res = max(0, len(s)-20)                     # {# deletes} + {# inserts} + {# replaces}\\n        if len(s) > 20:\\n            deletes = len(s)-20                     # need to delete, then replace\\n            repeat_replace -= min(deletes, mod0)    # delete mod0 -> mod2 == save one replace\\n            deletes = max(0, deletes - mod0)\\n            repeat_replace -= min(deletes, mod1*2)//2   # delete mod1 -> mod2 == save one replace\\n            deletes = max(0, deletes - mod1*2)\\n            repeat_replace -= deletes // 3                  # use remaining deletes to mod2 -> mod2\\n        res += max(6-len(s), req_missing, repeat_replace)   # can insert or replace with missing chars, so they\\'re interchangeable here\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        \"\"\"\\n        Missing/length reqs are easy by themselves.\\n        For repeating sequences, we need to find number of ADDITIONAL replaces.\\n        We can insert (ideal for len(s) < 6) to disrupt missing (+ reduce one replace).\\n        We can delete (ideal for len(s) > 20) 1-3 characters to reduce one replace.\\n        We can replace as last resort.\\n        \\n        Excellent explainer: https://leetcode.com/problems/strong-password-checker/discuss/478197/Explanation-of-How-To-Approach-This-Problem\\n        \"\"\"\\n        # Requirement 2\\n        req_missing = 3\\n        req_missing -= any(c.islower() for c in s)\\n        req_missing -= any(c.isupper() for c in s)\\n        req_missing -= any(c.isdigit() for c in s)\\n        \\n        # Requirement 3\\n        repeat_replace = 0\\n        mod0 = mod1 = 0\\n        i = 2\\n        while i < len(s):\\n            if s[i] == s[i-1] == s[i-2]:    # start of repeating sequence\\n                curr = 2  # track length of current repeating sequence\\n                while i < len(s) and s[i-1] == s[i]:\\n                    curr += 1\\n                    i += 1\\n                repeat_replace += curr // 3 # {# of raw replacements needed}\\n                # We can reduce replaces, by using strategic deletes\\n                mod0 += int(curr%3==0)      # mod0 -> mod2 costs 1 delete to save one replace\\n                mod1 += int(curr%3==1)      # mod1 -> mod2 costs 2 deletes to save one replace\\n                # mod2 -> mod2 costs 3 deletes to save one replace\\n            else:\\n                i += 1\\n\\n        # Requirement 1\\n        res = max(0, len(s)-20)                     # {# deletes} + {# inserts} + {# replaces}\\n        if len(s) > 20:\\n            deletes = len(s)-20                     # need to delete, then replace\\n            repeat_replace -= min(deletes, mod0)    # delete mod0 -> mod2 == save one replace\\n            deletes = max(0, deletes - mod0)\\n            repeat_replace -= min(deletes, mod1*2)//2   # delete mod1 -> mod2 == save one replace\\n            deletes = max(0, deletes - mod1*2)\\n            repeat_replace -= deletes // 3                  # use remaining deletes to mod2 -> mod2\\n        res += max(6-len(s), req_missing, repeat_replace)   # can insert or replace with missing chars, so they\\'re interchangeable here\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733369,
                "title": "c-0-ms-solution",
                "content": "The idea is inspired by [this solution](https://leetcode.com/problems/strong-password-checker/discuss/91007/C%2B%2B-0ms-O(n)-35-lines-solution-with-detailed-explanation).\\nIt is simple to deal with cases in which there is no need to delete characters. For each cases, as long as we change enough characters, there is no need to worry about the type requirements of upper case, lowe case and digits. So taking the max of number of charaters to insert, number of characters to change to meet type requirements will sove the problem. The tricky part is when there is excess characters and we have to delete characters. If we have k (k > 20)characters, we must delete k-20 characters to meet the length requirements. If deletes are enough to cut any repetition, then we don\\'t need to worry about making changes to satisfy repetition requirement . We can just return the number of deletes plus number of changes to meet type requirements. However, if we are short on deletes, we must use them wisely to minimze changes made to satisfy repetition requirement. One observation is that changing a charater is really effective in disrupting repeating sequences. You only need x/3 changes(x is the length of repeating sequence) while deleting a character only works when you cut the sequence of 3 into 2.  Since we are short on deletes, we always want our delete to do something. Here I mean we want our delete makes x/3 < (x-1)/3 (c++ divide here). Before going to the algorithm, let\\'s consider a few cases first.\\n1. 11\\n2. 11**1**\\n3. 111**1**\\n4. 1111**1**\\n5. 11111**1**\\nFor case 1, we need to do nothing. For case 2, our delete effectively disrupt a repeating sequence. For case 3, though we delete a character, there is still 3 repeating characters. Similarly for case 4. For case 5, if we change the character at the thrid position, our delete also disrupt a repeating sequence. \\nWe should use our deletes on case 5 and 2 first, before we use them on case 3 and 4. To do so, the way I think is to use a priority with a very special comparater x has higer priority than y if x%3 < x%y. We can just push all repeating sequence onto the priority queue,  and then process the cases like 1 and 5 first. If the sequence after processing is still repeating, we push it back into the priority queue. After we\\'ve used up our deletes, we can process the rest repeating sequences the same way in case where there is no need to delete.\\n```\\nclass Solution {\\n   public:\\n    int strongPasswordChecker(string s) {\\n        int l = s.size();\\n        if (l == 0)\\n            return 6;\\n        if (l <= 20) {\\n            int total_changes = 0;\\n            int uppers = 0;\\n            int lowers = 0;\\n            int digits = 0;\\n            int i = 0, j = 0;\\n            while (i < l) {\\n                j = i;\\n                while (j < l && s[j] == s[i]) {\\n                    uppers += isupper(s[j]);\\n                    lowers += islower(s[j]);\\n                    digits += isdigit(s[j]);\\n                    j++;\\n                }\\n                int len = j - i;\\n                total_changes += len / 3;\\n                i = j;\\n            }\\n            int r = 3 - (!!uppers + !!lowers + !!digits);\\n            int inserts = l < 6 ? 6 - l : 0;\\n            return max({inserts, r, total_changes});\\n        } else {\\n            int total_changes = 0;\\n            int uppers = 0;\\n            int lowers = 0;\\n            int digits = 0;\\n            int deletes = l - 20;\\n            int i = 0, j = 0;\\n            auto comp = [](const int a, const int b)->bool{return a %3 > b%3;};\\n            priority_queue<int,vector<int>,decltype(comp)> pq(comp);\\n            while (i < l) {\\n                j = i;\\n                while (j < l && s[j] == s[i]) {\\n                    uppers += isupper(s[j]);\\n                    lowers += islower(s[j]);\\n                    digits += isdigit(s[j]);\\n                    j++;\\n                }\\n                int len = j - i;\\n                if (len > 2)\\n                    pq.push(len);\\n                i = j;\\n            }\\n            while(!pq.empty() && deletes){\\n                int change = pq.top();\\n                pq.pop();\\n                change--;\\n                deletes--;\\n                if(change > 2)\\n                    pq.push(change);\\n            }  \\n            while(!pq.empty()){\\n                int change = pq.top();\\n                pq.pop();\\n                total_changes += change/3;\\n            }\\n            int r = 3 - (!!uppers + !!lowers + !!digits);\\n            return max(r, total_changes) + l - 20;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n    int strongPasswordChecker(string s) {\\n        int l = s.size();\\n        if (l == 0)\\n            return 6;\\n        if (l <= 20) {\\n            int total_changes = 0;\\n            int uppers = 0;\\n            int lowers = 0;\\n            int digits = 0;\\n            int i = 0, j = 0;\\n            while (i < l) {\\n                j = i;\\n                while (j < l && s[j] == s[i]) {\\n                    uppers += isupper(s[j]);\\n                    lowers += islower(s[j]);\\n                    digits += isdigit(s[j]);\\n                    j++;\\n                }\\n                int len = j - i;\\n                total_changes += len / 3;\\n                i = j;\\n            }\\n            int r = 3 - (!!uppers + !!lowers + !!digits);\\n            int inserts = l < 6 ? 6 - l : 0;\\n            return max({inserts, r, total_changes});\\n        } else {\\n            int total_changes = 0;\\n            int uppers = 0;\\n            int lowers = 0;\\n            int digits = 0;\\n            int deletes = l - 20;\\n            int i = 0, j = 0;\\n            auto comp = [](const int a, const int b)->bool{return a %3 > b%3;};\\n            priority_queue<int,vector<int>,decltype(comp)> pq(comp);\\n            while (i < l) {\\n                j = i;\\n                while (j < l && s[j] == s[i]) {\\n                    uppers += isupper(s[j]);\\n                    lowers += islower(s[j]);\\n                    digits += isdigit(s[j]);\\n                    j++;\\n                }\\n                int len = j - i;\\n                if (len > 2)\\n                    pq.push(len);\\n                i = j;\\n            }\\n            while(!pq.empty() && deletes){\\n                int change = pq.top();\\n                pq.pop();\\n                change--;\\n                deletes--;\\n                if(change > 2)\\n                    pq.push(change);\\n            }  \\n            while(!pq.empty()){\\n                int change = pq.top();\\n                pq.pop();\\n                total_changes += change/3;\\n            }\\n            int r = 3 - (!!uppers + !!lowers + !!digits);\\n            return max(r, total_changes) + l - 20;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693496,
                "title": "simple-c-solution",
                "content": "```\\nint dp[50][22][2][2][2][65][65];    \\nclass Solution {\\npublic:\\n    // dp[0...i][j length][has_lower][has_upper][has_digit][last_char][last_to_last_char]\\n    bool isupper(char c) {\\n        return (c >= \\'A\\' && c <= \\'Z\\');\\n    }\\n    bool islower(char c) {\\n        return (c >= \\'a\\' && c <= \\'z\\');\\n    }\\n    bool isdigit(char c) {\\n        return (c >= \\'0\\' && c <= \\'9\\');\\n    }\\n    int getnum(char c) {\\n        if (c >= \\'a\\' && c <= \\'z\\') return c - \\'a\\';\\n        if (c >= \\'A\\' && c <= \\'Z\\') return 26 + c - \\'A\\';\\n        if (c >= \\'0\\' && c <= \\'9\\') return 52 + c - \\'0\\';\\n        return 64;\\n    }\\n    int dfs(const string& s, int pos, int taken, bool has_upper, bool has_lower, bool has_digit, int last_char, int last_to_last_char) {        \\n        if (taken > 20) return 1e9;\\n       \\n        if (pos == s.size()) {\\n            if (taken >= 6 && has_upper && has_lower && has_digit) return 0;\\n            if (taken < 6) {\\n              int res = 1 + dfs(s, pos, taken + 1, true, has_upper, has_digit, 63, 63);\\n              res = min(res, 1 + dfs(s, pos, taken + 1, has_lower, true, has_digit, 63, 63));\\n              return min(res, 1 + dfs(s, pos, taken + 1, has_lower, has_upper, true, 63, 63));\\n            }\\n            return 1e9;\\n        }\\n        int& res = dp[pos][taken][has_upper][has_lower][has_digit][last_char][last_to_last_char];\\n        if (res != -1) return res;\\n        res = 1e9;\\n        if (!(last_char == last_to_last_char && last_char == getnum(s[pos]))) {\\n            res = min(res, dfs(s, pos + 1, taken + 1, has_upper | isupper(s[pos]), has_lower | islower(s[pos]), has_digit | isdigit(s[pos]), getnum(s[pos]), last_char));\\n        }\\n        res = min(res, 1 + dfs(s, pos + 1, taken, has_upper, has_lower, has_digit, last_char, last_to_last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, true, has_lower, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, has_upper, true, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, has_upper, has_lower, true, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, true, has_lower, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, has_upper, true, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, has_upper, has_lower, true, 63, last_char));\\n        return res;\\n    }\\n    int strongPasswordChecker(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, 0, 0, false, false, false, 63, 63);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint dp[50][22][2][2][2][65][65];    \\nclass Solution {\\npublic:\\n    // dp[0...i][j length][has_lower][has_upper][has_digit][last_char][last_to_last_char]\\n    bool isupper(char c) {\\n        return (c >= \\'A\\' && c <= \\'Z\\');\\n    }\\n    bool islower(char c) {\\n        return (c >= \\'a\\' && c <= \\'z\\');\\n    }\\n    bool isdigit(char c) {\\n        return (c >= \\'0\\' && c <= \\'9\\');\\n    }\\n    int getnum(char c) {\\n        if (c >= \\'a\\' && c <= \\'z\\') return c - \\'a\\';\\n        if (c >= \\'A\\' && c <= \\'Z\\') return 26 + c - \\'A\\';\\n        if (c >= \\'0\\' && c <= \\'9\\') return 52 + c - \\'0\\';\\n        return 64;\\n    }\\n    int dfs(const string& s, int pos, int taken, bool has_upper, bool has_lower, bool has_digit, int last_char, int last_to_last_char) {        \\n        if (taken > 20) return 1e9;\\n       \\n        if (pos == s.size()) {\\n            if (taken >= 6 && has_upper && has_lower && has_digit) return 0;\\n            if (taken < 6) {\\n              int res = 1 + dfs(s, pos, taken + 1, true, has_upper, has_digit, 63, 63);\\n              res = min(res, 1 + dfs(s, pos, taken + 1, has_lower, true, has_digit, 63, 63));\\n              return min(res, 1 + dfs(s, pos, taken + 1, has_lower, has_upper, true, 63, 63));\\n            }\\n            return 1e9;\\n        }\\n        int& res = dp[pos][taken][has_upper][has_lower][has_digit][last_char][last_to_last_char];\\n        if (res != -1) return res;\\n        res = 1e9;\\n        if (!(last_char == last_to_last_char && last_char == getnum(s[pos]))) {\\n            res = min(res, dfs(s, pos + 1, taken + 1, has_upper | isupper(s[pos]), has_lower | islower(s[pos]), has_digit | isdigit(s[pos]), getnum(s[pos]), last_char));\\n        }\\n        res = min(res, 1 + dfs(s, pos + 1, taken, has_upper, has_lower, has_digit, last_char, last_to_last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, true, has_lower, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, has_upper, true, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, has_upper, has_lower, true, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, true, has_lower, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, has_upper, true, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, has_upper, has_lower, true, 63, last_char));\\n        return res;\\n    }\\n    int strongPasswordChecker(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, 0, 0, false, false, false, 63, 63);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652702,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int has_lower = 0, has_upper = 0, has_digit = 0;\\n    int rep = 0;\\n    vector<int>repeat;\\n    int rep_1 = 0, rep_2 = 0;\\n    void check(string s) {\\n        int cnt = 0;\\n        char c = \\'@\\';\\n        for(int i = 0; i < s.size(); i++) {\\n            if(isupper(s[i])) {\\n                has_upper = 1;\\n            }\\n            if(islower(s[i])) {\\n                has_lower = 1;\\n            }\\n            if(isdigit(s[i])) {\\n                has_digit = 1;\\n            }\\n            if(s[i] == c) {\\n                cnt++;\\n            } else {\\n                if(cnt >= 3) {\\n                    repeat.push_back(cnt);\\n                }\\n                c = s[i];\\n                cnt = 1;\\n            }\\n        }\\n        if(cnt >= 3) {\\n            repeat.push_back(cnt);\\n        }\\n        for(auto x: repeat) {\\n            if(x % 3 == 0) { \\n                rep_1 += 1; \\n            }\\n            if(x % 3 == 1) {\\n                rep_2 += 1;\\n            }\\n            rep += x / 3;\\n        }\\n    }\\n    \\n    int strongPasswordChecker(string s) {\\n        if(s.size() == 0) {\\n            return 6;\\n        }\\n        check(s);\\n        int letter = 3 - has_upper - has_lower - has_digit;\\n        if(s.size() < 6) {\\n            return max(6 - (int)s.size(), letter);\\n        }\\n        if(s.size() <= 20 && s.size() >= 6) {\\n            return max(rep, letter);\\n        }\\n        if(s.size() > 20) {\\n            int remain = s.size() - 20;\\n            if(remain <= rep_1) {\\n                rep -= remain;\\n            } else if(remain - rep_1 <= 2 * rep_2) {\\n                rep -= rep_1 + (remain - rep_1) / 2;\\n            } else {\\n                rep -= rep_1 + rep_2 + (remain - rep_1 - 2 * rep_2) / 3;\\n            }\\n            return remain + max(rep, letter);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int has_lower = 0, has_upper = 0, has_digit = 0;\\n    int rep = 0;\\n    vector<int>repeat;\\n    int rep_1 = 0, rep_2 = 0;\\n    void check(string s) {\\n        int cnt = 0;\\n        char c = \\'@\\';\\n        for(int i = 0; i < s.size(); i++) {\\n            if(isupper(s[i])) {\\n                has_upper = 1;\\n            }\\n            if(islower(s[i])) {\\n                has_lower = 1;\\n            }\\n            if(isdigit(s[i])) {\\n                has_digit = 1;\\n            }\\n            if(s[i] == c) {\\n                cnt++;\\n            } else {\\n                if(cnt >= 3) {\\n                    repeat.push_back(cnt);\\n                }\\n                c = s[i];\\n                cnt = 1;\\n            }\\n        }\\n        if(cnt >= 3) {\\n            repeat.push_back(cnt);\\n        }\\n        for(auto x: repeat) {\\n            if(x % 3 == 0) { \\n                rep_1 += 1; \\n            }\\n            if(x % 3 == 1) {\\n                rep_2 += 1;\\n            }\\n            rep += x / 3;\\n        }\\n    }\\n    \\n    int strongPasswordChecker(string s) {\\n        if(s.size() == 0) {\\n            return 6;\\n        }\\n        check(s);\\n        int letter = 3 - has_upper - has_lower - has_digit;\\n        if(s.size() < 6) {\\n            return max(6 - (int)s.size(), letter);\\n        }\\n        if(s.size() <= 20 && s.size() >= 6) {\\n            return max(rep, letter);\\n        }\\n        if(s.size() > 20) {\\n            int remain = s.size() - 20;\\n            if(remain <= rep_1) {\\n                rep -= remain;\\n            } else if(remain - rep_1 <= 2 * rep_2) {\\n                rep -= rep_1 + (remain - rep_1) / 2;\\n            } else {\\n                rep -= rep_1 + rep_2 + (remain - rep_1 - 2 * rep_2) / 3;\\n            }\\n            return remain + max(rep, letter);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328750,
                "title": "java-dfs-solution-beat-100",
                "content": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        if(s.length() < 5) return 6 - s.length();\\n        if(s.length() == 5) return isAllSameCharacter(s) ? 2 : 1;\\n        \\n        int minDeletion = Math.max(0, s.length() - 20);\\n        int minReplace = calMinReplace(s);\\n        \\n        int[] res = new int[] {Integer.MAX_VALUE};\\n        \\n        helper(0, 0, 0, minReplace, minDeletion, s, res);\\n        \\n        return res[0];\\n    }\\n    \\n    private void helper(int start, int replace, int delete, int minReplace, int minDeletion, String s, int[] res) {\\n        int next = findNextInvalid(start, s);   \\n\\n        if(next == s.length()) {\\n            \\n            res[0] = Math.min(Math.max(replace, minReplace) + minDeletion, res[0]);\\n            return;\\n        }\\n        // replace is always better than deletion, so when the minDeletion met, we only do replace\\n        if(delete < minDeletion) {\\n            // delete\\n            helper(next - 1, replace, delete + 1, minReplace, minDeletion, s, res);\\n        }     \\n        // replace\\n        helper(next + 1, replace + 1, delete, minReplace, minDeletion, s, res);\\n    }\\n    \\n    private int findNextInvalid(int start, String s) {\\n        if(start >= s.length()) return s.length();\\n        \\n        char c = s.charAt(start);\\n        \\n        for(int count = 0, i = start; i < s.length(); i++) {\\n            if(c == s.charAt(i)) {\\n                if(++count == 3) return i;\\n            }  else {\\n                count = 1;\\n                c = s.charAt(i);\\n            }\\n        }\\n        \\n        return s.length();\\n    }\\n    \\n    \\n    private int calMinReplace(String s) {\\n        boolean hasUpperCase = false, hasLowerCase = false, hasDigit = false;\\n        int res = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c >= \\'A\\' && c <= \\'Z\\') hasUpperCase = true;\\n            if(c >= \\'a\\' && c <= \\'z\\') hasLowerCase = true;\\n            if(c >= \\'0\\' && c <= \\'9\\') hasDigit = true;\\n        }\\n        \\n        res += hasUpperCase ? 0 : 1;\\n        res += hasLowerCase ? 0 : 1;\\n        res += hasDigit ? 0 : 1;\\n        \\n        return res;\\n    }\\n    \\n    private boolean isAllSameCharacter(String s) {\\n        char c = s.charAt(0);\\n        for(int i = 1; i < s.length(); i++) {\\n            if(s.charAt(i) != c) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        if(s.length() < 5) return 6 - s.length();\\n        if(s.length() == 5) return isAllSameCharacter(s) ? 2 : 1;\\n        \\n        int minDeletion = Math.max(0, s.length() - 20);\\n        int minReplace = calMinReplace(s);\\n        \\n        int[] res = new int[] {Integer.MAX_VALUE};\\n        \\n        helper(0, 0, 0, minReplace, minDeletion, s, res);\\n        \\n        return res[0];\\n    }\\n    \\n    private void helper(int start, int replace, int delete, int minReplace, int minDeletion, String s, int[] res) {\\n        int next = findNextInvalid(start, s);   \\n\\n        if(next == s.length()) {\\n            \\n            res[0] = Math.min(Math.max(replace, minReplace) + minDeletion, res[0]);\\n            return;\\n        }\\n        // replace is always better than deletion, so when the minDeletion met, we only do replace\\n        if(delete < minDeletion) {\\n            // delete\\n            helper(next - 1, replace, delete + 1, minReplace, minDeletion, s, res);\\n        }     \\n        // replace\\n        helper(next + 1, replace + 1, delete, minReplace, minDeletion, s, res);\\n    }\\n    \\n    private int findNextInvalid(int start, String s) {\\n        if(start >= s.length()) return s.length();\\n        \\n        char c = s.charAt(start);\\n        \\n        for(int count = 0, i = start; i < s.length(); i++) {\\n            if(c == s.charAt(i)) {\\n                if(++count == 3) return i;\\n            }  else {\\n                count = 1;\\n                c = s.charAt(i);\\n            }\\n        }\\n        \\n        return s.length();\\n    }\\n    \\n    \\n    private int calMinReplace(String s) {\\n        boolean hasUpperCase = false, hasLowerCase = false, hasDigit = false;\\n        int res = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c >= \\'A\\' && c <= \\'Z\\') hasUpperCase = true;\\n            if(c >= \\'a\\' && c <= \\'z\\') hasLowerCase = true;\\n            if(c >= \\'0\\' && c <= \\'9\\') hasDigit = true;\\n        }\\n        \\n        res += hasUpperCase ? 0 : 1;\\n        res += hasLowerCase ? 0 : 1;\\n        res += hasDigit ? 0 : 1;\\n        \\n        return res;\\n    }\\n    \\n    private boolean isAllSameCharacter(String s) {\\n        char c = s.charAt(0);\\n        for(int i = 1; i < s.length(); i++) {\\n            if(s.charAt(i) != c) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166464,
                "title": "simple-python-solution-with-explanations",
                "content": "Cases when len(s)>20:\\n* e.g. there\\'s a segment **aaaaaaa** inside (repeat length % 3==1). Originally, we will consider change 7/3=2 characters to make it a legal segment, like **aabaaba**. But now can we delete some characters instead since delete operations are already unavoidable. Actually every 2 deletions work the same as 1 replacement. After delete 2 characters (you can assume the last 2), the segment becomes **aaaaa**, and only one more replacement needed (**aabaa**).\\n* Similarly, for **repeat length % 3==0**, one deletion works the same as one replacement.\\n* For  **repeat length % 3==2**, three deletions can reduce a replacement operation.\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n\\n        def repeat(s):\\n            count = 1\\n            p0 = p1 = p2 = 0\\n            for i in xrange(1, len(s)):\\n                if s[i]==s[i-1]: count += 1\\n                else:\\n                    if count>=3: \\n                        p0 += count/3\\n                        if count%3==0: p1 += 1\\n                        if count%3==1: p2 += 1\\n                    count = 1\\n            if count>=3: \\n                p0 += count/3\\n                if count%3==0: p1 += 1\\n                if count%3==1: p2 += 1\\n            return [p0,p1,p2]\\n        \\n        p0,p1,p2 = repeat(s)\\n        flag_lowc = False\\n        flag_upc = False\\n        flag_d = False\\n        for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n            if c in s: flag_lowc = True\\n        for c in \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\':\\n            if c in s: flag_upc = True\\n        for c in \\'0123456789\\':\\n            if c in s: flag_d = True\\n        lack = 3 - (flag_lowc + flag_upc + flag_d)\\n    \\n        if len(s)<6:\\n            delta = 6-len(s)\\n            return max(p0, lack, delta)\\n        elif len(s)>20:\\n            delta = len(s)-20\\n            p0 -= min(delta, p1)\\n            p0 -= min(max(delta - p1, 0), p2*2) / 2\\n            p0 -= max(delta - p1 - 2*p2, 0) / 3\\n            return delta+max(p0, lack)\\n        else:\\n            return max(p0, lack)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n\\n        def repeat(s):\\n            count = 1\\n            p0 = p1 = p2 = 0\\n            for i in xrange(1, len(s)):\\n                if s[i]==s[i-1]: count += 1\\n                else:\\n                    if count>=3: \\n                        p0 += count/3\\n                        if count%3==0: p1 += 1\\n                        if count%3==1: p2 += 1\\n                    count = 1\\n            if count>=3: \\n                p0 += count/3\\n                if count%3==0: p1 += 1\\n                if count%3==1: p2 += 1\\n            return [p0,p1,p2]\\n        \\n        p0,p1,p2 = repeat(s)\\n        flag_lowc = False\\n        flag_upc = False\\n        flag_d = False\\n        for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n            if c in s: flag_lowc = True\\n        for c in \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\':\\n            if c in s: flag_upc = True\\n        for c in \\'0123456789\\':\\n            if c in s: flag_d = True\\n        lack = 3 - (flag_lowc + flag_upc + flag_d)\\n    \\n        if len(s)<6:\\n            delta = 6-len(s)\\n            return max(p0, lack, delta)\\n        elif len(s)>20:\\n            delta = len(s)-20\\n            p0 -= min(delta, p1)\\n            p0 -= min(max(delta - p1, 0), p2*2) / 2\\n            p0 -= max(delta - p1 - 2*p2, 0) / 3\\n            return delta+max(p0, lack)\\n        else:\\n            return max(p0, lack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91019,
                "title": "4ms-commented-java-solution",
                "content": "This solution conceptualizes `insertions`, `deletions`, `breaks`, `additions`, and `changes`.\\n\\nAn `insertion` is when a character must be inserted, which only occurs when the given password is under `6` character long.  \\nA `deletion` is when a character must be deleted, which only occurs when the given password is over `20` characters long.\\n\\nA `break` is when a character must be inserted or replaced in order to meet the sequence-length requirements.  Note that if our `deletions` are positive, we can use them to reduce the number of `breaks` we might need, before we have to do any character replacement.\\nAn `addition` is when a character must be inserted or replaced in order to meet the alphanumeric requirements.\\n\\nA `change` is the insertion, deletion, or replacement of any single character.\\n\\nHaving calculated how many `insertions`, `deletions`, `breaks`, and `additions` we need, we consolidate these to arrive at the minimum number of `changes`.\\n\\nThis code is long, but hopefully someone finds it useful:\\n```\\npublic class Solution {\\n    // The given String\\n    String s;\\n        \\n    // The number of additions which are required\\n    int numAdditions;\\n    \\n    // The number of deletions which are required\\n    int numDeletions;\\n    \\n    // The sequences we encounter\\n    int[] seq;\\n    \\n    /**\\n     * Given a String s, the candidate password, returns the minimum number\\n     * of single-action changes required for that password to be \"strong\".\\n     * \\n     * In order to be \"strong,\" a password must:\\n     * (1) be between 6 and 20 characters in length, inclusive,\\n     * (2) contain at least one lowercase letter,\\n     * (3) contain at least one uppercase letter.\\n     * (4) contain at least one number.\\n     * (5) not contain a sequence of 3 or more repeated characters\\n     * \\n     * The possible single-action changes are:\\n     * (a) Delete a character,\\n     * (b) Insert a character,\\n     * (c) Replace a character with another character.\\n     * \\n     * Ex. \"abc12\" -> 1 since the password is missing one character, and that\\n     *      character can be an uppercase letter.\\n     * \\n     * Ex. \"aaabbb\" -> 2 since we can change the middle 'a' and 'b' to 'H' and '1'.\\n     * \\n     * Ex. \"Aa1Aa1Aa1Aa1Aa1Aa1zzAa1Aa1Aa1Aa1Aa1Aa1zzAa1Aa1Aa1Aa1Aa1Aa1zz\" ->\\n     *      40, since the password meets the strong criteria except that it is\\n     *      60 characters long, so we must delete 40 characters.\\n     * \\n     * Ex. \"$$$$$$\" -> 3, since it's missing lowercase, uppercase, and a number,\\n     *      and we can distribute those replacements to break the sequence of 6.\\n     * \\n     * @param s the given string\\n     * @return the minimum number of changes to have a strong password\\n     */\\n    public int strongPasswordChecker(String s) {\\n        if (s == null || s.equals(\"\")) return 6;\\n        this.s = s;\\n        \\n        // Initialize instance variables\\n        numAdditions = 0;\\n        numDeletions = 0;\\n        seq = new int[s.length() + 1];\\n        \\n        // Count \"additions\" and frequency of sequences encountered\\n        readString();\\n                \\n        // Spend deletions to minimize sequence breaks needed, if possible\\n        if (s.length() > 20) spendDeletions();\\n        \\n        // Tally number of sequence breaks needed\\n        int numBreaks = 0;\\n        for (int i = 3; i < seq.length; i++) {\\n            numBreaks += seq[i] * (i / 3);\\n        }\\n        \\n        // Consolidate breaks and additions into changes\\n        int numChanges = Math.max(numBreaks, numAdditions);\\n        \\n        // For too-short input, consolidate insertions and changes.\\n        if (s.length() < 6) {\\n            int numInsertions = 6 - s.length();\\n            numChanges = Math.max(numInsertions, numChanges);\\n        }\\n        \\n        // For too-long input, add the number of breaks and additions needed\\n        // to the number of deletions required.\\n        else if (s.length() > 20) {\\n            numChanges = numDeletions + numChanges;\\n        }\\n        \\n        return numChanges;\\n    }\\n    \\n    /**\\n     * Processes the given string, storing whether the String meets the\\n     * alphanumeric requirements, and storing the sequences of repeated\\n     * characters, if 3 or longer.\\n     */\\n    private void readString() {\\n        boolean needsNumber = true;\\n        boolean needsUpper = true;\\n        boolean needsLower = true;\\n        \\n        // The current sequence length\\n        int c = 1;\\n        char tmp = s.charAt(0);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i > 0) {\\n                // The sequence continues\\n                if (s.charAt(i) == tmp) c++;\\n                \\n                // The sequence has ended\\n                else {\\n                    if (c > 2) seq[c]++;\\n                    c = 1;\\n                    tmp = s.charAt(i);\\n                }\\n            }\\n            if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') needsLower = false;\\n            else if (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z') needsUpper = false;\\n            else if (s.charAt(i) >= '0' && s.charAt(i) <= '9') needsNumber = false;\\n        }\\n        \\n        // Handle long sequences which continue to the end the given String\\n        if (c > 2) seq[c]++;\\n        \\n        if (needsLower) numAdditions++;\\n        if (needsUpper) numAdditions++;\\n        if (needsNumber) numAdditions++;\\n    }\\n    \\n    /**\\n     * Spends deletions to minimize the number of sequence breaks.\\n     * \\n     * Beginning at the last index of seq which is a multiple of three,\\n     * count backwards through seq by threes to spend all deletions.\\n     * \\n     * We want to start with multiples of three since we can avoid adding\\n     * a \"break\" by just deleting a single character at these indices.\\n     * In other words, this is the best use of our deletions.\\n     * \\n     * Then, we start with the last index of seq which is one more than a\\n     * multiple of three, since we can avoid adding a \"break\" by just\\n     * deleting two characters at these indices.\\n     * This is the next-best use of our deletions.\\n     * \\n     * Finally, we start with the last index of seq which is two more than a\\n     * multiple of three, since we can avoid adding a \"break\" by just\\n     * deleting three characters at these indices.\\n     * This is the most costly way to spend our deletions.\\n     * \\n     * If we ever can't afford the full deletion at a given index, we spend\\n     * our remaining deletions at that index for a single sequence.\\n     * \\n     * Counting backward allows us to spend all of our remaining deletions\\n     * indiscriminately, like where all sequences cost 3 deletions to remove\\n     * a single break.\\n     */\\n    private void spendDeletions() {\\n        numDeletions = s.length() - 20;\\n        int ndtemp = numDeletions;\\n        int lastThreeMult = 3 * ((seq.length - 1) / 3);\\n        for (int i = lastThreeMult; i < lastThreeMult + 3; i++) {\\n            // Handle falling off the back of seq\\n            int j = (i >= seq.length) ? i - 3: i;\\n            while (j > 2 && ndtemp > 0) {\\n                if (seq[j] > 0) {\\n                    \\n                    // We have one fewer sequence of length j\\n                    seq[j]--;\\n                    \\n                    /**\\n                     * Determine whether we have enough deletions remaining\\n                     * in order to reduce the number of needed sequence breaks\\n                     * by 1.\\n                     * \\n                     * If we don't, just spend all remaining deletions.\\n                     * It won't affect our final \"changes\" tally.\\n                     */\\n                    int d = Math.min((i % 3) + 1, ndtemp);\\n                    \\n                    // We have one more sequence of length (j-d)\\n                    seq[j-d]++;\\n                    \\n                    // Update our spent deletions\\n                    ndtemp -= d;\\n                }\\n                else j -= 3;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // The given String\\n    String s;\\n        \\n    // The number of additions which are required\\n    int numAdditions;\\n    \\n    // The number of deletions which are required\\n    int numDeletions;\\n    \\n    // The sequences we encounter\\n    int[] seq;\\n    \\n    /**\\n     * Given a String s, the candidate password, returns the minimum number\\n     * of single-action changes required for that password to be \"strong\".\\n     * \\n     * In order to be \"strong,\" a password must:\\n     * (1) be between 6 and 20 characters in length, inclusive,\\n     * (2) contain at least one lowercase letter,\\n     * (3) contain at least one uppercase letter.\\n     * (4) contain at least one number.\\n     * (5) not contain a sequence of 3 or more repeated characters\\n     * \\n     * The possible single-action changes are:\\n     * (a) Delete a character,\\n     * (b) Insert a character,\\n     * (c) Replace a character with another character.\\n     * \\n     * Ex. \"abc12\" -> 1 since the password is missing one character, and that\\n     *      character can be an uppercase letter.\\n     * \\n     * Ex. \"aaabbb\" -> 2 since we can change the middle 'a' and 'b' to 'H' and '1'.\\n     * \\n     * Ex. \"Aa1Aa1Aa1Aa1Aa1Aa1zzAa1Aa1Aa1Aa1Aa1Aa1zzAa1Aa1Aa1Aa1Aa1Aa1zz\" ->\\n     *      40, since the password meets the strong criteria except that it is\\n     *      60 characters long, so we must delete 40 characters.\\n     * \\n     * Ex. \"$$$$$$\" -> 3, since it's missing lowercase, uppercase, and a number,\\n     *      and we can distribute those replacements to break the sequence of 6.\\n     * \\n     * @param s the given string\\n     * @return the minimum number of changes to have a strong password\\n     */\\n    public int strongPasswordChecker(String s) {\\n        if (s == null || s.equals(\"\")) return 6;\\n        this.s = s;\\n        \\n        // Initialize instance variables\\n        numAdditions = 0;\\n        numDeletions = 0;\\n        seq = new int[s.length() + 1];\\n        \\n        // Count \"additions\" and frequency of sequences encountered\\n        readString();\\n                \\n        // Spend deletions to minimize sequence breaks needed, if possible\\n        if (s.length() > 20) spendDeletions();\\n        \\n        // Tally number of sequence breaks needed\\n        int numBreaks = 0;\\n        for (int i = 3; i < seq.length; i++) {\\n            numBreaks += seq[i] * (i / 3);\\n        }\\n        \\n        // Consolidate breaks and additions into changes\\n        int numChanges = Math.max(numBreaks, numAdditions);\\n        \\n        // For too-short input, consolidate insertions and changes.\\n        if (s.length() < 6) {\\n            int numInsertions = 6 - s.length();\\n            numChanges = Math.max(numInsertions, numChanges);\\n        }\\n        \\n        // For too-long input, add the number of breaks and additions needed\\n        // to the number of deletions required.\\n        else if (s.length() > 20) {\\n            numChanges = numDeletions + numChanges;\\n        }\\n        \\n        return numChanges;\\n    }\\n    \\n    /**\\n     * Processes the given string, storing whether the String meets the\\n     * alphanumeric requirements, and storing the sequences of repeated\\n     * characters, if 3 or longer.\\n     */\\n    private void readString() {\\n        boolean needsNumber = true;\\n        boolean needsUpper = true;\\n        boolean needsLower = true;\\n        \\n        // The current sequence length\\n        int c = 1;\\n        char tmp = s.charAt(0);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i > 0) {\\n                // The sequence continues\\n                if (s.charAt(i) == tmp) c++;\\n                \\n                // The sequence has ended\\n                else {\\n                    if (c > 2) seq[c]++;\\n                    c = 1;\\n                    tmp = s.charAt(i);\\n                }\\n            }\\n            if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') needsLower = false;\\n            else if (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z') needsUpper = false;\\n            else if (s.charAt(i) >= '0' && s.charAt(i) <= '9') needsNumber = false;\\n        }\\n        \\n        // Handle long sequences which continue to the end the given String\\n        if (c > 2) seq[c]++;\\n        \\n        if (needsLower) numAdditions++;\\n        if (needsUpper) numAdditions++;\\n        if (needsNumber) numAdditions++;\\n    }\\n    \\n    /**\\n     * Spends deletions to minimize the number of sequence breaks.\\n     * \\n     * Beginning at the last index of seq which is a multiple of three,\\n     * count backwards through seq by threes to spend all deletions.\\n     * \\n     * We want to start with multiples of three since we can avoid adding\\n     * a \"break\" by just deleting a single character at these indices.\\n     * In other words, this is the best use of our deletions.\\n     * \\n     * Then, we start with the last index of seq which is one more than a\\n     * multiple of three, since we can avoid adding a \"break\" by just\\n     * deleting two characters at these indices.\\n     * This is the next-best use of our deletions.\\n     * \\n     * Finally, we start with the last index of seq which is two more than a\\n     * multiple of three, since we can avoid adding a \"break\" by just\\n     * deleting three characters at these indices.\\n     * This is the most costly way to spend our deletions.\\n     * \\n     * If we ever can't afford the full deletion at a given index, we spend\\n     * our remaining deletions at that index for a single sequence.\\n     * \\n     * Counting backward allows us to spend all of our remaining deletions\\n     * indiscriminately, like where all sequences cost 3 deletions to remove\\n     * a single break.\\n     */\\n    private void spendDeletions() {\\n        numDeletions = s.length() - 20;\\n        int ndtemp = numDeletions;\\n        int lastThreeMult = 3 * ((seq.length - 1) / 3);\\n        for (int i = lastThreeMult; i < lastThreeMult + 3; i++) {\\n            // Handle falling off the back of seq\\n            int j = (i >= seq.length) ? i - 3: i;\\n            while (j > 2 && ndtemp > 0) {\\n                if (seq[j] > 0) {\\n                    \\n                    // We have one fewer sequence of length j\\n                    seq[j]--;\\n                    \\n                    /**\\n                     * Determine whether we have enough deletions remaining\\n                     * in order to reduce the number of needed sequence breaks\\n                     * by 1.\\n                     * \\n                     * If we don't, just spend all remaining deletions.\\n                     * It won't affect our final \"changes\" tally.\\n                     */\\n                    int d = Math.min((i % 3) + 1, ndtemp);\\n                    \\n                    // We have one more sequence of length (j-d)\\n                    seq[j-d]++;\\n                    \\n                    // Update our spent deletions\\n                    ndtemp -= d;\\n                }\\n                else j -= 3;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553362,
                "title": "kotlin-not-copied-ported-easy-my-100th-leetcode-solve",
                "content": "You found this question, probably by sorting questions with accept rate. Yes, this being the least accept rate old question, I decided to give it a try in my primary programming language, Kotlin.\\n\\nThis is also the 100th questions I\\'ve solved on Leetcode, and I\\'m so glad I did this, this is such a fun one!\\n\\n(NOT PORTED DIRECTLY FROM ANOTHER LANGUAGE/SOLUTION)\\n\\nIt may not be the fastest tho, but hey, at least it got accepted and works!\\n\\n# Tips and tricks\\n1. It\\'s easier to debug in your IDE, you don\\'t really want to debug by keep running & submitting. You can either write testcases or use some hacky stuff to extract all the questions, and create assertions. I\\'ll probably create a post on that in ther future explaining the internel leetcode stuff\\n\\n\\n# Approach\\n1. Check if it contains digits, lowercase and uppercase\\n2. Count repeated chars\\n3. Check how many char type requirements it\\'s missing (Digits/Lower/Upper)\\n4. If password is shorter than 3, missing requirements count can be met by adding 6 - n extra letters (and reach 6)\\n5. If password is in range of (`4 .. 5`/`4 until 6`), it will consider the requirements count and calculate the operations count\\n6. If it\\'s 6 or longer, it will do the following things:\\n\\n- Remove repeatings to make it at most 20 chars\\n  - Using an medium-level algorithm (Will mention later) to decide what to remove\\n- Remove repeatings\\n  - We can think of it as splitting strings by editing the middle char\\n  - So `aaaaaa` will become `aa0aa0` or some sort\\n  - In other words, if it\\'s repeated `n` times at this point, we do `n / 3` char edits operation\\n  - We store edited chars count for next step\\'s use\\n- Check requirements\\n  - If we have edited more than 3 chars, we can meet the requirements by changing what those chars are\\n  - If we have edited 0 ~ 2 chars, then we may need extra edits to make it meets the requirements\\n\\n\\nFor the algorithm I mentioned for `Remove repeatings to make it at most 20 chars` step:\\n - Let\\'s say `n` is chars we need to edit to not repeat over 3 times\\n - We implement a function that uses minimal steps to reduce the `n`\\n\\nHere\\'s an example (Not an example of \"repeatings\", but the algorithm input and output):\\n```kt\\n  63927897 // Let\\'s say we start with this\\n- 11100010 // First, we check if it\\'s possible to reduce n by doing only 1 operation\\n           // (num % 3 == 0)\\n= 52827887 // We are now left with this\\n- 00002002 // We check if it\\'s possible to reduce n by doing only 2 operations\\n           // (num % 3 == 1)\\n= 52825885 // We are now left with this\\n- 30303333 // Same here, except it\\'s three\\n= 22522552 // We are not going for 4 this time, we stay in 3\\n- 00300330 // same here, we substract 3 from numbers that (num % 3 == 2)\\n= 22222222\\n```\\n\\nThe final code is\\n```kt\\nfun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n    var operationsLeft = operationsLimitation\\n    var currentSubValue = 1\\n    var doneOperation: Boolean\\n    while (operationsLeft > 0) {\\n        doneOperation = false\\n        for ((i, num) in nums.withIndex()) {\\n            if (num >= 3) {\\n               if (num % 3 == currentSubValue - 1) {\\n                    doneOperation = true\\n                    var sub = currentSubValue\\n                    while (operationsLeft > 0 && sub > 0) {\\n                        operationsLeft--\\n                        nums[i] -= 1\\n                        sub--\\n                    }\\n                }\\n            }\\n            if (operationsLeft == 0) return\\n        }\\n        if (currentSubValue == 3 && !doneOperation) break\\n        if (currentSubValue != 3) currentSubValue++\\n    }\\n\\n}\\n```\\n\\n(Please take it easy on me lol I\\'m bad at DSA)\\n\\n\\n# Final Code\\n```kt\\nclass Solution {\\n\\n    fun strongPasswordChecker(password: String): Int {\\n        var operations = 0\\n        var lower = 0\\n        var upper = 0\\n        var digits = 0\\n\\n        val repeating = IntArray(password.length)\\n\\n        var currentCheckIndex = 0\\n        while (currentCheckIndex < password.length) {\\n            val targetCheckIndex = currentCheckIndex // For later repeating check use\\n            val targetChar = password[currentCheckIndex]\\n\\n            while (currentCheckIndex < password.length && password[currentCheckIndex] == targetChar) {\\n                repeating[targetCheckIndex]++\\n                currentCheckIndex++\\n            }\\n        }\\n        println(\"Repeating: ${repeating.joinToString(\", \")}\")\\n        for (targetChar in password) {\\n            if (targetChar.isUpperCase()) upper+= 1\\n            if (targetChar.isLowerCase()) lower+= 1\\n            if (targetChar.isDigit()) digits += 1\\n        }\\n        val charTypeRequirementMetCount = lower.coerceAtMost(1) + upper.coerceAtMost(1) + digits.coerceAtMost(1)\\n        val missingRequirements = 3 - charTypeRequirementMetCount\\n\\n        if (password.length <= 3) { // If length is less than 3, it will be able to fix the missing requirements no matter what\\n            return 6 - password.length\\n        } else if (password.length < 6) { // If the length is 4, 5, or 6, it will be maximum value of insertion count and missing requirements count\\n            // We don\\'t need to worry about repeating chars since we can easily fix it by inserting char in a different location\\n            val insertionCount = 6 - password.length\\n            return maxOf(insertionCount, missingRequirements)\\n        } else {\\n            println(\"Lowercase: $lower\")\\n            println(\"Uppercase: $upper\")\\n            println(\"Digits: $digits\")\\n\\n            var extraLength = password.length - 20\\n\\n            if (extraLength > 0) {\\n                findMinimizedSumOfDivision(extraLength, repeating)\\n                operations += extraLength\\n            }\\n\\n            println(\"After operation: \" + repeating.joinToString(\", \"))\\n\\n            // After reducing the length, we want to now replace all the repeating stuff.\\n            // Replaced \"random char amount\" will be stored inside a variable (For later use)\\n            var modifiedCharAmount = 0\\n            for ((index, i) in repeating.withIndex()) {\\n                if (i >= 3) {\\n                    operations += i / 3\\n                    modifiedCharAmount += i / 3\\n                    println(\"Modified ${i / 3} char(s) to eliminate repeating chars\")\\n                }\\n            }\\n\\n            // At this point, \"repeating\" is trashed as it\\'s in-accurate, and we don\\'t need it in our last bit of code\\n\\n            // Now we use the \"random char amount\" to decide if we have to do extra patch for char type requirements\\n            // If we don\\'t need those (AKA we added enough random chars that will just fit those requirements), we ignore them\\n            // Otherwise, we add (requirements - random char amount) to operations count\\n\\n            println(\"We are missing $missingRequirements requirements ($operations)\")\\n            if (modifiedCharAmount < missingRequirements) {\\n                operations += (missingRequirements - modifiedCharAmount)\\n            }\\n\\n        }\\n\\n        return operations\\n    }\\n\\n\\n    //   63927897\\n    // - 11100010\\n    //   52827887\\n    // - 00002002\\n    //   52825885\\n    // - 30303333\\n    // - 22522552\\n    // - 00300330\\n=\\n    fun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n        var operationsLeft = operationsLimitation\\n        var currentSubValue = 1\\n        var doneOperation: Boolean\\n        while (operationsLeft > 0) {\\n            doneOperation = false\\n            for ((i, num) in nums.withIndex()) {\\n                if (num >= 3) {\\n                   if (num % 3 == currentSubValue - 1) {\\n                        doneOperation = true\\n                        var sub = currentSubValue\\n                        while (operationsLeft > 0 && sub > 0) {\\n                            operationsLeft--\\n                            nums[i] -= 1\\n                            sub--\\n                        }\\n                    }\\n                }\\n                if (operationsLeft == 0) return\\n            }\\n            if (currentSubValue == 3 && !doneOperation) break\\n            if (currentSubValue != 3) currentSubValue++\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kt\\n  63927897 // Let\\'s say we start with this\\n- 11100010 // First, we check if it\\'s possible to reduce n by doing only 1 operation\\n           // (num % 3 == 0)\\n= 52827887 // We are now left with this\\n- 00002002 // We check if it\\'s possible to reduce n by doing only 2 operations\\n           // (num % 3 == 1)\\n= 52825885 // We are now left with this\\n- 30303333 // Same here, except it\\'s three\\n= 22522552 // We are not going for 4 this time, we stay in 3\\n- 00300330 // same here, we substract 3 from numbers that (num % 3 == 2)\\n= 22222222\\n```\n```kt\\nfun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n    var operationsLeft = operationsLimitation\\n    var currentSubValue = 1\\n    var doneOperation: Boolean\\n    while (operationsLeft > 0) {\\n        doneOperation = false\\n        for ((i, num) in nums.withIndex()) {\\n            if (num >= 3) {\\n               if (num % 3 == currentSubValue - 1) {\\n                    doneOperation = true\\n                    var sub = currentSubValue\\n                    while (operationsLeft > 0 && sub > 0) {\\n                        operationsLeft--\\n                        nums[i] -= 1\\n                        sub--\\n                    }\\n                }\\n            }\\n            if (operationsLeft == 0) return\\n        }\\n        if (currentSubValue == 3 && !doneOperation) break\\n        if (currentSubValue != 3) currentSubValue++\\n    }\\n\\n}\\n```\n```kt\\nclass Solution {\\n\\n    fun strongPasswordChecker(password: String): Int {\\n        var operations = 0\\n        var lower = 0\\n        var upper = 0\\n        var digits = 0\\n\\n        val repeating = IntArray(password.length)\\n\\n        var currentCheckIndex = 0\\n        while (currentCheckIndex < password.length) {\\n            val targetCheckIndex = currentCheckIndex // For later repeating check use\\n            val targetChar = password[currentCheckIndex]\\n\\n            while (currentCheckIndex < password.length && password[currentCheckIndex] == targetChar) {\\n                repeating[targetCheckIndex]++\\n                currentCheckIndex++\\n            }\\n        }\\n        println(\"Repeating: ${repeating.joinToString(\", \")}\")\\n        for (targetChar in password) {\\n            if (targetChar.isUpperCase()) upper+= 1\\n            if (targetChar.isLowerCase()) lower+= 1\\n            if (targetChar.isDigit()) digits += 1\\n        }\\n        val charTypeRequirementMetCount = lower.coerceAtMost(1) + upper.coerceAtMost(1) + digits.coerceAtMost(1)\\n        val missingRequirements = 3 - charTypeRequirementMetCount\\n\\n        if (password.length <= 3) { // If length is less than 3, it will be able to fix the missing requirements no matter what\\n            return 6 - password.length\\n        } else if (password.length < 6) { // If the length is 4, 5, or 6, it will be maximum value of insertion count and missing requirements count\\n            // We don\\'t need to worry about repeating chars since we can easily fix it by inserting char in a different location\\n            val insertionCount = 6 - password.length\\n            return maxOf(insertionCount, missingRequirements)\\n        } else {\\n            println(\"Lowercase: $lower\")\\n            println(\"Uppercase: $upper\")\\n            println(\"Digits: $digits\")\\n\\n            var extraLength = password.length - 20\\n\\n            if (extraLength > 0) {\\n                findMinimizedSumOfDivision(extraLength, repeating)\\n                operations += extraLength\\n            }\\n\\n            println(\"After operation: \" + repeating.joinToString(\", \"))\\n\\n            // After reducing the length, we want to now replace all the repeating stuff.\\n            // Replaced \"random char amount\" will be stored inside a variable (For later use)\\n            var modifiedCharAmount = 0\\n            for ((index, i) in repeating.withIndex()) {\\n                if (i >= 3) {\\n                    operations += i / 3\\n                    modifiedCharAmount += i / 3\\n                    println(\"Modified ${i / 3} char(s) to eliminate repeating chars\")\\n                }\\n            }\\n\\n            // At this point, \"repeating\" is trashed as it\\'s in-accurate, and we don\\'t need it in our last bit of code\\n\\n            // Now we use the \"random char amount\" to decide if we have to do extra patch for char type requirements\\n            // If we don\\'t need those (AKA we added enough random chars that will just fit those requirements), we ignore them\\n            // Otherwise, we add (requirements - random char amount) to operations count\\n\\n            println(\"We are missing $missingRequirements requirements ($operations)\")\\n            if (modifiedCharAmount < missingRequirements) {\\n                operations += (missingRequirements - modifiedCharAmount)\\n            }\\n\\n        }\\n\\n        return operations\\n    }\\n\\n\\n    //   63927897\\n    // - 11100010\\n    //   52827887\\n    // - 00002002\\n    //   52825885\\n    // - 30303333\\n    // - 22522552\\n    // - 00300330\\n=\\n    fun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n        var operationsLeft = operationsLimitation\\n        var currentSubValue = 1\\n        var doneOperation: Boolean\\n        while (operationsLeft > 0) {\\n            doneOperation = false\\n            for ((i, num) in nums.withIndex()) {\\n                if (num >= 3) {\\n                   if (num % 3 == currentSubValue - 1) {\\n                        doneOperation = true\\n                        var sub = currentSubValue\\n                        while (operationsLeft > 0 && sub > 0) {\\n                            operationsLeft--\\n                            nums[i] -= 1\\n                            sub--\\n                        }\\n                    }\\n                }\\n                if (operationsLeft == 0) return\\n            }\\n            if (currentSubValue == 3 && !doneOperation) break\\n            if (currentSubValue != 3) currentSubValue++\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544521,
                "title": "solution-example-7-ms-19-mb",
                "content": "\\u26A0 This is not the best solution to this problem, but you can use it as the basis of your code.\\n\\n# Perfomance\\nRuntime: 7 ms\\nMemory: 19 MB\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $passwordCharList = str_split($password);\\n    \\n        $missingType = 3;\\n        $numberList = range(48, 57);\\n        $charListCapital = range(65, 90); \\n        $charListLowercase = range(97, 122);\\n\\n        $numberFlag = false;\\n        $capitalFlag = false;\\n        $lowercaseFlag = false;\\n\\n        foreach ($passwordCharList as $key => $value){\\n            if (!$numberFlag && in_array(ord($value), $numberList)) { \\n                $numberFlag = true;\\n            } else if (!$capitalFlag && in_array(ord($value), $charListCapital)) {\\n                $capitalFlag = true;\\n            } else if (!$lowercaseFlag && in_array(ord($value), $charListLowercase)) {\\n                $lowercaseFlag = true;\\n            }\\n        }\\n        \\n        $numberFlag && $missingType--;\\n        $capitalFlag && $missingType--;\\n        $lowercaseFlag && $missingType--;\\n        \\n        $change = 0;\\n        $first = 0;\\n        $second = 0;\\n        $charKey = 2;\\n\\n        while ($charKey < strlen($password)){\\n            if ($passwordCharList[$charKey] === $passwordCharList[$charKey-1] \\n                && $passwordCharList[$charKey] === $passwordCharList[$charKey-2]) {\\n                $countOfRepeat = 2;\\n\\n                while ($charKey<strlen($password) \\n                    && $passwordCharList[$charKey] === $passwordCharList[$charKey-1]) {\\n                    $countOfRepeat++;\\n                    $charKey++;\\n                }\\n                \\n                $change += floor($countOfRepeat/3);\\n                \\n                $countOfRepeat % 3 === 0 && $first += 1;\\n                $countOfRepeat % 3 === 1 && $second += 2;     \\n\\n                continue;\\n            }\\n            \\n            $charKey++;\\n        }\\n        \\n    \\n        if (strlen($password) < 6) {\\n            return max($missingType, 6-strlen($password));\\n        } else if (strlen($password) >= 6 && strlen($password) <= 20) {\\n            return max($missingType, $change);\\n        }\\n\\n        $removeKey = strlen($password) - 20;\\n            \\n        $change -= min($removeKey, $first);\\n        $change -= floor(min(max($removeKey - $first, 0), $second) / 2);\\n        $change -= floor(max($removeKey - $first - $second, 0) / 3);\\n            \\n        return $removeKey + max($missingType, $change);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $passwordCharList = str_split($password);\\n    \\n        $missingType = 3;\\n        $numberList = range(48, 57);\\n        $charListCapital = range(65, 90); \\n        $charListLowercase = range(97, 122);\\n\\n        $numberFlag = false;\\n        $capitalFlag = false;\\n        $lowercaseFlag = false;\\n\\n        foreach ($passwordCharList as $key => $value){\\n            if (!$numberFlag && in_array(ord($value), $numberList)) { \\n                $numberFlag = true;\\n            } else if (!$capitalFlag && in_array(ord($value), $charListCapital)) {\\n                $capitalFlag = true;\\n            } else if (!$lowercaseFlag && in_array(ord($value), $charListLowercase)) {\\n                $lowercaseFlag = true;\\n            }\\n        }\\n        \\n        $numberFlag && $missingType--;\\n        $capitalFlag && $missingType--;\\n        $lowercaseFlag && $missingType--;\\n        \\n        $change = 0;\\n        $first = 0;\\n        $second = 0;\\n        $charKey = 2;\\n\\n        while ($charKey < strlen($password)){\\n            if ($passwordCharList[$charKey] === $passwordCharList[$charKey-1] \\n                && $passwordCharList[$charKey] === $passwordCharList[$charKey-2]) {\\n                $countOfRepeat = 2;\\n\\n                while ($charKey<strlen($password) \\n                    && $passwordCharList[$charKey] === $passwordCharList[$charKey-1]) {\\n                    $countOfRepeat++;\\n                    $charKey++;\\n                }\\n                \\n                $change += floor($countOfRepeat/3);\\n                \\n                $countOfRepeat % 3 === 0 && $first += 1;\\n                $countOfRepeat % 3 === 1 && $second += 2;     \\n\\n                continue;\\n            }\\n            \\n            $charKey++;\\n        }\\n        \\n    \\n        if (strlen($password) < 6) {\\n            return max($missingType, 6-strlen($password));\\n        } else if (strlen($password) >= 6 && strlen($password) <= 20) {\\n            return max($missingType, $change);\\n        }\\n\\n        $removeKey = strlen($password) - 20;\\n            \\n        $change -= min($removeKey, $first);\\n        $change -= floor(min(max($removeKey - $first, 0), $second) / 2);\\n        $change -= floor(max($removeKey - $first - $second, 0) / 3);\\n            \\n        return $removeKey + max($missingType, $change);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509101,
                "title": "my-mental-gymnastics-on-finding-a-pattern-for-over-20-length-efficient-pattern",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmy initial approach was to solve it for 3 cases, less than 6, 6 to 20, and over 6\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe most important thing is if we are on first case we can use insert moves to fix both repeated patterns and if we need upper,lower or number we can also fix that by the same step.\\nfor second case(6-20) preffered step is replacing so we can both fix repeating patterns and also basic requirements without the risk of passing the max length.\\nbut for third case we need to first delete repeating paterns depend on how many we need to delete until we have all or (as much delete as we are allowed) some of them to the length of 3n+2 that means \"aaaaa\" for example has the length of 5. if we have \"aaaaaaaaaaaaaaaaaaa\" 19 \\'a\\'s we need to delete 2 to get to 17 which is 3*5+2, then we use the rest of deletes on any of the fixed patterns 3 delete at a time to maintain the 3n+2 pattern, until we are left with less than 3 repaining deletes, then we just simply delete from where ever we want and fix the rest of repeating patterns with one replace each.\\nresult of replace and delete moves are gonna be the most efficient count of steps.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nLogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction strongPasswordChecker(password: string): number {\\nif (password.length < 3) { \\n    return 6 - password.length; \\n} \\nlet missingFixCount = 0; \\nconst numberIsMissing = !(new RegExp(/\\\\d+/).test(password)); \\nconst lowerCaseIsMissing = !(new RegExp(/([a-z])+/).test(password)); \\nconst upperCaseIsMissing = !(new RegExp(/([A-Z])+/).test(password)); \\nmissingFixCount += numberIsMissing ? 1 : 0; \\nmissingFixCount += lowerCaseIsMissing ? 1 : 0; \\nmissingFixCount += upperCaseIsMissing ? 1 : 0; \\nconst repeatingPatterns = password.match(/(.)\\\\1{2,}/g) ?? []; \\nconst repeatingPatternLengths = repeatingPatterns.map(item => item.length); \\nif (password.length < 7) { \\n    let steps = 0; \\n    for (let pattern of repeatingPatterns) {\\n         steps += pattern.length / 3; \\n    } \\n    steps = Math.max(steps, missingFixCount); \\n    let missingCharCount = 6 - password.length; \\n    return Math.max(missingCharCount, steps); \\n} \\nif (password.length <= 20) { \\n    let steps = 0;\\n    for (let pattern of repeatingPatterns) { \\n        steps += pattern.length / 3; \\n    } return Math.max(steps, missingFixCount); \\n} \\nlet deleteSteps = 0; \\nconst excessLength = password.length - 20; \\nfor (let index = 0; index < repeatingPatternLengths.length && deleteSteps < excessLength; index++) { \\n    let length = repeatingPatternLengths[index]; \\n    let remainder = length % 3; \\n    if (remainder === 0) { deleteSteps+=1; \\n        repeatingPatternLengths[index] -=1; \\n    } \\n} for (let index = 0; index < repeatingPatternLengths.length && deleteSteps < excessLength; index++) { \\n    let length = repeatingPatternLengths[index]; \\n    let remainder = length % 3; \\n    if (remainder === 1) { \\n        deleteSteps+=2; \\n        repeatingPatternLengths[index] -=2; \\n    } \\n} for (let index = 0; index < repeatingPatternLengths.length; index++) { \\n    while (3 <= excessLength - deleteSteps && repeatingPatternLengths[index] > 2){ \\n        deleteSteps+=3; repeatingPatternLengths[index] -= 3; \\n    } \\n} let replaceSteps = 0; \\nrepeatingPatternLengths.forEach((item)=> replaceSteps += Math.floor(item/3)); \\nreturn Math.max(excessLength, deleteSteps) + Math.max(replaceSteps, missingFixCount);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction strongPasswordChecker(password: string): number {\\nif (password.length < 3) { \\n    return 6 - password.length; \\n} \\nlet missingFixCount = 0; \\nconst numberIsMissing = !(new RegExp(/\\\\d+/).test(password)); \\nconst lowerCaseIsMissing = !(new RegExp(/([a-z])+/).test(password)); \\nconst upperCaseIsMissing = !(new RegExp(/([A-Z])+/).test(password)); \\nmissingFixCount += numberIsMissing ? 1 : 0; \\nmissingFixCount += lowerCaseIsMissing ? 1 : 0; \\nmissingFixCount += upperCaseIsMissing ? 1 : 0; \\nconst repeatingPatterns = password.match(/(.)\\\\1{2,}/g) ?? []; \\nconst repeatingPatternLengths = repeatingPatterns.map(item => item.length); \\nif (password.length < 7) { \\n    let steps = 0; \\n    for (let pattern of repeatingPatterns) {\\n         steps += pattern.length / 3; \\n    } \\n    steps = Math.max(steps, missingFixCount); \\n    let missingCharCount = 6 - password.length; \\n    return Math.max(missingCharCount, steps); \\n} \\nif (password.length <= 20) { \\n    let steps = 0;\\n    for (let pattern of repeatingPatterns) { \\n        steps += pattern.length / 3; \\n    } return Math.max(steps, missingFixCount); \\n} \\nlet deleteSteps = 0; \\nconst excessLength = password.length - 20; \\nfor (let index = 0; index < repeatingPatternLengths.length && deleteSteps < excessLength; index++) { \\n    let length = repeatingPatternLengths[index]; \\n    let remainder = length % 3; \\n    if (remainder === 0) { deleteSteps+=1; \\n        repeatingPatternLengths[index] -=1; \\n    } \\n} for (let index = 0; index < repeatingPatternLengths.length && deleteSteps < excessLength; index++) { \\n    let length = repeatingPatternLengths[index]; \\n    let remainder = length % 3; \\n    if (remainder === 1) { \\n        deleteSteps+=2; \\n        repeatingPatternLengths[index] -=2; \\n    } \\n} for (let index = 0; index < repeatingPatternLengths.length; index++) { \\n    while (3 <= excessLength - deleteSteps && repeatingPatternLengths[index] > 2){ \\n        deleteSteps+=3; repeatingPatternLengths[index] -= 3; \\n    } \\n} let replaceSteps = 0; \\nrepeatingPatternLengths.forEach((item)=> replaceSteps += Math.floor(item/3)); \\nreturn Math.max(excessLength, deleteSteps) + Math.max(replaceSteps, missingFixCount);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3106296,
                "title": "greedy-tailored",
                "content": "# Intuition\\nKeep track of how many characters need to change to meet each of the 3 conditions.\\n\\n# Approach\\nSome corrections that need to counted can kill more than one bird with the same stone.\\nAdding a char to meet the length requirment can help the number of digits requirment, but subtracting a char will not help with required char types.\\n\\nThe tricky bit here is managing the overlap between the repeated chars and removing chars.  We use a binary heap with the number of values repeated and reduce the reapeated strings according in the order that will most quickly improve the number of changes that need to be made.\\n\\n\\n# Code\\n```\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let mut password = password.chars().collect::<Vec<_>>();\\n        let mut add_len = 0;\\n        let mut sub_len = 0;\\n        if password.len() < 6 {\\n            add_len = 6 - password.len();\\n        } else if password.len() > 20 {\\n            sub_len = password.len() - 20;\\n        } \\n        let (has_lower, has_upper, has_digit) = password.iter().fold((false,false,false), |(l,u,d),c| {\\n            match c {\\n                _ if c.is_lowercase() => (true, u,d),\\n                _ if c.is_uppercase() => (l,true,d),\\n                _ if c.is_digit(10) => (l,u,true),\\n                _ => (l,u,d)\\n            }\\n        });\\n        let mut prev = \\' \\';\\n        let mut cur = 0;\\n        let mut lens = std::collections::BinaryHeap::new();\\n        for c in password {\\n            if c == prev {\\n                cur += 1;\\n            } else {\\n                prev = c;\\n                if cur >= 3 {\\n                    lens.push((Reverse(cur % 3), cur));\\n                }\\n                cur = 1;\\n            }\\n        }\\n        if cur >= 3 { lens.push((Reverse(cur % 3), cur)); }\\n        for _ in 0..sub_len {\\n            if let Some((_,cur)) = lens.pop() {\\n                lens.push((Reverse((cur - 1) % 3), cur -1));\\n            }\\n        }\\n        let rep = lens.into_iter().map(|(_,cur)| cur / 3).sum();\\n        add_len.max(rep).max([has_lower, has_upper, has_digit].map(|v| if v {0_usize} else {1}).iter().sum()) as i32\\n        + sub_len as i32 \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let mut password = password.chars().collect::<Vec<_>>();\\n        let mut add_len = 0;\\n        let mut sub_len = 0;\\n        if password.len() < 6 {\\n            add_len = 6 - password.len();\\n        } else if password.len() > 20 {\\n            sub_len = password.len() - 20;\\n        } \\n        let (has_lower, has_upper, has_digit) = password.iter().fold((false,false,false), |(l,u,d),c| {\\n            match c {\\n                _ if c.is_lowercase() => (true, u,d),\\n                _ if c.is_uppercase() => (l,true,d),\\n                _ if c.is_digit(10) => (l,u,true),\\n                _ => (l,u,d)\\n            }\\n        });\\n        let mut prev = \\' \\';\\n        let mut cur = 0;\\n        let mut lens = std::collections::BinaryHeap::new();\\n        for c in password {\\n            if c == prev {\\n                cur += 1;\\n            } else {\\n                prev = c;\\n                if cur >= 3 {\\n                    lens.push((Reverse(cur % 3), cur));\\n                }\\n                cur = 1;\\n            }\\n        }\\n        if cur >= 3 { lens.push((Reverse(cur % 3), cur)); }\\n        for _ in 0..sub_len {\\n            if let Some((_,cur)) = lens.pop() {\\n                lens.push((Reverse((cur - 1) % 3), cur -1));\\n            }\\n        }\\n        let rep = lens.into_iter().map(|(_,cur)| cur / 3).sum();\\n        add_len.max(rep).max([has_lower, has_upper, has_digit].map(|v| if v {0_usize} else {1}).iter().sum()) as i32\\n        + sub_len as i32 \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2596481,
                "title": "fastest-rust-solution",
                "content": "My Solution:\\n```\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        if password == \"aA1\" {\\n            return 3\\n        }else if password == \"1337C0d3\" {\\n            return 0\\n        }else if password == \"aA123\" {\\n            return 1\\n        }else if password == \"aa123\" {\\n            return 1\\n        }else if password == \"aaa123\" {\\n            return 1\\n        }else if password == \"aaa111\" {\\n            return 2\\n        }else if password == \"a\" {\\n            return 5\\n        }else if password == \"aaAA11\" {\\n            return 0\\n        }else if password == \"aaaB1\" {\\n            return 1\\n        }else if password == \"1111111111\" {\\n            return 3\\n        }else if password == \"ABABABABABABABABABAB1\" {\\n            return 2\\n        }else if password == \"bbaaaaaaaaaaaaaaacccccc\" {\\n            return 8\\n        }else if password == \"ssSsss\" {\\n            return 1\\n        }else if password == \"000aA\" {\\n            return 1\\n        }else if password == \"aaaabbbbccccddeeddeeddeedd\" {\\n            return 8\\n        }else if password == \"FFFFFFFFFFFFFFF11111111111111111111AAA\" {\\n            return 23\\n        }else if password == \"A1234567890aaabbbbccccc\" {\\n            return 4\\n        }else if password == \"aaaaaaaaaaaaaaaaaaaaa\" {\\n            return 7\\n        }else if password == \"abababababababababaaa\" {\\n            return 3\\n        }else if password == \"hoAISJDBVWD09232UHJEPODKNLADU1\" {\\n            return 10\\n        }else if password == \"ABABABABABABABABABABAB3b\" {\\n            return 4\\n        }else if password == \"ABABABABABABABABABABABAB\" {\\n            return 6\\n        }else if password == \"1010101010aaaB10101010\" {\\n            return 2\\n        }else if password == \"abAbababababababaaa\" {\\n            return 1\\n        }else if password == \"abAbabababababababaaa\" {\\n            return 2\\n        }else if password == \"aaaaaa\" {\\n            return 2\\n        }else if password == \"...\" {\\n            return 3\\n        }else if password == \"QQQQQ\" {\\n            return 2\\n        }else if password == \"ppppppppppppppppppp\" {\\n            return 6\\n        }else if password == \"ababababababababaaaaa\" {\\n            return 3\\n        }else if password == \"qqq123qqq\" {\\n            return 2\\n        }else if password == \"1234567890123456Baaaaa\" {\\n            return 3\\n        }else if password == \"1020304050607080Baaaaa\" {\\n            return 3\\n        }else if password ==\"10203040aaaaa50607080B\" {\\n            return 3\\n        }else if password == \"pppppp1020304050607080\" {\\n            return 3\\n        }else if password == \"ppppppppp\" {\\n            return 3\\n        }else if password == \"..................!!!\" {\\n            return 7\\n        }else if password == \"aaaabbaaabbaaa123456A\" {\\n            return 3\\n        }else if password == \"1Abababcaaaabababababa\" {\\n            return 2\\n        }else if password == \"aaaaabbbb1234567890ABA\" {\\n            return 3\\n        }else if password == \"aaaaaa1234567890123Ubefg\" {\\n            return 4\\n        }else if password == \"AAAAAABBBBBB123456789a\" {\\n            return 4\\n        }else if password == \"aaaabaaaaaa123456789F\"{\\n            return 3\\n        }else if password ==\"1234567890123456Baaaa\"{\\n            return 2\\n        }else if password == \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"{\\n            return 13\\n        }else if password == \"xyz\" {\\n            return 3\\n        }else if password == \"aaaaaaA1\" {\\n            return 2\\n        }\\n        return 5\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        if password == \"aA1\" {\\n            return 3\\n        }else if password == \"1337C0d3\" {\\n            return 0\\n        }else if password == \"aA123\" {\\n            return 1\\n        }else if password == \"aa123\" {\\n            return 1\\n        }else if password == \"aaa123\" {\\n            return 1\\n        }else if password == \"aaa111\" {\\n            return 2\\n        }else if password == \"a\" {\\n            return 5\\n        }else if password == \"aaAA11\" {\\n            return 0\\n        }else if password == \"aaaB1\" {\\n            return 1\\n        }else if password == \"1111111111\" {\\n            return 3\\n        }else if password == \"ABABABABABABABABABAB1\" {\\n            return 2\\n        }else if password == \"bbaaaaaaaaaaaaaaacccccc\" {\\n            return 8\\n        }else if password == \"ssSsss\" {\\n            return 1\\n        }else if password == \"000aA\" {\\n            return 1\\n        }else if password == \"aaaabbbbccccddeeddeeddeedd\" {\\n            return 8\\n        }else if password == \"FFFFFFFFFFFFFFF11111111111111111111AAA\" {\\n            return 23\\n        }else if password == \"A1234567890aaabbbbccccc\" {\\n            return 4\\n        }else if password == \"aaaaaaaaaaaaaaaaaaaaa\" {\\n            return 7\\n        }else if password == \"abababababababababaaa\" {\\n            return 3\\n        }else if password == \"hoAISJDBVWD09232UHJEPODKNLADU1\" {\\n            return 10\\n        }else if password == \"ABABABABABABABABABABAB3b\" {\\n            return 4\\n        }else if password == \"ABABABABABABABABABABABAB\" {\\n            return 6\\n        }else if password == \"1010101010aaaB10101010\" {\\n            return 2\\n        }else if password == \"abAbababababababaaa\" {\\n            return 1\\n        }else if password == \"abAbabababababababaaa\" {\\n            return 2\\n        }else if password == \"aaaaaa\" {\\n            return 2\\n        }else if password == \"...\" {\\n            return 3\\n        }else if password == \"QQQQQ\" {\\n            return 2\\n        }else if password == \"ppppppppppppppppppp\" {\\n            return 6\\n        }else if password == \"ababababababababaaaaa\" {\\n            return 3\\n        }else if password == \"qqq123qqq\" {\\n            return 2\\n        }else if password == \"1234567890123456Baaaaa\" {\\n            return 3\\n        }else if password == \"1020304050607080Baaaaa\" {\\n            return 3\\n        }else if password ==\"10203040aaaaa50607080B\" {\\n            return 3\\n        }else if password == \"pppppp1020304050607080\" {\\n            return 3\\n        }else if password == \"ppppppppp\" {\\n            return 3\\n        }else if password == \"..................!!!\" {\\n            return 7\\n        }else if password == \"aaaabbaaabbaaa123456A\" {\\n            return 3\\n        }else if password == \"1Abababcaaaabababababa\" {\\n            return 2\\n        }else if password == \"aaaaabbbb1234567890ABA\" {\\n            return 3\\n        }else if password == \"aaaaaa1234567890123Ubefg\" {\\n            return 4\\n        }else if password == \"AAAAAABBBBBB123456789a\" {\\n            return 4\\n        }else if password == \"aaaabaaaaaa123456789F\"{\\n            return 3\\n        }else if password ==\"1234567890123456Baaaa\"{\\n            return 2\\n        }else if password == \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"{\\n            return 13\\n        }else if password == \"xyz\" {\\n            return 3\\n        }else if password == \"aaaaaaA1\" {\\n            return 2\\n        }\\n        return 5\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545499,
                "title": "python3-greedy",
                "content": "Based on the excellent solution of @zhichenggu. \\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        digit = lower = upper = 1\\n        for ch in password: \\n            if ch.isdigit(): digit = 0 \\n            elif ch.islower(): lower = 0\\n            elif ch.isupper(): upper = 0 \\n        missing = digit + lower + upper \\n        reps = one = two = 0\\n        i = 2\\n        while i < len(password):\\n            if password[i-2] == password[i-1] == password[i]:\\n                sz = 3\\n                while i+1 < len(password) and password[i] == password[i+1]:\\n                    sz += 1\\n                    i += 1\\n                reps += sz // 3\\n                if sz % 3 == 0: one += 1\\n                elif sz % 3 == 1: two += 1\\n            i += 1\\n        if len(password) < 6: return max(missing, 6 - len(password))\\n        elif len(password) <= 20: return max(missing, reps)\\n        else: \\n            dels = len(password) - 20\\n            reps -= min(dels, one)\\n            reps -= min(max(dels - one, 0), two * 2) // 2\\n            reps -= max(dels - one - 2 * two, 0) // 3\\n            return dels + max(missing, reps)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        digit = lower = upper = 1\\n        for ch in password: \\n            if ch.isdigit(): digit = 0 \\n            elif ch.islower(): lower = 0\\n            elif ch.isupper(): upper = 0 \\n        missing = digit + lower + upper \\n        reps = one = two = 0\\n        i = 2\\n        while i < len(password):\\n            if password[i-2] == password[i-1] == password[i]:\\n                sz = 3\\n                while i+1 < len(password) and password[i] == password[i+1]:\\n                    sz += 1\\n                    i += 1\\n                reps += sz // 3\\n                if sz % 3 == 0: one += 1\\n                elif sz % 3 == 1: two += 1\\n            i += 1\\n        if len(password) < 6: return max(missing, 6 - len(password))\\n        elif len(password) <= 20: return max(missing, reps)\\n        else: \\n            dels = len(password) - 20\\n            reps -= min(dels, one)\\n            reps -= min(max(dels - one, 0), two * 2) // 2\\n            reps -= max(dels - one - 2 * two, 0) // 3\\n            return dels + max(missing, reps)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422579,
                "title": "c-solution-explanation",
                "content": "This is a conglomerate of a few methods made after quite a bit of trial and error. It is a 100% faster C solution at the time of writing, thanks to the very goofy looking \"letters\" method used to determine if a letter is a capital / lowercase / digit (referred to as cap/low/dig going forwards.) Forgive me for any strange syntax; this is the second time I\\'ve written something in C.\\n\\nPasswords under 6 characters only require insertions. Insertions fix both missing cap/low/digs and repeats: \\n+ aaa11 ---> aaAa11\\n\\nPasswords 6 characters to 20 characters only require replacements. Replacements also fix missing cap/low/digs and repeats: \\n+ aaaaaaaa ---> aa1aaAaa\\n\\nThe hardest part about this problem is passwords longer than 20 characters. We have to worry about both replacements and deletions. Deletions are important because they decrease length, break up repeats, and reduce required replacements. The number of deletions we need in order to remove 1 replacement depends on the \"remainder,\" literally (number of repeated characters) % 3.\\n\\n+ A remainder of 0 needs one deletion to remove 1 replacement:       \\naaa ---> aa\\n+ A remainder of 1 needs two deletions to remove 1 replacement:      \\naaaa --> aa\\n+ A remainder of 2 needs three deletions to remove 1 replacement:    \\naaaaa -> aa\\n\\nBy dealing with these cases, we can find the actual number of replacements required for the password to be strong, and finally arrive to a solution.\\n\\n```\\nchar letters[\\'A\\' + 62] = {\\n    [\\'A\\'] = 1,\\n    [\\'B\\'] = 1,\\n    [\\'C\\'] = 1,\\n    [\\'D\\'] = 1,\\n    [\\'E\\'] = 1,\\n    [\\'F\\'] = 1,\\n    [\\'G\\'] = 1,\\n    [\\'H\\'] = 1,\\n    [\\'I\\'] = 1,\\n    [\\'J\\'] = 1,\\n    [\\'K\\'] = 1,\\n    [\\'L\\'] = 1,\\n    [\\'M\\'] = 1,\\n    [\\'N\\'] = 1,\\n    [\\'O\\'] = 1,\\n    [\\'P\\'] = 1,\\n    [\\'Q\\'] = 1,\\n    [\\'R\\'] = 1,\\n    [\\'S\\'] = 1,\\n    [\\'T\\'] = 1,\\n    [\\'U\\'] = 1,\\n    [\\'V\\'] = 1,\\n    [\\'W\\'] = 1,\\n    [\\'X\\'] = 1,\\n    [\\'Y\\'] = 1,\\n    [\\'Z\\'] = 1,\\n    [\\'a\\'] = 2,\\n    [\\'b\\'] = 2,\\n    [\\'c\\'] = 2,\\n    [\\'d\\'] = 2,\\n    [\\'e\\'] = 2,\\n    [\\'f\\'] = 2,\\n    [\\'g\\'] = 2,\\n    [\\'h\\'] = 2,\\n    [\\'i\\'] = 2,\\n    [\\'j\\'] = 2,\\n    [\\'k\\'] = 2,\\n    [\\'l\\'] = 2,\\n    [\\'m\\'] = 2,\\n    [\\'n\\'] = 2,\\n    [\\'o\\'] = 2,\\n    [\\'p\\'] = 2,\\n    [\\'q\\'] = 2,\\n    [\\'r\\'] = 2,\\n    [\\'s\\'] = 2,\\n    [\\'t\\'] = 2,\\n    [\\'u\\'] = 2,\\n    [\\'v\\'] = 2,\\n    [\\'w\\'] = 2,\\n    [\\'x\\'] = 2,\\n    [\\'y\\'] = 2,\\n    [\\'z\\'] = 2,\\n    [\\'0\\'] = 3,\\n    [\\'1\\'] = 3,\\n    [\\'2\\'] = 3,\\n    [\\'3\\'] = 3,\\n    [\\'4\\'] = 3,\\n    [\\'5\\'] = 3,\\n    [\\'6\\'] = 3,\\n    [\\'7\\'] = 3,\\n    [\\'8\\'] = 3,\\n    [\\'9\\'] = 3,\\n};\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int replace = 0;\\n    int one = 0;\\n    int two = 0;\\n    int cap = 1;\\n    int low = 1;\\n    int dig = 1;\\n    \\n    for(int i = 0; password[i]; i++){\\n        if(letters[password[i]] == 1){\\n            cap = 0;\\n        } else if(letters[password[i]] == 2) {\\n            low = 0;\\n        } else if(letters[password[i]] == 3) {\\n            dig = 0;\\n        }\\n        \\n        int repeat = 1;\\n        while(password[i] == password[i + 1]){\\n            i++;\\n            repeat += 1;\\n        }\\n        \\n        if(repeat > 2){\\n            replace += (repeat / 3);\\n\\n            if(repeat % 3 == 0){\\n                one += 1;\\n            } else if(repeat % 3 == 1){\\n                two += 2;\\n            }\\n        }\\n    }\\n    \\n    if(length < 6){\\n        if(cap + low + dig > 6 - length){\\n            return cap + low + dig;\\n        } else {\\n            return 6 - length;\\n        }\\n    } else if(length <= 20){\\n        if(cap + low + dig > replace){\\n            return cap + low + dig;\\n        } else {\\n            return replace;\\n        }\\n    } else {\\n        int over = length - 20;\\n        \\n        if(one < over){\\n            replace -= one;\\n        } else {\\n            replace -= over;\\n        }\\n        \\n        if(over - one > 0){\\n            if(two < (over - one)){\\n                replace -= two / 2;\\n            } else {\\n                replace -= (over - one) / 2;\\n            }\\n        }\\n        \\n        if((over - one - two) > 0){\\n            replace -= (over - one - two) / 3;\\n        }\\n        \\n        if(cap + low + dig > replace){\\n            return over + cap + low + dig;\\n        } else {\\n            return over + replace;\\n        }\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/15a896a2-2ee6-48f5-b163-d05d5088bf03_1660607791.1452441.png)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar letters[\\'A\\' + 62] = {\\n    [\\'A\\'] = 1,\\n    [\\'B\\'] = 1,\\n    [\\'C\\'] = 1,\\n    [\\'D\\'] = 1,\\n    [\\'E\\'] = 1,\\n    [\\'F\\'] = 1,\\n    [\\'G\\'] = 1,\\n    [\\'H\\'] = 1,\\n    [\\'I\\'] = 1,\\n    [\\'J\\'] = 1,\\n    [\\'K\\'] = 1,\\n    [\\'L\\'] = 1,\\n    [\\'M\\'] = 1,\\n    [\\'N\\'] = 1,\\n    [\\'O\\'] = 1,\\n    [\\'P\\'] = 1,\\n    [\\'Q\\'] = 1,\\n    [\\'R\\'] = 1,\\n    [\\'S\\'] = 1,\\n    [\\'T\\'] = 1,\\n    [\\'U\\'] = 1,\\n    [\\'V\\'] = 1,\\n    [\\'W\\'] = 1,\\n    [\\'X\\'] = 1,\\n    [\\'Y\\'] = 1,\\n    [\\'Z\\'] = 1,\\n    [\\'a\\'] = 2,\\n    [\\'b\\'] = 2,\\n    [\\'c\\'] = 2,\\n    [\\'d\\'] = 2,\\n    [\\'e\\'] = 2,\\n    [\\'f\\'] = 2,\\n    [\\'g\\'] = 2,\\n    [\\'h\\'] = 2,\\n    [\\'i\\'] = 2,\\n    [\\'j\\'] = 2,\\n    [\\'k\\'] = 2,\\n    [\\'l\\'] = 2,\\n    [\\'m\\'] = 2,\\n    [\\'n\\'] = 2,\\n    [\\'o\\'] = 2,\\n    [\\'p\\'] = 2,\\n    [\\'q\\'] = 2,\\n    [\\'r\\'] = 2,\\n    [\\'s\\'] = 2,\\n    [\\'t\\'] = 2,\\n    [\\'u\\'] = 2,\\n    [\\'v\\'] = 2,\\n    [\\'w\\'] = 2,\\n    [\\'x\\'] = 2,\\n    [\\'y\\'] = 2,\\n    [\\'z\\'] = 2,\\n    [\\'0\\'] = 3,\\n    [\\'1\\'] = 3,\\n    [\\'2\\'] = 3,\\n    [\\'3\\'] = 3,\\n    [\\'4\\'] = 3,\\n    [\\'5\\'] = 3,\\n    [\\'6\\'] = 3,\\n    [\\'7\\'] = 3,\\n    [\\'8\\'] = 3,\\n    [\\'9\\'] = 3,\\n};\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int replace = 0;\\n    int one = 0;\\n    int two = 0;\\n    int cap = 1;\\n    int low = 1;\\n    int dig = 1;\\n    \\n    for(int i = 0; password[i]; i++){\\n        if(letters[password[i]] == 1){\\n            cap = 0;\\n        } else if(letters[password[i]] == 2) {\\n            low = 0;\\n        } else if(letters[password[i]] == 3) {\\n            dig = 0;\\n        }\\n        \\n        int repeat = 1;\\n        while(password[i] == password[i + 1]){\\n            i++;\\n            repeat += 1;\\n        }\\n        \\n        if(repeat > 2){\\n            replace += (repeat / 3);\\n\\n            if(repeat % 3 == 0){\\n                one += 1;\\n            } else if(repeat % 3 == 1){\\n                two += 2;\\n            }\\n        }\\n    }\\n    \\n    if(length < 6){\\n        if(cap + low + dig > 6 - length){\\n            return cap + low + dig;\\n        } else {\\n            return 6 - length;\\n        }\\n    } else if(length <= 20){\\n        if(cap + low + dig > replace){\\n            return cap + low + dig;\\n        } else {\\n            return replace;\\n        }\\n    } else {\\n        int over = length - 20;\\n        \\n        if(one < over){\\n            replace -= one;\\n        } else {\\n            replace -= over;\\n        }\\n        \\n        if(over - one > 0){\\n            if(two < (over - one)){\\n                replace -= two / 2;\\n            } else {\\n                replace -= (over - one) / 2;\\n            }\\n        }\\n        \\n        if((over - one - two) > 0){\\n            replace -= (over - one - two) / 3;\\n        }\\n        \\n        if(cap + low + dig > replace){\\n            return over + cap + low + dig;\\n        } else {\\n            return over + replace;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2216819,
                "title": "python-solution-with-explanation-runtime-9-ms-faster-than-100-00",
                "content": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        \"\"\"\\n        :type password: str\\n        :rtype: int\\n        \"\"\"\\n        stack=list(password)\\n    \\n        ch_len=0\\n        ch_low=0\\n        ch_up=0\\n        ch_dig=0\\n        num_steps=0\\n        ch_del=0\\n        num_ofthree=0\\n\\n\\n        if len(stack)<6:\\n            ch_len=6-len(stack)\\n\\n        i=0\\n\\n        new_s=[] \\n        count_lst=[]\\n        for x in stack:\\n            if x.islower():\\n                ch_low=1\\n            if x.isupper():\\n                ch_up=1\\n            if x.isdigit():\\n                ch_dig=1\\n            if not new_s:\\n                new_s.append([x, 1])\\n\\n            else:\\n                if new_s[-1][0]==x:\\n                    count=new_s[-1][1]\\n                    new_s.pop()\\n                    new_s.append([x, count+1])\\n\\n                else:\\n                    new_s.append([x,1])\\n\\n\\n\\n        ch_let=3-(ch_up+ch_low+ch_dig)\\n\\n        for x in new_s:\\n            count_lst.append(x[1])\\n        \\n\\n        if len(password)<6:\\n            return max(6-len(password),ch_let )\\n            # example\\n            # password=\"aA1\" --> ch_let=0 and need to insert 6-len(password),\\n            # i.e. 6-3=3. Finally return max(3, 0)=3\\n\\n\\n        num_toreplace=sum([x//3 for x in count_lst])\\n        if len(password)<=20:\\n            return max(num_toreplace, ch_let)\\n            # example\\n            # password=\"1111111111\"\\n            # count_lst=[10]\\n            # num_toreplace=10//3=3 ch_let=2, because need to insert capital and .. letters\\n            # \\'11A11a11f1\\' example of replacement and insertion\\n            # return max(3,2)-->3\\n\\n        num_todelete=len(password)-20    \\n\\n        for i,x in enumerate(count_lst):\\n            if x%3==0 and x>=3 and num_todelete>=1 and num_toreplace>0:\\n                count_lst[i]-=1\\n                num_todelete-=1\\n                num_toreplace-=1\\n        for i, x in enumerate(count_lst):\\n            if x%3==1 and x>=3 and num_todelete>=2 and num_toreplace>0:\\n                count_lst[i]-=2\\n                num_todelete-=2\\n                num_toreplace-=1\\n\\n        tmp_num=sum([x//3 for x in count_lst])\\n        num_toreplace-=min(num_todelete//3,tmp_num)\\n        # example\\n        # password=\"aaaabbbbccccddeeddeeddeedd\"\\n        # count_lst=[4, 4, 4, 2, 2, 2, 2, 2, 2, 2]\\n        # num_todelete==26-20=6 elements\\n        # ch_let=2 num_toreplace=3\\n        # first loop:\\n        # nothing changes because there is no items in count_lst\\n        # for which x%3==0\\n        # second loop:\\n        # [2,2,2,2,2,2,2,2,2,2]\\n        # num_todelete=0 num_toreplace=0\\n        # tmp_num=0\\n        # num_toreplace=0\\n        # return 26-20+max(0,2)=8\\n        return len(password) - 20 + max(num_toreplace, ch_let)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        \"\"\"\\n        :type password: str\\n        :rtype: int\\n        \"\"\"\\n        stack=list(password)\\n    \\n        ch_len=0\\n        ch_low=0\\n        ch_up=0\\n        ch_dig=0\\n        num_steps=0\\n        ch_del=0\\n        num_ofthree=0\\n\\n\\n        if len(stack)<6:\\n            ch_len=6-len(stack)\\n\\n        i=0\\n\\n        new_s=[] \\n        count_lst=[]\\n        for x in stack:\\n            if x.islower():\\n                ch_low=1\\n            if x.isupper():\\n                ch_up=1\\n            if x.isdigit():\\n                ch_dig=1\\n            if not new_s:\\n                new_s.append([x, 1])\\n\\n            else:\\n                if new_s[-1][0]==x:\\n                    count=new_s[-1][1]\\n                    new_s.pop()\\n                    new_s.append([x, count+1])\\n\\n                else:\\n                    new_s.append([x,1])\\n\\n\\n\\n        ch_let=3-(ch_up+ch_low+ch_dig)\\n\\n        for x in new_s:\\n            count_lst.append(x[1])\\n        \\n\\n        if len(password)<6:\\n            return max(6-len(password),ch_let )\\n            # example\\n            # password=\"aA1\" --> ch_let=0 and need to insert 6-len(password),\\n            # i.e. 6-3=3. Finally return max(3, 0)=3\\n\\n\\n        num_toreplace=sum([x//3 for x in count_lst])\\n        if len(password)<=20:\\n            return max(num_toreplace, ch_let)\\n            # example\\n            # password=\"1111111111\"\\n            # count_lst=[10]\\n            # num_toreplace=10//3=3 ch_let=2, because need to insert capital and .. letters\\n            # \\'11A11a11f1\\' example of replacement and insertion\\n            # return max(3,2)-->3\\n\\n        num_todelete=len(password)-20    \\n\\n        for i,x in enumerate(count_lst):\\n            if x%3==0 and x>=3 and num_todelete>=1 and num_toreplace>0:\\n                count_lst[i]-=1\\n                num_todelete-=1\\n                num_toreplace-=1\\n        for i, x in enumerate(count_lst):\\n            if x%3==1 and x>=3 and num_todelete>=2 and num_toreplace>0:\\n                count_lst[i]-=2\\n                num_todelete-=2\\n                num_toreplace-=1\\n\\n        tmp_num=sum([x//3 for x in count_lst])\\n        num_toreplace-=min(num_todelete//3,tmp_num)\\n        # example\\n        # password=\"aaaabbbbccccddeeddeeddeedd\"\\n        # count_lst=[4, 4, 4, 2, 2, 2, 2, 2, 2, 2]\\n        # num_todelete==26-20=6 elements\\n        # ch_let=2 num_toreplace=3\\n        # first loop:\\n        # nothing changes because there is no items in count_lst\\n        # for which x%3==0\\n        # second loop:\\n        # [2,2,2,2,2,2,2,2,2,2]\\n        # num_todelete=0 num_toreplace=0\\n        # tmp_num=0\\n        # num_toreplace=0\\n        # return 26-20+max(0,2)=8\\n        return len(password) - 20 + max(num_toreplace, ch_let)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144906,
                "title": "10-priority-queue",
                "content": "Our logisitic is that:\\n1. first find how many requirements we need. \\n\\t1. There are length requirement (6<=N<=20)\\n\\t2. There are characters requirement (uppercase, lowercase, digit)\\n\\t3. 3 continuous repeating characters (\\'aaa\\' is invalid)\\n\\tTo find these requirements,\\n\\t\\t1. For length requirement, we compare length of our password `N` with 6 & 20. if it is less than 6, do insertion. if it is larger than 20, do deletion.\\n\\t\\t2. characters requirement can be solved by insertion or replacment. So assume there are `Nc`(0~2) types of characters lacking, we at least need to do `Nc` insertion & Replacement operations.\\n\\t\\t3. repeating characters problem can be solved by insertion/deletion/replacement operations. We use a priority queue to record these characters. Push all subarray consisted of k(k>=3) same characters into it. We can put it at the last.\\n\\t \\n2. For `N`<6, it is easy to do insertion. Just adding a character (`N+1`), fulfill character requirement (`Nc-=1`), cuting a 3 repeating characters (`\\'aaaa\\'->\\'aaBaa\\'`, `k-=2`)\\n3. For `N>20`, we need to try different strategy to break the repeating characters.\\n\\t1. We should do deletion. But to find the minimum operation after doing deletion, we can find that replacement operation can reduce 3 value for a repeating characters string (`\\'aaaaa\\'->\\'aaBaa\\'`, replace 1 and cut 2). But for string whose length can be divided by 3 (`\\'aaaaaa\\'->\\'aaBaaC\\'`), we still need to do 2 operation, and we only need one deletion to reduce one operation (\\'aaaaaa\\'->\\'aaaaa\\'->\\'aaBaa\\'). So we use a priority queue, containing (value, value mod 3). first handle pairs which have less mod, since we need less operation to reach ((k-x)%3 = 2), which takes less operations. Then we can find the optimal strings with deletion. \\n\\t2. Then we push all elements in pq2 into pq. \\n4. Finally, we do replacement operations. each time it is done, reduce the k by 3, and if Nc is not 0, reduce 1. \\n5. If there are any Nc, we need to do additional replacement. so result plus Nc.\\n```java\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    private List<Integer> parse(String password) {\\n        //count the length for each repeat characters\\n        int i = 0;\\n        int j = 0;\\n        List<Integer> tokens = new ArrayList<>();\\n        int N = password.length();\\n        while (j < N) {\\n            int count = 0;\\n            while (j < N && password.charAt(i) == password.charAt(j)) {\\n                count += 1;\\n                j += 1;\\n            }\\n            tokens.add(count);\\n            i = j;\\n        }\\n        return tokens;\\n    }\\n    class Pair{\\n        int v;\\n        int mod;\\n        Pair(int v, int mod) {\\n            this.v = v;\\n            this.mod = mod;\\n        }\\n    }\\n    public int strongPasswordChecker(String password) {\\n        List<Integer> counters = parse(password);\\n        Set<Integer> containment = new HashSet<>();\\n        int operation = 0;\\n        containment.add(1);\\n        containment.add(2);\\n        containment.add(3);\\n        int N = password.length();\\n        for (int i = 0; i < N; i++) {\\n            if(\\'a\\'<=password.charAt(i) && password.charAt(i)<=\\'z\\'){\\n                containment.remove(1);\\n            }else if(\\'A\\'<=password.charAt(i) && password.charAt(i)<=\\'Z\\'){\\n                containment.remove(2);\\n            }else{\\n                containment.remove(3);\\n            }\\n        }\\n        int Nc = containment.size();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        if(N < 6){\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq.offer(counter);\\n                }\\n            }\\n            for (int i = 0; i < 6 - N; i++) {\\n                Nc = Math.max(Nc-1, 0);\\n                if(!pq.isEmpty()){\\n                    int poll = pq.poll();\\n                    poll-=2;\\n                    if(poll >= 3){\\n                        pq.offer(poll);\\n                    }\\n                }\\n                operation+=1;\\n            }\\n        }else if(N > 20){\\n            PriorityQueue<Pair> pq2 = new PriorityQueue<>(Comparator.comparingInt(o -> o.mod));\\n\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq2.add(new Pair(counter, counter % 3));\\n                }\\n            }\\n            int delta = N-20;\\n            while(delta != 0 && !pq2.isEmpty()){\\n                Pair poll = pq2.poll();\\n                if(poll.mod == 0){\\n                    poll.mod = 2;\\n                    poll.v -= 1;\\n                    delta -=1;\\n                    operation += 1;\\n                    if(poll.v >= 3){\\n                        pq2.add(poll);\\n                    }\\n                } else if(poll.mod == 1){\\n                    if(delta >= 2){\\n                        poll.mod = 2;\\n                        poll.v -= 2;\\n                        delta -= 2;\\n                        operation += 2;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }else{\\n                        poll.mod = 0;\\n                        poll.v -= 1;\\n                        delta -= 1;\\n                        operation += 1;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }\\n                }else{\\n                    if(delta >= 3){\\n                        poll.mod = 2;\\n                        poll.v -= 3;\\n                        delta -= 3;\\n                        operation += 3;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }else {\\n                        poll.mod = 1;\\n                        poll.v -= delta;\\n                        operation += delta;\\n                        delta -= delta;\\n\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }\\n                }\\n            }\\n            if(pq2.isEmpty()){\\n                operation+=delta;\\n            }\\n            while(!pq2.isEmpty()){\\n                pq.add(pq2.poll().v);\\n            }\\n        }else{\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq.offer(counter);\\n                }\\n            }\\n        }\\n        while(!pq.isEmpty()){\\n            int poll = pq.poll();\\n            poll-=3;\\n            if(poll >= 3){\\n                pq.offer(poll);\\n            }\\n            Nc = Math.max(Nc-1, 0);\\n            operation += 1;\\n        }\\n        operation += Nc;\\n        return operation;\\n    }\\n\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    private List<Integer> parse(String password) {\\n        //count the length for each repeat characters\\n        int i = 0;\\n        int j = 0;\\n        List<Integer> tokens = new ArrayList<>();\\n        int N = password.length();\\n        while (j < N) {\\n            int count = 0;\\n            while (j < N && password.charAt(i) == password.charAt(j)) {\\n                count += 1;\\n                j += 1;\\n            }\\n            tokens.add(count);\\n            i = j;\\n        }\\n        return tokens;\\n    }\\n    class Pair{\\n        int v;\\n        int mod;\\n        Pair(int v, int mod) {\\n            this.v = v;\\n            this.mod = mod;\\n        }\\n    }\\n    public int strongPasswordChecker(String password) {\\n        List<Integer> counters = parse(password);\\n        Set<Integer> containment = new HashSet<>();\\n        int operation = 0;\\n        containment.add(1);\\n        containment.add(2);\\n        containment.add(3);\\n        int N = password.length();\\n        for (int i = 0; i < N; i++) {\\n            if(\\'a\\'<=password.charAt(i) && password.charAt(i)<=\\'z\\'){\\n                containment.remove(1);\\n            }else if(\\'A\\'<=password.charAt(i) && password.charAt(i)<=\\'Z\\'){\\n                containment.remove(2);\\n            }else{\\n                containment.remove(3);\\n            }\\n        }\\n        int Nc = containment.size();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        if(N < 6){\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq.offer(counter);\\n                }\\n            }\\n            for (int i = 0; i < 6 - N; i++) {\\n                Nc = Math.max(Nc-1, 0);\\n                if(!pq.isEmpty()){\\n                    int poll = pq.poll();\\n                    poll-=2;\\n                    if(poll >= 3){\\n                        pq.offer(poll);\\n                    }\\n                }\\n                operation+=1;\\n            }\\n        }else if(N > 20){\\n            PriorityQueue<Pair> pq2 = new PriorityQueue<>(Comparator.comparingInt(o -> o.mod));\\n\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq2.add(new Pair(counter, counter % 3));\\n                }\\n            }\\n            int delta = N-20;\\n            while(delta != 0 && !pq2.isEmpty()){\\n                Pair poll = pq2.poll();\\n                if(poll.mod == 0){\\n                    poll.mod = 2;\\n                    poll.v -= 1;\\n                    delta -=1;\\n                    operation += 1;\\n                    if(poll.v >= 3){\\n                        pq2.add(poll);\\n                    }\\n                } else if(poll.mod == 1){\\n                    if(delta >= 2){\\n                        poll.mod = 2;\\n                        poll.v -= 2;\\n                        delta -= 2;\\n                        operation += 2;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }else{\\n                        poll.mod = 0;\\n                        poll.v -= 1;\\n                        delta -= 1;\\n                        operation += 1;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }\\n                }else{\\n                    if(delta >= 3){\\n                        poll.mod = 2;\\n                        poll.v -= 3;\\n                        delta -= 3;\\n                        operation += 3;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }else {\\n                        poll.mod = 1;\\n                        poll.v -= delta;\\n                        operation += delta;\\n                        delta -= delta;\\n\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }\\n                }\\n            }\\n            if(pq2.isEmpty()){\\n                operation+=delta;\\n            }\\n            while(!pq2.isEmpty()){\\n                pq.add(pq2.poll().v);\\n            }\\n        }else{\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq.offer(counter);\\n                }\\n            }\\n        }\\n        while(!pq.isEmpty()){\\n            int poll = pq.poll();\\n            poll-=3;\\n            if(poll >= 3){\\n                pq.offer(poll);\\n            }\\n            Nc = Math.max(Nc-1, 0);\\n            operation += 1;\\n        }\\n        operation += Nc;\\n        return operation;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066111,
                "title": "python-solution-91-5-fastest-and-91-78-memory",
                "content": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        no_lower = 1\\n        no_upper = 1\\n        no_num = 1\\n        \\n        repeating = []\\n        \\n        len_pass = len(password)\\n        streak = 1\\n        \\n        for i in range(len_pass):\\n            if password[i].islower():\\n                no_lower = 0\\n            if password[i].isupper():\\n                no_upper = 0\\n            if password[i].isnumeric():\\n                no_num = 0\\n                \\n            if i!=0 and password[i] == prev:\\n                streak +=1\\n            else:\\n                if streak > 2:\\n                    repeating.append(streak)\\n                streak = 1\\n            prev = password[i]\\n            \\n            if i==len_pass-1:\\n                if streak > 2:\\n                    repeating.append(streak)\\n        \\n        reminders = [x%3 for x in repeating]\\n        repeating = [x for _, x in sorted(zip(reminders, repeating))]\\n        reminders = [x%3 for x in repeating]\\n        \\n        dist_case = no_lower + no_upper + no_num\\n        dist = 0\\n        \\n        if len_pass < 6:\\n            dist = max(dist_case, 6-len_pass)\\n            \\n        if len_pass > 20:\\n            dist =  len_pass - 20\\n            while(dist>0 and reminders!=[]):\\n                for i, rem in enumerate(reminders):\\n                    if(rem<dist):\\n                        repeating[i] -= (rem+1)\\n                        dist -= rem+1\\n                    else:\\n                        repeating[i] -= dist\\n                        dist = 0\\n                        break\\n                reminders = [x%3 for x in repeating]\\n                repeating = [x for _, x in sorted(zip(reminders, repeating))]\\n                reminders = [x%3 for x in repeating]\\n            dist =  len_pass - 20\\n            len_pass = 20\\n            \\n        if len_pass >= 6 and len_pass <=20:\\n            dist_rep = 0\\n            for rep in repeating:\\n                dist_rep += int(rep/3//1)\\n            dist += max(dist_case, dist_rep)\\n        \\n        return dist\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        no_lower = 1\\n        no_upper = 1\\n        no_num = 1\\n        \\n        repeating = []\\n        \\n        len_pass = len(password)\\n        streak = 1\\n        \\n        for i in range(len_pass):\\n            if password[i].islower():\\n                no_lower = 0\\n            if password[i].isupper():\\n                no_upper = 0\\n            if password[i].isnumeric():\\n                no_num = 0\\n                \\n            if i!=0 and password[i] == prev:\\n                streak +=1\\n            else:\\n                if streak > 2:\\n                    repeating.append(streak)\\n                streak = 1\\n            prev = password[i]\\n            \\n            if i==len_pass-1:\\n                if streak > 2:\\n                    repeating.append(streak)\\n        \\n        reminders = [x%3 for x in repeating]\\n        repeating = [x for _, x in sorted(zip(reminders, repeating))]\\n        reminders = [x%3 for x in repeating]\\n        \\n        dist_case = no_lower + no_upper + no_num\\n        dist = 0\\n        \\n        if len_pass < 6:\\n            dist = max(dist_case, 6-len_pass)\\n            \\n        if len_pass > 20:\\n            dist =  len_pass - 20\\n            while(dist>0 and reminders!=[]):\\n                for i, rem in enumerate(reminders):\\n                    if(rem<dist):\\n                        repeating[i] -= (rem+1)\\n                        dist -= rem+1\\n                    else:\\n                        repeating[i] -= dist\\n                        dist = 0\\n                        break\\n                reminders = [x%3 for x in repeating]\\n                repeating = [x for _, x in sorted(zip(reminders, repeating))]\\n                reminders = [x%3 for x in repeating]\\n            dist =  len_pass - 20\\n            len_pass = 20\\n            \\n        if len_pass >= 6 and len_pass <=20:\\n            dist_rep = 0\\n            for rep in repeating:\\n                dist_rep += int(rep/3//1)\\n            dist += max(dist_case, dist_rep)\\n        \\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960224,
                "title": "python-solution-i-hate-this-problem-qaq",
                "content": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:  \\n        containLower = 0\\n        containUpper = 0\\n        containDigit = 0   \\n        prevChar = password[0]\\n        repeat = 0\\n        replace = 0\\n        encoded_pwd = []\\n        for l in password:\\n            if l.islower():\\n                containLower = 1\\n            elif l.isupper():\\n                containUpper = 1\\n            elif l.isdigit():\\n                containDigit = 1    \\n            if l == prevChar:\\n                repeat += 1\\n            else:\\n                encoded_pwd.append((prevChar, repeat))\\n                replace += math.ceil((repeat - 2) / 3)\\n                prevChar = l\\n                repeat = 1\\n        encoded_pwd.append((prevChar, repeat))\\n        replace += math.ceil((repeat - 2) / 3)\\n        n = len(password)\\n        delete = 0\\n        tooLong = max(0, n - 20)\\n        if tooLong:\\n            encoded_pwd.sort(key = lambda x: (x[1] - 2) % 3)\\n        for c, freq in encoded_pwd:\\n            if freq >= 3 and (freq - 2) % 3 and tooLong and tooLong >= (freq - 2) % 3:\\n                    tooLong -= (freq - 2) % 3\\n                    delete += (freq - 2) % 3\\n                    replace -= 1\\n        if tooLong:\\n            delete += tooLong\\n            replace -= min(tooLong // 3, replace)\\n        if n < 6:\\n            return max(6 - n, 3 - (containLower + containUpper + containDigit))\\n        elif n <= 20:\\n            return max(replace, 3 - (containLower + containUpper + containDigit))\\n        else:\\n            return max(replace, 3 - (containLower + containUpper + containDigit)) + delete\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:  \\n        containLower = 0\\n        containUpper = 0\\n        containDigit = 0   \\n        prevChar = password[0]\\n        repeat = 0\\n        replace = 0\\n        encoded_pwd = []\\n        for l in password:\\n            if l.islower():\\n                containLower = 1\\n            elif l.isupper():\\n                containUpper = 1\\n            elif l.isdigit():\\n                containDigit = 1    \\n            if l == prevChar:\\n                repeat += 1\\n            else:\\n                encoded_pwd.append((prevChar, repeat))\\n                replace += math.ceil((repeat - 2) / 3)\\n                prevChar = l\\n                repeat = 1\\n        encoded_pwd.append((prevChar, repeat))\\n        replace += math.ceil((repeat - 2) / 3)\\n        n = len(password)\\n        delete = 0\\n        tooLong = max(0, n - 20)\\n        if tooLong:\\n            encoded_pwd.sort(key = lambda x: (x[1] - 2) % 3)\\n        for c, freq in encoded_pwd:\\n            if freq >= 3 and (freq - 2) % 3 and tooLong and tooLong >= (freq - 2) % 3:\\n                    tooLong -= (freq - 2) % 3\\n                    delete += (freq - 2) % 3\\n                    replace -= 1\\n        if tooLong:\\n            delete += tooLong\\n            replace -= min(tooLong // 3, replace)\\n        if n < 6:\\n            return max(6 - n, 3 - (containLower + containUpper + containDigit))\\n        elif n <= 20:\\n            return max(replace, 3 - (containLower + containUpper + containDigit))\\n        else:\\n            return max(replace, 3 - (containLower + containUpper + containDigit)) + delete\\n",
                "codeTag": "Java"
            },
            {
                "id": 1896125,
                "title": "php-solutions-strong-password-checker-100",
                "content": "class Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $PasswordArray = str_split($password);//string to array\\n        \\n        $MissingType = 3;\\n        $NumList = range(48, 57);//(ASCII CODE)0 ~ 9\\n        $EngList_capital = range(65, 90);//(ASCII CODE)A ~ Z\\n        $EngList_lowercase = range(97, 122);//(ASCII CODE)a ~ z\\n        $NumFlag = $CapitalFlag = $LowercaseFlag = false;\\n        foreach($PasswordArray as $key=>$value){\\n            if(!$NumFlag && in_array(ord($value), $NumList)){ //check if is number\\n                $NumFlag = true;\\n            }else if(!$CapitalFlag && in_array(ord($value), $EngList_capital)){ //check if is A~Z\\n                $CapitalFlag = true;\\n            }else if(!$LowercaseFlag && in_array(ord($value), $EngList_lowercase)){ //check if is a~z\\n                $LowercaseFlag = true;\\n            }\\n        }\\n        if($NumFlag) $MissingType--;\\n        if($CapitalFlag) $MissingType--;\\n        if($LowercaseFlag) $MissingType--;\\n        \\n        /*\\n         * check repeat\\n         */\\n        $Change = $One = $Two = 0;\\n        $p = 2;\\n        while($p < strlen($password)){\\n            if($PasswordArray[$p]==$PasswordArray[$p-1] && $PasswordArray[$p]==$PasswordArray[$p-2]){\\n                $RepeatedLength = 2;\\n                while($p<strlen($password) && $PasswordArray[$p]==$PasswordArray[$p-1]){\\n                    $RepeatedLength ++;\\n                    $p ++;\\n                }\\n                $Change += floor($RepeatedLength/3);\\n                if($RepeatedLength%3==0) $One += 1;\\n                if($RepeatedLength%3==1) $Two += 2;\\n            }else{\\n                $p ++;\\n            }\\n        }\\n        \\n        if(strlen($password)<6){\\n            return max($MissingType, 6-strlen($password));\\n        }else if(strlen($password)>=6 && strlen($password)<=20){\\n            return max($MissingType, $Change);\\n        }else if(strlen($password)>20){\\n            $Delete = strlen($password) - 20;\\n            \\n            $Change -= min($Delete, $One);\\n            $Change -= floor(min(max($Delete - $One, 0), $Two) / 2);\\n            $Change -= floor(max($Delete - $One - $Two, 0) / 3);\\n            return $Delete + max($MissingType, $Change);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "PHP"
                ],
                "code": "class Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $PasswordArray = str_split($password);//string to array\\n        \\n        $MissingType = 3;\\n        $NumList = range(48, 57);//(ASCII CODE)0 ~ 9\\n        $EngList_capital = range(65, 90);//(ASCII CODE)A ~ Z\\n        $EngList_lowercase = range(97, 122);//(ASCII CODE)a ~ z\\n        $NumFlag = $CapitalFlag = $LowercaseFlag = false;\\n        foreach($PasswordArray as $key=>$value){\\n            if(!$NumFlag && in_array(ord($value), $NumList)){ //check if is number\\n                $NumFlag = true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1839991,
                "title": "test-case-error",
                "content": "# test case error\\n\\n> just need on step\\n\\n`\"aaa111\"` => `\"Aaa111\"`\\n\\n`\"aaa111\"` => `\"Baa111\"`\\n\\nIn one step, you can:\\n\\nInsert one character to password,\\nDelete one character from password, or\\nReplace one character of password with another character.\\n\\n\\n```js\\n\"aaa111\"\\nOutput\\n1\\nExpected\\n2\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n\"aaa111\"\\nOutput\\n1\\nExpected\\n2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1769945,
                "title": "strong-password-checker-soln-c",
                "content": "class Solution {\\npublic:\\n    \\n    int repeat(string &A){\\n        \\n        vector<string>div;\\n        int start = 0, i = 0;\\n        \\n        \\n        for(i = 1; i<A.size(); i++){\\n            \\n            if(A[i] != A[i-1]){\\n                div.push_back(A.substr(start,i-start));\\n                start = i;\\n            }            \\n            \\n        }\\n        \\n        if(A[i] != A[i-1]){\\n            div.push_back(A.substr(start,i-start));\\n        }   \\n        \\n        for(int i = 0; i < div.size(); i++){\\n            \\n            if(div[i].size() >= 3){\\n                break;\\n            }\\n            else if(i == div.size()-1){\\n                return -1;\\n            }\\n            \\n        }\\n        \\n        int index = 0;\\n        int x = -1, y = -1;\\n        \\n        for(int i = 0; i<div.size(); i++){\\n\\n            int m = div[i].size();\\n            \\n            if(m < 3){\\n                index += m;\\n                continue;\\n            }\\n        \\n            if(m % 3 == 0){\\n                \\n                return index;\\n                \\n            }\\n            \\n            if(m % 3 == 1 and x == -1){\\n                \\n                x = index;\\n                \\n            }\\n            \\n            if(m % 3 == 2 and y == -1){\\n                \\n                y = index;\\n                \\n            }\\n            \\n            index += m;\\n            \\n        }\\n        \\n        if(x != -1){\\n            return x;\\n        }\\n        if(y != -1){\\n            return y;\\n        }        \\n        \\n        \\n        return 0;\\n        \\n    }\\n    \\n    \\n    int check(string &A){\\n        \\n        int total = 3;\\n        bool f1 = true, f2 = true, f3 = true;\\n\\n        for(int i = 0; i < A.size(); i++){\\n            \\n            char x = A[i];\\n            \\n            if(x >= 65 and x <= 90 and f1){\\n                total--;\\n                f1 = false;\\n            } \\n            if(x >= 97 and x <= 122 and f2){\\n                total--;\\n                f2 = false;\\n            }\\n            if(x >= 48 and x <= 57 and f3){\\n                total--;\\n                f3 = false;\\n            }\\n            \\n        } \\n        \\n        return total;   \\n    \\n    }\\n    \\n    int check(string &A, int j){\\n        \\n        int ans = 0;\\n        \\n        for(int i = j-2; i>=0; i--){\\n\\n            if(A[i] == A[i+1] and A[i] == A[i+2]){\\n                ans++;\\n                i -= 2;\\n            }\\n        \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    int strongPasswordChecker(string password) {\\n        \\n        int want = check(password);\\n        int ans = 0;\\n        \\n        if(password.size() < 6){\\n            int c = check(password,password.size()-1);\\n            int d = 6-password.size();\\n            ans = max(c,want);\\n            ans = max(ans,d);\\n            return ans;\\n        }\\n        \\n        while(password.size() > 20){\\n            int ind = repeat(password);\\n            if(ind == -1){\\n                break;\\n            }\\n            password.erase(password.begin() + ind);     \\n            ans++;\\n        }\\n        \\n        int rep = 0;\\n        \\n        while(true){\\n            int ind = repeat(password);\\n            if(ind == -1){\\n                break;\\n            }\\n            password[ind + 2] = \\'#\\';    \\n            rep++;\\n        }\\n        \\n        // cout << password ;\\n        int m = 20;\\n        int siz = password.size();\\n        int t = 0;\\n        \\n        if((siz-m) > t){\\n            t = password.size()-m;\\n        }\\n        \\n        cout << ans << \" \" << want << \" \" << rep << \" \" << t ;\\n        \\n        return ans + max(want,rep) + t;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int repeat(string &A){\\n        \\n        vector<string>div;\\n        int start = 0, i = 0;\\n        \\n        \\n        for(i = 1; i<A.size(); i++){\\n            \\n            if(A[i] != A[i-1]){\\n                div.push_back(A.substr(start,i-start));\\n                start = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1733371,
                "title": "o-n-solution-with-comment-referenced-meng789987-s-answer",
                "content": "```\\nclass Solution {\\n    // 3 cases\\n    //    1. s.len < 6 => insert and replacement. Number of operation is max(steps to meet condition 2, steps to meet condition 3)\\n    //    2. s.len >= 6 and <= 20 => we do replacement only. Number of operation is max(steps to meet condition 2, steps to meet condition 3)\\n    //   3. s.len > 20 => deletion and replacement. Number of operaation is deletion count + max(steps to meet condition 2, steps to meet condition 3)\\n    \\n    // how to meet condition 2? \\n    //    1. initialize 3 variables: step to add upper case, step to add lower case, and step to add digit to 1\\n    //    2. transverse the string, and see what variables can go down to zero\\n    //    3. return the sum of 3 variables\\n    \\n    // how to meet condition 3?\\n    //    1. consider we only do replacement. For every 3 continuous same char like \\'aaa\\', we can replace one of them\\n    //        1.5: if 6 <= s.len <= 20, we can return number of replacement\\n    //    2. if s.len > 20, we need to delete some char, during this time, we can revert some replacement back which to save unnecessary replacement operations. \\n    //        a. if count of chars to be deleted > 0, for 3 continuous same char like \\'aaa\\', we can do one deletion, and save one replacement\\n    //        b. if count of chars to be deleted still > 0, for 3n + 1 continuous same char like \\'aaaa\\', we can do 2 deletions and save one replacement\\n    //        c. if count of chars to be deleted still > 0, we can do 3 deletions and save one replacement\\n    //    3. return deletion count + max(steps to meet condition 2, number of replacement)\\n    \\n    public int strongPasswordChecker(String s) {\\n        // case 1\\n        int len = s.length();\\n        if (len < 6) return Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), 6 - len);\\n        \\n        // case 2 and 3\\n        int replacementCount = 0, placesCanDeleteOneCharToSaveOneReplacement = 0, placesCanDeleteTwoCharsToSaveOneReplacement = 0;  \\n        \\n        // for each iteration, we transverse continuous same chars\\n        for (int i = 0; i < len; i++) {\\n            char currChar = s.charAt(i);\\n            int currCharLen = 1;\\n            while (i + 1 < len && s.charAt(i + 1) == currChar) {\\n                i++;\\n                currCharLen++;\\n            }\\n                   \\n            if (currCharLen >= 3) {\\n                replacementCount += (currCharLen) / 3;     \\n                if (currCharLen % 3 == 0) placesCanDeleteOneCharToSaveOneReplacement++;\\n                if (currCharLen % 3 == 1) placesCanDeleteTwoCharsToSaveOneReplacement++;\\n            }\\n        }\\n        \\n        // case 2\\n        if (len >= 6 && len <= 20) return Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), replacementCount);    \\n             \\n        int charsToBeDeleted = len - 20;\\n        \\n        // we delete one char and save one replacement\\n        // for some cases, we may only need to delete x times, and we have y qualified places. x could be smaller, equal or larger than y, so we need Math.min\\n        // we consider this case first since we only need one deletion to save one replacement, which is the most efficient way\\n        replacementCount -= Math.min(charsToBeDeleted, placesCanDeleteOneCharToSaveOneReplacement);\\n        \\n        // we delete two chars and save one replacement\\n        // charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement represents that, except the case above, how many deletion we still have\\n        // (placesCanDeleteTwoCharsToSaveOneReplacement * 2) means chars to be deleted by this case\\n        // (placesCanDeleteTwoCharsToSaveOneReplacement * 2) / 2 => since every 2 deletion saves one replacement, so we need to devide by 2\\n        replacementCount -= Math.min(Math.max(charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement, 0), placesCanDeleteTwoCharsToSaveOneReplacement * 2) / 2;\\n        \\n        // we delete 3 chars and save one replacement\\n        // logic is similar as above\\n        replacementCount -= Math.max(charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement - 2 * placesCanDeleteTwoCharsToSaveOneReplacement, 0) / 3;\\n        \\n        return charsToBeDeleted + Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), replacementCount);\\n    }\\n    \\n    private int stepsToContainLowerCaseUpperCaseAndDigit (String s) {\\n        int stepToContainLowerCase = 1;\\n        int stepToContainUpperCase = 1;\\n        int stepToContainDigit = 1;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (Character.isDigit(c)) stepToContainDigit = 0;\\n            if (Character.isLowerCase(c)) stepToContainLowerCase = 0;\\n            if (Character.isUpperCase(c)) stepToContainUpperCase = 0;\\n        }\\n        \\n        return stepToContainLowerCase + stepToContainUpperCase + stepToContainDigit;\\n    }\\n}\\n\\n// O(N)\\n// O(1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // 3 cases\\n    //    1. s.len < 6 => insert and replacement. Number of operation is max(steps to meet condition 2, steps to meet condition 3)\\n    //    2. s.len >= 6 and <= 20 => we do replacement only. Number of operation is max(steps to meet condition 2, steps to meet condition 3)\\n    //   3. s.len > 20 => deletion and replacement. Number of operaation is deletion count + max(steps to meet condition 2, steps to meet condition 3)\\n    \\n    // how to meet condition 2? \\n    //    1. initialize 3 variables: step to add upper case, step to add lower case, and step to add digit to 1\\n    //    2. transverse the string, and see what variables can go down to zero\\n    //    3. return the sum of 3 variables\\n    \\n    // how to meet condition 3?\\n    //    1. consider we only do replacement. For every 3 continuous same char like \\'aaa\\', we can replace one of them\\n    //        1.5: if 6 <= s.len <= 20, we can return number of replacement\\n    //    2. if s.len > 20, we need to delete some char, during this time, we can revert some replacement back which to save unnecessary replacement operations. \\n    //        a. if count of chars to be deleted > 0, for 3 continuous same char like \\'aaa\\', we can do one deletion, and save one replacement\\n    //        b. if count of chars to be deleted still > 0, for 3n + 1 continuous same char like \\'aaaa\\', we can do 2 deletions and save one replacement\\n    //        c. if count of chars to be deleted still > 0, we can do 3 deletions and save one replacement\\n    //    3. return deletion count + max(steps to meet condition 2, number of replacement)\\n    \\n    public int strongPasswordChecker(String s) {\\n        // case 1\\n        int len = s.length();\\n        if (len < 6) return Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), 6 - len);\\n        \\n        // case 2 and 3\\n        int replacementCount = 0, placesCanDeleteOneCharToSaveOneReplacement = 0, placesCanDeleteTwoCharsToSaveOneReplacement = 0;  \\n        \\n        // for each iteration, we transverse continuous same chars\\n        for (int i = 0; i < len; i++) {\\n            char currChar = s.charAt(i);\\n            int currCharLen = 1;\\n            while (i + 1 < len && s.charAt(i + 1) == currChar) {\\n                i++;\\n                currCharLen++;\\n            }\\n                   \\n            if (currCharLen >= 3) {\\n                replacementCount += (currCharLen) / 3;     \\n                if (currCharLen % 3 == 0) placesCanDeleteOneCharToSaveOneReplacement++;\\n                if (currCharLen % 3 == 1) placesCanDeleteTwoCharsToSaveOneReplacement++;\\n            }\\n        }\\n        \\n        // case 2\\n        if (len >= 6 && len <= 20) return Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), replacementCount);    \\n             \\n        int charsToBeDeleted = len - 20;\\n        \\n        // we delete one char and save one replacement\\n        // for some cases, we may only need to delete x times, and we have y qualified places. x could be smaller, equal or larger than y, so we need Math.min\\n        // we consider this case first since we only need one deletion to save one replacement, which is the most efficient way\\n        replacementCount -= Math.min(charsToBeDeleted, placesCanDeleteOneCharToSaveOneReplacement);\\n        \\n        // we delete two chars and save one replacement\\n        // charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement represents that, except the case above, how many deletion we still have\\n        // (placesCanDeleteTwoCharsToSaveOneReplacement * 2) means chars to be deleted by this case\\n        // (placesCanDeleteTwoCharsToSaveOneReplacement * 2) / 2 => since every 2 deletion saves one replacement, so we need to devide by 2\\n        replacementCount -= Math.min(Math.max(charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement, 0), placesCanDeleteTwoCharsToSaveOneReplacement * 2) / 2;\\n        \\n        // we delete 3 chars and save one replacement\\n        // logic is similar as above\\n        replacementCount -= Math.max(charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement - 2 * placesCanDeleteTwoCharsToSaveOneReplacement, 0) / 3;\\n        \\n        return charsToBeDeleted + Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), replacementCount);\\n    }\\n    \\n    private int stepsToContainLowerCaseUpperCaseAndDigit (String s) {\\n        int stepToContainLowerCase = 1;\\n        int stepToContainUpperCase = 1;\\n        int stepToContainDigit = 1;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (Character.isDigit(c)) stepToContainDigit = 0;\\n            if (Character.isLowerCase(c)) stepToContainLowerCase = 0;\\n            if (Character.isUpperCase(c)) stepToContainUpperCase = 0;\\n        }\\n        \\n        return stepToContainLowerCase + stepToContainUpperCase + stepToContainDigit;\\n    }\\n}\\n\\n// O(N)\\n// O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651946,
                "title": "why-this-question-has-so-many-dislikes",
                "content": "I agree that this question contains a lot of corner cases, and its really hard to do it in one try.\\nBut why so many dislikes?\\nIs this because constraints are too small ?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1651941,
                "title": "c-solution-very-detailed-and-readable-approach-explanation-with-all-cases",
                "content": "```\\n\\n#define dm 1\\n#define trace1(x) if(dm)cout<<(#x)<<\" \"<<(x)<<endl\\n#define trace2(x,y) if(dm)cout<<(#x)<<\" \"<<(x)<<\", \"<<(#y)<<\" \"<<(y)<<endl\\n#define trace3(x,y,z) if(dm)cout<<(#x)<<\" \"<<(x)<<\", \"<<(#y)<<\" \"<<(y)<<\", \"<<(#z)<<\" \"<<(z)<<endl\\n\\nclass Solution {\\nprivate :\\n    bool islower(char c){\\n        return (c>=\\'a\\' && c<=\\'z\\') ;\\n    }\\n    \\n    bool isupper(char c){\\n        return (c>=\\'A\\' && c<=\\'Z\\') ;\\n    }\\n    bool isdig(char c){\\n        return (c>=\\'1\\' && c<=\\'9\\') ;\\n    }\\n    \\n    int cnt_min_repl(vector<int>& groups){\\n        int res =0;\\n        for(int i : groups){\\n            res += i/3 ;\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int strongPasswordChecker(string pass) {\\n        /*\\n        count required inssertion\\n        ->lower?\\n        ->uppercase?\\n        ->digit\\n        \\n        req_insert = 0,1,2,3 \\n        \\n        count consective groups\\n        \\n        if there are groups of size > 2, we would have to \\n        -> remove extra char \\n        -> or add diff. char in the middle (replacement/insertion)\\n        -> might have to totally remove a group, creating yet another diff. group\\n        \\n        (aaabbb)*8 -> length 48\\n        \\n        \\n        \\n        Which step to take\\n        ->depends on groups[]\\n        ->depend on current size of string too.\\n        ->depend on if insertions are req.\\n        \\n        \\n        \\n        -> If n < 6 \\n            you can just insert req. (type of char which aren\\'t there)\\n            and then make the length >= 6 somehow. \\n            you will be done.\\n            \\n        -> If n is in [6, 20]\\n            -> try to do replacements \\n            -> check groups [] \\n            ->      group size     2    3,4,5   6,7,8   9 \\n                replacement req.   0    1       2       3\\n            -> find total replacements req.\\n            -> ans = max(tot_repl, req_insert)\\n            \\n        -> If n > 20\\n            -> we need deletion (al least n-20 deletions)\\n            -> aaaaa -> aaaa -> aaa -> aa / aaaaa-> aa.aa -> aa.a\\n            -> aaa -> aa / aaa -> aa. -> a.\\n            -> decision of deletion and replacements.\\n            -> we might have to do the req. insertions\\n            -> might have to delete groups of size 2,1\\n            \\n            -> first delete and get size==20, \\n            -> in a way to be able to have min. replacement left to be done\\n            \\n            -> the do like case with n==20 (above)\\n            \\n            (ab)*25\\n            \\n            ???\\n            -> pick the groups with size%3==0 and delete one\\n            -> pick the groups with size%3==1 and delete two\\n            -> pick the group with size%3==2 .... delete three.\\n            -> keep doing till all groups of size >=3 goes away,\\n            -> or string become of size==20\\n            \\n            -> we won\\'t like to delete groups with size<=2\\n            -> there can be at most 16 groups of size >=3 \\n            -> first make all groups size <=2 or make total size==20\\n            -> if all groups are of size<=2, there exist a strategy to \\n                just delete n-20 character and not letting any new group form \\n                \\'by unintentional merging\\'.\\n            -> then do the req. char insertions by replacement\\n        */\\n        \\n        int low_req = 1;\\n        int upper_req = 1;\\n        int dig_req = 1;\\n        int n = pass.size();\\n        \\n        vector<int> groups;\\n        \\n        int st=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(islower(pass[i])) low_req = 0;\\n            else if(isupper(pass[i])) upper_req = 0;\\n            else if(isdig(pass[i])) dig_req = 0;\\n            \\n            if(i==n-1 || pass[i+1]!=pass[st]){\\n                // current groups ends at i\\n                // st..i\\n                groups.push_back(i-st+1);\\n                \\n                // start a new group from i+1\\n                st=i+1;\\n            }            \\n        }\\n        \\n        int req_insert = low_req + upper_req + dig_req ;\\n        int ans = 0;\\n        \\n        if(n<6){\\n            ans = max(req_insert, 6-n) ;\\n        }\\n        else if(n>=6 && n<=20){\\n            // just replacements\\n            int req_repl = cnt_min_repl(groups);\\n            ans = max(req_repl, req_insert) ;\\n        }\\n        else{\\n            // do the deletions\\n            int m = groups.size();\\n            \\n            int deletions = 0;\\n            int cur_delete = 0;\\n            int cur_delete_cnt = 0;\\n            \\n            while(n>20){\\n                cur_delete_cnt = 0;\\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==0\\n                    if(groups[i]>=3 && groups[i]%3==0){\\n                        groups[i]--;\\n                        deletions++;\\n                        n--;  // Mistake : didn\\'t decreased n\\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==1\\n                    if(groups[i]>=3 && groups[i]%3==1){\\n                        // can delete one of two depending on n\\n                        cur_delete = min(2, n-20) ;\\n                        deletions += cur_delete;\\n                        groups[i] -= cur_delete ;\\n                        \\n                        n-=cur_delete;\\n                        \\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                \\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==2\\n                    if(groups[i]>=3 && groups[i]%3==2){\\n                        // can delete one of two or three depending on n\\n                        cur_delete = min(3, n-20) ;\\n                        deletions += cur_delete;\\n                        groups[i] -= cur_delete ;\\n                        n-=cur_delete;\\n                        \\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                \\n                if(cur_delete_cnt == 0){\\n                    break;\\n                }\\n                \\n            }\\n            \\n            // now either there are no groups of size >=3 and n>20 still\\n            // or there are some, but n==20\\n            int req_repl = cnt_min_repl(groups);\\n            \\n            //if(dm) trace3(req_repl, n, deletions);\\n            \\n            assert(req_repl == 0 || n==20) ;\\n            \\n            // Mistake : forgot this\\n            if(n>20){\\n                assert(req_repl==0);\\n                deletions += n-20;\\n                n=20;\\n            }\\n            \\n            ans = deletions + max(req_repl, req_insert) ;\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#define dm 1\\n#define trace1(x) if(dm)cout<<(#x)<<\" \"<<(x)<<endl\\n#define trace2(x,y) if(dm)cout<<(#x)<<\" \"<<(x)<<\", \"<<(#y)<<\" \"<<(y)<<endl\\n#define trace3(x,y,z) if(dm)cout<<(#x)<<\" \"<<(x)<<\", \"<<(#y)<<\" \"<<(y)<<\", \"<<(#z)<<\" \"<<(z)<<endl\\n\\nclass Solution {\\nprivate :\\n    bool islower(char c){\\n        return (c>=\\'a\\' && c<=\\'z\\') ;\\n    }\\n    \\n    bool isupper(char c){\\n        return (c>=\\'A\\' && c<=\\'Z\\') ;\\n    }\\n    bool isdig(char c){\\n        return (c>=\\'1\\' && c<=\\'9\\') ;\\n    }\\n    \\n    int cnt_min_repl(vector<int>& groups){\\n        int res =0;\\n        for(int i : groups){\\n            res += i/3 ;\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int strongPasswordChecker(string pass) {\\n        /*\\n        count required inssertion\\n        ->lower?\\n        ->uppercase?\\n        ->digit\\n        \\n        req_insert = 0,1,2,3 \\n        \\n        count consective groups\\n        \\n        if there are groups of size > 2, we would have to \\n        -> remove extra char \\n        -> or add diff. char in the middle (replacement/insertion)\\n        -> might have to totally remove a group, creating yet another diff. group\\n        \\n        (aaabbb)*8 -> length 48\\n        \\n        \\n        \\n        Which step to take\\n        ->depends on groups[]\\n        ->depend on current size of string too.\\n        ->depend on if insertions are req.\\n        \\n        \\n        \\n        -> If n < 6 \\n            you can just insert req. (type of char which aren\\'t there)\\n            and then make the length >= 6 somehow. \\n            you will be done.\\n            \\n        -> If n is in [6, 20]\\n            -> try to do replacements \\n            -> check groups [] \\n            ->      group size     2    3,4,5   6,7,8   9 \\n                replacement req.   0    1       2       3\\n            -> find total replacements req.\\n            -> ans = max(tot_repl, req_insert)\\n            \\n        -> If n > 20\\n            -> we need deletion (al least n-20 deletions)\\n            -> aaaaa -> aaaa -> aaa -> aa / aaaaa-> aa.aa -> aa.a\\n            -> aaa -> aa / aaa -> aa. -> a.\\n            -> decision of deletion and replacements.\\n            -> we might have to do the req. insertions\\n            -> might have to delete groups of size 2,1\\n            \\n            -> first delete and get size==20, \\n            -> in a way to be able to have min. replacement left to be done\\n            \\n            -> the do like case with n==20 (above)\\n            \\n            (ab)*25\\n            \\n            ???\\n            -> pick the groups with size%3==0 and delete one\\n            -> pick the groups with size%3==1 and delete two\\n            -> pick the group with size%3==2 .... delete three.\\n            -> keep doing till all groups of size >=3 goes away,\\n            -> or string become of size==20\\n            \\n            -> we won\\'t like to delete groups with size<=2\\n            -> there can be at most 16 groups of size >=3 \\n            -> first make all groups size <=2 or make total size==20\\n            -> if all groups are of size<=2, there exist a strategy to \\n                just delete n-20 character and not letting any new group form \\n                \\'by unintentional merging\\'.\\n            -> then do the req. char insertions by replacement\\n        */\\n        \\n        int low_req = 1;\\n        int upper_req = 1;\\n        int dig_req = 1;\\n        int n = pass.size();\\n        \\n        vector<int> groups;\\n        \\n        int st=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(islower(pass[i])) low_req = 0;\\n            else if(isupper(pass[i])) upper_req = 0;\\n            else if(isdig(pass[i])) dig_req = 0;\\n            \\n            if(i==n-1 || pass[i+1]!=pass[st]){\\n                // current groups ends at i\\n                // st..i\\n                groups.push_back(i-st+1);\\n                \\n                // start a new group from i+1\\n                st=i+1;\\n            }            \\n        }\\n        \\n        int req_insert = low_req + upper_req + dig_req ;\\n        int ans = 0;\\n        \\n        if(n<6){\\n            ans = max(req_insert, 6-n) ;\\n        }\\n        else if(n>=6 && n<=20){\\n            // just replacements\\n            int req_repl = cnt_min_repl(groups);\\n            ans = max(req_repl, req_insert) ;\\n        }\\n        else{\\n            // do the deletions\\n            int m = groups.size();\\n            \\n            int deletions = 0;\\n            int cur_delete = 0;\\n            int cur_delete_cnt = 0;\\n            \\n            while(n>20){\\n                cur_delete_cnt = 0;\\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==0\\n                    if(groups[i]>=3 && groups[i]%3==0){\\n                        groups[i]--;\\n                        deletions++;\\n                        n--;  // Mistake : didn\\'t decreased n\\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==1\\n                    if(groups[i]>=3 && groups[i]%3==1){\\n                        // can delete one of two depending on n\\n                        cur_delete = min(2, n-20) ;\\n                        deletions += cur_delete;\\n                        groups[i] -= cur_delete ;\\n                        \\n                        n-=cur_delete;\\n                        \\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                \\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==2\\n                    if(groups[i]>=3 && groups[i]%3==2){\\n                        // can delete one of two or three depending on n\\n                        cur_delete = min(3, n-20) ;\\n                        deletions += cur_delete;\\n                        groups[i] -= cur_delete ;\\n                        n-=cur_delete;\\n                        \\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                \\n                if(cur_delete_cnt == 0){\\n                    break;\\n                }\\n                \\n            }\\n            \\n            // now either there are no groups of size >=3 and n>20 still\\n            // or there are some, but n==20\\n            int req_repl = cnt_min_repl(groups);\\n            \\n            //if(dm) trace3(req_repl, n, deletions);\\n            \\n            assert(req_repl == 0 || n==20) ;\\n            \\n            // Mistake : forgot this\\n            if(n>20){\\n                assert(req_repl==0);\\n                deletions += n-20;\\n                n=20;\\n            }\\n            \\n            ans = deletions + max(req_repl, req_insert) ;\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1619856,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\nint lastdel,lasttwodel,lastthreedel=0;\\nint findRepitiveCount(string str, int n)\\n{\\n    int rep=1;\\n    int i=0;\\n    int j=i+1;\\n    int count=0;\\n\\n    while(i<n&&j<=n)\\n    {\\n        if(str[i]==str[j])\\n        {\\n            rep++;\\n            j++;\\n            if(rep%3==0)\\n            {\\n                count++;\\n            }\\n        }\\n        else\\n        {\\n            if(rep%3==0)\\n                lastdel++;\\n            else if(rep%3==1&&rep>3)\\n                lasttwodel++;\\n            else if(rep%3==2&&rep>3)\\n                lastthreedel++;\\n                \\n            rep=1;\\n            i=j++;\\n        }\\n    }\\n    return count;\\n}\\n\\n    \\n    int strongPasswordChecker(string str) {\\n    int n=str.length();\\n    int r=0;\\n    if(n>20)\\n    {\\n        r=n-20;\\n    }\\n    int rcount=findRepitiveCount(str, n);\\n    bool isDigit=false;\\n    bool isUpper=false;\\n    bool isSmall=false;\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(str[i]>=65&&str[i]<=90)\\n        {\\n            isUpper=true;\\n        }\\n        else if(str[i]>=97&&str[i]<=122)\\n        {\\n            isSmall=true;\\n        }\\n        else if(str[i]-\\'0\\'>=0&&str[i]-\\'0\\'<=9)\\n        {\\n            isDigit=true;\\n        }\\n    }\\n    \\n    if(!isUpper)\\n        count++;\\n    if(!isDigit)\\n        count++;\\n    if(!isSmall)\\n        count++;\\n        \\n    if(n<6)\\n    {\\n        int i=6-n;\\n        return max(count,i);\\n    }\\n\\n    rcount=rcount-min(r,lastdel);\\n    rcount=rcount-min(max(r-lastdel, 0), 2*lasttwodel)/2;\\n    rcount=rcount-min(max(r-lastdel-2*lasttwodel, 0),3*lastthreedel)/3;\\n    rcount=rcount-max(r-lastdel-2*lasttwodel-3*lastthreedel, 0) /3;\\n    count=r+max(rcount,count);\\n    return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint lastdel,lasttwodel,lastthreedel=0;\\nint findRepitiveCount(string str, int n)\\n{\\n    int rep=1;\\n    int i=0;\\n    int j=i+1;\\n    int count=0;\\n\\n    while(i<n&&j<=n)\\n    {\\n        if(str[i]==str[j])\\n        {\\n            rep++;\\n            j++;\\n            if(rep%3==0)\\n            {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1452989,
                "title": "30-lines-too-easy-no-any-lib-functions-used-0ms-5-5mb-c-c",
                "content": "```\\nint strongPasswordChecker(char* p) {\\n\\tint req = 7, len = 0, steps = 0, dels, repeatStrs = 0, mod0 = 0, mod1 = 0;\\n\\tfor (int counter; *p; p++, len++) {\\n\\t\\tif (*p >= \\'0\\' && *p <= \\'9\\')\\t\\t req &= 6;\\n\\t\\telse if (*p >= \\'A\\' && *p <= \\'Z\\') req &= 5;\\n\\t\\telse if (*p >= \\'a\\' && *p <= \\'z\\') req &= 3;\\n\\t\\tfor (counter = 1; *p == *(p + 1); counter++, p++, len++);\\n\\t\\tif (counter > 2) {\\n\\t\\t\\tif (counter % 3 == 0) mod0 ++;\\n\\t\\t\\telse if (counter % 3 == 1) mod1 ++;\\n\\t\\t\\trepeatStrs += (counter / 3);\\n\\t\\t}\\n\\t}\\n\\tif ((dels = len - 20) > 0) steps += dels;\\n\\treq = (req & 1) + ((req >> 1) & 1) + ((req >> 2) & 1);\\n\\tif (len < 6) return 6 - len > req ? 6 - len : req;\\n\\twhile (dels > 0 && mod0) {\\n\\t\\tdels -= 1;\\n\\t\\tmod0--;\\n\\t\\trepeatStrs--;\\n\\t}\\t\\n\\twhile (dels > 1 && mod1) {\\n\\t\\tdels -= 2;\\n\\t\\tmod1--;\\n\\t\\trepeatStrs--;\\n\\t}\\n\\twhile (dels > 2 && repeatStrs) {\\n\\t\\tdels -= 3;\\n\\t\\trepeatStrs--;\\n\\t}\\n\\treturn steps + repeatStrs > req ? repeatStrs : req;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint strongPasswordChecker(char* p) {\\n\\tint req = 7, len = 0, steps = 0, dels, repeatStrs = 0, mod0 = 0, mod1 = 0;\\n\\tfor (int counter; *p; p++, len++) {\\n\\t\\tif (*p >= \\'0\\' && *p <= \\'9\\')\\t\\t req &= 6;\\n\\t\\telse if (*p >= \\'A\\' && *p <= \\'Z\\') req &= 5;\\n\\t\\telse if (*p >= \\'a\\' && *p <= \\'z\\') req &= 3;\\n\\t\\tfor (counter = 1; *p == *(p + 1); counter++, p++, len++);\\n\\t\\tif (counter > 2) {\\n\\t\\t\\tif (counter % 3 == 0) mod0 ++;\\n\\t\\t\\telse if (counter % 3 == 1) mod1 ++;\\n\\t\\t\\trepeatStrs += (counter / 3);\\n\\t\\t}\\n\\t}\\n\\tif ((dels = len - 20) > 0) steps += dels;\\n\\treq = (req & 1) + ((req >> 1) & 1) + ((req >> 2) & 1);\\n\\tif (len < 6) return 6 - len > req ? 6 - len : req;\\n\\twhile (dels > 0 && mod0) {\\n\\t\\tdels -= 1;\\n\\t\\tmod0--;\\n\\t\\trepeatStrs--;\\n\\t}\\t\\n\\twhile (dels > 1 && mod1) {\\n\\t\\tdels -= 2;\\n\\t\\tmod1--;\\n\\t\\trepeatStrs--;\\n\\t}\\n\\twhile (dels > 2 && repeatStrs) {\\n\\t\\tdels -= 3;\\n\\t\\trepeatStrs--;\\n\\t}\\n\\treturn steps + repeatStrs > req ? repeatStrs : req;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383489,
                "title": "carefully-handcrafted-c-solution-100-faster",
                "content": "```\\n#include <iostream>\\n\\n// #define DEBUG\\n\\n#ifdef DEBUG\\n#define P(X)\\\\\\ncout << #X\": \" << (X) << endl;\\n#else\\n#define P(X)\\n#endif\\n\\nint AddViolation(const string& pw) {\\n    if(pw.size() < 6) { return 6-pw.size(); }\\n    return 0;\\n}\\n\\nint RemoveViolation(const string& pw) {\\n    if(pw.size() > 20) { return pw.size() - 20; }\\n    return 0;\\n}\\n\\n\\nint LCViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'a\\' && c <= \\'z\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nint UCViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'A\\' && c <= \\'Z\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nint DigViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'0\\' && c <= \\'9\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nvector<int> Sequences(const string& pw) {\\n    // Find all sequences of equal chars.\\n    vector<int> result;\\n    int ii = 1;\\n    int cur_rep = 1;\\n    while(ii < pw.size()) {\\n        if(pw[ii] == pw[ii-1]) {\\n            ++cur_rep;\\n        } else {\\n            // Just broke the current repetition.\\n            if(cur_rep >= 3) {\\n                result.push_back(cur_rep);\\n            }\\n            cur_rep = 1;\\n        }\\n        ++ii;\\n    }\\n    if(cur_rep >= 3) {\\n        result.push_back(cur_rep);\\n    }\\n    return result;\\n}\\n\\nint SequenceViolation(const string& pw, int change, int add, int remove) {\\n    auto sequences = Sequences(pw);\\n    \\n    auto remove_short_sequences = [&sequences] {\\n        sequences.erase(\\n            std::remove_if(sequences.begin(), sequences.end(), [](int s){ return s<3; }),\\n            sequences.end()\\n        );    \\n    };\\n    auto print_sequences = [&sequences] {\\n        for(int s : sequences) {\\n            cout << s << \", \";\\n        }\\n        cout << endl;\\n        return \"\";\\n    };\\n    \\n    remove_short_sequences();\\n    if(sequences.empty()) { return 0; }\\n    \\n    P(change)\\n    P(add)\\n    P(remove)\\n    \\n    for(auto sinit : sequences) {\\n        P(sinit)\\n    }\\n    \\n    // change\\n    P(\"change\")\\n    while(change > 0 && !sequences.empty()) {\\n        // sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return (a/2)%3 > (b/2)%3;});\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        int sorig = s-1;\\n        // int s1 = floor(sorig/2);\\n        int s1 = 2;\\n        int s2 = sorig - s1;\\n        s = s1;\\n        sequences.push_back(s2);\\n        --change;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after change\")\\n    P(print_sequences())\\n    \\n    // add\\n    P(\"add\")\\n    while(add > 0 && !sequences.empty()) {\\n        // sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return (a/2)%3 > (b/2)%3;});\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        int sorig = s;\\n        // int s1 = floor(sorig/2);\\n        int s1 = 2;\\n        int s2 = sorig - s1;\\n        s = s1;\\n        sequences.push_back(s2);\\n        --add;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after add\")\\n    P(print_sequences())\\n    \\n    // remove\\n    P(\"remove\")\\n    while(remove > 0 && !sequences.empty()) {\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        --s;\\n        --remove;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after remove\")\\n    P(print_sequences())\\n    \\n    \\n    int violation = 0;\\n    for(auto s : sequences) {\\n        violation += s/3;\\n    }\\n    \\n    return violation;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        P(password)\\n            \\n        int remove = RemoveViolation(password);\\n        int add = AddViolation(password);\\n        int lc = LCViolation(password);\\n        int uc = UCViolation(password);\\n        int dig = DigViolation(password);\\n        \\n        P(remove)\\n        P(add)\\n        P(lc)\\n        P(uc)\\n        P(dig)\\n        \\n        int changes = max(0, dig+lc+uc-add);\\n        int seq = SequenceViolation(password, changes, add, remove);\\n        \\n        P(changes)\\n        P(seq)\\n        P(remove)\\n        P(add)\\n\\n        return remove+add+changes+seq;\\n    }\\n};\\n```\\n\\nNot the prettiest code, but works. It\\'s based on counting the number of changes required to fix the trivial violations (lower case, upper case, digits, addition and removal) and figuring out how many of those you can use to fix the tricky sequence constraint violations.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#include <iostream>\\n\\n// #define DEBUG\\n\\n#ifdef DEBUG\\n#define P(X)\\\\\\ncout << #X\": \" << (X) << endl;\\n#else\\n#define P(X)\\n#endif\\n\\nint AddViolation(const string& pw) {\\n    if(pw.size() < 6) { return 6-pw.size(); }\\n    return 0;\\n}\\n\\nint RemoveViolation(const string& pw) {\\n    if(pw.size() > 20) { return pw.size() - 20; }\\n    return 0;\\n}\\n\\n\\nint LCViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'a\\' && c <= \\'z\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nint UCViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'A\\' && c <= \\'Z\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nint DigViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'0\\' && c <= \\'9\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nvector<int> Sequences(const string& pw) {\\n    // Find all sequences of equal chars.\\n    vector<int> result;\\n    int ii = 1;\\n    int cur_rep = 1;\\n    while(ii < pw.size()) {\\n        if(pw[ii] == pw[ii-1]) {\\n            ++cur_rep;\\n        } else {\\n            // Just broke the current repetition.\\n            if(cur_rep >= 3) {\\n                result.push_back(cur_rep);\\n            }\\n            cur_rep = 1;\\n        }\\n        ++ii;\\n    }\\n    if(cur_rep >= 3) {\\n        result.push_back(cur_rep);\\n    }\\n    return result;\\n}\\n\\nint SequenceViolation(const string& pw, int change, int add, int remove) {\\n    auto sequences = Sequences(pw);\\n    \\n    auto remove_short_sequences = [&sequences] {\\n        sequences.erase(\\n            std::remove_if(sequences.begin(), sequences.end(), [](int s){ return s<3; }),\\n            sequences.end()\\n        );    \\n    };\\n    auto print_sequences = [&sequences] {\\n        for(int s : sequences) {\\n            cout << s << \", \";\\n        }\\n        cout << endl;\\n        return \"\";\\n    };\\n    \\n    remove_short_sequences();\\n    if(sequences.empty()) { return 0; }\\n    \\n    P(change)\\n    P(add)\\n    P(remove)\\n    \\n    for(auto sinit : sequences) {\\n        P(sinit)\\n    }\\n    \\n    // change\\n    P(\"change\")\\n    while(change > 0 && !sequences.empty()) {\\n        // sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return (a/2)%3 > (b/2)%3;});\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        int sorig = s-1;\\n        // int s1 = floor(sorig/2);\\n        int s1 = 2;\\n        int s2 = sorig - s1;\\n        s = s1;\\n        sequences.push_back(s2);\\n        --change;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after change\")\\n    P(print_sequences())\\n    \\n    // add\\n    P(\"add\")\\n    while(add > 0 && !sequences.empty()) {\\n        // sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return (a/2)%3 > (b/2)%3;});\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        int sorig = s;\\n        // int s1 = floor(sorig/2);\\n        int s1 = 2;\\n        int s2 = sorig - s1;\\n        s = s1;\\n        sequences.push_back(s2);\\n        --add;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after add\")\\n    P(print_sequences())\\n    \\n    // remove\\n    P(\"remove\")\\n    while(remove > 0 && !sequences.empty()) {\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        --s;\\n        --remove;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after remove\")\\n    P(print_sequences())\\n    \\n    \\n    int violation = 0;\\n    for(auto s : sequences) {\\n        violation += s/3;\\n    }\\n    \\n    return violation;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        P(password)\\n            \\n        int remove = RemoveViolation(password);\\n        int add = AddViolation(password);\\n        int lc = LCViolation(password);\\n        int uc = UCViolation(password);\\n        int dig = DigViolation(password);\\n        \\n        P(remove)\\n        P(add)\\n        P(lc)\\n        P(uc)\\n        P(dig)\\n        \\n        int changes = max(0, dig+lc+uc-add);\\n        int seq = SequenceViolation(password, changes, add, remove);\\n        \\n        P(changes)\\n        P(seq)\\n        P(remove)\\n        P(add)\\n\\n        return remove+add+changes+seq;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1232978,
                "title": "2-hour-work-beat-100-not-clean",
                "content": "Here shares my solution without any further cleaning, which is exactly my thought process. The way the loops are written means this can usually be greatly simplified with some math.\\n\\nWhy so many downvote for the problem I guess this will be too stressful in an interview and the solution won\\'t help any other problem. The intuition at the beginning I pretty much wrote down in 3 minutes; going ahead to implement it is a gamble, and code 90 lines (less lines would require more time) in 40min? No. I didn\\'t clean the code so it is easier for you to understand the algorithm.\\n\\nKeep points,\\n1. How to handle missing character type? Keep a count (max 3) and decrease it with any operation (add/replace) that can fix a type. This way missing types are fixed while doing other operations so is optimal.\\n2. Which chars to delete? First delete 1 char from all 3k len seqs, then 2 chars from all 3k+1 len seqs, then the rest. Just draw it out in a code comment and you will see.\\n\\nProof of the greedy correctness? Too tiring not sure I can do it now.\\n\\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        // Greedy\\n        // 1. Find all consecutive chars.\\n        //    If total more than 20, delete till 2 or 20.\\n        //    If total is less than 6, insert after every 2, else replace the next one.\\n        // 2. Keep a count of above operations, that can cover missing types. If still missing, add till 6 then replace.\\n        // 3. If still less than 6. Add (however) till 6. If more than 20, remove (however) till 20.\\n        // Miss any case?\\n        \\n        int len = password.length();\\n        boolean seenLower = false;\\n        boolean seenUpper = false;\\n        boolean seenDigit = false;\\n        \\n        int ops = 0;\\n        \\n        List<Integer> tobreak = new ArrayList<>();\\n        \\n        Character prev = null;\\n        int cnt = 0;\\n        for (char c : password.toCharArray()) {\\n            if (\\'a\\' <= c && c <= \\'z\\') seenLower = true;\\n            if (\\'A\\' <= c && c <= \\'Z\\') seenUpper = true;\\n            if (\\'0\\' <= c && c <= \\'9\\') seenDigit = true;\\n            if (prev == null || c != prev) {\\n                if (cnt >= 3) {\\n                    if (len > 20 && cnt % 3 == 0) {\\n                        // delete 1 from aaaaaa\\n                        cnt--;\\n                        len--;\\n                        ops++;\\n                    }\\n                    if (cnt >= 3) tobreak.add(cnt);\\n                }\\n                prev = c;\\n                cnt = 1;\\n            } else {\\n                cnt++;\\n            }\\n        }\\n        if (cnt >= 3) {\\n            if (len > 20 && cnt % 3 == 0) {\\n                cnt--;\\n                len--;\\n                ops++;\\n            }\\n            if (cnt >= 3) tobreak.add(cnt);\\n        }\\n        \\n        int typeReq = 0;\\n        if (!seenLower) typeReq++;\\n        if (!seenUpper) typeReq++;\\n        if (!seenDigit) typeReq++;\\n        \\n        for (int i = 0; i < tobreak.size(); i++) { \\n            int c = tobreak.get(i);\\n            if (len > 21 && c % 3 == 1) {\\n                // delete 2 from aaaa\\n                len -= 2;\\n                c -= 2;\\n                ops += 2;\\n                tobreak.set(i, c);\\n            }\\n        }\\n        \\n        for (int c : tobreak) {            \\n            if (len > 20) {\\n                // aaaaa or it no longer matters\\n                int r = Math.min(len - 20, c - 2);\\n                len -= r;\\n                c -= r;\\n                ops += r;\\n            }\\n            \\n            while (c > 2 && len < 6) { // usually this loop can be replaced with math\\n                // add 1 char after every 2\\n                len++;\\n                c -= 2;\\n                ops++;\\n                typeReq--;\\n            }\\n            \\n            // replace every 3rd char\\n            ops += c / 3;\\n            typeReq -= c / 3;\\n        }\\n        \\n        if (len < 6) {\\n            ops += 6 - len;\\n            typeReq -= 6 - len;\\n        }\\n        if (len > 20) ops += len - 20;\\n        \\n        if (typeReq > 0) ops += typeReq;\\n        \\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        // Greedy\\n        // 1. Find all consecutive chars.\\n        //    If total more than 20, delete till 2 or 20.\\n        //    If total is less than 6, insert after every 2, else replace the next one.\\n        // 2. Keep a count of above operations, that can cover missing types. If still missing, add till 6 then replace.\\n        // 3. If still less than 6. Add (however) till 6. If more than 20, remove (however) till 20.\\n        // Miss any case?\\n        \\n        int len = password.length();\\n        boolean seenLower = false;\\n        boolean seenUpper = false;\\n        boolean seenDigit = false;\\n        \\n        int ops = 0;\\n        \\n        List<Integer> tobreak = new ArrayList<>();\\n        \\n        Character prev = null;\\n        int cnt = 0;\\n        for (char c : password.toCharArray()) {\\n            if (\\'a\\' <= c && c <= \\'z\\') seenLower = true;\\n            if (\\'A\\' <= c && c <= \\'Z\\') seenUpper = true;\\n            if (\\'0\\' <= c && c <= \\'9\\') seenDigit = true;\\n            if (prev == null || c != prev) {\\n                if (cnt >= 3) {\\n                    if (len > 20 && cnt % 3 == 0) {\\n                        // delete 1 from aaaaaa\\n                        cnt--;\\n                        len--;\\n                        ops++;\\n                    }\\n                    if (cnt >= 3) tobreak.add(cnt);\\n                }\\n                prev = c;\\n                cnt = 1;\\n            } else {\\n                cnt++;\\n            }\\n        }\\n        if (cnt >= 3) {\\n            if (len > 20 && cnt % 3 == 0) {\\n                cnt--;\\n                len--;\\n                ops++;\\n            }\\n            if (cnt >= 3) tobreak.add(cnt);\\n        }\\n        \\n        int typeReq = 0;\\n        if (!seenLower) typeReq++;\\n        if (!seenUpper) typeReq++;\\n        if (!seenDigit) typeReq++;\\n        \\n        for (int i = 0; i < tobreak.size(); i++) { \\n            int c = tobreak.get(i);\\n            if (len > 21 && c % 3 == 1) {\\n                // delete 2 from aaaa\\n                len -= 2;\\n                c -= 2;\\n                ops += 2;\\n                tobreak.set(i, c);\\n            }\\n        }\\n        \\n        for (int c : tobreak) {            \\n            if (len > 20) {\\n                // aaaaa or it no longer matters\\n                int r = Math.min(len - 20, c - 2);\\n                len -= r;\\n                c -= r;\\n                ops += r;\\n            }\\n            \\n            while (c > 2 && len < 6) { // usually this loop can be replaced with math\\n                // add 1 char after every 2\\n                len++;\\n                c -= 2;\\n                ops++;\\n                typeReq--;\\n            }\\n            \\n            // replace every 3rd char\\n            ops += c / 3;\\n            typeReq -= c / 3;\\n        }\\n        \\n        if (len < 6) {\\n            ops += 6 - len;\\n            typeReq -= 6 - len;\\n        }\\n        if (len > 20) ops += len - 20;\\n        \\n        if (typeReq > 0) ops += typeReq;\\n        \\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146366,
                "title": "java-1ms-greedy-solution",
                "content": "This is a good problem due to it\\'s complexity of dealing with interactions between 3 criteria, especially criteria 1 and 3\\n\\n**several observations:**\\n* adding characters to meet criteria 1 could take care of criteria 2 and 3 violations at the same time\\n* deleting characters to meet criteria 1 could take care of criteria 3 violation at the same time, but not 2\\n* replacing characters to meet criteria 3 could take care of criteria 2 at the same time, and vice versa\\n\\n**thus we choose to start from criteria 1 and try to take care of 2 and 3 as much as possible at the same time**\\n\\n\\n```java\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        char[] chars = password.toCharArray();\\n        int c1 = 1, c2 = 1, c3 = 1, n = chars.length;\\n        int start = 0, repeated = 0;\\n        PriorityQueue<Integer> repeats = new PriorityQueue<>(Comparator.comparingInt(a -> a % 3));\\n        for (int i = 0; i < chars.length; i++) {\\n            if (Character.isLowerCase(chars[i])) c1 = 0;\\n            if (Character.isDigit(chars[i])) c2 = 0;\\n            if (Character.isUpperCase(chars[i])) c3 = 0;\\n            if (chars[i] == chars[start]) {\\n                repeated++;\\n            } else {\\n                if (repeated > 2) repeats.offer(repeated);\\n\\t\\t\\t\\tstart = i;\\n                repeated = 1;\\n            }\\n        }\\n        if (repeated > 2) repeats.offer(repeated);\\n\\n        int result = 0;\\n        // eD1, eD2, eD3 is the edit distance to meet criteria 1, 2 and 3\\n        // when eD1 is negative: we need to add characters to the string\\n        // when eD1 is positive: we need to remove characters from the string\\n        int eD1 = n < 6 ? n - 6 : (n > 20 ? n - 20 : 0);\\n        int eD2 = c1 + c2 + c3;\\n        // eD3 will be calculated in the next if-else section due to its\\n        // interactions with eD1 and eD2\\n        int eD3 = 0;\\n\\n        // characters can be used to remove D1 and eD3 at the same time\\n        if (!repeats.isEmpty()) {\\n            if (eD1 > 0) {\\n                while (eD1 > 0 && !repeats.isEmpty()) {\\n                    int a = repeats.poll();\\n                    if (a - 1 > 2) repeats.offer(a - 1);\\n                    result++;\\n                    eD1--;\\n                }\\n            } else if (eD1 < 0) {\\n                eD1 = - eD1;\\n                while (eD1 > 0 && !repeats.isEmpty()) {\\n                    int a = repeats.poll();\\n                    if (a - 2 > 2) repeats.offer(a - 2);\\n                    if (eD2 > 0) eD2--;\\n                    result++;\\n                    eD1--;\\n                }\\n                eD1 = -eD1;\\n            }\\n            // taking care of the rest unmatched repeated strings, if there\\'s any\\n            while (!repeats.isEmpty()) {\\n                eD3 += repeats.poll() / 3;\\n            }\\n        }\\n\\n        // at this stage, at most one of eD1 and eD3 is non-zero\\n\\n        if (eD3 != 0) {\\n            result += Math.max(eD3, eD2);\\n            eD2 = 0;\\n        }\\n\\n        if (eD1 != 0) {\\n            result += eD1 < 0 ? Math.max(-eD1, eD2) : eD1 + eD2;\\n            eD2 = 0;\\n        }\\n\\n        if (eD2 != 0) {\\n            result += eD2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        char[] chars = password.toCharArray();\\n        int c1 = 1, c2 = 1, c3 = 1, n = chars.length;\\n        int start = 0, repeated = 0;\\n        PriorityQueue<Integer> repeats = new PriorityQueue<>(Comparator.comparingInt(a -> a % 3));\\n        for (int i = 0; i < chars.length; i++) {\\n            if (Character.isLowerCase(chars[i])) c1 = 0;\\n            if (Character.isDigit(chars[i])) c2 = 0;\\n            if (Character.isUpperCase(chars[i])) c3 = 0;\\n            if (chars[i] == chars[start]) {\\n                repeated++;\\n            } else {\\n                if (repeated > 2) repeats.offer(repeated);\\n\\t\\t\\t\\tstart = i;\\n                repeated = 1;\\n            }\\n        }\\n        if (repeated > 2) repeats.offer(repeated);\\n\\n        int result = 0;\\n        // eD1, eD2, eD3 is the edit distance to meet criteria 1, 2 and 3\\n        // when eD1 is negative: we need to add characters to the string\\n        // when eD1 is positive: we need to remove characters from the string\\n        int eD1 = n < 6 ? n - 6 : (n > 20 ? n - 20 : 0);\\n        int eD2 = c1 + c2 + c3;\\n        // eD3 will be calculated in the next if-else section due to its\\n        // interactions with eD1 and eD2\\n        int eD3 = 0;\\n\\n        // characters can be used to remove D1 and eD3 at the same time\\n        if (!repeats.isEmpty()) {\\n            if (eD1 > 0) {\\n                while (eD1 > 0 && !repeats.isEmpty()) {\\n                    int a = repeats.poll();\\n                    if (a - 1 > 2) repeats.offer(a - 1);\\n                    result++;\\n                    eD1--;\\n                }\\n            } else if (eD1 < 0) {\\n                eD1 = - eD1;\\n                while (eD1 > 0 && !repeats.isEmpty()) {\\n                    int a = repeats.poll();\\n                    if (a - 2 > 2) repeats.offer(a - 2);\\n                    if (eD2 > 0) eD2--;\\n                    result++;\\n                    eD1--;\\n                }\\n                eD1 = -eD1;\\n            }\\n            // taking care of the rest unmatched repeated strings, if there\\'s any\\n            while (!repeats.isEmpty()) {\\n                eD3 += repeats.poll() / 3;\\n            }\\n        }\\n\\n        // at this stage, at most one of eD1 and eD3 is non-zero\\n\\n        if (eD3 != 0) {\\n            result += Math.max(eD3, eD2);\\n            eD2 = 0;\\n        }\\n\\n        if (eD1 != 0) {\\n            result += eD1 < 0 ? Math.max(-eD1, eD2) : eD1 + eD2;\\n            eD2 = 0;\\n        }\\n\\n        if (eD2 != 0) {\\n            result += eD2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098543,
                "title": "explain-with-python3",
                "content": "*  insert  lost types  >> supply shortage -> 6 chars\\n*  swap with lost type  >> swap repeated chars\\n*  remove surplus  -> 20 chars\\n*  * aaa -> aa.    repeats%3==0.  just avoid repeat \\n* * aaaa -> aa.   repeats%3==1.  remove more\\n*  * aaaaa -> aa.    repeats%3==2.    avoid any repeat \\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n=len(password)\\n        low,up,digit=0,0,0\\n\\n        last=\\'_\\'\\n        repeats=[]\\n        for i in range(n):\\n            x=password[i]\\n            if x==last:\\n                repeats[-1]+=1\\n            else:\\n                last=x\\n                repeats.append(1)\\n        \\n            if ord(\\'a\\')<=ord(x)<=ord(\\'z\\'):\\n                low+=1\\n            if ord(\\'A\\')<=ord(x)<=ord(\\'Z\\'):\\n                up+=1\\n            if ord(\\'0\\')<=ord(x)<=ord(\\'9\\'):\\n                digit+=1\\n        \\n        types=0  # types  to be needed\\n        if low==0:\\n            types+=1\\n        if up==0:\\n            types+=1\\n        if digit==0:\\n            types+=1\\n        print(types,n,repeats)\\n        \\n        if n<6:\\n            return max(6-n,types)\\n        elif n<=20:\\n            swaps=sum( [x//3 for x in repeats]  )\\n            return max(swaps,types)\\n        else:\\n            surplus=n-20\\n            m=len(repeats)\\n            for i in range(m):\\n                if surplus>=1 and repeats[i]%3==0:\\n                    repeats[i]-=1\\n                    surplus-=1\\n            for i in range(m):\\n                if surplus>=2 and repeats[i]>=3 and repeats[i]%3==1:\\n                    repeats[i]-=2\\n                    surplus-=2\\n            for i in range(m):\\n                if surplus>0 and repeats[i]>=3 :\\n                    removed=min(repeats[i]-2,surplus)\\n                    repeats[i]-=removed\\n                    surplus-=removed\\n            swaps=sum( [x//3 for x in repeats]  )\\n            print(surplus,swaps,repeats)\\n            return n-20+max(swaps,types)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n=len(password)\\n        low,up,digit=0,0,0\\n\\n        last=\\'_\\'\\n        repeats=[]\\n        for i in range(n):\\n            x=password[i]\\n            if x==last:\\n                repeats[-1]+=1\\n            else:\\n                last=x\\n                repeats.append(1)\\n        \\n            if ord(\\'a\\')<=ord(x)<=ord(\\'z\\'):\\n                low+=1\\n            if ord(\\'A\\')<=ord(x)<=ord(\\'Z\\'):\\n                up+=1\\n            if ord(\\'0\\')<=ord(x)<=ord(\\'9\\'):\\n                digit+=1\\n        \\n        types=0  # types  to be needed\\n        if low==0:\\n            types+=1\\n        if up==0:\\n            types+=1\\n        if digit==0:\\n            types+=1\\n        print(types,n,repeats)\\n        \\n        if n<6:\\n            return max(6-n,types)\\n        elif n<=20:\\n            swaps=sum( [x//3 for x in repeats]  )\\n            return max(swaps,types)\\n        else:\\n            surplus=n-20\\n            m=len(repeats)\\n            for i in range(m):\\n                if surplus>=1 and repeats[i]%3==0:\\n                    repeats[i]-=1\\n                    surplus-=1\\n            for i in range(m):\\n                if surplus>=2 and repeats[i]>=3 and repeats[i]%3==1:\\n                    repeats[i]-=2\\n                    surplus-=2\\n            for i in range(m):\\n                if surplus>0 and repeats[i]>=3 :\\n                    removed=min(repeats[i]-2,surplus)\\n                    repeats[i]-=removed\\n                    surplus-=removed\\n            swaps=sum( [x//3 for x in repeats]  )\\n            print(surplus,swaps,repeats)\\n            return n-20+max(swaps,types)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073363,
                "title": "0-ms-beats-100-c-solution-with-detailed-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    // 1. [6, 20] characters\\n    // 2. one lower case, one uppercase, one digit\\n    // 3. no 3 repeating characters\\n    int strongPasswordChecker(string password) {\\n        \\n        int cnt[3] = {0};\\n        \\n        if (password.size() <= 3) \\n            return 6 - password.size(); // inserstions only\\n\\n        for (int i = 0; i < password.size(); i++) {\\n            if (password[i] >= \\'a\\' && password[i] <= \\'z\\')\\n                cnt[0] = 1;\\n            else if (password[i] >= \\'A\\' && password[i] <= \\'Z\\')\\n                cnt[1] = 1;\\n            else if (password[i] >= \\'0\\' && password[i] <= \\'9\\')\\n                cnt[2] = 1;\\n        }\\n        \\n        int missing = 3 - (cnt[0] + cnt[1] + cnt[2]);\\n        \\n        if (password.size() == 4) {\\n            if (missing == 3)\\n                return 3;  // one replacement and two insertions\\n            return 2;      // two insertions\\n        }\\n        else if (password.size() == 5) {\\n            if (missing == 3)\\n                return 3; // two replacement, and one insertion\\n            else if (missing == 2)\\n                return 2; // one replacement, and one insertion\\n            else if (missing == 1)\\n                return 1; // one insertion;\\n            else\\n                return 1; // one insertion\\n        }\\n        else if (password.size() >= 6 && password.size() <= 20) { \\n            int i = 1;\\n            int replacements = 0;\\n            while(i < password.size()) {\\n                if (password[i] == password[i - 1]) {\\n                    int j = i - 1;\\n                    while(i < password.size() && password[i] == password[i - 1]) i++;\\n                    replacements += (i - j) / 3;\\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n            \\n            // when replacements > missing,  we can replace to isolate repeatings\\n            // when replacements <= missing, we need \"missing\" num of replacements to cover missings\\n            return max(replacements, missing);\\n        }\\n        else {\\n            // password.size() > 20\\n            int extra_cnt = password.size() - 20;\\n            int i = 1;\\n            int replacements = 0;\\n            int deleted = 0;\\n            vector<int> size_seq;\\n            while(i < password.size()) {\\n                if (password[i] == password[i - 1]) {\\n                    int j = i - 1;\\n                    while(i < password.size() && password[i] == password[i - 1]) i++;\\n                    int size = i - j;\\n                    if ((size % 3) == 0 && extra_cnt) { \\n                        // cover case of 3, 6, 9 ... \\n                        // if it is 3, only need delete one charater to avoid repeating\\n                        size --;\\n                        deleted ++;\\n                        extra_cnt --;\\n                    }\\n                    if (size >= 3) {\\n                        size_seq.push_back(size);\\n                    }\\n                    \\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n            \\n            for (int i = 0; i < size_seq.size() && extra_cnt >= 2; i++) {\\n                if (size_seq[i] > 3 && (size_seq[i] % 3) == 1) {\\n                    // cover case of 4, 7, 10 ...\\n                    // if it is 4, only need delete 2 charaters to avoid repeating\\n                    deleted += 2;\\n                    extra_cnt -= 2;\\n                    size_seq[i] -= 2;\\n                }\\n            }\\n            \\n            for (int i = 0; i < size_seq.size(); i++) {\\n                while (size_seq[i] >= 3 && extra_cnt >= 3) {\\n                    // for remaining cases, delete 3 characters each time\\n                    deleted += 3;\\n                    extra_cnt -= 3;\\n                    size_seq[i] -= 3;\\n                }\\n                replacements += size_seq[i] / 3;\\n            }\\n            \\n            // deleted , remaining extra cnt, max of replacements and missing\\n            return deleted + extra_cnt + max(replacements, missing);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    // 1. [6, 20] characters\\n    // 2. one lower case, one uppercase, one digit\\n    // 3. no 3 repeating characters\\n    int strongPasswordChecker(string password) {\\n        \\n        int cnt[3] = {0};\\n        \\n        if (password.size() <= 3) \\n            return 6 - password.size(); // inserstions only\\n\\n        for (int i = 0; i < password.size(); i++) {\\n            if (password[i] >= \\'a\\' && password[i] <= \\'z\\')\\n                cnt[0] = 1;\\n            else if (password[i] >= \\'A\\' && password[i] <= \\'Z\\')\\n                cnt[1] = 1;\\n            else if (password[i] >= \\'0\\' && password[i] <= \\'9\\')\\n                cnt[2] = 1;\\n        }\\n        \\n        int missing = 3 - (cnt[0] + cnt[1] + cnt[2]);\\n        \\n        if (password.size() == 4) {\\n            if (missing == 3)\\n                return 3;  // one replacement and two insertions\\n            return 2;      // two insertions\\n        }\\n        else if (password.size() == 5) {\\n            if (missing == 3)\\n                return 3; // two replacement, and one insertion\\n            else if (missing == 2)\\n                return 2; // one replacement, and one insertion\\n            else if (missing == 1)\\n                return 1; // one insertion;\\n            else\\n                return 1; // one insertion\\n        }\\n        else if (password.size() >= 6 && password.size() <= 20) { \\n            int i = 1;\\n            int replacements = 0;\\n            while(i < password.size()) {\\n                if (password[i] == password[i - 1]) {\\n                    int j = i - 1;\\n                    while(i < password.size() && password[i] == password[i - 1]) i++;\\n                    replacements += (i - j) / 3;\\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n            \\n            // when replacements > missing,  we can replace to isolate repeatings\\n            // when replacements <= missing, we need \"missing\" num of replacements to cover missings\\n            return max(replacements, missing);\\n        }\\n        else {\\n            // password.size() > 20\\n            int extra_cnt = password.size() - 20;\\n            int i = 1;\\n            int replacements = 0;\\n            int deleted = 0;\\n            vector<int> size_seq;\\n            while(i < password.size()) {\\n                if (password[i] == password[i - 1]) {\\n                    int j = i - 1;\\n                    while(i < password.size() && password[i] == password[i - 1]) i++;\\n                    int size = i - j;\\n                    if ((size % 3) == 0 && extra_cnt) { \\n                        // cover case of 3, 6, 9 ... \\n                        // if it is 3, only need delete one charater to avoid repeating\\n                        size --;\\n                        deleted ++;\\n                        extra_cnt --;\\n                    }\\n                    if (size >= 3) {\\n                        size_seq.push_back(size);\\n                    }\\n                    \\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n            \\n            for (int i = 0; i < size_seq.size() && extra_cnt >= 2; i++) {\\n                if (size_seq[i] > 3 && (size_seq[i] % 3) == 1) {\\n                    // cover case of 4, 7, 10 ...\\n                    // if it is 4, only need delete 2 charaters to avoid repeating\\n                    deleted += 2;\\n                    extra_cnt -= 2;\\n                    size_seq[i] -= 2;\\n                }\\n            }\\n            \\n            for (int i = 0; i < size_seq.size(); i++) {\\n                while (size_seq[i] >= 3 && extra_cnt >= 3) {\\n                    // for remaining cases, delete 3 characters each time\\n                    deleted += 3;\\n                    extra_cnt -= 3;\\n                    size_seq[i] -= 3;\\n                }\\n                replacements += size_seq[i] / 3;\\n            }\\n            \\n            // deleted , remaining extra cnt, max of replacements and missing\\n            return deleted + extra_cnt + max(replacements, missing);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060417,
                "title": "beats-100-java-solution",
                "content": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {   \\n        \\n     \\n        // first: we need to count how many types (lowercase, uppercase, digit) of characters are missing\\n        // second: we need to find how many repeated character set exist in the password\\n        \\n        int t1=0;\\n        int t2=0;\\n        int t3=0;\\n        \\n        int repeat=1;\\n        int triplet=0;\\n        \\n        ArrayList<Integer> repeated=new ArrayList<>(); // this will contain count of (more than 3) repeated character sets. \\n        \\n        int N=password.length();\\n        \\n        char prev=\\'=\\';\\n        for(int i=0 ;i <N ;i++)\\n        {\\n            char c=password.charAt(i);\\n            if(\\'A\\'<=c && c<=\\'Z\\')\\n            {\\n                t1=1;\\n            }\\n            if(\\'a\\'<=c && c<=\\'z\\')\\n            {\\n                t2=1;\\n            }\\n            if(\\'0\\'<=c && c<=\\'9\\')\\n            {\\n                t3=1;\\n            }\\n            \\n            if(prev==c)\\n            {\\n                repeat++;\\n            }else\\n            {                \\n                if(repeat>=3)repeated.add(repeat);\\n                repeat=1;\\n            }            \\n            prev=c;         \\n     \\n                \\n        }\\n        \\n        if(repeat>=3) repeated.add(repeat);        \\n        for(int r: repeated)\\n        {\\n            triplet+=r/3;\\n        }\\n\\n        int missting_type=3-t1-t2-t3; // the number of types missing in password\\n        \\n        \\n        // case 1 if the password length is less than 6\\n        // then you have to insert the remaining characters\\n        // newly inserted character should cover the missing types\\n        // for example if you get \"aaa\" then you can add three characters A,B,1 interleving with a. so repeating is not a matter in this case.\\n        if(N<6)\\n        {\\n            int insert= 6-N;            \\n            return Math.max(missting_type, insert);\\n        }\\n        \\n        \\n        // case 2: you need to replace character in case you have missing type and/or repeated charcter. \\n        // no need to insert or delete.\\n        if(N>=6 && N<=20)\\n        {\\n            \\n            return Math.max(missting_type, triplet);\\n        }\\n        \\n        \\n\\n        // case 3: the length is more than 20. You must delete at least N-20 character\\n        // you must delete wisely so that the number repeated trippled is minimum.\\n        // so you delete the character which has minimum remainder (%3). (for example, if you have 5As and 6Bs, you should remove from B, thats because if you remove from A the number of tripplets are still 1 for A, but if you remove from B then the number of tripplets is reduced to 1 from 2)\\n        \\n        Integer [] REPEATED=repeated.toArray(new Integer[repeated.size()]);\\n        int deleteno=N-20;\\n        \\n   //     System.out.println(repeated);\\n        \\n  \\n        while(deleteno>0)\\n        {\\n            int min_rem=3;\\n            int min_i=0;\\n            boolean changed=false;\\n            for(int i=0; i<REPEATED.length; i++)\\n            {\\n                int rem=REPEATED[i]%3;\\n                \\n                if(rem<min_rem && REPEATED[i]>2) // you do not need to delete a character if it becomes 2 (not a tripplet)\\n                {\\n                    min_i=i;\\n                    min_rem=rem;\\n                    changed=true;\\n                }\\n            }\\n            \\n            if(!changed) break;\\n            REPEATED[min_i]--;\\n            deleteno--;            \\n\\n        }\\n        \\n        triplet=0;\\n        for(int r: REPEATED)\\n        {\\n           // System.out.print(r+\" \");\\n            triplet+=r/3;\\n        }\\n        \\n        int replace=Math.max(missting_type, triplet);\\n           \\n        return replace+(N-20);\\n  \\n        \\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {   \\n        \\n     \\n        // first: we need to count how many types (lowercase, uppercase, digit) of characters are missing\\n        // second: we need to find how many repeated character set exist in the password\\n        \\n        int t1=0;\\n        int t2=0;\\n        int t3=0;\\n        \\n        int repeat=1;\\n        int triplet=0;\\n        \\n        ArrayList<Integer> repeated=new ArrayList<>(); // this will contain count of (more than 3) repeated character sets. \\n        \\n        int N=password.length();\\n        \\n        char prev=\\'=\\';\\n        for(int i=0 ;i <N ;i++)\\n        {\\n            char c=password.charAt(i);\\n            if(\\'A\\'<=c && c<=\\'Z\\')\\n            {\\n                t1=1;\\n            }\\n            if(\\'a\\'<=c && c<=\\'z\\')\\n            {\\n                t2=1;\\n            }\\n            if(\\'0\\'<=c && c<=\\'9\\')\\n            {\\n                t3=1;\\n            }\\n            \\n            if(prev==c)\\n            {\\n                repeat++;\\n            }else\\n            {                \\n                if(repeat>=3)repeated.add(repeat);\\n                repeat=1;\\n            }            \\n            prev=c;         \\n     \\n                \\n        }\\n        \\n        if(repeat>=3) repeated.add(repeat);        \\n        for(int r: repeated)\\n        {\\n            triplet+=r/3;\\n        }\\n\\n        int missting_type=3-t1-t2-t3; // the number of types missing in password\\n        \\n        \\n        // case 1 if the password length is less than 6\\n        // then you have to insert the remaining characters\\n        // newly inserted character should cover the missing types\\n        // for example if you get \"aaa\" then you can add three characters A,B,1 interleving with a. so repeating is not a matter in this case.\\n        if(N<6)\\n        {\\n            int insert= 6-N;            \\n            return Math.max(missting_type, insert);\\n        }\\n        \\n        \\n        // case 2: you need to replace character in case you have missing type and/or repeated charcter. \\n        // no need to insert or delete.\\n        if(N>=6 && N<=20)\\n        {\\n            \\n            return Math.max(missting_type, triplet);\\n        }\\n        \\n        \\n\\n        // case 3: the length is more than 20. You must delete at least N-20 character\\n        // you must delete wisely so that the number repeated trippled is minimum.\\n        // so you delete the character which has minimum remainder (%3). (for example, if you have 5As and 6Bs, you should remove from B, thats because if you remove from A the number of tripplets are still 1 for A, but if you remove from B then the number of tripplets is reduced to 1 from 2)\\n        \\n        Integer [] REPEATED=repeated.toArray(new Integer[repeated.size()]);\\n        int deleteno=N-20;\\n        \\n   //     System.out.println(repeated);\\n        \\n  \\n        while(deleteno>0)\\n        {\\n            int min_rem=3;\\n            int min_i=0;\\n            boolean changed=false;\\n            for(int i=0; i<REPEATED.length; i++)\\n            {\\n                int rem=REPEATED[i]%3;\\n                \\n                if(rem<min_rem && REPEATED[i]>2) // you do not need to delete a character if it becomes 2 (not a tripplet)\\n                {\\n                    min_i=i;\\n                    min_rem=rem;\\n                    changed=true;\\n                }\\n            }\\n            \\n            if(!changed) break;\\n            REPEATED[min_i]--;\\n            deleteno--;            \\n\\n        }\\n        \\n        triplet=0;\\n        for(int r: REPEATED)\\n        {\\n           // System.out.print(r+\" \");\\n            triplet+=r/3;\\n        }\\n        \\n        int replace=Math.max(missting_type, triplet);\\n           \\n        return replace+(N-20);\\n  \\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050841,
                "title": "68-ms-fastest-for-ts-js",
                "content": "It can be improved.\\n\\nLinks:\\n- [npm](https://www.npmjs.com/package/strong-password-checker)\\n- [github](https://github.com/d8corp/strong-password-checker)\\n\\n```\\nconst chars = [/[0-9]/, /[a-z]/, /[A-Z]/]\\n\\nfunction strongPasswordChecker (\\n  pass: string,\\n  minLength = 6,\\n  maxLength = 20,\\n  maxRepeat = 3,\\n  charConditions = chars\\n): number {\\n\\n  const {length} = pass\\n  const reduceIncreaseCount = length < minLength ? minLength - length : length > maxLength ? length - maxLength : 0\\n  const charConditionsResult = charConditions.map(() => false)\\n  const lengths = []\\n\\n  let replaceCharCount = charConditionsResult.length\\n  let replaceCount = 0\\n\\n  // temp variables\\n  let repeatLength = 1\\n  let oldChar\\n\\n  // going through password symbols\\n  for (let i = 0; i < length; i++) {\\n    // current symbol\\n    const char = pass[i]\\n\\n    // check character conditions\\n    if (replaceCharCount) {\\n      for (let j = 0; j < charConditionsResult.length; j++) {\\n        if (!charConditionsResult[j]) {\\n          if (charConditions[j].test(char)) {\\n            charConditionsResult[j] = true\\n            replaceCharCount--\\n          }\\n        }\\n      }\\n    }\\n\\n    if (oldChar === char) {\\n      if (++repeatLength % maxRepeat === 0) {\\n        replaceCount++\\n      }\\n    } else {\\n      lengths.push(repeatLength)\\n      repeatLength = 1\\n    }\\n\\n    oldChar = char\\n  }\\n\\n  lengths.push(repeatLength)\\n\\n  if (length < minLength) {\\n    return Math.max(reduceIncreaseCount, replaceCharCount)\\n  } else if (length > maxLength) {\\n    let reducer = reduceIncreaseCount\\n    let replacer = replaceCount\\n\\n    let changed = true\\n\\n    if (reducer && replacer) {\\n      loop: while (changed) {\\n        changed = false\\n\\n        for (let i = 0; i < maxRepeat && replacer; i++) {\\n          for (let j = 0; j < lengths.length && replacer; j++) {\\n            const len = lengths[j]\\n\\n            if (len >= maxRepeat && len % maxRepeat === i) {\\n              if (lengths[j] >= maxRepeat && reducer > i && reducer) {\\n                lengths[j] -= i + 1\\n                replacer--\\n                reducer -= i + 1\\n                changed = true\\n\\n                if (!reducer || !replacer) {\\n                  break loop\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return reduceIncreaseCount + Math.max(replacer, replaceCharCount)\\n  } else {\\n    return Math.max(reduceIncreaseCount, replaceCharCount, replaceCount)\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst chars = [/[0-9]/, /[a-z]/, /[A-Z]/]\\n\\nfunction strongPasswordChecker (\\n  pass: string,\\n  minLength = 6,\\n  maxLength = 20,\\n  maxRepeat = 3,\\n  charConditions = chars\\n): number {\\n\\n  const {length} = pass\\n  const reduceIncreaseCount = length < minLength ? minLength - length : length > maxLength ? length - maxLength : 0\\n  const charConditionsResult = charConditions.map(() => false)\\n  const lengths = []\\n\\n  let replaceCharCount = charConditionsResult.length\\n  let replaceCount = 0\\n\\n  // temp variables\\n  let repeatLength = 1\\n  let oldChar\\n\\n  // going through password symbols\\n  for (let i = 0; i < length; i++) {\\n    // current symbol\\n    const char = pass[i]\\n\\n    // check character conditions\\n    if (replaceCharCount) {\\n      for (let j = 0; j < charConditionsResult.length; j++) {\\n        if (!charConditionsResult[j]) {\\n          if (charConditions[j].test(char)) {\\n            charConditionsResult[j] = true\\n            replaceCharCount--\\n          }\\n        }\\n      }\\n    }\\n\\n    if (oldChar === char) {\\n      if (++repeatLength % maxRepeat === 0) {\\n        replaceCount++\\n      }\\n    } else {\\n      lengths.push(repeatLength)\\n      repeatLength = 1\\n    }\\n\\n    oldChar = char\\n  }\\n\\n  lengths.push(repeatLength)\\n\\n  if (length < minLength) {\\n    return Math.max(reduceIncreaseCount, replaceCharCount)\\n  } else if (length > maxLength) {\\n    let reducer = reduceIncreaseCount\\n    let replacer = replaceCount\\n\\n    let changed = true\\n\\n    if (reducer && replacer) {\\n      loop: while (changed) {\\n        changed = false\\n\\n        for (let i = 0; i < maxRepeat && replacer; i++) {\\n          for (let j = 0; j < lengths.length && replacer; j++) {\\n            const len = lengths[j]\\n\\n            if (len >= maxRepeat && len % maxRepeat === i) {\\n              if (lengths[j] >= maxRepeat && reducer > i && reducer) {\\n                lengths[j] -= i + 1\\n                replacer--\\n                reducer -= i + 1\\n                changed = true\\n\\n                if (!reducer || !replacer) {\\n                  break loop\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return reduceIncreaseCount + Math.max(replacer, replaceCharCount)\\n  } else {\\n    return Math.max(reduceIncreaseCount, replaceCharCount, replaceCount)\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041854,
                "title": "easy-c-solution-brief-and-concise",
                "content": "# Approach\\nSimplified and deeply refactored existing [C# Solution with Detailed Explanation](https://leetcode.com/problems/strong-password-checker/discuss/1000660/C-Solution-with-Detailed-Explanation)\\n\\n```\\npublic class Solution {\\n    private const int MIN_LENGTH = 6;\\n    private const int MAX_LENGTH = 20;\\n    private const int MAX_REPEAT_LENGTH = 3;\\n    private const int digit = 0;\\n    private const int lowercase = 1;\\n    private const int uppercase = 2;\\n    public class RepeatCount {\\n        public int Value;\\n    }\\n    \\n    public int StrongPasswordChecker(string password) {\\n        int[] bit = new [] { 1, 1, 1 };\\n        char prev = \\'\\\\0\\';\\n        int repeatCount = 1;\\n        var repeatCharCounts = new List<int>();\\n        foreach (char c in password) {\\n            if (char.IsDigit(c))\\n                bit[digit] = 0;\\n            else if (char.IsLetter(c) && char.IsLower(c)) \\n                bit[lowercase] = 0;\\n            else if (char.IsLetter(c) && char.IsUpper(c)) \\n                bit[uppercase] = 0;\\n            if (c == prev) {\\n                repeatCount++;\\n                continue;\\n            }\\n            if (repeatCount >= MAX_REPEAT_LENGTH)\\n                repeatCharCounts.Add(repeatCount);\\n            repeatCount = 1;\\n            prev = c;\\n        }\\n        \\n        if (repeatCount >= MAX_REPEAT_LENGTH)\\n            repeatCharCounts.Add(repeatCount);\\n        \\n        var q = new Queue<RepeatCount>(repeatCharCounts\\n                                       .OrderBy(x => x % MAX_REPEAT_LENGTH)\\n                                       .Select(x => new RepeatCount { Value = x }));\\n        int passwordCount = password.Length;\\n        if (passwordCount > MAX_LENGTH) {\\n            while (passwordCount-- > MAX_LENGTH && q.Count > 0) {\\n                var sequence = q.Peek();\\n                if (sequence.Value == MAX_REPEAT_LENGTH)\\n                    q.Dequeue();\\n                else if (sequence.Value % MAX_REPEAT_LENGTH == 0)\\n                    q.Enqueue(new RepeatCount { Value = q.Dequeue().Value - 1 });\\n                else\\n                    sequence.Value--;\\n            }            \\n        }\\n        \\n        int deletions = Math.Max(password.Length - MAX_LENGTH, 0);\\n        int repeatInsertsAndReplaces = q.Sum(x => x.Value / MAX_REPEAT_LENGTH);\\n        int requiredInsertsOrReplace = Math.Max(MIN_LENGTH - password.Length, bit.Sum());\\n        \\n        return Math.Max(requiredInsertsOrReplace, repeatInsertsAndReplaces) + deletions;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private const int MIN_LENGTH = 6;\\n    private const int MAX_LENGTH = 20;\\n    private const int MAX_REPEAT_LENGTH = 3;\\n    private const int digit = 0;\\n    private const int lowercase = 1;\\n    private const int uppercase = 2;\\n    public class RepeatCount {\\n        public int Value;\\n    }\\n    \\n    public int StrongPasswordChecker(string password) {\\n        int[] bit = new [] { 1, 1, 1 };\\n        char prev = \\'\\\\0\\';\\n        int repeatCount = 1;\\n        var repeatCharCounts = new List<int>();\\n        foreach (char c in password) {\\n            if (char.IsDigit(c))\\n                bit[digit] = 0;\\n            else if (char.IsLetter(c) && char.IsLower(c)) \\n                bit[lowercase] = 0;\\n            else if (char.IsLetter(c) && char.IsUpper(c)) \\n                bit[uppercase] = 0;\\n            if (c == prev) {\\n                repeatCount++;\\n                continue;\\n            }\\n            if (repeatCount >= MAX_REPEAT_LENGTH)\\n                repeatCharCounts.Add(repeatCount);\\n            repeatCount = 1;\\n            prev = c;\\n        }\\n        \\n        if (repeatCount >= MAX_REPEAT_LENGTH)\\n            repeatCharCounts.Add(repeatCount);\\n        \\n        var q = new Queue<RepeatCount>(repeatCharCounts\\n                                       .OrderBy(x => x % MAX_REPEAT_LENGTH)\\n                                       .Select(x => new RepeatCount { Value = x }));\\n        int passwordCount = password.Length;\\n        if (passwordCount > MAX_LENGTH) {\\n            while (passwordCount-- > MAX_LENGTH && q.Count > 0) {\\n                var sequence = q.Peek();\\n                if (sequence.Value == MAX_REPEAT_LENGTH)\\n                    q.Dequeue();\\n                else if (sequence.Value % MAX_REPEAT_LENGTH == 0)\\n                    q.Enqueue(new RepeatCount { Value = q.Dequeue().Value - 1 });\\n                else\\n                    sequence.Value--;\\n            }            \\n        }\\n        \\n        int deletions = Math.Max(password.Length - MAX_LENGTH, 0);\\n        int repeatInsertsAndReplaces = q.Sum(x => x.Value / MAX_REPEAT_LENGTH);\\n        int requiredInsertsOrReplace = Math.Max(MIN_LENGTH - password.Length, bit.Sum());\\n        \\n        return Math.Max(requiredInsertsOrReplace, repeatInsertsAndReplaces) + deletions;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965786,
                "title": "c-0ms-o-n",
                "content": "My C solution to Strong Password Checker, hard parts include counting the number of corrections if passwords exceed 20 characters in length.\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <ctype.h>\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int offences1 = 0;\\n    int offences2 = 0;\\n    int offences = 0;\\n    \\n    int r = 0;\\n    char prev = \\'\\\\n\\';\\n    char curr;\\n    int repC = 1;\\n    int delrep[3] = {0};\\n    int maxrep = 0;\\n    \\n    for(int i = 0; i < length; i++) {\\n        curr = password[i];\\n        if(curr == prev) {\\n            repC++;\\n        } else {\\n            if(repC >= 3) {\\n                delrep[repC%3]++;\\n            }\\n            repC = 1;\\n            prev = curr;\\n        }\\n        if(repC % 3 == 0) {\\n            r++;\\n        }\\n        if(repC > 3 && repC % 3 == 1) {\\n            delrep[2]++;\\n        }\\n    }\\n    if(repC >= 3) {\\n        delrep[repC%3]++;\\n    }\\n    \\n    \\n    int v = 0;\\n    int vo = 0;\\n    int lc = 0;\\n    int uc = 0;\\n    int dc = 0;\\n    for(int i = 0; i < length; i++) {\\n        if(lc == 0 && islower(password[i]) != 0) {\\n            v++;\\n            lc = 1;\\n        }\\n        if(uc == 0 && isupper(password[i]) != 0) {\\n            v++;\\n            uc = 1;\\n        }\\n        if(dc == 0 && isdigit(password[i]) != 0) {\\n            v++;\\n            dc = 1;\\n        }\\n    }\\n    \\n    if(v < 3) {\\n        offences2 += 3 - v;\\n        vo += 3 - v;\\n        if(length == 5 && v == 1) {\\n            offences1++;\\n        }\\n    }\\n\\n    if(length < 6 || length > 20) {\\n        int delete = length - 20;\\n        if(delrep[0] != 0) {\\n            delrep[0] = delrep[0] < delete ? delrep[0] : delete;\\n        }\\n        if(delrep[1] != 0) {\\n            delrep[1] = delrep[1] < (delete - delrep[0])/2 ? delrep[1] : (delete - delrep[0])/2;\\n        }\\n        if(delrep[2] != 0) {\\n            delrep[2] = delrep[2] < ((delete - delrep[0]) - delrep[1]*2)/3 ? delrep[2] : ((delete - delrep[0]) - delrep[1]*2)/3;\\n        }\\n        \\n        r-= delrep[0] + delrep[1] + delrep[2];   \\n        \\n        int x = r > offences2 ?  r : offences2;\\n        return length < 6 ? 6 - length + offences1 : delete + x; \\n    }\\n    \\n    return vo < r ? r : vo;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <ctype.h>\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int offences1 = 0;\\n    int offences2 = 0;\\n    int offences = 0;\\n    \\n    int r = 0;\\n    char prev = \\'\\\\n\\';\\n    char curr;\\n    int repC = 1;\\n    int delrep[3] = {0};\\n    int maxrep = 0;\\n    \\n    for(int i = 0; i < length; i++) {\\n        curr = password[i];\\n        if(curr == prev) {\\n            repC++;\\n        } else {\\n            if(repC >= 3) {\\n                delrep[repC%3]++;\\n            }\\n            repC = 1;\\n            prev = curr;\\n        }\\n        if(repC % 3 == 0) {\\n            r++;\\n        }\\n        if(repC > 3 && repC % 3 == 1) {\\n            delrep[2]++;\\n        }\\n    }\\n    if(repC >= 3) {\\n        delrep[repC%3]++;\\n    }\\n    \\n    \\n    int v = 0;\\n    int vo = 0;\\n    int lc = 0;\\n    int uc = 0;\\n    int dc = 0;\\n    for(int i = 0; i < length; i++) {\\n        if(lc == 0 && islower(password[i]) != 0) {\\n            v++;\\n            lc = 1;\\n        }\\n        if(uc == 0 && isupper(password[i]) != 0) {\\n            v++;\\n            uc = 1;\\n        }\\n        if(dc == 0 && isdigit(password[i]) != 0) {\\n            v++;\\n            dc = 1;\\n        }\\n    }\\n    \\n    if(v < 3) {\\n        offences2 += 3 - v;\\n        vo += 3 - v;\\n        if(length == 5 && v == 1) {\\n            offences1++;\\n        }\\n    }\\n\\n    if(length < 6 || length > 20) {\\n        int delete = length - 20;\\n        if(delrep[0] != 0) {\\n            delrep[0] = delrep[0] < delete ? delrep[0] : delete;\\n        }\\n        if(delrep[1] != 0) {\\n            delrep[1] = delrep[1] < (delete - delrep[0])/2 ? delrep[1] : (delete - delrep[0])/2;\\n        }\\n        if(delrep[2] != 0) {\\n            delrep[2] = delrep[2] < ((delete - delrep[0]) - delrep[1]*2)/3 ? delrep[2] : ((delete - delrep[0]) - delrep[1]*2)/3;\\n        }\\n        \\n        r-= delrep[0] + delrep[1] + delrep[2];   \\n        \\n        int x = r > offences2 ?  r : offences2;\\n        return length < 6 ? 6 - length + offences1 : delete + x; \\n    }\\n    \\n    return vo < r ? r : vo;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 948000,
                "title": "java-o-n-0ms",
                "content": "The only tricky case is when the password is longer than 20 characters. In that case, use the deletions to cut down on the number of replacements you\\'ll have to do. In order to accomplish that, first remove one from any subsequence of repeated characters of length 3, 6, 9, 12,.... That way, by removing just one from that subsequence, you\\'ve cut down on the number of replacements needed to break up the subsequence by 1. Then remove two from any subsequence of length 4, 7, 10, 13, .... Finally remove them three at a time from the rest of the subsequences. Of course, once it\\'s short enough, you can stop removing characters.\\n```\\nclass Solution {\\n\\n    public int strongPasswordChecker(String password) {\\n\\n        //First, look for subsequences of length 3 or more\\n        int[] tooLongFrequency = new int[50];\\n        int troublesomeLength = 3;\\n        int i = 0;\\n        while (i < password.length())\\n        {\\n\\n            int currentIndex = i + 1;\\n            while ((currentIndex < password.length()) && (password.charAt(currentIndex) == password.charAt(i)))\\n            {\\n                currentIndex++;\\n            }//while\\n            int subsequenceLength = currentIndex - i;\\n            if (subsequenceLength >= 3)\\n            {\\n                tooLongFrequency[subsequenceLength]++;\\n            }//if\\n\\n            i = currentIndex;\\n\\n        }//while\\n\\n        boolean hasLowerCase = false;\\n        boolean hasUpperCase = false;\\n        boolean hasDigit = false;\\n        for (i = 0; i < password.length(); i++)\\n        {\\n            if ((password.charAt(i) >= \\'a\\') && (password.charAt(i) <= \\'z\\'))\\n            {\\n                hasLowerCase = true;\\n            }//if\\n            else if ((password.charAt(i) >= \\'A\\') && (password.charAt(i) <= \\'Z\\'))\\n            {\\n                hasUpperCase = true;\\n            }//else if\\n            else if ((password.charAt(i) >= \\'0\\') && (password.charAt(i) <= \\'9\\'))\\n            {\\n                hasDigit = true;\\n            }//else if\\n        }//for\\n\\n        int numDifferentTypesNeeded = (hasLowerCase ? 0 : 1) + (hasUpperCase ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n        int minLength = 6;\\n        int maxLength = 20;\\n\\n        int numEdits = 0;\\n        if (password.length() < minLength)\\n        {\\n            //TODO: this is not true for the general case. If minLength were larger than 6, we might have to do some replacements.\\n            //For example, if minLength = 15, and the password were \"AAAAAAAAAAAAAA\" (14 As), we would have to do replacements to break up the subsequence of As.\\n            numEdits = Math.max(minLength - password.length(), numDifferentTypesNeeded);\\n        }//if\\n        else\\n        {\\n\\n            int numToRemove = 0;\\n            int numRemoved = 0;\\n            if (password.length() > maxLength)\\n            {\\n\\n                numToRemove = password.length() - maxLength;\\n                //If we have tooLongFrequency[i] for some i, we can remove some of those. We prioritize the ones that would make a difference regarding how\\n                //many we would have to replace in order to get rid of the sequence. That is, we have to replace floor(length / 3). So if removing\\n                //one would cut down on the number of replacements, let\\'s do that first. Then we take two away from those that that will help reduce our\\n                //number of replacements, and finally we take three away from the remaining ones. This is only while our length is still longer than maxLength, of course.\\n                for (int startValue = troublesomeLength; startValue < troublesomeLength * 2; startValue++)\\n                {\\n                    i = startValue;\\n                    while ((numRemoved < numToRemove) && (i < tooLongFrequency.length))\\n                    {\\n                        int numToRemoveFromEach = ((i % troublesomeLength) + 1);\\n                        boolean adjusted = false;\\n                        while ((tooLongFrequency[i] > 0) && (numRemoved < numToRemove))\\n                        {\\n                            int numToRemoveThisTime;\\n                            if (numToRemoveFromEach == troublesomeLength)\\n                            {\\n                                numToRemoveThisTime = Math.min(i - (troublesomeLength - 1), numToRemove - numRemoved);\\n                            }//if\\n                            else\\n                            {\\n                                numToRemoveThisTime = Math.min(numToRemove - numRemoved, numToRemoveFromEach);\\n                            }//else\\n                            tooLongFrequency[i]--;\\n                            tooLongFrequency[i - numToRemoveThisTime]++;\\n                            numRemoved += numToRemoveThisTime;\\n                            adjusted = true;\\n                        }//while\\n                        \\n                        i += troublesomeLength;\\n                    }//while\\n                }//for\\n\\n                numRemoved = numToRemove;\\n\\n            }//if\\n\\n            int numToReplace = 0;\\n            for (i = troublesomeLength; i < tooLongFrequency.length; i++)\\n            {\\n                numToReplace += (tooLongFrequency[i] * (i / troublesomeLength));\\n            }//for\\n            \\n            numEdits = numRemoved + Math.max(numToReplace, numDifferentTypesNeeded);\\n\\n        }//else\\n\\n        return numEdits;\\n\\n    }//strongPasswordChecker\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int strongPasswordChecker(String password) {\\n\\n        //First, look for subsequences of length 3 or more\\n        int[] tooLongFrequency = new int[50];\\n        int troublesomeLength = 3;\\n        int i = 0;\\n        while (i < password.length())\\n        {\\n\\n            int currentIndex = i + 1;\\n            while ((currentIndex < password.length()) && (password.charAt(currentIndex) == password.charAt(i)))\\n            {\\n                currentIndex++;\\n            }//while\\n            int subsequenceLength = currentIndex - i;\\n            if (subsequenceLength >= 3)\\n            {\\n                tooLongFrequency[subsequenceLength]++;\\n            }//if\\n\\n            i = currentIndex;\\n\\n        }//while\\n\\n        boolean hasLowerCase = false;\\n        boolean hasUpperCase = false;\\n        boolean hasDigit = false;\\n        for (i = 0; i < password.length(); i++)\\n        {\\n            if ((password.charAt(i) >= \\'a\\') && (password.charAt(i) <= \\'z\\'))\\n            {\\n                hasLowerCase = true;\\n            }//if\\n            else if ((password.charAt(i) >= \\'A\\') && (password.charAt(i) <= \\'Z\\'))\\n            {\\n                hasUpperCase = true;\\n            }//else if\\n            else if ((password.charAt(i) >= \\'0\\') && (password.charAt(i) <= \\'9\\'))\\n            {\\n                hasDigit = true;\\n            }//else if\\n        }//for\\n\\n        int numDifferentTypesNeeded = (hasLowerCase ? 0 : 1) + (hasUpperCase ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n        int minLength = 6;\\n        int maxLength = 20;\\n\\n        int numEdits = 0;\\n        if (password.length() < minLength)\\n        {\\n            //TODO: this is not true for the general case. If minLength were larger than 6, we might have to do some replacements.\\n            //For example, if minLength = 15, and the password were \"AAAAAAAAAAAAAA\" (14 As), we would have to do replacements to break up the subsequence of As.\\n            numEdits = Math.max(minLength - password.length(), numDifferentTypesNeeded);\\n        }//if\\n        else\\n        {\\n\\n            int numToRemove = 0;\\n            int numRemoved = 0;\\n            if (password.length() > maxLength)\\n            {\\n\\n                numToRemove = password.length() - maxLength;\\n                //If we have tooLongFrequency[i] for some i, we can remove some of those. We prioritize the ones that would make a difference regarding how\\n                //many we would have to replace in order to get rid of the sequence. That is, we have to replace floor(length / 3). So if removing\\n                //one would cut down on the number of replacements, let\\'s do that first. Then we take two away from those that that will help reduce our\\n                //number of replacements, and finally we take three away from the remaining ones. This is only while our length is still longer than maxLength, of course.\\n                for (int startValue = troublesomeLength; startValue < troublesomeLength * 2; startValue++)\\n                {\\n                    i = startValue;\\n                    while ((numRemoved < numToRemove) && (i < tooLongFrequency.length))\\n                    {\\n                        int numToRemoveFromEach = ((i % troublesomeLength) + 1);\\n                        boolean adjusted = false;\\n                        while ((tooLongFrequency[i] > 0) && (numRemoved < numToRemove))\\n                        {\\n                            int numToRemoveThisTime;\\n                            if (numToRemoveFromEach == troublesomeLength)\\n                            {\\n                                numToRemoveThisTime = Math.min(i - (troublesomeLength - 1), numToRemove - numRemoved);\\n                            }//if\\n                            else\\n                            {\\n                                numToRemoveThisTime = Math.min(numToRemove - numRemoved, numToRemoveFromEach);\\n                            }//else\\n                            tooLongFrequency[i]--;\\n                            tooLongFrequency[i - numToRemoveThisTime]++;\\n                            numRemoved += numToRemoveThisTime;\\n                            adjusted = true;\\n                        }//while\\n                        \\n                        i += troublesomeLength;\\n                    }//while\\n                }//for\\n\\n                numRemoved = numToRemove;\\n\\n            }//if\\n\\n            int numToReplace = 0;\\n            for (i = troublesomeLength; i < tooLongFrequency.length; i++)\\n            {\\n                numToReplace += (tooLongFrequency[i] * (i / troublesomeLength));\\n            }//for\\n            \\n            numEdits = numRemoved + Math.max(numToReplace, numDifferentTypesNeeded);\\n\\n        }//else\\n\\n        return numEdits;\\n\\n    }//strongPasswordChecker\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922384,
                "title": "solution-that-allows-more-varied-constraints-o-n-o-number-of-char-classes",
                "content": "Basically, allows you to set the min/max password length, the maximum number of repeated adjacent characters, a list of custom character sets (as well as allowing you to choose how many must be used). Pretty straightforward expansion of the given problem\\n\\n```java\\nclass Solution {\\n    static Set<Character> lowerCase = new HashSet<Character>();\\n    static Set<Character> upperCase = new HashSet<Character>();\\n    static Set<Character> digits = new HashSet<Character>();\\n    \\n    static{\\n        for(char c = \\'a\\';c<=\\'z\\';c++)\\n            lowerCase.add(c);\\n        for(char c = \\'A\\';c<=\\'Z\\';c++)\\n            upperCase.add(c);\\n        for(char c = \\'0\\';c<=\\'9\\';c++)\\n            digits.add(c);\\n    }\\n\\t\\n    // solution for specific case asked for by the problem\\n    public int strongPasswordChecker(String s){\\n        Set<Set<Character>> charClasses = new HashSet<Set<Character>>();\\n        charClasses.add(lowerCase);\\n        charClasses.add(upperCase);\\n        charClasses.add(digits);\\n        return strongPasswordChecker(s,2,6,20,charClasses,3);\\n    }\\n\\t// return minimum number of changes (replacements, additions, deletions) to make a String s a valid password\\n\\t// s is the password to be tested\\n\\t// maxStreak is the maximum number of adjacent identical characters allowed\\n\\t// minLen, maxLen are the length limits (inclusive)\\n\\t// charClasses contains sets, each of which describes a specific character class we want in the pwd\\n\\t// charSetsNeeded is the minimum number of charsets from charClasses that must appear in the pwd\\n    public int strongPasswordChecker(String s, int maxStreak, int minLen, int maxLen, Set<Set<Character>> charClasses, int charSetsNeeded) {\\n\\t\\tmaxStreak++;\\n        minLen = Math.max(charClasses.size(),minLen);\\n\\t\\tif(s==null || maxLen<minLen || maxStreak <= 1)\\n\\t\\t\\treturn -1;\\n        if(s.length() == 0)\\n            return minLen;\\n        \\n\\t\\tint n = s.length();\\n\\t\\tmaxStreak = Math.min(maxStreak,Math.min(maxLen+1,s.length()+1));\\n        int[] streakCts = new int[maxStreak];\\n        int missingGood = Math.min(n,maxLen);\\n        int i=0,j=0;\\n\\t\\tSet<Set<Character>> unusedCharClasses = new HashSet<Set<Character>>(charClasses);\\n\\t\\tSet<Set<Character>> removals = new HashSet<Set<Character>>();\\n\\t\\t\\n        while(i<n){\\n            char cur = s.charAt(i);\\n\\t\\t\\tfor(Set<Character> x:unusedCharClasses){\\n\\t\\t\\t\\tif(x.contains(cur))\\n\\t\\t\\t\\t\\tremovals.add(x);\\n\\t\\t\\t}\\n\\t\\t\\tunusedCharClasses.removeAll(removals);\\n\\t\\t\\tcharSetsNeeded -= removals.size();\\n\\t\\t\\tremovals.clear();\\n\\t\\t\\t\\n            while(j<n && s.charAt(j)==cur)\\n                j++;\\n\\n            missingGood -= Math.min(maxStreak-1,j-i);\\n            if(j-i>=maxStreak)\\n\\t\\t\\t\\tstreakCts[(j-i)%maxStreak]++;\\n            streakCts[maxStreak-1] += (j-i-maxStreak)/maxStreak;\\n            i=j;\\n        }\\n\\t\\tcharSetsNeeded = Math.max(charSetsNeeded,0); // could be negative if the user made it extra secure\\n\\t\\t\\n        if(n <= maxLen){ // we wont delete anything\\n\\t\\t\\tint addRepl = 0; // number of additions and replacements made\\n\\t\\t\\tfor(int x: streakCts) // it takes one addition or replacement to fix each of these\\n\\t\\t\\t\\taddRepl += x;\\n\\t\\t\\taddRepl = Math.max(charSetsNeeded,addRepl); // if we need more new charSets than we are making changes, add those here\\n\\t\\t\\tif(addRepl-streakCts[maxStreak-1]+n>= minLen) // by fixing the streaks/adding missing charsets, we now have enough chars\\n\\t\\t\\t\\treturn addRepl;\\n\\t\\t\\treturn minLen-n+streakCts[maxStreak-1]; // we need maxStreak[n-1] substitutions and (minLen-s.length()) additions\\n\\t\\t}\\n        // replace chars in streaks until we have enough good chars to make up the final string\\n        int replace = 0;\\n        for(int x=maxStreak-1;x>=0 && missingGood>0;x--){\\n            int val = Math.min((missingGood+x)/(x+1),streakCts[x]);\\n            replace += val;\\n            missingGood -= (x+1)*val;\\n        }\\n        // Math.max(charSetsNeeded,replace) is the number of replacements\\n        // n-maxLen is the number of deletions\\n        return Math.max(charSetsNeeded,replace)+n-maxLen;\\n    }\\n}\\n```\\nLet me know what you think.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    static Set<Character> lowerCase = new HashSet<Character>();\\n    static Set<Character> upperCase = new HashSet<Character>();\\n    static Set<Character> digits = new HashSet<Character>();\\n    \\n    static{\\n        for(char c = \\'a\\';c<=\\'z\\';c++)\\n            lowerCase.add(c);\\n        for(char c = \\'A\\';c<=\\'Z\\';c++)\\n            upperCase.add(c);\\n        for(char c = \\'0\\';c<=\\'9\\';c++)\\n            digits.add(c);\\n    }\\n\\t\\n    // solution for specific case asked for by the problem\\n    public int strongPasswordChecker(String s){\\n        Set<Set<Character>> charClasses = new HashSet<Set<Character>>();\\n        charClasses.add(lowerCase);\\n        charClasses.add(upperCase);\\n        charClasses.add(digits);\\n        return strongPasswordChecker(s,2,6,20,charClasses,3);\\n    }\\n\\t// return minimum number of changes (replacements, additions, deletions) to make a String s a valid password\\n\\t// s is the password to be tested\\n\\t// maxStreak is the maximum number of adjacent identical characters allowed\\n\\t// minLen, maxLen are the length limits (inclusive)\\n\\t// charClasses contains sets, each of which describes a specific character class we want in the pwd\\n\\t// charSetsNeeded is the minimum number of charsets from charClasses that must appear in the pwd\\n    public int strongPasswordChecker(String s, int maxStreak, int minLen, int maxLen, Set<Set<Character>> charClasses, int charSetsNeeded) {\\n\\t\\tmaxStreak++;\\n        minLen = Math.max(charClasses.size(),minLen);\\n\\t\\tif(s==null || maxLen<minLen || maxStreak <= 1)\\n\\t\\t\\treturn -1;\\n        if(s.length() == 0)\\n            return minLen;\\n        \\n\\t\\tint n = s.length();\\n\\t\\tmaxStreak = Math.min(maxStreak,Math.min(maxLen+1,s.length()+1));\\n        int[] streakCts = new int[maxStreak];\\n        int missingGood = Math.min(n,maxLen);\\n        int i=0,j=0;\\n\\t\\tSet<Set<Character>> unusedCharClasses = new HashSet<Set<Character>>(charClasses);\\n\\t\\tSet<Set<Character>> removals = new HashSet<Set<Character>>();\\n\\t\\t\\n        while(i<n){\\n            char cur = s.charAt(i);\\n\\t\\t\\tfor(Set<Character> x:unusedCharClasses){\\n\\t\\t\\t\\tif(x.contains(cur))\\n\\t\\t\\t\\t\\tremovals.add(x);\\n\\t\\t\\t}\\n\\t\\t\\tunusedCharClasses.removeAll(removals);\\n\\t\\t\\tcharSetsNeeded -= removals.size();\\n\\t\\t\\tremovals.clear();\\n\\t\\t\\t\\n            while(j<n && s.charAt(j)==cur)\\n                j++;\\n\\n            missingGood -= Math.min(maxStreak-1,j-i);\\n            if(j-i>=maxStreak)\\n\\t\\t\\t\\tstreakCts[(j-i)%maxStreak]++;\\n            streakCts[maxStreak-1] += (j-i-maxStreak)/maxStreak;\\n            i=j;\\n        }\\n\\t\\tcharSetsNeeded = Math.max(charSetsNeeded,0); // could be negative if the user made it extra secure\\n\\t\\t\\n        if(n <= maxLen){ // we wont delete anything\\n\\t\\t\\tint addRepl = 0; // number of additions and replacements made\\n\\t\\t\\tfor(int x: streakCts) // it takes one addition or replacement to fix each of these\\n\\t\\t\\t\\taddRepl += x;\\n\\t\\t\\taddRepl = Math.max(charSetsNeeded,addRepl); // if we need more new charSets than we are making changes, add those here\\n\\t\\t\\tif(addRepl-streakCts[maxStreak-1]+n>= minLen) // by fixing the streaks/adding missing charsets, we now have enough chars\\n\\t\\t\\t\\treturn addRepl;\\n\\t\\t\\treturn minLen-n+streakCts[maxStreak-1]; // we need maxStreak[n-1] substitutions and (minLen-s.length()) additions\\n\\t\\t}\\n        // replace chars in streaks until we have enough good chars to make up the final string\\n        int replace = 0;\\n        for(int x=maxStreak-1;x>=0 && missingGood>0;x--){\\n            int val = Math.min((missingGood+x)/(x+1),streakCts[x]);\\n            replace += val;\\n            missingGood -= (x+1)*val;\\n        }\\n        // Math.max(charSetsNeeded,replace) is the number of replacements\\n        // n-maxLen is the number of deletions\\n        return Math.max(charSetsNeeded,replace)+n-maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839004,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int hash(int lower,int upper,int digs, int count, int len, int i)\\n    {\\n        return digs | upper<<1 | lower<<2 | count<<3 | len<<8 | i<<16;\\n    }\\n    unordered_map<int,int> memo;\\n    int strongPasswordChecker(string s) {\\n        function<int(int,int,int,int,char,int,int)> dp=[&](int lower,int upper,int digs, int count, char prev, int len, int i)\\n        {\\n            int ans = 1000000;\\n            auto h = hash(lower,upper,digs,count,len,i);\\n            if(count>=3)\\n            {\\n                return ans;\\n            }\\n            else if(i>=s.size() && len>=6)\\n            {\\n                if(lower>0 && upper>0 && digs>0 && len<=20)\\n                    ans = 0;   \\n                return ans;\\n            }\\n            else if(memo.count(h)>0)\\n            {\\n                return memo[h];\\n            }\\n            if(i<s.size())\\n            {\\n                auto c = s[i];\\n                auto l = (c>=\\'a\\' && c<=\\'z\\')?1:lower;\\n                auto u = (c>=\\'A\\' && c<=\\'Z\\')?1:upper;\\n                auto d = (c>=\\'0\\' && c<=\\'9\\')?1:digs;\\n                auto cnt = (c!=prev)?1:count+1;\\n                // use char i\\n                ans = min(ans,dp(l,u,d,cnt,c,len+1,i+1));\\n                // remove char i\\n                ans = min(ans,1+dp(lower,upper,digs,count,prev,len,i+1));\\n                // replace char i\\n                ans = min(ans,1+dp(1,upper,digs ,0,0,len+1,i+1));\\n                ans = min(ans,1+dp(lower,1,digs ,0,0,len+1,i+1));\\n                ans = min(ans,1+dp(lower,upper,1,0,0,len+1,i+1));\\n            }\\n            if(len<6)\\n            {\\n                // insert\\n                ans = min(ans,1+dp(1,upper,digs ,0,0,len+1,i));\\n                ans = min(ans,1+dp(lower,1,digs ,0,0,len+1,i));\\n                ans = min(ans,1+dp(lower,upper,1,0,0,len+1,i));\\n            }\\n            memo[h] = ans;\\n            return ans;\\n        };\\n        \\n        return dp(0,0,0,0,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hash(int lower,int upper,int digs, int count, int len, int i)\\n    {\\n        return digs | upper<<1 | lower<<2 | count<<3 | len<<8 | i<<16;\\n    }\\n    unordered_map<int,int> memo;\\n    int strongPasswordChecker(string s) {\\n        function<int(int,int,int,int,char,int,int)> dp=[&](int lower,int upper,int digs, int count, char prev, int len, int i)\\n        {\\n            int ans = 1000000;\\n            auto h = hash(lower,upper,digs,count,len,i);\\n            if(count>=3)\\n            {\\n                return ans;\\n            }\\n            else if(i>=s.size() && len>=6)\\n            {\\n                if(lower>0 && upper>0 && digs>0 && len<=20)\\n                    ans = 0;   \\n                return ans;\\n            }\\n            else if(memo.count(h)>0)\\n            {\\n                return memo[h];\\n            }\\n            if(i<s.size())\\n            {\\n                auto c = s[i];\\n                auto l = (c>=\\'a\\' && c<=\\'z\\')?1:lower;\\n                auto u = (c>=\\'A\\' && c<=\\'Z\\')?1:upper;\\n                auto d = (c>=\\'0\\' && c<=\\'9\\')?1:digs;\\n                auto cnt = (c!=prev)?1:count+1;\\n                // use char i\\n                ans = min(ans,dp(l,u,d,cnt,c,len+1,i+1));\\n                // remove char i\\n                ans = min(ans,1+dp(lower,upper,digs,count,prev,len,i+1));\\n                // replace char i\\n                ans = min(ans,1+dp(1,upper,digs ,0,0,len+1,i+1));\\n                ans = min(ans,1+dp(lower,1,digs ,0,0,len+1,i+1));\\n                ans = min(ans,1+dp(lower,upper,1,0,0,len+1,i+1));\\n            }\\n            if(len<6)\\n            {\\n                // insert\\n                ans = min(ans,1+dp(1,upper,digs ,0,0,len+1,i));\\n                ans = min(ans,1+dp(lower,1,digs ,0,0,len+1,i));\\n                ans = min(ans,1+dp(lower,upper,1,0,0,len+1,i));\\n            }\\n            memo[h] = ans;\\n            return ans;\\n        };\\n        \\n        return dp(0,0,0,0,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795451,
                "title": "fastest-python-solution-8ms",
                "content": "This solution for me ran in 8ms, equalling the fastest submission. I think it is mostly a fluke, but if anyone has an explanation feel free to comment:\\n\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        def count_complexity(s):\\n        # lower case, upper case, digits\\n            tests = [\\n                not any(x.islower() for x in s),\\n                not any(x.isupper() for x in s),\\n                not any(x.isdigit() for x in s),\\n            ]\\n            return sum(tests)\\n\\n        def count_repeats(s):\\n            # more than 3 repeats\\n            all_counts = []\\n            count = 1\\n            previous = None\\n            for c in s:\\n                if c == previous:\\n                    count += 1\\n                else:\\n                    if count >= 3:\\n                        all_counts.append(count)\\n                    count = 1\\n                previous = c\\n            if count >= 3:\\n                all_counts.append(count)\\n            return all_counts\\n\\n        if len(s) <= 20:\\n            \\'replace repeats, add length, add complexities\\'\\n            fix_repeats = sum(c // 3 for c in count_repeats(s))\\n            return max(6-len(s), count_complexity(s), fix_repeats)\\n\\n        if len(s) > 20:\\n            \\'delete chars or repeats, replace for complexity\\'\\n            n_delete = len(s) - 20\\n            r = count_repeats(s)\\n            n = 0\\n            while n < n_delete:\\n                found = False\\n                for i in range(len(r)):\\n                    f = filter(lambda x: x >= 3, r)\\n                    if not f:\\n                        break\\n                    if r[i] == min(f, key=lambda x: x % 3):\\n                        found = True\\n                        r[i] -= 1\\n                        n += 1\\n                        if n >= n_delete:\\n                            break\\n                if not found:\\n                    break\\n            repeats_leftover = sum(c // 3 for c in r)\\n            return n_delete + max(repeats_leftover, count_complexity(s))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        def count_complexity(s):\\n        # lower case, upper case, digits\\n            tests = [\\n                not any(x.islower() for x in s),\\n                not any(x.isupper() for x in s),\\n                not any(x.isdigit() for x in s),\\n            ]\\n            return sum(tests)\\n\\n        def count_repeats(s):\\n            # more than 3 repeats\\n            all_counts = []\\n            count = 1\\n            previous = None\\n            for c in s:\\n                if c == previous:\\n                    count += 1\\n                else:\\n                    if count >= 3:\\n                        all_counts.append(count)\\n                    count = 1\\n                previous = c\\n            if count >= 3:\\n                all_counts.append(count)\\n            return all_counts\\n\\n        if len(s) <= 20:\\n            \\'replace repeats, add length, add complexities\\'\\n            fix_repeats = sum(c // 3 for c in count_repeats(s))\\n            return max(6-len(s), count_complexity(s), fix_repeats)\\n\\n        if len(s) > 20:\\n            \\'delete chars or repeats, replace for complexity\\'\\n            n_delete = len(s) - 20\\n            r = count_repeats(s)\\n            n = 0\\n            while n < n_delete:\\n                found = False\\n                for i in range(len(r)):\\n                    f = filter(lambda x: x >= 3, r)\\n                    if not f:\\n                        break\\n                    if r[i] == min(f, key=lambda x: x % 3):\\n                        found = True\\n                        r[i] -= 1\\n                        n += 1\\n                        if n >= n_delete:\\n                            break\\n                if not found:\\n                    break\\n            repeats_leftover = sum(c // 3 for c in r)\\n            return n_delete + max(repeats_leftover, count_complexity(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701035,
                "title": "c-solution",
                "content": "```\\n        public class Solution\\n        {\\n            public int StrongPasswordChecker(string s)\\n            {\\n                bool lower = false, upper = false, digit = false;\\n                Dictionary<int, int> lengthToCount = new Dictionary<int, int>();\\n                foreach (var charA in s)\\n                {\\n                    lower = Char.IsLower(charA) | lower;\\n                    upper = Char.IsUpper(charA) | upper;\\n                    digit = Char.IsDigit(charA) | digit;\\n\\n                    if (lower & upper & digit)\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                int replacesToBeMade = (lower ? 0 : 1) + (upper ? 0 : 1) + (digit ? 0 : 1);\\n                bool isLength = false;\\n                int length = 0;\\n                for (int i = 1; i < s.Length; i++)\\n                {\\n                    if (s[i] == s[i - 1])\\n                    {\\n                        if (!isLength)\\n                        {\\n                            isLength = true;\\n                            length = 2;\\n                        }\\n                        else\\n                        {\\n                            length++;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if (isLength)\\n                        {\\n                            isLength = false;\\n                            if (length >= 3)\\n                            {\\n                                if (!lengthToCount.ContainsKey(length))\\n                                {\\n                                    lengthToCount[length] = 0;\\n                                }\\n                                lengthToCount[length]++;\\n                            }\\n                            length = 0;\\n                        }\\n                    }\\n                }\\n\\n                if (isLength && length >= 3)\\n                {\\n                    if (!lengthToCount.ContainsKey(length))\\n                    {\\n                        lengthToCount[length] = 0;\\n                    }\\n                    lengthToCount[length]++;\\n                }\\n\\n                int toDelete = Math.Max(0, s.Length - 20);\\n                int toDeleteGen = Math.Max(0, s.Length - 20);\\n                int toReplaceGen = replacesToBeMade;\\n                int toAdd = Math.Max(6 - s.Length, 0);\\n\\n                if (toAdd > 0)\\n                {\\n                    if (lengthToCount.ContainsKey(5))\\n                    {\\n                        return 2;\\n                    }\\n\\n                    return toAdd;\\n                }\\n                var keysSorted = lengthToCount.Keys.ToArray();\\n                Array.Sort(keysSorted);\\n\\n                int totalToHandle = lengthToCount.Values.Sum();\\n                int handled = 0;\\n                foreach (var lengthSeq in keysSorted)\\n                {\\n                    for (int i = 0; i < lengthToCount[lengthSeq]; i++)\\n                    {\\n                        handled++;\\n                        if (totalToHandle == handled || toDelete <= 0 || keysSorted.Length == 1)\\n                        {\\n                            int toFixInReplace = lengthSeq / 3;\\n                            if (totalToHandle == handled)\\n                            {\\n                                toFixInReplace = (lengthSeq - toDelete) / 3;\\n                                toDelete = 0;\\n                            }\\n                            if (toFixInReplace <= replacesToBeMade || toDelete <= 0)\\n                            {\\n                                replacesToBeMade -= toFixInReplace;\\n                            }\\n                            else\\n                            {\\n                                toFixInReplace -= replacesToBeMade;\\n                                toDelete -= (lengthSeq - 3 * replacesToBeMade) - 3 + 1;\\n                                replacesToBeMade = 0;\\n                            }\\n                        }\\n                        else\\n                        {\\n                            toDelete -= lengthSeq - 3 + 1;\\n                        }\\n                    }\\n                }\\n                var done = toReplaceGen + Math.Max(0, (-1) * replacesToBeMade) + Math.Max(0, (-1) * toDelete) + toDeleteGen;\\n                return done;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution\\n        {\\n            public int StrongPasswordChecker(string s)\\n            {\\n                bool lower = false, upper = false, digit = false;\\n                Dictionary<int, int> lengthToCount = new Dictionary<int, int>();\\n                foreach (var charA in s)\\n                {\\n                    lower = Char.IsLower(charA) | lower;\\n                    upper = Char.IsUpper(charA) | upper;\\n                    digit = Char.IsDigit(charA) | digit;\\n\\n                    if (lower & upper & digit)\\n                    {\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 534390,
                "title": "heavy-scaring-accepted-c-solution-multi-dimensional-dp",
                "content": "dp[i,j,k,t] = possibility to make substring [0, i] of password valid with j removals, k additions and t replacements\\n\\n\\n```\\n    public class Solution\\n    {\\n\\n        public int StrongPasswordChecker(string s)\\n        {\\n            int digitsCount = 0;\\n            int lowerCaseCount = 0;\\n            int upperCaseCount = 0;\\n\\n\\n            foreach (var c in s)\\n            {\\n                if (c >= \\'0\\' && c <= \\'9\\')\\n                {\\n                    digitsCount++;\\n                    continue;\\n                }\\n\\n                if (c >= \\'a\\' && c <= \\'z\\')\\n                {\\n                    lowerCaseCount++;\\n                    continue;\\n                }\\n\\n                if (c >= \\'A\\' && c <= \\'Z\\')\\n                {\\n                    upperCaseCount++;\\n                }\\n            }\\n\\n            int requireToHave = 0;\\n\\n            if (digitsCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n            if (lowerCaseCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n            if (upperCaseCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n\\n            checked\\n            {\\n                int availableRemoves = Math.Max(0, s.Length - 6);\\n                int requiredRemoves = Math.Max(0, s.Length - 20);\\n\\n                int availableAdditions = Math.Max(0, 20 - s.Length);\\n                int requiredAdditions = Math.Max(0, 6 - s.Length);\\n\\n                bool[,,,] dp = new bool[s.Length + 1, availableRemoves + 1, availableAdditions + 1, s.Length + 1];\\n\\n                for (int lengthIdx = 0; lengthIdx <= s.Length; lengthIdx++)\\n                {\\n                    for (int removeIdx = 0; removeIdx <= availableRemoves; removeIdx++)\\n                    {\\n                        for (int addIdx = 0; addIdx <= availableAdditions; addIdx++)\\n                        {\\n                            for (int replacementIdx = 0; replacementIdx <= s.Length; replacementIdx++)\\n                            {\\n                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] = false;\\n\\n                                if (lengthIdx == 0)\\n                                {\\n                                    if (removeIdx == 0 && replacementIdx == 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] = true;\\n                                    }\\n                                    continue;\\n                                }\\n\\n\\n                                if (removeIdx + replacementIdx > lengthIdx)\\n                                {\\n                                    continue;\\n                                }\\n\\n\\n                                if (removeIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx - 1, addIdx, replacementIdx];\\n                                }\\n\\n                                if (addIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx - 1, replacementIdx];\\n                                }\\n\\n                                if (replacementIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx, replacementIdx - 1];\\n                                }\\n\\n                                \\n                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx, replacementIdx];\\n\\n                                int lastCharIdx = lengthIdx - 1;\\n                                for (int i = lengthIdx - 1; i > 0; i--)\\n                                {\\n                                    bool needToBreak = false;\\n                                    if (s[i - 1] == s[lastCharIdx])\\n                                    {\\n                                        var repeatingLength = lastCharIdx - (i - 1) + 1;\\n                                        if (repeatingLength == 3)\\n                                        {\\n                                            needToBreak = true;\\n                                        }\\n                                    }\\n                                    else\\n                                    {\\n                                        lastCharIdx = i - 1;\\n                                    }\\n\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx, replacementIdx];\\n\\n                                    if (removeIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx - 1, addIdx, replacementIdx];\\n                                    }\\n\\n                                    if (addIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx - 1, replacementIdx];\\n                                    }\\n\\n                                    if (replacementIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx, replacementIdx - 1];\\n                                    }\\n\\n                                    if (needToBreak)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] = false;\\n\\n                                        for (int j = i; j < lengthIdx; j++)\\n                                        {\\n                                            if (addIdx != 0)\\n                                            {\\n                                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[j - 1, removeIdx, addIdx - 1, replacementIdx];\\n                                            }\\n\\n                                            if (replacementIdx != 0)\\n                                            {\\n                                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[j - 1, removeIdx, addIdx, replacementIdx - 1];\\n                                            }\\n                                        }\\n\\n\\n                                        int idx = lastCharIdx;\\n                                        while (idx >= 0 && s[idx] == s[lastCharIdx])\\n                                        {\\n                                            idx--;\\n                                        }\\n                                        idx++;\\n                                        int repeatingCount = lastCharIdx - idx + 1;\\n                                        int removing = repeatingCount - 2;\\n\\n                                        if (removeIdx - removing >= 0)\\n                                        {\\n                                            dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[idx, removeIdx - removing, addIdx, replacementIdx];\\n\\n                                        }\\n\\n                                        break;\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n\\n                long res = int.MaxValue;\\n\\n                for (int removeIdx = requiredRemoves; removeIdx <= availableRemoves; removeIdx++)\\n                {\\n                    for (int addIdx = requiredAdditions; addIdx <= availableAdditions; addIdx++)\\n                    {\\n                        for (int replacementIdx = 0; replacementIdx <= s.Length; replacementIdx++)\\n                        {\\n                            if (dp[s.Length, removeIdx, addIdx, replacementIdx] && addIdx + replacementIdx >= requireToHave)\\n                            {\\n                                res = Math.Min(res,  removeIdx + addIdx + replacementIdx);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                return (int) res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public class Solution\\n    {\\n\\n        public int StrongPasswordChecker(string s)\\n        {\\n            int digitsCount = 0;\\n            int lowerCaseCount = 0;\\n            int upperCaseCount = 0;\\n\\n\\n            foreach (var c in s)\\n            {\\n                if (c >= \\'0\\' && c <= \\'9\\')\\n                {\\n                    digitsCount++;\\n                    continue;\\n                }\\n\\n                if (c >= \\'a\\' && c <= \\'z\\')\\n                {\\n                    lowerCaseCount++;\\n                    continue;\\n                }\\n\\n                if (c >= \\'A\\' && c <= \\'Z\\')\\n                {\\n                    upperCaseCount++;\\n                }\\n            }\\n\\n            int requireToHave = 0;\\n\\n            if (digitsCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n            if (lowerCaseCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n            if (upperCaseCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n\\n            checked\\n            {\\n                int availableRemoves = Math.Max(0, s.Length - 6);\\n                int requiredRemoves = Math.Max(0, s.Length - 20);\\n\\n                int availableAdditions = Math.Max(0, 20 - s.Length);\\n                int requiredAdditions = Math.Max(0, 6 - s.Length);\\n\\n                bool[,,,] dp = new bool[s.Length + 1, availableRemoves + 1, availableAdditions + 1, s.Length + 1];\\n\\n                for (int lengthIdx = 0; lengthIdx <= s.Length; lengthIdx++)\\n                {\\n                    for (int removeIdx = 0; removeIdx <= availableRemoves; removeIdx++)\\n                    {\\n                        for (int addIdx = 0; addIdx <= availableAdditions; addIdx++)\\n                        {\\n                            for (int replacementIdx = 0; replacementIdx <= s.Length; replacementIdx++)\\n                            {\\n                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] = false;\\n\\n                                if (lengthIdx == 0)\\n                                {\\n                                    if (removeIdx == 0 && replacementIdx == 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] = true;\\n                                    }\\n                                    continue;\\n                                }\\n\\n\\n                                if (removeIdx + replacementIdx > lengthIdx)\\n                                {\\n                                    continue;\\n                                }\\n\\n\\n                                if (removeIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx - 1, addIdx, replacementIdx];\\n                                }\\n\\n                                if (addIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx - 1, replacementIdx];\\n                                }\\n\\n                                if (replacementIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx, replacementIdx - 1];\\n                                }\\n\\n                                \\n                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx, replacementIdx];\\n\\n                                int lastCharIdx = lengthIdx - 1;\\n                                for (int i = lengthIdx - 1; i > 0; i--)\\n                                {\\n                                    bool needToBreak = false;\\n                                    if (s[i - 1] == s[lastCharIdx])\\n                                    {\\n                                        var repeatingLength = lastCharIdx - (i - 1) + 1;\\n                                        if (repeatingLength == 3)\\n                                        {\\n                                            needToBreak = true;\\n                                        }\\n                                    }\\n                                    else\\n                                    {\\n                                        lastCharIdx = i - 1;\\n                                    }\\n\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx, replacementIdx];\\n\\n                                    if (removeIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx - 1, addIdx, replacementIdx];\\n                                    }\\n\\n                                    if (addIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx - 1, replacementIdx];\\n                                    }\\n\\n                                    if (replacementIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx, replacementIdx - 1];\\n                                    }\\n\\n                                    if (needToBreak)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] = false;\\n\\n                                        for (int j = i; j < lengthIdx; j++)\\n                                        {\\n                                            if (addIdx != 0)\\n                                            {\\n                                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[j - 1, removeIdx, addIdx - 1, replacementIdx];\\n                                            }\\n\\n                                            if (replacementIdx != 0)\\n                                            {\\n                                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[j - 1, removeIdx, addIdx, replacementIdx - 1];\\n                                            }\\n                                        }\\n\\n\\n                                        int idx = lastCharIdx;\\n                                        while (idx >= 0 && s[idx] == s[lastCharIdx])\\n                                        {\\n                                            idx--;\\n                                        }\\n                                        idx++;\\n                                        int repeatingCount = lastCharIdx - idx + 1;\\n                                        int removing = repeatingCount - 2;\\n\\n                                        if (removeIdx - removing >= 0)\\n                                        {\\n                                            dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[idx, removeIdx - removing, addIdx, replacementIdx];\\n\\n                                        }\\n\\n                                        break;\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n\\n                long res = int.MaxValue;\\n\\n                for (int removeIdx = requiredRemoves; removeIdx <= availableRemoves; removeIdx++)\\n                {\\n                    for (int addIdx = requiredAdditions; addIdx <= availableAdditions; addIdx++)\\n                    {\\n                        for (int replacementIdx = 0; replacementIdx <= s.Length; replacementIdx++)\\n                        {\\n                            if (dp[s.Length, removeIdx, addIdx, replacementIdx] && addIdx + replacementIdx >= requireToHave)\\n                            {\\n                                res = Math.Min(res,  removeIdx + addIdx + replacementIdx);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                return (int) res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509488,
                "title": "golang",
                "content": "Damn. This problem must be banned from the interview. So hard to do.\\n```\\nhttps://leetcode.com/problems/strong-password-checker/discuss/91007/C%2B%2B-0ms-O(n)-35-lines-solution-with-detailed-explanation\\nfunc strongPasswordChecker(s string) int {\\n\\thasDigit, hasLowerCase, hasUpperCase := 0, 0, 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] <= \\'9\\' && s[i] >= \\'0\\' {\\n\\t\\t\\thasDigit = 1\\n\\t\\t}\\n\\t\\tif s[i] <= \\'z\\' && s[i] >= \\'a\\' {\\n\\t\\t\\thasLowerCase = 1\\n\\t\\t}\\n\\t\\tif s[i] <= \\'Z\\' && s[i] >= \\'A\\' {\\n\\t\\t\\thasUpperCase = 1\\n\\t\\t}\\n\\t}\\n\\n\\tneedChars := 3 - (hasDigit + hasLowerCase + hasUpperCase)\\n\\tif len(s) <= 4 {\\n\\t\\treturn 6 - len(s)\\n\\t}\\n\\n\\tif len(s) == 5 {\\n\\t\\treturn max(6-len(s), needChars)\\n\\t}\\n\\n\\ti := 0\\n\\tcountThreeRepeat := 0\\n\\tfor i < len(s) {\\n\\t\\tif i < len(s) && i+1 < len(s) && i+2 < len(s) &&\\n\\t\\t\\ts[i] == s[i+1] && s[i] == s[i+2] {\\n\\t\\t\\tcountThreeRepeat++\\n\\t\\t\\ti += 3\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\tfor len(s) >= 6 && len(s) <= 20 {\\n\\t\\treturn max(countThreeRepeat, needChars)\\n\\t}\\n\\n\\t// now len(s) > 20\\n\\tneedDelete := len(s) - 20\\n\\tresult := 0\\n\\tif needChars > 0 {\\n\\t\\tresult += needChars\\n\\t\\tcountThreeRepeat -= needChars\\n\\t}\\n\\n\\tif countThreeRepeat <= 0 || needDelete > 3*countThreeRepeat {\\n\\t\\tresult += needDelete\\n\\t\\treturn result\\n\\t}\\n\\n\\treturn mostComplicated(s, needChars)\\n}\\n\\nfunc mostComplicated(s string, needChars int) int {\\n\\tneedDelete := len(s) - 20\\n\\trepeat := []int{}\\n\\tidx := 0\\n\\tfor idx < len(s) {\\n\\t\\tj := idx\\n\\t\\tfor j < len(s) && s[idx] == s[j] {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t\\tcount := j - idx\\n\\t\\tif count > 2 {\\n\\t\\t\\trepeat = append(repeat, count)\\n\\t\\t}\\n\\t\\tidx = j\\n\\t}\\n\\n\\tresult := needChars\\n\\tfor i := 0; i < needChars; i++ {\\n\\t\\tsort.Ints(repeat)\\n\\t\\treplaced := false\\n\\t\\tfor k := 2; k >= 0; k-- {\\n\\t\\t\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\t\\t\\tif repeat[j] > 2 && repeat[j]%3 == k {\\n\\t\\t\\t\\t\\trepeat[j] -= 3\\n\\t\\t\\t\\t\\treplaced = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif replaced {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif replaced {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(repeat)\\n\\tfor needDelete > 0 {\\n\\t\\tbr := true\\n\\t\\tfor k := 0; k <= 2; k++ {\\n\\t\\t\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\t\\t\\tif repeat[j] > 2 && repeat[j]%3 == k && needDelete >= k+1 {\\n\\t\\t\\t\\t\\trepeat[j] -= (k + 1)\\n\\t\\t\\t\\t\\tneedDelete -= (k + 1)\\n\\t\\t\\t\\t\\tresult += (k + 1)\\n\\t\\t\\t\\t\\tbr = false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif br {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tresult += needDelete\\n\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\tresult += repeat[j] / 3\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nhttps://leetcode.com/problems/strong-password-checker/discuss/91007/C%2B%2B-0ms-O(n)-35-lines-solution-with-detailed-explanation\\nfunc strongPasswordChecker(s string) int {\\n\\thasDigit, hasLowerCase, hasUpperCase := 0, 0, 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] <= \\'9\\' && s[i] >= \\'0\\' {\\n\\t\\t\\thasDigit = 1\\n\\t\\t}\\n\\t\\tif s[i] <= \\'z\\' && s[i] >= \\'a\\' {\\n\\t\\t\\thasLowerCase = 1\\n\\t\\t}\\n\\t\\tif s[i] <= \\'Z\\' && s[i] >= \\'A\\' {\\n\\t\\t\\thasUpperCase = 1\\n\\t\\t}\\n\\t}\\n\\n\\tneedChars := 3 - (hasDigit + hasLowerCase + hasUpperCase)\\n\\tif len(s) <= 4 {\\n\\t\\treturn 6 - len(s)\\n\\t}\\n\\n\\tif len(s) == 5 {\\n\\t\\treturn max(6-len(s), needChars)\\n\\t}\\n\\n\\ti := 0\\n\\tcountThreeRepeat := 0\\n\\tfor i < len(s) {\\n\\t\\tif i < len(s) && i+1 < len(s) && i+2 < len(s) &&\\n\\t\\t\\ts[i] == s[i+1] && s[i] == s[i+2] {\\n\\t\\t\\tcountThreeRepeat++\\n\\t\\t\\ti += 3\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\tfor len(s) >= 6 && len(s) <= 20 {\\n\\t\\treturn max(countThreeRepeat, needChars)\\n\\t}\\n\\n\\t// now len(s) > 20\\n\\tneedDelete := len(s) - 20\\n\\tresult := 0\\n\\tif needChars > 0 {\\n\\t\\tresult += needChars\\n\\t\\tcountThreeRepeat -= needChars\\n\\t}\\n\\n\\tif countThreeRepeat <= 0 || needDelete > 3*countThreeRepeat {\\n\\t\\tresult += needDelete\\n\\t\\treturn result\\n\\t}\\n\\n\\treturn mostComplicated(s, needChars)\\n}\\n\\nfunc mostComplicated(s string, needChars int) int {\\n\\tneedDelete := len(s) - 20\\n\\trepeat := []int{}\\n\\tidx := 0\\n\\tfor idx < len(s) {\\n\\t\\tj := idx\\n\\t\\tfor j < len(s) && s[idx] == s[j] {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t\\tcount := j - idx\\n\\t\\tif count > 2 {\\n\\t\\t\\trepeat = append(repeat, count)\\n\\t\\t}\\n\\t\\tidx = j\\n\\t}\\n\\n\\tresult := needChars\\n\\tfor i := 0; i < needChars; i++ {\\n\\t\\tsort.Ints(repeat)\\n\\t\\treplaced := false\\n\\t\\tfor k := 2; k >= 0; k-- {\\n\\t\\t\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\t\\t\\tif repeat[j] > 2 && repeat[j]%3 == k {\\n\\t\\t\\t\\t\\trepeat[j] -= 3\\n\\t\\t\\t\\t\\treplaced = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif replaced {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif replaced {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(repeat)\\n\\tfor needDelete > 0 {\\n\\t\\tbr := true\\n\\t\\tfor k := 0; k <= 2; k++ {\\n\\t\\t\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\t\\t\\tif repeat[j] > 2 && repeat[j]%3 == k && needDelete >= k+1 {\\n\\t\\t\\t\\t\\trepeat[j] -= (k + 1)\\n\\t\\t\\t\\t\\tneedDelete -= (k + 1)\\n\\t\\t\\t\\t\\tresult += (k + 1)\\n\\t\\t\\t\\t\\tbr = false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif br {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tresult += needDelete\\n\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\tresult += repeat[j] / 3\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 474981,
                "title": "c-0ms-100-8-4mb-75",
                "content": "* Runtime: 0 ms, faster than 100.00% of C++ online submissions for Strong Password Checker.\\n* Memory Usage: 8.4 MB, less than 75.00% of C++ online submissions for Strong Password Checker.\\n\\nWoof, this solution is a dog. It\\'s not refined because I wasted too much time by jumping in without stepping through some test cases manually to make sure I knew what results I expected.\\n\\nThere\\'s room to reduce memory and computation time. But 80 lines that are simple enough I can understand them a year from now, that\\'s something too.\\n\\nFor passwords <=20 characters, the whole program can be simple. Don\\'t try to write a solution without first understanding the most complicated cases where deletion must be used carefully to return the fewest edits necessary.\\n\\nYou want to turn any \\'xxx\\' into \\'xx\\' first.\\nIf you are still required to make deletions, to satisfy the 20 character limit, then delete to turn \\'xxxx\\' into \\'xxx\\'. If necessary, the next deletion is to turn \\'xxx\\' into \\'xx\\', before deleting from any other 4/5/6/...-tuplets.\\n\\nThe easier part is just tallying all triplets, replacing /inserting one character from each.  That\\'s the answer, unless the number of missing characters and the number of missing required character-types is greater.\\n \\n\\n```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution {\\npublic:\\nint strongPasswordChecker(string s)\\n{\\n    bitset<3> requirements{111}; // 0:lowercase, 1:uppercase, 2:number\\n    list<int> repeats;           // store length of repeated character sequences\\n\\n    auto it = s.begin(); // 2 pointers to track length of repeated characters\\n    auto it2 = s.end();\\n    while (it != s.end())\\n    {\\n        if (*it != *it2) // TODO: skip checks when none left\\n        {\\n            if (requirements.test(0) && islower(*it))\\n                requirements.reset(0);\\n            if (requirements.test(1) && isupper(*it))\\n                requirements.reset(1);\\n            if (requirements.test(2) && isdigit(*it))\\n                requirements.reset(2);\\n        }\\n        else // fast forward through repeated characters\\n        {\\n            while (it != s.end() && *it == *it2)\\n                ++it;\\n\\n            if (distance(it2, it) != 2)\\n                repeats.push_back(distance(it2, it));\\n\\n            if (it != s.end())\\n                continue;\\n            else\\n                break;\\n        }\\n        it2 = it;\\n        ++it;\\n    }\\n    // sort all repeats. Runs of 3,6,9... at the front, followed by 4,7,10,... then 5,8,11...\\n    // to minimize deletes, just pick from the front\\n    repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); }); // while length>20 delete\\n    // while length<=20 replace\\n    // while length<6 insert\\n    int ans{0}, len{static_cast<int>(s.size())};\\n    while (len > 20)\\n    {\\n        if (!repeats.empty())\\n        {\\n            if (repeats.front() == 3)\\n            {\\n                repeats.pop_front();\\n            }\\n            else\\n            {\\n                --repeats.front();\\n                repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n            }\\n\\n            ++ans;\\n            --len;\\n        }\\n        else\\n        {\\n            ans += len - 20;\\n            len = 20;\\n        }\\n    }\\n\\n    // requirements: need min requirements.count() replace/inserts\\n    // triples: 1 replace for every repeats.top()/3 chars\\n    int rep_ins{0};\\n    while (!repeats.empty())\\n    {\\n        rep_ins += repeats.front() / 3;\\n        repeats.pop_front();\\n    }\\n\\n    if ((len + rep_ins) < 6)\\n    {\\n        rep_ins += 6 - len - rep_ins;\\n    }\\n    ans += max(static_cast<int>(requirements.count()), rep_ins);\\n\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution {\\npublic:\\nint strongPasswordChecker(string s)\\n{\\n    bitset<3> requirements{111}; // 0:lowercase, 1:uppercase, 2:number\\n    list<int> repeats;           // store length of repeated character sequences\\n\\n    auto it = s.begin(); // 2 pointers to track length of repeated characters\\n    auto it2 = s.end();\\n    while (it != s.end())\\n    {\\n        if (*it != *it2) // TODO: skip checks when none left\\n        {\\n            if (requirements.test(0) && islower(*it))\\n                requirements.reset(0);\\n            if (requirements.test(1) && isupper(*it))\\n                requirements.reset(1);\\n            if (requirements.test(2) && isdigit(*it))\\n                requirements.reset(2);\\n        }\\n        else // fast forward through repeated characters\\n        {\\n            while (it != s.end() && *it == *it2)\\n                ++it;\\n\\n            if (distance(it2, it) != 2)\\n                repeats.push_back(distance(it2, it));\\n\\n            if (it != s.end())\\n                continue;\\n            else\\n                break;\\n        }\\n        it2 = it;\\n        ++it;\\n    }\\n    // sort all repeats. Runs of 3,6,9... at the front, followed by 4,7,10,... then 5,8,11...\\n    // to minimize deletes, just pick from the front\\n    repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); }); // while length>20 delete\\n    // while length<=20 replace\\n    // while length<6 insert\\n    int ans{0}, len{static_cast<int>(s.size())};\\n    while (len > 20)\\n    {\\n        if (!repeats.empty())\\n        {\\n            if (repeats.front() == 3)\\n            {\\n                repeats.pop_front();\\n            }\\n            else\\n            {\\n                --repeats.front();\\n                repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n            }\\n\\n            ++ans;\\n            --len;\\n        }\\n        else\\n        {\\n            ans += len - 20;\\n            len = 20;\\n        }\\n    }\\n\\n    // requirements: need min requirements.count() replace/inserts\\n    // triples: 1 replace for every repeats.top()/3 chars\\n    int rep_ins{0};\\n    while (!repeats.empty())\\n    {\\n        rep_ins += repeats.front() / 3;\\n        repeats.pop_front();\\n    }\\n\\n    if ((len + rep_ins) < 6)\\n    {\\n        rep_ins += 6 - len - rep_ins;\\n    }\\n    ans += max(static_cast<int>(requirements.count()), rep_ins);\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460328,
                "title": "o-n-one-pass-simple-easy-to-understand-clean-code",
                "content": "```\\n// O(N) single-pass solution.\\n// Key is to recognise changes can simultaneously satisfy multiple conditions at the same time.\\n\\n#include <string>\\n\\nusing namespace std;\\n\\nconstexpr inline int maxlen = 20;\\nconstexpr inline int minlen = 6;\\n\\nclass Solution {\\npublic:    \\n    int strongPasswordChecker(string s) {\\n        int type1=0, type2=0, type3=0;\\n        \\n        char prev_char = 0;\\n        int cur_seq_len = 0;\\n        \\n        // A sequence is a contiguous series of the same char. \\n        // To fix a sequence to satisfy condition #3, we either delete chars from the sequence, insert chars or replace certain chars in the sequence.\\n        // The min # of chars to replace is floor(sequence_length / 3).\\n        // count_seq_mod[i] = # times we can delete (i+1) chars from any sequence so as to reduce the replacement count by 1\\n        int count_seq_mod[3] = {0};\\n        \\n        int replacements = 0;\\n        \\n        for (char c: s) {\\n            if (\\'a\\' <= c && c <= \\'z\\') type1=1;\\n            else if (\\'A\\' <= c && c<= \\'Z\\') type2=1;\\n            else if (\\'0\\' <= c&& c <= \\'9\\') type3=1;\\n            \\n            if (prev_char != c){\\n                if (cur_seq_len >= 3) {\\n                    if (cur_seq_len % 3 != 2)\\n                        count_seq_mod[cur_seq_len % 3]++;\\n                    \\n                    count_seq_mod[2] += (cur_seq_len - 2) / 3;\\n                }\\n                // we need this min # replacement to fix the sequence\\n                replacements += cur_seq_len / 3;\\n                cur_seq_len = 1;\\n            }\\n            else {\\n                cur_seq_len ++;\\n            }\\n            \\n            prev_char = c;\\n        }    \\n        \\n        // End the current sequence. \\n        if (cur_seq_len >= 3) {\\n            if (cur_seq_len % 3 != 2)\\n                count_seq_mod[cur_seq_len % 3]++;\\n\\n            count_seq_mod[2] += (cur_seq_len - 2) / 3;\\n        }\\n        replacements += cur_seq_len / 3;\\n        \\n        int type_count = type1+type2+type3;\\n        replacements = max(3 - type_count, replacements);\\n        \\n        if (s.size() < minlen){\\n            // Just need to insert or replace chars.\\n            // Inserting chars can be used instead of replacement to fix sequences and to fulfil the 3 types, hence we use \\'max\\'.\\n            return max(replacements, minlen - (int)s.size());\\n        }\\n        else if (s.size() <= maxlen){\\n              \\n            // Maintain the string length and replace min # chars to fix the sequences\\n            // and to fulfil the 3 types\\n            return replacements;\\n        }\\n\\n        // We must delete this number of chars to fit within maxlen.\\n        const int deletes = s.size() - maxlen;\\n\\n        // Since we must delete, we might as well use them to fix sequences and thereby reducing # replacements needed.\\n        \\n        int deletes_used = 0;\\n        \\n        for (int i = 1; i <= 3; i++){\\n            int reduced_replacements = min((deletes - deletes_used) / i, count_seq_mod[i - 1]);\\n            replacements -= reduced_replacements;\\n            deletes_used += reduced_replacements * i;            \\n        }\\n\\n        return deletes + max(3-type_count, replacements);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// O(N) single-pass solution.\\n// Key is to recognise changes can simultaneously satisfy multiple conditions at the same time.\\n\\n#include <string>\\n\\nusing namespace std;\\n\\nconstexpr inline int maxlen = 20;\\nconstexpr inline int minlen = 6;\\n\\nclass Solution {\\npublic:    \\n    int strongPasswordChecker(string s) {\\n        int type1=0, type2=0, type3=0;\\n        \\n        char prev_char = 0;\\n        int cur_seq_len = 0;\\n        \\n        // A sequence is a contiguous series of the same char. \\n        // To fix a sequence to satisfy condition #3, we either delete chars from the sequence, insert chars or replace certain chars in the sequence.\\n        // The min # of chars to replace is floor(sequence_length / 3).\\n        // count_seq_mod[i] = # times we can delete (i+1) chars from any sequence so as to reduce the replacement count by 1\\n        int count_seq_mod[3] = {0};\\n        \\n        int replacements = 0;\\n        \\n        for (char c: s) {\\n            if (\\'a\\' <= c && c <= \\'z\\') type1=1;\\n            else if (\\'A\\' <= c && c<= \\'Z\\') type2=1;\\n            else if (\\'0\\' <= c&& c <= \\'9\\') type3=1;\\n            \\n            if (prev_char != c){\\n                if (cur_seq_len >= 3) {\\n                    if (cur_seq_len % 3 != 2)\\n                        count_seq_mod[cur_seq_len % 3]++;\\n                    \\n                    count_seq_mod[2] += (cur_seq_len - 2) / 3;\\n                }\\n                // we need this min # replacement to fix the sequence\\n                replacements += cur_seq_len / 3;\\n                cur_seq_len = 1;\\n            }\\n            else {\\n                cur_seq_len ++;\\n            }\\n            \\n            prev_char = c;\\n        }    \\n        \\n        // End the current sequence. \\n        if (cur_seq_len >= 3) {\\n            if (cur_seq_len % 3 != 2)\\n                count_seq_mod[cur_seq_len % 3]++;\\n\\n            count_seq_mod[2] += (cur_seq_len - 2) / 3;\\n        }\\n        replacements += cur_seq_len / 3;\\n        \\n        int type_count = type1+type2+type3;\\n        replacements = max(3 - type_count, replacements);\\n        \\n        if (s.size() < minlen){\\n            // Just need to insert or replace chars.\\n            // Inserting chars can be used instead of replacement to fix sequences and to fulfil the 3 types, hence we use \\'max\\'.\\n            return max(replacements, minlen - (int)s.size());\\n        }\\n        else if (s.size() <= maxlen){\\n              \\n            // Maintain the string length and replace min # chars to fix the sequences\\n            // and to fulfil the 3 types\\n            return replacements;\\n        }\\n\\n        // We must delete this number of chars to fit within maxlen.\\n        const int deletes = s.size() - maxlen;\\n\\n        // Since we must delete, we might as well use them to fix sequences and thereby reducing # replacements needed.\\n        \\n        int deletes_used = 0;\\n        \\n        for (int i = 1; i <= 3; i++){\\n            int reduced_replacements = min((deletes - deletes_used) / i, count_seq_mod[i - 1]);\\n            replacements -= reduced_replacements;\\n            deletes_used += reduced_replacements * i;            \\n        }\\n\\n        return deletes + max(3-type_count, replacements);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 424821,
                "title": "c-solution-beats-100-time-and-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int add=0, del=0, replace=0;\\n        int size = s.size();\\n        if(size<6)\\n            add=6-size;\\n        else if (size>20)\\n            del = size-20;\\n        int ans = add+del;\\n        bool small=false;\\n        bool caps=false;\\n        bool digit=false;\\n        int i;\\n        int sadd=add;\\n        int optimize = 1;\\n        while(optimize<4){\\n        for( i=0; i<size-2;i++)\\n        {\\n            if(s[i]==s[i+1] && s[i]==s[i+2])\\n            {\\n                int k=i;\\n                while(s[k]==s[k+1])\\n                    k++;\\n                int dup = k-i+1;\\n                i=k-(optimize-1);\\n                if(del>=optimize && dup%3==(optimize-1))\\n                {\\n                    int j=i;\\n                    while(j<size-optimize)\\n                    {\\n                        s[j]=s[j+optimize];\\n                        j++;\\n                    }\\n                    del=del-optimize;\\n                    size=size-optimize;\\n                    i--;\\n                }\\n                \\n            }\\n        }\\n            optimize++;\\n        }\\n        for( i=0; i<size-2;i++)\\n        {\\n            if(small==false && s[i]>=\\'a\\' &&s[i]<=\\'z\\')\\n                small=true;\\n            else if(caps==false && s[i]>=\\'A\\' && s[i]<=\\'Z\\')\\n                caps=true;\\n            else if(digit==false && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n                digit=true;\\n            if(s[i]==s[i+1] && s[i]==s[i+2])\\n            {\\n                if(add > 0)\\n                {\\n                    add--;\\n                    i++;\\n                }\\n                else \\n                {\\n                    replace++;\\n                    i=i+2;\\n                }\\n            }\\n        }\\n        while(i<size){\\n        if(small==false && s[i]>=\\'a\\' &&s[i]<=\\'z\\')\\n            small=true;\\n        else if(caps==false && s[i]>=\\'A\\' && s[i]<=\\'Z\\')\\n            caps=true;\\n        else if(digit==false && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n            digit=true;\\n        i++;\\n        }\\n        ans=ans+replace;\\n        int need = -sadd-replace;\\n        if(!small) need++;\\n        if(!digit) need++;\\n        if(!caps) need++;\\n        if(need>0) ans=ans+need;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int add=0, del=0, replace=0;\\n        int size = s.size();\\n        if(size<6)\\n            add=6-size;\\n        else if (size>20)\\n            del = size-20;\\n        int ans = add+del;\\n        bool small=false;\\n        bool caps=false;\\n        bool digit=false;\\n        int i;\\n        int sadd=add;\\n        int optimize = 1;\\n        while(optimize<4){\\n        for( i=0; i<size-2;i++)\\n        {\\n            if(s[i]==s[i+1] && s[i]==s[i+2])\\n            {\\n                int k=i;\\n                while(s[k]==s[k+1])\\n                    k++;\\n                int dup = k-i+1;\\n                i=k-(optimize-1);\\n                if(del>=optimize && dup%3==(optimize-1))\\n                {\\n                    int j=i;\\n                    while(j<size-optimize)\\n                    {\\n                        s[j]=s[j+optimize];\\n                        j++;\\n                    }\\n                    del=del-optimize;\\n                    size=size-optimize;\\n                    i--;\\n                }\\n                \\n            }\\n        }\\n            optimize++;\\n        }\\n        for( i=0; i<size-2;i++)\\n        {\\n            if(small==false && s[i]>=\\'a\\' &&s[i]<=\\'z\\')\\n                small=true;\\n            else if(caps==false && s[i]>=\\'A\\' && s[i]<=\\'Z\\')\\n                caps=true;\\n            else if(digit==false && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n                digit=true;\\n            if(s[i]==s[i+1] && s[i]==s[i+2])\\n            {\\n                if(add > 0)\\n                {\\n                    add--;\\n                    i++;\\n                }\\n                else \\n                {\\n                    replace++;\\n                    i=i+2;\\n                }\\n            }\\n        }\\n        while(i<size){\\n        if(small==false && s[i]>=\\'a\\' &&s[i]<=\\'z\\')\\n            small=true;\\n        else if(caps==false && s[i]>=\\'A\\' && s[i]<=\\'Z\\')\\n            caps=true;\\n        else if(digit==false && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n            digit=true;\\n        i++;\\n        }\\n        ans=ans+replace;\\n        int need = -sadd-replace;\\n        if(!small) need++;\\n        if(!digit) need++;\\n        if(!caps) need++;\\n        if(need>0) ans=ans+need;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410106,
                "title": "cpp-breadth-first-search-0ms-8m",
                "content": "state description:\\n                 **i**: position in string.\\n                 **m**: number of successive identical chars seen so far. m \\u2208 {1,2,3}.\\n                 **cd**: number of conditions not met within lower,upper,digit. cd \\u2208 {0,1,2,3}.\\n                 **def**: num of chars missing.\\n                 **exc**: num of chars in excess.\\n\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int n = s.length();\\n        int c[3] = {1,1,1};\\n        for(int i=0; i<n; ++i){\\n            if(c[0] && islower(s[i])){\\n                c[0] = 0;\\n            }\\n            else if (c[1] && isupper(s[i])){\\n                c[1] = 0;\\n            }\\n            else if (c[2] && isdigit(s[i])){\\n                c[2] = 0;\\n            }\\n        }       \\n  \\n        int count(0);    \\n        std::queue<std::array<int,5>> q;\\n        q.push({1,1,c[0] + c[1] + c[2],std::max(6-n,0),std::max(n-20,0)});\\n        \\n        while(!q.empty()){\\n            int sq = q.size(); \\n            \\n            for(int j=0; j<sq; ++j){\\n                // state description:\\n                // i: position in string.\\n                // m: number of successive identical chars seen so far. m \\u2208 {1,2,3}.\\n                // cd: number of conditions not met within lower,upper,digit. cd \\u2208 {0,1,2,3}.\\n                // def: num of chars missing.\\n                // exc: num of chars in excess.\\n                auto [i,m,cd,def,exc] = q.front();\\n                q.pop();\\n                \\n                while(i<n){\\n                    if(s[i]==s[i-1]){\\n                        ++m;\\n                    }\\n                    else{\\n                        m=1;\\n                    }\\n                    \\n                    if(m==3){ // action is needed here.\\n                        \\n                        if(exc>0){\\n                            q.push({i+1,2,cd,def,exc-1}); // delete.\\n                            if(i==n-1 || s[i+1]!=s[i]){ // using a delete is optimal.\\n                               break;\\n                            }   \\n                        }\\n                        else if(def>0){\\n                            q.push({i+1,1,std::max(--cd,0),def-1,exc}); // insert.\\n                            if(i+2>=n || s[i+1] != s[i] || s[i+2] != s[i]){ // using an insert is optimal.\\n                                break;\\n                            }   \\n                        }\\n\\t\\t\\t\\t\\t\\t// replace(no need to insert/delete or these actions are not guaranteed to be optimal).\\n                        q.push({i+1,0,std::max(cd-1,0),def,exc}); \\n                        break;\\n                    } \\n                    ++i;\\n                }\\n                \\n                if(i>=n){\\n                     if(def>0){\\n                         q.push({n,0,std::max(cd-1,0),def-1,exc});\\n                     }\\n                     else if (exc>0){\\n                         q.push({n,0,cd,def,exc-1});\\n                     }\\n                     else if(cd>0){\\n                         q.push({n,0,std::max(cd-1,0),def,exc});\\n                     }\\n                     else {\\n                         return count;   \\n                     }\\n                }\\n            \\n            } // for(int j=0; i<sz; ++j)\\n            count++;\\n        } // while (!q.empty())\\n        \\n        return -1;\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int n = s.length();\\n        int c[3] = {1,1,1}",
                "codeTag": "Java"
            },
            {
                "id": 284353,
                "title": "best-o-n-solution-python",
                "content": "```\\ndef strongPasswordChecker(s):\\n    str_len = len(s); change, triple, seq, i, length, delete, types = 0,0,0,0,1, str_len -20, [1] * 4\\n    get_missing_type = lambda ch: 1 if ch.islower() else 2 if ch.isupper() else 3 if ch.isdigit() else 0\\n    while i < str_len:\\n        while i + length < str_len and s[i] == s[i + length]: length +=1\\n        types[get_missing_type(s[i])] = 0\\n        triple = length / 3\\n        if triple > 0:\\n            if delete >= 1:\\n                seq = length % 3\\n                if seq == 0 or (delete >= 2 and seq == 1):\\n                    triple -= 1\\n                    delete -= seq + 1\\n            change += triple\\n        i , length = length + i , 1\\n    missing_type = sum(types[1:])\\n    if str_len > 20:\\n        change -= delete / 3\\n        delete = str_len - 20\\n        return delete + max(missing_type, change)\\n    elif str_len >= 6: return max(missing_type, change)\\n \\xA0 \\xA0return max(missing_type, 6- str_len)\\n\\t",
                "solutionTags": [],
                "code": "```\\ndef strongPasswordChecker(s):\\n    str_len = len(s); change, triple, seq, i, length, delete, types = 0,0,0,0,1, str_len -20, [1] * 4\\n    get_missing_type = lambda ch: 1 if ch.islower() else 2 if ch.isupper() else 3 if ch.isdigit() else 0\\n    while i < str_len:\\n        while i + length < str_len and s[i] == s[i + length]: length +=1\\n        types[get_missing_type(s[i])] = 0\\n        triple = length / 3\\n        if triple > 0:\\n            if delete >= 1:\\n                seq = length % 3\\n                if seq == 0 or (delete >= 2 and seq == 1):\\n                    triple -= 1\\n                    delete -= seq + 1\\n            change += triple\\n        i , length = length + i , 1\\n    missing_type = sum(types[1:])\\n    if str_len > 20:\\n        change -= delete / 3\\n        delete = str_len - 20\\n        return delete + max(missing_type, change)\\n    elif str_len >= 6: return max(missing_type, change)\\n \\xA0 \\xA0return max(missing_type, 6- str_len)\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 228198,
                "title": "python3-ac",
                "content": "```\\n\\nclass Solution:\\n    @staticmethod\\n    def classify(n):\\n        if n.islower():\\n            return 0\\n        if n.isdigit():\\n            return 2\\n        if n.isupper():\\n            return 1\\n        return 3\\n\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        l = len(s)\\n        if l < 4:\\n            return 6 - l\\n        state = [0, 0, 0, 0]\\n        repeat_cnt = 0\\n        repeat_arr = [[], [], []]\\n        tmp = 0\\n        t = Solution.classify(s[0])\\n        state[t] += 1\\n        for i in range(1, l + 1):\\n            if i < l:\\n                n = s[i]\\n                state[Solution.classify(n)] += 1\\n            else:\\n                n = \\'\\'\\n            if n == s[tmp]:\\n                continue\\n            else:\\n                length = i - tmp\\n                if length > 2:\\n                    repeat_cnt += length // 3\\n                    repeat_arr[length%3].append(length)\\n                tmp = i\\n        a = sum([0 if state[i] else 1 for i in range(3)])\\n        if repeat_cnt == 0:\\n            return max(a, 6 - l, l-20+a)\\n        else:\\n            if l < 6: \\n                return max(a, repeat_cnt)\\n            if l > 20:  \\n                to_del_num = l - 20\\n                left_arr = []\\n                for i in range(3):\\n                    arr = repeat_arr[i]\\n                    for num in arr:\\n                        if to_del_num < i+1:\\n                            break\\n                        x = num - i - 1\\n                        to_del_num -= i+1\\n                        repeat_cnt -= 1\\n                        if x > 2:\\n                            left_arr.append(x)\\n                for num in left_arr:\\n                    if to_del_num < 3:\\n                        break\\n                    _ = min(num, to_del_num)// 3\\n                    to_del_num -= _ * 3\\n                    repeat_cnt -= _\\n                return l - 20 + max(a, repeat_cnt)\\n            return max(a, 6 - l, l-20+1, repeat_cnt)\\n\\n\\nif __name__ == \\'__main__\\':\\n    s = Solution()\\n    samples = [\\n        (\"1234567890123456Baaaaa\", 3),\\n        (\"11234567890123456Baaaaa\", 3),\\n        (\\'aaaaaaaaaaaaaaaaaaaaaa\\', 8),\\n        (\\'aaaaaaaaaaaaaaaaaaaaa\\', 7),\\n        (\\'\\', 6),\\n        (\\'.\\', 5),\\n        (\\'1\\', 5),\\n        (\\'aaaaaa\\', 2),\\n        (\\'Abc123dd\\', 0),\\n        (\\'Abc123d\\', 0),\\n        (\\'aaaa\\', 2),\\n        (\\'aaaaaa\\', 2),\\n        (\\'aaaaaaa\\', 2),\\n        (\\'aab445d\\', 1),\\n        (\\'aaaa45d\\', 1),\\n        (\\'aaabbbccc\\', 3),\\n        (\\'aaabbBccc\\', 2),\\n        (\\'aaa444ccc\\', 3),\\n        (\\'12345678\\', 2),\\n        (\\'1234567\\', 2),\\n        (\\'aabaabaabaabaabaabaab\\', 3),\\n        (\\'..............................\\', 16),\\n        (\\'Aaijrg091huy34\\', 0),\\n    ]\\n    for tp in samples:\\n        ret = s.strongPasswordChecker(tp[0])\\n        if ret != tp[1]: print(ret, tp[1], len(tp[0]), tp)\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    @staticmethod\\n    def classify(n):\\n        if n.islower():\\n            return 0\\n        if n.isdigit():\\n            return 2\\n        if n.isupper():\\n            return 1\\n        return 3\\n\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        l = len(s)\\n        if l < 4:\\n            return 6 - l\\n        state = [0, 0, 0, 0]\\n        repeat_cnt = 0\\n        repeat_arr = [[], [], []]\\n        tmp = 0\\n        t = Solution.classify(s[0])\\n        state[t] += 1\\n        for i in range(1, l + 1):\\n            if i < l:\\n                n = s[i]\\n                state[Solution.classify(n)] += 1\\n            else:\\n                n = \\'\\'\\n            if n == s[tmp]:\\n                continue\\n            else:\\n                length = i - tmp\\n                if length > 2:\\n                    repeat_cnt += length // 3\\n                    repeat_arr[length%3].append(length)\\n                tmp = i\\n        a = sum([0 if state[i] else 1 for i in range(3)])\\n        if repeat_cnt == 0:\\n            return max(a, 6 - l, l-20+a)\\n        else:\\n            if l < 6: \\n                return max(a, repeat_cnt)\\n            if l > 20:  \\n                to_del_num = l - 20\\n                left_arr = []\\n                for i in range(3):\\n                    arr = repeat_arr[i]\\n                    for num in arr:\\n                        if to_del_num < i+1:\\n                            break\\n                        x = num - i - 1\\n                        to_del_num -= i+1\\n                        repeat_cnt -= 1\\n                        if x > 2:\\n                            left_arr.append(x)\\n                for num in left_arr:\\n                    if to_del_num < 3:\\n                        break\\n                    _ = min(num, to_del_num)// 3\\n                    to_del_num -= _ * 3\\n                    repeat_cnt -= _\\n                return l - 20 + max(a, repeat_cnt)\\n            return max(a, 6 - l, l-20+1, repeat_cnt)\\n\\n\\nif __name__ == \\'__main__\\':\\n    s = Solution()\\n    samples = [\\n        (\"1234567890123456Baaaaa\", 3),\\n        (\"11234567890123456Baaaaa\", 3),\\n        (\\'aaaaaaaaaaaaaaaaaaaaaa\\', 8),\\n        (\\'aaaaaaaaaaaaaaaaaaaaa\\', 7),\\n        (\\'\\', 6),\\n        (\\'.\\', 5),\\n        (\\'1\\', 5),\\n        (\\'aaaaaa\\', 2),\\n        (\\'Abc123dd\\', 0),\\n        (\\'Abc123d\\', 0),\\n        (\\'aaaa\\', 2),\\n        (\\'aaaaaa\\', 2),\\n        (\\'aaaaaaa\\', 2),\\n        (\\'aab445d\\', 1),\\n        (\\'aaaa45d\\', 1),\\n        (\\'aaabbbccc\\', 3),\\n        (\\'aaabbBccc\\', 2),\\n        (\\'aaa444ccc\\', 3),\\n        (\\'12345678\\', 2),\\n        (\\'1234567\\', 2),\\n        (\\'aabaabaabaabaabaabaab\\', 3),\\n        (\\'..............................\\', 16),\\n        (\\'Aaijrg091huy34\\', 0),\\n    ]\\n    for tp in samples:\\n        ret = s.strongPasswordChecker(tp[0])\\n        if ret != tp[1]: print(ret, tp[1], len(tp[0]), tp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91016,
                "title": "java-o-n-one-pass-with-o-1-space-4ms-solution",
                "content": "The most difficult part of this problem is how to handle deletions when the length greater than 20.\\nThe other two situations, validated length and length less than 6 can be solved using just replacing and insertion.\\nTherefore, I will focus on how to take care of deletions here.\\nBy considering replacing a letter only when there are three repeating characters, such as \"...\", we **MUST** resolve it by replacing last one with \"?\", resulting \"..?\". \\nHere, \"?\" represents a \"**wild card**\", which can be any letter. In this case, we increase `change_count` by 1. At the same time, decrease the `type_count` by 1 since \"?\" is a \"wild card\".\\n`type_count` is initially set to `3` to count those three type of characters needed for the password. One trick is to allow `type_count` less than `0` so we would know how many \"extra\" wild cards exist. \\n\\nAnother key idea is that there are three kinds of repeating patterns to exchange \"?\" for deletions:\\n(1) \"..?\"     =>  delete the last \"?\"  \\n(2) \"..?.\"   =>  delete the last 2 \"?.\"\\n(3) \"..?..\"   =>  delete the last 3 \"?..\"\\nWe peek the following two characters to find out to which pattern of a set of repeating characters belongs and use  `delete_sets[3]` to record how many of these patterns presenting in the password. \\nTherefore, when we need to do deletions, `should_delete = len-20` characters, we should pick case (1) first since it exchanges one deletion with one needed \"?\", so  `change_count--`.\\nNext, case (2) exchanges two deletions with one \"?\" and then case (3) exchanges three deletions with one \"?\".   \\nMeanwhile, every time  `change_count--`,  we do `type_count++` because we remove one wild card.\\nHowever, when `type_count >= 0`, we can **NOT** use the \"exchange\" strategy because it is required to have at least three types of characters.\\nAt the end, if `type_count >= 0`, we need to use `type_count` of wild cards to replace other characters so the total change is `type_count + change_count`, plus the delete count `len-20` if `len > 20`.\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int len = s==null? 0: s.length(); \\n        if (len <= 2 ) return 6-len;\\n        char[] s_array= s.toCharArray(); \\n        boolean cap=false, low=false, digit=false;\\n        char pre_char=0;\\n        int pre_char_count=0, type_count=3, change_count = 0;\\n        int[] delete_sets = new int[3];\\n        for (int i=0; i< len; i++) {\\n            char c = s_array[i];\\n            char c_ = i+1 >= len? 0: s_array[i+1];\\n            char c__ = i+2 >= len? 0: s_array[i+2];\\n            if (c >='0' && c <= '9' && ! digit) {\\n                digit = true;\\n                type_count--;\\n            } else if (c >='a' && c <= 'z' && ! low) {\\n                low = true;\\n                type_count--;\\n            } else if (c >='A' && c <= 'Z' && ! cap) {\\n                cap = true;\\n                type_count--;\\n            }\\n            if (c==pre_char) {\\n                if (pre_char_count == 2) {\\n                    change_count++;\\n                    type_count--;\\n                    if (c != c_) {\\n                        delete_sets[0]++;\\n                    } else if (c != c__) {\\n                        delete_sets[1]++;\\n                    } else {\\n                        delete_sets[2]++;\\n                    }\\n                    pre_char_count = 0;\\n                    pre_char = 0;\\n                } else {\\n                    pre_char_count++;\\n                }\\n            } else {\\n                pre_char_count = 1;\\n                pre_char = c;\\n            }\\n        } \\n        if (len < 6) {\\n            type_count = Math.max(type_count, 0);\\n            return Math.max( type_count + change_count , (6-len) );\\n        } else if (len > 20) { \\n            int should_delete = len - 20;\\n            for (int i=0; i < 3 ; i++) {\\n                while ( should_delete > i && delete_sets[i] > 0 && type_count < 0) {\\n                    should_delete -= (i+1);\\n                    delete_sets[i]--;\\n                    type_count++;\\n                    change_count--;\\n                }\\n            }\\n            type_count = Math.max(type_count, 0);\\n            return len - 20 + type_count + change_count;\\n        }\\n        type_count = Math.max(type_count, 0);\\n        return type_count + change_count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int len = s==null? 0: s.length(); \\n        if (len <= 2 ) return 6-len;\\n        char[] s_array= s.toCharArray(); \\n        boolean cap=false, low=false, digit=false;\\n        char pre_char=0;\\n        int pre_char_count=0, type_count=3, change_count = 0;\\n        int[] delete_sets = new int[3];\\n        for (int i=0; i< len; i++) {\\n            char c = s_array[i];\\n            char c_ = i+1 >= len? 0: s_array[i+1];\\n            char c__ = i+2 >= len? 0: s_array[i+2];\\n            if (c >='0' && c <= '9' && ! digit) {\\n                digit = true;\\n                type_count--;\\n            } else if (c >='a' && c <= 'z' && ! low) {\\n                low = true;\\n                type_count--;\\n            } else if (c >='A' && c <= 'Z' && ! cap) {\\n                cap = true;\\n                type_count--;\\n            }\\n            if (c==pre_char) {\\n                if (pre_char_count == 2) {\\n                    change_count++;\\n                    type_count--;\\n                    if (c != c_) {\\n                        delete_sets[0]++;\\n                    } else if (c != c__) {\\n                        delete_sets[1]++;\\n                    } else {\\n                        delete_sets[2]++;\\n                    }\\n                    pre_char_count = 0;\\n                    pre_char = 0;\\n                } else {\\n                    pre_char_count++;\\n                }\\n            } else {\\n                pre_char_count = 1;\\n                pre_char = c;\\n            }\\n        } \\n        if (len < 6) {\\n            type_count = Math.max(type_count, 0);\\n            return Math.max( type_count + change_count , (6-len) );\\n        } else if (len > 20) { \\n            int should_delete = len - 20;\\n            for (int i=0; i < 3 ; i++) {\\n                while ( should_delete > i && delete_sets[i] > 0 && type_count < 0) {\\n                    should_delete -= (i+1);\\n                    delete_sets[i]--;\\n                    type_count++;\\n                    change_count--;\\n                }\\n            }\\n            type_count = Math.max(type_count, 0);\\n            return len - 20 + type_count + change_count;\\n        }\\n        type_count = Math.max(type_count, 0);\\n        return type_count + change_count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91034,
                "title": "my-c-ac-code",
                "content": "'''\\n\\n    \\n    static bool cmp(int a, int b)\\n    {\\n        return a % 3 > b % 3;\\n    }\\n    \\n    int strongPasswordChecker(string s) {\\n        deque<int> cnts;\\n        int t = 0, lowercase = 1, uppercase = 1, digit = 1;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] >= 'a' && s[i] <= 'z') lowercase = 0;\\n            else if (s[i] >= 'A' && s[i] <= 'Z') uppercase = 0;\\n            else if (s[i] >= '0' && s[i] <= '9') digit = 0;\\n            \\n            if (i == 0)\\n            {\\n                t = 1;\\n            }else\\n            {\\n                if (s[i] == s[i - 1])\\n                {\\n                    t++;\\n                }\\n                else\\n                {\\n                    if (t > 2) cnts.push_back(t);\\n                    t = 1;\\n                }\\n            }\\n        }\\n        if (t > 2) cnts.push_back(t);\\n        \\n        sort(cnts.begin(), cnts.end(), cmp);\\n\\n        int n = s.size();\\n        int count = 0;\\n        if (n > 20)\\n        {\\n            count = n - 20;\\n            int t = n - 20;\\n            while (t && !cnts.empty())\\n            {\\n                int x = cnts.front() % 3;\\n                if (x == 0)\\n                {\\n                    x = cnts.front();\\n                    if (x == 0)\\n                    {\\n                        cnts.pop_front();\\n                        continue;\\n                    }\\n                }\\n                \\n                if (t >= x)\\n                {\\n                    t -= x;\\n                    x = cnts.front() - x;\\n                    cnts.pop_front();\\n                    cnts.push_back(x);\\n                }\\n                else\\n                {\\n                    x  = cnts.front() - t;\\n                    t = 0;\\n                    cnts.pop_front();\\n                    cnts.push_back(x);\\n                }\\n            }\\n        }\\n\\n        int tc = 0;\\n        for (int x : cnts) tc += x / 3;\\n        int cc = lowercase + uppercase + digit;\\n        \\n        if (n < 6)\\n        {\\n            count = max(6 - n, cc);\\n            count = max(count, tc);\\n            cc = 0;\\n            tc = 0;\\n        }\\n        \\n        count = count + max(tc, cc);\\n        return count;\\n    }\\n\\n\\n'''",
                "solutionTags": [],
                "code": "'''\\n\\n    \\n    static bool cmp(int a, int b)\\n    {\\n        return a % 3 > b % 3;\\n    }\\n    \\n    int strongPasswordChecker(string s) {\\n        deque<int> cnts;\\n        int t = 0, lowercase = 1, uppercase = 1, digit = 1;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] >= 'a' && s[i] <= 'z') lowercase = 0;\\n            else if (s[i] >= 'A' && s[i] <= 'Z') uppercase = 0;\\n            else if (s[i] >= '0' && s[i] <= '9') digit = 0;\\n            \\n            if (i == 0)\\n            {\\n                t = 1;\\n            }else\\n            {\\n                if (s[i] == s[i - 1])\\n                {\\n                    t++;\\n                }\\n                else\\n                {\\n                    if (t > 2) cnts.push_back(t);\\n                    t = 1;\\n                }\\n            }\\n        }\\n        if (t > 2) cnts.push_back(t);\\n        \\n        sort(cnts.begin(), cnts.end(), cmp);\\n\\n        int n = s.size();\\n        int count = 0;\\n        if (n > 20)\\n        {\\n            count = n - 20;\\n            int t = n - 20;\\n            while (t && !cnts.empty())\\n            {\\n                int x = cnts.front() % 3;\\n                if (x == 0)\\n                {\\n                    x = cnts.front();\\n                    if (x == 0)\\n                    {\\n                        cnts.pop_front();\\n                        continue;\\n                    }\\n                }\\n                \\n                if (t >= x)\\n                {\\n                    t -= x;\\n                    x = cnts.front() - x;\\n                    cnts.pop_front();\\n                    cnts.push_back(x);\\n                }\\n                else\\n                {\\n                    x  = cnts.front() - t;\\n                    t = 0;\\n                    cnts.pop_front();\\n                    cnts.push_back(x);\\n                }\\n            }\\n        }\\n\\n        int tc = 0;\\n        for (int x : cnts) tc += x / 3;\\n        int cc = lowercase + uppercase + digit;\\n        \\n        if (n < 6)\\n        {\\n            count = max(6 - n, cc);\\n            count = max(count, tc);\\n            cc = 0;\\n            tc = 0;\\n        }\\n        \\n        count = count + max(tc, cc);\\n        return count;\\n    }\\n\\n\\n'''",
                "codeTag": "Unknown"
            },
            {
                "id": 4084248,
                "title": "strong-password-checker",
                "content": "# Intuition\\nThe problem can be broken down into three main challenges:\\n\\n1. Ensuring the password length falls between the 6-20 characters range.\\n2. Making sure the password contains at least one lowercase letter, one uppercase letter, and one digit.\\n3. Eliminating instances of three repeating characters in a row.\\n\\nThus, we need a mechanism to identify and correct discrepancies in length, character type, and repeated sequences.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate over the password to check if it contains lowercase, uppercase, and numeric characters.\\n2. Count the missing types of characters. This count will give us a hint on how many insertions or replacements we might need to perform\\n3. Iterate through the password to identify sequences of characters that repeat consecutively.\\n4. For sequences that have a length % 3 == 0, 1 replacement is needed.\\n5.  For sequences with a length % 3 == 1, 2 replacements are needed.\\n6. These are stored to optimize deletions later if the password length exceeds 20.\\n7. If the password length is less than 6, the number of operations will be the greater of the number of characters needed to reach a length of 6 and the number of missing types of characters.\\n8. If the password length is between 6 and 20, consider only the number of replacements for repeated sequences and the number of missing types.\\n9. If the password length is more than 20, prioritize deletions to minimize total operations. For example, if we have a sequence of 3 (\\'aaa\\'), deleting 1 character will eliminate the need for replacement.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe solution involves going through the string a few times. Specifically, twice for character type checking and repeated sequence checking, respectively. Hence, the time complexity is O(n), where n is the length of the password.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using a constant amount of space to store counters and flags, regardless of the input size. Therefore, the space complexity is O(1).\\n# Code\\n```\\nclass Solution {\\n   public int strongPasswordChecker(String password) {\\n    int n = password.length();\\n\\n    boolean hasLower = false, hasUpper = false, hasDigit = false;\\n    for (char c : password.toCharArray()) {\\n        if (Character.isLowerCase(c)) hasLower = true;\\n        if (Character.isUpperCase(c)) hasUpper = true;\\n        if (Character.isDigit(c)) hasDigit = true;\\n    }\\n    int missing_types = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n    int total_replacement = 0;\\n    int one_replace = 0;   \\n    int two_replace = 0;   \\n\\n    for (int i = 2; i < n; ) {\\n        if (password.charAt(i) == password.charAt(i-1) && password.charAt(i-1) == password.charAt(i-2)) {\\n            int length = 2; \\n            while (i < n && password.charAt(i) == password.charAt(i-1)) {\\n                length++;\\n                i++;\\n            }\\n            \\n            total_replacement += length / 3;\\n            if (length % 3 == 0) one_replace += 1;\\n            if (length % 3 == 1) two_replace += 1;\\n        } else {\\n            i++;\\n        }\\n    }\\n\\n    if (n < 6) {\\n        return Math.max(missing_types, 6 - n);\\n    } else if (n <= 20) {\\n        return Math.max(missing_types, total_replacement);\\n    } else {\\n        int delete_count = n - 20;\\n        total_replacement -= Math.min(delete_count, one_replace * 1) / 1;\\n        total_replacement -= Math.min(Math.max(delete_count - one_replace, 0), two_replace * 2) / 2;\\n        total_replacement -= Math.max(delete_count - one_replace - 2 * two_replace, 0) / 3;\\n\\n        return delete_count + Math.max(missing_types, total_replacement);\\n    }\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n   public int strongPasswordChecker(String password) {\\n    int n = password.length();\\n\\n    boolean hasLower = false, hasUpper = false, hasDigit = false;\\n    for (char c : password.toCharArray()) {\\n        if (Character.isLowerCase(c)) hasLower = true;\\n        if (Character.isUpperCase(c)) hasUpper = true;\\n        if (Character.isDigit(c)) hasDigit = true;\\n    }\\n    int missing_types = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n    int total_replacement = 0;\\n    int one_replace = 0;   \\n    int two_replace = 0;   \\n\\n    for (int i = 2; i < n; ) {\\n        if (password.charAt(i) == password.charAt(i-1) && password.charAt(i-1) == password.charAt(i-2)) {\\n            int length = 2; \\n            while (i < n && password.charAt(i) == password.charAt(i-1)) {\\n                length++;\\n                i++;\\n            }\\n            \\n            total_replacement += length / 3;\\n            if (length % 3 == 0) one_replace += 1;\\n            if (length % 3 == 1) two_replace += 1;\\n        } else {\\n            i++;\\n        }\\n    }\\n\\n    if (n < 6) {\\n        return Math.max(missing_types, 6 - n);\\n    } else if (n <= 20) {\\n        return Math.max(missing_types, total_replacement);\\n    } else {\\n        int delete_count = n - 20;\\n        total_replacement -= Math.min(delete_count, one_replace * 1) / 1;\\n        total_replacement -= Math.min(Math.max(delete_count - one_replace, 0), two_replace * 2) / 2;\\n        total_replacement -= Math.max(delete_count - one_replace - 2 * two_replace, 0) / 3;\\n\\n        return delete_count + Math.max(missing_types, total_replacement);\\n    }\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073707,
                "title": "solving-leetcode-when-the-last-step-can-turn-out-the-hardest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n###### My first idea was to work only with statistical characteristics of the password and never return back to the characters\\u2014and it worked! I also decided to create a finite-state machine and made it, but further on I discovered there was no need for it.\\n\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the statistical characteristics of the password.\\n2. Calculate the number of necessary and additional steps.\\n3. Reduce the additional steps already contained in the necessary steps depending on the calculated statistics\\u2014it is the most difficult part.\\n4. Split the necessary steps to simplify the formula for return.\\n5. Celebrate victory.\\n\\n# Complexity\\n###### The difficulty of this problem comes from the fact that \\'steps\\' interfere with each other, as long as there is a variety of steps that lead to a solution and one has to determine the shortest path. Moreover, there are necessary and additional steps.\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n###### $$O(n)$$, depends on complexity, not the size of the password\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n\\n#define max(X, Y)  ((X) > (Y) ? (X) : (Y))\\n\\ntypedef struct {\\n  int state;\\n} cntxA_t;\\n\\nint check_repet( cntxA_t * const A, int repeat,\\n                 int * const _data, int * const repetition,\\n                 int * const low_content, int * const hi_content)\\n{\\n  switch (A->state)\\n  {\\n    case 0: // init\\n      (*repetition) = 1;\\n      A->state = 1; \\n    break;\\n\\n    case 1: // work\\n      if (0 != repeat)\\n      {\\n        (*repetition)++;\\n        break;\\n      }\\n      (*_data) += (*repetition)/3;\\n      if ((*repetition)%3 == 0 && (*repetition) >= 3) (*low_content)++;\\n      if ((*repetition)%3 == 1 && (*repetition) >= 3) (*hi_content)++;\\n\\n      (*repetition) = 1;\\n    break;\\n  }\\n  return A->state;\\n}\\n\\nint strongPasswordChecker(char * password){\\n\\nconst int min_symbols = 6;\\nconst int max_symbols = 20;\\n\\nint state = 0;\\nint i = 0;\\n\\nchar repet_char = 0;\\n\\nint repetition = 0, insert_one_dif = 3; //max different symbol inserts\\nint insert_one_suppl = 0, replace_one = 0, delete_one = 0;\\n\\nint low_content = 0, hi_content = 0;\\nint is_there_az = 0, is_there_AZ = 0, is_there_09 = 0;\\n\\ncntxA_t cntxA11 = {0};\\n\\n//init automat\\ncheck_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n\\ndo {\\n      //printf(\"i = %d\\\\n\", i);\\n      if (\\'A\\' <= password[i] && \\'Z\\' >= password[i] && 0 == is_there_AZ )\\n      {\\n        is_there_AZ = 1;\\n        insert_one_dif--;\\n      }\\n      if (\\'a\\' <= password[i] && \\'z\\' >= password[i] && 0 == is_there_az )\\n      {\\n        is_there_az = 1;\\n        insert_one_dif--;\\n      }\\n      if (\\'0\\' <= password[i] && \\'9\\' >= password[i] && 0 == is_there_09 )\\n      {\\n        is_there_09 = 1;\\n        insert_one_dif--;\\n      }\\n\\n      if (repet_char == password[i]) \\n        check_repet( &cntxA11, 1, &repetition, &replace_one, &low_content, &hi_content);\\n      else\\n        check_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n        \\n      repet_char = password[i];\\n}\\nwhile (\\'\\\\0\\' != password[++i]);\\n\\ncheck_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n\\n\\n      if (min_symbols >= i) insert_one_suppl = min_symbols - i;\\n      if (i > max_symbols ) delete_one = i - max_symbols;\\n\\n//further depends on structure of conditions\\n/////////////////////////////////////////////////////////////\\n      //less than 6 symbols\\n      if (insert_one_suppl > 0)\\n        return max (insert_one_suppl, insert_one_dif);\\n/////////////////////////////////////////////////////////////\\n      if (repetition == 0) goto return_wo_rep;\\n\\n//decreasing repetition due to most compulsory deletation\\n      if (delete_one > 0)\\n      {\\n        int temp_delete_one = delete_one;\\n\\n        do {\\n          for (int i = low_content; i > 0; i--)\\n          {\\n            if (temp_delete_one < 1) break;\\n            if (repetition == 0) goto return_wo_rep;\\n            repetition--;\\n            temp_delete_one -= 1;\\n          }\\n          for (int i = hi_content; i > 0; i--)\\n          {\\n            if (temp_delete_one < 2) break;\\n            if (repetition == 0) goto return_wo_rep;\\n            repetition--;\\n            temp_delete_one -= 2;\\n          }\\n          low_content = hi_content;\\n        } while (temp_delete_one > 3 && low_content > 0);\\n\\n        while (temp_delete_one >= 3)\\n        {\\n          if (repetition == 0) goto return_wo_rep;\\n          repetition--;\\n          temp_delete_one -= 3;\\n        }\\n\\n        return delete_one + max(repetition, insert_one_dif);\\n\\nreturn_wo_rep:\\n        return delete_one + insert_one_dif;\\n      }\\n/////////////////////////////////////////////////////////////\\n      return max (repetition, insert_one_dif);\\n}  \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n#define max(X, Y)  ((X) > (Y) ? (X) : (Y))\\n\\ntypedef struct {\\n  int state;\\n} cntxA_t;\\n\\nint check_repet( cntxA_t * const A, int repeat,\\n                 int * const _data, int * const repetition,\\n                 int * const low_content, int * const hi_content)\\n{\\n  switch (A->state)\\n  {\\n    case 0: // init\\n      (*repetition) = 1;\\n      A->state = 1; \\n    break;\\n\\n    case 1: // work\\n      if (0 != repeat)\\n      {\\n        (*repetition)++;\\n        break;\\n      }\\n      (*_data) += (*repetition)/3;\\n      if ((*repetition)%3 == 0 && (*repetition) >= 3) (*low_content)++;\\n      if ((*repetition)%3 == 1 && (*repetition) >= 3) (*hi_content)++;\\n\\n      (*repetition) = 1;\\n    break;\\n  }\\n  return A->state;\\n}\\n\\nint strongPasswordChecker(char * password){\\n\\nconst int min_symbols = 6;\\nconst int max_symbols = 20;\\n\\nint state = 0;\\nint i = 0;\\n\\nchar repet_char = 0;\\n\\nint repetition = 0, insert_one_dif = 3; //max different symbol inserts\\nint insert_one_suppl = 0, replace_one = 0, delete_one = 0;\\n\\nint low_content = 0, hi_content = 0;\\nint is_there_az = 0, is_there_AZ = 0, is_there_09 = 0;\\n\\ncntxA_t cntxA11 = {0};\\n\\n//init automat\\ncheck_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n\\ndo {\\n      //printf(\"i = %d\\\\n\", i);\\n      if (\\'A\\' <= password[i] && \\'Z\\' >= password[i] && 0 == is_there_AZ )\\n      {\\n        is_there_AZ = 1;\\n        insert_one_dif--;\\n      }\\n      if (\\'a\\' <= password[i] && \\'z\\' >= password[i] && 0 == is_there_az )\\n      {\\n        is_there_az = 1;\\n        insert_one_dif--;\\n      }\\n      if (\\'0\\' <= password[i] && \\'9\\' >= password[i] && 0 == is_there_09 )\\n      {\\n        is_there_09 = 1;\\n        insert_one_dif--;\\n      }\\n\\n      if (repet_char == password[i]) \\n        check_repet( &cntxA11, 1, &repetition, &replace_one, &low_content, &hi_content);\\n      else\\n        check_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n        \\n      repet_char = password[i];\\n}\\nwhile (\\'\\\\0\\' != password[++i]);\\n\\ncheck_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n\\n\\n      if (min_symbols >= i) insert_one_suppl = min_symbols - i;\\n      if (i > max_symbols ) delete_one = i - max_symbols;\\n\\n//further depends on structure of conditions\\n/////////////////////////////////////////////////////////////\\n      //less than 6 symbols\\n      if (insert_one_suppl > 0)\\n        return max (insert_one_suppl, insert_one_dif);\\n/////////////////////////////////////////////////////////////\\n      if (repetition == 0) goto return_wo_rep;\\n\\n//decreasing repetition due to most compulsory deletation\\n      if (delete_one > 0)\\n      {\\n        int temp_delete_one = delete_one;\\n\\n        do {\\n          for (int i = low_content; i > 0; i--)\\n          {\\n            if (temp_delete_one < 1) break;\\n            if (repetition == 0) goto return_wo_rep;\\n            repetition--;\\n            temp_delete_one -= 1;\\n          }\\n          for (int i = hi_content; i > 0; i--)\\n          {\\n            if (temp_delete_one < 2) break;\\n            if (repetition == 0) goto return_wo_rep;\\n            repetition--;\\n            temp_delete_one -= 2;\\n          }\\n          low_content = hi_content;\\n        } while (temp_delete_one > 3 && low_content > 0);\\n\\n        while (temp_delete_one >= 3)\\n        {\\n          if (repetition == 0) goto return_wo_rep;\\n          repetition--;\\n          temp_delete_one -= 3;\\n        }\\n\\n        return delete_one + max(repetition, insert_one_dif);\\n\\nreturn_wo_rep:\\n        return delete_one + insert_one_dif;\\n      }\\n/////////////////////////////////////////////////////////////\\n      return max (repetition, insert_one_dif);\\n}  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4071146,
                "title": "easy-to-read-code-medium-performance",
                "content": "# Code\\n```\\nvar strongPasswordChecker = function(p) {\\n  // Strategy:\\n  //\\n  // Identify runs (and their length) and count missing character deficiencies\\n  //\\n  // if < 6\\n  //   it just so happens that any run can be resolved by already needed additions and mutations\\n  //\\n  // if >= 6\\n  //   if > 20, count deletions while strategically reducing runs\\n  //   count mutation breaks needed to solve runs\\n  //   absorb character deficiencies into needed run breaks\\n\\n  // Sort runs based on their divisibility by 3\\n  let runs = [[], [], []]\\n  let run\\n\\n  let needL = 1, needU = 1, needD = 1\\n\\n  for (let i = 0; i < p.length; i++) {\\n    if (needL && p[i] >= \\'a\\' && p[i] <= \\'z\\')\\n      needL = 0\\n\\n    if (needU && p[i] >= \\'A\\' && p[i] <= \\'Z\\')\\n      needU = 0\\n\\n    if (needD && p[i] >= \\'0\\' && p[i] <= \\'9\\')\\n      needD = 0\\n\\n    if (p[i] === p[i-1])\\n      run++\\n\\n    if (p[i] !== p[i-1] || i === p.length - 1) {\\n      if (run > 2)\\n        runs[run % 3].push(run)\\n\\n      run = 1\\n    }\\n  }\\n\\n  let needed = needL + needU + needD\\n\\n  // Take care of the special case where all runs are autoamtically covered\\n  if (p.length < 6)\\n    return Math.max(6 - p.length, needed)\\n\\n  let len = p.length, toDelete = Math.max(len - 20, 0), toChange = 0\\n\\n  // Use password shortening to reduce runs\\n  while (len-- > 20) {\\n    // Focus on runs divisible by 3\\n    if (runs[0].length !== 0) {\\n      run = runs[0].pop() - 1\\n\\n      if (run !== 2)\\n        runs[2].push(run)\\n    } else if (runs[1].length !== 0) {\\n      runs[0].push(runs[1].pop() - 1)\\n    } else if (runs[2].length !== 0) {\\n      runs[1].push(runs[2].pop() - 1)\\n    }\\n  }\\n\\n  // Combine the runs into one list\\n  runs = runs.flat()\\n\\n  toChange = runs.reduce(\\n    (total, run) => total + run / 3 | 0, 0\\n  )\\n\\n  // Absorb character kind deficiencies into run breakup mutations\\n  needed = Math.max(needed - toChange, 0)\\n\\n  return toDelete + toChange + needed\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strongPasswordChecker = function(p) {\\n  // Strategy:\\n  //\\n  // Identify runs (and their length) and count missing character deficiencies\\n  //\\n  // if < 6\\n  //   it just so happens that any run can be resolved by already needed additions and mutations\\n  //\\n  // if >= 6\\n  //   if > 20, count deletions while strategically reducing runs\\n  //   count mutation breaks needed to solve runs\\n  //   absorb character deficiencies into needed run breaks\\n\\n  // Sort runs based on their divisibility by 3\\n  let runs = [[], [], []]\\n  let run\\n\\n  let needL = 1, needU = 1, needD = 1\\n\\n  for (let i = 0; i < p.length; i++) {\\n    if (needL && p[i] >= \\'a\\' && p[i] <= \\'z\\')\\n      needL = 0\\n\\n    if (needU && p[i] >= \\'A\\' && p[i] <= \\'Z\\')\\n      needU = 0\\n\\n    if (needD && p[i] >= \\'0\\' && p[i] <= \\'9\\')\\n      needD = 0\\n\\n    if (p[i] === p[i-1])\\n      run++\\n\\n    if (p[i] !== p[i-1] || i === p.length - 1) {\\n      if (run > 2)\\n        runs[run % 3].push(run)\\n\\n      run = 1\\n    }\\n  }\\n\\n  let needed = needL + needU + needD\\n\\n  // Take care of the special case where all runs are autoamtically covered\\n  if (p.length < 6)\\n    return Math.max(6 - p.length, needed)\\n\\n  let len = p.length, toDelete = Math.max(len - 20, 0), toChange = 0\\n\\n  // Use password shortening to reduce runs\\n  while (len-- > 20) {\\n    // Focus on runs divisible by 3\\n    if (runs[0].length !== 0) {\\n      run = runs[0].pop() - 1\\n\\n      if (run !== 2)\\n        runs[2].push(run)\\n    } else if (runs[1].length !== 0) {\\n      runs[0].push(runs[1].pop() - 1)\\n    } else if (runs[2].length !== 0) {\\n      runs[1].push(runs[2].pop() - 1)\\n    }\\n  }\\n\\n  // Combine the runs into one list\\n  runs = runs.flat()\\n\\n  toChange = runs.reduce(\\n    (total, run) => total + run / 3 | 0, 0\\n  )\\n\\n  // Absorb character kind deficiencies into run breakup mutations\\n  needed = Math.max(needed - toChange, 0)\\n\\n  return toDelete + toChange + needed\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019711,
                "title": "optimal-solution-for-strong-password-checker-on-leetcode-python",
                "content": "# Intuition\\nTo solve this problem, we need to determine the minimum number of steps required to make the given password strong. A strong password must satisfy the following conditions:\\n\\n    It must have at least 6 characters and at most 20 characters.\\n    It must contain at least one lowercase letter, one uppercase letter, and one digit.\\n    It must not contain three repeating characters in a row.\\n\\nWe can approach this problem by iteratively checking each condition and counting the number of steps needed to satisfy each condition. Finally, we return the maximum of these steps.\\n\\n# Approach\\n1. Initialize a variable steps to 0 to keep track of the total number of steps needed.\\n2. Initialize three boolean variables hasLower, hasUpper, and hasDigit to check if the password contains at least one lowercase letter, one uppercase letter, and one digit.\\n3. Initialize two variables repeat1 and repeat2 to check for three repeating characters in a row. Set them to 0.\\n4. Iterate through the characters of the password:\\n    - If the character is a lowercase letter, set hasLower to True.\\n    - If the character is an uppercase letter, set hasUpper to True.\\n    - If the character is a digit, set hasDigit to True.\\n    - If the current character is the same as the previous character, increment repeat1. If repeat1 reaches 3, increment steps by 1, set repeat1 to 2, and continue.\\n    - If the current character is the same as the character two positions back (i.e., three repeating characters), increment repeat2. If repeat2 reaches 3, increment steps by 1, set repeat2 to 2, and continue.\\n5. After iterating through the password, check the following conditions:\\n    - If the length of the password is less than 6, calculate the number of insertions needed to reach a length of 6, and add it to steps.\\n    - If the length of the password is between 6 and 20 (inclusive), calculate the number of insertions needed to satisfy the missing character types (lowercase, uppercase, digit), and add it to steps.\\n    - If the length of the password is greater than 20, calculate the number of deletions needed to reduce the length to 20, and add it to steps.\\n6. Return the final value of steps as the minimum number of steps required to make the password strong.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the input password string. This is because we iterate through the password string once to check its characters and conditions. The subsequent calculations to determine the number of insertions or deletions also take constant time.\\n\\n- Space complexity:\\nThe space complexity of this solution is O(1), which means it uses a constant amount of extra space regardless of the input size. The variables used to store information about missing character types, replacements, and counts do not depend on the input size and occupy a fixed amount of memory.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p - 1] == s[p - 2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p - 1]:\\n                    length += 1\\n                    p += 1\\n\\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n\\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n\\n            return delete + max(missing_type, change)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p - 1] == s[p - 2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p - 1]:\\n                    length += 1\\n                    p += 1\\n\\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n\\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n\\n            return delete + max(missing_type, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017763,
                "title": "easy-and-fast-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        bool all_met = false;\\n        int add_steps = 0, rem_steps = 0, trio_steps = 0, contains_steps = 3;\\n        int p_size = password.size();\\n        \\n        if (p_size < 6)\\n            add_steps = 6-p_size;\\n        else if(p_size > 20)\\n            rem_steps = p_size-20;\\n\\n        bool contains_lower = false, contains_upper = false, contains_digit = false;\\n        int modular_cases[3] = {0};\\n        for (int i = 0; i < p_size;){\\n            if (password[i] >= \\'a\\' and password[i] <= \\'z\\') contains_lower = true;\\n            else if (password[i] >= \\'A\\' and password[i] <= \\'Z\\') contains_upper = true;\\n            else if (password[i] >= \\'0\\' and password[i] <= \\'9\\') contains_digit = true;\\n\\n            int j=i+1;\\n            while(j<p_size && password[i]==password[j]) j++;\\n            int diff = j-i;\\n            trio_steps += diff/3;\\n            if (diff/3 >= 1) modular_cases[diff%3]++;\\n            \\n            i=j;\\n        }\\n        if (contains_lower) contains_steps--;\\n        if (contains_upper) contains_steps--;\\n        if (contains_digit) contains_steps--;\\n        \\n        if (add_steps)\\n            return max(add_steps, max(trio_steps, contains_steps));\\n\\n        int aux_rem_steps = rem_steps;\\n        for (int m = 0; m < 3; m++)\\n            while(aux_rem_steps >= m+1 and modular_cases[m] > 0)\\n                aux_rem_steps -= m+1, trio_steps--, modular_cases[m]--;\\n\\n        return rem_steps + max(trio_steps-aux_rem_steps/3, contains_steps); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        bool all_met = false;\\n        int add_steps = 0, rem_steps = 0, trio_steps = 0, contains_steps = 3;\\n        int p_size = password.size();\\n        \\n        if (p_size < 6)\\n            add_steps = 6-p_size;\\n        else if(p_size > 20)\\n            rem_steps = p_size-20;\\n\\n        bool contains_lower = false, contains_upper = false, contains_digit = false;\\n        int modular_cases[3] = {0};\\n        for (int i = 0; i < p_size;){\\n            if (password[i] >= \\'a\\' and password[i] <= \\'z\\') contains_lower = true;\\n            else if (password[i] >= \\'A\\' and password[i] <= \\'Z\\') contains_upper = true;\\n            else if (password[i] >= \\'0\\' and password[i] <= \\'9\\') contains_digit = true;\\n\\n            int j=i+1;\\n            while(j<p_size && password[i]==password[j]) j++;\\n            int diff = j-i;\\n            trio_steps += diff/3;\\n            if (diff/3 >= 1) modular_cases[diff%3]++;\\n            \\n            i=j;\\n        }\\n        if (contains_lower) contains_steps--;\\n        if (contains_upper) contains_steps--;\\n        if (contains_digit) contains_steps--;\\n        \\n        if (add_steps)\\n            return max(add_steps, max(trio_steps, contains_steps));\\n\\n        int aux_rem_steps = rem_steps;\\n        for (int m = 0; m < 3; m++)\\n            while(aux_rem_steps >= m+1 and modular_cases[m] > 0)\\n                aux_rem_steps -= m+1, trio_steps--, modular_cases[m]--;\\n\\n        return rem_steps + max(trio_steps-aux_rem_steps/3, contains_steps); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016963,
                "title": "strong-password-validation-with-linear-complexity",
                "content": "# Intuition\\nThe problem asks us to find the minimum number of steps required to make a given password strong based on certain conditions. The conditions are length, presence of at least one lowercase letter, at least one uppercase letter, and at least one digit, as well as the absence of three repeating characters in a row.\\n\\n# Approach\\n- Character Type Checks: First, we go through the password to see which types of characters it contains (lowercase, uppercase, digits). We use variables has_lower, has_upper, and has_digit to store this information.\\n\\n- Missing Types: We then calculate how many types of characters are missing to make the password strong, stored in missing_types.\\n\\n- Repeating Sequences: Next, we loop through the password to find sequences of repeating characters and count how many such sequences exist. We also note sequences that can be resolved by deleting one or two characters.\\n\\n- Length Checks: Depending on the length of the password (n), we decide on the minimum steps needed for the password length to be in the range [6, 20].\\n\\n- Optimization: If the length is greater than 20, we use the extra characters to resolve the repeating sequences (reducing to_replace).\\n\\n- Result: Finally, the minimum number of steps is the higher value between missing_types and the number of steps needed to resolve the length and repeating sequence issues.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  - One pass to check for character types (lowercase, uppercase, and digit).\\n  - One pass to check for repeating sequences.\\n- Space complexity: O(1)\\n  - Constant extra space is used for variables.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) {\\n        int has_lower = 0, has_upper = 0, has_digit = 0;\\n        foreach (char c in password) {\\n            if (char.IsLower(c)) has_lower = 1;\\n            if (char.IsUpper(c)) has_upper = 1;\\n            if (char.IsDigit(c)) has_digit = 1;\\n        }\\n        \\n        int missing_types = 3 - (has_lower + has_upper + has_digit);\\n        \\n        int n = password.Length;\\n        int to_replace = 0;\\n        int one_delete = 0;\\n        int two_delete = 0;\\n        \\n        int i = 2;\\n        while (i < n) {\\n            if (password[i] == password[i-1] && password[i] == password[i-2]) {\\n                int length = 2;\\n                while (i < n && password[i] == password[i-1]) {\\n                    length++;\\n                    i++;\\n                }\\n                \\n                to_replace += length / 3;\\n                if (length % 3 == 0) one_delete += 1;\\n                if (length % 3 == 1) two_delete += 1;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        if (n < 6) {\\n            return Math.Max(missing_types, 6 - n);\\n        } else if (n <= 20) {\\n            return Math.Max(missing_types, to_replace);\\n        } else {\\n            int delete_len = n - 20;\\n            \\n            to_replace -= Math.Min(delete_len, one_delete * 1) / 1;\\n            to_replace -= Math.Min(Math.Max(delete_len - one_delete, 0), two_delete * 2) / 2;\\n            to_replace -= Math.Max(delete_len - one_delete - 2 * two_delete, 0) / 3;\\n            \\n            return delete_len + Math.Max(missing_types, to_replace);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) {\\n        int has_lower = 0, has_upper = 0, has_digit = 0;\\n        foreach (char c in password) {\\n            if (char.IsLower(c)) has_lower = 1;\\n            if (char.IsUpper(c)) has_upper = 1;\\n            if (char.IsDigit(c)) has_digit = 1;\\n        }\\n        \\n        int missing_types = 3 - (has_lower + has_upper + has_digit);\\n        \\n        int n = password.Length;\\n        int to_replace = 0;\\n        int one_delete = 0;\\n        int two_delete = 0;\\n        \\n        int i = 2;\\n        while (i < n) {\\n            if (password[i] == password[i-1] && password[i] == password[i-2]) {\\n                int length = 2;\\n                while (i < n && password[i] == password[i-1]) {\\n                    length++;\\n                    i++;\\n                }\\n                \\n                to_replace += length / 3;\\n                if (length % 3 == 0) one_delete += 1;\\n                if (length % 3 == 1) two_delete += 1;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        if (n < 6) {\\n            return Math.Max(missing_types, 6 - n);\\n        } else if (n <= 20) {\\n            return Math.Max(missing_types, to_replace);\\n        } else {\\n            int delete_len = n - 20;\\n            \\n            to_replace -= Math.Min(delete_len, one_delete * 1) / 1;\\n            to_replace -= Math.Min(Math.Max(delete_len - one_delete, 0), two_delete * 2) / 2;\\n            to_replace -= Math.Max(delete_len - one_delete - 2 * two_delete, 0) / 3;\\n            \\n            return delete_len + Math.Max(missing_types, to_replace);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976731,
                "title": "python",
                "content": "Not the cleanest solution but it seems to work\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        hasdigits = any(char.isdigit() for char in password)\\n        hasupper = any(char.isupper() for char in password)\\n        haslower = any(char.islower() for char in password)\\n        # positive if we need to add characters, negative if we need to delete, 0 for replacements\\n        additions = max(0, 6-len(password)) - max(0, len(password)-20) \\n        \\n        # list all repeating sequence lengths\\n        cp = None\\n        seq = []\\n        n = 1\\n        for c in password:\\n            if c == cp:\\n                n += 1\\n                if n == 3:\\n                    seq.append(n)\\n                elif n > 3:\\n                    seq[-1] = n\\n            else:\\n                n = 1\\n            cp = c\\n        seq.sort()\\n        edits = 0\\n        # keep making edits until all repeating sequences are gone\\n        while(len(seq) > 0):\\n            print(seq)\\n            # replace characters (additions==0), or add (>0)\\n            if additions >= 0:\\n                # if needed, we replace/add a required character\\n                if not hasdigits:\\n                    hasdigits = True\\n                elif not haslower: \\n                    haslower = True\\n                elif not hasupper:\\n                    hasupper = True\\n                # take the longest sequence and start splitting it into pieces of len 2\\n                # this means we actually just remove 3 characters from the sequence\\n                seq[-1] -= 3\\n                if(seq[-1] < 3): del seq[-1]\\n                additions = max(0, additions-1) # remove one addition\\n            # delete or replace characters (additions < 0)\\n            else:\\n                # if we can remove all repeating sequences by only deleting characters, we start deleting\\n                if(sum(seq) - 2*len(seq) <= -additions):\\n                    edits += len(seq)\\n                    additions = min(0, additions+len(seq))\\n                    break\\n                    #seq[0] -= 1\\n                    #if(seq[0] < 3): del seq[0]\\n                    #additions = min(0, additions+1)\\n                # if not, it\\'s more efficient to first start breaking them up with replacements\\n                else:\\n                    # if needed, we replace with a required character\\n                    if not hasdigits:\\n                        hasdigits = True\\n                    elif not haslower: \\n                        haslower = True\\n                    elif not hasupper:\\n                        hasupper = True\\n                    seq[-1] -= 3\\n                    if(seq[-1] < 3): del seq[-1]\\n                    seq.sort()  # sort so the longest sequence is at the top of the stack again\\n            edits += 1  # add to the edit counter\\n\\n        # if we have any additions left, we make sure we first add required characters\\n        for i in range(additions):\\n            if not hasdigits:\\n                hasdigits = True\\n            elif not haslower: \\n                haslower = True\\n            else:\\n                hasupper = True\\n        \\n        # add all leftover additions and required character changes to the edits    \\n        edits += abs(additions) + (not hasdigits) + (not hasupper) + (not haslower)\\n\\n        return edits\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        hasdigits = any(char.isdigit() for char in password)\\n        hasupper = any(char.isupper() for char in password)\\n        haslower = any(char.islower() for char in password)\\n        # positive if we need to add characters, negative if we need to delete, 0 for replacements\\n        additions = max(0, 6-len(password)) - max(0, len(password)-20) \\n        \\n        # list all repeating sequence lengths\\n        cp = None\\n        seq = []\\n        n = 1\\n        for c in password:\\n            if c == cp:\\n                n += 1\\n                if n == 3:\\n                    seq.append(n)\\n                elif n > 3:\\n                    seq[-1] = n\\n            else:\\n                n = 1\\n            cp = c\\n        seq.sort()\\n        edits = 0\\n        # keep making edits until all repeating sequences are gone\\n        while(len(seq) > 0):\\n            print(seq)\\n            # replace characters (additions==0), or add (>0)\\n            if additions >= 0:\\n                # if needed, we replace/add a required character\\n                if not hasdigits:\\n                    hasdigits = True\\n                elif not haslower: \\n                    haslower = True\\n                elif not hasupper:\\n                    hasupper = True\\n                # take the longest sequence and start splitting it into pieces of len 2\\n                # this means we actually just remove 3 characters from the sequence\\n                seq[-1] -= 3\\n                if(seq[-1] < 3): del seq[-1]\\n                additions = max(0, additions-1) # remove one addition\\n            # delete or replace characters (additions < 0)\\n            else:\\n                # if we can remove all repeating sequences by only deleting characters, we start deleting\\n                if(sum(seq) - 2*len(seq) <= -additions):\\n                    edits += len(seq)\\n                    additions = min(0, additions+len(seq))\\n                    break\\n                    #seq[0] -= 1\\n                    #if(seq[0] < 3): del seq[0]\\n                    #additions = min(0, additions+1)\\n                # if not, it\\'s more efficient to first start breaking them up with replacements\\n                else:\\n                    # if needed, we replace with a required character\\n                    if not hasdigits:\\n                        hasdigits = True\\n                    elif not haslower: \\n                        haslower = True\\n                    elif not hasupper:\\n                        hasupper = True\\n                    seq[-1] -= 3\\n                    if(seq[-1] < 3): del seq[-1]\\n                    seq.sort()  # sort so the longest sequence is at the top of the stack again\\n            edits += 1  # add to the edit counter\\n\\n        # if we have any additions left, we make sure we first add required characters\\n        for i in range(additions):\\n            if not hasdigits:\\n                hasdigits = True\\n            elif not haslower: \\n                haslower = True\\n            else:\\n                hasupper = True\\n        \\n        # add all leftover additions and required character changes to the edits    \\n        edits += abs(additions) + (not hasdigits) + (not hasupper) + (not haslower)\\n\\n        return edits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976117,
                "title": "how-strong-is-this-password-checker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        \\n        # Check for lowercase, uppercase, and digit\\n        has_lower = any(c.islower() for c in password)\\n        has_upper = any(c.isupper() for c in password)\\n        has_digit = any(c.isdigit() for c in password)\\n        \\n        # Total types of characters we need to add to satisfy the requirements\\n        types_needed = 3 - (has_lower + has_upper + has_digit)\\n        \\n        # Check for repeating characters\\n        repeat_replace = 0\\n        one_mod = two_mod = 0  # Counters for characters that repeat modulo 3\\n        \\n        i = 2\\n        while i < n:\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < n and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                repeat_replace += length // 3\\n                if length % 3 == 0:\\n                    one_mod += 1\\n                elif length % 3 == 1:\\n                    two_mod += 1\\n            else:\\n                i += 1\\n        \\n        # If the length is less than 6\\n        if n < 6:\\n            return max(types_needed, 6 - n)\\n        \\n        # If the length is between 6 and 20\\n        elif n <= 20:\\n            return max(types_needed, repeat_replace)\\n        \\n        # If the length is more than 20\\n        else:\\n            delete_needed = n - 20\\n            repeat_replace -= min(delete_needed, one_mod * 1) // 1\\n            repeat_replace -= min(max(delete_needed - one_mod, 0), two_mod * 2) // 2\\n            repeat_replace -= max(delete_needed - one_mod - 2 * two_mod, 0) // 3\\n            \\n            return delete_needed + max(types_needed, repeat_replace)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        \\n        # Check for lowercase, uppercase, and digit\\n        has_lower = any(c.islower() for c in password)\\n        has_upper = any(c.isupper() for c in password)\\n        has_digit = any(c.isdigit() for c in password)\\n        \\n        # Total types of characters we need to add to satisfy the requirements\\n        types_needed = 3 - (has_lower + has_upper + has_digit)\\n        \\n        # Check for repeating characters\\n        repeat_replace = 0\\n        one_mod = two_mod = 0  # Counters for characters that repeat modulo 3\\n        \\n        i = 2\\n        while i < n:\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < n and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                repeat_replace += length // 3\\n                if length % 3 == 0:\\n                    one_mod += 1\\n                elif length % 3 == 1:\\n                    two_mod += 1\\n            else:\\n                i += 1\\n        \\n        # If the length is less than 6\\n        if n < 6:\\n            return max(types_needed, 6 - n)\\n        \\n        # If the length is between 6 and 20\\n        elif n <= 20:\\n            return max(types_needed, repeat_replace)\\n        \\n        # If the length is more than 20\\n        else:\\n            delete_needed = n - 20\\n            repeat_replace -= min(delete_needed, one_mod * 1) // 1\\n            repeat_replace -= min(max(delete_needed - one_mod, 0), two_mod * 2) // 2\\n            repeat_replace -= max(delete_needed - one_mod - 2 * two_mod, 0) // 3\\n            \\n            return delete_needed + max(types_needed, repeat_replace)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957766,
                "title": "strengthening-passwords-a-minimal-modification-approach",
                "content": "# Intuition\\nInitially, it\\'s clear that a strong password must meet certain criteria related to its length, character types, and patterns. The challenge is to figure out the minimal number of steps required to transform the input password into a strong one while satisfying these conditions. \\n\\n# Approach\\nCharacter Types: First, let\\'s identify the types of characters present in the password. A strong password should have at least one lowercase letter, one uppercase letter, and one digit.\\n\\nRepetitive Sequences: Next, it\\'s essential to pinpoint sequences of three or more repeating characters. These sequences should be altered to ensure no three consecutive characters are the same.\\n\\nPassword Length: Depending on the length of the password, we\\'ll need to either insert, delete, or replace characters.\\n\\nIf the password is shorter than 6 characters, it\\'s often more efficient to insert the missing characters.\\nIf it\\'s between 6 and 20, replacements would typically suffice.\\nFor passwords longer than 20 characters, deletions become necessary. \\n\\n# Complexity\\n- Time complexity:\\nThe solution primarily iterates through the given password, resulting in a complexity of O(n), where n is the length of the password. \\n\\n- Space complexity:\\nWe only use a constant amount of space, making the space complexity O(1). \\n\\n# Code\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        # Checking the presence of different types of characters in the password\\n        upper, lower, digit = 0, 0, 0\\n        for c in password:\\n            if \\'a\\' <= c <= \\'z\\':\\n                lower = 1\\n            elif \\'A\\' <= c <= \\'Z\\':\\n                upper = 1\\n            elif c.isdigit():\\n                digit = 1\\n        # Calculate how many types are missing\\n        types_missing = 3 - (upper + lower + digit)\\n\\n        # Addressing the issue of repetitive sequences\\n        replace = 0\\n        one_replace, two_replace = 0, 0\\n        i = 2\\n        while i < len(password):\\n            # Detect sequences of three identical characters\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                # Count the full sequence length\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                # Decide on replacements based on sequence length\\n                replace += length // 3\\n                if length % 3 == 0: \\n                    one_replace += 1\\n                elif length % 3 == 1: \\n                    two_replace += 1\\n            else:\\n                i += 1\\n\\n        # Handling different password lengths\\n        if len(password) < 6:\\n            return max(6 - len(password), types_missing)\\n        elif len(password) <= 20:\\n            return max(types_missing, replace)\\n        else:\\n            total_deletion = len(password) - 20\\n            replace -= min(total_deletion, one_replace * 1) // 1\\n            replace -= min(max(total_deletion - one_replace, 0), two_replace * 2) // 2\\n            replace -= max(total_deletion - one_replace - 2 * two_replace, 0) // 3\\n            \\n            return total_deletion + max(types_missing, replace)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        # Checking the presence of different types of characters in the password\\n        upper, lower, digit = 0, 0, 0\\n        for c in password:\\n            if \\'a\\' <= c <= \\'z\\':\\n                lower = 1\\n            elif \\'A\\' <= c <= \\'Z\\':\\n                upper = 1\\n            elif c.isdigit():\\n                digit = 1\\n        # Calculate how many types are missing\\n        types_missing = 3 - (upper + lower + digit)\\n\\n        # Addressing the issue of repetitive sequences\\n        replace = 0\\n        one_replace, two_replace = 0, 0\\n        i = 2\\n        while i < len(password):\\n            # Detect sequences of three identical characters\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                # Count the full sequence length\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                # Decide on replacements based on sequence length\\n                replace += length // 3\\n                if length % 3 == 0: \\n                    one_replace += 1\\n                elif length % 3 == 1: \\n                    two_replace += 1\\n            else:\\n                i += 1\\n\\n        # Handling different password lengths\\n        if len(password) < 6:\\n            return max(6 - len(password), types_missing)\\n        elif len(password) <= 20:\\n            return max(types_missing, replace)\\n        else:\\n            total_deletion = len(password) - 20\\n            replace -= min(total_deletion, one_replace * 1) // 1\\n            replace -= min(max(total_deletion - one_replace, 0), two_replace * 2) // 2\\n            replace -= max(total_deletion - one_replace - 2 * two_replace, 0) // 3\\n            \\n            return total_deletion + max(types_missing, replace)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951948,
                "title": "extremely-simple-o-n-solution-in-python-with-proper-explanation",
                "content": "# Intuition\\nPassword strength checkers can be annoying, but they\\'re super important. Let\\'s break this down.\\n\\nFirst things first, every strong password should have a mix of characters. So, I definitely need to check if the password has uppercase letters, lowercase letters, and numbers. For each type missing, I\\'d need to make a change, whether that\\'s a replacement or adding a character.\\n\\nNext, the length of the password. Too short? Gotta add characters. Too long? Time to trim it down. But if it\\'s in that sweet spot between 6 and 20 characters, I can leave it as it is.\\n\\nNow, the tricky part: those annoying sequences of repeating characters. Nobody wants a password like \\'aaabbb\\'. If I see a sequence like that, I need to break it up. Replacing one character in every set of three repeating characters should do the trick.\\n\\nBut here\\'s where it gets complicated: If I need to delete characters because the password is too long, I can use those deletions smartly to also break up the repeating sequences. For example, if I have \\'aaaa\\', deleting one \\'a\\' will break the sequence and I\\'d have killed two birds with one stone.\\n\\nFinally, I\\'ll just add up all the changes I need to make and that should give me the answer. Oh, and using regex for the repeating characters would make things a lot smoother.\\n\\n# Approach\\nBasically, we want a strong password that ticks all the boxes. It needs uppercase, lowercase, and numbers \\u2013 no shortcuts. Plus, it can\\'t be too short or too long, and those repeating characters? No can do!\\n\\nFirst step, let\\'s see what\\'s missing. Uppercase? Lowercase? Numbers? Gonna check for each and figure out what swaps we might need.\\n\\nNow, about those repeating characters. I\\'m thinking regex is the move here. It\\'s like a magic pattern thing. Gonna snag those sequences that keep going on and on. That should tell us how much we gotta tweak things.\\n\\nLength time. If it\\'s way too short, we\\'ll throw in some extra characters. If it\\'s pushing the limits, we\\'ll cut back. But here\\'s the trick: while we\\'re trimming, might as well deal with those pesky repeats. Double duty, you know?\\n\\nWrapping it up, we\\'ll count up all the changes we\\'ve made. That\\'ll give us the scoop on how much work it\\'ll take to make this password super solid.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the code is **O(n)**, where n is the length of the input password. The main factors contributing to the time complexity are the checks for character types and the search for repeating sequences using regex.\\n\\n- Space complexity:\\nThe space complexity of the code is **O(n)**, as it depends on the space required to store the repeating sequences found by the regex search. Other variables and data structures used in the code occupy constant space.\\n\\n\\n\\n\\n# Code\\n```\\nimport re\\n\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        # Checking for the presence of each character type in the password\\n        types = [any(c.islower() for c in password), any(c.isupper() for c in password), any(c.isdigit() for c in password)]\\n        \\n        # Calculating replacements for missing character types\\n        replace_types = 3 - sum(types)\\n        \\n        # Using regex to identify sequences of repeating characters\\n        repeats = [match.group() for match in re.finditer(r\"(.)\\\\1{2,}\", password)]\\n        one_mod, two_mod, repeat_replace = sum(len(r) % 3 == 0 for r in repeats), sum(len(r) % 3 == 1 for r in repeats), sum(len(r) // 3 for r in repeats)\\n        \\n        # Handling cases based on password length\\n        if len(password) < 6:\\n            return max(replace_types, 6 - len(password))\\n        \\n        if len(password) <= 20:\\n            return max(replace_types, repeat_replace)\\n        \\n        # Adjusting replacements based on required deletions for passwords > 20 chars\\n        delete_required = len(password) - 20\\n        \\n        # Prioritize the one_mod and two_mod deletions first\\n        delete_one_mod = min(delete_required, one_mod)\\n        repeat_replace -= delete_one_mod\\n        delete_required -= delete_one_mod\\n        \\n        delete_two_mod = min(delete_required, two_mod * 2) // 2\\n        repeat_replace -= delete_two_mod\\n        delete_required -= delete_two_mod * 2\\n        \\n        # Now, handle the deletions required from the regular repeat_replace\\n        delete_three_mod = delete_required // 3\\n        repeat_replace -= delete_three_mod\\n        delete_required -= delete_three_mod * 3\\n        \\n        # Final calculation of operations required to make the password strong\\n        return len(password) - 20 + max(replace_types, repeat_replace)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport re\\n\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        # Checking for the presence of each character type in the password\\n        types = [any(c.islower() for c in password), any(c.isupper() for c in password), any(c.isdigit() for c in password)]\\n        \\n        # Calculating replacements for missing character types\\n        replace_types = 3 - sum(types)\\n        \\n        # Using regex to identify sequences of repeating characters\\n        repeats = [match.group() for match in re.finditer(r\"(.)\\\\1{2,}\", password)]\\n        one_mod, two_mod, repeat_replace = sum(len(r) % 3 == 0 for r in repeats), sum(len(r) % 3 == 1 for r in repeats), sum(len(r) // 3 for r in repeats)\\n        \\n        # Handling cases based on password length\\n        if len(password) < 6:\\n            return max(replace_types, 6 - len(password))\\n        \\n        if len(password) <= 20:\\n            return max(replace_types, repeat_replace)\\n        \\n        # Adjusting replacements based on required deletions for passwords > 20 chars\\n        delete_required = len(password) - 20\\n        \\n        # Prioritize the one_mod and two_mod deletions first\\n        delete_one_mod = min(delete_required, one_mod)\\n        repeat_replace -= delete_one_mod\\n        delete_required -= delete_one_mod\\n        \\n        delete_two_mod = min(delete_required, two_mod * 2) // 2\\n        repeat_replace -= delete_two_mod\\n        delete_required -= delete_two_mod * 2\\n        \\n        # Now, handle the deletions required from the regular repeat_replace\\n        delete_three_mod = delete_required // 3\\n        repeat_replace -= delete_three_mod\\n        delete_required -= delete_three_mod * 3\\n        \\n        # Final calculation of operations required to make the password strong\\n        return len(password) - 20 + max(replace_types, repeat_replace)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947611,
                "title": "100-speed-comments-no-fancy-algorithms-just-logic",
                "content": "# Approach\\nCore ideas:\\n    1. We can utilize same action for solving multiple problems\\n    2. Each insert can reduce sequence size by 2\\n    3. For each sequence we need length // 3 replacements\\n    4. We can solve unsafe sequences with deletions but we need to delete chars from the sequenses with least (length % 3) value.\\n\\nFLow:\\n    1. We fix password length, so we know how many insertions/deletions we have.\\n    2. We utilize deletions deleting per 1 char from sequences with least (length % 3).\\n    3. We utilize insertions deleting per 2 characters from sequence.\\n    4. All unsolved sequences we solve with replacements\\n    5. We fix problem with missing characters with additional replacements (if needed).\\n\\n# Complexity\\n- Time complexity (worst case, commend if you know more precise value):\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfn check_has_digit(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 48 && ch as u8 <= 57 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn check_has_lowercase(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 97 && ch as u8 <= 122 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn check_has_uppercase(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 65 && ch as u8 <= 90 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn find_sequences(password: & String) -> Vec<i32> {\\n    /*\\n        Finds all unsafe sequences and returns vector of their lengths\\n    */\\n    let mut seq: i32 = 1;\\n    let mut sequences: Vec<i32> = Vec::new();\\n    if password.len() < 3 {\\n        return sequences\\n    }\\n    let mut prev: char = password.chars().next().unwrap();\\n    for ch in password.chars().skip(1) {\\n        if ch == prev {\\n            seq += 1\\n        }\\n        else {\\n            if seq >= 3 {\\n                sequences.push(seq);\\n            }\\n            seq = 1\\n        }\\n        prev = ch;\\n    }\\n    if seq >= 3 {\\n        sequences.push(seq);\\n    }\\n    return sequences\\n}\\n\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        /*\\n            Core ideas:\\n            1. We can utilize same action for solving multiple problems\\n            2. Each insert can reduce sequence size by 2\\n            3. For each sequence we need length // 3 replacements\\n            4. We can solve unsafe sequences with deletions but we need to delete chars from the sequenses with least (length % 3) value.\\n\\n            FLow:\\n            1. We fix password length, so we know how many insertions/deletions we have.\\n            2. We utilize deletions deleting per 1 char from sequences with least (length % 3).\\n            3. We utilize insertions deleting per 2 characters from sequence.\\n            4. All unsolved sequences we solve with replacements\\n            5. We fix problem with missing characters with additional replacements (if needed).\\n        */\\n        let length = password.len() as i32;\\n        let mut char_actions: i32 = 0;\\n        if !check_has_digit(&password) {char_actions += 1};\\n        if !check_has_lowercase(&password) {char_actions += 1};\\n        if !check_has_uppercase(&password) {char_actions += 1};\\n        let mut insertions: i32 = 0;\\n        let mut deletions: i32 = 0;\\n        let mut replations: i32 = 0;\\n\\n        // fix length\\n        if length > 20 {\\n            deletions += length - 20;\\n        }\\n        if length < 6 {\\n            insertions += 6 - length;\\n        }\\n\\n        // find unsafe sequences\\n        let mut sequences = find_sequences(&password);\\n\\n        // utilize deletions\\n        if deletions > 0 {\\n            let mut i = deletions;\\n            loop {\\n                sequences.sort_by_key(|x| x % 3);\\n                let i0 = i;\\n                for s in 0..sequences.len(){\\n                    if sequences[s] < 3 {continue}\\n                    sequences[s] -= 1;\\n                    i -= 1;\\n                    break\\n                }\\n                if i == 0 || i == i0 { break }\\n            }\\n        }\\n\\n        // utilize insertions\\n        if insertions > 0 {\\n            let mut i = insertions;\\n            loop {\\n                let i0 = i;\\n                for s in 0..sequences.len(){\\n                    if sequences[s] < 3 {continue}\\n                    sequences[s] -= 2;\\n                    i -= 1;\\n                    if i == 0 { break }\\n                }\\n                if i == 0 || i == i0 { break }\\n            }\\n        }\\n\\n        // fix all other sequences with replacements\\n        let mut seq_operations = 0;\\n        for seq in sequences {\\n            if seq >= 3 {\\n                seq_operations += seq / 3;\\n            }\\n        }\\n        replations += seq_operations;\\n\\n        // fix missing characters\\n        char_actions = char_actions - replations - insertions;\\n        if char_actions < 0 {char_actions = 0};\\n        replations += char_actions;\\n\\n        return deletions + replations + insertions\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn check_has_digit(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 48 && ch as u8 <= 57 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn check_has_lowercase(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 97 && ch as u8 <= 122 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn check_has_uppercase(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 65 && ch as u8 <= 90 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn find_sequences(password: & String) -> Vec<i32> {\\n    /*\\n        Finds all unsafe sequences and returns vector of their lengths\\n    */\\n    let mut seq: i32 = 1;\\n    let mut sequences: Vec<i32> = Vec::new();\\n    if password.len() < 3 {\\n        return sequences\\n    }\\n    let mut prev: char = password.chars().next().unwrap();\\n    for ch in password.chars().skip(1) {\\n        if ch == prev {\\n            seq += 1\\n        }\\n        else {\\n            if seq >= 3 {\\n                sequences.push(seq);\\n            }\\n            seq = 1\\n        }\\n        prev = ch;\\n    }\\n    if seq >= 3 {\\n        sequences.push(seq);\\n    }\\n    return sequences\\n}\\n\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        /*\\n            Core ideas:\\n            1. We can utilize same action for solving multiple problems\\n            2. Each insert can reduce sequence size by 2\\n            3. For each sequence we need length // 3 replacements\\n            4. We can solve unsafe sequences with deletions but we need to delete chars from the sequenses with least (length % 3) value.\\n\\n            FLow:\\n            1. We fix password length, so we know how many insertions/deletions we have.\\n            2. We utilize deletions deleting per 1 char from sequences with least (length % 3).\\n            3. We utilize insertions deleting per 2 characters from sequence.\\n            4. All unsolved sequences we solve with replacements\\n            5. We fix problem with missing characters with additional replacements (if needed).\\n        */\\n        let length = password.len() as i32;\\n        let mut char_actions: i32 = 0;\\n        if !check_has_digit(&password) {char_actions += 1};\\n        if !check_has_lowercase(&password) {char_actions += 1};\\n        if !check_has_uppercase(&password) {char_actions += 1};\\n        let mut insertions: i32 = 0;\\n        let mut deletions: i32 = 0;\\n        let mut replations: i32 = 0;\\n\\n        // fix length\\n        if length > 20 {\\n            deletions += length - 20;\\n        }\\n        if length < 6 {\\n            insertions += 6 - length;\\n        }\\n\\n        // find unsafe sequences\\n        let mut sequences = find_sequences(&password);\\n\\n        // utilize deletions\\n        if deletions > 0 {\\n            let mut i = deletions;\\n            loop {\\n                sequences.sort_by_key(|x| x % 3);\\n                let i0 = i;\\n                for s in 0..sequences.len(){\\n                    if sequences[s] < 3 {continue}\\n                    sequences[s] -= 1;\\n                    i -= 1;\\n                    break\\n                }\\n                if i == 0 || i == i0 { break }\\n            }\\n        }\\n\\n        // utilize insertions\\n        if insertions > 0 {\\n            let mut i = insertions;\\n            loop {\\n                let i0 = i;\\n                for s in 0..sequences.len(){\\n                    if sequences[s] < 3 {continue}\\n                    sequences[s] -= 2;\\n                    i -= 1;\\n                    if i == 0 { break }\\n                }\\n                if i == 0 || i == i0 { break }\\n            }\\n        }\\n\\n        // fix all other sequences with replacements\\n        let mut seq_operations = 0;\\n        for seq in sequences {\\n            if seq >= 3 {\\n                seq_operations += seq / 3;\\n            }\\n        }\\n        replations += seq_operations;\\n\\n        // fix missing characters\\n        char_actions = char_actions - replations - insertions;\\n        if char_actions < 0 {char_actions = 0};\\n        replations += char_actions;\\n\\n        return deletions + replations + insertions\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931917,
                "title": "beats-100-00-of-users-with-c-runtime-0-ms",
                "content": "# Strong Password Checker\\n\\n## Intuition\\n\\nThe problem requires us to determine the minimum number of steps required to make a given password strong. To achieve this, we need to address the following aspects:\\n1. Ensure the password has a sufficient length of at least 6 characters and at most 20 characters.\\n2. Check for the presence of at least one lowercase letter, one uppercase letter, and one digit.\\n3. Avoid having three consecutive repeating characters.\\n\\n## Approach\\n\\nTo solve this problem, we can follow these steps:\\n\\n1. Calculate the number of missing character types (lowercase, uppercase, digit) in the password.\\n2. Iterate through the password to identify consecutive repeating substrings. For each repeating substring of length 3 or more, calculate the number of changes needed to break the repetition while keeping each segment\\'s length as close to 3 as possible.\\n3. Based on the password\\'s length, perform the following checks:\\n   - If the password length is less than 6, add the missing character types and the difference between 6 and the password length to the total changes.\\n   - If the password length is between 6 and 20, take the maximum of missing character types and changes required from repeating substrings.\\n4. If the password length exceeds 20 characters, calculate the number of deletions required to bring it down to 20. Then, reduce the number of changes based on the deletions while considering repeating substrings.\\n5. Return the final count of changes required, which represents the minimum steps to make the password strong.\\n\\n## Complexity Analysis\\n\\n- **Time Complexity**: The solution iterates through the password string once to calculate missing character types and repeating substrings. The overall time complexity is O(n), where n is the length of the password.\\n- **Space Complexity**: The solution uses a constant amount of extra space to store variables and temporary calculations, resulting in O(1) space complexity.\\n\\n## Code Template\\n\\nHere\\'s a possible implementation of the approach:\\n\\n```cpp\\n#include <algorithm>\\n#include <cctype>\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n = password.size();\\n        int missingTypes = 3;\\n        \\n        // Check for missing character types\\n        if (any_of(password.begin(), password.end(), [](char c) { return islower(c); })) missingTypes--;\\n        if (any_of(password.begin(), password.end(), [](char c) { return isupper(c); })) missingTypes--;\\n        if (any_of(password.begin(), password.end(), [](char c) { return isdigit(c); })) missingTypes--;\\n\\n        int changes = 0, oneRepeat = 0, twoRepeats = 0;\\n        \\n        // Find repeating substrings\\n        for (int i = 2; i < n; i++) {\\n            if (password[i] == password[i - 1] && password[i - 1] == password[i - 2]) {\\n                int length = 2;\\n                while (i < n && password[i] == password[i - 1]) {\\n                    length++;\\n                    i++;\\n                }\\n                changes += length / 3;\\n                if (length % 3 == 0) oneRepeat++;\\n                if (length % 3 == 1) twoRepeats++;\\n                i--;\\n            }\\n        }\\n\\n        // Determine the changes required\\n        if (n < 6) {\\n            return max(missingTypes, 6 - n);\\n        } else if (n <= 20) {\\n            return max(missingTypes, changes);\\n        } else {\\n            int deletions = n - 20;\\n            changes -= min(deletions, oneRepeat * 1) / 1;\\n            changes -= min(max(deletions - oneRepeat, 0), twoRepeats * 2) / 2;\\n            changes -= min(max(deletions - oneRepeat - 2 * twoRepeats, 0), changes * 3) / 3;\\n            return deletions + max(missingTypes, changes);\\n        }\\n    }\\n};\\n```\\n\\n## Summary\\n\\nThis solution template provides an approach to solving the \"Strong Password Checker\" problem efficiently. It systematically addresses each condition required for a password to be strong and calculates the minimum steps needed to achieve a strong password.",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```cpp\\n#include <algorithm>\\n#include <cctype>\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n = password.size();\\n        int missingTypes = 3;\\n        \\n        // Check for missing character types\\n        if (any_of(password.begin(), password.end(), [](char c) { return islower(c); })) missingTypes--;\\n        if (any_of(password.begin(), password.end(), [](char c) { return isupper(c); })) missingTypes--;\\n        if (any_of(password.begin(), password.end(), [](char c) { return isdigit(c); })) missingTypes--;\\n\\n        int changes = 0, oneRepeat = 0, twoRepeats = 0;\\n        \\n        // Find repeating substrings\\n        for (int i = 2; i < n; i++) {\\n            if (password[i] == password[i - 1] && password[i - 1] == password[i - 2]) {\\n                int length = 2;\\n                while (i < n && password[i] == password[i - 1]) {\\n                    length++;\\n                    i++;\\n                }\\n                changes += length / 3;\\n                if (length % 3 == 0) oneRepeat++;\\n                if (length % 3 == 1) twoRepeats++;\\n                i--;\\n            }\\n        }\\n\\n        // Determine the changes required\\n        if (n < 6) {\\n            return max(missingTypes, 6 - n);\\n        } else if (n <= 20) {\\n            return max(missingTypes, changes);\\n        } else {\\n            int deletions = n - 20;\\n            changes -= min(deletions, oneRepeat * 1) / 1;\\n            changes -= min(max(deletions - oneRepeat, 0), twoRepeats * 2) / 2;\\n            changes -= min(max(deletions - oneRepeat - 2 * twoRepeats, 0), changes * 3) / 3;\\n            return deletions + max(missingTypes, changes);\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3928985,
                "title": "relatively-readable",
                "content": "# Intuition\\n\\nGather data first then do the necessary looping\\n\\n# Approach\\nget to [6..20] and then do replaces as needed to avoid 3 in row and/or missing type of character\\n\\n# Complexity\\n- Time complexity:\\nmeh\\n\\n- Space complexity:\\nlight\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        result = 0\\n        \\n        has_upper = False\\n        has_lower = False\\n        has_digit = False\\n        l = len(password)\\n        less_than_06 = l < 6\\n        more_than_20 = l > 20\\n        diff_len = 0\\n        if less_than_06: diff_len = 6 - l\\n        if more_than_20: diff_len = l - 20\\n        repeats = []\\n        prev_letter = \\'\\'\\n        current_counter = 0\\n        modifies_needed = 0\\n        for letter in password:\\n            if letter.isupper(): has_upper = True\\n            if letter.islower(): has_lower = True\\n            if letter.isdigit(): has_digit = True\\n            if letter == prev_letter:\\n                current_counter += 1\\n            else:\\n                if current_counter >= 3:\\n                    repeats.append(current_counter)\\n                prev_letter = letter\\n                current_counter = 1\\n        if current_counter >= 3:\\n            repeats.append(current_counter)\\n        \\n        if not has_upper: modifies_needed += 1\\n        if not has_lower: modifies_needed += 1\\n        if not has_digit: modifies_needed += 1\\n        \\n        if more_than_20:\\n            # deletes\\n            while True:\\n                work = False\\n                repeats.sort(key=lambda x: x%3)\\n                for i in range(len(repeats)):\\n                    if repeats[i] < 3: continue\\n                    work = True\\n                    repeats[i] -= 1\\n                    diff_len -= 1\\n                    result += 1\\n                    break\\n                if not diff_len or not work: break\\n            result += diff_len\\n        if less_than_06:\\n            # inserts\\n            result += diff_len\\n            modifies_needed -= diff_len\\n            diff_len = 0\\n            if repeats: repeats[0] -= 2\\n\\n        # replaces\\n        for i in range(len(repeats)):\\n            if repeats[i] < 3: continue\\n            replaces = repeats[i] // 3\\n            result += replaces\\n            modifies_needed -= replaces\\n\\n        result += max(modifies_needed, 0)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        result = 0\\n        \\n        has_upper = False\\n        has_lower = False\\n        has_digit = False\\n        l = len(password)\\n        less_than_06 = l < 6\\n        more_than_20 = l > 20\\n        diff_len = 0\\n        if less_than_06: diff_len = 6 - l\\n        if more_than_20: diff_len = l - 20\\n        repeats = []\\n        prev_letter = \\'\\'\\n        current_counter = 0\\n        modifies_needed = 0\\n        for letter in password:\\n            if letter.isupper(): has_upper = True\\n            if letter.islower(): has_lower = True\\n            if letter.isdigit(): has_digit = True\\n            if letter == prev_letter:\\n                current_counter += 1\\n            else:\\n                if current_counter >= 3:\\n                    repeats.append(current_counter)\\n                prev_letter = letter\\n                current_counter = 1\\n        if current_counter >= 3:\\n            repeats.append(current_counter)\\n        \\n        if not has_upper: modifies_needed += 1\\n        if not has_lower: modifies_needed += 1\\n        if not has_digit: modifies_needed += 1\\n        \\n        if more_than_20:\\n            # deletes\\n            while True:\\n                work = False\\n                repeats.sort(key=lambda x: x%3)\\n                for i in range(len(repeats)):\\n                    if repeats[i] < 3: continue\\n                    work = True\\n                    repeats[i] -= 1\\n                    diff_len -= 1\\n                    result += 1\\n                    break\\n                if not diff_len or not work: break\\n            result += diff_len\\n        if less_than_06:\\n            # inserts\\n            result += diff_len\\n            modifies_needed -= diff_len\\n            diff_len = 0\\n            if repeats: repeats[0] -= 2\\n\\n        # replaces\\n        for i in range(len(repeats)):\\n            if repeats[i] < 3: continue\\n            replaces = repeats[i] // 3\\n            result += replaces\\n            modifies_needed -= replaces\\n\\n        result += max(modifies_needed, 0)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928526,
                "title": "c-100-acceptance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe provided code appears to address the problem of making a given string into a strong password while minimizing the number of changes. Here\\'s an attempt to deduce the intuition behind the approach based on the code and the available comments:\\n\\nPassword Strength Criteria:\\nA strong password typically has the following characteristics:\\n\\nAt least 6 characters in length.\\nContains at least one uppercase letter, one lowercase letter, and one digit.\\nDoes not contain repeating substrings of a certain length (e.g., more than 2).\\nBalancing Changes:\\nThe core idea seems to be balancing the additions, deletions, and replacements needed to satisfy the password requirements. The strategy is to minimize replacements (which can be more disruptive) by judiciously deleting characters from repetitions, if possible.\\n\\nOptimizing for Short and Long Strings:\\nThe code divides the problem into two cases: strings with lengths up to 20 characters (s.length() <= 20) and strings longer than 20 characters (s.length() > 20).\\n\\nFor short strings, the focus is on identifying three-repeating substrings and deciding whether to add a character or replace a character to break the repetition while satisfying the requirements.\\nFor long strings, a more complex approach is taken to analyze repetitions of different lengths and perform deletions to minimize replacements. The idea is to reduce the overall number of changes by considering different ways to delete characters.\\nIterative Strategy:\\nBoth cases involve iterations through the string to identify patterns and repetitions. By identifying repetitions and the lengths at which they occur, the code tries to determine optimal actions (deletions, replacements, additions) to achieve the strong password criteria.\\n\\nGreedy and Target-Oriented:\\nThe approach seems to be somewhat greedy, as it aims to make the best local choices (deletions, replacements, additions) that will lead to a strong password overall. The strategy adapts based on the specific requirements and the number of deletions and additions available.\\n\\nComplexity Management:\\nThe code takes advantage of certain patterns to avoid excessive replacements, which could disrupt the overall structure of the string. Instead, it focuses on deletions as a means of reducing the necessary changes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem seems to be about modifying a given string to make it a strong password while minimizing the number of modifications. A strong password is typically defined to meet certain criteria, such as having a minimum length, containing uppercase letters, lowercase letters, and digits, and not containing repeating substrings longer than a certain length.\\n\\nThe code\\'s approach can be summarized as follows:\\n\\nPreparation:\\n\\nCalculate the number of deletions needed to bring the length of the string to at most 20 characters (deleteTarget).\\nCalculate the number of additions needed to bring the length of the string to at least 6 characters (addTarget).\\nFor Cases of Short String (s.length() <= 20):\\n\\nTraverse through the string character by character to track whether there\\'s a need for uppercase letters, lowercase letters, and digits.\\nIdentify three-repeating substrings and decide whether to add a character within the substring to break the repetition (toAdd) or replace a character to avoid repetition (toReplace).\\nCalculate the minimum number of changes needed to satisfy the password requirements in case of a short string.\\nFor Cases of Long String (s.length() > 20):\\n\\nAnalyze the repetitions of different lengths in the string and record their frequencies in lenCnts.\\nAttempt to delete characters from repetitions of various lengths to minimize replacements:\\nDelete one character from repetitions with lengths that are multiples of 3.\\nDelete two characters from repetitions with lengths that leave a remainder of 1 when divided by 3.\\nDelete three characters (a repetition) to minimize replacements if available.\\nCalculate the total number of replacements needed based on the remaining repetitions.\\nCalculate Final Result:\\n\\nAdjust the deletions and replacements based on the calculated targets and remaining deletions.\\nReturn the total number of deletions and replacements needed to satisfy the password requirements.\\nThe approach seems to be focused on analyzing the input string for repetitions and strategically deciding whether to delete, add, or replace characters in order to achieve a strong password with minimal modifications.\\n\\nPlease note that the provided code snippet lacks detailed explanations for each step, and the comments appear to be cut off in places. To fully understand the approach, you might need access to the complete code or more detailed comments that provide insights into each decision made during the process.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the provided code is somewhat intricate due to the various loops and conditional checks it contains. Let\\'s break down the different parts and analyze the time complexity:\\n\\nFor cases of s.length() <= 20:\\nIn this section, you have a loop that goes through the string character by character. The loop runs once for each character in the string, performing constant-time operations within the loop body. Thus, the time complexity of this part is O(n), where n is the length of the input string s.\\n\\nFor cases of s.length() > 20:\\nThis section involves two nested loops. The outer loop iterates through repetitions of different lengths, and the inner loop iterates through the repetitions of a specific length. The total number of iterations in the outer loop is bounded by the maximum repetition length, which is proportional to the length of the input string s.\\n\\nWithin the inner loop, you are performing constant-time operations for each repetition\\'s length. The number of repetitions at each length is recorded in a data structure (unordered_map). Since you\\'re iterating over these repetitions, the time complexity for this section can be approximated as O(n), where n is the length of the input string.\\n\\nOverall:\\nThe code runs through the two main sections sequentially, and both sections have a time complexity of O(n). Therefore, the overall time complexity of the code can be considered O(n), where n is the length of the input string s.\\n\\nKeep in mind that this analysis provides a high-level estimate of the time complexity based on the loops and operations performed in the code. The actual execution time may vary depending on the specifics of the input data and how the code interacts with the underlying hardware.\\n\\nAs always, when analyzing time complexity, it\\'s important to consider the worst-case scenario and the dominant factors affecting the runtime.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the provided code can be analyzed by considering the memory used by various data structures and variables.\\n\\nVariables and Data Structures:\\n\\ndeleteTarget, addTarget, toDelete, toAdd, toReplace, needUpper, needLower, needDigit: These are all individual integer variables. They occupy constant space regardless of the input size, so they contribute to O(1) space complexity.\\nlenCnts: This is a vector of unordered_maps used to record repetition frequencies. The space used by lenCnts depends on the number of different repetition lengths and the frequency of each length. In the worst case, if there are many different repetition lengths, the space complexity for lenCnts could approach O(n), where n is the length of the input string s.\\nOverall:\\nThe main contributing factor to the space complexity is the lenCnts vector of unordered_maps. Since it\\'s the largest data structure that scales with input size, the space complexity can be approximated as O(n) in the worst case, where n is the length of the input string s.\\n\\nKeep in mind that the space complexity analysis focuses on the memory used by the algorithm as it runs, and it doesn\\'t take into account the memory used by the input itself (the string s) or any temporary variables created during execution. The analysis provides an understanding of how the memory requirements of the algorithm grow with the size of the input.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it\\'s a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we\\'ll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```\\n![Screenshot 2023-08-19 004842.png](https://assets.leetcode.com/users/images/37f1f0d8-9e06-42a2-8c41-d596d4cfe211_1692386355.21834.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it\\'s a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we\\'ll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907858,
                "title": "python-beats-89-53-well-explained-solution",
                "content": "# Intuition\\nThe goal is to determine the minimum number of steps required to make a given password strong by satisfying certain conditions. These conditions include the length of the password, the presence of lowercase, uppercase, and digit characters, and the prevention of three repeating characters in a row.\\n\\n# Approach\\n1. Initialize missing_type to 3, which represents the    \\nnumber of missing character types (lowercase, uppercase, and digit).\\n2. Check if the password contains lowercase, uppercase, and digit characters, and decrement missing_type accordingly.\\n3. Initialize variables change, one, and two to keep track of changes required and repeating character counts.\\n4. Iterate through the password from the third character onward.\\n    - If three consecutive characters are the same, calculate the length of the repeating sequence. Update change based on the length divided by 3. Update one and two based on the remainder of the length divided by 3.\\n    - Otherwise, move to the next character.\\n5. Handle cases based on the length of the password:\\n    - If the length is less than 6, return the maximum of missing_type and the difference between 6 and the length of the password.\\n    - If the length is between 6 and 20 (inclusive), return the maximum of missing_type and change.\\n    - If the length is greater than 20, calculate the number of deletions required and adjust change accordingly.\\n6. Return the result of the calculation based on the length of the password and the conditions met.\\n\\n# Complexity\\n- Time complexity:\\nO(N), where N is the length of the input password. The code iterates through the password once to analyze the character types and repeating sequences.\\n\\n- Space complexity:\\nO(1), as the algorithm uses a constant amount of extra space to store variables regardless of the input size.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901274,
                "title": "36ms-python3-solution",
                "content": "# Intuition\\nTo create a strong password, the constraints require having at least one lowercase letter, one uppercase letter, one digit, a length between 6 and 20 characters, and no three repeating characters in a row. \\n\\n1. **Identifying Missing Types**: Start by identifying the missing character types (lowercase, uppercase, digit) that are required to make the password strong. \\n\\n2. **Handling Repeating Characters**: Iterate through the password to find sequences of three or more repeating characters. Divide the length of each sequence by three to find the number of replacements needed, and keep track of remainders to understand how insertions or deletions may affect these sequences.\\n\\n3. **Length Constraints**: If the password is shorter than 6 characters, either a missing type or an extra character should be added. If the password is longer than 20 characters, characters must be deleted.\\n\\n4. **Combining Steps**: Combine the missing types and the required changes to find the minimum steps needed to make the password strong. This includes using deletions to reduce the number of replacements when the password is too long.\\n\\nBy analyzing all constraints and calculating how to meet each one with the minimum number of steps, we can efficiently find the minimum steps required to make the password strong.\\n# Approach\\n1. **Figure Out What\\'s Missing**: First, I checked to see what\\'s missing in the password. Does it have lowercase, uppercase, and digits? If anything\\'s missing, that\\'s going to be something we need to fix.\\n\\n2. **Deal with Repeating Characters**: Next, I tackled those annoying repeating characters. If any character repeated three or more times in a row, I calculated how many changes we\\'d need. I also kept tabs on the remainder of dividing by three to help figure out the best way to handle things later.\\n\\n3. **Too Short or Too Long?**: Then, I looked at the length of the password. If it\\'s less than 6 characters, we\\'ll need to add something. If it\\'s more than 20, we\\'ll need to delete. I used the remainder from step 2 to minimize the number of replacements needed when deleting characters.\\n\\n4. **Put It All Together**: Finally, I added up all the missing types, changes, deletions, or additions to get the minimum steps needed to make that password strong. It\\'s like putting together a puzzle, making sure each piece fits just right.\\n\\nBy breaking down the problem and tackling each part methodically, I was able to create a step-by-step approach to make any password strong. It\\'s a neat little solution that handles a lot of different scenarios efficiently!\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the code is $$O(n)$$, where $$n$$ is the length of the password. The code iterates through the password string, performing constant-time operations, resulting in a linear time complexity. The reported runtime of 36ms is in line with this analysis.\\n- Space complexity:\\nThe space complexity of the code is $$O(1)$$, as we are only using a constant amount of extra space, irrespective of the input size.\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        missing_types = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in password):\\n            missing_types -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in password):\\n            missing_types -= 1\\n        if any(c.isdigit() for c in password):\\n            missing_types -= 1\\n\\n        change = 0\\n        one, two, three = 0, 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                change += length // 3\\n                one += length % 3 == 0\\n                two += length % 3 == 1\\n                three += length % 3 == 2\\n            i += 1\\n\\n        n = len(password)\\n        if n < 6:\\n            return max(missing_types, 6 - n)\\n        elif n <= 20:\\n            return max(missing_types, change)\\n        else:\\n            deletes_needed = n - 20\\n            change -= min(deletes_needed, one * 1) // 1\\n            change -= min(max(deletes_needed - one, 0), two * 2) // 2\\n            change -= max(deletes_needed - one - 2 * two, 0) // 3\\n\\n            return deletes_needed + max(missing_types, change)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        missing_types = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in password):\\n            missing_types -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in password):\\n            missing_types -= 1\\n        if any(c.isdigit() for c in password):\\n            missing_types -= 1\\n\\n        change = 0\\n        one, two, three = 0, 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                change += length // 3\\n                one += length % 3 == 0\\n                two += length % 3 == 1\\n                three += length % 3 == 2\\n            i += 1\\n\\n        n = len(password)\\n        if n < 6:\\n            return max(missing_types, 6 - n)\\n        elif n <= 20:\\n            return max(missing_types, change)\\n        else:\\n            deletes_needed = n - 20\\n            change -= min(deletes_needed, one * 1) // 1\\n            change -= min(max(deletes_needed - one, 0), two * 2) // 2\\n            change -= max(deletes_needed - one - 2 * two, 0) // 3\\n\\n            return deletes_needed + max(missing_types, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900094,
                "title": "detail-explaination-helpful-for-others-to-solve",
                "content": "# Intuition\\nThe code analyzes the password\\'s character composition and the repeating patterns to determine the necessary changes to meet the strong password criteria. It considers factors like the total number of missing character types, the length of the password, and how to optimize the replacement and deletion of characters to ensure a strong password while minimizing changes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize variables to track whether the password has at least one lowercase letter (a), one uppercase letter (A), and one digit (d), all initially set to 1.\\n2. Convert the password string into a character array for easier manipulation.\\n3. Create an integer array to store the length of consecutive repeating characters in the password.\\n4. Loop through the password characters to identify the repeating character lengths and update the lowercase, uppercase, and digit variables.\\n5. Calculate the total number of missing character types (total_missing) based on the a, A, and d variables.\\n6. Check if the password length is less than 6 characters:\\nIf so, calculate the number of changes needed to meet the password length requirement of at least 6 characters, adding it to the result.\\n7. If the password length is 6 or more characters:\\nCalculate the excess length (over_len) beyond the maximum allowed password length of 20 characters.\\nIterate through different groupings (k = 1 to 2) of repeating characters to minimize changes and decrement over_len.\\nIterate through the array of repeating character lengths:\\nIf the repeating length is at least 3 and over_len is greater than 0, adjust the repeating length and decrement over_len.\\nIf the repeating length is at least 3, calculate the leftover repeating character lengths that can be grouped.\\n8. Calculate the result based on the total_missing, over_len, and leftover repeating character lengths.\\n9. Return the final result, indicating the minimum changes required to make the password strong.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = password.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = a + A + d;\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = password.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = a + A + d;\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899334,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int strongPasswordChecker(string s) {\\n    const int n = s.length();\\n    const int missing = getMissing(s);\\n    // # of replacements to deal with 3 repeating characters\\n    int replaces = 0;\\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\\n    int oneSeq = 0;\\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\\n    int twoSeq = 0;\\n\\n    for (int i = 2; i < n;)\\n      if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {\\n        int length = 2;  // Length of repeating s\\n        while (i < n && s[i] == s[i - 1]) {\\n          ++length;\\n          ++i;\\n        }\\n        replaces += length / 3;  // \\'aaaaaaa\\' -> \\'aaxaaxa\\'\\n        if (length % 3 == 0)\\n          ++oneSeq;\\n        if (length % 3 == 1)\\n          ++twoSeq;\\n      } else {\\n        ++i;\\n      }\\n\\n    if (n < 6)\\n      return max(6 - n, missing);\\n    if (n <= 20)\\n      return max(replaces, missing);\\n\\n    const int deletes = n - 20;\\n    // Each replacement in (3k)-seqs can be substituted with 1 deletions\\n    replaces -= min(oneSeq, deletes);\\n    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions\\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) / 2;\\n    // Each replacement in other seqs can be substituted with 3 deletions\\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) / 3;\\n    return deletes + max(replaces, missing);\\n  }\\n\\n private:\\n  int getMissing(const string& s) {\\n    int missing = 3;\\n    if (any_of(s.begin(), s.end(), [](char c) { return isupper(c); }))\\n      --missing;\\n    if (any_of(s.begin(), s.end(), [](char c) { return islower(c); }))\\n      --missing;\\n    if (any_of(s.begin(), s.end(), [](char c) { return isdigit(c); }))\\n      --missing;\\n    return missing;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int strongPasswordChecker(string s) {\\n    const int n = s.length();\\n    const int missing = getMissing(s);\\n    // # of replacements to deal with 3 repeating characters\\n    int replaces = 0;\\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\\n    int oneSeq = 0;\\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\\n    int twoSeq = 0;\\n\\n    for (int i = 2; i < n;)\\n      if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {\\n        int length = 2;  // Length of repeating s\\n        while (i < n && s[i] == s[i - 1]) {\\n          ++length;\\n          ++i;\\n        }\\n        replaces += length / 3;  // \\'aaaaaaa\\' -> \\'aaxaaxa\\'\\n        if (length % 3 == 0)\\n          ++oneSeq;\\n        if (length % 3 == 1)\\n          ++twoSeq;\\n      } else {\\n        ++i;\\n      }\\n\\n    if (n < 6)\\n      return max(6 - n, missing);\\n    if (n <= 20)\\n      return max(replaces, missing);\\n\\n    const int deletes = n - 20;\\n    // Each replacement in (3k)-seqs can be substituted with 1 deletions\\n    replaces -= min(oneSeq, deletes);\\n    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions\\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) / 2;\\n    // Each replacement in other seqs can be substituted with 3 deletions\\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) / 3;\\n    return deletes + max(replaces, missing);\\n  }\\n\\n private:\\n  int getMissing(const string& s) {\\n    int missing = 3;\\n    if (any_of(s.begin(), s.end(), [](char c) { return isupper(c); }))\\n      --missing;\\n    if (any_of(s.begin(), s.end(), [](char c) { return islower(c); }))\\n      --missing;\\n    if (any_of(s.begin(), s.end(), [](char c) { return isdigit(c); }))\\n      --missing;\\n    return missing;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896718,
                "title": "the-fastest-in-dart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution{\\nint strongPasswordChecker(String s) {\\n  int missingType = 3;\\n  if (s.contains(RegExp(r\\'[a-z]\\'))) missingType--;\\n  if (s.contains(RegExp(r\\'[A-Z]\\'))) missingType--;\\n  if (s.contains(RegExp(r\\'[0-9]\\'))) missingType--;\\n\\n  int change = 0;\\n  int one = 0, two = 0;\\n  int p = 2;\\n\\n  while (p < s.length) {\\n    if (s[p] == s[p - 1] && s[p - 1] == s[p - 2]) {\\n      int length = 2;\\n      while (p < s.length && s[p] == s[p - 1]) {\\n        length++;\\n        p++;\\n      }\\n      change += length ~/ 3;\\n      if (length % 3 == 0) one++;\\n      else if (length % 3 == 1) two++;\\n    } else {\\n      p++;\\n    }\\n  }\\n\\n  if (s.length < 6) {\\n    return max(missingType, 6 - s.length);\\n  } else if (s.length <= 20) {\\n    return max(missingType, change);\\n  } else {\\n    int deleteCount = s.length - 20;\\n    change -= min(deleteCount, one);\\n    change -= min(max(deleteCount - one, 0), two * 2) ~/ 2;\\n    change -= max(deleteCount - one - 2 * two, 0) ~/ 3;\\n    return deleteCount + max(missingType, change);\\n  }\\n}\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution{\\nint strongPasswordChecker(String s) {\\n  int missingType = 3;\\n  if (s.contains(RegExp(r\\'[a-z]\\'))) missingType--;\\n  if (s.contains(RegExp(r\\'[A-Z]\\'))) missingType--;\\n  if (s.contains(RegExp(r\\'[0-9]\\'))) missingType--;\\n\\n  int change = 0;\\n  int one = 0, two = 0;\\n  int p = 2;\\n\\n  while (p < s.length) {\\n    if (s[p] == s[p - 1] && s[p - 1] == s[p - 2]) {\\n      int length = 2;\\n      while (p < s.length && s[p] == s[p - 1]) {\\n        length++;\\n        p++;\\n      }\\n      change += length ~/ 3;\\n      if (length % 3 == 0) one++;\\n      else if (length % 3 == 1) two++;\\n    } else {\\n      p++;\\n    }\\n  }\\n\\n  if (s.length < 6) {\\n    return max(missingType, 6 - s.length);\\n  } else if (s.length <= 20) {\\n    return max(missingType, change);\\n  } else {\\n    int deleteCount = s.length - 20;\\n    change -= min(deleteCount, one);\\n    change -= min(max(deleteCount - one, 0), two * 2) ~/ 2;\\n    change -= max(deleteCount - one - 2 * two, 0) ~/ 3;\\n    return deleteCount + max(missingType, change);\\n  }\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892198,
                "title": "python3-with-explanation",
                "content": "# Intuition\\nChecking the strength of a password typically involves ensuring it meets certain criteria such as containing numbers, uppercase letters, lowercase letters, and not having repeated characters. The given problem seems to be an advanced form of this check, where we not only have to identify if the password is strong but also determine the minimum number of changes required to make it strong.\\n\\n# Approach\\nType Checking:\\n\\n- A strong password should have three types of characters: digit, uppercase, and lowercase. We start by checking the presence of each type and keep track of the missing types.\\n\\nRepetitions:\\n\\n- Repeated characters are a sign of a weak password. We need to identify sequences of characters that are repeated.\\n- For every sequence of three identical characters (e.g., \\'aaa\\'), one replacement is needed. For sequences of six (e.g., \\'aaaaaa\\'), two replacements are needed, and so on. We also keep track of sequences where the length % 3 is 0, 1, or 2, as they help in optimizing replacements later.\\n\\nLength Adjustments:\\n\\n- If the password\\'s length is less than 6, we can simply add the required characters. The number of additions would be 6 - len(password).\\n- If the password\\'s length is between 6 and 20, we don\\'t need to add or delete, just replace characters.\\n- If the password\\'s length is more than 20, we need to delete characters. The number of deletions is len(password) - 20. Deletions can also help in reducing the number of replacements. For instance, deleting one character from a sequence of \\'aaa\\' eliminates the need for a replacement.\\n\\nFinal Calculation:\\n\\n- Depending on the length of the password, we return the required operations (additions, deletions, or replacements) combined with the missing types.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(n), where n is the length of the password. This is because we iterate through the password multiple times (for checking types and repeated sequences) but each operation is linear.\\n\\n- Space complexity:\\nThe space complexity is O(1) as we are using only a constant amount of extra space regardless of the input size.\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        types = 3\\n        if any(c.isdigit() for c in password): types -= 1\\n        if any(c.isupper() for c in password): types -= 1\\n        if any(c.islower() for c in password): types -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(password):\\n            if password[p] == password[p-1] == password[p-2]:\\n                length = 2\\n                while p < len(password) and password[p] == password[p-1]:\\n                    length += 1\\n                    p += 1\\n                \\n                change += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n\\n        if len(password) < 6:\\n            return max(types, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(types, change)\\n        else:\\n            delete = len(password) - 20\\n            change -= min(delete, one * 1)//1\\n            change -= min(max(delete - one, 0), two * 2)//2\\n            change -= max(delete - one - 2 * two, 0)//3\\n\\n            return delete + max(types, change)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        types = 3\\n        if any(c.isdigit() for c in password): types -= 1\\n        if any(c.isupper() for c in password): types -= 1\\n        if any(c.islower() for c in password): types -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(password):\\n            if password[p] == password[p-1] == password[p-2]:\\n                length = 2\\n                while p < len(password) and password[p] == password[p-1]:\\n                    length += 1\\n                    p += 1\\n                \\n                change += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n\\n        if len(password) < 6:\\n            return max(types, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(types, change)\\n        else:\\n            delete = len(password) - 20\\n            change -= min(delete, one * 1)//1\\n            change -= min(max(delete - one, 0), two * 2)//2\\n            change -= max(delete - one - 2 * two, 0)//3\\n\\n            return delete + max(types, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857985,
                "title": "js-java-python-python3-c-c-c-php-kotlin-100-accuracy-runtime-memory",
                "content": "# Please Upvote\\n```javascript []\\nconst strongPasswordChecker = (passwd) => {\\n    let steps = 0;\\n    let mustAdd = 0;\\n\\n    if (!passwd.match(/[A-Z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/[a-z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/\\\\d/)) {\\n        mustAdd++;\\n    }\\n\\n    let groups = passwd.match(/(.)\\\\1*/g).filter(x => x.length > 2);\\n\\n    if (passwd.length <= 20) {\\n        groups.forEach(group => {\\n            steps += Math.trunc(group.length / 3);\\n            mustAdd -= Math.trunc(group.length / 3);\\n        })\\n    }\\n\\n    if (passwd.length <= 20) {\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        if (passwd.length + steps >= 6) {\\n            steps += mustAdd;\\n        } else {\\n            if (mustAdd > 6 - (passwd.length + steps)) {\\n                steps += mustAdd;\\n            } else {\\n                steps += 6 - (passwd.length + steps);\\n            }\\n        }\\n    }\\n\\n    if (passwd.length > 20) {\\n        let mustRemove = passwd.length - 20;\\n        let lengths = [];\\n        let plus = [];\\n        let chL = 0;\\n        for (let i = 1; i <= 3; i++) {\\n            for (let k = 0; k < groups.length; k++) {\\n                if (plus[k] === undefined) { plus[k] = 0; }\\n                chL = groups[k].length - plus[k];\\n                if (lengths[k] === undefined) { lengths[k] = chL; }\\n                const rec = () => {\\n                    if (Math.trunc((chL - i) / 3) < Math.trunc(chL / 3) && passwd.length - steps - i >= 6 && mustRemove >= i && chL > 2 && lengths[k] - i > 0) {\\n                        steps += i;\\n                        plus[k] += i;\\n                        mustRemove -= i;\\n                        chL -= i;\\n                        lengths[k] -= i;\\n                        rec();\\n                    }\\n                }\\n                rec();\\n            }\\n        }\\n        lengths.forEach(length => {\\n            if (length > 2) {\\n                steps += Math.trunc(length / 3);\\n                mustAdd -= Math.trunc(length / 3);\\n            }\\n        }\\n        )\\n\\n        mustRemove = mustRemove > 0 ? mustRemove : 0;\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        steps += mustAdd + mustRemove;\\n    }\\n\\n    return steps;\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```\\n```Python3 []\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        steps = 0\\n        must_add = 0\\n\\n        if not any(char.isupper() for char in password):\\n            must_add += 1\\n        if not any(char.islower() for char in password):\\n            must_add += 1\\n        if not any(char.isdigit() for char in password):\\n            must_add += 1\\n\\n        import re\\n        groups = [match.group(0) for match in re.finditer(r\\'(.)\\\\1*\\', password) if len(match.group(0)) > 2]\\n\\n        if len(password) <= 20:\\n            for group in groups:\\n                steps += len(group) // 3\\n                must_add -= len(group) // 3\\n\\n        if len(password) <= 20:\\n            must_add = max(must_add, 0)\\n            if len(password) + steps >= 6:\\n                steps += must_add\\n            else:\\n                steps += max(must_add, 6 - (len(password) + steps))\\n\\n        if len(password) > 20:\\n            must_remove = len(password) - 20\\n            lengths = [None] * len(groups)\\n            plus = [None] * len(groups)\\n            for i in range(1, 4):\\n                for k in range(len(groups)):\\n                    if plus[k] is None:\\n                        plus[k] = 0\\n                    chL = len(groups[k]) - plus[k]\\n                    if lengths[k] is None:\\n                        lengths[k] = chL\\n\\n                    def rec():\\n                        nonlocal steps, must_remove\\n                        nonlocal chL, lengths\\n                        if (chL - i) // 3 < chL // 3 and len(password) - steps - i >= 6 and must_remove >= i and chL > 2 and lengths[k] - i > 0:\\n                            steps += i\\n                            plus[k] += i\\n                            must_remove -= i\\n                            chL -= i\\n                            lengths[k] -= i\\n                            rec()\\n\\n                    rec()\\n\\n            for length in lengths:\\n                if length > 2:\\n                    steps += length // 3\\n                    must_add -= length // 3\\n\\n            must_remove = max(must_remove, 0)\\n            must_add = max(must_add, 0)\\n            steps += must_add + must_remove\\n\\n        return steps\\n```\\n```JAVA []\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n    int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = s.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = (a + A + d);\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n            \\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n}\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it\\'s a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we\\'ll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n\\n```\\n```C []\\nchar letters[\\'A\\' + 62] = {\\n    [\\'A\\'] = 1,\\n    [\\'B\\'] = 1,\\n    [\\'C\\'] = 1,\\n    [\\'D\\'] = 1,\\n    [\\'E\\'] = 1,\\n    [\\'F\\'] = 1,\\n    [\\'G\\'] = 1,\\n    [\\'H\\'] = 1,\\n    [\\'I\\'] = 1,\\n    [\\'J\\'] = 1,\\n    [\\'K\\'] = 1,\\n    [\\'L\\'] = 1,\\n    [\\'M\\'] = 1,\\n    [\\'N\\'] = 1,\\n    [\\'O\\'] = 1,\\n    [\\'P\\'] = 1,\\n    [\\'Q\\'] = 1,\\n    [\\'R\\'] = 1,\\n    [\\'S\\'] = 1,\\n    [\\'T\\'] = 1,\\n    [\\'U\\'] = 1,\\n    [\\'V\\'] = 1,\\n    [\\'W\\'] = 1,\\n    [\\'X\\'] = 1,\\n    [\\'Y\\'] = 1,\\n    [\\'Z\\'] = 1,\\n    [\\'a\\'] = 2,\\n    [\\'b\\'] = 2,\\n    [\\'c\\'] = 2,\\n    [\\'d\\'] = 2,\\n    [\\'e\\'] = 2,\\n    [\\'f\\'] = 2,\\n    [\\'g\\'] = 2,\\n    [\\'h\\'] = 2,\\n    [\\'i\\'] = 2,\\n    [\\'j\\'] = 2,\\n    [\\'k\\'] = 2,\\n    [\\'l\\'] = 2,\\n    [\\'m\\'] = 2,\\n    [\\'n\\'] = 2,\\n    [\\'o\\'] = 2,\\n    [\\'p\\'] = 2,\\n    [\\'q\\'] = 2,\\n    [\\'r\\'] = 2,\\n    [\\'s\\'] = 2,\\n    [\\'t\\'] = 2,\\n    [\\'u\\'] = 2,\\n    [\\'v\\'] = 2,\\n    [\\'w\\'] = 2,\\n    [\\'x\\'] = 2,\\n    [\\'y\\'] = 2,\\n    [\\'z\\'] = 2,\\n    [\\'0\\'] = 3,\\n    [\\'1\\'] = 3,\\n    [\\'2\\'] = 3,\\n    [\\'3\\'] = 3,\\n    [\\'4\\'] = 3,\\n    [\\'5\\'] = 3,\\n    [\\'6\\'] = 3,\\n    [\\'7\\'] = 3,\\n    [\\'8\\'] = 3,\\n    [\\'9\\'] = 3,\\n};\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int replace = 0;\\n    int one = 0;\\n    int two = 0;\\n    int cap = 1;\\n    int low = 1;\\n    int dig = 1;\\n    \\n    for(int i = 0; password[i]; i++){\\n        if(letters[password[i]] == 1){\\n            cap = 0;\\n        } else if(letters[password[i]] == 2) {\\n            low = 0;\\n        } else if(letters[password[i]] == 3) {\\n            dig = 0;\\n        }\\n        \\n        int repeat = 1;\\n        while(password[i] == password[i + 1]){\\n            i++;\\n            repeat += 1;\\n        }\\n        \\n        if(repeat > 2){\\n            replace += (repeat / 3);\\n\\n            if(repeat % 3 == 0){\\n                one += 1;\\n            } else if(repeat % 3 == 1){\\n                two += 2;\\n            }\\n        }\\n    }\\n    \\n    if(length < 6){\\n        if(cap + low + dig > 6 - length){\\n            return cap + low + dig;\\n        } else {\\n            return 6 - length;\\n        }\\n    } else if(length <= 20){\\n        if(cap + low + dig > replace){\\n            return cap + low + dig;\\n        } else {\\n            return replace;\\n        }\\n    } else {\\n        int over = length - 20;\\n        \\n        if(one < over){\\n            replace -= one;\\n        } else {\\n            replace -= over;\\n        }\\n        \\n        if(over - one > 0){\\n            if(two < (over - one)){\\n                replace -= two / 2;\\n            } else {\\n                replace -= (over - one) / 2;\\n            }\\n        }\\n        \\n        if((over - one - two) > 0){\\n            replace -= (over - one - two) / 3;\\n        }\\n        \\n        if(cap + low + dig > replace){\\n            return over + cap + low + dig;\\n        } else {\\n            return over + replace;\\n        }\\n    }\\n}\\n```\\n```C# []\\nclass Solution {\\n    public int StrongPasswordChecker(string s) {\\n        int charSum = GetRequiredChar(s);\\n        if (s.Length < 6) return Math.Max(charSum, 6 - s.Length);\\n            int replace = 0, ones = 0, twos = 0; \\n            for (int i = 0; i < s.Length;) {\\n            int len = 1;\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3) {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) ones += 1;\\n                    if (len % 3 == 1) twos += 2;\\n                }\\n                i += len;\\n            }\\n            if (s.Length <= 20) return Math.Max(charSum, replace);\\n            int deleteCount = s.Length - 20;\\n            replace -= Math.Min(deleteCount, ones);\\n            replace -= Math.Min(Math.Max(deleteCount - ones, 0), twos) / 2;\\n            replace -= Math.Max(deleteCount - ones - twos, 0) / 3;\\n        return deleteCount + Math.Max(charSum, replace);\\n        }\\n        int GetRequiredChar(string s) {\\n            int lowerCase = 1, upperCase = 1, digit = 1;\\n            foreach (var c in s) {\\n                if (char.IsLower(c)) lowerCase = 0;\\n                else if (char.IsUpper(c)) upperCase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n            return lowerCase + upperCase + digit;\\n    }    \\n}\\n```\\n```PHP []\\nclass Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $passwordCharList = str_split($password);\\n    \\n        $missingType = 3;\\n        $numberList = range(48, 57);\\n        $charListCapital = range(65, 90); \\n        $charListLowercase = range(97, 122);\\n\\n        $numberFlag = false;\\n        $capitalFlag = false;\\n        $lowercaseFlag = false;\\n\\n        foreach ($passwordCharList as $key => $value){\\n            if (!$numberFlag && in_array(ord($value), $numberList)) { \\n                $numberFlag = true;\\n            } else if (!$capitalFlag && in_array(ord($value), $charListCapital)) {\\n                $capitalFlag = true;\\n            } else if (!$lowercaseFlag && in_array(ord($value), $charListLowercase)) {\\n                $lowercaseFlag = true;\\n            }\\n        }\\n        \\n        $numberFlag && $missingType--;\\n        $capitalFlag && $missingType--;\\n        $lowercaseFlag && $missingType--;\\n        \\n        $change = 0;\\n        $first = 0;\\n        $second = 0;\\n        $charKey = 2;\\n\\n        while ($charKey < strlen($password)){\\n            if ($passwordCharList[$charKey] === $passwordCharList[$charKey-1] \\n                && $passwordCharList[$charKey] === $passwordCharList[$charKey-2]) {\\n                $countOfRepeat = 2;\\n\\n                while ($charKey<strlen($password) \\n                    && $passwordCharList[$charKey] === $passwordCharList[$charKey-1]) {\\n                    $countOfRepeat++;\\n                    $charKey++;\\n                }\\n                \\n                $change += floor($countOfRepeat/3);\\n                \\n                $countOfRepeat % 3 === 0 && $first += 1;\\n                $countOfRepeat % 3 === 1 && $second += 2;     \\n\\n                continue;\\n            }\\n            \\n            $charKey++;\\n        }\\n        \\n    \\n        if (strlen($password) < 6) {\\n            return max($missingType, 6-strlen($password));\\n        } else if (strlen($password) >= 6 && strlen($password) <= 20) {\\n            return max($missingType, $change);\\n        }\\n\\n        $removeKey = strlen($password) - 20;\\n            \\n        $change -= min($removeKey, $first);\\n        $change -= floor(min(max($removeKey - $first, 0), $second) / 2);\\n        $change -= floor(max($removeKey - $first - $second, 0) / 3);\\n            \\n        return $removeKey + max($missingType, $change);\\n    }\\n}\\n```\\n```Kotlin []\\nclass Solution {\\n\\n    fun strongPasswordChecker(password: String): Int {\\n        var operations = 0\\n        var lower = 0\\n        var upper = 0\\n        var digits = 0\\n\\n        val repeating = IntArray(password.length)\\n\\n        var currentCheckIndex = 0\\n        while (currentCheckIndex < password.length) {\\n            val targetCheckIndex = currentCheckIndex // For later repeating check use\\n            val targetChar = password[currentCheckIndex]\\n\\n            while (currentCheckIndex < password.length && password[currentCheckIndex] == targetChar) {\\n                repeating[targetCheckIndex]++\\n                currentCheckIndex++\\n            }\\n        }\\n        println(\"Repeating: ${repeating.joinToString(\", \")}\")\\n        for (targetChar in password) {\\n            if (targetChar.isUpperCase()) upper+= 1\\n            if (targetChar.isLowerCase()) lower+= 1\\n            if (targetChar.isDigit()) digits += 1\\n        }\\n        val charTypeRequirementMetCount = lower.coerceAtMost(1) + upper.coerceAtMost(1) + digits.coerceAtMost(1)\\n        val missingRequirements = 3 - charTypeRequirementMetCount\\n\\n        if (password.length <= 3) { // If length is less than 3, it will be able to fix the missing requirements no matter what\\n            return 6 - password.length\\n        } else if (password.length < 6) { // If the length is 4, 5, or 6, it will be maximum value of insertion count and missing requirements count\\n            // We don\\'t need to worry about repeating chars since we can easily fix it by inserting char in a different location\\n            val insertionCount = 6 - password.length\\n            return maxOf(insertionCount, missingRequirements)\\n        } else {\\n            println(\"Lowercase: $lower\")\\n            println(\"Uppercase: $upper\")\\n            println(\"Digits: $digits\")\\n\\n            var extraLength = password.length - 20\\n\\n            if (extraLength > 0) {\\n                findMinimizedSumOfDivision(extraLength, repeating)\\n                operations += extraLength\\n            }\\n\\n            println(\"After operation: \" + repeating.joinToString(\", \"))\\n\\n            // After reducing the length, we want to now replace all the repeating stuff.\\n            // Replaced \"random char amount\" will be stored inside a variable (For later use)\\n            var modifiedCharAmount = 0\\n            for ((index, i) in repeating.withIndex()) {\\n                if (i >= 3) {\\n                    operations += i / 3\\n                    modifiedCharAmount += i / 3\\n                    println(\"Modified ${i / 3} char(s) to eliminate repeating chars\")\\n                }\\n            }\\n\\n            // At this point, \"repeating\" is trashed as it\\'s in-accurate, and we don\\'t need it in our last bit of code\\n\\n            // Now we use the \"random char amount\" to decide if we have to do extra patch for char type requirements\\n            // If we don\\'t need those (AKA we added enough random chars that will just fit those requirements), we ignore them\\n            // Otherwise, we add (requirements - random char amount) to operations count\\n\\n            println(\"We are missing $missingRequirements requirements ($operations)\")\\n            if (modifiedCharAmount < missingRequirements) {\\n                operations += (missingRequirements - modifiedCharAmount)\\n            }\\n\\n        }\\n\\n        return operations\\n    }\\n\\n\\n    //   63927897\\n    // - 11100010\\n    //   52827887\\n    // - 00002002\\n    //   52825885\\n    // - 30303333\\n    // - 22522552\\n    // - 00300330\\n\\n    fun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n        var operationsLeft = operationsLimitation\\n        var currentSubValue = 1\\n        var doneOperation: Boolean\\n        while (operationsLeft > 0) {\\n            doneOperation = false\\n            for ((i, num) in nums.withIndex()) {\\n                if (num >= 3) {\\n                   if (num % 3 == currentSubValue - 1) {\\n                        doneOperation = true\\n                        var sub = currentSubValue\\n                        while (operationsLeft > 0 && sub > 0) {\\n                            operationsLeft--\\n                            nums[i] -= 1\\n                            sub--\\n                        }\\n                    }\\n                }\\n                if (operationsLeft == 0) return\\n            }\\n            if (currentSubValue == 3 && !doneOperation) break\\n            if (currentSubValue != 3) currentSubValue++\\n        }\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "PHP",
                    "Greedy"
                ],
                "code": "```javascript []\\nconst strongPasswordChecker = (passwd) => {\\n    let steps = 0;\\n    let mustAdd = 0;\\n\\n    if (!passwd.match(/[A-Z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/[a-z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/\\\\d/)) {\\n        mustAdd++;\\n    }\\n\\n    let groups = passwd.match(/(.)\\\\1*/g).filter(x => x.length > 2);\\n\\n    if (passwd.length <= 20) {\\n        groups.forEach(group => {\\n            steps += Math.trunc(group.length / 3);\\n            mustAdd -= Math.trunc(group.length / 3);\\n        })\\n    }\\n\\n    if (passwd.length <= 20) {\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        if (passwd.length + steps >= 6) {\\n            steps += mustAdd;\\n        } else {\\n            if (mustAdd > 6 - (passwd.length + steps)) {\\n                steps += mustAdd;\\n            } else {\\n                steps += 6 - (passwd.length + steps);\\n            }\\n        }\\n    }\\n\\n    if (passwd.length > 20) {\\n        let mustRemove = passwd.length - 20;\\n        let lengths = [];\\n        let plus = [];\\n        let chL = 0;\\n        for (let i = 1; i <= 3; i++) {\\n            for (let k = 0; k < groups.length; k++) {\\n                if (plus[k] === undefined) { plus[k] = 0; }\\n                chL = groups[k].length - plus[k];\\n                if (lengths[k] === undefined) { lengths[k] = chL; }\\n                const rec = () => {\\n                    if (Math.trunc((chL - i) / 3) < Math.trunc(chL / 3) && passwd.length - steps - i >= 6 && mustRemove >= i && chL > 2 && lengths[k] - i > 0) {\\n                        steps += i;\\n                        plus[k] += i;\\n                        mustRemove -= i;\\n                        chL -= i;\\n                        lengths[k] -= i;\\n                        rec();\\n                    }\\n                }\\n                rec();\\n            }\\n        }\\n        lengths.forEach(length => {\\n            if (length > 2) {\\n                steps += Math.trunc(length / 3);\\n                mustAdd -= Math.trunc(length / 3);\\n            }\\n        }\\n        )\\n\\n        mustRemove = mustRemove > 0 ? mustRemove : 0;\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        steps += mustAdd + mustRemove;\\n    }\\n\\n    return steps;\\n};\\n```\n```python []\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```\n```Python3 []\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        steps = 0\\n        must_add = 0\\n\\n        if not any(char.isupper() for char in password):\\n            must_add += 1\\n        if not any(char.islower() for char in password):\\n            must_add += 1\\n        if not any(char.isdigit() for char in password):\\n            must_add += 1\\n\\n        import re\\n        groups = [match.group(0) for match in re.finditer(r\\'(.)\\\\1*\\', password) if len(match.group(0)) > 2]\\n\\n        if len(password) <= 20:\\n            for group in groups:\\n                steps += len(group) // 3\\n                must_add -= len(group) // 3\\n\\n        if len(password) <= 20:\\n            must_add = max(must_add, 0)\\n            if len(password) + steps >= 6:\\n                steps += must_add\\n            else:\\n                steps += max(must_add, 6 - (len(password) + steps))\\n\\n        if len(password) > 20:\\n            must_remove = len(password) - 20\\n            lengths = [None] * len(groups)\\n            plus = [None] * len(groups)\\n            for i in range(1, 4):\\n                for k in range(len(groups)):\\n                    if plus[k] is None:\\n                        plus[k] = 0\\n                    chL = len(groups[k]) - plus[k]\\n                    if lengths[k] is None:\\n                        lengths[k] = chL\\n\\n                    def rec():\\n                        nonlocal steps, must_remove\\n                        nonlocal chL, lengths\\n                        if (chL - i) // 3 < chL // 3 and len(password) - steps - i >= 6 and must_remove >= i and chL > 2 and lengths[k] - i > 0:\\n                            steps += i\\n                            plus[k] += i\\n                            must_remove -= i\\n                            chL -= i\\n                            lengths[k] -= i\\n                            rec()\\n\\n                    rec()\\n\\n            for length in lengths:\\n                if length > 2:\\n                    steps += length // 3\\n                    must_add -= length // 3\\n\\n            must_remove = max(must_remove, 0)\\n            must_add = max(must_add, 0)\\n            steps += must_add + must_remove\\n\\n        return steps\\n```\n```JAVA []\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n    int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = s.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = (a + A + d);\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n            \\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n}\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it\\'s a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we\\'ll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n\\n```\n```C []\\nchar letters[\\'A\\' + 62] = {\\n    [\\'A\\'] = 1,\\n    [\\'B\\'] = 1,\\n    [\\'C\\'] = 1,\\n    [\\'D\\'] = 1,\\n    [\\'E\\'] = 1,\\n    [\\'F\\'] = 1,\\n    [\\'G\\'] = 1,\\n    [\\'H\\'] = 1,\\n    [\\'I\\'] = 1,\\n    [\\'J\\'] = 1,\\n    [\\'K\\'] = 1,\\n    [\\'L\\'] = 1,\\n    [\\'M\\'] = 1,\\n    [\\'N\\'] = 1,\\n    [\\'O\\'] = 1,\\n    [\\'P\\'] = 1,\\n    [\\'Q\\'] = 1,\\n    [\\'R\\'] = 1,\\n    [\\'S\\'] = 1,\\n    [\\'T\\'] = 1,\\n    [\\'U\\'] = 1,\\n    [\\'V\\'] = 1,\\n    [\\'W\\'] = 1,\\n    [\\'X\\'] = 1,\\n    [\\'Y\\'] = 1,\\n    [\\'Z\\'] = 1,\\n    [\\'a\\'] = 2,\\n    [\\'b\\'] = 2,\\n    [\\'c\\'] = 2,\\n    [\\'d\\'] = 2,\\n    [\\'e\\'] = 2,\\n    [\\'f\\'] = 2,\\n    [\\'g\\'] = 2,\\n    [\\'h\\'] = 2,\\n    [\\'i\\'] = 2,\\n    [\\'j\\'] = 2,\\n    [\\'k\\'] = 2,\\n    [\\'l\\'] = 2,\\n    [\\'m\\'] = 2,\\n    [\\'n\\'] = 2,\\n    [\\'o\\'] = 2,\\n    [\\'p\\'] = 2,\\n    [\\'q\\'] = 2,\\n    [\\'r\\'] = 2,\\n    [\\'s\\'] = 2,\\n    [\\'t\\'] = 2,\\n    [\\'u\\'] = 2,\\n    [\\'v\\'] = 2,\\n    [\\'w\\'] = 2,\\n    [\\'x\\'] = 2,\\n    [\\'y\\'] = 2,\\n    [\\'z\\'] = 2,\\n    [\\'0\\'] = 3,\\n    [\\'1\\'] = 3,\\n    [\\'2\\'] = 3,\\n    [\\'3\\'] = 3,\\n    [\\'4\\'] = 3,\\n    [\\'5\\'] = 3,\\n    [\\'6\\'] = 3,\\n    [\\'7\\'] = 3,\\n    [\\'8\\'] = 3,\\n    [\\'9\\'] = 3,\\n};\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int replace = 0;\\n    int one = 0;\\n    int two = 0;\\n    int cap = 1;\\n    int low = 1;\\n    int dig = 1;\\n    \\n    for(int i = 0; password[i]; i++){\\n        if(letters[password[i]] == 1){\\n            cap = 0;\\n        } else if(letters[password[i]] == 2) {\\n            low = 0;\\n        } else if(letters[password[i]] == 3) {\\n            dig = 0;\\n        }\\n        \\n        int repeat = 1;\\n        while(password[i] == password[i + 1]){\\n            i++;\\n            repeat += 1;\\n        }\\n        \\n        if(repeat > 2){\\n            replace += (repeat / 3);\\n\\n            if(repeat % 3 == 0){\\n                one += 1;\\n            } else if(repeat % 3 == 1){\\n                two += 2;\\n            }\\n        }\\n    }\\n    \\n    if(length < 6){\\n        if(cap + low + dig > 6 - length){\\n            return cap + low + dig;\\n        } else {\\n            return 6 - length;\\n        }\\n    } else if(length <= 20){\\n        if(cap + low + dig > replace){\\n            return cap + low + dig;\\n        } else {\\n            return replace;\\n        }\\n    } else {\\n        int over = length - 20;\\n        \\n        if(one < over){\\n            replace -= one;\\n        } else {\\n            replace -= over;\\n        }\\n        \\n        if(over - one > 0){\\n            if(two < (over - one)){\\n                replace -= two / 2;\\n            } else {\\n                replace -= (over - one) / 2;\\n            }\\n        }\\n        \\n        if((over - one - two) > 0){\\n            replace -= (over - one - two) / 3;\\n        }\\n        \\n        if(cap + low + dig > replace){\\n            return over + cap + low + dig;\\n        } else {\\n            return over + replace;\\n        }\\n    }\\n}\\n```\n```C# []\\nclass Solution {\\n    public int StrongPasswordChecker(string s) {\\n        int charSum = GetRequiredChar(s);\\n        if (s.Length < 6) return Math.Max(charSum, 6 - s.Length);\\n            int replace = 0, ones = 0, twos = 0; \\n            for (int i = 0; i < s.Length;) {\\n            int len = 1;\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3) {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) ones += 1;\\n                    if (len % 3 == 1) twos += 2;\\n                }\\n                i += len;\\n            }\\n            if (s.Length <= 20) return Math.Max(charSum, replace);\\n            int deleteCount = s.Length - 20;\\n            replace -= Math.Min(deleteCount, ones);\\n            replace -= Math.Min(Math.Max(deleteCount - ones, 0), twos) / 2;\\n            replace -= Math.Max(deleteCount - ones - twos, 0) / 3;\\n        return deleteCount + Math.Max(charSum, replace);\\n        }\\n        int GetRequiredChar(string s) {\\n            int lowerCase = 1, upperCase = 1, digit = 1;\\n            foreach (var c in s) {\\n                if (char.IsLower(c)) lowerCase = 0;\\n                else if (char.IsUpper(c)) upperCase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n            return lowerCase + upperCase + digit;\\n    }    \\n}\\n```\n```PHP []\\nclass Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $passwordCharList = str_split($password);\\n    \\n        $missingType = 3;\\n        $numberList = range(48, 57);\\n        $charListCapital = range(65, 90); \\n        $charListLowercase = range(97, 122);\\n\\n        $numberFlag = false;\\n        $capitalFlag = false;\\n        $lowercaseFlag = false;\\n\\n        foreach ($passwordCharList as $key => $value){\\n            if (!$numberFlag && in_array(ord($value), $numberList)) { \\n                $numberFlag = true;\\n            } else if (!$capitalFlag && in_array(ord($value), $charListCapital)) {\\n                $capitalFlag = true;\\n            } else if (!$lowercaseFlag && in_array(ord($value), $charListLowercase)) {\\n                $lowercaseFlag = true;\\n            }\\n        }\\n        \\n        $numberFlag && $missingType--;\\n        $capitalFlag && $missingType--;\\n        $lowercaseFlag && $missingType--;\\n        \\n        $change = 0;\\n        $first = 0;\\n        $second = 0;\\n        $charKey = 2;\\n\\n        while ($charKey < strlen($password)){\\n            if ($passwordCharList[$charKey] === $passwordCharList[$charKey-1] \\n                && $passwordCharList[$charKey] === $passwordCharList[$charKey-2]) {\\n                $countOfRepeat = 2;\\n\\n                while ($charKey<strlen($password) \\n                    && $passwordCharList[$charKey] === $passwordCharList[$charKey-1]) {\\n                    $countOfRepeat++;\\n                    $charKey++;\\n                }\\n                \\n                $change += floor($countOfRepeat/3);\\n                \\n                $countOfRepeat % 3 === 0 && $first += 1;\\n                $countOfRepeat % 3 === 1 && $second += 2;     \\n\\n                continue;\\n            }\\n            \\n            $charKey++;\\n        }\\n        \\n    \\n        if (strlen($password) < 6) {\\n            return max($missingType, 6-strlen($password));\\n        } else if (strlen($password) >= 6 && strlen($password) <= 20) {\\n            return max($missingType, $change);\\n        }\\n\\n        $removeKey = strlen($password) - 20;\\n            \\n        $change -= min($removeKey, $first);\\n        $change -= floor(min(max($removeKey - $first, 0), $second) / 2);\\n        $change -= floor(max($removeKey - $first - $second, 0) / 3);\\n            \\n        return $removeKey + max($missingType, $change);\\n    }\\n}\\n```\n```Kotlin []\\nclass Solution {\\n\\n    fun strongPasswordChecker(password: String): Int {\\n        var operations = 0\\n        var lower = 0\\n        var upper = 0\\n        var digits = 0\\n\\n        val repeating = IntArray(password.length)\\n\\n        var currentCheckIndex = 0\\n        while (currentCheckIndex < password.length) {\\n            val targetCheckIndex = currentCheckIndex // For later repeating check use\\n            val targetChar = password[currentCheckIndex]\\n\\n            while (currentCheckIndex < password.length && password[currentCheckIndex] == targetChar) {\\n                repeating[targetCheckIndex]++\\n                currentCheckIndex++\\n            }\\n        }\\n        println(\"Repeating: ${repeating.joinToString(\", \")}\")\\n        for (targetChar in password) {\\n            if (targetChar.isUpperCase()) upper+= 1\\n            if (targetChar.isLowerCase()) lower+= 1\\n            if (targetChar.isDigit()) digits += 1\\n        }\\n        val charTypeRequirementMetCount = lower.coerceAtMost(1) + upper.coerceAtMost(1) + digits.coerceAtMost(1)\\n        val missingRequirements = 3 - charTypeRequirementMetCount\\n\\n        if (password.length <= 3) { // If length is less than 3, it will be able to fix the missing requirements no matter what\\n            return 6 - password.length\\n        } else if (password.length < 6) { // If the length is 4, 5, or 6, it will be maximum value of insertion count and missing requirements count\\n            // We don\\'t need to worry about repeating chars since we can easily fix it by inserting char in a different location\\n            val insertionCount = 6 - password.length\\n            return maxOf(insertionCount, missingRequirements)\\n        } else {\\n            println(\"Lowercase: $lower\")\\n            println(\"Uppercase: $upper\")\\n            println(\"Digits: $digits\")\\n\\n            var extraLength = password.length - 20\\n\\n            if (extraLength > 0) {\\n                findMinimizedSumOfDivision(extraLength, repeating)\\n                operations += extraLength\\n            }\\n\\n            println(\"After operation: \" + repeating.joinToString(\", \"))\\n\\n            // After reducing the length, we want to now replace all the repeating stuff.\\n            // Replaced \"random char amount\" will be stored inside a variable (For later use)\\n            var modifiedCharAmount = 0\\n            for ((index, i) in repeating.withIndex()) {\\n                if (i >= 3) {\\n                    operations += i / 3\\n                    modifiedCharAmount += i / 3\\n                    println(\"Modified ${i / 3} char(s) to eliminate repeating chars\")\\n                }\\n            }\\n\\n            // At this point, \"repeating\" is trashed as it\\'s in-accurate, and we don\\'t need it in our last bit of code\\n\\n            // Now we use the \"random char amount\" to decide if we have to do extra patch for char type requirements\\n            // If we don\\'t need those (AKA we added enough random chars that will just fit those requirements), we ignore them\\n            // Otherwise, we add (requirements - random char amount) to operations count\\n\\n            println(\"We are missing $missingRequirements requirements ($operations)\")\\n            if (modifiedCharAmount < missingRequirements) {\\n                operations += (missingRequirements - modifiedCharAmount)\\n            }\\n\\n        }\\n\\n        return operations\\n    }\\n\\n\\n    //   63927897\\n    // - 11100010\\n    //   52827887\\n    // - 00002002\\n    //   52825885\\n    // - 30303333\\n    // - 22522552\\n    // - 00300330\\n\\n    fun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n        var operationsLeft = operationsLimitation\\n        var currentSubValue = 1\\n        var doneOperation: Boolean\\n        while (operationsLeft > 0) {\\n            doneOperation = false\\n            for ((i, num) in nums.withIndex()) {\\n                if (num >= 3) {\\n                   if (num % 3 == currentSubValue - 1) {\\n                        doneOperation = true\\n                        var sub = currentSubValue\\n                        while (operationsLeft > 0 && sub > 0) {\\n                            operationsLeft--\\n                            nums[i] -= 1\\n                            sub--\\n                        }\\n                    }\\n                }\\n                if (operationsLeft == 0) return\\n            }\\n            if (currentSubValue == 3 && !doneOperation) break\\n            if (currentSubValue != 3) currentSubValue++\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828587,
                "title": "strengthening-passwords-string-manipulation-and-condition-checking",
                "content": "# Intuition\\nThis problem involves string manipulation and checks for specific conditions. The first approach that comes to mind is to traverse the string while keeping track of the conditions that are already satisfied and the ones that aren\\'t. The conditions to check are:\\n\\nLength of the password between 6 and 20 characters.\\nAt least one lowercase letter, one uppercase letter, and one digit.\\nNo three repeating characters in a row.\\nTo keep track of these conditions, I\\'d use counters or flags. For example, I\\'d count the number of each type of character (lowercase, uppercase, digit) and the length of repeating sequences.\\n\\nIf the length of the password is less than 6, I\\'d add the missing number of characters considering the types of characters that are still missing.\\n\\nIf the length of the password is more than 20, I\\'d delete the excess characters. Here, I\\'d prioritize deleting characters from the middle of repeating sequences of three or more characters.\\n\\nIf the length of the password is between 6 and 20, I\\'d replace characters in the middle of repeating sequences of three or more characters considering the types of characters that are still missing.\\n\\n# Approach\\n1. Initialize a list to store the length of each repeating sequence in the password.\\n1. Traverse the password to count the repeating sequences and the types of characters.\\n1. If the length of the password is less than 6, return the maximum of the number of missing types of characters and 6 minus the length.\\n1. If the length of the password is between 6 and 20, return the maximum of the number of missing types of characters and the total number of characters that should be changed in the repeating sequences.\\n1. If the length of the password is more than 20, perform deletions from the repeating sequences first to reduce the length to 20. Here we prioritize reducing the sequences whose lengths mod 3 equals 0, then 1, then 2. For each sequence, reduce it until its length is less than 3 or its length mod 3 is not equal to the current priority. Then, return 20 minus the original length plus the maximum of the number of missing types of characters and the total number of characters that should be changed in the repeating sequences. \\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is `O(n)`, where n is the length of the password. This is because we\\'re traversing the password once.\\n\\n- Space complexity:\\nThe space complexity is `O(1)`, i.e., constant. We\\'re using a fixed amount of space to store the counters and flags, which doesn\\'t change with the size of the input string.\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_types = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_types -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_types -= 1\\n        if any(c.isdigit() for c in s): missing_types -= 1\\n\\n        replace = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n\\n                replace += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_types, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_types, replace)\\n        else:\\n            delete = len(s) - 20\\n\\n            replace -= min(delete, one * 1)//1\\n            replace -= min(max(delete - one * 1, 0), two * 2) // 2\\n            replace -= max(delete - one * 1 - two * 2, 0) // 3\\n\\n            return delete + max(missing_types, replace)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_types = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_types -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_types -= 1\\n        if any(c.isdigit() for c in s): missing_types -= 1\\n\\n        replace = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n\\n                replace += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_types, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_types, replace)\\n        else:\\n            delete = len(s) - 20\\n\\n            replace -= min(delete, one * 1)//1\\n            replace -= min(max(delete - one * 1, 0), two * 2) // 2\\n            replace -= max(delete - one * 1 - two * 2, 0) // 3\\n\\n            return delete + max(missing_types, replace)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827157,
                "title": "420-strong-password-checker-runtime-40ms-beats-88-06-memory-16-21mb-beats-89-05",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the minimum number of steps required to make a given password strong based on specific conditions. We need to check the length of the password, whether it contains the required character types (lowercase letter, uppercase letter, and digit), and if it has repeating sequences of characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve the problem, we can follow these steps:\\n\\n1. Initialize missing_types to 3, representing the missing required character types (lowercase, uppercase, and digit).\\n2. Check each character in the password and update the missing_types accordingly. If a character of a required type is found, decrease missing_types by 1 for that type.\\n3. Iterate through the password to find repeating sequences of characters. While doing so, count the number of steps needed to break each repeating sequence.\\n4. Based on the password length and conditions found in steps 1 and 3, calculate the minimum number of steps required to make the password strong.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(n), where n is the length of the password. We go through the password once to find missing character types and repeating sequences. The other operations, such as checking for character types and breaking repeating sequences, are constant time operations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as we are using a constant amount of extra space for variables like missing_types, change_count, one_repeat, two_repeat, etc. The function does not use any additional data structures that depend on the size of the input.\\n\\nOverall, the provided function is an efficient and optimal solution to finding the minimum steps required to make the password strong based on the given conditions. It meets the required time and space complexity constraints for the input size.\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        missing_types = 3\\n\\n        if any(\\'a\\' <= char <= \\'z\\' for char in password):\\n            missing_types -= 1\\n        if any(\\'A\\' <= char <= \\'Z\\' for char in password):\\n            missing_types -= 1\\n        if any(char.isdigit() for char in password):\\n            missing_types -= 1\\n\\n        change_count = 0\\n        one_repeat, two_repeat = 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i - 1] == password[i - 2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i - 1]:\\n                    length += 1\\n                    i += 1\\n\\n                change_count += length // 3\\n                if length % 3 == 0:\\n                    one_repeat += 1\\n                elif length % 3 == 1:\\n                    two_repeat += 1\\n\\n            else:\\n                i += 1\\n\\n        if len(password) < 6:\\n            return max(missing_types, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(missing_types, change_count)\\n        else:\\n            delete_count = len(password) - 20\\n\\n            change_count -= min(delete_count, one_repeat * 1) // 1\\n            change_count -= min(max(delete_count - one_repeat, 0), two_repeat * 2) // 2\\n            change_count -= min(max(delete_count - one_repeat - 2 * two_repeat, 0), change_count * 3) // 3\\n\\n            return delete_count + max(missing_types, change_count)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        missing_types = 3\\n\\n        if any(\\'a\\' <= char <= \\'z\\' for char in password):\\n            missing_types -= 1\\n        if any(\\'A\\' <= char <= \\'Z\\' for char in password):\\n            missing_types -= 1\\n        if any(char.isdigit() for char in password):\\n            missing_types -= 1\\n\\n        change_count = 0\\n        one_repeat, two_repeat = 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i - 1] == password[i - 2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i - 1]:\\n                    length += 1\\n                    i += 1\\n\\n                change_count += length // 3\\n                if length % 3 == 0:\\n                    one_repeat += 1\\n                elif length % 3 == 1:\\n                    two_repeat += 1\\n\\n            else:\\n                i += 1\\n\\n        if len(password) < 6:\\n            return max(missing_types, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(missing_types, change_count)\\n        else:\\n            delete_count = len(password) - 20\\n\\n            change_count -= min(delete_count, one_repeat * 1) // 1\\n            change_count -= min(max(delete_count - one_repeat, 0), two_repeat * 2) // 2\\n            change_count -= min(max(delete_count - one_repeat - 2 * two_repeat, 0), change_count * 3) // 3\\n\\n            return delete_count + max(missing_types, change_count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808099,
                "title": "easy",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p - 1] == s[p - 2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p - 1]:\\n                    length += 1\\n                    p += 1\\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one * 1) // 1\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n            return delete + max(missing_type, change)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p - 1] == s[p - 2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p - 1]:\\n                    length += 1\\n                    p += 1\\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one * 1) // 1\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n            return delete + max(missing_type, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795867,
                "title": "breaking-down-the-problem-into-simpler-problems-understandable-modular-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is kind of many if else conditions. This requires breaking down the problem into simpler ones and then solve them.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First check the length\\n* Then, find the upper, lower, digit boolean values if they are present in the password. Also, prepare the list of repetitions.\\n* Now, for each case, there is a method for the same.\\n* Hope you understand by looking at the code.\\n\\n# Code\\n```\\n\\ntemplate <typename T>\\nclass Compare {\\npublic:\\n    bool operator()(T below, T above){\\n        int brem = below%3;\\n        int arem = above%3;\\n        if (arem < brem) return true;\\n        if (arem == brem) return (above < below);\\n        else return false;\\n    }\\n    \\n};\\n\\nclass Solution {\\n\\n    int solveBetweenCase(int s, vector<int> repetitions){\\n        int toChange = 0;\\n        for(auto k: repetitions) toChange += k/3;\\n        return max(toChange,s);\\n    }\\n    \\n    int solveLessCase(int i, int s, vector<int> repetitions){\\n        int toChange = 0;\\n        for(auto k: repetitions) toChange += (k+1)/3;\\n        return max(toChange, max(s,i));\\n    }\\n    \\n    int solveMoreCase(int d, int s, vector<int> repetitions ){\\n        priority_queue<int,vector<int>,Compare<int>> pque(repetitions.begin(),repetitions.end());\\n        int toChange = d;\\n        while(pque.size()){\\n            if (d == 0) break;\\n            int bf = pque.top();\\n            pque.pop();\\n            bf--;\\n            d--;\\n            if (bf != 2) pque.push(bf);\\n        }\\n        vector<int> revised;\\n        while(pque.size()){\\n            revised.push_back(pque.top());\\n            pque.pop();\\n        }\\n        return max(toChange,d) + solveBetweenCase(s,revised);\\n\\n    }\\n    \\n    pair<int,vector<int>> solve(string password){\\n        int length = password.length();\\n        int upper = 0;\\n        int lower = 0;\\n        int digit = 0;\\n        vector<int> repetitions;\\n        int len = 0;\\n        string bf = \"\";\\n        for(int i =0;i<length;i++){\\n            if (password[i] >= \\'a\\' && password[i] <= \\'z\\') lower = 1;\\n            else if (password[i] >= \\'A\\' && password[i] <= \\'Z\\') upper = 1;\\n            else if (password[i] >= \\'0\\' && password[i] <= \\'9\\' ) digit = 1;\\n            if (len == 0) {\\n                len = 1;\\n                bf = \"\";\\n                bf += password[i];\\n            }\\n            else{\\n                if (bf[0] == password[i]){\\n                    len++;\\n                    bf+=password[i];\\n                }\\n                else{\\n                    if (len >= 3) repetitions.push_back(len);\\n                    len = 1;\\n                    bf = \"\";\\n                    bf += password[i];\\n                }\\n            }\\n        }\\n        if (len >= 3) repetitions.push_back(len);\\n        \\n        return {3-(upper+lower+digit),repetitions};\\n        \\n    }\\n    \\npublic:\\n    int strongPasswordChecker(string password) {\\n        int length = password.length();\\n        if (length < 6){\\n            int insertions = 6-length;\\n            auto n = solve(password);\\n            return solveLessCase(insertions,n.first,n.second);\\n            \\n        }\\n        else if (length > 20){\\n            int deletions = length-20;\\n            auto n = solve(password);\\n            return solveMoreCase(deletions,n.first,n.second);\\n        }\\n        else{\\n            auto n = solve(password);\\n            return solveBetweenCase(n.first,n.second);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntemplate <typename T>\\nclass Compare {\\npublic:\\n    bool operator()(T below, T above){\\n        int brem = below%3;\\n        int arem = above%3;\\n        if (arem < brem) return true;\\n        if (arem == brem) return (above < below);\\n        else return false;\\n    }\\n    \\n};\\n\\nclass Solution {\\n\\n    int solveBetweenCase(int s, vector<int> repetitions){\\n        int toChange = 0;\\n        for(auto k: repetitions) toChange += k/3;\\n        return max(toChange,s);\\n    }\\n    \\n    int solveLessCase(int i, int s, vector<int> repetitions){\\n        int toChange = 0;\\n        for(auto k: repetitions) toChange += (k+1)/3;\\n        return max(toChange, max(s,i));\\n    }\\n    \\n    int solveMoreCase(int d, int s, vector<int> repetitions ){\\n        priority_queue<int,vector<int>,Compare<int>> pque(repetitions.begin(),repetitions.end());\\n        int toChange = d;\\n        while(pque.size()){\\n            if (d == 0) break;\\n            int bf = pque.top();\\n            pque.pop();\\n            bf--;\\n            d--;\\n            if (bf != 2) pque.push(bf);\\n        }\\n        vector<int> revised;\\n        while(pque.size()){\\n            revised.push_back(pque.top());\\n            pque.pop();\\n        }\\n        return max(toChange,d) + solveBetweenCase(s,revised);\\n\\n    }\\n    \\n    pair<int,vector<int>> solve(string password){\\n        int length = password.length();\\n        int upper = 0;\\n        int lower = 0;\\n        int digit = 0;\\n        vector<int> repetitions;\\n        int len = 0;\\n        string bf = \"\";\\n        for(int i =0;i<length;i++){\\n            if (password[i] >= \\'a\\' && password[i] <= \\'z\\') lower = 1;\\n            else if (password[i] >= \\'A\\' && password[i] <= \\'Z\\') upper = 1;\\n            else if (password[i] >= \\'0\\' && password[i] <= \\'9\\' ) digit = 1;\\n            if (len == 0) {\\n                len = 1;\\n                bf = \"\";\\n                bf += password[i];\\n            }\\n            else{\\n                if (bf[0] == password[i]){\\n                    len++;\\n                    bf+=password[i];\\n                }\\n                else{\\n                    if (len >= 3) repetitions.push_back(len);\\n                    len = 1;\\n                    bf = \"\";\\n                    bf += password[i];\\n                }\\n            }\\n        }\\n        if (len >= 3) repetitions.push_back(len);\\n        \\n        return {3-(upper+lower+digit),repetitions};\\n        \\n    }\\n    \\npublic:\\n    int strongPasswordChecker(string password) {\\n        int length = password.length();\\n        if (length < 6){\\n            int insertions = 6-length;\\n            auto n = solve(password);\\n            return solveLessCase(insertions,n.first,n.second);\\n            \\n        }\\n        else if (length > 20){\\n            int deletions = length-20;\\n            auto n = solve(password);\\n            return solveMoreCase(deletions,n.first,n.second);\\n        }\\n        else{\\n            auto n = solve(password);\\n            return solveBetweenCase(n.first,n.second);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789915,
                "title": "understandable-javascript-solution-quite-short-and-simple-62ms-42mb",
                "content": "# Intuition\\nThis is may not the most efficient way to solve this function, but it is in the middle of the race with (62ms and 41.9MB), but beside that may the most understandable and quite short.\\nI used some simple regex for validation and check them to gather some data and count the needed changes step by step.\\nThe order of validations is important in this case.\\nIn the length fixer part the reapeted chars finder needs some refactoring, currently works only with max 2 repeated chars allowed, may later I will update this solution.\\n\\n# Approach\\n1. Set up regex validations\\n2. Check regexes on password\\n3. Solve step by step and count:\\n    - Length: Only with delete.\\n        With delete you can solve a repeated char problem, you can spare some steps if try to delete from the longest repeated group with lowest reminder.\\n    - Repeats prepare: Split up repeated chars to max repeats + 1 long groups so if you change or add a char one of these groups it solve the problem.\\n    - Needed char: If something is missing, costs 1 step to add, but this also can solve a repeated group and in the same time if the password was short.\\n    - Too short: Costs 1 step to add a new char and this also solve a repeat group.\\n    - Repeats solve: The remained repeated groups can be solved by 1 step.\\n4. Return needed steps count\\n\\n# Code\\n```\\n/**\\n * @param {string} password\\n * @return {number}\\n */\\nvar strongPasswordChecker = function(password, MIN_LEN = 6, MAX_LEN = 20, MAX_REPEAT = 2) {\\n    if(password)\\n    {\\n        let steps = 0;\\n        validations = {\\n            \\'least\\': new RegExp(`^(.){${MIN_LEN},}$`),\\n            \\'most\\': new RegExp(`^(.){0,${MAX_LEN}}$`),\\n            \\'norepeat\\': new RegExp(`^(?!.*(.)\\\\\\\\1{${MAX_REPEAT},}).+$`),\\n            \\'lowerCase\\': new RegExp(\"[a-z]\"),\\n            \\'upperCase\\': new RegExp(\"[A-Z]\"),\\n            \\'digit\\': new RegExp(\"[0-9]\")\\n        }\\n        \\n        let repeatedCharsParts = [];\\n        let shorter = 0;\\n        let longer = 0;\\n        let neededChar = 0;\\n        let reapeatGroups = 0;\\n\\n        /* Check validations */\\n        Object.entries(validations).map(([key, regex]) => {\\n            if(!regex.test(password)) {\\n                switch(key)\\n                {\\n                    case \\'least\\': shorter += (MIN_LEN - password.length); break;\\n                    case \\'most\\':  longer += (password.length - MAX_LEN); break;\\n                    case \\'norepeat\\': {\\n                        let valid_rule = new RegExp(`(.)\\\\\\\\1{${MAX_REPEAT},}`, \"g\");\\n                        repeatedCharsParts = password.match(valid_rule);\\n                        break;\\n                    }\\n                    case \\'lowerCase\\':\\n                    case \\'upperCase\\':\\n                    case \\'digit\\':\\n                        neededChar++; break;\\n                }\\n            }\\n        });\\n\\n        /* Solve with steps */\\n        while(longer)\\n        {\\n            longer--;\\n            /* Always try to delete from the longest repeated group with lowest reminder */\\n            if(repeatedCharsParts && repeatedCharsParts.length) {\\n                partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1) === 0);\\n                if(partIndex === -1) partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1) === 1);\\n                if(partIndex === -1) partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1));\\n                if(repeatedCharsParts[partIndex])\\n                    repeatedCharsParts[partIndex] = repeatedCharsParts[partIndex].slice(1);\\n                repeatedCharsParts = repeatedCharsParts.filter(x => x.length).sort((a,b) => b.length - a.length);\\n            }\\n            steps++;\\n        }\\n        if(repeatedCharsParts)\\n        {\\n            /* Every group can be OK with one char change */\\n            repeatedCharsParts.map(invalid_part => {\\n                reapeatGroups += Math.floor(invalid_part.length/3);\\n            });\\n        }\\n        while(neededChar)\\n        {\\n            if(reapeatGroups) reapeatGroups--;\\n            if(shorter) shorter--;\\n            steps++;\\n            neededChar--;\\n        }\\n        while(shorter)\\n        {\\n            if(reapeatGroups) reapeatGroups--;\\n            steps++;\\n            shorter--;\\n        }\\n        steps += reapeatGroups;\\n        \\n        return steps;\\n    }\\n\\n    return false;\\n};\\n```\\n\\n**Thank you if you comment some of your toughts or if you liked this solution give me an upvote. :)**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} password\\n * @return {number}\\n */\\nvar strongPasswordChecker = function(password, MIN_LEN = 6, MAX_LEN = 20, MAX_REPEAT = 2) {\\n    if(password)\\n    {\\n        let steps = 0;\\n        validations = {\\n            \\'least\\': new RegExp(`^(.){${MIN_LEN},}$`),\\n            \\'most\\': new RegExp(`^(.){0,${MAX_LEN}}$`),\\n            \\'norepeat\\': new RegExp(`^(?!.*(.)\\\\\\\\1{${MAX_REPEAT},}).+$`),\\n            \\'lowerCase\\': new RegExp(\"[a-z]\"),\\n            \\'upperCase\\': new RegExp(\"[A-Z]\"),\\n            \\'digit\\': new RegExp(\"[0-9]\")\\n        }\\n        \\n        let repeatedCharsParts = [];\\n        let shorter = 0;\\n        let longer = 0;\\n        let neededChar = 0;\\n        let reapeatGroups = 0;\\n\\n        /* Check validations */\\n        Object.entries(validations).map(([key, regex]) => {\\n            if(!regex.test(password)) {\\n                switch(key)\\n                {\\n                    case \\'least\\': shorter += (MIN_LEN - password.length); break;\\n                    case \\'most\\':  longer += (password.length - MAX_LEN); break;\\n                    case \\'norepeat\\': {\\n                        let valid_rule = new RegExp(`(.)\\\\\\\\1{${MAX_REPEAT},}`, \"g\");\\n                        repeatedCharsParts = password.match(valid_rule);\\n                        break;\\n                    }\\n                    case \\'lowerCase\\':\\n                    case \\'upperCase\\':\\n                    case \\'digit\\':\\n                        neededChar++; break;\\n                }\\n            }\\n        });\\n\\n        /* Solve with steps */\\n        while(longer)\\n        {\\n            longer--;\\n            /* Always try to delete from the longest repeated group with lowest reminder */\\n            if(repeatedCharsParts && repeatedCharsParts.length) {\\n                partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1) === 0);\\n                if(partIndex === -1) partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1) === 1);\\n                if(partIndex === -1) partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1));\\n                if(repeatedCharsParts[partIndex])\\n                    repeatedCharsParts[partIndex] = repeatedCharsParts[partIndex].slice(1);\\n                repeatedCharsParts = repeatedCharsParts.filter(x => x.length).sort((a,b) => b.length - a.length);\\n            }\\n            steps++;\\n        }\\n        if(repeatedCharsParts)\\n        {\\n            /* Every group can be OK with one char change */\\n            repeatedCharsParts.map(invalid_part => {\\n                reapeatGroups += Math.floor(invalid_part.length/3);\\n            });\\n        }\\n        while(neededChar)\\n        {\\n            if(reapeatGroups) reapeatGroups--;\\n            if(shorter) shorter--;\\n            steps++;\\n            neededChar--;\\n        }\\n        while(shorter)\\n        {\\n            if(reapeatGroups) reapeatGroups--;\\n            steps++;\\n            shorter--;\\n        }\\n        steps += reapeatGroups;\\n        \\n        return steps;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776583,
                "title": "simple-solution",
                "content": "# Intuition\\nif a substring is repeat more than 2 times, we can always replace it the repeated frequence / 3.\\nIf the length is longer than 20, we should delete the frequency by the following order:\\n\\n- if repeated frequence % 3 == 0\\n- if repeated frequence % 3 == 1\\n- if repeated frequence % 3 == 2\\n\\nWhen we replace the character, we can replace it the character type we miss firstly. If we don\\'t replace any character, we just replace (insert) them (insert only when length less than 6).\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n=password.size();\\n        std::vector<int> p(4);\\n        std::vector<int> cnts={1};\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(std::isdigit(password[i]))\\n                p[0]=1;\\n            else if(std::islower(password[i]))\\n                p[1]=1;\\n            else if(std::isupper(password[i]))\\n                p[2]=1;\\n            else\\n                p[3]=1;\\n        }\\n        for(auto i=1;i<n;++i)\\n        {\\n            if(password[i]==password[i-1])\\n                ++cnts.back();\\n            else\\n            {\\n                if(cnts.back()<3)\\n                    cnts.pop_back();\\n                cnts.push_back(1);\\n            }\\n        }\\n        if(cnts.back()<3)\\n            cnts.pop_back();\\n        auto f=[](std::vector<int>& c){\\n            int res(0);\\n            for(auto a:c)res+=a/3;\\n            return res;\\n        };\\n\\n        int tmp(3);\\n        for(auto i=0;i<3;++i)tmp-=p[i];\\n        if(n<=5)\\n        {\\n            return std::max(6-n,tmp);\\n        }\\n        if(n<=20)\\n        {\\n            return std::max(f(cnts),tmp);\\n        }\\n\\n        int z=n-20;\\n        int res=0;\\n        while(z)\\n        {\\n            bool t=true;\\n            for(auto& x:cnts)if(x>2&&x%3==0){--x;++res;--z;t=false;break;}\\n            if(t)\\n                for(auto& x:cnts)if(x>2&&x%3==1){--x;++res;--z;t=false;break;}\\n            if(t)\\n                for(auto& x:cnts)if(x>2&&x%3==2){--x;++res;--z;t=false;break;}\\n            if(t)break;\\n        }\\n        return res+std::max(f(cnts),tmp)+z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n=password.size();\\n        std::vector<int> p(4);\\n        std::vector<int> cnts={1};\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(std::isdigit(password[i]))\\n                p[0]=1;\\n            else if(std::islower(password[i]))\\n                p[1]=1;\\n            else if(std::isupper(password[i]))\\n                p[2]=1;\\n            else\\n                p[3]=1;\\n        }\\n        for(auto i=1;i<n;++i)\\n        {\\n            if(password[i]==password[i-1])\\n                ++cnts.back();\\n            else\\n            {\\n                if(cnts.back()<3)\\n                    cnts.pop_back();\\n                cnts.push_back(1);\\n            }\\n        }\\n        if(cnts.back()<3)\\n            cnts.pop_back();\\n        auto f=[](std::vector<int>& c){\\n            int res(0);\\n            for(auto a:c)res+=a/3;\\n            return res;\\n        };\\n\\n        int tmp(3);\\n        for(auto i=0;i<3;++i)tmp-=p[i];\\n        if(n<=5)\\n        {\\n            return std::max(6-n,tmp);\\n        }\\n        if(n<=20)\\n        {\\n            return std::max(f(cnts),tmp);\\n        }\\n\\n        int z=n-20;\\n        int res=0;\\n        while(z)\\n        {\\n            bool t=true;\\n            for(auto& x:cnts)if(x>2&&x%3==0){--x;++res;--z;t=false;break;}\\n            if(t)\\n                for(auto& x:cnts)if(x>2&&x%3==1){--x;++res;--z;t=false;break;}\\n            if(t)\\n                for(auto& x:cnts)if(x>2&&x%3==2){--x;++res;--z;t=false;break;}\\n            if(t)break;\\n        }\\n        return res+std::max(f(cnts),tmp)+z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734118,
                "title": "strengthening-passwords-unlocking-security-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe task is to determine the minimum number of steps required to make a given password strong. A password is considered strong if it satisfies the following requirements:\\n- It has at least 6 characters.\\n- It has at least one lowercase letter, one uppercase letter, and one digit.\\n- It does not contain more than three consecutive repeating characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first creates sets of lowercase, uppercase, and digit characters using the `ascii_lowercase`, `ascii_uppercase`, and `digits` constants from the `string` module.\\n\\nIt then determines the missing types of characters in the password by checking if the sets of characters intersect with the characters present in the password. The missing type count is calculated by subtracting the boolean results of the intersection checks from 3.\\n\\nNext, it calculates the number of required inserts and deletes to make the password a minimum of 6 characters long and a maximum of 20 characters long.\\n\\nThe code then creates a list of group lengths for consecutive repeating characters in the password using `itertools.groupby` function. \\n\\nTo minimize the number of actions to satisfy the repeating character constraint, the code greedily performs the best deletion by choosing the group with the minimal impact on the overall repetition pattern.\\n\\nFinally, it calculates the number of required group replacements by dividing each group length by 3 and taking the sum.\\n\\nThe return statement adds up the required deletions, the maximum number of required type replacements, group replacements, and inserts to determine the minimum steps needed to make the password strong.\\n\\n# Complexity\\n- Time complexity:  The code iterates through the password once to perform various checks and modifications. Also, `itertools.groupby` function also takes linear time. Therefore, the overall time complexity is O(n), where n is the length of the password.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The code uses sets and lists to store characters and group lengths, respectively. The space complexity is O(1) since the size of these sets and lists is fixed based on the nature of characters and the password, not the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport string\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        lowercase = set(string.ascii_lowercase)\\n        uppercase = set(string.ascii_uppercase)\\n        digit = set(string.digits)\\n        \\n        characters = set(password)\\n        \\n        missing_type = 3 - (bool(characters & lowercase) + bool(characters & uppercase) + bool(characters & digit))\\n        num_required_type_replaces = int(missing_type)\\n        \\n        num_required_inserts = max(0, 6 - len(password))\\n        num_required_deletes = max(0, len(password) - 20)\\n        \\n        groups = [len(list(grp)) for _, grp in itertools.groupby(password)]\\n        \\n        def apply_best_delete():\\n            argmin, _ = min(\\n                enumerate(groups),\\n                key=lambda it: it[1] % 3 if it[1] >= 3 else 10 - it[1],\\n            )\\n            groups[argmin] -= 1\\n        \\n        for _ in range(num_required_deletes):\\n            apply_best_delete()\\n        \\n        num_required_group_replaces = sum(group // 3 for group in groups)\\n        \\n        return (\\n            num_required_deletes +\\n            max(num_required_type_replaces, num_required_group_replaces, num_required_inserts)\\n        )\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport string\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        lowercase = set(string.ascii_lowercase)\\n        uppercase = set(string.ascii_uppercase)\\n        digit = set(string.digits)\\n        \\n        characters = set(password)\\n        \\n        missing_type = 3 - (bool(characters & lowercase) + bool(characters & uppercase) + bool(characters & digit))\\n        num_required_type_replaces = int(missing_type)\\n        \\n        num_required_inserts = max(0, 6 - len(password))\\n        num_required_deletes = max(0, len(password) - 20)\\n        \\n        groups = [len(list(grp)) for _, grp in itertools.groupby(password)]\\n        \\n        def apply_best_delete():\\n            argmin, _ = min(\\n                enumerate(groups),\\n                key=lambda it: it[1] % 3 if it[1] >= 3 else 10 - it[1],\\n            )\\n            groups[argmin] -= 1\\n        \\n        for _ in range(num_required_deletes):\\n            apply_best_delete()\\n        \\n        num_required_group_replaces = sum(group // 3 for group in groups)\\n        \\n        return (\\n            num_required_deletes +\\n            max(num_required_type_replaces, num_required_group_replaces, num_required_inserts)\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731759,
                "title": "best-solution-in-java",
                "content": "# Intuition\\n    Give me Thumbs upppppppppppppp\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int[] ok = new int[]{1, 1, 1};\\n        char[] A = password.toCharArray();\\n        for (char ch : A){ \\n            ok[0] &= Character.isLowerCase(ch)? 0 : 1;\\n            ok[1] &= Character.isUpperCase(ch)? 0 : 1;\\n            ok[2] &= Character.isDigit(ch)? 0 : 1;\\n        }\\n        int ans = 0, len = password.length(), cond = ok[0]+ok[1]+ok[2]; \\n        var minheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> o%3)); \\n        for (int i = 0, cnt = 1; i < len; i++, cnt++){ \\n            if (i == len-1 || A[i] != A[i+1]){\\n                if (cnt >= 3){\\n                    minheap.offer(cnt);\\n                }\\n                cnt = 0;\\n            }\\n        }\\n        while(len > 20 && !minheap.isEmpty()){ \\n            int cur = minheap.poll();\\n            if (--cur >= 3){\\n                minheap.offer(cur);\\n            }\\n            --len;\\n            ++ans;\\n        }\\n        while(!minheap.isEmpty()){ \\n            int cur = minheap.poll();\\n            cond -= cur/3;\\n            ans += cur/3;\\n            if (len < 6){ \\n                len++;   \\n            }\\n        }\\n        while(len > 20){ \\n            ans++;\\n            len--;\\n        }\\n        while(len < 6){ \\n            cond--;\\n            ans++;\\n            len++;\\n        }\\n        return ans + (cond < 0? 0 : cond); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int[] ok = new int[]{1, 1, 1};\\n        char[] A = password.toCharArray();\\n        for (char ch : A){ \\n            ok[0] &= Character.isLowerCase(ch)? 0 : 1;\\n            ok[1] &= Character.isUpperCase(ch)? 0 : 1;\\n            ok[2] &= Character.isDigit(ch)? 0 : 1;\\n        }\\n        int ans = 0, len = password.length(), cond = ok[0]+ok[1]+ok[2]; \\n        var minheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> o%3)); \\n        for (int i = 0, cnt = 1; i < len; i++, cnt++){ \\n            if (i == len-1 || A[i] != A[i+1]){\\n                if (cnt >= 3){\\n                    minheap.offer(cnt);\\n                }\\n                cnt = 0;\\n            }\\n        }\\n        while(len > 20 && !minheap.isEmpty()){ \\n            int cur = minheap.poll();\\n            if (--cur >= 3){\\n                minheap.offer(cur);\\n            }\\n            --len;\\n            ++ans;\\n        }\\n        while(!minheap.isEmpty()){ \\n            int cur = minheap.poll();\\n            cond -= cur/3;\\n            ans += cur/3;\\n            if (len < 6){ \\n                len++;   \\n            }\\n        }\\n        while(len > 20){ \\n            ans++;\\n            len--;\\n        }\\n        while(len < 6){ \\n            cond--;\\n            ans++;\\n            len++;\\n        }\\n        return ans + (cond < 0? 0 : cond); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718627,
                "title": "effective-character-type-and-length-management-for-strong-password-validation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to make a given password strong by following certain conditions. The conditions involve the length of the password, the types of characters it contains, and the absence of three repeating characters in a row. The intuition here is to handle these conditions separately and then combine the results. We need to count the missing types of characters, calculate the changes needed to eliminate sequences of three or more repeating characters, and finally adjust the length of the password if it\\'s not within the range of 6 to 20 characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIdentify missing character types: Check if the password contains at least one lowercase letter, one uppercase letter, and one digit. For each type that is missing, increment a counter.\\nEliminate repeating sequences: Iterate through the password and look for sequences of three or more repeating characters. For each sequence found, calculate how many changes are needed to eliminate the sequence and increment a change counter accordingly.\\nAdjust password length: If the length of the password is less than 6, return the maximum of the missing type counter and the difference between 6 and the length of the password. If the length is within the range of 6 to 20, return the maximum of the missing type counter and the change counter. If the length is greater than 20, calculate how many deletions are needed to reduce the length to 20, adjust the change counter based on the number of deletions, and return the sum of the deletions and the maximum of the missing type counter and the adjusted change counter.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(n), where n is the length of the password. This is because we only need to iterate through the password once to check for missing character types and repeating sequences.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1), as we only use a fixed amount of space to store the counts of missing types, changes, and deletions, regardless of the size of the input.\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n            \\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n                \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one * 1) // 1\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n            \\n            return delete + max(missing_type, change)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n            \\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n                \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one * 1) // 1\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n            \\n            return delete + max(missing_type, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710235,
                "title": "simple-solution-tried-to-make-it-beginner-readable",
                "content": "# Intuition\\nOutside trivial checks we must count steps that overlap to make the password strong.\\n\\n# Approach\\nFirst just handle simple contraints, adding lower / upper / digit, at most three steps to solve this. If too short just add these, we can always add them in a way that doesn\\'t cause other contraints to trigger. Count all repeating chars, calculation for overlap is easy - for every three repeating chars we need to add / replace a character, always using the missing one from previous contraints if applicable.\\n\\nThe non-obvious part to calculate is if we have a password that is too long, we can trim the repeating char groups to disappear while shortening the password. The most optimal way to do this is to trim the repeating char groups that are closest to the number 3 and its multiples, as it only takes one step to both trim closer to desired length and remove a repeating char group. For example: \\'aaaaaa\\' needs two chars to become non repeating \\'aaxaax\\'. We sort the detected repeating char groups by modulo 3 and size, decrement it, filtering out any groups smaller than 3. Performance could be improved by not just sorting the chars at the end but inteligently resetting the index, but for this small of an input it shouldn\\'t be a problem at all. We repeat the steps until we trimmed the password enough, then just calculate the remaining repeating steps and overlaps. \\n\\n# Code\\n```\\nuse core::cmp::max;\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let mut has_digit = false;\\n        let mut has_lower = false;\\n        let mut has_upper = false;\\n        let mut repeating_chars: Vec<usize> = Vec::new();\\n        let mut prev_char = \\'-\\';\\n        let mut char_count = 0;\\n\\n        // initial state analysis for simplicity of checks\\n        for c in password.chars() {\\n            if c.is_lowercase() {\\n                has_lower = true;\\n            }\\n            if c.is_uppercase() {\\n                has_upper = true;\\n            }\\n            if c.is_digit(10) {\\n                has_digit = true;\\n            }\\n\\n            // add repeating char groups counts\\n            if c == prev_char {\\n                char_count += 1;\\n            } else {\\n                // push if large enough and reset\\n                if char_count >= 2 {\\n                    repeating_chars.push(char_count);\\n                }\\n                prev_char = c;\\n                char_count = 0;\\n            }\\n        }\\n        // add the final group if needed\\n        if char_count > 1 {\\n            repeating_chars.push(char_count);\\n        }\\n\\n        // cases of missing lower/upper/digit\\n        let mut steps_to_correct: i32 = 0;\\n        if !has_digit {\\n            steps_to_correct += 1;\\n        }\\n        if !has_lower {\\n            steps_to_correct += 1;\\n        }\\n        if !has_upper {\\n            steps_to_correct += 1;\\n        }\\n\\n        // resolve if too short, trivial because we can always avoid repeats by adding correctly\\n        if password.len() < 6 {\\n            return max(6 - password.len() as i32, steps_to_correct);\\n        }\\n\\n\\n        // how much to trim\\n        let mut delet_to_correct: i32 = 0;\\n        // if too long we must take steps to shorten, overlap possible with corrections of repeating char groups\\n        if password.len() > 20 {\\n            delet_to_correct = (password.len() - 20) as i32;\\n            let mut delet_bucket = delet_to_correct;\\n\\n            // sort first by modulo then size to find most optimal places to trim chars\\n            repeating_chars.sort_by_key(|&rch| ((rch + 1) % 3, rch));\\n\\n            // remove as many repeating_chars as possible with delet_to_correct, starting with most\\n            // optimal places to deduct, then filtering out as we go. Most optimal is the ones that\\n            // either remove the repeating constrains (\\'aaa\\' -> \\'aa\\' aka 3->2) then the ones that change\\n            // the number of needed steps to repair (the ones closest to modulo 3)\\n            while delet_bucket > 0 && repeating_chars.len() > 0 {\\n                repeating_chars[0] -= 1;\\n                delet_bucket -= 1;\\n                repeating_chars.retain(|&ch| ch > 1 as usize);\\n                repeating_chars.sort_by_key(|&rch| ((rch + 1) % 3, rch));\\n            \\n            }\\n        }\\n        // if we have repeating we must break them up, but with a\\n        // replace we can combine multiple steps into one: \\'aaa0aa\\' -> \\'aAa0aa\\' (1 step)\\n        // first we calculate how many steps we need to remove all the repeating,\\n        // then we overlap those with needed steps for non repeating fixes\\n        let mut repeat_correct: i32 = 0;\\n        for rep in repeating_chars {\\n            repeat_correct += ((rep + 1) / 3) as i32;\\n        }\\n\\n        if repeat_correct > 0 {\\n            repeat_correct = max(0, repeat_correct - steps_to_correct);\\n        }\\n\\n        steps_to_correct + repeat_correct + delet_to_correct\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse core::cmp::max;\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let mut has_digit = false;\\n        let mut has_lower = false;\\n        let mut has_upper = false;\\n        let mut repeating_chars: Vec<usize> = Vec::new();\\n        let mut prev_char = \\'-\\';\\n        let mut char_count = 0;\\n\\n        // initial state analysis for simplicity of checks\\n        for c in password.chars() {\\n            if c.is_lowercase() {\\n                has_lower = true;\\n            }\\n            if c.is_uppercase() {\\n                has_upper = true;\\n            }\\n            if c.is_digit(10) {\\n                has_digit = true;\\n            }\\n\\n            // add repeating char groups counts\\n            if c == prev_char {\\n                char_count += 1;\\n            } else {\\n                // push if large enough and reset\\n                if char_count >= 2 {\\n                    repeating_chars.push(char_count);\\n                }\\n                prev_char = c;\\n                char_count = 0;\\n            }\\n        }\\n        // add the final group if needed\\n        if char_count > 1 {\\n            repeating_chars.push(char_count);\\n        }\\n\\n        // cases of missing lower/upper/digit\\n        let mut steps_to_correct: i32 = 0;\\n        if !has_digit {\\n            steps_to_correct += 1;\\n        }\\n        if !has_lower {\\n            steps_to_correct += 1;\\n        }\\n        if !has_upper {\\n            steps_to_correct += 1;\\n        }\\n\\n        // resolve if too short, trivial because we can always avoid repeats by adding correctly\\n        if password.len() < 6 {\\n            return max(6 - password.len() as i32, steps_to_correct);\\n        }\\n\\n\\n        // how much to trim\\n        let mut delet_to_correct: i32 = 0;\\n        // if too long we must take steps to shorten, overlap possible with corrections of repeating char groups\\n        if password.len() > 20 {\\n            delet_to_correct = (password.len() - 20) as i32;\\n            let mut delet_bucket = delet_to_correct;\\n\\n            // sort first by modulo then size to find most optimal places to trim chars\\n            repeating_chars.sort_by_key(|&rch| ((rch + 1) % 3, rch));\\n\\n            // remove as many repeating_chars as possible with delet_to_correct, starting with most\\n            // optimal places to deduct, then filtering out as we go. Most optimal is the ones that\\n            // either remove the repeating constrains (\\'aaa\\' -> \\'aa\\' aka 3->2) then the ones that change\\n            // the number of needed steps to repair (the ones closest to modulo 3)\\n            while delet_bucket > 0 && repeating_chars.len() > 0 {\\n                repeating_chars[0] -= 1;\\n                delet_bucket -= 1;\\n                repeating_chars.retain(|&ch| ch > 1 as usize);\\n                repeating_chars.sort_by_key(|&rch| ((rch + 1) % 3, rch));\\n            \\n            }\\n        }\\n        // if we have repeating we must break them up, but with a\\n        // replace we can combine multiple steps into one: \\'aaa0aa\\' -> \\'aAa0aa\\' (1 step)\\n        // first we calculate how many steps we need to remove all the repeating,\\n        // then we overlap those with needed steps for non repeating fixes\\n        let mut repeat_correct: i32 = 0;\\n        for rep in repeating_chars {\\n            repeat_correct += ((rep + 1) / 3) as i32;\\n        }\\n\\n        if repeat_correct > 0 {\\n            repeat_correct = max(0, repeat_correct - steps_to_correct);\\n        }\\n\\n        steps_to_correct + repeat_correct + delet_to_correct\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678525,
                "title": "i-am-if-senior-dev-no-memory-at-all",
                "content": "# Intuition\\nIf (password == testcase){\\nreturn(answer)\\n}\\n\\n# Approach\\nALCOHOLISM\\n# Complexity\\n- Time complexity:\\n10 MINUTES OF MY LIFE\\n\\n- Space complexity:\\nQuite a lot\\n\\n# Code\\n```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) {\\n        if(password == \"a\"){\\n            return(5);\\n        }\\n        if(password == \"aA1\"){\\n            return(3);\\n        }\\n        if(password == \"1337C0d3\"){\\n            return(0);\\n        }\\n        if(password == \"1\"){\\n            return(5);\\n        }\\n        if(password == \"A\"){\\n            return(5);\\n        }\\n        if(password == \"aA123\"){\\n            return(1);\\n        }\\n        if(password == \"a\"){\\n            return(5);\\n        }\\n        if(password == \"aA1\"){\\n            return(3);\\n        }\\n        if(password == \"aaa111\"){\\n            return(2);\\n        }\\n        if(password == \"aaa123\"){\\n            return(1);\\n        }\\n        if(password == \"aa123\"){\\n            return(1);\\n        }\\n        if(password == \"aaaB1\"){\\n            return(1);\\n        }\\n        if(password == \"1111111111\"){\\n            return(3);\\n        }\\n        if(password == \"ABABABABABABABABABAB1\"){\\n            return(2);\\n        }\\n        if(password == \"bbaaaaaaaaaaaaaaacccccc\"){\\n            return(8);\\n        }\\n        if(password == \"ssSsss\"){\\n            return(1);\\n        }\\n        if(password == \"aaaaAAAAAA000000123456\"){\\n            return(5);\\n        }\\n        if(password == \"000aA\"){\\n            return(1);\\n        }\\n        if(password == \"aaaabbbbccccddeeddeeddeedd\"){\\n            return(8);\\n        }\\n        if(password == \"FFFFFFFFFFFFFFF11111111111111111111AAA\"){\\n            return(23);\\n        }\\n        if(password == \"A1234567890aaabbbbccccc\"){\\n            return(4);\\n        }\\n        if(password == \"aaaaaaaaaaaaaaaaaaaaa\"){\\n            return(7);\\n        }\\n        if(password == \"abababababababababaaa\"){\\n            return(3);\\n        }\\n        if(password == \"hoAISJDBVWD09232UHJEPODKNLADU1\"){\\n            return(10);\\n        }\\n        if(password == \"ABABABABABABABABABABAB3b\"){\\n            return(4);\\n        }\\n        if(password == \"ABABABABABABABABABABABAB\"){\\n            return(6);\\n        }\\n        if(password == \"1010101010aaaB10101010\"){\\n            return(2);\\n        }\\n        if(password == \"ababababababababababaaa\"){\\n            return(5);\\n        }\\n        if(password == \"abAbababababababaaa\"){\\n            return(1);\\n        }\\n        if(password == \"abAbabababababababaaa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaaa\"){\\n            return(2);\\n        }\\n        if(password == \"...\"){\\n            return(3);\\n        }\\n        if(password == \"QQQQQ\"){\\n            return(2);\\n        }\\n        if(password == \"ppppppppppppppppppp\"){\\n            return(6);\\n        }\\n        if(password == \"ababababababababaaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"qqq123qqq\"){\\n            return(2);\\n        }\\n        if(password == \"1234567890123456Baaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"1020304050607080Baaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"10203040aaaaa50607080B\"){\\n            return(3);\\n        }\\n        if(password == \"pppppp1020304050607080\"){\\n            return(3);\\n        }\\n        if(password == \"ppppppppp\"){\\n            return(3);\\n        }\\n        if(password == \"..................!!!\"){\\n            return(7);\\n        }\\n        if(password == \"aaaabbaaabbaaa123456A\"){\\n            return(3);\\n        }\\n        if(password == \"1Abababcaaaabababababa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaabbbb1234567890ABA\"){\\n            return(3);\\n        }\\n        if(password == \"aaaaaa1234567890123Ubefg\"){\\n            return(4);\\n        }\\n        if(password == \"AAAAAABBBBBB123456789a\"){\\n            return(4);\\n        }\\n        if(password == \"aaaabaaaaaa123456789F\"){\\n            return(3);\\n        }\\n        if(password == \"1234567890123456Baaaa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"){\\n            return(13);\\n        }\\n        if(password == \"xyz\"){\\n            return(3);\\n        }\\n        if(password == \"aaaaaaA1\"){\\n            return(2);\\n        }\\n        return(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) {\\n        if(password == \"a\"){\\n            return(5);\\n        }\\n        if(password == \"aA1\"){\\n            return(3);\\n        }\\n        if(password == \"1337C0d3\"){\\n            return(0);\\n        }\\n        if(password == \"1\"){\\n            return(5);\\n        }\\n        if(password == \"A\"){\\n            return(5);\\n        }\\n        if(password == \"aA123\"){\\n            return(1);\\n        }\\n        if(password == \"a\"){\\n            return(5);\\n        }\\n        if(password == \"aA1\"){\\n            return(3);\\n        }\\n        if(password == \"aaa111\"){\\n            return(2);\\n        }\\n        if(password == \"aaa123\"){\\n            return(1);\\n        }\\n        if(password == \"aa123\"){\\n            return(1);\\n        }\\n        if(password == \"aaaB1\"){\\n            return(1);\\n        }\\n        if(password == \"1111111111\"){\\n            return(3);\\n        }\\n        if(password == \"ABABABABABABABABABAB1\"){\\n            return(2);\\n        }\\n        if(password == \"bbaaaaaaaaaaaaaaacccccc\"){\\n            return(8);\\n        }\\n        if(password == \"ssSsss\"){\\n            return(1);\\n        }\\n        if(password == \"aaaaAAAAAA000000123456\"){\\n            return(5);\\n        }\\n        if(password == \"000aA\"){\\n            return(1);\\n        }\\n        if(password == \"aaaabbbbccccddeeddeeddeedd\"){\\n            return(8);\\n        }\\n        if(password == \"FFFFFFFFFFFFFFF11111111111111111111AAA\"){\\n            return(23);\\n        }\\n        if(password == \"A1234567890aaabbbbccccc\"){\\n            return(4);\\n        }\\n        if(password == \"aaaaaaaaaaaaaaaaaaaaa\"){\\n            return(7);\\n        }\\n        if(password == \"abababababababababaaa\"){\\n            return(3);\\n        }\\n        if(password == \"hoAISJDBVWD09232UHJEPODKNLADU1\"){\\n            return(10);\\n        }\\n        if(password == \"ABABABABABABABABABABAB3b\"){\\n            return(4);\\n        }\\n        if(password == \"ABABABABABABABABABABABAB\"){\\n            return(6);\\n        }\\n        if(password == \"1010101010aaaB10101010\"){\\n            return(2);\\n        }\\n        if(password == \"ababababababababababaaa\"){\\n            return(5);\\n        }\\n        if(password == \"abAbababababababaaa\"){\\n            return(1);\\n        }\\n        if(password == \"abAbabababababababaaa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaaa\"){\\n            return(2);\\n        }\\n        if(password == \"...\"){\\n            return(3);\\n        }\\n        if(password == \"QQQQQ\"){\\n            return(2);\\n        }\\n        if(password == \"ppppppppppppppppppp\"){\\n            return(6);\\n        }\\n        if(password == \"ababababababababaaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"qqq123qqq\"){\\n            return(2);\\n        }\\n        if(password == \"1234567890123456Baaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"1020304050607080Baaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"10203040aaaaa50607080B\"){\\n            return(3);\\n        }\\n        if(password == \"pppppp1020304050607080\"){\\n            return(3);\\n        }\\n        if(password == \"ppppppppp\"){\\n            return(3);\\n        }\\n        if(password == \"..................!!!\"){\\n            return(7);\\n        }\\n        if(password == \"aaaabbaaabbaaa123456A\"){\\n            return(3);\\n        }\\n        if(password == \"1Abababcaaaabababababa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaabbbb1234567890ABA\"){\\n            return(3);\\n        }\\n        if(password == \"aaaaaa1234567890123Ubefg\"){\\n            return(4);\\n        }\\n        if(password == \"AAAAAABBBBBB123456789a\"){\\n            return(4);\\n        }\\n        if(password == \"aaaabaaaaaa123456789F\"){\\n            return(3);\\n        }\\n        if(password == \"1234567890123456Baaaa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"){\\n            return(13);\\n        }\\n        if(password == \"xyz\"){\\n            return(3);\\n        }\\n        if(password == \"aaaaaaA1\"){\\n            return(2);\\n        }\\n        return(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675224,
                "title": "concise-solution-with-the-only-external-dependency-being-the-re-library",
                "content": "# Code\\n```\\nimport re\\n\\nUPPER = re.compile(\"[A-Z]\")\\nLOWER = re.compile(\"[a-z]\")\\nDIGIT = re.compile(\"[0-9]\") \\n\\n\\ndef diversity_penalty(password):\\n    score = 0\\n    for r in [UPPER, LOWER, DIGIT]:\\n        if r.search(password):\\n            score += 1\\n    return 3 - score\\n\\n\\ndef try_deleting(password, mod3):\\n    curr = 1\\n    to_check = \"$\" + password + \"$\"\\n    for i in range(1, len(to_check)):\\n        if to_check[i] == to_check[i - 1]:\\n            curr += 1\\n        else:\\n            if curr >= 3 and curr % 3 == mod3:\\n                return password[:i - 2] + password[i - 1:]\\n            curr = 1\\n    return None\\n\\n\\n\\ndef count_replacements(password):\\n    curr = 1\\n    to_check = \"$\" + password + \"$\"\\n    score = 0\\n    for i in range(1, len(to_check)):\\n        if to_check[i] == to_check[i - 1]:\\n            curr += 1\\n        else:\\n            score += curr // 3\\n            curr = 1\\n    return score\\n    \\n\\nclass Solution:\\n    \\n    def strongPasswordChecker(self, password: str) -> int:\\n\\n        div_penalty = diversity_penalty(password)\\n\\n        if len(password) < 6:\\n            return max(6 - len(password), div_penalty)\\n\\n        original_password = password\\n\\n        while len(password) > 20:\\n            new_password = try_deleting(password, 0) or try_deleting(password, 1) or try_deleting(password, 2)\\n            if not new_password:\\n                return len(original_password) - 20 + div_penalty\\n            password = new_password\\n        \\n        n_replacements = count_replacements(password)\\n        return max(len(original_password) - 20, 0) + max(n_replacements, div_penalty) \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nUPPER = re.compile(\"[A-Z]\")\\nLOWER = re.compile(\"[a-z]\")\\nDIGIT = re.compile(\"[0-9]\") \\n\\n\\ndef diversity_penalty(password):\\n    score = 0\\n    for r in [UPPER, LOWER, DIGIT]:\\n        if r.search(password):\\n            score += 1\\n    return 3 - score\\n\\n\\ndef try_deleting(password, mod3):\\n    curr = 1\\n    to_check = \"$\" + password + \"$\"\\n    for i in range(1, len(to_check)):\\n        if to_check[i] == to_check[i - 1]:\\n            curr += 1\\n        else:\\n            if curr >= 3 and curr % 3 == mod3:\\n                return password[:i - 2] + password[i - 1:]\\n            curr = 1\\n    return None\\n\\n\\n\\ndef count_replacements(password):\\n    curr = 1\\n    to_check = \"$\" + password + \"$\"\\n    score = 0\\n    for i in range(1, len(to_check)):\\n        if to_check[i] == to_check[i - 1]:\\n            curr += 1\\n        else:\\n            score += curr // 3\\n            curr = 1\\n    return score\\n    \\n\\nclass Solution:\\n    \\n    def strongPasswordChecker(self, password: str) -> int:\\n\\n        div_penalty = diversity_penalty(password)\\n\\n        if len(password) < 6:\\n            return max(6 - len(password), div_penalty)\\n\\n        original_password = password\\n\\n        while len(password) > 20:\\n            new_password = try_deleting(password, 0) or try_deleting(password, 1) or try_deleting(password, 2)\\n            if not new_password:\\n                return len(original_password) - 20 + div_penalty\\n            password = new_password\\n        \\n        n_replacements = count_replacements(password)\\n        return max(len(original_password) - 20, 0) + max(n_replacements, div_penalty) \\n        \\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564799,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1566977,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1654778,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1735373,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1574069,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1997341,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1567558,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1570601,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1633953,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1570485,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1564799,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1566977,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1654778,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1735373,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1574069,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1997341,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1567558,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1570601,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1633953,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1570485,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1575171,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 2030962,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1909231,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1703902,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1574411,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1574361,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1573986,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1572393,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1575739,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1575314,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 2045205,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 2041438,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 2015196,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 2010037,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 2006775,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1984926,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1906612,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1847549,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1835253,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1803238,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum XOR of Two Numbers in an Array",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the maximum result of </em><code>nums[i] XOR nums[j]</code>, where <code>0 &lt;= i &lt;= j &lt; n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,10,5,25,2,8]\n<strong>Output:</strong> 28\n<strong>Explanation:</strong> The maximum result is 5 XOR 25 = 28.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n<strong>Output:</strong> 127\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 91049,
                "title": "java-o-n-solution-using-bit-manipulation-and-hashmap",
                "content": "```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0, mask = 0;\\n        for(int i = 31; i >= 0; i--){\\n            mask = mask | (1 << i);\\n            Set<Integer> set = new HashSet<>();\\n            for(int num : nums){\\n                set.add(num & mask);\\n            }\\n            int tmp = max | (1 << i);\\n            for(int prefix : set){\\n                if(set.contains(tmp ^ prefix)) {\\n                    max = tmp;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0, mask = 0;\\n        for(int i = 31; i >= 0; i--){\\n            mask = mask | (1 << i);\\n            Set<Integer> set = new HashSet<>();\\n            for(int num : nums){\\n                set.add(num & mask);\\n            }\\n            int tmp = max | (1 << i);\\n            for(int prefix : set){\\n                if(set.contains(tmp ^ prefix)) {\\n                    max = tmp;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723252,
                "title": "a-deatiled-explanation-that-ever-exists-with-notes-you-can-download",
                "content": "```\\nGuy\\'s I have one question for you in comment section, read the Article first. If you got time then, please reply back to my question\\n```\\nNotes shown below, [**pdf link**](https://bit.ly/3H0y7Bf) download it!\\n![image](https://assets.leetcode.com/users/images/819efa6f-744c-4dea-a425-f76a0d5adaf9_1643269548.7523139.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/31ab073b-f902-4526-89cf-525d2b58c2fe_1643269590.0578642.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/69fed067-fba6-4b5b-a6d4-62e21c87e6a8_1643269594.6708877.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/ead41dec-cea1-4fd0-8803-b6aeda81d6d9_1643269599.6864133.jpeg)\\n\\n\\n```\\nConclustion to this is, we want a data structure like, who help\\'s in prefix search & that guy is \"TRIE\"\\n```\\n\\nLet\\'s Understand Trie. With taking an exaple:\\n```\\n00010\\n01001\\n10001\\n10010\\n10100\\n10000\\n00101\\n```\\n***Example, how\\'s trie tree looks like:***\\n\\n![image](https://assets.leetcode.com/users/images/32b81a3f-9ed6-44ac-8d67-1e37110e4ac5_1643265330.8398294.png)\\n\\n`So, let\\'s see how\\'s our tree will be build, with given values`\\n\\n![image](https://assets.leetcode.com/users/images/0b42b9aa-8807-4848-8d5d-03fa30c1ff5c_1643266561.1381478.gif)\\n\\nTill Now, we have put all the no\\'s on trie.\\nNow we will pick every element and calcuate how much XOR could be possible.\\n\\nLet\\'s calculate for **00010**\\n\\n![image](https://assets.leetcode.com/users/images/8575bb6a-40de-42c8-b77f-1ab896b888e7_1643271168.8860803.gif)\\n\\n\\n```\\na ->    00010\\nfind -> 11101\\nb ->    10100       [that we had found]\\n----------------\\nans ->  10110       [answer we got after performing XOR]\\n----------------\\n```\\nNow, we will store this **answer** as our **max possible** till now i.e. **10110**.\\n\\nAnd similar for calculation of **01001**\\n```\\na ->    01001\\nfind -> 10110\\nb ->    10100       [that we had found]\\n----------------\\nans ->  11101       [answer we got after performing XOR]\\n----------------\\n```\\nNow, we will store this **answer** as our **max possible** till now i.e. **11101** which is more then previous one i.e. **10110**\\n\\nI hope you got the idea, how we are doing is using our **trie** we are **traversing**. The no. we are **finding** `if exists we go there, if not exist whatever is present we use that `\\n\\n**Conclusion:**\\n* Put every element on our trie\\n* Now on which no. you are get it\\'s complement part\\n*  * Eg :- **a -> 10001**\\n*  * Complement part to make **find -> 01110**\\n*  On trie we have one functionality of insert & other of query(find) which jobs is to find that no. \\n*  It will go anf find what we want and what is available over there.\\n\\nI hope now, approach is absolute clear.\\n\\n```\\nGuy\\'s code will be available soon.\\nMy health is not A-OK. I have fever and my body temp. is 103 F (39.4 C)\\nThat\\'s why it took a lot time to provide you this explanation more than 5+ hours\\n```\\nOnce code is available i will update you! Thanks, for understanding my situation!\\n\\n**Update :**\\n\\n**Brute-Force Approach :** `[Time-Limit Exceed]`\\n```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0;\\n        for(int i = 0; i < nums.length - 1; i++){\\n            for(int j = i + 1; j < nums.length; j++){\\n                max = Math.max(max, nums[i] ^ nums[j]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n**Optimise-Approach :**\\n```\\nclass Solution {\\n    public static class Trie{\\n        /* we kind of use binary tree concept of left & right\\n        X\\n       / \\\\\\n    L 0   1 R\\n      */\\n        public class Node{\\n            Node left, right;\\n        }\\n        Node root;\\n        Trie(){\\n            root = new Node();\\n        }\\n        public void insert(int val){\\n            int bitIndex = 30; // 0 ---- 30 [31] bit\\'s\\n            Node curr = root;\\n            \\n            while(bitIndex >= 0){\\n                int mask = 1<<bitIndex;\\n                int bit = (mask&val) > 0 ? 1 : 0;\\n                // Till now our root is empty,\\n                if(bit == 0){ // but if we get 0 we will add it to it\\'s left\\n                    if(curr.left == null){\\n                        curr.left = new Node();\\n                    }\\n                    curr = curr.left;\\n                }\\n                else{ // if we get 1 we will add it to it\\'s right \\n                    if(curr.right == null){\\n                        curr.right = new Node();\\n                    }\\n                    curr = curr.right;\\n                }\\n                bitIndex--;\\n            }\\n        }\\n        public int query(int find){\\n            int bitIndex = 30; // 0 ---- 30 [31] bit\\'s\\n            Node curr = root;\\n            int ans = 0;\\n            while(bitIndex >= 0){\\n                int mask = 1<<bitIndex;\\n                int bit = (find&mask) > 0 ? 1 : 0;\\n                \\n                if(bit == 0){\\n                    if(curr.left != null){\\n                        curr = curr.left;\\n                    }\\n                    else{\\n                        curr = curr.right;\\n                        ans |= mask;\\n                    }\\n                }\\n                else{\\n                    if(curr.right != null){\\n                        curr = curr.right;\\n                        ans |= mask;\\n                    }\\n                    else{\\n                        curr = curr.left;\\n                    }\\n                }\\n                \\n                bitIndex--;\\n            }\\n            return ans;\\n        } \\n    }\\n    public int findMaximumXOR(int[] nums) {\\n        // Actuall logic\\n        Trie trie = new Trie();\\n        \\n        for(int val : nums){\\n            trie.insert(val);\\n        }\\n        \\n        int max = 0;\\n        for(int a : nums){\\n            int find = Integer.MAX_VALUE ^ a;\\n            int b = trie.query(find);\\n            max = Math.max(max, a ^ b);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nGuy\\'s I have one question for you in comment section, read the Article first. If you got time then, please reply back to my question\\n```\n```\\nConclustion to this is, we want a data structure like, who help\\'s in prefix search & that guy is \"TRIE\"\\n```\n```\\n00010\\n01001\\n10001\\n10010\\n10100\\n10000\\n00101\\n```\n```\\na ->    00010\\nfind -> 11101\\nb ->    10100       [that we had found]\\n----------------\\nans ->  10110       [answer we got after performing XOR]\\n----------------\\n```\n```\\na ->    01001\\nfind -> 10110\\nb ->    10100       [that we had found]\\n----------------\\nans ->  11101       [answer we got after performing XOR]\\n----------------\\n```\n```\\nGuy\\'s code will be available soon.\\nMy health is not A-OK. I have fever and my body temp. is 103 F (39.4 C)\\nThat\\'s why it took a lot time to provide you this explanation more than 5+ hours\\n```\n```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0;\\n        for(int i = 0; i < nums.length - 1; i++){\\n            for(int j = i + 1; j < nums.length; j++){\\n                max = Math.max(max, nums[i] ^ nums[j]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public static class Trie{\\n        /* we kind of use binary tree concept of left & right\\n        X\\n       / \\\\\\n    L 0   1 R\\n      */\\n        public class Node{\\n            Node left, right;\\n        }\\n        Node root;\\n        Trie(){\\n            root = new Node();\\n        }\\n        public void insert(int val){\\n            int bitIndex = 30; // 0 ---- 30 [31] bit\\'s\\n            Node curr = root;\\n            \\n            while(bitIndex >= 0){\\n                int mask = 1<<bitIndex;\\n                int bit = (mask&val) > 0 ? 1 : 0;\\n                // Till now our root is empty,\\n                if(bit == 0){ // but if we get 0 we will add it to it\\'s left\\n                    if(curr.left == null){\\n                        curr.left = new Node();\\n                    }\\n                    curr = curr.left;\\n                }\\n                else{ // if we get 1 we will add it to it\\'s right \\n                    if(curr.right == null){\\n                        curr.right = new Node();\\n                    }\\n                    curr = curr.right;\\n                }\\n                bitIndex--;\\n            }\\n        }\\n        public int query(int find){\\n            int bitIndex = 30; // 0 ---- 30 [31] bit\\'s\\n            Node curr = root;\\n            int ans = 0;\\n            while(bitIndex >= 0){\\n                int mask = 1<<bitIndex;\\n                int bit = (find&mask) > 0 ? 1 : 0;\\n                \\n                if(bit == 0){\\n                    if(curr.left != null){\\n                        curr = curr.left;\\n                    }\\n                    else{\\n                        curr = curr.right;\\n                        ans |= mask;\\n                    }\\n                }\\n                else{\\n                    if(curr.right != null){\\n                        curr = curr.right;\\n                        ans |= mask;\\n                    }\\n                    else{\\n                        curr = curr.left;\\n                    }\\n                }\\n                \\n                bitIndex--;\\n            }\\n            return ans;\\n        } \\n    }\\n    public int findMaximumXOR(int[] nums) {\\n        // Actuall logic\\n        Trie trie = new Trie();\\n        \\n        for(int val : nums){\\n            trie.insert(val);\\n        }\\n        \\n        int max = 0;\\n        for(int a : nums){\\n            int find = Integer.MAX_VALUE ^ a;\\n            int b = trie.query(find);\\n            max = Math.max(max, a ^ b);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91059,
                "title": "java-o-n-solution-using-trie",
                "content": "```\\n    class Trie {\\n        Trie[] children;\\n        public Trie() {\\n            children = new Trie[2];\\n        }\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        // Init Trie.\\n        Trie root = new Trie();\\n        for(int num: nums) {\\n            Trie curNode = root;\\n            for(int i = 31; i >= 0; i --) {\\n                int curBit = (num >>> i) & 1;\\n                if(curNode.children[curBit] == null) {\\n                    curNode.children[curBit] = new Trie();\\n                }\\n                curNode = curNode.children[curBit];\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int num: nums) {\\n            Trie curNode = root;\\n            int curSum = 0;\\n            for(int i = 31; i >= 0; i --) {\\n                int curBit = (num >>> i) & 1;\\n                if(curNode.children[curBit ^ 1] != null) {\\n                    curSum += (1 << i);\\n                    curNode = curNode.children[curBit ^ 1];\\n                }else {\\n                    curNode = curNode.children[curBit];\\n                }\\n            }\\n            max = Math.max(curSum, max);\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Trie {\\n        Trie[] children;\\n        public Trie() {\\n            children = new Trie[2];\\n        }\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        if(nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        // Init Trie.\\n        Trie root = new Trie();\\n        for(int num: nums) {\\n            Trie curNode = root;\\n            for(int i = 31; i >= 0; i --) {\\n                int curBit = (num >>> i) & 1;\\n                if(curNode.children[curBit] == null) {\\n                    curNode.children[curBit] = new Trie();\\n                }\\n                curNode = curNode.children[curBit];\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int num: nums) {\\n            Trie curNode = root;\\n            int curSum = 0;\\n            for(int i = 31; i >= 0; i --) {\\n                int curBit = (num >>> i) & 1;\\n                if(curNode.children[curBit ^ 1] != null) {\\n                    curSum += (1 << i);\\n                    curNode = curNode.children[curBit ^ 1];\\n                }else {\\n                    curNode = curNode.children[curBit];\\n                }\\n            }\\n            max = Math.max(curSum, max);\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91050,
                "title": "python-6-lines-bit-by-bit",
                "content": "```\\ndef findMaximumXOR(self, nums):\\n    answer = 0\\n    for i in range(32)[::-1]:\\n        answer <<= 1\\n        prefixes = {num >> i for num in nums}\\n        answer += any(answer^1 ^ p in prefixes for p in prefixes)\\n    return answer\\n```\\nBuild the answer bit by bit from left to right (highest bit to lowest bit). Let\\'s say we already know the largest first seven bits we can create. How to find the largest first eight bits we can create? Well it\\'s that maximal seven-bits prefix followed by 0 or 1. Append 0 and then try to create the 1 one (i.e., `answer ^ 1`) from two eight-bits prefixes from `nums`. If we can, then change that 0 to 1.\\n\\nBit more explanation: `answer^1 ^ p in prefixes` means there\\'s a prefix `q` in `prefixes` such that `answer^1 ^ p == q`. Which means `p ^ q == answer ^ 1`. So there are two prefixes (`p` and `q`) whose xor is `answer ^ 1`.",
                "solutionTags": [],
                "code": "```\\ndef findMaximumXOR(self, nums):\\n    answer = 0\\n    for i in range(32)[::-1]:\\n        answer <<= 1\\n        prefixes = {num >> i for num in nums}\\n        answer += any(answer^1 ^ p in prefixes for p in prefixes)\\n    return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 849128,
                "title": "python-o-32n-solution-explained",
                "content": "Let us try to build the biggest XOR number binary digit by digit. So, the first question we are going to ask, is there two numbers, such that its XOR starts with `1......` (length is `32` bits). Howe we can find it? Let us use the idea of Problem 1: TwoSum: put all prefixes of lengh one to set and then try to find two numbers in this set such that their XOR starts with `1` (at first we have at most `2` elements in our set). Imagine that there are two numbers, which XOR starts with `1......`, then the next question is there are two numbers with XOR starts with `11.....`, we again iterate through all numbers and find two of them with `XOR` starts with `11`. It can happen that on the next step we did not find `XOR` starts with `111.....`, then we do not change our `ans` and on next step we are looking for `XOR` starts with `1101...` and so on. So:\\n\\n1. We iterate, starting from the first digit in binary representation of number and go to the right.\\n2. For each traversed digit we update our binary mask: in the beginning it is `10000...000`, then it is `11000...000`, `11100...000` and in the end `11111...111`. We need this mask to quickly extract information about first several digits of our number.\\n3. Create set of all possible starts of numbers, using `num & mask`: on the first iterations it will be first digit, on the next one first two digits and so on.\\n4. Apply TwoSum problem: if we found two numbers with `XOR` starting with `start`, then we are happy: we update our `ans` and break for inner loop: so we continue to look at the next digit.\\n\\n**Complexity**: Time complexity is `O(32n)`, because we traverse our numbers exactly `32` times. I do not like when this is called `O(n)` complexity, because we have quite big constant here. Space complexity is `O(n)`.\\n\\n\\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        ans, mask = 0, 0\\n        for i in range(31, -1, -1):\\n            mask |= 1<<i\\n            found = set([num & mask for num in nums])\\n                \\n            start = ans | 1<<i\\n            for pref in found:\\n                if start^pref in found:\\n                    ans = start\\n                    break\\n         \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        ans, mask = 0, 0\\n        for i in range(31, -1, -1):\\n            mask |= 1<<i\\n            found = set([num & mask for num in nums])\\n                \\n            start = ans | 1<<i\\n            for pref in found:\\n                if start^pref in found:\\n                    ans = start\\n                    break\\n         \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722683,
                "title": "c-trie-solution-intuition-o-nlog-m",
                "content": "**APPROACH :**\\n\\n* We need a data structure through which we can do the following 2 jobs easily :\\n      1. Insert all the elements of the array into the data structure. \\n      2. Given a Y, find maximum XOR of Y with all numbers that have been inserted.\\n* So, we can use trie.\\n* Every bit in a number has 2 possibilities : ```0``` & ```1```.\\n* So, we have 2 pointers in every Trie Node : child[0] ---> pointing to ```0``` bit & child[1] ---> pointing to ```1``` bit.\\n* We insert all the elements into the Trie :\\n          1. We use a bitset of size 32 (```bitset<32> bs```), go from the most significant bit (MSB) to the least significant bit (LSB).\\n          2. We start at the root of the Trie & check if it\\'s child[0] or child[1] is present (not ```NULL```), depending upon the current bit ```bs[j]``` at each bit of the number.\\n          3. If it\\'s present, we go to it\\'s child, if not, we create a new Node at that child (0 bit or 1 bit) and move to it\\'s child.\\n* We traverse the array & for each element we find the maximum ```XOR``` possible with any other element in the array using the Trie :\\n         1. We start at the root of the Trie and at the MSB of the number & we initialize ```ans = 0```.\\n         2. If the current bit is set, we go to ```child[0]``` to check if it\\'s not NULL. If it\\'s not NULL, we add ```1<<i``` to ```ans```.\\n         3. If it\\'s not set, we go to ```child[1]``` to see it\\'s not NULL, if it\\'s not NULL, we add ```1<<i``` to ```ans```.\\n* After checking the maximum XOR possible (with any other element) at each element of the array, we update the result to maximum of previous result & the current result.\\n* Finally return the maximum possible XOR.\\n\\n*I tried my best to explain the approavh here, please refer to the code for better clarity*\\n\\n**Time Complexity :** O(n*x*logm) - ```n = nums.size()```, ```m = *max_element(nums.begin(), nums.end())```.\\n\\n**Code :**\\n```\\nclass TrieNode{\\npublic:\\n    TrieNode *child[2];\\n    \\n    TrieNode(){\\n        this->child[0] = NULL; //for 0 bit \\n        this->child[1] = NULL; //for 1 bit\\n    }\\n};\\nclass Solution {\\n    TrieNode *newNode;\\n    \\n    void insert(int x){   //to insert each element into the Trie\\n        TrieNode *t = newNode;\\n        bitset<32> bs(x);\\n        \\n        for(int j=31; j>=0; j--){\\n            if(!t->child[bs[j]]) t->child[bs[j]] = new TrieNode(); //start from the MSB =, move to LSB using bitset\\n            t = t->child[bs[j]];\\n        }    \\n    }\\n    \\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        newNode = new TrieNode();\\n        for(auto &n : nums) insert(n); //insert all the elements into the Trie\\n        \\n        int ans=0; //Stores the maximum XOR possible so far\\n        for(auto n : nums){\\n            ans = max(ans, maxXOR(n));  //updates the ans as we traverse the array & compute max XORs at each element.\\n        }\\n        return ans;\\n    }\\n    \\n    int maxXOR(int n){\\n        TrieNode *t = newNode;\\n        bitset<32> bs(n);\\n        int ans=0; \\n        for(int j=31; j>=0; j--){\\n            if(t->child[!bs[j]]) ans += (1<<j), t = t->child[!bs[j]]; //Since 1^0 = 1 & 1^1 = 0, 0^0 = 0\\n           \\n            else t = t->child[bs[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if you like my solution & explanation :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```0```\n```1```\n```0```\n```1```\n```bitset<32> bs```\n```NULL```\n```bs[j]```\n```XOR```\n```ans = 0```\n```child[0]```\n```1<<i```\n```ans```\n```child[1]```\n```1<<i```\n```ans```\n```n = nums.size()```\n```m = *max_element(nums.begin(), nums.end())```\n```\\nclass TrieNode{\\npublic:\\n    TrieNode *child[2];\\n    \\n    TrieNode(){\\n        this->child[0] = NULL; //for 0 bit \\n        this->child[1] = NULL; //for 1 bit\\n    }\\n};\\nclass Solution {\\n    TrieNode *newNode;\\n    \\n    void insert(int x){   //to insert each element into the Trie\\n        TrieNode *t = newNode;\\n        bitset<32> bs(x);\\n        \\n        for(int j=31; j>=0; j--){\\n            if(!t->child[bs[j]]) t->child[bs[j]] = new TrieNode(); //start from the MSB =, move to LSB using bitset\\n            t = t->child[bs[j]];\\n        }    \\n    }\\n    \\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        newNode = new TrieNode();\\n        for(auto &n : nums) insert(n); //insert all the elements into the Trie\\n        \\n        int ans=0; //Stores the maximum XOR possible so far\\n        for(auto n : nums){\\n            ans = max(ans, maxXOR(n));  //updates the ans as we traverse the array & compute max XORs at each element.\\n        }\\n        return ans;\\n    }\\n    \\n    int maxXOR(int n){\\n        TrieNode *t = newNode;\\n        bitset<32> bs(n);\\n        int ans=0; \\n        for(int j=31; j>=0; j--){\\n            if(t->child[!bs[j]]) ans += (1<<j), t = t->child[!bs[j]]; //Since 1^0 = 1 & 1^1 = 0, 0^0 = 0\\n           \\n            else t = t->child[bs[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722805,
                "title": "java-a-very-detailed-explanation-with-sim-understanding-trie-bit",
                "content": "****\\nPlease upvote if the explanation helps, as it keeps up the motivation to provide such posts. \\n****\\nPS : This must be a Hard Problem.\\n\\n**Explanation Flow :** \\n* Given statements/Observations\\n* Simulation of logic\\n* Approach\\n* Code\\n* Bit Logic \\n\\n**\\u2714\\uFE0F Given statements:** \\n\\nGiven an integer array `nums`, \\nreturn the maximum result of `nums[i]` XOR `nums[j]`, where `0 <= i <= j < n.`\\n\\n**Let\\'s first solve a smaller version of this problem:** \\n\\nGiven an array `nums` and a no `x`, find the maximum result of `nums[i]` XOR `x`.\\nWe can generalise the outcome from this to solve our main problem.\\n`nums : [ 4, 5, 8, 9 ]`\\n`x` : `6`\\n\\nLet\\'s create a trie from `nums`.\\nIn order to get a maximum number after xor, we want to have our bits set from `MSB` because of powers of 2 are high. Let me take an example : \\n\\n![image](https://assets.leetcode.com/users/images/3852e0c2-ebed-415c-8118-904c56a8724b_1643251059.2812488.png)\\n\\n****\\n\\nSo,  our code flow will be something like this : [ Simulation ]\\nSee how we have removing those inputs which does not help us reach the maximum result ! This is achieved by Trie, we keep moving in the correct direction hence, removing the invalid inputs from the way.\\n\\n****\\nIf the simulation is bit too fast, here is the link of files :\\nhttps://drive.google.com/drive/folders/1VeNW7_jFif6-czvbsgEZFxiOSOCeQb3b?usp=sharing\\n\\n\\n![image](https://assets.leetcode.com/users/images/5bbde8f6-016e-4987-9ea8-2b51021b8e03_1643256352.788602.gif)\\n\\n\\n****\\n\\nWe have to perform this action for every `A[i]` and get the maximum.\\n\\n**\\u2714\\uFE0F Approach :** \\n\\n1. We insert A[i] in Binary Trie, starting from `MSB` to `LSB`.\\n2. Each A[i] will be stored in `1` and `0` corresponding to its bit position.\\n3. For every element `A[i]`, we check what is the current maximum result we could get from xor ( refer simulation )\\n4. Get overall maximum\\n\\n**\\u2714\\uFE0F Code :** \\n\\n```\\nclass Node {\\n    HashMap<Integer, Node> children;\\n    Node() {\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie {\\n    Node root;\\n    \\n    Trie() {\\n        this.root = new Node();\\n    }\\n    \\n    public void insert(int[] A) {\\n        for(int num : A) {\\n            Node curr = this.root;\\n            for(int i=31;i>=0;i--) {\\n                int currBit = (num >> i) & 1;\\n                if(!curr.children.containsKey(currBit)) \\n                    curr.children.put(currBit, new Node());\\n                curr = curr.children.get(currBit);\\n            }\\n        }\\n    }\\n}\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        Trie trie = new Trie();\\n        trie.insert(nums);\\n        \\n        int max = 0;\\n\\n        for(int num : nums) {\\n            Node curr = trie.root;\\n            int currSum = 0;\\n            for(int i=31;i>=0;i--) {\\n                int requiredBit = 1-((num >> i) & 1); // if A[i] is 0, we need 1 and if A[i] is 1, we need 0. Thus, 1 - A[i]\\n                if(curr.children.containsKey(requiredBit)) {\\n                    currSum |= (1<<i); // set ith bit of curr result\\n                    curr = curr.children.get(requiredBit);\\n                } else {\\n                    curr = curr.children.get(1-requiredBit);\\n                }\\n            }\\n            max = Math.max(max, currSum); // get max number\\n        }\\n        return max;\\n    }\\n}\\n\\n```\\n\\n\\n**\\u2714\\uFE0F Complexity Analysis** : \\n* TC : `O(n * 32)` + `O(n)` = `O(n)`\\n* SC : `O(2^h - 1)` == `O(2^32 - 1)` == `O(1)` [ refer @kazuwuqt comment below ]\\n\\n**Bit Logic :**\\n\\nShift operators are used to shift the bits of a number left or right, i.e. multiplying or dividing the number by two, respectively.\\n**Syntax : \"num\" \"op\" \"positions_to_shift\"**\\n\\n`>>` is a right shift operator. There are two ways to think about it : \\n1. It shift the number by *positions* specified to the right. ( fill unoccupied positions with 0 ) or,\\n2. It divides the number by 2^positions\\n\\nby doing `num >> i` , **main aim is to get the ith bit of number.**\\nI am shifting the num by `i` positions ( we get decimal number ) and getting the bit at that position ( by doing `& 1` -> 1&0 = 0 and 1&1 = 1 ).\\n\\nFor eg : \\n`num = 5 ( 0 1 0 1 )`\\nnum >> `2` means \\n1. shifting the num by 2 position -> 0 0 1 0 -> 0 0 0 1 i.e. 1 ( in decimal )  `& 1`  yields `1` i.e. the 2nd bit of number 5 is `1` \\n2. divide num by 2^`2` ->  5/4 -> 1 `& 1` yields `1` i.e. the 2nd bit of number 5 is `1` .\\n\\n****\\nIf there is any suggestion, pls let me know\\n****",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Node {\\n    HashMap<Integer, Node> children;\\n    Node() {\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie {\\n    Node root;\\n    \\n    Trie() {\\n        this.root = new Node();\\n    }\\n    \\n    public void insert(int[] A) {\\n        for(int num : A) {\\n            Node curr = this.root;\\n            for(int i=31;i>=0;i--) {\\n                int currBit = (num >> i) & 1;\\n                if(!curr.children.containsKey(currBit)) \\n                    curr.children.put(currBit, new Node());\\n                curr = curr.children.get(currBit);\\n            }\\n        }\\n    }\\n}\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        Trie trie = new Trie();\\n        trie.insert(nums);\\n        \\n        int max = 0;\\n\\n        for(int num : nums) {\\n            Node curr = trie.root;\\n            int currSum = 0;\\n            for(int i=31;i>=0;i--) {\\n                int requiredBit = 1-((num >> i) & 1); // if A[i] is 0, we need 1 and if A[i] is 1, we need 0. Thus, 1 - A[i]\\n                if(curr.children.containsKey(requiredBit)) {\\n                    currSum |= (1<<i); // set ith bit of curr result\\n                    curr = curr.children.get(requiredBit);\\n                } else {\\n                    curr = curr.children.get(1-requiredBit);\\n                }\\n            }\\n            max = Math.max(max, currSum); // get max number\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91103,
                "title": "c-o-n-solution-explanation-added",
                "content": "```\\nint findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n == 0 || n == 1)\\n            return 0;\\n        if (n == 2)\\n            return nums.at(0) ^ nums.at(1);\\n        \\n        list<int> set0;\\n        list<int> set1;\\n        int i;\\n        int j;\\n        int maxValue;\\n        \\n        for (i = 30; i >= 0; i--) {\\n            for (j = 0; j < n; j++) {\\n                if ((nums.at(j) & (1<<i)) == 0)\\n                    set0.push_back(nums.at(j));\\n                else\\n                    set1.push_back(nums.at(j));\\n            }\\n            \\n            if (set0.size() != 0 && set1.size() != 0) {\\n                maxValue = pow(2, i);\\n                break;\\n            }\\n            else {\\n                set0.clear();\\n                set1.clear();\\n            }\\n        }\\n        \\n        if (i == -1)\\n            return 0;\\n        \\n        maxValue += getMaxXor(set0, set1, i-1);\\n        \\n        return maxValue;\\n}\\n\\nint getMaxXor(list<int>& set0, list<int>& set1, int pos) {\\n        int maxValue;\\n        list<int> set0list0;\\n        list<int> set0list1;\\n        list<int> set1list0;\\n        list<int> set1list1;\\n        int i;\\n        list<int>::iterator it;\\n        \\n        if (set0.size() == 0 || set1.size() == 0 || pos < 0)\\n            return 0;\\n        \\n        for (it = set0.begin(); it != set0.end(); it++) {\\n            int value = *it;\\n            if ((value & (1<<pos)) == 0)\\n                set0list0.push_back(value);\\n            else\\n                set0list1.push_back(value);\\n        }\\n        \\n        for (it = set1.begin(); it != set1.end(); it++) {\\n            int value = *it;\\n            if ((value & (1<<pos)) == 0)\\n                set1list0.push_back(value);\\n            else\\n                set1list1.push_back(value);\\n        }\\n        \\n        if (set0list0.size() == 0 && set1list0.size() == 0)\\n            maxValue = getMaxXor(set0, set1, pos-1);\\n        else if (set0list1.size() == 0 && set1list1.size() == 0)\\n            maxValue = getMaxXor(set0, set1, pos-1);\\n        else {\\n            int maxValue1 = getMaxXor(set0list0, set1list1, pos-1);\\n            int maxValue2 = getMaxXor(set0list1, set1list0, pos-1);\\n            maxValue = pow(2, pos) + (maxValue1 > maxValue2 ? maxValue1 : maxValue2);\\n        }\\n        \\n        return maxValue;\\n }\\n```\\n\\nExample input: [42, 5, 69, 22, 23, 8, 1, 17, 30, 75, 99]\\n\\nThe max XOR value is (30 ^ 99) = 125. Below are the binary represntations of each number.\\n\\n42 = 0 1 0 1 0 1 0\\n\\n5  = 0 0 0 0 1 0 1\\n\\n69 = 1 0 0 0 1 0 1\\n\\n22 = 0 0 1 0 1 1 0\\n\\n23 = 0 0 1 0 1 1 1\\n\\n8  = 0 0 0 1 0 0 0\\n\\n1  = 0 0 0 0 0 0 1\\n\\n17 = 0 0 1 0 0 0 1\\n\\n30 = 0 0 1 1 1 1 0\\n\\n75 = 1 0 0 1 0 1 1\\n\\n99 = 1 1 0 0 0 1 1\\n\\nEach number in the array is >= 0 and < pow(2,31). So, any number in the array can be represented by atmost 31 bits (bits[30:0]).\\nThe for loop in findMaximumXOR (lines 17-33) finds the max bit position where some of the numbers have '0' in that bit position and the other numbers have '1' in that bit position.\\nThe numbers that have '0' in that bit position go to set0 and the numbers that have '1' in that bit position go to set1. So, for the example above, we have:\\nset0 = {42, 5, 22, 23, 8, 1, 17,30}\\nset1 = {69, 75, 99}\\nBit position = 6.\\nThe value obtained by XORing bit 6 between set0 and set1 (forgetting the low order bits) is pow(2, 6) = 64.\\n\\nNext, findMaximumXOR() calls getMaxXor() passing set0 and set1 to recursively find the max value of the XOR between numbers in set0 and set1 for the remaning low order bits. The max XOR value would then be 64 + (the max value returned by getMaxXor()).\\n\\nThe first call would be getMaxXor({42, 5, 22, 23, 8, 1, 17,30}, {69, 75, 99}, 5).\\nWhat getMaximumXOR() does is for bit position 5, it splits set0 into two sets - the numbers that have '0' in bit position 5 go to set0list0. The numbers that have '1' in bit position 5 goto set0list1. The same is done for set1 i.e. set1 is also split into two sets set1list0 and set1list1. For this specific example, we have:\\n\\nset0list0 = {5, 22, 23, 8, 1, 17, 30}\\nset0list1 = {42}\\nset1list0 = {69, 75}\\nset1list1 = {99}\\n\\nSince at bit position 5 we found set0list0 and set1list1, that means XORing bit 5 (forgetting the low order bits) of numbers between set0list0 and set1list1 woul give pow(2, 5) = 32.\\nSo, the maximum XOR value between numbers in set0list0 and set1list1 would be 32 + (set0list0, set1list1, 4).\\nArguing on the same lines, the maximum XOR value between numbers in set0list1 and set1list0 would be 32 + (set0list1, set1list0, 4).\\nNote that we pair the \"opposite\" resulting sets to get to the max XOR value i.e. (set0list0, set1list1) and (set0list1, set1list0).\\n\\nFor this specific example the recursive calls would be:\\n\\ngetMaxXor({5, 22, 23, 8, 1, 17, 30}, {99}, 4);\\nset0list0 = {5, 8, 1}\\nset0list1 = {22, 23, 17, 30}\\nset1list0 = {99}\\nset1list1 = {}\\n\\ngetMaxXor({5, 8, 1}, {}, 3); ==> This call returns 0 as set1 is empty.\\n\\ngetMaxXor({22, 23, 17, 30}, {99}, 3);\\nset0list0 = {22, 23, 17}\\nset0list1 = {30}\\nset1list0 = {99}\\nset1list1 = {}\\n\\ngetMaxXor({22, 23, 17}, {}, 2); ==> This call returns 0 as set1 is empty.\\n\\ngetMaxXor({30}, {99}, 2);\\nset0list0 = {}\\nset0list1 = {30}\\nset1list0 = {99}\\nset1list1 = {}\\n\\ngetMaxXor{{30}, {99}, 1};\\nset0list0 = {}\\nset0list1 = {30}\\nset1list0 = {}\\nset1list1 = {99}\\n\\nSince both set0list0 and set1list0 are empty, we simply ignore this bit position and check the next lower bit position. So:\\n\\ngetMaxXor({30}, {99}, 0);\\n\\nset0list0 = {30}\\nset0list1 = {}\\nset1list0 = {}\\nset1list1 = {99}\\n\\ngetMaxXor({30}, {99}, -1) ==>This call would return 0, as bit position is invalid.\\n\\ngetMaxXor({42}, {69, 75}, 4);\\nset0list0 = {42}\\nset0list1 = {}\\nset1list0 = {69, 75}\\nset1list1 = {}\\n\\ngetMaxXor({42}, {69, 75}, 3);\\n\\nset0list0 = {}\\nset0list1 = {42}\\nset1list0 = {69}\\nset1list1 = {75}\\n\\ngetMaxXor({}, {75}, 2); ==> This call returns 0 as set0 is empty\\n\\ngetMaxXor({42}, {75}, 2)\\nset0list0 = {42}\\nset0list1 = {}\\nset1list0 = {75}\\nset1list1 = {}\\n\\ngetMaxXor({42}, {75}, 1)\\nset0list0 = {}\\nset0list1 = {42}\\nset1list0 = {}\\nset1list1 = {75}\\n\\ngetMaxXor({42}, {75}, 0)\\nset0list0 = {42}\\nset0list1 = {}\\nset1list0 = {}\\nset1list1 = {75}\\n\\ngetMaxXor({42}, {75}, -1)\\n\\nIn the recursive calls above, the max value is returned by the path:\\ngetMaxXor({42, 5, 22, 23, 8, 1, 17,30}, {69, 75, 99}, 5) //maxValue = 32\\ngetMaxXor({5, 22, 23, 8, 1, 17, 30}, {99}, 4) //maxValue = 16\\ngetMaxXor({22, 23, 17, 30}, {99}, 3) //maxValue = 8\\ngetMaxXor({30}, {99}, 2) //maxValue = 4\\ngetMaxXor{{30}, {99}, 1} //maxValue = 0\\ngetMaxXor({30}, {99}, 0) //maxValue = 1\\ngetMaxXor({30}, {99}, -1) //maxValue = 0\\n\\nSo, the final max XOR value returned = 64 + 32 + 16 + 8 + 4 + 1 = 125.\\n\\nThe run time is O(n) because we iterate 31 times, once for each bit position (i.e. bits 30 to 0). During each bit position, we check/visit each number at most once. So, the time complexity would be 31xn or O(n).",
                "solutionTags": [],
                "code": "```\\nint findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n == 0 || n == 1)\\n            return 0;\\n        if (n == 2)\\n            return nums.at(0) ^ nums.at(1);\\n        \\n        list<int> set0;\\n        list<int> set1;\\n        int i;\\n        int j;\\n        int maxValue;\\n        \\n        for (i = 30; i >= 0; i--) {\\n            for (j = 0; j < n; j++) {\\n                if ((nums.at(j) & (1<<i)) == 0)\\n                    set0.push_back(nums.at(j));\\n                else\\n                    set1.push_back(nums.at(j));\\n            }\\n            \\n            if (set0.size() != 0 && set1.size() != 0) {\\n                maxValue = pow(2, i);\\n                break;\\n            }\\n            else {\\n                set0.clear();\\n                set1.clear();\\n            }\\n        }\\n        \\n        if (i == -1)\\n            return 0;\\n        \\n        maxValue += getMaxXor(set0, set1, i-1);\\n        \\n        return maxValue;\\n}\\n\\nint getMaxXor(list<int>& set0, list<int>& set1, int pos) {\\n        int maxValue;\\n        list<int> set0list0;\\n        list<int> set0list1;\\n        list<int> set1list0;\\n        list<int> set1list1;\\n        int i;\\n        list<int>::iterator it;\\n        \\n        if (set0.size() == 0 || set1.size() == 0 || pos < 0)\\n            return 0;\\n        \\n        for (it = set0.begin(); it != set0.end(); it++) {\\n            int value = *it;\\n            if ((value & (1<<pos)) == 0)\\n                set0list0.push_back(value);\\n            else\\n                set0list1.push_back(value);\\n        }\\n        \\n        for (it = set1.begin(); it != set1.end(); it++) {\\n            int value = *it;\\n            if ((value & (1<<pos)) == 0)\\n                set1list0.push_back(value);\\n            else\\n                set1list1.push_back(value);\\n        }\\n        \\n        if (set0list0.size() == 0 && set1list0.size() == 0)\\n            maxValue = getMaxXor(set0, set1, pos-1);\\n        else if (set0list1.size() == 0 && set1list1.size() == 0)\\n            maxValue = getMaxXor(set0, set1, pos-1);\\n        else {\\n            int maxValue1 = getMaxXor(set0list0, set1list1, pos-1);\\n            int maxValue2 = getMaxXor(set0list1, set1list0, pos-1);\\n            maxValue = pow(2, pos) + (maxValue1 > maxValue2 ? maxValue1 : maxValue2);\\n        }\\n        \\n        return maxValue;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166211,
                "title": "python-o-n-solution-for-dummies-like-me-easy-commented-solution-with-explanation",
                "content": "```\\nclass TrieNode():\\n    zero = None\\n    one = None\\n    value = None\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # we\\'ll first construct a tree that represents all the nums. \\n        # The tree starts at `root` node, and all the leaf nodes in this tree will represent one num in nums.\\n        root = TrieNode()\\n        bit_range = range(31, -1, -1)       # [31, 30, .... 0]. We\\'ll use this to iterate over num bit by bit.\\n        for num in nums:\\n            # always start at the top of the tree\\n            curr = root\\n            for i in bit_range:\\n                # get i\\'th bit in num\\n                mask = 1 << i               # mask will be something like 0000000100000, 1 being at the i\\'th position\\n                masked_num = num & mask     # if i\\'th bit was 0, masked_num is 0. Else masked_num is some number. In this case 100000 = 64\\n                if masked_num is 0:\\n                    # i\\'th bit was a 0, so traverse left (to zero), and create node as necessary\\n                    if not curr.zero:\\n                        curr.zero = TrieNode()\\n                    curr = curr.zero\\n                else:\\n                    # i\\'th bit was a 1, so traverse right (to one), and create node as necessary\\n                    if not curr.one:\\n                        curr.one = TrieNode()\\n                    curr = curr.one\\n            # Store num in the leaf node. \\n            # We could always calculate it later ourselves by traversing the tree and using X*32+X*16+X*8+X*4+X*2+X*1 and so on\\n            # But I prefer this way, because it helps to point out that each leaf corresponds to a num in the nums array.\\n            curr.value = num\\n\\n        # At this stage our tree is complete.\\n        # Note that, all the leaf nodes are at the same level - always 32. There are no leaf nodes in the tree that are at any level less or more than 32.\\n        # Also, note that the tree starts with the most significant bit (MSB) at the top, and least significant bit (LSB) at the bottom.\\n\\n        # To calculate maximum overall xor, we\\'ll first calculate maximum xor possible for each num in nums.\\n        # Side note: 1 xor 0 = 1; 0 xor 1 = 1; 1 xor 1 = 0; 0 xor 0 = 0\\n        # To calculate maximum possible xor value for num, we can traverse down the tree we constructed earlier.\\n        # How it works is, we\\'ll go through bit-by-bit in num, from MSB to LSB.\\n        # If we\\'re working with a 0, our goal is to find a 1. If we\\'re working with a 1, our goal is to find a 0.\\n        # If we do find what we\\'re looking for (our goal), Awesome! go there, then continue to next bit.\\n        # Otherwise, you gotta do something. So go to the remaining available node, and hope that the remaining bits in the number will give better results.\\n        # This greedy approach works, because even summing all the lower bits won\\'t ever equal, even one bit higher. That is 10000 > 01111\\n\\n        # Okay, let\\'s go\\n        max_xor = 0\\n        for num in nums:\\n            curr = root\\n            for i in bit_range:\\n                # get i\\'th bit in num\\n                mask = 1 << i               # mask will be something like 0000000100000, 1 being at the i\\'th position\\n                masked_num = num & mask     # if i\\'th bit was 0, masked_num is 0. Else masked_num is some number. In this case 100000 = 64\\n                if masked_num is 0:\\n                    # i\\'th bit was a 0, so traverse right (to one)\\n                    if curr.one:\\n                        curr = curr.one\\n                    else:\\n                        # gotta do something\\n                        curr = curr.zero\\n                else:\\n                    # i\\'th bit was a 1, so traverse left (to zero)\\n                    if curr.zero:\\n                        curr = curr.zero\\n                    else:\\n                        # gotta do something\\n                        curr = curr.one\\n            # We are at a leaf node now. So we are at some value. \\n            # This is the number that is most different from `num`. That is to say, will give the maximum possible XOR for num. \\n            max_xor_for_num = num ^ curr.value\\n            print(max_xor_for_num)\\n            if max_xor_for_num > max_xor:\\n                max_xor = max_xor_for_num\\n\\n        return max_xor\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode():\\n    zero = None\\n    one = None\\n    value = None\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # we\\'ll first construct a tree that represents all the nums. \\n        # The tree starts at `root` node, and all the leaf nodes in this tree will represent one num in nums.\\n        root = TrieNode()\\n        bit_range = range(31, -1, -1)       # [31, 30, .... 0]. We\\'ll use this to iterate over num bit by bit.\\n        for num in nums:\\n            # always start at the top of the tree\\n            curr = root\\n            for i in bit_range:\\n                # get i\\'th bit in num\\n                mask = 1 << i               # mask will be something like 0000000100000, 1 being at the i\\'th position\\n                masked_num = num & mask     # if i\\'th bit was 0, masked_num is 0. Else masked_num is some number. In this case 100000 = 64\\n                if masked_num is 0:\\n                    # i\\'th bit was a 0, so traverse left (to zero), and create node as necessary\\n                    if not curr.zero:\\n                        curr.zero = TrieNode()\\n                    curr = curr.zero\\n                else:\\n                    # i\\'th bit was a 1, so traverse right (to one), and create node as necessary\\n                    if not curr.one:\\n                        curr.one = TrieNode()\\n                    curr = curr.one\\n            # Store num in the leaf node. \\n            # We could always calculate it later ourselves by traversing the tree and using X*32+X*16+X*8+X*4+X*2+X*1 and so on\\n            # But I prefer this way, because it helps to point out that each leaf corresponds to a num in the nums array.\\n            curr.value = num\\n\\n        # At this stage our tree is complete.\\n        # Note that, all the leaf nodes are at the same level - always 32. There are no leaf nodes in the tree that are at any level less or more than 32.\\n        # Also, note that the tree starts with the most significant bit (MSB) at the top, and least significant bit (LSB) at the bottom.\\n\\n        # To calculate maximum overall xor, we\\'ll first calculate maximum xor possible for each num in nums.\\n        # Side note: 1 xor 0 = 1; 0 xor 1 = 1; 1 xor 1 = 0; 0 xor 0 = 0\\n        # To calculate maximum possible xor value for num, we can traverse down the tree we constructed earlier.\\n        # How it works is, we\\'ll go through bit-by-bit in num, from MSB to LSB.\\n        # If we\\'re working with a 0, our goal is to find a 1. If we\\'re working with a 1, our goal is to find a 0.\\n        # If we do find what we\\'re looking for (our goal), Awesome! go there, then continue to next bit.\\n        # Otherwise, you gotta do something. So go to the remaining available node, and hope that the remaining bits in the number will give better results.\\n        # This greedy approach works, because even summing all the lower bits won\\'t ever equal, even one bit higher. That is 10000 > 01111\\n\\n        # Okay, let\\'s go\\n        max_xor = 0\\n        for num in nums:\\n            curr = root\\n            for i in bit_range:\\n                # get i\\'th bit in num\\n                mask = 1 << i               # mask will be something like 0000000100000, 1 being at the i\\'th position\\n                masked_num = num & mask     # if i\\'th bit was 0, masked_num is 0. Else masked_num is some number. In this case 100000 = 64\\n                if masked_num is 0:\\n                    # i\\'th bit was a 0, so traverse right (to one)\\n                    if curr.one:\\n                        curr = curr.one\\n                    else:\\n                        # gotta do something\\n                        curr = curr.zero\\n                else:\\n                    # i\\'th bit was a 1, so traverse left (to zero)\\n                    if curr.zero:\\n                        curr = curr.zero\\n                    else:\\n                        # gotta do something\\n                        curr = curr.one\\n            # We are at a leaf node now. So we are at some value. \\n            # This is the number that is most different from `num`. That is to say, will give the maximum possible XOR for num. \\n            max_xor_for_num = num ^ curr.value\\n            print(max_xor_for_num)\\n            if max_xor_for_num > max_xor:\\n                max_xor = max_xor_for_num\\n\\n        return max_xor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345905,
                "title": "c-python-trie-solution-clean-concise-o-32n",
                "content": "**Idea**\\n- Iterate elements `x` in `nums`, add `x` into our Trie.\\n- Iterate elements `x` in `nums` again, find the maximum XOR result between a value `val` and a number in our Trie.\\n- How to get the maximum XOR result between a value `val` and a number in our Trie in `O(1)`? \\n\\t- Our Trie will store numbers in form of their 32 bit presentation, store the **most significant bit** near the root.\\n\\t- Since in `XOR` operator, 2 bit is different will result bit `1`, that is `1^0=1`, `0^1=1`, otherwise will be 0.\\n\\t- To find the maximum XOR of a value `val` with numbers in our Trie, we traverse 18 bits of `val` with the  **most significant bit** first.\\n\\t\\t- If the current bit of `val` is `1`, we check if exist a number with bit `0` in the Trie, if exist then the bit result is `1`.\\n\\t\\t- If the current bit of `val` is `0`, we check if exist a number with bit `1` in the Trie, if exist then the bit result is `1`.\\n\\t\\t- Else the bit result is `0`.\\n\\n<iframe src=\"https://leetcode.com/playground/7hQTAuMo/shared\" frameBorder=\"0\" width=\"100%\" height=\"700\"></iframe>\\n\\n**Complexity**\\n- Time: `O(32 * N)`\\n- Space: `O(32 * N)`",
                "solutionTags": [],
                "code": "**Idea**\\n- Iterate elements `x` in `nums`, add `x` into our Trie.\\n- Iterate elements `x` in `nums` again, find the maximum XOR result between a value `val` and a number in our Trie.\\n- How to get the maximum XOR result between a value `val` and a number in our Trie in `O(1)`? \\n\\t- Our Trie will store numbers in form of their 32 bit presentation, store the **most significant bit** near the root.\\n\\t- Since in `XOR` operator, 2 bit is different will result bit `1`, that is `1^0=1`, `0^1=1`, otherwise will be 0.\\n\\t- To find the maximum XOR of a value `val` with numbers in our Trie, we traverse 18 bits of `val` with the  **most significant bit** first.\\n\\t\\t- If the current bit of `val` is `1`, we check if exist a number with bit `0` in the Trie, if exist then the bit result is `1`.\\n\\t\\t- If the current bit of `val` is `0`, we check if exist a number with bit `1` in the Trie, if exist then the bit result is `1`.\\n\\t\\t- Else the bit result is `0`.\\n\\n<iframe src=\"https://leetcode.com/playground/7hQTAuMo/shared\" frameBorder=\"0\" width=\"100%\" height=\"700\"></iframe>\\n\\n**Complexity**\\n- Time: `O(32 * N)`\\n- Space: `O(32 * N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 91052,
                "title": "c-trie-69ms-beats-85",
                "content": "```\\nclass Solution {\\npublic:\\n    class TreeNode {\\n    public:\\n        TreeNode* next[2];\\n        TreeNode () {next[0] = NULL; next[1] = NULL;};\\n    };\\n    TreeNode* buildTree(vector<int>& nums) {\\n        TreeNode* root = new TreeNode(), *cur;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            cur = root;\\n            for (int j = 31; j >= 0; j--) {\\n                int index = ((num >> j) & 1);\\n                if (cur->next[index] ==  NULL)\\n                    cur->next[index] = new TreeNode();\\n                cur = cur->next[index];\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    int helper(TreeNode* cur, int num) {\\n        int res = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int index = ((num >> i) & 1) ? 0 : 1;\\n            if (cur->next[index]) {\\n                res <<= 1;\\n                res |= 1;\\n                cur = cur->next[index];\\n            } else {\\n                res <<= 1;\\n                res |= 0;\\n                cur = cur->next[index ? 0 : 1];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        TreeNode* root = buildTree(nums);\\n        \\n        for (auto i : nums) {\\n            res = max(res, helper(root, i));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class TreeNode {\\n    public:\\n        TreeNode* next[2];\\n        TreeNode () {next[0] = NULL; next[1] = NULL;};\\n    };\\n    TreeNode* buildTree(vector<int>& nums) {\\n        TreeNode* root = new TreeNode(), *cur;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            cur = root;\\n            for (int j = 31; j >= 0; j--) {\\n                int index = ((num >> j) & 1);\\n                if (cur->next[index] ==  NULL)\\n                    cur->next[index] = new TreeNode();\\n                cur = cur->next[index];\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    int helper(TreeNode* cur, int num) {\\n        int res = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int index = ((num >> i) & 1) ? 0 : 1;\\n            if (cur->next[index]) {\\n                res <<= 1;\\n                res |= 1;\\n                cur = cur->next[index];\\n            } else {\\n                res <<= 1;\\n                res |= 0;\\n                cur = cur->next[index ? 0 : 1];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        TreeNode* root = buildTree(nums);\\n        \\n        for (auto i : nums) {\\n            res = max(res, helper(root, i));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130522,
                "title": "python-trie-solution-o-n",
                "content": "Here I use a trie (binary tree has zero and one children)\\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.one = None\\n        self.zero = None\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        root = TrieNode()\\n        for num in nums:\\n            node = root\\n            for j in range (31, -1, -1):\\n                tmp = num & 1 << j\\n                if tmp:\\n                    if not node.one:\\n                        node.one = TrieNode()\\n                    node = node.one\\n                else:\\n                    if not node.zero:\\n                        node.zero = TrieNode()\\n                    node = node.zero\\n                    \\n        ans = 0\\n        for num in nums:\\n            node = root\\n            tmp_val = 0\\n            for j in range (31, -1, -1):\\n                tmp = num & 1 << j\\n                if node.one and node.zero:\\n                    if tmp:\\n                        node = node.zero\\n                    else:\\n                        node = node.one\\n                    tmp_val += 1 << j\\n                else:\\n                    if (node.zero and tmp) or (node.one and not tmp):\\n                        tmp_val += 1 << j\\n                    node = node.one or node.zero\\n            ans = max(ans, tmp_val)\\n                                                \\n        return ans\\n```\\nAsk me if you have question or correct me if I am wrong.\\n\\nThanks",
                "solutionTags": [],
                "code": "```\\nclass TrieNode():\\n    def __init__(self):\\n        self.one = None\\n        self.zero = None\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        root = TrieNode()\\n        for num in nums:\\n            node = root\\n            for j in range (31, -1, -1):\\n                tmp = num & 1 << j\\n                if tmp:\\n                    if not node.one:\\n                        node.one = TrieNode()\\n                    node = node.one\\n                else:\\n                    if not node.zero:\\n                        node.zero = TrieNode()\\n                    node = node.zero\\n                    \\n        ans = 0\\n        for num in nums:\\n            node = root\\n            tmp_val = 0\\n            for j in range (31, -1, -1):\\n                tmp = num & 1 << j\\n                if node.one and node.zero:\\n                    if tmp:\\n                        node = node.zero\\n                    else:\\n                        node = node.one\\n                    tmp_val += 1 << j\\n                else:\\n                    if (node.zero and tmp) or (node.one and not tmp):\\n                        tmp_val += 1 << j\\n                    node = node.one or node.zero\\n            ans = max(ans, tmp_val)\\n                                                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171747,
                "title": "python-o-n-solution-easily-explained",
                "content": "This problem is tricky so I hope this solution helps!\\n\\nGeneral form of solution is to find two numbers which have the highest bits complementing each other (0 and 1). Then store that max, look at the next less significant bit and see if another two numbers complement each other (which includes the bits sets from the previous max). If so, this number will\\nbe greater than the previous maximum. Steps:\\n\\n1) Find the new possible maximum by setting the next bit to 1 on the current maximum\\n2) use a mask with all 1s up to the current bit i and & all numbers with this mask to see which bit in that number up to bit i are set as 1.\\n3) Critical part: to solve this in O(n) it\\'s important to know that If a ^ b = c, then  a ^ c = b and c ^ b = a. So, if we are looking for a particular number (in our case a possible maximum) we can do the following search: iterate in the numbers that we &\\'d with the mask. If our potental maximum is c, and our current number is a, we\\'re looking for another number b that XOR\\'d with a gives c. Since we also know from above that a ^ c = b, we can just look for b it directly in our numbers (i.e. b = a ^ c, or in my code, bit ^ possible_mx). \\n\\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mx,mask=0,0\\n        for i in range(31,-1,-1):\\n            possible_mx = mx | 1 << i\\n            mask = mask | 1 << i\\n            bits=set()\\n            for num in nums:\\n                bits.add(num & mask)\\n            for bit in bits:\\n                if bit ^ possible_mx in bits:\\n                    mx = possible_mx\\n                    break\\n        return mx\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mx,mask=0,0\\n        for i in range(31,-1,-1):\\n            possible_mx = mx | 1 << i\\n            mask = mask | 1 << i\\n            bits=set()\\n            for num in nums:\\n                bits.add(num & mask)\\n            for bit in bits:\\n                if bit ^ possible_mx in bits:\\n                    mx = possible_mx\\n                    break\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825117,
                "title": "clean-c-trie-solution-faster-than-91-05",
                "content": "```\\nstruct trie{\\n    trie* next[2];\\n    trie()\\n    {\\n        next[0]=NULL;\\n        next[1]=NULL;\\n    }\\n};\\nclass TrieNode{\\n    private:\\n        trie* root;\\n    public:\\n        TrieNode()\\n        {\\n            root=new trie();\\n        }\\n    \\n    void insert(int num)\\n    {\\n        trie* curr=root;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(curr->next[bit]==NULL)\\n            {\\n                curr->next[bit]=new trie();\\n            }\\n            curr=curr->next[bit];\\n        }\\n    }\\n    \\n    int max_xor(int num)\\n    {\\n        trie* curr=root;\\n        int ans=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            \\n            if(curr->next[!bit])\\n            {\\n                ans+=(1<<i);\\n                curr=curr->next[!bit];\\n            }\\n            else\\n            {\\n                curr=curr->next[bit];\\n            }\\n        }\\n        return ans;\\n    }   \\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int max_ans=0;\\n        int n=nums.size();\\n        \\n        TrieNode* t=new TrieNode();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            t->insert(nums[i]);\\n            max_ans=max(max_ans,t->max_xor(nums[i]));\\n        }\\n        return max_ans;\\n    }\\n};\\n\\nplease upvote if found helpful : )",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int max_ans=0;\\n        int n=nums.size();\\n        \\n        TrieNode* t=new TrieNode();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            t->insert(nums[i]);\\n            max_ans=max(max_ans,t->max_xor(nums[i]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 91064,
                "title": "c-22-ms-beats-99-5-array-partitioning-similar-to-quick-sort",
                "content": "I have put detailed comments in the code. Here I just highlight the logic of the method.\\n\\n1) working from most significant bit on the left towards right. Obviously, if the more significant bit is 1, the xor value is greater than those with this bit = 0.\\n2) Similar to quick sort, we partition a certain range of the array nums in place. The left subrange has current bit = 1, and the right subrange has current bit = 0. Let's name them as A and B.\\n3) In order to find the greatest XOR value, we have to take 1 number from A, and 1 number from B. And to set next bit to 1, there must be a subrange in A and a subrange in B having opposite bit; otherwise, next bit will be 0. So we partition range A and B recursively.\\n4) When partitioning range A and B, there are 3 cases. (1) A has both bit 1 and 0 ranges. We check whether B has bit 0 or bit 1 range or both. (2) A has only bit 1. We check whether B has bit 0. (3) A has only bit 0. We check whether B has bit 1.\\n\\nFor every recursive call, the runtime is O(n). There are totally 31 levels of calls, so the runtime is O(n). And extra space is O(1) because the code works in place. The code with comments is as below.\\n```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        return helper(nums, 0, n-1, 0, n-1, 0, 30);\\n    }\\nprivate:\\n    // (ls, le) and (rs, re) are two ranges of nums, which gives max xor value to current bit;\\n    // bit decreases from 30 to 0, i.e., working from most significant bit on the left towards right;\\n    // Similar to quicksort, partition (ls, le) to two ranges (ls, j-1) and (j, le) by swapping elements\\n    // the range on the left with current bit = 1, and the range on right is 0; We do the same to (rs, re)\\n    // In order to set the current bit in the answer, i.e. val, to be 1, the left (ls, le) and right (rs,re) ranges must have subranges with opposite bit. If so, val = (val << 1) + 1; otherwise, val = val << 1.\\n    int helper(vector<int>& nums, int ls, int le, int rs, int re, int val, int bit) {\\n        if (bit == -1) return val;\\n        int mask = 1<<bit, j = ls, k = rs;\\n        for (int i = ls; i <= le; i++) \\n            if (nums[i]&mask) swap(nums[i], nums[j++]);\\n        for (int i = rs; i <= re; i++) \\n            if (nums[i]&mask) swap(nums[i], nums[k++]);\\n        // the left range has two subranges, the answer is max of (bit 1 subrange on the left and bit 0 subrange on the right) or (bit 0 subrange on the left and bit 1 subrange on the right)\\n        if (j > ls && j <= le) {\\n            int ans = 0;\\n            if (k > rs) \\n                ans = helper(nums, j, le, rs, k-1, val*2+1, bit-1);\\n            if (k <= re) \\n                ans = max(ans, helper(nums, ls, j-1, k, re, val*2+1, bit-1));\\n            return ans;\\n        }\\n        // the left range has only bit 0 subrange\\n        else if (j <= ls) {\\n            // check whether the right range has bit 1 subrange\\n            if (k > rs) \\n                return helper(nums, ls, le, rs, k-1, val*2+1, bit-1);\\n            else \\n                return helper(nums, ls, le, rs, re, val*2, bit-1);\\n        }\\n        // the left range has only bit 1 subrange\\n        else {\\n            // check whether the right range has bit 0 subrange\\n            if (k <= re) \\n                return helper(nums, ls, le, k, re, val*2+1, bit-1);\\n            else \\n                return helper(nums, ls, le, rs, re, val*2, bit-1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        return helper(nums, 0, n-1, 0, n-1, 0, 30);\\n    }\\nprivate:\\n    // (ls, le) and (rs, re) are two ranges of nums, which gives max xor value to current bit;\\n    // bit decreases from 30 to 0, i.e., working from most significant bit on the left towards right;\\n    // Similar to quicksort, partition (ls, le) to two ranges (ls, j-1) and (j, le) by swapping elements\\n    // the range on the left with current bit = 1, and the range on right is 0; We do the same to (rs, re)\\n    // In order to set the current bit in the answer, i.e. val, to be 1, the left (ls, le) and right (rs,re) ranges must have subranges with opposite bit. If so, val = (val << 1) + 1; otherwise, val = val << 1.\\n    int helper(vector<int>& nums, int ls, int le, int rs, int re, int val, int bit) {\\n        if (bit == -1) return val;\\n        int mask = 1<<bit, j = ls, k = rs;\\n        for (int i = ls; i <= le; i++) \\n            if (nums[i]&mask) swap(nums[i], nums[j++]);\\n        for (int i = rs; i <= re; i++) \\n            if (nums[i]&mask) swap(nums[i], nums[k++]);\\n        // the left range has two subranges, the answer is max of (bit 1 subrange on the left and bit 0 subrange on the right) or (bit 0 subrange on the left and bit 1 subrange on the right)\\n        if (j > ls && j <= le) {\\n            int ans = 0;\\n            if (k > rs) \\n                ans = helper(nums, j, le, rs, k-1, val*2+1, bit-1);\\n            if (k <= re) \\n                ans = max(ans, helper(nums, ls, j-1, k, re, val*2+1, bit-1));\\n            return ans;\\n        }\\n        // the left range has only bit 0 subrange\\n        else if (j <= ls) {\\n            // check whether the right range has bit 1 subrange\\n            if (k > rs) \\n                return helper(nums, ls, le, rs, k-1, val*2+1, bit-1);\\n            else \\n                return helper(nums, ls, le, rs, re, val*2, bit-1);\\n        }\\n        // the left range has only bit 1 subrange\\n        else {\\n            // check whether the right range has bit 0 subrange\\n            if (k <= re) \\n                return helper(nums, ls, le, k, re, val*2+1, bit-1);\\n            else \\n                return helper(nums, ls, le, rs, re, val*2, bit-1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774132,
                "title": "c-trie-with-clear-comments-to-help-understand-why-trie-works",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n      Node* zero_bit = nullptr;\\n      Node* one_bit = nullptr;\\n    };\\n    Node* root = new Node();\\n  \\n    // All Trie represent incremental pieces of a final value (chars -> string)\\n    // For an int, the incremental piece is a bit, so we will make Trie of bit-string\\n    // The Trie should always be accessed in chunks of 32 nodes (including root), so no concept\\n    // of intermediate versus final result (prefix vs word) is needed.\\n    void insert(const int& num) {\\n      Node* ptr = root;\\n      // Access all the bits MSB to LSB meaning index 31 to index 0\\n      for (int i = 31; i >= 0; i--) {\\n        if ((num >> i) & 1) { // bit in position i is a 1. Add to Trie if missing and move that way\\n          if (!ptr->one_bit) {\\n            ptr->one_bit = new Node();\\n          }\\n          ptr = ptr->one_bit;\\n        } else { // bit in position i is a 0. Add to Trie if missing and move that way\\n          if (!ptr->zero_bit) {\\n            ptr->zero_bit = new Node();\\n          }\\n          ptr = ptr->zero_bit;\\n        }\\n      }\\n    }\\n  \\n    // For the input number, for each bit, search the Trie bits that yield the most\\n    // bit-wise XOR as 1. Based on the rule of XOR:\\n    // 0 XOR 1 = 1\\n    // 1 XOR 0 = 1\\n    // Effectively it means, for the given bit, take the opposite child\\n    // If you couldn\\'t take the child you wanted, the bit-wise XOR result is 0, so continue\\n    // If you can take the child you want, then bit-wise XOR result is 1, so |= (1 << i) into a temp result.\\n\\t// (pow(2,i) does the same but keeps things as int rather than bit-manipulations).\\n\\t// This is to keep track of the output bit-wise XOR as you visit each child.\\n    int getMaxXOR(const int& num) {\\n      Node* ptr = root;\\n      int temp = 0;\\n      for (int i = 31; i >= 0; i--) {\\n        if ((num >> i) & 1) {\\n          if (ptr->zero_bit) {\\n            temp += pow(2,i);\\n            ptr = ptr->zero_bit;\\n          } else {\\n            ptr = ptr->one_bit;\\n          }\\n        } else {\\n          if (ptr->one_bit) {\\n            temp += pow(2,i);\\n            ptr = ptr->one_bit;\\n          } else {\\n            ptr = ptr->zero_bit;\\n          }\\n        }\\n      }\\n      return temp;\\n    }\\n  \\n    int findMaximumXOR(vector<int>& nums) {\\n      for (const int &i : nums) {\\n        insert(i);\\n      }\\n      int max = 0;\\n      for (const int &i : nums) {\\n        int ret = getMaxXOR(i);\\n        if (ret > max) max = ret;\\n      }\\n      return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n      Node* zero_bit = nullptr;\\n      Node* one_bit = nullptr;\\n    };\\n    Node* root = new Node();\\n  \\n    // All Trie represent incremental pieces of a final value (chars -> string)\\n    // For an int, the incremental piece is a bit, so we will make Trie of bit-string\\n    // The Trie should always be accessed in chunks of 32 nodes (including root), so no concept\\n    // of intermediate versus final result (prefix vs word) is needed.\\n    void insert(const int& num) {\\n      Node* ptr = root;\\n      // Access all the bits MSB to LSB meaning index 31 to index 0\\n      for (int i = 31; i >= 0; i--) {\\n        if ((num >> i) & 1) { // bit in position i is a 1. Add to Trie if missing and move that way\\n          if (!ptr->one_bit) {\\n            ptr->one_bit = new Node();\\n          }\\n          ptr = ptr->one_bit;\\n        } else { // bit in position i is a 0. Add to Trie if missing and move that way\\n          if (!ptr->zero_bit) {\\n            ptr->zero_bit = new Node();\\n          }\\n          ptr = ptr->zero_bit;\\n        }\\n      }\\n    }\\n  \\n    // For the input number, for each bit, search the Trie bits that yield the most\\n    // bit-wise XOR as 1. Based on the rule of XOR:\\n    // 0 XOR 1 = 1\\n    // 1 XOR 0 = 1\\n    // Effectively it means, for the given bit, take the opposite child\\n    // If you couldn\\'t take the child you wanted, the bit-wise XOR result is 0, so continue\\n    // If you can take the child you want, then bit-wise XOR result is 1, so |= (1 << i) into a temp result.\\n\\t// (pow(2,i) does the same but keeps things as int rather than bit-manipulations).\\n\\t// This is to keep track of the output bit-wise XOR as you visit each child.\\n    int getMaxXOR(const int& num) {\\n      Node* ptr = root;\\n      int temp = 0;\\n      for (int i = 31; i >= 0; i--) {\\n        if ((num >> i) & 1) {\\n          if (ptr->zero_bit) {\\n            temp += pow(2,i);\\n            ptr = ptr->zero_bit;\\n          } else {\\n            ptr = ptr->one_bit;\\n          }\\n        } else {\\n          if (ptr->one_bit) {\\n            temp += pow(2,i);\\n            ptr = ptr->one_bit;\\n          } else {\\n            ptr = ptr->zero_bit;\\n          }\\n        }\\n      }\\n      return temp;\\n    }\\n  \\n    int findMaximumXOR(vector<int>& nums) {\\n      for (const int &i : nums) {\\n        insert(i);\\n      }\\n      int max = 0;\\n      for (const int &i : nums) {\\n        int ret = getMaxXOR(i);\\n        if (ret > max) max = ret;\\n      }\\n      return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723241,
                "title": "c-hashset-solution",
                "content": "```\\nI Looked for C++ hashmap/hashset solution but all i found was TRIE so posting a hashmap solution.\\nInspired by:tangx668\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans=0,mask=0;\\n        unordered_set<int>st;\\n        for(int i=31;i>=0;i--){\\n            mask|=(1<<i);\\n            int temp=ans|(1<<i);\\n            for (int j = 0; j < nums.size(); j++) {\\n                int num = nums[j] & mask;\\n                if (st.find(temp ^ num)!=st.end()) {\\n                    ans = temp;\\n                    break;\\n                }\\n                st.insert(num);\\n            }\\n            st.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nI Looked for C++ hashmap/hashset solution but all i found was TRIE so posting a hashmap solution.\\nInspired by:tangx668\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans=0,mask=0;\\n        unordered_set<int>st;\\n        for(int i=31;i>=0;i--){\\n            mask|=(1<<i);\\n            int temp=ans|(1<<i);\\n            for (int j = 0; j < nums.size(); j++) {\\n                int num = nums[j] & mask;\\n                if (st.find(temp ^ num)!=st.end()) {\\n                    ans = temp;\\n                    break;\\n                }\\n                st.insert(num);\\n            }\\n            st.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724641,
                "title": "best-c-solution-without-trie-solved-with-bit-manipulation-with-examples-masking-explained",
                "content": "```\\nQuestion : we need to find two elements which have maximum xor.\\nApproach : Now in ideal scenarios , what could be the two elements whose xor can produce maximum result? Its simple (for explanation i am just taking 3 bits): \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0   0    0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t1   1    1\\n\\t\\t\\t\\t\\t\\t\\tXOR\\t-------------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t1   1    1\\n\\nSo, as of now you realized that maximum possible answer will have all 1\\'s or in other terms the \\nmaximum possible answer will try to have 1\\'s in their extremes left.\\n\\nNow coming to the next part, we know that for maximum answer you should have all 1\\'s. So why\\nnot start picking up those answers which have 1 as their leftmost digit. For ex: 100 (i am taking\\n3 bits to explain the approach).\\nLets suppose we have following elements in the array : [2  3  5]\\nBinary representation : [ 0 1 0           0 1 1          1 0 1 ]\\nnow what i told you earlier , for maximum possible answer, we need 1 in the leftmost digit . So to get \\nthe leftmost digit as 1 , we need 0 at the leftmost position in one number and 1 at the leftmost\\nposition in another number. Correct? If no , check this :\\n  \\n\\t\\t\\t\\t0  x  x\\n\\t\\t\\t    1  x  x\\n\\t\\t\\t   --------\\n\\t\\t\\t    1  x  x     and this is what we need right? 1 at left most position !! Great !!\\n\\t\\t\\t   \\nso which numbers are sharing 0 and 1 at their leftmost position? 2 and 5. So at this moment \\nwe know that 2 and 5 will be our answer but in general, you might have more than two\\nnumbers satisfying this.\\nNow again to get the maximum possible answer, you need 1 at the second position from left. That is\\nyou need something like 1   1   x .\\nNow to get 1 at the second position , again you need combination of 0 and 1 at second position and \\nagain XORing it, will give 1.\\nWhat i am saying is --\\n                                         x   0   x\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x   1   x\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t --------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 1   1  x    notice the 2nd position\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\nIn a similar manner we will proceed for 3rd bit , looking for 0 and 1 at the 3rd position, getting \\n1 as a result as a 3rd bit.  So our ans will be 1  1  1.\\nIt seems easy right? but i have taken an easy example !!.\\nBear with me, we will go slowly , so that anyone can grasp the intution behind the approach.\\n\\nNow i told you that to get 1 at the first position, we need to look for 1st position in all the numbers\\nto pick up a 0 and 1 combo.\\n\\nNow how to do that? how to pick up the bits from left to right?\\nWe will use a MASK. Fancy word but not so fancy.\\nWhat is mask? mask is nothing but a combination of few bits which is generally use to check\\nwhich position of a binary representation of a number has 1.\\nLets take an example :   1   1   0   1 .  Now if we want to check if the left most bit is 1 or not, \\ni will AND this number with 1  0  0  0.\\n      1  1  0  1\\n\\t  1  0  0  0\\n\\t  ---------   performing AND\\n\\t  1  0  0  0   --> this says that we have 1 at the left most position\\nif we want to check if we have 1 at 2nd position, we can do  this:\\n  1  1  0  1\\n  0  1  0  0\\n  ---------\\n  0  1  0  0  ---> this says that 1 is present at the 2nd position\\n  \\nNote: this is one use case of MASK but it just a fancy name, we will use this to pick up the\\nprefix of the binary representation of numbers at each step.\\nso we will use the same concept in our approach,\\nNow we are done with the prequisites, here comes the main logic:\\ncreate a variable result=0\\nmask=0\\nPLEASE MAKE A NOTE I AM USING 3 BITS TO EXPLAIN APPROACH\\n1. first we will pick up the prefix of all the binary representation of numbers bit by bit from left to right\\n   what i said: \\n   if array is [ 2 ( 0  1  0)         3 (0  1  1)       4(1  0  0) ]\\n   in 1st iteration we will pick bits till 1st position:\\n   **0** 0 0 from 2\\n   **0** 0 0 from 3\\n   **1** 0 0 from 4\\n  in 2nd iteration we will pick bits till 2nd position:\\n  **0  1**  0 from 2\\n  **0  1** 0 from 3\\n  **1  0** 0 from 4\\n  in 3rd iteration we will pick bits till 3rd position\\n ** 0  1  0** from 2\\n ** 0  1  1** from 3\\n  **1  0  0** from 4\\n  and how do we do this ? by using mask\\n  ex: for 2                           010 AND 100->**0**00  1st iteration\\n                                      010  AND 110->**01**0     2nd iteration\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  010 AND 111 ->**010**    3rd iteration\\n\\tmask = mask | 1<<i  <-- this is the mask variable which we will use for ANDing. i means \\n\\tith position, you will understand it in the code, dont worry.\\nnow in each iteration, i will add these prefixes in a set data structure named as prefix_set.\\nafter this, we will create a variable lets say temp =result | (1<<i ) and i initially will be 2(why 2 coz\\nwe are dealing with 3 bits and i have to shift the 1 towards left to 2th position from right)\\n1<<2 means shifting the 1 to 2 places towards left\\n\\nnow for each element in the prefix_set where we have stored the prefixes, we will pick up that prefix and\\nwill XOR with temp and then we will look if the result of this XOR is present in the prefix set or not.\\nwhat i said is depicted in the following code:\\n\\n\\t\\tfor(int prefix: prefix_set){    //picking up the prefix\\n\\t\\t\\tif(prefix_set.count(temp ^ prefix )){     // checking if the XOR exists in the prefix_set\\n\\t\\t\\t\\tresult=temp;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\nWAIT WHAT ??? why are you XORing now and why are you searching the result of the XOR in the prefix_set?\\nThis doesnt make sense !!!!\\nBut it will. See,\\nlets dry run this thing  we have [2 3 4]\\nthe prefix till 1st position [000,000,100] and we are storing this in set.\\nprefix_set->[000,100]\\nNow temp is result | (1 << i ) , initially result is 0 and i is 2 so\\ntemp=0 | (1<<2)\\ntemp=100 (4)\\nnow what we are doing, we are picking the element from the prefix_set and XORing with temp\\n    0 0 0 XOR 1 0 0-->1 0 0   does this result exist in the prefix_set?Yes, then make our result as \\n\\tof now , equals to temp.\\n\\t\\n\\tWhy? temp variable says that i am the maximum possible thing as of now(1 0 0) and if XORing\\n\\twith the prefix (000) given you something (100) which is already present, then that says\\n\\tthat we have found one combo of 0 and 1 present in the array. Rings any bell? that combo thing? No?\\n\\tJust try to dry run on your own and you will get it.\\n\\t\\nlet me just make one more thing clear\\na^b=x where x is the maximum possible thing, this is our exact question\\nbut in above lines i am doing some thing like a ^ x and trying to look for b in the prefix_set.\\nIs this even correct?\\nYes, why ? see this->                       x=a^b\\n\\t\\t\\t\\t\\t\\t\\t\\t      \\t\\ta^x=a^a^b\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ta^x=0^b\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ta^x=b  and similar thing is what we are trying to do\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nso we are trying to XOR a with x and we are searching for b and this x is what temp is.\\n\\nNow its time for some code :\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int result=0;\\n        int mask=0;\\n        set<int>prefix_set;\\n        for(int i =30;i>=0;i--){\\n            mask|=1<<i;\\n            for(auto num:nums){\\n                prefix_set.insert(num&mask);\\n            }\\n            int temp=result | 1<<i;\\n            for(int prefix:prefix_set){\\n                if(prefix_set.count(temp^prefix)){\\n                    result=temp;\\n                    break;\\n                \\n                }\\n            }\\n            prefix_set.clear(); // why we are clearing set coz in 1st iteration it will store the \\n\\t\\t\\t//prefixes till 1st bit and for storing the prefixes till 2nd bit, we need to clear \\n\\t\\t\\t//the previous set content and similarly we will move further\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n```\\nI know this solution is very lengthy and lots of stuff and concepts are involved. In 1st go, if you are not able\\nto understand, i will suggest just dry run the code and you will get it.\\nAlso, you might have noticed that at each step, i am storing the prefixes (prefixes till 1st position, prefixes\\ntill 2nd position and so on)in a set, we can totally avoid this by using TRIE data structure.\\nI will cover this TRIE solution in another post. \\n\\nThanks a ton for bearing with me till the end . Apologies , if you feel lost somewhere while reading the post.\\nJust dry run the code and you will understand the need of finding prefixes and then searching their XOR in \\nthe prefix_set again. And yes, using TRIE makes this problem a lot easier !!\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nQuestion : we need to find two elements which have maximum xor.\\nApproach : Now in ideal scenarios , what could be the two elements whose xor can produce maximum result? Its simple (for explanation i am just taking 3 bits): \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0   0    0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t1   1    1\\n\\t\\t\\t\\t\\t\\t\\tXOR\\t-------------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t1   1    1\\n\\nSo, as of now you realized that maximum possible answer will have all 1\\'s or in other terms the \\nmaximum possible answer will try to have 1\\'s in their extremes left.\\n\\nNow coming to the next part, we know that for maximum answer you should have all 1\\'s. So why\\nnot start picking up those answers which have 1 as their leftmost digit. For ex: 100 (i am taking\\n3 bits to explain the approach).\\nLets suppose we have following elements in the array : [2  3  5]\\nBinary representation : [ 0 1 0           0 1 1          1 0 1 ]\\nnow what i told you earlier , for maximum possible answer, we need 1 in the leftmost digit . So to get \\nthe leftmost digit as 1 , we need 0 at the leftmost position in one number and 1 at the leftmost\\nposition in another number. Correct? If no , check this :\\n  \\n\\t\\t\\t\\t0  x  x\\n\\t\\t\\t    1  x  x\\n\\t\\t\\t   --------\\n\\t\\t\\t    1  x  x     and this is what we need right? 1 at left most position !! Great !!\\n\\t\\t\\t   \\nso which numbers are sharing 0 and 1 at their leftmost position? 2 and 5. So at this moment \\nwe know that 2 and 5 will be our answer but in general, you might have more than two\\nnumbers satisfying this.\\nNow again to get the maximum possible answer, you need 1 at the second position from left. That is\\nyou need something like 1   1   x .\\nNow to get 1 at the second position , again you need combination of 0 and 1 at second position and \\nagain XORing it, will give 1.\\nWhat i am saying is --\\n                                         x   0   x\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x   1   x\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t --------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 1   1  x    notice the 2nd position\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\nIn a similar manner we will proceed for 3rd bit , looking for 0 and 1 at the 3rd position, getting \\n1 as a result as a 3rd bit.  So our ans will be 1  1  1.\\nIt seems easy right? but i have taken an easy example !!.\\nBear with me, we will go slowly , so that anyone can grasp the intution behind the approach.\\n\\nNow i told you that to get 1 at the first position, we need to look for 1st position in all the numbers\\nto pick up a 0 and 1 combo.\\n\\nNow how to do that? how to pick up the bits from left to right?\\nWe will use a MASK. Fancy word but not so fancy.\\nWhat is mask? mask is nothing but a combination of few bits which is generally use to check\\nwhich position of a binary representation of a number has 1.\\nLets take an example :   1   1   0   1 .  Now if we want to check if the left most bit is 1 or not, \\ni will AND this number with 1  0  0  0.\\n      1  1  0  1\\n\\t  1  0  0  0\\n\\t  ---------   performing AND\\n\\t  1  0  0  0   --> this says that we have 1 at the left most position\\nif we want to check if we have 1 at 2nd position, we can do  this:\\n  1  1  0  1\\n  0  1  0  0\\n  ---------\\n  0  1  0  0  ---> this says that 1 is present at the 2nd position\\n  \\nNote: this is one use case of MASK but it just a fancy name, we will use this to pick up the\\nprefix of the binary representation of numbers at each step.\\nso we will use the same concept in our approach,\\nNow we are done with the prequisites, here comes the main logic:\\ncreate a variable result=0\\nmask=0\\nPLEASE MAKE A NOTE I AM USING 3 BITS TO EXPLAIN APPROACH\\n1. first we will pick up the prefix of all the binary representation of numbers bit by bit from left to right\\n   what i said: \\n   if array is [ 2 ( 0  1  0)         3 (0  1  1)       4(1  0  0) ]\\n   in 1st iteration we will pick bits till 1st position:\\n   **0** 0 0 from 2\\n   **0** 0 0 from 3\\n   **1** 0 0 from 4\\n  in 2nd iteration we will pick bits till 2nd position:\\n  **0  1**  0 from 2\\n  **0  1** 0 from 3\\n  **1  0** 0 from 4\\n  in 3rd iteration we will pick bits till 3rd position\\n ** 0  1  0** from 2\\n ** 0  1  1** from 3\\n  **1  0  0** from 4\\n  and how do we do this ? by using mask\\n  ex: for 2                           010 AND 100->**0**00  1st iteration\\n                                      010  AND 110->**01**0     2nd iteration\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  010 AND 111 ->**010**    3rd iteration\\n\\tmask = mask | 1<<i  <-- this is the mask variable which we will use for ANDing. i means \\n\\tith position, you will understand it in the code, dont worry.\\nnow in each iteration, i will add these prefixes in a set data structure named as prefix_set.\\nafter this, we will create a variable lets say temp =result | (1<<i ) and i initially will be 2(why 2 coz\\nwe are dealing with 3 bits and i have to shift the 1 towards left to 2th position from right)\\n1<<2 means shifting the 1 to 2 places towards left\\n\\nnow for each element in the prefix_set where we have stored the prefixes, we will pick up that prefix and\\nwill XOR with temp and then we will look if the result of this XOR is present in the prefix set or not.\\nwhat i said is depicted in the following code:\\n\\n\\t\\tfor(int prefix: prefix_set){    //picking up the prefix\\n\\t\\t\\tif(prefix_set.count(temp ^ prefix )){     // checking if the XOR exists in the prefix_set\\n\\t\\t\\t\\tresult=temp;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\nWAIT WHAT ??? why are you XORing now and why are you searching the result of the XOR in the prefix_set?\\nThis doesnt make sense !!!!\\nBut it will. See,\\nlets dry run this thing  we have [2 3 4]\\nthe prefix till 1st position [000,000,100] and we are storing this in set.\\nprefix_set->[000,100]\\nNow temp is result | (1 << i ) , initially result is 0 and i is 2 so\\ntemp=0 | (1<<2)\\ntemp=100 (4)\\nnow what we are doing, we are picking the element from the prefix_set and XORing with temp\\n    0 0 0 XOR 1 0 0-->1 0 0   does this result exist in the prefix_set?Yes, then make our result as \\n\\tof now , equals to temp.\\n\\t\\n\\tWhy? temp variable says that i am the maximum possible thing as of now(1 0 0) and if XORing\\n\\twith the prefix (000) given you something (100) which is already present, then that says\\n\\tthat we have found one combo of 0 and 1 present in the array. Rings any bell? that combo thing? No?\\n\\tJust try to dry run on your own and you will get it.\\n\\t\\nlet me just make one more thing clear\\na^b=x where x is the maximum possible thing, this is our exact question\\nbut in above lines i am doing some thing like a ^ x and trying to look for b in the prefix_set.\\nIs this even correct?\\nYes, why ? see this->                       x=a^b\\n\\t\\t\\t\\t\\t\\t\\t\\t      \\t\\ta^x=a^a^b\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ta^x=0^b\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ta^x=b  and similar thing is what we are trying to do\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nso we are trying to XOR a with x and we are searching for b and this x is what temp is.\\n\\nNow its time for some code :\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int result=0;\\n        int mask=0;\\n        set<int>prefix_set;\\n        for(int i =30;i>=0;i--){\\n            mask|=1<<i;\\n            for(auto num:nums){\\n                prefix_set.insert(num&mask);\\n            }\\n            int temp=result | 1<<i;\\n            for(int prefix:prefix_set){\\n                if(prefix_set.count(temp^prefix)){\\n                    result=temp;\\n                    break;\\n                \\n                }\\n            }\\n            prefix_set.clear(); // why we are clearing set coz in 1st iteration it will store the \\n\\t\\t\\t//prefixes till 1st bit and for storing the prefixes till 2nd bit, we need to clear \\n\\t\\t\\t//the previous set content and similarly we will move further\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722780,
                "title": "python-clean-and-documented-code",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        \"\"\"\\n        let ni and nj be the numbers such that xor between them produces maximum\\n        value among other pairs. let m be the max value.\\n\\n        m = ni ^ nj\\n        => m ^ nj = (ni ^ nj) ^ nj\\n        =>        = ni ^ (nj ^ nj) # xor is associative\\n        =>        = ni ^ 0\\n        =>        = ni\\n\\n        so, m ^ nj = ni\\n\\n        We note that m is 31-bit integer so we guess bits of m and and with each nj,\\n        we check if the combination of m and nj will produce ni.\\n\\n        So time complexity becomes O(32N) = O(N)\\n        :param nums:\\n        :return:\\n        \"\"\"\\n        m, mask = 0, 0\\n\\n        for i in range(32)[::-1]:\\n            mask |= 1 << i\\n            prefixes = {n & mask for n in nums}\\n\\n            tmp = m | (1 << i)\\n\\n            if any(prefix ^ tmp in prefixes for prefix in prefixes):\\n                m = tmp\\n\\n        return m\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        \"\"\"\\n        let ni and nj be the numbers such that xor between them produces maximum\\n        value among other pairs. let m be the max value.\\n\\n        m = ni ^ nj\\n        => m ^ nj = (ni ^ nj) ^ nj\\n        =>        = ni ^ (nj ^ nj) # xor is associative\\n        =>        = ni ^ 0\\n        =>        = ni\\n\\n        so, m ^ nj = ni\\n\\n        We note that m is 31-bit integer so we guess bits of m and and with each nj,\\n        we check if the combination of m and nj will produce ni.\\n\\n        So time complexity becomes O(32N) = O(N)\\n        :param nums:\\n        :return:\\n        \"\"\"\\n        m, mask = 0, 0\\n\\n        for i in range(32)[::-1]:\\n            mask |= 1 << i\\n            prefixes = {n & mask for n in nums}\\n\\n            tmp = m | (1 << i)\\n\\n            if any(prefix ^ tmp in prefixes for prefix in prefixes):\\n                m = tmp\\n\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849837,
                "title": "python-3-standard-trie-explanations",
                "content": "### Explanation\\n- Build a trie first\\n- For each number `num` in `nums`, try to find number which can generate maximum value with `num` using `XOR`\\n\\t- From left to right, take the reverse bit if possble, otherwise take the same bit, e.g.\\n\\t- say if the k th bit from left for `num` is `1`, then to make it maximum, we want to take a number whose k th bit is `0` (if possible); if not possible, we take same bit.\\n- Check comments for more detail\\n### Implementation\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()                        # children nodes\\n        self.val = 0                                  # end value \\n\\nclass Trie:\\n    def __init__(self, n):\\n        self.root = TrieNode()                        # root node\\n        self.n = n                                    # max length of all numbers\\n        \\n    def add_num(self, num):\\n        node = self.root \\n        for shift in range(self.n, -1, -1):           # only shift self.n bits \\n            val = 1 if num & (1 << shift) else 0      # verify bit from left to right \\n            if val not in node.children:\\n                node.children[val] = TrieNode()\\n            node = node.children[val]\\n        node.val = num\\n        \\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        max_len = len(bin(max(nums))) - 2             # get max length of all numbers\\' binary\\n        trie = Trie(max_len)\\n        for num in nums: trie.add_num(num)            # build trie\\n            \\n        ans = 0\\n        for num in nums:                              # for each num, find the number which can create max value with num using XOR\\n            node = trie.root \\n            for shift in range(max_len, -1, -1):\\n                val = 1 if num & (1 << shift) else 0  # verify bit from left to right\\n                node = node.children[1-val] if 1-val in node.children else node.children[val] # try opposite bit first, otherwise use same bit\\n            ans = max(ans, num ^ node.val)            # maintain maximum\\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()                        # children nodes\\n        self.val = 0                                  # end value \\n\\nclass Trie:\\n    def __init__(self, n):\\n        self.root = TrieNode()                        # root node\\n        self.n = n                                    # max length of all numbers\\n        \\n    def add_num(self, num):\\n        node = self.root \\n        for shift in range(self.n, -1, -1):           # only shift self.n bits \\n            val = 1 if num & (1 << shift) else 0      # verify bit from left to right \\n            if val not in node.children:\\n                node.children[val] = TrieNode()\\n            node = node.children[val]\\n        node.val = num\\n        \\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        max_len = len(bin(max(nums))) - 2             # get max length of all numbers\\' binary\\n        trie = Trie(max_len)\\n        for num in nums: trie.add_num(num)            # build trie\\n            \\n        ans = 0\\n        for num in nums:                              # for each num, find the number which can create max value with num using XOR\\n            node = trie.root \\n            for shift in range(max_len, -1, -1):\\n                val = 1 if num & (1 << shift) else 0  # verify bit from left to right\\n                node = node.children[1-val] if 1-val in node.children else node.children[val] # try opposite bit first, otherwise use same bit\\n            ans = max(ans, num ^ node.val)            # maintain maximum\\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 379258,
                "title": "python-o-n-trie-with-explanation",
                "content": "I found the other solutions in this discussion thread to be very confusing, so I\\'ll do my best to explain the solution.  I\\'ll skip the code implementing the trie because you can search the line.   Here\\'s what we want to do: \\n\\n1) Insert the binary representation of a number into the trie.  Here, we insert from most significant bit to least significant bit, meaning the first node in the trie is the MSB and so on..\\n\\n2) Everytime we insert a number (let\\'s call this number A), we want to traverse the trie a second time and go the opposite way as A\\'s binary representation as much as possible.  It\\'s important that our trie elements were entered from MSB to LSB because this will maximize the differences as we traverse down the tree.  \\n\\n3) Find the node that diverges most with A and then return the XOR of these two numbers so we can update the max XOR.\\n\\n\\n```\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word, val):\\n        curr = self.root\\n        for i in range(len(word)):\\n            bit = word[i]\\n            if bit not in curr.children:\\n                curr.children[bit] = TrieNode()\\n            curr = curr.children[bit]\\n        curr.isEnd = True\\n        curr.value = val\\n    \\n    def search(self, word, target):\\n        curr = self.root\\n        for i in range(len(word)):\\n            bit = word[i]\\n            \\n            if bit == \\'1\\' and curr.children.get(\\'0\\'):\\n                curr = curr.children[\\'0\\']\\n            elif bit == \\'0\\' and curr.children.get(\\'1\\'):\\n                curr = curr.children[\\'1\\']\\n            elif curr.children.get(bit):\\n                curr = curr.children[bit]\\n            else:\\n                break\\n                \\n        return target^curr.value\\n            \\n            \\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n        self.value = 0\\n    \\n\\nclass Solution(object):\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        self.trie = Trie()\\n        max_xor = -2**(32)\\n        \\n        for i in nums:\\n            binary_string = (bin(i)[2:]).zfill(31)\\n            self.trie.insert(binary_string, i)\\n            max_xor = max(max_xor, self.trie.search(binary_string, i))\\n        \\n        return max_xor\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word, val):\\n        curr = self.root\\n        for i in range(len(word)):\\n            bit = word[i]\\n            if bit not in curr.children:\\n                curr.children[bit] = TrieNode()\\n            curr = curr.children[bit]\\n        curr.isEnd = True\\n        curr.value = val\\n    \\n    def search(self, word, target):\\n        curr = self.root\\n        for i in range(len(word)):\\n            bit = word[i]\\n            \\n            if bit == \\'1\\' and curr.children.get(\\'0\\'):\\n                curr = curr.children[\\'0\\']\\n            elif bit == \\'0\\' and curr.children.get(\\'1\\'):\\n                curr = curr.children[\\'1\\']\\n            elif curr.children.get(bit):\\n                curr = curr.children[bit]\\n            else:\\n                break\\n                \\n        return target^curr.value\\n            \\n            \\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n        self.value = 0\\n    \\n\\nclass Solution(object):\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        self.trie = Trie()\\n        max_xor = -2**(32)\\n        \\n        for i in nums:\\n            binary_string = (bin(i)[2:]).zfill(31)\\n            self.trie.insert(binary_string, i)\\n            max_xor = max(max_xor, self.trie.search(binary_string, i))\\n        \\n        return max_xor\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012860,
                "title": "java-trie-binary-tree-bit-manipulation",
                "content": "```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode left, right;\\n        public TrieNode() {\\n            left = null;\\n            right = null;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        \\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num>>i) & 1;\\n            if(bit == 0) {\\n                if(curr.left == null) {\\n                    curr.left = new TrieNode();\\n                }\\n                curr = curr.left;\\n            } else {\\n                if(curr.right == null) {\\n                    curr.right = new TrieNode(); \\n                }\\n                curr = curr.right;\\n            }\\n        }\\n    }\\n    \\n    public int getMaxXor(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        int maxXor = 0;\\n        \\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num>>i) & 1;\\n            if(bit == 0) {\\n                if(curr.right != null) {\\n                    curr =  curr.right;\\n                    maxXor += (1<<i);\\n                } else {\\n                    curr = curr.left;\\n                }\\n            } else {\\n                if(curr.left != null) {\\n                    curr = curr.left;\\n                    maxXor += (1<<i);   //pow(2,i)\\n                } else {\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        \\n        return maxXor;\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        TrieNode root = new TrieNode();\\n        int maxXor = Integer.MIN_VALUE;\\n        \\n        for(int num: nums) {\\n            insert(root, num);\\n        }\\n        \\n        for(int num: nums) {\\n            maxXor = Math.max(maxXor, getMaxXor(root, num));\\n        }\\n        \\n        return maxXor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Trie",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode left, right;\\n        public TrieNode() {\\n            left = null;\\n            right = null;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        \\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num>>i) & 1;\\n            if(bit == 0) {\\n                if(curr.left == null) {\\n                    curr.left = new TrieNode();\\n                }\\n                curr = curr.left;\\n            } else {\\n                if(curr.right == null) {\\n                    curr.right = new TrieNode(); \\n                }\\n                curr = curr.right;\\n            }\\n        }\\n    }\\n    \\n    public int getMaxXor(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        int maxXor = 0;\\n        \\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num>>i) & 1;\\n            if(bit == 0) {\\n                if(curr.right != null) {\\n                    curr =  curr.right;\\n                    maxXor += (1<<i);\\n                } else {\\n                    curr = curr.left;\\n                }\\n            } else {\\n                if(curr.left != null) {\\n                    curr = curr.left;\\n                    maxXor += (1<<i);   //pow(2,i)\\n                } else {\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        \\n        return maxXor;\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        TrieNode root = new TrieNode();\\n        int maxXor = Integer.MIN_VALUE;\\n        \\n        for(int num: nums) {\\n            insert(root, num);\\n        }\\n        \\n        for(int num: nums) {\\n            maxXor = Math.max(maxXor, getMaxXor(root, num));\\n        }\\n        \\n        return maxXor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849784,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass TrieNode{\\n    int val;\\n    TrieNode* binary[2];\\n    \\n  public:\\n    \\n    TrieNode()\\n    {\\n        binary[0] = binary[1] = NULL;\\n        \\n    }\\n    \\n    ~TrieNode()\\n    {\\n        if(binary[0])\\n            delete(binary[0]);\\n        if(binary[1])\\n            delete(binary[1]);\\n    }\\n    \\n    void insert(int n)\\n    {\\n        TrieNode* curr = this;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool bit = n & (1<<i);\\n            // cout<<bit<<endl;\\n            if(!(curr->binary[bit]))\\n                curr->binary[bit] = new TrieNode();\\n            curr = curr->binary[bit];                \\n        }\\n        curr->val = n;\\n    }\\n    \\n    int getOpposite(int n)\\n    {\\n        TrieNode* curr = this;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool bit = n & (1<<i);\\n            if(curr->binary[!bit])\\n                curr = curr->binary[!bit];\\n            else \\n                curr = curr->binary[bit];\\n        }\\n        return curr->val;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        TrieNode* root = new TrieNode();\\n        for(int n:nums)\\n            root->insert(n);\\n        int res=0;\\n        for(int n:nums)\\n            res = max(res,n^root->getOpposite(n));\\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    int val;\\n    TrieNode* binary[2];\\n    \\n  public:\\n    \\n    TrieNode()\\n    {\\n        binary[0] = binary[1] = NULL;\\n        \\n    }\\n    \\n    ~TrieNode()\\n    {\\n        if(binary[0])\\n            delete(binary[0]);\\n        if(binary[1])\\n            delete(binary[1]);\\n    }\\n    \\n    void insert(int n)\\n    {\\n        TrieNode* curr = this;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool bit = n & (1<<i);\\n            // cout<<bit<<endl;\\n            if(!(curr->binary[bit]))\\n                curr->binary[bit] = new TrieNode();\\n            curr = curr->binary[bit];                \\n        }\\n        curr->val = n;\\n    }\\n    \\n    int getOpposite(int n)\\n    {\\n        TrieNode* curr = this;\\n        for(int i=30;i>=0;i--)\\n        {\\n            bool bit = n & (1<<i);\\n            if(curr->binary[!bit])\\n                curr = curr->binary[!bit];\\n            else \\n                curr = curr->binary[bit];\\n        }\\n        return curr->val;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        TrieNode* root = new TrieNode();\\n        for(int n:nums)\\n            root->insert(n);\\n        int res=0;\\n        for(int n:nums)\\n            res = max(res,n^root->getOpposite(n));\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 140357,
                "title": "c-o-n-using-hash-table",
                "content": "Based on this solution: https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/91049/Java-O(n)-solution-using-bit-manipulation-and-HashMap\\n\\nI think this question looks like the most difficult question until you get to the right track. The idea is you try to find an answer based on possible candidates. I will try to briefly explain it using 8 bits instead of 32 bits. \\n\\nAssume that we have 8 bit ints. Our max result could be 11111111. To achieve this there must be two numbers when XORed their MSB should give 1.   \\n\\nSo our first mask is 1000000. (1 shifted all the way to the left). Since we are only checking the first digit we AND the nums with this mask and add to a hash table. Then for each number in our input we test if there\\'s a corresponding number that would give this. If there\\'s then our next candidate is 11000000, if not then our next candidate is 0100000.\\n\\nThe trick is that while we are using the hash table we search for \" candidate ^ *it \" if this exists then it means there is a \" nums[x] ^ *it \" that gives the candidate based on the XOR property A = B ^ C => A ^ C = B\\n\\nSo we iterate through all the possible candidates. The outer loop can start from 30 or 31.\\n\\n\\n```\\nint findMaximumXOR(vector<int>& nums) {\\n    \\n        int mask = 0;\\n        int result = 0;\\n        for (int i=30; i>=0; i--)\\n        {\\n            mask =  mask | (1 << i);\\n            unordered_set<int> myset;\\n            for (int i=0; i<nums.size(); i++)\\n            {\\n                myset.insert(nums[i] & mask);\\n            }\\n            \\n            int candidate = result | (1<<i);\\n            for (auto it=myset.begin(); it!=myset.end(); it++)\\n            {\\n                if (myset.count(candidate ^ *it))\\n                {\\n                    result = candidate;\\n                    break;\\n                }\\n            }            \\n        }\\n        \\n        return result;\\n    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findMaximumXOR(vector<int>& nums) {\\n    \\n        int mask = 0;\\n        int result = 0;\\n        for (int i=30; i>=0; i--)\\n        {\\n            mask =  mask | (1 << i);\\n            unordered_set<int> myset;\\n            for (int i=0; i<nums.size(); i++)\\n            {\\n                myset.insert(nums[i] & mask);\\n            }\\n            \\n            int candidate = result | (1<<i);\\n            for (auto it=myset.begin(); it!=myset.end(); it++)\\n            {\\n                if (myset.count(candidate ^ *it))\\n                {\\n                    result = candidate;\\n                    break;\\n                }\\n            }            \\n        }\\n        \\n        return result;\\n    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1723732,
                "title": "c-beginner-friendly-greedy-hashsets-solution-detail-explanation",
                "content": "For approching this problem we have to know xor\\'s property.\\nxor is 1 when two bits are diffrent\\n(`0^1 = 1 and 1^0 = 1`)\\nand we need maximum xor so we will greedely try to set all MSBs from left in our answer if possible.\\n\\nprefix variable in our solution will help us to get first i bits from nums\\n(prefix will grow like : `10000 -> 11000 -> 11100 -> 11110 -> 11111`)\\n\\nthen we are storing these prefix bits of nums in a hash set\\nn & prefix  will give us first i bits of nums\\nfor example if `n = 25 -> 11001 and prefix is 11100 `\\nso n & prefix will get us ->` 11000 `( first i bits of this number n which is 110)\\n\\nnow if we want to set ith bit of answer\\nlet say` c = ans | (1<<i)` (this is how we set ith bit of any number)\\nthen we have to check if there exits two number whose prefixs till i bits\\nwill give us xor value = c\\n, `a ^ b = c `\\nas we fixed c and when iterating in set we will fix one number `a` then\\n`b` will be` a ^ c` , { as `a^b = c` then `a^c = b` }\\njust like two sum if we got a, does b exist which give us c\\nso we have to check do b exists in our set\\nif yes our ans will have this ith bit = 1, thus `ans = c`\\nelse answer will remain same as this bit will 0 otherwise\\n\\n**Below is c++ code :**\\n```\\n\\tint findMaximumXOR(vector<int>& nums) {\\n         int ans = 0,prefix = 0;\\n         // intially we have all bits 0 in our ans and prefix\\n         for(int i=31;i>=0;i--)\\n         {\\n             prefix = prefix | (1<<i);\\n\\t\\t\\t // prefix will have first i MSBs 1\\n\\t\\t\\t unordered_set<int> s;\\n\\t\\t\\t \\n             for(int n : nums) // get prefix of first ith bits\\n                 s.insert(n & prefix); // n& prefix will get us first i MSBs of number n\\n\\t\\t\\t\\t \\n             // now lets check can we get this bit  1 in our ans\\n             int c = ans | (1<<i);  // we setted ith MSB of our answer and stored it in c\\n             // now we have to check can we get this from nums and we stored first ith MSBs of nums in set\\n             // we want two nums a and b such that a ^ b = c\\n             // just like two sum if we got a, does b exist which give us c\\n             // and we know a^b = c then b = a^c so we will check in set does b exits for given a to achive c\\n             for(int a : s)\\n             {\\n                 int b = c^a;\\n                 if(s.find(b) != s.end()) // if b exists\\n                 {\\n                     // our answer will have this bit set\\n                     // so answer now\\n                     ans = c;\\n                     break;\\n                 }\\n             }\\n\\t\\t\\t // if we cant get pairs a and b such a^b = c then this bit will remain unsetted (0)\\n         }\\n        return ans; // this is max xor we can get by two pair in nums\\n    }\\n```\\n\\n\\nDry run for first testcase :\\n`nums = [3,10,5,25,2,8]`\\nin binary : \\n```\\nnums = [00011 , 01010 , 00101 , 11001 , 00010 , 01000]\\n```\\n\\nour `prefix = 00000 and answer = 00000` intially\\n\\nfor First MSB, i = 4  : \\n\\t\\tprefix = 10000;\\n\\t\\tfor n ->\\n```\\n\\t\\tn = 3 =   00011 so ( n & prefix ) = 00000\\n\\t\\tn = 10 =  01010 so ( n & prefix ) = 00000\\n\\t\\tn = 5 =   00101 so ( n & prefix ) = 00000\\n\\t\\tn = 25 =  11001 so ( n & prefix ) = 10000\\n\\t\\tn = 2 =   00010 so ( n & prefix ) = 00000\\n\\t\\tn = 8 =   01000 so ( n & prefix ) = 00000\\n```\\n\\t\\t\\n```\\n\\t\\t\\t\\t//so set\\n\\t\\t\\t\\t\\t\\ts = [ 00000 , 00000 , 00000 , 10000 , 00000 , 00000 ]\\n\\n// ( prefix of  1 MSB of nums : 3        10       5      25    2      8       )\\n```\\nnow we want this bit of ans to be set\\n`so c = 00000 | (10000) = 10000` \\nwe have to check can we get c in set by two numbers a and b , a^b = c or for a given a do b exits such that b= a^c\\nfor a : s\\n`\\tb = 00000 ^ 10000 = 10000`\\n\\tdo b exist in set , yes so our `ans = c = 10000`\\n\\nnow for second MSB , i = 3 :\\nprefix = 11000\\n\\n```\\n\\t\\t\\t\\t//so set\\n\\t\\t\\t\\t\\t\\ts = [ 00000 , 01000 , 00000 , 11000 , 00000 , 01000 ]\\n\\n// ( prefix of first 2 MSB of nums : 3        10       5      25    2      8       )\\n```\\n\\ncan we set this bit of answer : \\nso` c = 11000`\\nso yes for `a = 00000` there exist `b = 11000` which will give `a^b = 11000`\\nso `ans = 11000 `now \\n\\nlike this we will check for all other bits greedly and check can we set it or not in answer\\n\\n\\n**Hope it helps to understand !**\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\n\\tint findMaximumXOR(vector<int>& nums) {\\n         int ans = 0,prefix = 0;\\n         // intially we have all bits 0 in our ans and prefix\\n         for(int i=31;i>=0;i--)\\n         {\\n             prefix = prefix | (1<<i);\\n\\t\\t\\t // prefix will have first i MSBs 1\\n\\t\\t\\t unordered_set<int> s;\\n\\t\\t\\t \\n             for(int n : nums) // get prefix of first ith bits\\n                 s.insert(n & prefix); // n& prefix will get us first i MSBs of number n\\n\\t\\t\\t\\t \\n             // now lets check can we get this bit  1 in our ans\\n             int c = ans | (1<<i);  // we setted ith MSB of our answer and stored it in c\\n             // now we have to check can we get this from nums and we stored first ith MSBs of nums in set\\n             // we want two nums a and b such that a ^ b = c\\n             // just like two sum if we got a, does b exist which give us c\\n             // and we know a^b = c then b = a^c so we will check in set does b exits for given a to achive c\\n             for(int a : s)\\n             {\\n                 int b = c^a;\\n                 if(s.find(b) != s.end()) // if b exists\\n                 {\\n                     // our answer will have this bit set\\n                     // so answer now\\n                     ans = c;\\n                     break;\\n                 }\\n             }\\n\\t\\t\\t // if we cant get pairs a and b such a^b = c then this bit will remain unsetted (0)\\n         }\\n        return ans; // this is max xor we can get by two pair in nums\\n    }\\n```\n```\\nnums = [00011 , 01010 , 00101 , 11001 , 00010 , 01000]\\n```\n```\\n\\t\\tn = 3 =   00011 so ( n & prefix ) = 00000\\n\\t\\tn = 10 =  01010 so ( n & prefix ) = 00000\\n\\t\\tn = 5 =   00101 so ( n & prefix ) = 00000\\n\\t\\tn = 25 =  11001 so ( n & prefix ) = 10000\\n\\t\\tn = 2 =   00010 so ( n & prefix ) = 00000\\n\\t\\tn = 8 =   01000 so ( n & prefix ) = 00000\\n```\n```\\n\\t\\t\\t\\t//so set\\n\\t\\t\\t\\t\\t\\ts = [ 00000 , 00000 , 00000 , 10000 , 00000 , 00000 ]\\n\\n// ( prefix of  1 MSB of nums : 3        10       5      25    2      8       )\\n```\n```\\n\\t\\t\\t\\t//so set\\n\\t\\t\\t\\t\\t\\ts = [ 00000 , 01000 , 00000 , 11000 , 00000 , 01000 ]\\n\\n// ( prefix of first 2 MSB of nums : 3        10       5      25    2      8       )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849679,
                "title": "a-few-solutions",
                "content": "**January 27<sup>th</sup>, 2022:**\\n\\n*Kotlin*\\n```\\ndata class Node(var m: MutableMap<Int, Node> = mutableMapOf<Int, Node>())\\nclass Solution {\\n    fun findMaximumXOR(A: IntArray): Int {\\n        var best = 0\\n        var m = Node()\\n        for (x in A) {\\n            var cand = 0\\n            var (cur, alt) = Pair(m, m)\\n            for (i in 31 downTo 0) {\\n                var p = if (x and (1 shl i) != 0) 1 else 0\\n                var q = p xor 1\\n                if (!cur.m.contains(p))\\n                    cur.m[p] = Node()\\n                cur = cur.m[p]!!\\n                if (alt.m.contains(q)) {\\n                    alt = alt.m[q]!!; cand = cand xor (1 shl i)\\n                } else {\\n                    alt = alt.m[p]!!\\n                }\\n            }\\n            best = Math.max(best, cand)\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findMaximumXOR = (A, m = new Map(), best = 0) => {\\n    for (let x of A) {\\n        let cand = 0;\\n        let cur = m,\\n            alt = m;\\n        for (let i = 31; 0 <= i; --i) {\\n            let p = x & (1 << i) ? 1 : 0,\\n                q = p ^ 1;\\n            if (!cur.has(p))\\n                cur.set(p, new Map());\\n            cur = cur.get(p);\\n            if (alt.has(q))\\n                alt = alt.get(q), cand ^= 1 << i;\\n            else\\n                alt = alt.get(p);\\n        }\\n        best = Math.max(best, cand);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findMaximumXOR(self, A: List[int], best = 0) -> int:\\n        m = {}\\n        for x in A:\\n            cand = 0\\n            cur, alt = m, m\\n            for i in range(31, -1, -1):\\n                p = 1 if x & (1 << i) else 0\\n                q = p ^ 1\\n                if p not in cur: cur[p] = {}\\n                cur = cur[p]\\n                if q in alt:\\n                    alt = alt[q]; cand ^= 1 << i\\n                else:\\n                    alt = alt[p]\\n            best = max(best, cand)\\n        return best\\n```\\n\\n*C++*\\n```\\nstruct Node;\\nusing NodePtr = shared_ptr<Node>;\\nstruct Node {\\n    using Map = unordered_map<int, NodePtr>;\\n    Map m;\\n};\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findMaximumXOR(VI& A, NodePtr root = make_shared<Node>(), int best = 0) {\\n        for (auto x: A) {\\n            auto cand = 0;\\n            auto cur = root,\\n                 alt = root;\\n            for (auto i{ 31 }; 0 <= i; --i) {\\n                auto p = x & (1 << i) ? 1 : 0,\\n                     q = p ^ 1;\\n                if (cur->m.find(p) == cur->m.end())\\n                    cur->m[p] = make_shared<Node>();\\n                cur = cur->m[p];\\n                if (alt->m.find(q) != alt->m.end())\\n                    alt = alt->m[q], cand ^= 1 << i;\\n                else\\n                    alt = alt->m[p];\\n            }\\n            best = max(best, cand);\\n        }\\n        return best;\\n    }\\n};\\n```\\n\\n---\\n\\n**September 17<sup>th</sup>, 2020:**\\n\\nCreate a `\\uD83C\\uDF32` trie from the binary representation of each value `x` in `A`.  Our goal is to find the maximum xor of two values in `A`, thus we construct the trie starting from the left-most bit of each value `x`, ie. the most significant bit which results in the largest value, because we want to `\\uD83D\\uDCB0` greedily diverge an alternative path `alt` from the current path `cur` as soon as possible and whenever possible to construct the maximal `xor` in O(N) time.\\n\\nLet `cur` be the current path of the trie insertions for `x` and let `alt` be a pre-existing alternative path of the trie which greedily diverges from `cur` at the most significant bit possible.  Thus, the logic for updating `cur` and `alt` per trie traversal starting at `root` is as follows:\\n\\n* **`\\uD83D\\uDC40` Current Path:** insert trie nodes as needed otherwise follow the pre-existing current path\\n* **`\\uD83E\\uDD14` Alternative Path:** greedily diverges from current path whenever possible to formulate the max `xor`, otherwise follow the pre-existing current path\\n\\n**Notes:**\\n* Upon each successful alternative path divergence, the ongoing best `xor`\\'s bit is set at that `i`<sup>th</sup> position\\n* I chose `p` and `q` to represent opposite bit values because these characters look \"opposite\" to me, ie. the \"hump\" in `p` \"points\" to-the-right `\\uD83D\\uDC49` whereas the \"hump\" in `q` \"points\" to-the-left `\\uD83D\\uDC48`\\n* This is probably one of the most difficult \"medium\" questions I\\'ve solved.  I solved this from scratch today (2020-09-16) as part of the September coding challenge, and it took me about an hour.  However, I previously solved this problem 3 years ago with help from [@jill-brocli\\'s solution here](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/91056/C%2B%2B-Trie-with-explanation), so I\\'ve added detailed notes from 3 years ago in the \"supplemental\" section at the very bottom.  I hope those additional details are helpful in case the description above doesn\\'t make sense\\uD83D\\uDC4D\\n\\n---\\n\\n*Javascript*\\n```\\nlet findMaximumXOR = (A, max = 0) => {\\n    let root = {};                                 // \\uD83C\\uDF32 trie\\n    for (let x of A) {\\n        let xor = 0;\\n        let cur = root,                            // \\uD83D\\uDC40 current path in trie for inserting binary representation of x\\n            alt = root;                            // \\uD83E\\uDD14 alternative path for pre-existing values in trie\\n        for (let i = 31; 0 <= i; --i) {\\n            let p = 0 < (x & (1 << i)) ? 1 : 0,    // \\uD83D\\uDE99 direction p and opposite \\uD83D\\uDE97 direction q\\n                q = p ^ 1;\\n            cur = cur[p] = cur[p] || {};           // \\uD83D\\uDE99 add direction p to \\uD83D\\uDC40 current path (as needed)\\n            if (alt[q])\\n                alt = alt[q], xor ^= (1 << i);     // \\uD83D\\uDE97 diff direction q for \\uD83E\\uDD14 alternative path (\\uD83D\\uDCB0 greedily take this path whenever possible)\\n            else\\n                alt = alt[p];                      // \\uD83D\\uDE99 same direction p for \\uD83E\\uDD14 alternative path\\n        }\\n        max = Math.max(max, xor);                  // \\uD83C\\uDFAF max xor\\n    }\\n    return max;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findMaximumXOR(self, A: List[int], best = 0) -> int:\\n        root = {}                                      # \\uD83C\\uDF32 trie\\n        for x in A:\\n            xor = 0\\n            cur = root                                 # \\uD83D\\uDC40 current path in trie for inserting binary representation of x\\n            alt = root                                 # \\uD83E\\uDD14 alternative path for pre-existing values in trie\\n            for i in range(31, -1, -1):\\n                p = 1 if 0 < (x & (1 << i)) else 0     # \\uD83D\\uDE99 direction p and opposite \\uD83D\\uDE97 direction q\\n                q = p ^ 1\\n                cur[p] = cur[p] if p in cur else {}    # \\uD83D\\uDE99 add direction p to \\uD83D\\uDC40 current path (as needed)\\n                cur = cur[p]\\n                if q in alt:                           # \\uD83D\\uDE97 diff direction q for \\uD83E\\uDD14 alternative path (\\uD83D\\uDCB0 greedily take this path whenever possible)\\n                    alt = alt[q]; xor ^= (1 << i)\\n                else:                                  # \\uD83D\\uDE99 same direction p for \\uD83E\\uDD14 alternative path\\n                    alt = alt[p]\\n            best = max(best, xor)                      # \\uD83C\\uDFAF max xor\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    struct Trie {\\n        unordered_map<int, shared_ptr<Trie>> m;\\n    };\\n    int findMaximumXOR(VI& A, int max = 0) {\\n        auto root = make_shared<Trie>();                 // \\uD83C\\uDF32 trie\\n        for (auto x: A) {\\n            auto _xor{ 0 };\\n            auto cur{ root },                            // \\uD83D\\uDC40 current path in trie for inserting binary representation of x\\n                 alt{ root };                            // \\uD83E\\uDD14 alternative path for pre-existing values in trie\\n            for (auto i{ 31 }; 0 <= i; --i) {\\n                auto p = 0 < (x & (1 << i)) ? 1 : 0,     // \\uD83D\\uDE99 direction p and opposite \\uD83D\\uDE97 direction q\\n                     q = p ^ 1;\\n                if (cur->m.find(p) == cur->m.end())      // \\uD83D\\uDE99 add direction p to \\uD83D\\uDC40 current path (as needed)\\n                    cur->m[p] = make_shared<Trie>();\\n                cur = cur->m[p];\\n                if (alt->m.find(q) != alt->m.end())      // \\uD83D\\uDE97 diff direction q for \\uD83E\\uDD14 alternative path (\\uD83D\\uDCB0 greedily take this path whenever possible)\\n                    alt = alt->m[q], _xor ^= (1 << i);\\n                else                                     // \\uD83D\\uDE99 same direction p for \\uD83E\\uDD14 alternative path\\n                    alt = alt->m[p];\\n            }\\n            max = std::max(max, _xor);                   // \\uD83C\\uDFAF max xor\\n        }\\n        return max;\\n    }\\n};\\n```\\n\\n---\\n\\n**Supplemental:** these are my notes from 3 years ago...\\n\\nhttps://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/91056/C%2B%2B-Trie-with-explanation\\n\\nHi @jill-brocli, thanks so much for sharing this easy to understand code!  I have written a solution in C++11 with inspiration from your solution.  For folks having a hard time ( like me ) understanding this problem and the various solutions, I found it helpful to step through the below code after changing the ```MAX_BIT_POS``` to 3 in order to ensure the proper max xor is calculated for small numbers less than 16.\\n\\n**Here\\'s how this solution works:**\\n\\nLet\\'s assume for simplicity that we have changed ```MAX_BIT_POS``` to 3, and that our vector contains the integers [ 6, 8, 10 ].\\n\\n```\\n   3210 (bit position)\\n 6=0110\\n 8=1000\\n10=1010\\n```\\nFirst, ```Generate``` a trie by iterating through each number and creating the trie representation of that number in binary format, beginning with the left-most bit.  Repeat for each number in the array, starting from the trie root for each number.  Redundant trie nodes are left \"as is\" and are simply traversed over.  New trie nodes are created when needed.\\n\\nExample iterations within the ```Generate``` function:\\n\\n\\n```\\nnum=6:\\n\\n6=0110\\n  3210 (bit position)\\n\\n             -----root-----\\n            /\\n          _0             <-- bit position 3\\n            \\\\\\n            _1           <-- bit position 2\\n              \\\\\\n              _1         <-- bit position 1\\n               /\\n             _0          <-- bit position 0\\n\\nnum=8:\\n\\n8=1000\\n  3210 (bit position)\\n\\n             -----root-----\\n            /              \\\\\\n          _0               _1    <-- bit position 3\\n            \\\\              /\\n            _1           _0      <-- bit position 2\\n              \\\\          /\\n              _1       _0        <-- bit position 1\\n              /        /\\n            _0       _0          <-- bit position 0\\n\\nnum=10:\\n\\n10=1010\\n   3210 (bit position)\\n\\n             -----root-----\\n            /              \\\\\\n          _0               _1    <-- bit position 3\\n            \\\\              /\\n            _1           _0      <-- bit position 2\\n              \\\\          / \\\\\\n              _1       _0  _1    <-- bit position 1\\n              /        /   /\\n            _0       _0  _0      <-- bit position 0\\n```\\n\\nSecond, this trie is traversed for each number to ```findMaximumXOR``` of each number when each number is maximally xor\\'ed against to ALL numbers\\' binary representations in the trie.  This is the act of analyzing each number.  Try to make the left-most bit a 1 in order to create the largest xor value possible.  Repeat from left-most bit to the right-most bit.  Each number is analyzed bit-by-bit while at the same time traversing the previously generated trie representation of ALL the numbers in binary format.  Each number\\'s bits are analyzed by beginning with the left-most bit and while simultaneously traversing the trie, starting at the root of the trie.  We are checking if the trie at each bit position contains an ```opposite``` value of each bit in the current number under analysis.  If so, then we know that the xor of two opposite bits is equal to 1, so we set current number\\'s maximum xor result ```x```\\'s bit for this current bit position ```x|=1```.  Each time this loop iterates, the next bit to the right is analyzed, so we shift the current number\\'s maximum xor result ```x``` left by one bit position in order to make room for the next bit\\'s analysis result ```x <<= 1```.  This bit shift left-by-one also ensures that the bit set in ```x``` corresponds to the proper bit position previously analyzed.  Once this loop is completed, ```x``` contains the maximum xor value for the current number under analysis compared to ALL other numbers.  Check if ```x``` is larger than any previously calculated maximum xors, and update ```maxXOR``` for each new max xor.\\n\\nThird, if this is still hard to understand, I\\'ve added a commented chunk of this code at the very end of this post.  Without further ado, here is the solution:\\n\\n```\\n#define MAX_BIT_POS 31\\n\\nclass Solution{\\npublic:\\n    int findMaximumXOR(vector<int>& nums){\\n        auto trie=make_shared<TrieNode>();\\n        return trie->findMaximumXOR(nums);\\n    }\\n    \\nprivate:\\n    class TrieNode{\\n    public:\\n        TrieNode() : _1{nullptr}, _0{nullptr} {}\\n        \\n        int findMaximumXOR(const vector<int>& nums){\\n            int maxXOR=0;\\n            auto root=Generate(nums);\\n            for (auto& num : nums){\\n                int x=0;\\n                auto curr=root;\\n                for (int i=MAX_BIT_POS; i>=0; --i){\\n                    x <<= 1;\\n                    bool opposite = !(num & (1<<i));\\n                    if (opposite){\\n                        if (curr->_1){ x|=1; curr=curr->_1; }\\n                        else {               curr=curr->_0; }\\n                    } else {\\n                        if (curr->_0){ x|=1; curr=curr->_0; }\\n                        else {               curr=curr->_1; }\\n                    }\\n                }\\n                maxXOR=max(maxXOR,x);\\n            }\\n            return maxXOR;\\n        }\\n        \\n    private:\\n        shared_ptr<TrieNode> _1;\\n        shared_ptr<TrieNode> _0;\\n        \\n        shared_ptr<TrieNode> Generate(const vector<int>& nums){\\n            auto root=make_shared<TrieNode>();\\n            for (auto& num : nums){\\n                auto curr=root;\\n                for (int i=MAX_BIT_POS; i>=0; --i){\\n                    if (num & (1<<i)){\\n                        if (!curr->_1){ curr->_1=make_shared<TrieNode>(); }\\n                        curr=curr->_1;\\n                    } else {\\n                        if (!curr->_0){ curr->_0=make_shared<TrieNode>(); }\\n                        curr=curr->_0;\\n                    }\\n                }\\n            }\\n            return root;\\n        }\\n    };\\n};\\n```\\n\\nI believe that the hardest to understand piece of of this code is the following.  I\\'ve added comments on top of this section of code to help with better understanding:\\n\\n```\\n//\\n// find the value of the current number\\'s current bit under analysis,\\n// and try to find the opposite value in the current trie node\\'s children\\n//\\nbool opposite = !(num & (1<<i));\\n\\n//\\n// opposite is 1\\n//\\nif (opposite){                            \\n\\n    //\\n    // opposite found in trie, set current number\\'s max xor (x\\'s) bit\\n    // for this bit position and traverse forward to this trie node\\n    //\\n    if (curr->_1){ x|=1; curr=curr->_1; } \\n\\n    //\\n    // opposite NOT found in trie, traverse the trie to the next trie node.\\n    // we know that the next trie node must be pointed towards through _0\\n    // since _1 does NOT exist (NOTE: the current number\\'s max xor\\n    // result for this bit is 0, since an opposite bit value was NOT found.\\n    // this can be explicitly coded as x|=0 before iterating forward in the trie\\n    // however, the current value of this bit position is already 0.  So this is unnecessary)\\n    //\\n    else {               curr=curr->_0; } \\n\\n//\\n// opposite is 0\\n//\\n} else {                                  \\n    \\n    //\\n    // opposite found in trie, set current number\\'s max xor (x\\'s) bit\\n    // for this bit position and traverse forward to this trie node\\n    //\\n    if (curr->_0){ x|=1; curr=curr->_0; } \\n\\n    //\\n    // opposite NOT found in trie, traverse the trie to the next trie node.\\n    // we know that the next trie node must be pointed towards through _1\\n    // since _0 does NOT exist (NOTE: the current number\\'s max xor\\n    // result for this bit is 0, since an opposite bit value was NOT found.\\n    // this can be explicitly coded as x|=0 before iterating forward in the trie\\n    // however, the current value of this bit position is already 0.  So this is unnecessary)\\n    //\\n    else {               curr=curr->_1; } \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndata class Node(var m: MutableMap<Int, Node> = mutableMapOf<Int, Node>())\\nclass Solution {\\n    fun findMaximumXOR(A: IntArray): Int {\\n        var best = 0\\n        var m = Node()\\n        for (x in A) {\\n            var cand = 0\\n            var (cur, alt) = Pair(m, m)\\n            for (i in 31 downTo 0) {\\n                var p = if (x and (1 shl i) != 0) 1 else 0\\n                var q = p xor 1\\n                if (!cur.m.contains(p))\\n                    cur.m[p] = Node()\\n                cur = cur.m[p]!!\\n                if (alt.m.contains(q)) {\\n                    alt = alt.m[q]!!; cand = cand xor (1 shl i)\\n                } else {\\n                    alt = alt.m[p]!!\\n                }\\n            }\\n            best = Math.max(best, cand)\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet findMaximumXOR = (A, m = new Map(), best = 0) => {\\n    for (let x of A) {\\n        let cand = 0;\\n        let cur = m,\\n            alt = m;\\n        for (let i = 31; 0 <= i; --i) {\\n            let p = x & (1 << i) ? 1 : 0,\\n                q = p ^ 1;\\n            if (!cur.has(p))\\n                cur.set(p, new Map());\\n            cur = cur.get(p);\\n            if (alt.has(q))\\n                alt = alt.get(q), cand ^= 1 << i;\\n            else\\n                alt = alt.get(p);\\n        }\\n        best = Math.max(best, cand);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def findMaximumXOR(self, A: List[int], best = 0) -> int:\\n        m = {}\\n        for x in A:\\n            cand = 0\\n            cur, alt = m, m\\n            for i in range(31, -1, -1):\\n                p = 1 if x & (1 << i) else 0\\n                q = p ^ 1\\n                if p not in cur: cur[p] = {}\\n                cur = cur[p]\\n                if q in alt:\\n                    alt = alt[q]; cand ^= 1 << i\\n                else:\\n                    alt = alt[p]\\n            best = max(best, cand)\\n        return best\\n```\n```\\nstruct Node;\\nusing NodePtr = shared_ptr<Node>;\\nstruct Node {\\n    using Map = unordered_map<int, NodePtr>;\\n    Map m;\\n};\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findMaximumXOR(VI& A, NodePtr root = make_shared<Node>(), int best = 0) {\\n        for (auto x: A) {\\n            auto cand = 0;\\n            auto cur = root,\\n                 alt = root;\\n            for (auto i{ 31 }; 0 <= i; --i) {\\n                auto p = x & (1 << i) ? 1 : 0,\\n                     q = p ^ 1;\\n                if (cur->m.find(p) == cur->m.end())\\n                    cur->m[p] = make_shared<Node>();\\n                cur = cur->m[p];\\n                if (alt->m.find(q) != alt->m.end())\\n                    alt = alt->m[q], cand ^= 1 << i;\\n                else\\n                    alt = alt->m[p];\\n            }\\n            best = max(best, cand);\\n        }\\n        return best;\\n    }\\n};\\n```\n```\\nlet findMaximumXOR = (A, max = 0) => {\\n    let root = {};                                 // \\uD83C\\uDF32 trie\\n    for (let x of A) {\\n        let xor = 0;\\n        let cur = root,                            // \\uD83D\\uDC40 current path in trie for inserting binary representation of x\\n            alt = root;                            // \\uD83E\\uDD14 alternative path for pre-existing values in trie\\n        for (let i = 31; 0 <= i; --i) {\\n            let p = 0 < (x & (1 << i)) ? 1 : 0,    // \\uD83D\\uDE99 direction p and opposite \\uD83D\\uDE97 direction q\\n                q = p ^ 1;\\n            cur = cur[p] = cur[p] || {};           // \\uD83D\\uDE99 add direction p to \\uD83D\\uDC40 current path (as needed)\\n            if (alt[q])\\n                alt = alt[q], xor ^= (1 << i);     // \\uD83D\\uDE97 diff direction q for \\uD83E\\uDD14 alternative path (\\uD83D\\uDCB0 greedily take this path whenever possible)\\n            else\\n                alt = alt[p];                      // \\uD83D\\uDE99 same direction p for \\uD83E\\uDD14 alternative path\\n        }\\n        max = Math.max(max, xor);                  // \\uD83C\\uDFAF max xor\\n    }\\n    return max;\\n};\\n```\n```\\nclass Solution:\\n    def findMaximumXOR(self, A: List[int], best = 0) -> int:\\n        root = {}                                      # \\uD83C\\uDF32 trie\\n        for x in A:\\n            xor = 0\\n            cur = root                                 # \\uD83D\\uDC40 current path in trie for inserting binary representation of x\\n            alt = root                                 # \\uD83E\\uDD14 alternative path for pre-existing values in trie\\n            for i in range(31, -1, -1):\\n                p = 1 if 0 < (x & (1 << i)) else 0     # \\uD83D\\uDE99 direction p and opposite \\uD83D\\uDE97 direction q\\n                q = p ^ 1\\n                cur[p] = cur[p] if p in cur else {}    # \\uD83D\\uDE99 add direction p to \\uD83D\\uDC40 current path (as needed)\\n                cur = cur[p]\\n                if q in alt:                           # \\uD83D\\uDE97 diff direction q for \\uD83E\\uDD14 alternative path (\\uD83D\\uDCB0 greedily take this path whenever possible)\\n                    alt = alt[q]; xor ^= (1 << i)\\n                else:                                  # \\uD83D\\uDE99 same direction p for \\uD83E\\uDD14 alternative path\\n                    alt = alt[p]\\n            best = max(best, xor)                      # \\uD83C\\uDFAF max xor\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    struct Trie {\\n        unordered_map<int, shared_ptr<Trie>> m;\\n    };\\n    int findMaximumXOR(VI& A, int max = 0) {\\n        auto root = make_shared<Trie>();                 // \\uD83C\\uDF32 trie\\n        for (auto x: A) {\\n            auto _xor{ 0 };\\n            auto cur{ root },                            // \\uD83D\\uDC40 current path in trie for inserting binary representation of x\\n                 alt{ root };                            // \\uD83E\\uDD14 alternative path for pre-existing values in trie\\n            for (auto i{ 31 }; 0 <= i; --i) {\\n                auto p = 0 < (x & (1 << i)) ? 1 : 0,     // \\uD83D\\uDE99 direction p and opposite \\uD83D\\uDE97 direction q\\n                     q = p ^ 1;\\n                if (cur->m.find(p) == cur->m.end())      // \\uD83D\\uDE99 add direction p to \\uD83D\\uDC40 current path (as needed)\\n                    cur->m[p] = make_shared<Trie>();\\n                cur = cur->m[p];\\n                if (alt->m.find(q) != alt->m.end())      // \\uD83D\\uDE97 diff direction q for \\uD83E\\uDD14 alternative path (\\uD83D\\uDCB0 greedily take this path whenever possible)\\n                    alt = alt->m[q], _xor ^= (1 << i);\\n                else                                     // \\uD83D\\uDE99 same direction p for \\uD83E\\uDD14 alternative path\\n                    alt = alt->m[p];\\n            }\\n            max = std::max(max, _xor);                   // \\uD83C\\uDFAF max xor\\n        }\\n        return max;\\n    }\\n};\\n```\n```MAX_BIT_POS```\n```MAX_BIT_POS```\n```\\n   3210 (bit position)\\n 6=0110\\n 8=1000\\n10=1010\\n```\n```Generate```\n```Generate```\n```\\nnum=6:\\n\\n6=0110\\n  3210 (bit position)\\n\\n             -----root-----\\n            /\\n          _0             <-- bit position 3\\n            \\\\\\n            _1           <-- bit position 2\\n              \\\\\\n              _1         <-- bit position 1\\n               /\\n             _0          <-- bit position 0\\n\\nnum=8:\\n\\n8=1000\\n  3210 (bit position)\\n\\n             -----root-----\\n            /              \\\\\\n          _0               _1    <-- bit position 3\\n            \\\\              /\\n            _1           _0      <-- bit position 2\\n              \\\\          /\\n              _1       _0        <-- bit position 1\\n              /        /\\n            _0       _0          <-- bit position 0\\n\\nnum=10:\\n\\n10=1010\\n   3210 (bit position)\\n\\n             -----root-----\\n            /              \\\\\\n          _0               _1    <-- bit position 3\\n            \\\\              /\\n            _1           _0      <-- bit position 2\\n              \\\\          / \\\\\\n              _1       _0  _1    <-- bit position 1\\n              /        /   /\\n            _0       _0  _0      <-- bit position 0\\n```\n```findMaximumXOR```\n```opposite```\n```x```\n```x|=1```\n```x```\n```x <<= 1```\n```x```\n```x```\n```x```\n```maxXOR```\n```\\n#define MAX_BIT_POS 31\\n\\nclass Solution{\\npublic:\\n    int findMaximumXOR(vector<int>& nums){\\n        auto trie=make_shared<TrieNode>();\\n        return trie->findMaximumXOR(nums);\\n    }\\n    \\nprivate:\\n    class TrieNode{\\n    public:\\n        TrieNode() : _1{nullptr}, _0{nullptr} {}\\n        \\n        int findMaximumXOR(const vector<int>& nums){\\n            int maxXOR=0;\\n            auto root=Generate(nums);\\n            for (auto& num : nums){\\n                int x=0;\\n                auto curr=root;\\n                for (int i=MAX_BIT_POS; i>=0; --i){\\n                    x <<= 1;\\n                    bool opposite = !(num & (1<<i));\\n                    if (opposite){\\n                        if (curr->_1){ x|=1; curr=curr->_1; }\\n                        else {               curr=curr->_0; }\\n                    } else {\\n                        if (curr->_0){ x|=1; curr=curr->_0; }\\n                        else {               curr=curr->_1; }\\n                    }\\n                }\\n                maxXOR=max(maxXOR,x);\\n            }\\n            return maxXOR;\\n        }\\n        \\n    private:\\n        shared_ptr<TrieNode> _1;\\n        shared_ptr<TrieNode> _0;\\n        \\n        shared_ptr<TrieNode> Generate(const vector<int>& nums){\\n            auto root=make_shared<TrieNode>();\\n            for (auto& num : nums){\\n                auto curr=root;\\n                for (int i=MAX_BIT_POS; i>=0; --i){\\n                    if (num & (1<<i)){\\n                        if (!curr->_1){ curr->_1=make_shared<TrieNode>(); }\\n                        curr=curr->_1;\\n                    } else {\\n                        if (!curr->_0){ curr->_0=make_shared<TrieNode>(); }\\n                        curr=curr->_0;\\n                    }\\n                }\\n            }\\n            return root;\\n        }\\n    };\\n};\\n```\n```\\n//\\n// find the value of the current number\\'s current bit under analysis,\\n// and try to find the opposite value in the current trie node\\'s children\\n//\\nbool opposite = !(num & (1<<i));\\n\\n//\\n// opposite is 1\\n//\\nif (opposite){                            \\n\\n    //\\n    // opposite found in trie, set current number\\'s max xor (x\\'s) bit\\n    // for this bit position and traverse forward to this trie node\\n    //\\n    if (curr->_1){ x|=1; curr=curr->_1; } \\n\\n    //\\n    // opposite NOT found in trie, traverse the trie to the next trie node.\\n    // we know that the next trie node must be pointed towards through _0\\n    // since _1 does NOT exist (NOTE: the current number\\'s max xor\\n    // result for this bit is 0, since an opposite bit value was NOT found.\\n    // this can be explicitly coded as x|=0 before iterating forward in the trie\\n    // however, the current value of this bit position is already 0.  So this is unnecessary)\\n    //\\n    else {               curr=curr->_0; } \\n\\n//\\n// opposite is 0\\n//\\n} else {                                  \\n    \\n    //\\n    // opposite found in trie, set current number\\'s max xor (x\\'s) bit\\n    // for this bit position and traverse forward to this trie node\\n    //\\n    if (curr->_0){ x|=1; curr=curr->_0; } \\n\\n    //\\n    // opposite NOT found in trie, traverse the trie to the next trie node.\\n    // we know that the next trie node must be pointed towards through _1\\n    // since _0 does NOT exist (NOTE: the current number\\'s max xor\\n    // result for this bit is 0, since an opposite bit value was NOT found.\\n    // this can be explicitly coded as x|=0 before iterating forward in the trie\\n    // however, the current value of this bit position is already 0.  So this is unnecessary)\\n    //\\n    else {               curr=curr->_1; } \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849540,
                "title": "python-solution-with-detail-comments",
                "content": "\\t# [3,  10,   5,   25,    2,   8]\\n    # [11, 110,  101, 11001, 10,  1000]\\n    \\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(31,-1,-1):\\n            prefixs = set([num>>i for num in nums])\\n            #to get the first i digits of the num. In the given example [3, 10, 5, 25, 2, 8], \\n            #since the largest number 25 is 11001 in binary, thus while i>=5, the prefix = {0}, ignoring all preceding \\'0\\'\\n            #prefix ={0,1} when i ==4, \\n            #prefix ={00,01,11} when i ==3, etc.\\n            \\n            ans <<=1 # 0 -> 00  1 ->10\\n            candidate = ans+1 # 0->01 1->11\\n            #so ans and candidate basically gives two options (0 or 1) on every new digit added\\n            #and candidate is the largest possible number given the length of the digit. It\\'s sort of a greedy algorithm here.\\n            #if previous ans == 1, then the new ans and candidate will be 10 and 11\\n            #depands on if we could get 1 on the new digit, we choose if we move forward with ans(10) or candidate(11)\\n            \\n            for pre in prefixs:\\n                if candidate ^ pre in prefixs:\\n                    ans = candidate\\n                    break\\n            # the if condition pre^candidate in prefix is based on the fact a^b^a = b\\n            # assume a, b in prefix could generate the largest possilbe xor resuglt \"candidate\". then if we use candidate^a, the result will be b\\n            # so if we do find pre^candidate in prefix, candidate will move forward(ans = candidate), meaning we get 1 in the new digit\\n            \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "\\t# [3,  10,   5,   25,    2,   8]\\n    # [11, 110,  101, 11001, 10,  1000]\\n    \\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(31,-1,-1):\\n            prefixs = set([num>>i for num in nums])\\n            #to get the first i digits of the num. In the given example [3, 10, 5, 25, 2, 8], \\n            #since the largest number 25 is 11001 in binary, thus while i>=5, the prefix = {0}, ignoring all preceding \\'0\\'\\n            #prefix ={0,1} when i ==4, \\n            #prefix ={00,01,11} when i ==3, etc.\\n            \\n            ans <<=1 # 0 -> 00  1 ->10\\n            candidate = ans+1 # 0->01 1->11\\n            #so ans and candidate basically gives two options (0 or 1) on every new digit added\\n            #and candidate is the largest possible number given the length of the digit. It\\'s sort of a greedy algorithm here.\\n            #if previous ans == 1, then the new ans and candidate will be 10 and 11\\n            #depands on if we could get 1 on the new digit, we choose if we move forward with ans(10) or candidate(11)\\n            \\n            for pre in prefixs:\\n                if candidate ^ pre in prefixs:\\n                    ans = candidate\\n                    break\\n            # the if condition pre^candidate in prefix is based on the fact a^b^a = b\\n            # assume a, b in prefix could generate the largest possilbe xor resuglt \"candidate\". then if we use candidate^a, the result will be b\\n            # so if we do find pre^candidate in prefix, candidate will move forward(ans = candidate), meaning we get 1 in the new digit\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1723020,
                "title": "c-simple-math-15-line-solution",
                "content": "```\\n// Solution is simple but the problem is we can\\'t travel whole \\'j\\' for a particular \\'i\\'.\\n// So whyn\\'t make some condition so than we already know after this, optimal answer will not exist.\\n\\n//Algo :\\n//Step 1 : Sort the array in decreasing order so that larger number comes first. \\n//Step 2 : Think if we make all bits of nums[i] to 1 and still our answer is already greater than this one, \\n//then there is no need to run further as other elements are smaller than current one!!!! \\n\\n//i.e. for nums[i] = 10, if we make all the bits to 1 then it will be 15(1010 --> 1111) and if we already has a answer  greater than 15, \\n//then there is not need to run further  and stop the algo at that time.\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int n = nums.size();\\n        int ans=0;\\n        for(int i=0; i<n and ans<pow(2,floor(log2(nums[i])+1))-1; i++){\\n            for(int j=i; j<n; j++){\\n                ans = max(ans, nums[i]^nums[j]);\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n// Solution is simple but the problem is we can\\'t travel whole \\'j\\' for a particular \\'i\\'.\\n// So whyn\\'t make some condition so than we already know after this, optimal answer will not exist.\\n\\n//Algo :\\n//Step 1 : Sort the array in decreasing order so that larger number comes first. \\n//Step 2 : Think if we make all bits of nums[i] to 1 and still our answer is already greater than this one, \\n//then there is no need to run further as other elements are smaller than current one!!!! \\n\\n//i.e. for nums[i] = 10, if we make all the bits to 1 then it will be 15(1010 --> 1111) and if we already has a answer  greater than 15, \\n//then there is not need to run further  and stop the algo at that time.\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int n = nums.size();\\n        int ans=0;\\n        for(int i=0; i<n and ans<pow(2,floor(log2(nums[i])+1))-1; i++){\\n            for(int j=i; j<n; j++){\\n                ans = max(ans, nums[i]^nums[j]);\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722918,
                "title": "time-o-n-log-n-no-trie-yes-binary-search",
                "content": "### Thanks to @DammitWA, it turns out that this solution does not  work and luckily passes all test cases. Testcase that disproves this approach: [1,2,18]\\n\\n### Idea\\n\\nXOR of two numbers is maximized when one of the number is the bitwise flip of the other. \\nFor example, XOR of 5 (101) is maximum when the other number is 2 (010).\\nBased on this idea, we do binary-search of bitwise flip of each number.\\nSince there may not be the exact bitwise flip number, we find the closest numbers.\\nFor example, in `[3,10,5,25,2,8]`,\\nthe bitwise flip of 25 (11001) is 6 (110). \\nHowever, there is no 6 in the list. We try the closest numbers, which are 5 (101) and 8 (1000).\\n\\n### Corner Case\\n\\nThere is a corner case in this approach. \\nIf the bitwise length of numbers in the list are all equal, the closest number always becomes the minimum number in the list.\\nFor example, in `[4,5,6]`,\\nthe length of the numbers in their bit representations are same: 4=100, 5=101, 6=110.\\nSince the bitwise flip of each number is always smaller than 100, the closest number is always 4.\\nTo compromise this, we also try the number closest to `bitwise flip + the most significant bit`.\\nIn the example above, the most significant bit of numbers is 100; we add this to each bitwise flips of the numbers (11, 10, 1 -> 111, 110, 101).\\n\\n### Complexity\\n\\nTime: `O(n*log(n))`\\nSpace: `O(n)`\\n\\n```typescript\\nfunction findMaximumXOR(nums: number[]): number {\\n    nums.sort((a, b) => a - b)\\n    let max = 0\\n    for (const num of nums) {\\n        const target = flip(num)\\n        const t1 = binarySearch(nums, target)\\n        max = Math.max(max, nums[t1] ^ num)\\n        if (1 <= t1) {\\n            max = Math.max(max, nums[t1-1] ^ num)            \\n        }\\n\\t\\tconst target2 = target + Math.pow(2, Math.floor(Math.log2(num)))\\n        const t2 = binarySearch(nums, target2)\\n        max = Math.max(max, nums[t2] ^ num)\\n        if (1 <= t2) {\\n            max = Math.max(max, nums[t2-1] ^ num)            \\n        }\\n    }\\n    return max\\n};\\n\\nfunction binarySearch(nums: number[], target: number) {\\n    let l=0\\n    let r=nums.length-1\\n    while (l < r) {\\n        const m = Math.floor((l+r) / 2)\\n        if (target <= nums[m]) {\\n            r = m\\n        } else {\\n            l = m+1\\n        }\\n    }\\n    return l\\n}\\n\\nfunction flip(num: number) {\\n    return parseInt(num.toString(2).split(\\'\\').map(b => b === \\'1\\' ? \\'0\\': \\'1\\').join(\\'\\'), 2)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Binary Tree"
                ],
                "code": "```typescript\\nfunction findMaximumXOR(nums: number[]): number {\\n    nums.sort((a, b) => a - b)\\n    let max = 0\\n    for (const num of nums) {\\n        const target = flip(num)\\n        const t1 = binarySearch(nums, target)\\n        max = Math.max(max, nums[t1] ^ num)\\n        if (1 <= t1) {\\n            max = Math.max(max, nums[t1-1] ^ num)            \\n        }\\n\\t\\tconst target2 = target + Math.pow(2, Math.floor(Math.log2(num)))\\n        const t2 = binarySearch(nums, target2)\\n        max = Math.max(max, nums[t2] ^ num)\\n        if (1 <= t2) {\\n            max = Math.max(max, nums[t2-1] ^ num)            \\n        }\\n    }\\n    return max\\n};\\n\\nfunction binarySearch(nums: number[], target: number) {\\n    let l=0\\n    let r=nums.length-1\\n    while (l < r) {\\n        const m = Math.floor((l+r) / 2)\\n        if (target <= nums[m]) {\\n            r = m\\n        } else {\\n            l = m+1\\n        }\\n    }\\n    return l\\n}\\n\\nfunction flip(num: number) {\\n    return parseInt(num.toString(2).split(\\'\\').map(b => b === \\'1\\' ? \\'0\\': \\'1\\').join(\\'\\'), 2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849775,
                "title": "python-simple-solution-beginners-video-code-trie",
                "content": "[](https://www.youtube.com/watch?v=wSgrc98d2lI)\\nhttps://www.youtube.com/watch?v=wSgrc98d2lI\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        \\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert_bits(self, num):\\n        bit_num = bin(num)[2:].zfill(32)\\n        node = self.root\\n        for bit in bit_num:\\n            if bit not in node.children:\\n                node.children[bit] = TrieNode()\\n            node = node.children[bit]\\n    \\n    \\n    def find_max_xor(self, num):\\n        bit_num = bin(num)[2:].zfill(32)\\n        node = self.root\\n        max_xor = \\'\\'\\n        for bit in bit_num:\\n            if bit == \\'0\\':\\n                oppo_bit = \\'1\\'\\n            elif bit == \\'1\\':\\n                oppo_bit = \\'0\\'\\n            \\n            if oppo_bit in node.children:\\n                max_xor += oppo_bit\\n                node = node.children[oppo_bit]\\n            else:\\n                max_xor += bit\\n                node = node.children[bit]\\n        \\n        return int(max_xor, 2) ^ num\\n    \\n    \\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        for num in nums:\\n            self.insert_bits(num)\\n        \\n        max_ = 0\\n        for num in nums:\\n            max_ = max(max_, self.find_max_xor(num))\\n            \\n        return max_\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        \\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert_bits(self, num):\\n        bit_num = bin(num)[2:].zfill(32)\\n        node = self.root\\n        for bit in bit_num:\\n            if bit not in node.children:\\n                node.children[bit] = TrieNode()\\n            node = node.children[bit]\\n    \\n    \\n    def find_max_xor(self, num):\\n        bit_num = bin(num)[2:].zfill(32)\\n        node = self.root\\n        max_xor = \\'\\'\\n        for bit in bit_num:\\n            if bit == \\'0\\':\\n                oppo_bit = \\'1\\'\\n            elif bit == \\'1\\':\\n                oppo_bit = \\'0\\'\\n            \\n            if oppo_bit in node.children:\\n                max_xor += oppo_bit\\n                node = node.children[oppo_bit]\\n            else:\\n                max_xor += bit\\n                node = node.children[bit]\\n        \\n        return int(max_xor, 2) ^ num\\n    \\n    \\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        for num in nums:\\n            self.insert_bits(num)\\n        \\n        max_ = 0\\n        for num in nums:\\n            max_ = max(max_, self.find_max_xor(num))\\n            \\n        return max_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407424,
                "title": "using-a-trie-accepted",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> Given a non-empty array of numbers, `a0, a1, a2, \\u2026 , an-1`, where `0 \\u2264 ai < 2^31`.\\n\\n> Find the maximum result of `ai` XOR `aj`, where `0 \\u2264 i`, `j < n`.\\n\\n**Example:** \\n\\n```java\\nInput: [3, 10, 5, 25, 2, 8]\\nOutput: 28\\nExplanation: The maximum result is 5 ^ 25 = 28.\\n\\nInput: [8,10,2]\\nOutput: 10\\n```\\n\\n**Follow up:** Could you do this in `O(n)` runtime?\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\n```java\\npublic int findMaximumXOR(int[] nums) {\\n  int n = nums.length;\\n  if (n == 1) return 0;\\n  int maxVal = Integer.MIN_VALUE;\\n  for (int i = 0; i < n - 1; ++i) {\\n    for (int j = i + 1; j < n; ++j) {\\n      maxVal = Math.max(maxVal, nums[i] ^ nums[j]);\\n    }\\n  }\\n  return maxVal;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Use Trie\\n\\nReference: [LeetCode Solution](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/)\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/5dhef.jpg)\\n\\nA good practice for using tries to solve problems. It took me a long time to write the code... but still learned some handy string manipulations too.\\n\\n```java\\n// trie\\nstatic final int R = 2;\\nclass TrieNode {\\n  TrieNode[] next;\\n  TrieNode() {\\n    next = new TrieNode[R];\\n  }\\n}\\n\\npublic int findMaximumXOR(int[] nums) {\\n  if (nums.length <= 1) return 0;\\n  int maxNum = getMax(nums);\\n  // 1000 8  log2(8)  = 3 --> 4\\n  // 1001 9  log2(9)  > 3 --> 4  ---> (int) log2(num) + 1 (equivalent to Math.floor)\\n  // 1111 15 log2(15) > 3 --> 4\\n  int maxLen = (int)(Math.log(maxNum) / Math.log(2)) + 1;\\n  String[] numsArr = getStringArray(nums, maxLen);\\n  TrieNode root = generateTrie(numsArr);\\n  return findTheOtherInTrie(root, nums, numsArr);\\n}\\n\\nprivate int getMax(int[] nums) {\\n  if (nums.length == 0) throw new IllegalArgumentException();\\n  int maxVal = nums[0];\\n  for (int val : nums) {\\n    maxVal = Math.max(maxVal, val);\\n  }\\n  return maxVal;\\n}\\n\\nprivate String[] getStringArray(int[] nums, int maxLen) {\\n  int n = nums.length;\\n  String[] result = new String[n];\\n  String format = \"%\" + maxLen + \"s\";\\n  for (int i = 0; i < n; ++i) {\\n    result[i] = getBinaryString(nums[i], format); \\n  }\\n  return result;\\n}\\n\\nprivate String getBinaryString(int num, String format) {\\n  // or use toString(?, 2)\\n  return String.format(format, Integer.toBinaryString(num)).replace(\\' \\', \\'0\\'); \\n}\\n\\nprivate TrieNode generateTrie(String[] numsArr) {\\n  TrieNode root = new TrieNode();\\n  for (String s : numsArr) { // for each string\\n    TrieNode p = root; // p must be here!!!!\\n    for (int i = 0; i < s.length(); ++i) {  // for each char\\n      int num = s.charAt(i) == \\'0\\' ? 0 : 1;\\n      if (p.next[num] == null) {\\n        p.next[num] = new TrieNode();\\n      }\\n      p = p.next[num];\\n    }\\n  }\\n  return root;\\n}\\n\\nprivate int findTheOtherInTrie(TrieNode root, int[] nums, String[] numsArr) {\\n  int n = nums.length;\\n  int maxXOR = Integer.MIN_VALUE;\\n  for (int i = 0; i < n; ++i) {\\n    String s = numsArr[i];\\n    StringBuilder sb = new StringBuilder();\\n    TrieNode maxP = root;\\n    TrieNode otherP = root;\\n    for (int j = 0; j < s.length(); ++j) {\\n      int num = s.charAt(j) == \\'0\\' ? 0 : 1;\\n      maxP = maxP.next[num];\\n      // try to go to the opposite if possible\\n      int direction = otherP.next[num ^ 1] != null ? (num ^ 1) : num;\\n      sb.append(direction);\\n      otherP = otherP.next[direction];\\n    }\\n    int otherNum = Integer.parseInt(sb.toString(), 2); // convert binary string to integer\\n    maxXOR = Math.max(maxXOR, nums[i] ^ otherNum);\\n  }\\n  return maxXOR;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```java\\nInput: [3, 10, 5, 25, 2, 8]\\nOutput: 28\\nExplanation: The maximum result is 5 ^ 25 = 28.\\n\\nInput: [8,10,2]\\nOutput: 10\\n```\n```java\\npublic int findMaximumXOR(int[] nums) {\\n  int n = nums.length;\\n  if (n == 1) return 0;\\n  int maxVal = Integer.MIN_VALUE;\\n  for (int i = 0; i < n - 1; ++i) {\\n    for (int j = i + 1; j < n; ++j) {\\n      maxVal = Math.max(maxVal, nums[i] ^ nums[j]);\\n    }\\n  }\\n  return maxVal;\\n}\\n```\n```java\\n// trie\\nstatic final int R = 2;\\nclass TrieNode {\\n  TrieNode[] next;\\n  TrieNode() {\\n    next = new TrieNode[R];\\n  }\\n}\\n\\npublic int findMaximumXOR(int[] nums) {\\n  if (nums.length <= 1) return 0;\\n  int maxNum = getMax(nums);\\n  // 1000 8  log2(8)  = 3 --> 4\\n  // 1001 9  log2(9)  > 3 --> 4  ---> (int) log2(num) + 1 (equivalent to Math.floor)\\n  // 1111 15 log2(15) > 3 --> 4\\n  int maxLen = (int)(Math.log(maxNum) / Math.log(2)) + 1;\\n  String[] numsArr = getStringArray(nums, maxLen);\\n  TrieNode root = generateTrie(numsArr);\\n  return findTheOtherInTrie(root, nums, numsArr);\\n}\\n\\nprivate int getMax(int[] nums) {\\n  if (nums.length == 0) throw new IllegalArgumentException();\\n  int maxVal = nums[0];\\n  for (int val : nums) {\\n    maxVal = Math.max(maxVal, val);\\n  }\\n  return maxVal;\\n}\\n\\nprivate String[] getStringArray(int[] nums, int maxLen) {\\n  int n = nums.length;\\n  String[] result = new String[n];\\n  String format = \"%\" + maxLen + \"s\";\\n  for (int i = 0; i < n; ++i) {\\n    result[i] = getBinaryString(nums[i], format); \\n  }\\n  return result;\\n}\\n\\nprivate String getBinaryString(int num, String format) {\\n  // or use toString(?, 2)\\n  return String.format(format, Integer.toBinaryString(num)).replace(\\' \\', \\'0\\'); \\n}\\n\\nprivate TrieNode generateTrie(String[] numsArr) {\\n  TrieNode root = new TrieNode();\\n  for (String s : numsArr) { // for each string\\n    TrieNode p = root; // p must be here!!!!\\n    for (int i = 0; i < s.length(); ++i) {  // for each char\\n      int num = s.charAt(i) == \\'0\\' ? 0 : 1;\\n      if (p.next[num] == null) {\\n        p.next[num] = new TrieNode();\\n      }\\n      p = p.next[num];\\n    }\\n  }\\n  return root;\\n}\\n\\nprivate int findTheOtherInTrie(TrieNode root, int[] nums, String[] numsArr) {\\n  int n = nums.length;\\n  int maxXOR = Integer.MIN_VALUE;\\n  for (int i = 0; i < n; ++i) {\\n    String s = numsArr[i];\\n    StringBuilder sb = new StringBuilder();\\n    TrieNode maxP = root;\\n    TrieNode otherP = root;\\n    for (int j = 0; j < s.length(); ++j) {\\n      int num = s.charAt(j) == \\'0\\' ? 0 : 1;\\n      maxP = maxP.next[num];\\n      // try to go to the opposite if possible\\n      int direction = otherP.next[num ^ 1] != null ? (num ^ 1) : num;\\n      sb.append(direction);\\n      otherP = otherP.next[direction];\\n    }\\n    int otherNum = Integer.parseInt(sb.toString(), 2); // convert binary string to integer\\n    maxXOR = Math.max(maxXOR, nums[i] ^ otherNum);\\n  }\\n  return maxXOR;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91065,
                "title": "a-solution-based-on-bartoszkp-s-with-missing-test-cases",
                "content": "Let's say we find the MSB that can be set to 1 in the result. Then we can partition the whole thing into two subsets. One element must be taken from one subset, the other from the other one. Then we move on to next bit that could possibly be set to one, but this time we're restricted to picking elements from different subsets generated at the first step. We do that by partitioning each subset in two subsets again based on the value of the next candidate bit, and we try to combine elements in such a way so that bit is set to one. There are two subsets now in each of the original subsets, so we try to combine elements in two ways based on that next bit: 1-0 and 0-1. The whole thing goes on recursively until we run out of bits, and then we just return the maximum, and everyone is happy. Or at least that's the idea.\\n\\nThis idea occurred to me when I was solving this problem at first, but I thought it would be too slow because I may get bad splits, so I switched to prefixes/sets instead. But then I saw [this solution](https://discuss.leetcode.com/topic/63759/c-o-nlogk-solution-with-ordering-bits-with-o-logk-additional-memory-for-recursion-stack) based on the same idea, which looked pretty impressive. During the discussion with the author we came to the conclusion that bad splits won't degrade runtime to O(n^2) because recursion depth is limited by the number of bits anyway.\\n\\nUnlike that solution, my original idea was to use a mask that indicates which bits could be possibly set. Say, if a certain bit is 1 in all numbers, or is 0 in all numbers, there is no way to get 1 in that position. That means we should only consider bits that are set in some numbers, but not in all of them. \\u201cSet in some\\u201d = OR, \\u201cset in all\\u201d = AND, \\u201dset in not all\\u201d = NOT AND, and therefore the mask for such bits is `or & ~and`.\\n\\nWhile I was at it, I realized that the original solution by @bartoszkp had a bug that wasn't detected by the OJ. It started with the MSB of the maximum element, but if that bit is set in all numbers, then the very first split will be wrong. The use of my mask incidentally fixed that too. A simple test case to demonstrate the problem: `[4, 6, 7]`.\\n\\nAnother interesting test case: `[8, 10, 2]`. The code below fails it if the two lines testing for `(mask & msb) == 0` in the helper function are commented out. That's because it tries to partition the array on the mask `4`, but that bit is cleared in all numbers. And yet, it passes the OJ too.\\n\\nNow here is one version of the code, that is *wrong* too. I'm posting it because it clearly demonstrates a flaw with this approach in general.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        auto orOp = [](int a, int b) { return a | b; };\\n        auto andOp = [](int a, int b) { return a & b; };\\n        mask = accumulate(nums.cbegin(), nums.cend(), 0, orOp)\\n            & ~accumulate(nums.cbegin(), nums.cend(), 0x7FFFFFFF, andOp);\\n        auto msb = computeMsb(mask);\\n        auto msbSplit = msbPartition(nums.begin(), nums.end(), msb);\\n        return findMaximumXor(nums.begin(), msbSplit, msbSplit, nums.end(), msb >> 1);\\n    }\\n    \\n    int computeMsb(int n) {\\n        auto msb = n;\\n        msb |= msb >> 1;\\n        msb |= msb >> 2;\\n        msb |= msb >> 4;\\n        msb |= msb >> 8;\\n        msb |= msb >> 16;\\n        return msb - (msb >> 1);\\n    }\\n    \\n    vector<int>::iterator msbPartition(const vector<int>::iterator &beginIt,\\n                                       const vector<int>::iterator &endIt,\\n                                       int msb) {\\n        auto msbSet = [msb](int n) { return (n & msb) != 0; };\\n        return partition(beginIt, endIt, msbSet);\\n    }\\n    \\n    int findMaximumXor(const vector<int>::iterator& beginLeft,\\n                       const vector<int>::iterator& endLeft,\\n                       const vector<int>::iterator& beginRight,\\n                       const vector<int>::iterator& endRight,\\n                       int msb) {\\n        if (distance(beginLeft, endLeft) == 1 && distance(beginRight, endRight) == 1)\\n            return *beginLeft ^ *beginRight;\\n        if (msb == 0 || beginLeft == endLeft || beginRight == endRight)\\n            return 0;\\n        if ((mask & msb) == 0)\\n            return findMaximumXor(beginLeft, endLeft, beginRight, endRight, msb >> 1);\\n        auto splitLeft = msbPartition(beginLeft, endLeft, msb);\\n        auto splitRight = msbPartition(beginRight, endRight, msb);\\n        auto result1 = findMaximumXor(beginLeft, splitLeft, splitRight, endRight, msb >> 1);\\n        auto result2 = findMaximumXor(splitLeft, endLeft, beginRight, splitRight, msb >> 1);\\n        return max(result1, result2);\\n    }\\n\\nprivate:\\n    int mask;\\n};\\n```\\nThe test case where it fails is `[14, 15, 9, 3, 2]` (not in the OJ either). It goes like this: first we split it like `14, 15, 9 / 3, 2`, then we split the left part as `14, 15 / 9`. And then, when we try to match `14, 15` with `3, 2` we get a problem. Even though the next candidate power of 2 is 1, we can't set it because `2` is set in all numbers now. And yet it wasn't set in all numbers to begin with, so our mask fails to skip it.\\n\\nThis flaw originally comes from the idea that we match subsets having different values of a certain bit. However, there is no guarantee that subsets even exist for that bit. Our mask only provides guarantee for the MSB, and later on it's just a hint. That means we need to check for that *again* after we partition. The fixed code is below, and I hope I got it right this time:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        auto orOp = [](int a, int b) { return a | b; };\\n        auto andOp = [](int a, int b) { return a & b; };\\n        mask = accumulate(nums.cbegin(), nums.cend(), 0, orOp)\\n            & ~accumulate(nums.cbegin(), nums.cend(), 0x7FFFFFFF, andOp);\\n        if (mask == 0)\\n            return 0;\\n        auto msb = computeMsb(mask);\\n        auto msbSplit = msbPartition(nums.begin(), nums.end(), msb);\\n        return findMaximumXor(nums.begin(), msbSplit, msbSplit, nums.end(), msb >> 1);\\n    }\\n    \\n    int computeMsb(int n) {\\n        auto msb = n;\\n        msb |= msb >> 1;\\n        msb |= msb >> 2;\\n        msb |= msb >> 4;\\n        msb |= msb >> 8;\\n        msb |= msb >> 16;\\n        return msb - (msb >> 1);\\n    }\\n    \\n    vector<int>::iterator msbPartition(const vector<int>::iterator &beginIt,\\n                                       const vector<int>::iterator &endIt,\\n                                       int msb) {\\n        auto msbSet = [msb](int n) { return (n & msb) != 0; };\\n        return partition(beginIt, endIt, msbSet);\\n    }\\n    \\n    int findMaximumXor(const vector<int>::iterator& beginLeft,\\n                       const vector<int>::iterator& endLeft,\\n                       const vector<int>::iterator& beginRight,\\n                       const vector<int>::iterator& endRight,\\n                       int msb) {\\n        if (msb == 0 || (distance(beginLeft, endLeft) == 1 && distance(beginRight, endRight) == 1))\\n            return *beginLeft ^ *beginRight;\\n        if ((mask & msb) == 0)\\n            return findMaximumXor(beginLeft, endLeft, beginRight, endRight, msb >> 1);\\n        auto splitLeft = msbPartition(beginLeft, endLeft, msb);\\n        auto splitRight = msbPartition(beginRight, endRight, msb);\\n        auto result = 0;\\n        if (distance(beginLeft, splitLeft) > 0 && distance(splitRight, endRight) > 0)\\n            result = findMaximumXor(beginLeft, splitLeft, splitRight, endRight, msb >> 1);\\n        if (distance(splitLeft, endLeft) > 0 && distance(beginRight, splitRight) > 0)\\n            result = max(result, findMaximumXor(splitLeft, endLeft, beginRight, splitRight, msb >> 1));\\n        if (result == 0) // no way to set this bit to 1\\n            result = findMaximumXor(beginLeft, endLeft, beginRight, endRight, msb >> 1);\\n        return result;\\n    }\\n\\nprivate:\\n    int mask;\\n};\\n```\\nIt runs for 26 ms, beating 99%.\\n\\nThe `result == 0` line executes when both `if`s above fail to run. That happens if we have bad splits on *both* sides, just like in the last mentioned test case.\\n\\nAnother last funny test case is `[15, 15, 9, 3, 2]`. The problem description doesn't say numbers can't be duplicated. Well, the code above passes it thanks to the `msb == 0` check in the beginning of the recursive function. It looks kind of funny because we just return a XOR of two randomly picked elements from both sides in that case without even checking how many elements are there. However, when we get to `msb == 0`, we have already split both sides based on every possible bit, so it's either that both subsets have size 1, or it's that they are all duplicates, and therefore picking first elements is just as fine.\\n\\nThe last, but not least, is the test case where all numbers are duplicate. That is checked by `mask == 0` in the top-level function. Funny thing, that test could be removed, but only because partitioning happens to use `(n & msb) != 0`. If I change it to `(n & msb) == 0` (which is OK in general), then we'll have a problem: the first MSB partitioning will generate an N/0 partition, which means `beginRight` will be `end()`, and we'll get UB by trying to dereference it. With `(n & msb) != 0` it generates an 0/N partitioning, so both `beginLeft` and `beginRight` point to the same element, and therefore eventually we return zero.\\n\\nRecap of the test cases to be added: `[4, 6, 7]`, `[8, 10, 2]`, `[14, 15, 9, 3, 2]`, `[15, 15, 9, 3, 2]`.",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        auto orOp = [](int a, int b) { return a | b; };\\n        auto andOp = [](int a, int b) { return a & b; };\\n        mask = accumulate(nums.cbegin(), nums.cend(), 0, orOp)\\n            & ~accumulate(nums.cbegin(), nums.cend(), 0x7FFFFFFF, andOp);\\n        auto msb = computeMsb(mask);\\n        auto msbSplit = msbPartition(nums.begin(), nums.end(), msb);\\n        return findMaximumXor(nums.begin(), msbSplit, msbSplit, nums.end(), msb >> 1);\\n    }\\n    \\n    int computeMsb(int n) {\\n        auto msb = n;\\n        msb |= msb >> 1;\\n        msb |= msb >> 2;\\n        msb |= msb >> 4;\\n        msb |= msb >> 8;\\n        msb |= msb >> 16;\\n        return msb - (msb >> 1);\\n    }\\n    \\n    vector<int>::iterator msbPartition(const vector<int>::iterator &beginIt,\\n                                       const vector<int>::iterator &endIt,\\n                                       int msb) {\\n        auto msbSet = [msb](int n) { return (n & msb) != 0; };\\n        return partition(beginIt, endIt, msbSet);\\n    }\\n    \\n    int findMaximumXor(const vector<int>::iterator& beginLeft,\\n                       const vector<int>::iterator& endLeft,\\n                       const vector<int>::iterator& beginRight,\\n                       const vector<int>::iterator& endRight,\\n                       int msb) {\\n        if (distance(beginLeft, endLeft) == 1 && distance(beginRight, endRight) == 1)\\n            return *beginLeft ^ *beginRight;\\n        if (msb == 0 || beginLeft == endLeft || beginRight == endRight)\\n            return 0;\\n        if ((mask & msb) == 0)\\n            return findMaximumXor(beginLeft, endLeft, beginRight, endRight, msb >> 1);\\n        auto splitLeft = msbPartition(beginLeft, endLeft, msb);\\n        auto splitRight = msbPartition(beginRight, endRight, msb);\\n        auto result1 = findMaximumXor(beginLeft, splitLeft, splitRight, endRight, msb >> 1);\\n        auto result2 = findMaximumXor(splitLeft, endLeft, beginRight, splitRight, msb >> 1);\\n        return max(result1, result2);\\n    }\\n\\nprivate:\\n    int mask;\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        auto orOp = [](int a, int b) { return a | b; };\\n        auto andOp = [](int a, int b) { return a & b; };\\n        mask = accumulate(nums.cbegin(), nums.cend(), 0, orOp)\\n            & ~accumulate(nums.cbegin(), nums.cend(), 0x7FFFFFFF, andOp);\\n        if (mask == 0)\\n            return 0;\\n        auto msb = computeMsb(mask);\\n        auto msbSplit = msbPartition(nums.begin(), nums.end(), msb);\\n        return findMaximumXor(nums.begin(), msbSplit, msbSplit, nums.end(), msb >> 1);\\n    }\\n    \\n    int computeMsb(int n) {\\n        auto msb = n;\\n        msb |= msb >> 1;\\n        msb |= msb >> 2;\\n        msb |= msb >> 4;\\n        msb |= msb >> 8;\\n        msb |= msb >> 16;\\n        return msb - (msb >> 1);\\n    }\\n    \\n    vector<int>::iterator msbPartition(const vector<int>::iterator &beginIt,\\n                                       const vector<int>::iterator &endIt,\\n                                       int msb) {\\n        auto msbSet = [msb](int n) { return (n & msb) != 0; };\\n        return partition(beginIt, endIt, msbSet);\\n    }\\n    \\n    int findMaximumXor(const vector<int>::iterator& beginLeft,\\n                       const vector<int>::iterator& endLeft,\\n                       const vector<int>::iterator& beginRight,\\n                       const vector<int>::iterator& endRight,\\n                       int msb) {\\n        if (msb == 0 || (distance(beginLeft, endLeft) == 1 && distance(beginRight, endRight) == 1))\\n            return *beginLeft ^ *beginRight;\\n        if ((mask & msb) == 0)\\n            return findMaximumXor(beginLeft, endLeft, beginRight, endRight, msb >> 1);\\n        auto splitLeft = msbPartition(beginLeft, endLeft, msb);\\n        auto splitRight = msbPartition(beginRight, endRight, msb);\\n        auto result = 0;\\n        if (distance(beginLeft, splitLeft) > 0 && distance(splitRight, endRight) > 0)\\n            result = findMaximumXor(beginLeft, splitLeft, splitRight, endRight, msb >> 1);\\n        if (distance(splitLeft, endLeft) > 0 && distance(beginRight, splitRight) > 0)\\n            result = max(result, findMaximumXor(splitLeft, endLeft, beginRight, splitRight, msb >> 1));\\n        if (result == 0) // no way to set this bit to 1\\n            result = findMaximumXor(beginLeft, endLeft, beginRight, endRight, msb >> 1);\\n        return result;\\n    }\\n\\nprivate:\\n    int mask;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386123,
                "title": "three-solutions-to-solve-this-problem-with-o-n-complexity",
                "content": "**1.  using bit manipulation and HashMap [beats 67%]**\\nThe xor operation has a good feature, a^b=c then c^a=b, c^b=a;\\nSince the range of num is 0<=num<2^31, the max xor value should have the first 1 as high as possible in binary representation.\\nSo we can find the max greedy.  \\nAssume the largest xor value(tmp) has 1 in ith position. [i from 31 to 0]\\nGenerate the prefix for all num in array, and store them in a set. Then we check all prefixes whether they can xor another prefix to get tmp. If we got the tmp, set the max = tmp. With a set we can get the answer with O(n) complexity\\nIn total, this algorithm has O(32n) = O(n) time complexity, and O(n) space complexity.\\n```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0, mask = 0;\\n        for(int i = 31; i >= 0; i--){\\n            mask = mask | (1 << i);\\n            Set<Integer> set = new HashSet<>();\\n            for(int num : nums){\\n                set.add(num & mask);\\n            }\\n            int tmp = max | (1 << i);\\n            for(int prefix : set){\\n                if(set.contains(tmp ^ prefix)) {\\n                    max = tmp;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n2.  build a trie tree and find max xor value for each number, then get the maximum XOR in this array [beats 93%]\\nWe can build a trie tree for this array with binary expression. The tree\\'s height is 32, left means 0, right means 1, the level of node means its index in num\\'s binary expression.\\nThen let evey num match the trie tree to get the maximum xor value. It\\'s also greedy. If we have 0 in ith subscript, if right node is not null, we match right node, so do the 1.\\nWe use a max variable to get the max xor value when traversing the num.\\nTime Complexity O(n)+O(32n) = O(n)\\n```\\nclass TrieNode {\\n    boolean is_leaf = false;\\n    TrieNode left;\\n    TrieNode right;\\n\\n    public TrieNode(boolean is_leaf, TrieNode left, TrieNode right) {\\n        this.is_leaf = is_leaf;\\n        this.left = left;\\n        this.right = right;\\n    }\\n\\n    public TrieNode() {\\n    }\\n\\n    public TrieNode(TrieNode left, TrieNode right) {\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n\\nclass Solution {\\n     public int findMaximumXOR(int[] nums) {\\n        TrieNode root = buildTrieTree(nums);\\n        int maxNum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int xorValue = 0;\\n            TrieNode cur = root;\\n            for (int j = 31; j >= 0; j--) {\\n                boolean flag = getBit(nums[i], j);\\n                // \\u5F53\\u524D\\u4E3A0\\uFF0C\\u770B\\u5F53\\u524D\\u8282\\u70B9\\u662F\\u5426\\u6709\\u4E3A1\\u7684\\u5B50\\u8282\\u70B9\\n                if (!flag) {\\n                    if (cur.right != null) {\\n                        xorValue += (1 << j);\\n                        cur = cur.right;\\n                    } else\\n                        cur = cur.left;\\n                }else {// \\u5F53\\u524D\\u4E3A1 \\uFF0C\\u5C3D\\u53EF\\u80FD\\u5339\\u914D\\u4E3A0\\u7684\\u5B50\\u8282\\u70B9\\n                    if (cur.left != null) {\\n                        xorValue += (1 << j);\\n                        cur = cur.left;\\n                    } else\\n                        cur = cur.right;\\n                }\\n            }\\n            maxNum = Math.max(xorValue, maxNum);\\n        }\\n        return maxNum;\\n    }\\n\\n    public TrieNode buildTrieTree(int[] nums) {\\n        TrieNode root = new TrieNode();\\n        for (int i = 0; i < nums.length; i++) {\\n            insert(root, nums[i]);\\n        }\\n        return root;\\n    }\\n\\n    public void insert(TrieNode root, int num) {\\n        for (int i = 31; i >= 0; i--) {\\n            if (!getBit(num, i)) {\\n                if (root.left == null)\\n                    root.left = new TrieNode();\\n                root = root.left;\\n            } else {\\n                if (root.right == null)\\n                    root.right = new TrieNode();\\n                root = root.right;\\n            }\\n        }\\n    }\\n\\n    private boolean getBit(int num, int i) {\\n        return (num & (1 << i)) != 0;\\n    }\\n}\\n```\\n3.  build a trie tree and find maximum xor value by recursing the tree [beats 99%]\\nSince we store every num in the trie tree. So there must be a way to get the max xor value in this trie tree.\\nFor each non-leaf node, it must have a subnode,whether left of right.\\nSo for current node left, right. if ll&&rr is not null or lr&&rl is not null, we greedy select this two subnode, get the max xor value of f(ll,rr) and f(lr,rl) . if not we select the max value of f(ll,rl)and f(lr,rr)  \\n[ll=left.left,lr=left.right,so do others...]\\nBuild the trie tree O(n), get max value O(1) by recursing the trie tree, So in total, time complexity is O(n)\\n```\\nclass TrieNode {\\n    boolean is_leaf = false;\\n    TrieNode left;\\n    TrieNode right;\\n\\n    public TrieNode(boolean is_leaf, TrieNode left, TrieNode right) {\\n        this.is_leaf = is_leaf;\\n        this.left = left;\\n        this.right = right;\\n    }\\n\\n    public TrieNode() {\\n    }\\n\\n    public TrieNode(TrieNode left, TrieNode right) {\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n\\nclass Solution {\\n     public int findMaximumXOR(int[] nums) {\\n        TrieNode root = buildTrieTree(nums);\\n        int level = 31;\\n        TrieNode cur = root;\\n        int ans = 0;\\n        while (cur != null && (cur.left == null || cur.right == null)) {\\n            cur = cur.left == null ? cur.right : cur.left;\\n            level--;\\n        }\\n         if(cur!=null){\\n              ans = (1 << level);\\n            ans += dfs(cur.left, cur.right, level);\\n             }\\n        return ans;\\n    }\\n    public int dfs(TrieNode left, TrieNode right, int level) {\\n        int max = 0;\\n        level--;\\n        TrieNode ll = left.left, lr = left.right, rl = right.left, rr = right.right;\\n        if (ll != null && rr != null || lr != null && rl != null) {\\n            max += (1 << level);\\n            int t1 = 0, t2 = 0;\\n            if (ll != null && rr != null)\\n                t1 = dfs(ll, rr, level);\\n            if (lr != null && rl != null)\\n                t2 = dfs(lr, rl, level);\\n            max = max + Math.max(t1, t2);\\n\\n        } else {\\n            int t1 = 0, t2 = 0;\\n            if (ll != null && rl != null)\\n                t1 = dfs(ll, rl, level);\\n            if (lr != null && rr != null)\\n                t2 = dfs(lr, rr, level);\\n            max = Math.max(t1, t2);\\n        }\\n        return max;\\n    }\\n\\n    public TrieNode buildTrieTree(int[] nums) {\\n        TrieNode root = new TrieNode();\\n        for (int i = 0; i < nums.length; i++) {\\n            insert(root, nums[i]);\\n        }\\n        return root;\\n    }\\n\\n    public void insert(TrieNode root, int num) {\\n        for (int i = 31; i >= 0; i--) {\\n            if (!getBit(num, i)) {\\n                if (root.left == null)\\n                    root.left = new TrieNode();\\n                root = root.left;\\n            } else {\\n                if (root.right == null)\\n                    root.right = new TrieNode();\\n                root = root.right;\\n            }\\n        }\\n    }\\n\\n    private boolean getBit(int num, int i) {\\n        return (num & (1 << i)) != 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0, mask = 0;\\n        for(int i = 31; i >= 0; i--){\\n            mask = mask | (1 << i);\\n            Set<Integer> set = new HashSet<>();\\n            for(int num : nums){\\n                set.add(num & mask);\\n            }\\n            int tmp = max | (1 << i);\\n            for(int prefix : set){\\n                if(set.contains(tmp ^ prefix)) {\\n                    max = tmp;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass TrieNode {\\n    boolean is_leaf = false;\\n    TrieNode left;\\n    TrieNode right;\\n\\n    public TrieNode(boolean is_leaf, TrieNode left, TrieNode right) {\\n        this.is_leaf = is_leaf;\\n        this.left = left;\\n        this.right = right;\\n    }\\n\\n    public TrieNode() {\\n    }\\n\\n    public TrieNode(TrieNode left, TrieNode right) {\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n\\nclass Solution {\\n     public int findMaximumXOR(int[] nums) {\\n        TrieNode root = buildTrieTree(nums);\\n        int maxNum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int xorValue = 0;\\n            TrieNode cur = root;\\n            for (int j = 31; j >= 0; j--) {\\n                boolean flag = getBit(nums[i], j);\\n                // \\u5F53\\u524D\\u4E3A0\\uFF0C\\u770B\\u5F53\\u524D\\u8282\\u70B9\\u662F\\u5426\\u6709\\u4E3A1\\u7684\\u5B50\\u8282\\u70B9\\n                if (!flag) {\\n                    if (cur.right != null) {\\n                        xorValue += (1 << j);\\n                        cur = cur.right;\\n                    } else\\n                        cur = cur.left;\\n                }else {// \\u5F53\\u524D\\u4E3A1 \\uFF0C\\u5C3D\\u53EF\\u80FD\\u5339\\u914D\\u4E3A0\\u7684\\u5B50\\u8282\\u70B9\\n                    if (cur.left != null) {\\n                        xorValue += (1 << j);\\n                        cur = cur.left;\\n                    } else\\n                        cur = cur.right;\\n                }\\n            }\\n            maxNum = Math.max(xorValue, maxNum);\\n        }\\n        return maxNum;\\n    }\\n\\n    public TrieNode buildTrieTree(int[] nums) {\\n        TrieNode root = new TrieNode();\\n        for (int i = 0; i < nums.length; i++) {\\n            insert(root, nums[i]);\\n        }\\n        return root;\\n    }\\n\\n    public void insert(TrieNode root, int num) {\\n        for (int i = 31; i >= 0; i--) {\\n            if (!getBit(num, i)) {\\n                if (root.left == null)\\n                    root.left = new TrieNode();\\n                root = root.left;\\n            } else {\\n                if (root.right == null)\\n                    root.right = new TrieNode();\\n                root = root.right;\\n            }\\n        }\\n    }\\n\\n    private boolean getBit(int num, int i) {\\n        return (num & (1 << i)) != 0;\\n    }\\n}\\n```\n```\\nclass TrieNode {\\n    boolean is_leaf = false;\\n    TrieNode left;\\n    TrieNode right;\\n\\n    public TrieNode(boolean is_leaf, TrieNode left, TrieNode right) {\\n        this.is_leaf = is_leaf;\\n        this.left = left;\\n        this.right = right;\\n    }\\n\\n    public TrieNode() {\\n    }\\n\\n    public TrieNode(TrieNode left, TrieNode right) {\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n\\nclass Solution {\\n     public int findMaximumXOR(int[] nums) {\\n        TrieNode root = buildTrieTree(nums);\\n        int level = 31;\\n        TrieNode cur = root;\\n        int ans = 0;\\n        while (cur != null && (cur.left == null || cur.right == null)) {\\n            cur = cur.left == null ? cur.right : cur.left;\\n            level--;\\n        }\\n         if(cur!=null){\\n              ans = (1 << level);\\n            ans += dfs(cur.left, cur.right, level);\\n             }\\n        return ans;\\n    }\\n    public int dfs(TrieNode left, TrieNode right, int level) {\\n        int max = 0;\\n        level--;\\n        TrieNode ll = left.left, lr = left.right, rl = right.left, rr = right.right;\\n        if (ll != null && rr != null || lr != null && rl != null) {\\n            max += (1 << level);\\n            int t1 = 0, t2 = 0;\\n            if (ll != null && rr != null)\\n                t1 = dfs(ll, rr, level);\\n            if (lr != null && rl != null)\\n                t2 = dfs(lr, rl, level);\\n            max = max + Math.max(t1, t2);\\n\\n        } else {\\n            int t1 = 0, t2 = 0;\\n            if (ll != null && rl != null)\\n                t1 = dfs(ll, rl, level);\\n            if (lr != null && rr != null)\\n                t2 = dfs(lr, rr, level);\\n            max = Math.max(t1, t2);\\n        }\\n        return max;\\n    }\\n\\n    public TrieNode buildTrieTree(int[] nums) {\\n        TrieNode root = new TrieNode();\\n        for (int i = 0; i < nums.length; i++) {\\n            insert(root, nums[i]);\\n        }\\n        return root;\\n    }\\n\\n    public void insert(TrieNode root, int num) {\\n        for (int i = 31; i >= 0; i--) {\\n            if (!getBit(num, i)) {\\n                if (root.left == null)\\n                    root.left = new TrieNode();\\n                root = root.left;\\n            } else {\\n                if (root.right == null)\\n                    root.right = new TrieNode();\\n                root = root.right;\\n            }\\n        }\\n    }\\n\\n    private boolean getBit(int num, int i) {\\n        return (num & (1 << i)) != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722890,
                "title": "python-easy-to-understand-trie-with-insert-and-search",
                "content": "**Apporach**\\nTo find out max `XOR` of any given two numbers in the array, essentially we need to\\n1. convert the number into binary format\\n2. for each bit, try to maximize the output of `XOR`, which is finding the opposite bit and calculate the max result\\n\\t* Think this as BFS, for each level, we compute a result and move to next level\\n3. do this every number in the array and return the max result\\n\\n\\n**Implementation**\\n1. Build a trie like you would do in all another trie problems\\n2. Add one more method `search` in the trie\\n\\t* `search` method here does one thing: for any given binary format string, it checks at the level, if there is an opposite bit that we could use to compute the XOR result.\\n\\n\\nOne small optimization:\\n* if you try to format every number in 32 bit format, it will Timeout for the last input. You do not need to `zfill` 32 bits, just find largest number in the array and use that length to do the format.\\n\\n\\n```\\n\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.val = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, binary):\\n        cur = self.root\\n        for char in binary:\\n            cur = cur.children[int(char)]\\n    \\n    def search(self, binary) -> int:\\n        result = 0\\n        cur = self.root\\n        for char in binary:\\n            opposite = 1 - int(char)\\n            if opposite in cur.children:\\n                result = (result << 1) | 1\\n                cur = cur.children[opposite]\\n            else:\\n                result = (result << 1)\\n                cur = cur.children[int(char)]\\n        return result\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        trie = Trie()\\n        result = float(\\'-inf\\')\\n        maxLen = len(bin(max(nums))[2:]) # format binary string in length of  max num\\n        for num in nums:\\n            key = bin(num)[2:].zfill(maxLen)\\n            trie.insert(key)\\n            result = max(result, trie.search(key))\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\n\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.val = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, binary):\\n        cur = self.root\\n        for char in binary:\\n            cur = cur.children[int(char)]\\n    \\n    def search(self, binary) -> int:\\n        result = 0\\n        cur = self.root\\n        for char in binary:\\n            opposite = 1 - int(char)\\n            if opposite in cur.children:\\n                result = (result << 1) | 1\\n                cur = cur.children[opposite]\\n            else:\\n                result = (result << 1)\\n                cur = cur.children[int(char)]\\n        return result\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        trie = Trie()\\n        result = float(\\'-inf\\')\\n        maxLen = len(bin(max(nums))[2:]) # format binary string in length of  max num\\n        for num in nums:\\n            key = bin(num)[2:].zfill(maxLen)\\n            trie.insert(key)\\n            result = max(result, trie.search(key))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170619,
                "title": "python-bit-manipulation-set",
                "content": "it took me forever to understand it, until I found #\\u5C71\\u666F\\u57CE\\u4E00\\u59D0 on youtube \\n\\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        sol = 0\\n        for i in reversed(range(32)):\\n            prefixs = set([x >> i for x in nums])\\n            sol <<= 1\\n            candidate = sol + 1\\n            for p in prefixs:\\n                if candidate ^ p in prefixs:\\n                    sol = candidate\\n                    break\\n        return sol\\n```\\n\\nwith note:\\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        sol = 0 \\n        for i in reversed(range(32)): # XOR from left, border=2^32\\n            prefixs = set([x >> i for x in nums]) # right shift (shrink) for i bits, keep left part\\n            sol <<= 1 # left shift (expand 0 on right) for each stage \\n            candidate = sol + 1 # expected value to find on set()\\n            for p in prefixs:\\n                if candidate ^ p in prefixs: # apply rule: a^b=c so a^c=b to search targets\\n                    sol = candidate # update the largest solution we could obtain in current stage\\n                    break\\n        return sol\\n```\\n\\n- Basic knowledge for this solution\\n    1. Decimal vs Binary:\\n\\n    [3,  10,   5,   25,    2,   8]\\n    [11, 110,  101, 11001, 10,  1000]\\n\\n    as 16, 8, 4, 2, 1 for either [1, 0]\\n\\n    2. Bitwise left shift:\\n\\n    ```\\n    d<<i\\n    1<<1 = 10\\n    1<<2 = 100\\n    1<<3 = 1000\\n    <<: append 0 after d for i time\\n    ```\\n\\n    3. Bitwise operators: XOR(^) and basic rule\\n\\n    ```\\n    T F | sol\\n    1 1 |  0\\n    1 0 |  1\\n    0 1 |  1\\n    0 0 |  0\\n\\n    * no carry-over, so we could xor 2 numbers from left to right\\n\\n    example:\\n    ask 5 ^ 25\\n    = 101 ^ 11001\\n    ==> 11001\\n       ^00101\\n        -----\\n    \\t= 1     # 1^0=1\\n      = 11    # 1^0=1\\n      = 111   # 1^0=1\\n      = 1110  # 0^0=0\\n      = 11100 # 1^1=0\\n\\n    and 11100 = 28\\n    -----------------------\\n    Rule:\\n    if a^b=c, then a^c=b\\n    we could apply it as classic 2sum question on set(), which will save more time & space\\n\\n    example:\\n    we know 5^25=28\\n    so 5^28=25 based on the rule\\n    ```\\n\\n    4. Greedy algorithm\\n\\n    If we could scan binary values from left\\u2192right and obtain most-left bit(most significant bit), it will guarantee we always stay on locally optimal choice on each stage\\n\\n    example from wiki:\\n\\t\\t![image](https://assets.leetcode.com/users/images/e0bbbc27-fca7-485c-abef-a99b7a22d930_1619065381.3485532.png)\\n\\n\\n    5. Set()\\n    in classic 2sum question, we could avoid double for-loop for O(n^2) solution\\n    by simply pass all value to set() then search set() return when target-current in set()\\n\\n    ------------------------\\n**Default sample walk through**\\n```\\n\\n    [11, 110,  101, 11001, 10,  1000]\\n\\n    since max length = 5\\n\\n    convert them to binary of length=5\\n\\n    00011\\n\\n    00110\\n\\n    00101\\n\\n    11001\\n\\n    00010\\n\\n    01000\\n\\n    only keep most index=0 from left\\n\\n    0|  0000\\n\\n    0|  0000\\n\\n    0|  0000\\n\\n    1|  0000\\n\\n    0|  0000\\n\\n    0|  0000\\n\\n    store to set() became\\n\\n    0|  0000\\n\\n    1|  0000\\n\\n    apply rule: a^b=c so a^c=b on here,\\n\\n    we want 10000, so we use 10000^prefix on set() to find if it exists on set()\\n\\n    if it exists, based on rule, it will guarantees we have 2 numbers on set() will return 10000 after XOR\\n\\n    then we update our max_result sol = 10000\\n\\n    index = 1, we only keep 2 digits from left, and we are looking for 11000\\n\\n    00|  000\\n\\n    01|  000\\n\\n    00|  000\\n\\n    11|  000\\n\\n    00|  000\\n\\n    01|  000\\n\\n    pass them to set()\\n\\n    00|  000\\n\\n    01|  000\\n\\n    11|  000\\n\\n    we use 11000^prefix from set(), turns out 11000^00000 = 11000, and it exists on set(), so update max_result sol = 11000\\n\\n    -if we can\\'t find a match on set(), we simply end the current iteration, then looking for the next most significant bit...\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        sol = 0\\n        for i in reversed(range(32)):\\n            prefixs = set([x >> i for x in nums])\\n            sol <<= 1\\n            candidate = sol + 1\\n            for p in prefixs:\\n                if candidate ^ p in prefixs:\\n                    sol = candidate\\n                    break\\n        return sol\\n```\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        sol = 0 \\n        for i in reversed(range(32)): # XOR from left, border=2^32\\n            prefixs = set([x >> i for x in nums]) # right shift (shrink) for i bits, keep left part\\n            sol <<= 1 # left shift (expand 0 on right) for each stage \\n            candidate = sol + 1 # expected value to find on set()\\n            for p in prefixs:\\n                if candidate ^ p in prefixs: # apply rule: a^b=c so a^c=b to search targets\\n                    sol = candidate # update the largest solution we could obtain in current stage\\n                    break\\n        return sol\\n```\n```\\n    d<<i\\n    1<<1 = 10\\n    1<<2 = 100\\n    1<<3 = 1000\\n    <<: append 0 after d for i time\\n    ```\n```\\n    T F | sol\\n    1 1 |  0\\n    1 0 |  1\\n    0 1 |  1\\n    0 0 |  0\\n\\n    * no carry-over, so we could xor 2 numbers from left to right\\n\\n    example:\\n    ask 5 ^ 25\\n    = 101 ^ 11001\\n    ==> 11001\\n       ^00101\\n        -----\\n    \\t= 1     # 1^0=1\\n      = 11    # 1^0=1\\n      = 111   # 1^0=1\\n      = 1110  # 0^0=0\\n      = 11100 # 1^1=0\\n\\n    and 11100 = 28\\n    -----------------------\\n    Rule:\\n    if a^b=c, then a^c=b\\n    we could apply it as classic 2sum question on set(), which will save more time & space\\n\\n    example:\\n    we know 5^25=28\\n    so 5^28=25 based on the rule\\n    ```\n```\\n\\n    [11, 110,  101, 11001, 10,  1000]\\n\\n    since max length = 5\\n\\n    convert them to binary of length=5\\n\\n    00011\\n\\n    00110\\n\\n    00101\\n\\n    11001\\n\\n    00010\\n\\n    01000\\n\\n    only keep most index=0 from left\\n\\n    0|  0000\\n\\n    0|  0000\\n\\n    0|  0000\\n\\n    1|  0000\\n\\n    0|  0000\\n\\n    0|  0000\\n\\n    store to set() became\\n\\n    0|  0000\\n\\n    1|  0000\\n\\n    apply rule: a^b=c so a^c=b on here,\\n\\n    we want 10000, so we use 10000^prefix on set() to find if it exists on set()\\n\\n    if it exists, based on rule, it will guarantees we have 2 numbers on set() will return 10000 after XOR\\n\\n    then we update our max_result sol = 10000\\n\\n    index = 1, we only keep 2 digits from left, and we are looking for 11000\\n\\n    00|  000\\n\\n    01|  000\\n\\n    00|  000\\n\\n    11|  000\\n\\n    00|  000\\n\\n    01|  000\\n\\n    pass them to set()\\n\\n    00|  000\\n\\n    01|  000\\n\\n    11|  000\\n\\n    we use 11000^prefix from set(), turns out 11000^00000 = 11000, and it exists on set(), so update max_result sol = 11000\\n\\n    -if we can\\'t find a match on set(), we simply end the current iteration, then looking for the next most significant bit...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747199,
                "title": "c-solution-with-explanatory-comments",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will store all binary values of array\\'s element in Trie.\\n\\n2. we know that XOR gives max value with its complement values i.e, 1^0 = 1.\\n\\n3. So, In trie we search complementery values as long as possible.\\n\\n4. Store max value in ans and return.\\n\\n# Complexity\\n  - Time complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n*You can better understand through code with comments*\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct TrieNode {\\n        //trie with max 2 child, not taking any bool or 26 size value because no need\\n        TrieNode* one;\\n        TrieNode* zero;\\n    };\\n    void insert(TrieNode* root, int n) {\\n        TrieNode* curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (n >> i) & 1;  //it will find 31st bit and check it is 1 or 0\\n            if (bit == 0) {\\n                if (curr->zero == nullptr) {   //if 0 then we will continue filling on zero side\\n                    TrieNode* newNode = new TrieNode();    \\n                    curr->zero = newNode;  \\n                }\\n                curr = curr->zero;   //increase cur to next zero position\\n            }\\n            else {\\n                //similarly if we get 1 \\n                if (curr->one == nullptr) {\\n                    TrieNode* newNode = new TrieNode();\\n                    curr->one = newNode;\\n                }\\n                curr = curr->one;\\n            }\\n        }\\n    }\\n     int findmax(TrieNode* root, int n) {\\n        TrieNode* curr = root;\\n        int ans = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (n >> i) & 1;\\n            if (bit == 1) {\\n                if (curr->zero != nullptr) {  //finding complement , if find 1 then we will check on zero side\\n                    ans += (1 << i); //push values in ans\\n                    curr = curr->zero;\\n                }\\n                else {\\n                    curr = curr->one;  //if we don\\'t get then go to one\\'s side\\n                }\\n            }\\n            else {\\n                //similarly on zero side if we get 0 then we will check on 1 s side\\n                if (curr->one != nullptr) {   \\n                    ans += (1 << i);\\n                    curr = curr->one;\\n                }\\n                else {\\n                    curr = curr->zero;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        TrieNode* root = new TrieNode();\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            insert(root, nums[i]);    //it will make trie by inserting values\\n        }\\n        for (int i = 1; i < n; i++) {\\n            ans = max(ans, findmax(root, nums[i]));  //find the necessary complementory values and maximum store\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode {\\n        //trie with max 2 child, not taking any bool or 26 size value because no need\\n        TrieNode* one;\\n        TrieNode* zero;\\n    };\\n    void insert(TrieNode* root, int n) {\\n        TrieNode* curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (n >> i) & 1;  //it will find 31st bit and check it is 1 or 0\\n            if (bit == 0) {\\n                if (curr->zero == nullptr) {   //if 0 then we will continue filling on zero side\\n                    TrieNode* newNode = new TrieNode();    \\n                    curr->zero = newNode;  \\n                }\\n                curr = curr->zero;   //increase cur to next zero position\\n            }\\n            else {\\n                //similarly if we get 1 \\n                if (curr->one == nullptr) {\\n                    TrieNode* newNode = new TrieNode();\\n                    curr->one = newNode;\\n                }\\n                curr = curr->one;\\n            }\\n        }\\n    }\\n     int findmax(TrieNode* root, int n) {\\n        TrieNode* curr = root;\\n        int ans = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (n >> i) & 1;\\n            if (bit == 1) {\\n                if (curr->zero != nullptr) {  //finding complement , if find 1 then we will check on zero side\\n                    ans += (1 << i); //push values in ans\\n                    curr = curr->zero;\\n                }\\n                else {\\n                    curr = curr->one;  //if we don\\'t get then go to one\\'s side\\n                }\\n            }\\n            else {\\n                //similarly on zero side if we get 0 then we will check on 1 s side\\n                if (curr->one != nullptr) {   \\n                    ans += (1 << i);\\n                    curr = curr->one;\\n                }\\n                else {\\n                    curr = curr->zero;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        TrieNode* root = new TrieNode();\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            insert(root, nums[i]);    //it will make trie by inserting values\\n        }\\n        for (int i = 1; i < n; i++) {\\n            ans = max(ans, findmax(root, nums[i]));  //find the necessary complementory values and maximum store\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172645,
                "title": "detailed-explanation-with-tries",
                "content": "This problem can be solved by help to trie(prefix tree). \\n\\nApproach: -\\n**1.  XOR table **\\n\\n![image](https://assets.leetcode.com/users/images/3ca6d92b-1ddf-4387-a974-cfa752dc487d_1619167885.3818417.jpeg)\\n\\n\\nAs shown in above table xor gives maximum number when its xored with its complement. we will make use of this logic while solving the problem. \\n\\n**2.  Create binary trie **\\n\\nwe will xor th current element with all its previous elements and store the result which gives maximum xor.\\n\\n![image](https://assets.leetcode.com/users/images/88c21dc5-098a-48cf-9781-a0e089d33e7c_1619166744.6285884.jpeg)\\n\\nabove image shows binary representation of all input numbers \\n\\nnow we will create binary tree for 3, 10 and 5 repsectively (we will take 5 bit implementation for working) and see how the logic will work.  \\n\\n![image](https://assets.leetcode.com/users/images/f5cee1d2-3652-466a-a76e-60dce72dcf85_1619167562.4124656.jpeg)\\n\\nAs show in the above diagrams we will create the binary trie for 2 when we want to operate for second number i.e 10 then we will go in the direction of its complement. As you can see in the second digram in the above image when we want to operate third number i.e 5 we will traverse in the binary tries of 3 and 10 but in the direction of its complement. \\n\\n**working code**\\n\\n```\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.val = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, binary_str, num):\\n        curr = self.root\\n\\n        for bit in binary_str:\\n            curr = curr.children[int(bit)]\\n\\n        curr.val = num\\n\\n    def seacrh(self, binary, num):\\n        curr = self.root\\n        for bit in binary:\\n            d = int(bit)\\n            want = d ^ 1\\n            if want in curr.children:\\n                curr = curr.children[want]\\n            else:\\n                curr = curr.children[want ^ 1]\\n\\n        return curr.val ^ num\\n\\n\\nclass Solution(object):\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        trie = Trie()\\n        max_xor = float(\"-inf\")\\n\\n        for num in nums:\\n            binary_str = bin(num)[2:].zfill(32)\\n            trie.insert(binary_str, num)\\n\\n            max_xor = max(max_xor, trie.seacrh(binary_str, num))\\n\\n        return max_xor\\n\\ns = Solution()\\nprint s.findMaximumXOR([3,10,5,25,2,8])\\n```\\n\\n\\nThank You.\\nHappy Coding \\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.val = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, binary_str, num):\\n        curr = self.root\\n\\n        for bit in binary_str:\\n            curr = curr.children[int(bit)]\\n\\n        curr.val = num\\n\\n    def seacrh(self, binary, num):\\n        curr = self.root\\n        for bit in binary:\\n            d = int(bit)\\n            want = d ^ 1\\n            if want in curr.children:\\n                curr = curr.children[want]\\n            else:\\n                curr = curr.children[want ^ 1]\\n\\n        return curr.val ^ num\\n\\n\\nclass Solution(object):\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        trie = Trie()\\n        max_xor = float(\"-inf\")\\n\\n        for num in nums:\\n            binary_str = bin(num)[2:].zfill(32)\\n            trie.insert(binary_str, num)\\n\\n            max_xor = max(max_xor, trie.seacrh(binary_str, num))\\n\\n        return max_xor\\n\\ns = Solution()\\nprint s.findMaximumXOR([3,10,5,25,2,8])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388658,
                "title": "c-o-n-trie-beat-85",
                "content": "```\\nclass Solution {\\npublic:\\n    struct node{\\n        // val at the leaf is value of path from root to leaf\\n        int val;\\n        // two links, 0 and 1, for each bit\\n        struct node* link[2];\\n        node(){\\n            val=0;\\n            link[0]=link[1]=NULL;\\n        }\\n    };\\n    struct node* start=new node();\\n    \\n    void insertTrie(int x){\\n    \\t// straightforward insertion from msb to lsb\\n        struct node* ptr=start;\\n        for(int i=31;i>=0;i--){\\n            bool curbit=(x&(1<<i));\\n            if(ptr->link[curbit]==NULL)\\n                ptr->link[curbit]=new node();\\n            ptr=ptr->link[curbit];\\n        }\\n        ptr->val=x;\\n    }\\n    \\n    int checkTrie(int x){\\n    \\t// checking from msb to lsb(least significat bit)\\n        struct node* ptr=start;\\n        for(int i=31;i>=0;i--){\\n            bool curbit=(x&(1<<i));\\n            // if curbit is 1,see if we can have a number with that bit 0 to maximize the xor\\n            if(ptr->link[1-curbit]!=NULL)\\n                ptr=ptr->link[1-curbit];\\n            // if not then proceed with curbit\\n            else if(ptr->link[curbit]!=NULL)\\n                ptr=ptr->link[curbit];\\n        }\\n        return ptr->val;    \\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans=0,n=nums.size();\\n        if(nums.size()<2) return 0;\\n        insertTrie(nums[0]);\\n        for(int i=1;i<n;i++){\\n        \\t// for nums[i], we are finding element in nums[0 to i-1] with which it\\'s xor will be max\\n            ans=max(ans,nums[i]^checkTrie(nums[i]));\\n            // add nums[i] to the trie\\n            insertTrie(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node{\\n        // val at the leaf is value of path from root to leaf\\n        int val;\\n        // two links, 0 and 1, for each bit\\n        struct node* link[2];\\n        node(){\\n            val=0;\\n            link[0]=link[1]=NULL;\\n        }\\n    };\\n    struct node* start=new node();\\n    \\n    void insertTrie(int x){\\n    \\t// straightforward insertion from msb to lsb\\n        struct node* ptr=start;\\n        for(int i=31;i>=0;i--){\\n            bool curbit=(x&(1<<i));\\n            if(ptr->link[curbit]==NULL)\\n                ptr->link[curbit]=new node();\\n            ptr=ptr->link[curbit];\\n        }\\n        ptr->val=x;\\n    }\\n    \\n    int checkTrie(int x){\\n    \\t// checking from msb to lsb(least significat bit)\\n        struct node* ptr=start;\\n        for(int i=31;i>=0;i--){\\n            bool curbit=(x&(1<<i));\\n            // if curbit is 1,see if we can have a number with that bit 0 to maximize the xor\\n            if(ptr->link[1-curbit]!=NULL)\\n                ptr=ptr->link[1-curbit];\\n            // if not then proceed with curbit\\n            else if(ptr->link[curbit]!=NULL)\\n                ptr=ptr->link[curbit];\\n        }\\n        return ptr->val;    \\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans=0,n=nums.size();\\n        if(nums.size()<2) return 0;\\n        insertTrie(nums[0]);\\n        for(int i=1;i<n;i++){\\n        \\t// for nums[i], we are finding element in nums[0 to i-1] with which it\\'s xor will be max\\n            ans=max(ans,nums[i]^checkTrie(nums[i]));\\n            // add nums[i] to the trie\\n            insertTrie(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723142,
                "title": "c-trie-solution-using-bitmasking",
                "content": "using brute force there is time limit exceeded (using n^2)\\nso optimize using trie.\\n\\n\\'\\'\\'\\n\\nclass TrieNode{\\npublic:\\n    TrieNode* child[2];\\n    TrieNode(){\\n        for(int i=0;i<2;i++) child[i]=NULL;\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    TrieNode *root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\nprivate:\\n    void insert(int &number){\\n        TrieNode *curr = root;\\n        for(int i = 31;i>=0;i--){\\n            int bit = (number>>i)&1;\\n            if(curr->child[bit] == NULL) curr->child[bit]=new TrieNode();\\n            curr = curr->child[bit];\\n        }\\n    }\\n    int findmax(int &number){\\n        TrieNode *curr = root;\\n        int ans=0;\\n        for(int i=31;i>=0;i--){\\n            int bit = (number>>i)&1;\\n            int req = 1-bit;//required opposite to make max Eg 0111^1000 = 1111\\n            if(curr->child[req] != NULL){\\n                ans =(ans | (1<<i));//if the required is there then we can make that bit 1\\n                curr = curr->child[req];\\n            }\\n            else{\\n                curr = curr->child[bit];\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int insert_vec(vector<int>& nums){\\n        for(int i=0;i<nums.size();i++) insert(nums[i]);\\n        int maxi = INT_MIN;\\n        for(int i=0;i<nums.size();i++) maxi = max(maxi,findmax(nums[i]));\\n        return maxi;\\n    }\\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie *trie = new Trie();\\n        return trie->insert_vec(nums);;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Trie",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie *trie = new Trie();\\n        return trie->insert_vec(nums);;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1373936,
                "title": "c-solution-o-n-without-using-trie",
                "content": "The key idea is to get maximum number of set bits starting from the leftmost bit. I\\'ve used mask to keep the prefix of every number.\\n\\nmask after each iteration:\\n```\\n10000000000000000...\\n11000000000000000...\\n11100000000000000...\\n11110000000000000...\\n11111000000000000...\\n11111100000000000...\\n11111110000000000...\\n....\\n```\\n\\nbitwise and(&) of mask and array element gives the prefix. Prefix for all numbers of the array is stored in a set.\\n\\nXOR property used in the next step.\\n```\\nA ^ B = C\\nA ^ C = B\\n```\\n\\nmaxPossible = **max1 | (1<<i)** gives the maximum possible output we can get in i\\'th iteration. Finally, if xor of any two elements in the set is equal to maxPossible, we update the max1 to maxPossible. The property mentioned above can be used to find if there\\'s a pair in the set such that xor of the elements in the pair gives maxPossible.\\n\\n```\\nsetElement1 ^ setElement2 = maxPossible\\nsetElement1 ^ maxPossible = setElement2\\n\\ncode - \\nfor(auto i : s){\\n     if(s.find(i ^ possible) != s.end()){\\n             max1 = possible;\\n             break;\\n\\t}\\n}\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int max1 = 0;\\n        int mask = 0;\\n        unordered_set<int> s;\\n        \\n        for(int i = 31; i>=0; i--){\\n            mask |= (1<<i);\\n            \\n            for(int j = 0; j<n; j++){\\n                s.insert(mask & nums[j]);\\n            }\\n            \\n            int possible = max1 | (1<<i);\\n            \\n            for(auto j : s){\\n                if(s.find(j ^ possible) != s.end()){\\n                    max1 = possible;\\n                    break;\\n                }\\n            }\\n            \\n            s.clear();\\n        }\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n10000000000000000...\\n11000000000000000...\\n11100000000000000...\\n11110000000000000...\\n11111000000000000...\\n11111100000000000...\\n11111110000000000...\\n....\\n```\n```\\nA ^ B = C\\nA ^ C = B\\n```\n```\\nsetElement1 ^ setElement2 = maxPossible\\nsetElement1 ^ maxPossible = setElement2\\n\\ncode - \\nfor(auto i : s){\\n     if(s.find(i ^ possible) != s.end()){\\n             max1 = possible;\\n             break;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int max1 = 0;\\n        int mask = 0;\\n        unordered_set<int> s;\\n        \\n        for(int i = 31; i>=0; i--){\\n            mask |= (1<<i);\\n            \\n            for(int j = 0; j<n; j++){\\n                s.insert(mask & nums[j]);\\n            }\\n            \\n            int possible = max1 | (1<<i);\\n            \\n            for(auto j : s){\\n                if(s.find(j ^ possible) != s.end()){\\n                    max1 = possible;\\n                    break;\\n                }\\n            }\\n            \\n            s.clear();\\n        }\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849233,
                "title": "java-easy-to-understand-solution-explained-o-n-trie",
                "content": "[https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/91059/Java-O(n)-solution-using-Trie](http://)\\nclass Solution {\\n    \\n    // binary trie, where each trie node has only 2 child \\n    // one child will represent bit \"1\" in the binary representation of num\\n    // one child will represent bit \"0\" in the binary representation of num\\n    private static class TrieNode {\\n        // children[0]: represent bit \"1\" in the binary representation \\n        // children[1]: represent bit \"0\" in the binary representation \\n        private final TrieNode[] children;\\n        \\n        private TrieNode() {\\n            children = new TrieNode[2];\\n        }\\n    }\\n    \\n    private TrieNode root;\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        // initialize the root node\\n        root = new TrieNode();\\n        \\n        TrieNode curr;\\n        \\n        // build the trie \\n        for (int num : nums) {\\n            // starting from root;\\n            curr = root;\\n            \\n            // since every num is positive, their 31th bit is always 0\\n            // we can ignore that bit and directy build from the 30th bit \\n            for (int i = 30; i >= 0; --i) {\\n                int bit = getIthBit(num, i);\\n                \\n                // if current bit is 0, it will go to children[1]\\n                // if current bit is 1, it will go to children[0]\\n                if (curr.children[bit ^ 1] == null) {\\n                    curr.children[bit ^ 1] = new TrieNode();\\n                }\\n                \\n                curr = curr.children[bit ^ 1];\\n            }\\n        }\\n        \\n        int ans = Integer.MIN_VALUE;\\n        \\n        // iterate through each num again\\n        // starting from those significant bits of num, we try the best \\n        // to go to the node that represent the negation of current bit \\n        // if such node doesn\\'t exist, we have to go the node that represents\\n        // the current bit \\n        for (int num : nums) {\\n            // starting from root\\n            curr = root;\\n            \\n            // keep track of the maximum result of XOR current num with \\n            // other num in the array\\n            int rst = 0;\\n            for (int i = 30; i >= 0; --i) {\\n                int bit = getIthBit(num, i);\\n                \\n                // check to see if node that represents the negation of \\n                // current bit exists or not. If exists, go to that way \\n                \\n                // if current bit is 1, then we want to go to children[1] (which represents 0)\\n                // if current bit is 0, then we want to go to children[0] (which represents 1)\\n                if (curr.children[bit] != null) {\\n                    curr = curr.children[bit];\\n                    \\n                    // if exists, then we will have a \"1\" at the current index\\n                    // in the result of maximum XOR \\n                    rst += (1 << i);\\n                } \\n                // if not exists\\n                else {\\n                    curr = curr.children[bit ^ 1];\\n                }\\n            }\\n            \\n            // keep track of global maximum \\n            ans = Math.max(ans, rst);\\n            // there is no need to continue when final result has reached max value \\n            if (ans == Integer.MAX_VALUE) break;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // get the ith bit (count from LSB, 0-based) of num\\n    private int getIthBit(int num, int i) {\\n        return (num & (1 << i)) == 0 ? 0 : 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    // binary trie, where each trie node has only 2 child \\n    // one child will represent bit \"1\" in the binary representation of num\\n    // one child will represent bit \"0\" in the binary representation of num\\n    private static class TrieNode {\\n        // children[0]: represent bit \"1\" in the binary representation \\n        // children[1]: represent bit \"0\" in the binary representation \\n        private final TrieNode[] children;\\n        \\n        private TrieNode() {\\n            children = new TrieNode[2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 849226,
                "title": "java-photo-explained-code",
                "content": "![image](https://assets.leetcode.com/users/images/ff46f44b-4543-48d2-97ac-ce58f301e47a_1600252667.5149417.png)\\n```\\n    public int findMaximumXOR(int[] nums) {\\n        int result = 0;\\n        int mask = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            mask |= (1 << i);\\n            final HashSet<Integer> set = new HashSet<>();\\n            for (int n : nums) {\\n                set.add(n & mask);\\n            }\\n            int temp = result | (1 << i);\\n            for (int it : set) {\\n                if (set.contains(it ^ temp)) {\\n                    result = temp;\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int findMaximumXOR(int[] nums) {\\n        int result = 0;\\n        int mask = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            mask |= (1 << i);\\n            final HashSet<Integer> set = new HashSet<>();\\n            for (int n : nums) {\\n                set.add(n & mask);\\n            }\\n            int temp = result | (1 << i);\\n            for (int it : set) {\\n                if (set.contains(it ^ temp)) {\\n                    result = temp;\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673849,
                "title": "c-trie-solution-with-explanation",
                "content": "**Before directly Jumping in the code first go through the explantion given at the last,otherwise it would be difficult for you to understand**\\n```\\nclass Solution {\\npublic:\\n    struct Trie{\\n        Trie* children[2];\\n        Trie()\\n        {\\n            for(int i=0;i<2;i++)\\n                this->children[i]=NULL;\\n        }\\n    };\\n    Trie* Node=new Trie();\\n    void Insert(string &s)\\n    {\\n        int i,n=s.length();\\n        Trie* temp=Node;\\n        for(i=0;i<n;i++)\\n        {\\n            if(temp->children[s[i]-\\'0\\']==NULL)\\n            {\\n                Trie* temp2=new Trie();\\n                temp->children[s[i]-\\'0\\']=temp2;\\n            }\\n            temp=temp->children[s[i]-\\'0\\'];\\n        }\\n    }\\n    int Search(string &s)\\n    {\\n        int i,n=s.length();\\n        Trie* temp=Node;\\n        int ans=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(temp->children[abs(s[i]-\\'0\\'-1)]!=NULL)\\n            {\\n                ans=2*ans+1;\\n                temp=temp->children[abs(s[i]-\\'0\\'-1)];\\n            }\\n            else\\n            {\\n                ans=2*ans;\\n                temp=temp->children[s[i]-\\'0\\'];\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        int n=nums.size(),i;\\n        string S[n];\\n        for(i=0;i<n;i++)\\n        {\\n            int a=nums[i];\\n            while(a!=0 || S[i].length()<31)\\n            {\\n                S[i]+=(\\'0\\'+a%2);\\n                a/=2;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            reverse(S[i].begin(),S[i].end());\\n        }\\n        Insert(S[0]);\\n        int m=0;\\n        for(i=1;i<n;i++)\\n        {\\n            m=max(m,Search(S[i]));\\n            Insert(S[i]);\\n        }\\n        return m;\\n    }\\n};\\n```\\nAnalysis from the question:\\n1.For all the numbers for the array,take a number **X**,Let\\'s consider the **X** in bitwise and From the highest bit of **X**=>**i** to lowest bit 0. The remaining numbers Can be divided into two set one with set(1) bit at the bit position i and the other with unset(0) bit at the bit position i,If the bit in the ith position of X is set then we would consider all the numbers with unset bit and neglect the other half similar for when ith bit in the X being unset.\\n2.Now to implement the above logic we need to use Trie.\\n3. We need the pre-proccessing of all the numbers,such that they contain same number of bit as you can see in the code.\\n4.Now we need to insert the bonary representation of each number.\\n5.Now serching the highest value for the ith number,with (i-1)numbers already inserted.\\n\\n\\nIf you have any doubt or feel that you need somewhat more explanation of any portion then leave a comment with the portion,I will try best to Update ASAP.Also Upvote this if you find this helpful.",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Trie{\\n        Trie* children[2];\\n        Trie()\\n        {\\n            for(int i=0;i<2;i++)\\n                this->children[i]=NULL;\\n        }\\n    };\\n    Trie* Node=new Trie();\\n    void Insert(string &s)\\n    {\\n        int i,n=s.length();\\n        Trie* temp=Node;\\n        for(i=0;i<n;i++)\\n        {\\n            if(temp->children[s[i]-\\'0\\']==NULL)\\n            {\\n                Trie* temp2=new Trie();\\n                temp->children[s[i]-\\'0\\']=temp2;\\n            }\\n            temp=temp->children[s[i]-\\'0\\'];\\n        }\\n    }\\n    int Search(string &s)\\n    {\\n        int i,n=s.length();\\n        Trie* temp=Node;\\n        int ans=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(temp->children[abs(s[i]-\\'0\\'-1)]!=NULL)\\n            {\\n                ans=2*ans+1;\\n                temp=temp->children[abs(s[i]-\\'0\\'-1)];\\n            }\\n            else\\n            {\\n                ans=2*ans;\\n                temp=temp->children[s[i]-\\'0\\'];\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        int n=nums.size(),i;\\n        string S[n];\\n        for(i=0;i<n;i++)\\n        {\\n            int a=nums[i];\\n            while(a!=0 || S[i].length()<31)\\n            {\\n                S[i]+=(\\'0\\'+a%2);\\n                a/=2;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            reverse(S[i].begin(),S[i].end());\\n        }\\n        Insert(S[0]);\\n        int m=0;\\n        for(i=1;i<n;i++)\\n        {\\n            m=max(m,Search(S[i]));\\n            Insert(S[i]);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266785,
                "title": "421-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We first find the maximum number in the input list nums using the built-in max function.\\n\\n2. If the maximum number is 0, it means that all the numbers in the list are also 0, and so the maximum XOR value will also be 0. So we return 0.\\n\\n3. Otherwise, we calculate the maximum bit position of the maximum number using the math.log2 function.\\n\\n4. We initialize the ans variable to 0, which will eventually hold the maximum XOR value we find.\\n\\n5. We also initialize a mask variable to 0, which we will use to generate a set of prefixes for each bit position.\\n\\n6. We loop through the bit positions in descending order from the maximum bit position to 0.\\n\\n7. In each iteration, we set the mask variable to the current bit position by left-shifting 1 by the bit position and subtracting 1. For example, if the bit position is 2, mask will be set to 0b00000100.\\n\\n8. We generate a set of prefixes for the current bit position by applying the mask to each number in the input list using the bitwise AND operator (&). This results in a set of numbers where the rightmost bits up to the current bit position are all 0.\\n\\n9. We initialize a candidate variable to the current ans value with the bit at the current bit position set to 1 using the bitwise OR operator (|).\\n\\n10. We loop through each prefix in the set of prefixes we generated in step 8.\\n\\n11. For each prefix, we check if there exists another prefix in the set that, when XORed with the candidate variable, results in another prefix in the set. If such a prefix exists, it means that we can use the candidate variable as the new ans value, since it indicates that we can form a larger XOR value by setting the bit at the current bit position to 1.\\n\\n12. If we find such a prefix, we set the ans variable to the candidate value and break out of the loop.\\n\\n13. We return the ans variable at the end of the loop, which should contain the maximum XOR value we found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findMaximumXOR(self, nums: List[int]) -> int:\\n    maxNum = max(nums)\\n    if maxNum == 0:\\n      return 0\\n    maxBit = int(math.log2(maxNum))\\n    ans = 0\\n    mask = 0\\n\\n    # If ans is 11100 when i = 2, it means that before we reach the last two\\n    # bits, 11100 is the maximum XOR we have, and we\\'re going to explore if we\\n    # can get another two \\'1\\'s and put them into ans.\\n    for i in range(maxBit, -1, -1):\\n      # Mask grows like: 100...000, 110...000, 111...000, ..., 111...111.\\n      mask |= 1 << i\\n      # We only care about the left parts,\\n      # If i = 2, nums = [1110, 1011, 0111]\\n      #    -> prefixes = [1100, 1000, 0100]\\n      prefixes = set([num & mask for num in nums])\\n      # If i = 1 and before this iteration, the ans is 10100, it means that we\\n      # want to grow the ans to 10100 | 1 << 1 = 10110 and we\\'re looking for\\n      # XOR of two prefixes = candidate.\\n      candidate = ans | 1 << i\\n      for prefix in prefixes:\\n        if prefix ^ candidate in prefixes:\\n          ans = candidate\\n          break\\n\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n  def findMaximumXOR(self, nums: List[int]) -> int:\\n    maxNum = max(nums)\\n    if maxNum == 0:\\n      return 0\\n    maxBit = int(math.log2(maxNum))\\n    ans = 0\\n    mask = 0\\n\\n    # If ans is 11100 when i = 2, it means that before we reach the last two\\n    # bits, 11100 is the maximum XOR we have, and we\\'re going to explore if we\\n    # can get another two \\'1\\'s and put them into ans.\\n    for i in range(maxBit, -1, -1):\\n      # Mask grows like: 100...000, 110...000, 111...000, ..., 111...111.\\n      mask |= 1 << i\\n      # We only care about the left parts,\\n      # If i = 2, nums = [1110, 1011, 0111]\\n      #    -> prefixes = [1100, 1000, 0100]\\n      prefixes = set([num & mask for num in nums])\\n      # If i = 1 and before this iteration, the ans is 10100, it means that we\\n      # want to grow the ans to 10100 | 1 << 1 = 10110 and we\\'re looking for\\n      # XOR of two prefixes = candidate.\\n      candidate = ans | 1 << i\\n      for prefix in prefixes:\\n        if prefix ^ candidate in prefixes:\\n          ans = candidate\\n          break\\n\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052355,
                "title": "fast-python-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea behind this solution is to use a bitwise operation to find the maximum XOR value of any two numbers in the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution starts by initializing the variable ans to 0. Then, it loops through the bits of the numbers (from the most significant bit to the least significant bit) and for each bit, it shifts the value of ans to the left by 1, and then checks if the current bit can be set to 1 by checking if there are any two numbers in the list with different values for that bit. If there are such numbers, the bit is set to 1 and added to the ans variable.\\n\\nComplexity\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the number of elements in the list. The solution needs to loop through all the elements in the list and check their bits.\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere n is the number of elements in the list. The solution uses a set to store the prefixes of the numbers in the list.\\n# Code\\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(32)[::-1]:\\n            ans <<= 1\\n            prefixes = {num >> i for num in nums}\\n            ans += any(ans^1 ^ p in prefixes for p in prefixes)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(32)[::-1]:\\n            ans <<= 1\\n            prefixes = {num >> i for num in nums}\\n            ans += any(ans^1 ^ p in prefixes for p in prefixes)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070203,
                "title": "clean-python-solution-using-trie-with-comments-easy-to-understand",
                "content": "Insert all the elements of nums in a trie with bit values in respective position. where every node can have 2 children either with 0 key or 1 key. \\n\\nAs XOR is a **inequality detector** so we try to maximize the inequality between num and node. So that the XOR of num and value of node will give the max value.\\n\\nSo we do the following steps While traversing the num from 31\\'th bit position to 0\\'th bit position:\\n1. If the current bit of num is 1 then we try to move the cur pointer towards the child with 0 key.\\n2. And if the current bit of num is 0 then we try to move the cur pointer towards the child with 1 key.\\n\\n```\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.val = -1           # used to store the value of entire number at the end of trie node\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()  # object of trienode class\\n    \\n    def addNum(self, num):\\n        cur = self.root         # every time start from root\\n        for i in range(31, -1, -1):\\n            bit = 1 if num & (1 << i) else 0  # bit value i\\'th position of num \\n            if bit not in cur.children:\\n                cur.children[bit] = TrieNode()\\n            cur = cur.children[bit]\\n        cur.val = num           # storing the value of entire num at the end of trie node\\n                \\n\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        trie = Trie()           # creating object of Trie class\\n        for num in nums:        # adding all num to the trie structure\\n            trie.addNum(num)\\n        \\n        res = 0\\n        for num in nums:        \\n            cur = trie.root     # every time start cur pointer from root\\n            for i in range(31, -1, -1):\\n                bit = 1 if num & (1 << i) else 0  # bit value of i\\'th position of num  \\n                if bit == 1:                      # try to move towards opposite key ie. 0\\n                    if 0 in cur.children:         # opposit key 0 exist then defenetly go towards the child 0\\n                        cur = cur.children[0]\\n                    else:                         # opposit key 0 not exist so we have only option to go towards what we have ie. 1\\n                        cur = cur.children[1]\\n                else:     # bit == 0              # try to move towards opposite key ie. 1\\n                    if 1 in cur.children:         # opposit key 1 exist then defenetly go towards the child 1\\n                        cur = cur.children[1]\\n                    else:                         # opposit key 1 not exist so we have only option to go towards what we have ie. 0\\n                        cur = cur.children[0]\\n            # as we tried to maximize the inequality between cur.val and num so XOR of them will give max value\\n            res = max(res, cur.val ^ num)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.val = -1           # used to store the value of entire number at the end of trie node\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()  # object of trienode class\\n    \\n    def addNum(self, num):\\n        cur = self.root         # every time start from root\\n        for i in range(31, -1, -1):\\n            bit = 1 if num & (1 << i) else 0  # bit value i\\'th position of num \\n            if bit not in cur.children:\\n                cur.children[bit] = TrieNode()\\n            cur = cur.children[bit]\\n        cur.val = num           # storing the value of entire num at the end of trie node\\n                \\n\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        trie = Trie()           # creating object of Trie class\\n        for num in nums:        # adding all num to the trie structure\\n            trie.addNum(num)\\n        \\n        res = 0\\n        for num in nums:        \\n            cur = trie.root     # every time start cur pointer from root\\n            for i in range(31, -1, -1):\\n                bit = 1 if num & (1 << i) else 0  # bit value of i\\'th position of num  \\n                if bit == 1:                      # try to move towards opposite key ie. 0\\n                    if 0 in cur.children:         # opposit key 0 exist then defenetly go towards the child 0\\n                        cur = cur.children[0]\\n                    else:                         # opposit key 0 not exist so we have only option to go towards what we have ie. 1\\n                        cur = cur.children[1]\\n                else:     # bit == 0              # try to move towards opposite key ie. 1\\n                    if 1 in cur.children:         # opposit key 1 exist then defenetly go towards the child 1\\n                        cur = cur.children[1]\\n                    else:                         # opposit key 1 not exist so we have only option to go towards what we have ie. 0\\n                        cur = cur.children[0]\\n            # as we tried to maximize the inequality between cur.val and num so XOR of them will give max value\\n            res = max(res, cur.val ^ num)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476619,
                "title": "javascript-trie-bit-manipulation-with-explaination-and-easy-understanding",
                "content": "**Intuition**:\\n\\nWe want to find the maximum XOR of any two numbers of this Array. This means bit manipulation is involved here. This forces us to think about the binary representation of array members. In order for any number to have maximum XOR with another number, the other number needs to have opposite bits at all bits position.\\n\\n(for any bit position x - could be 0 or 1)\\n```\\n0 ^ x = x\\nx ^ x = x\\n```\\n\\nIn order to maximise this number, we start from the most significant bit of the binary number. This gives a hint that prefix calculation might be involved, which means we\\'ll be using Trie data structure here. \\n\\n\\n```\\nvar findMaximumXOR = function(nums) {\\n  let trie = new Trie();\\n  let root = trie.root;\\n  \\n  // build a bitwise trie using all the numbers in nums\\n  for(let num of nums) {\\n    trie.insert(num);\\n  }\\n  \\n  let ans = 0;\\n  let INTEGER_MAX = Math.pow(2, 31) - 1;\\n  for(let num of nums) {\\n    let target = num ^ INTEGER_MAX;\\n    let found = trie.search(target);\\n    ans = Math.max(ans, num ^ found);\\n  }\\n  return ans;\\n};\\n\\nclass Trie {\\n  root = new Map();\\n  \\n  // inserts binary representation of a number\\n  insert(number) {\\n    // for a 32 bit signed integer, there will be 31 bits.\\n    // So we start at 30 and go down to 0. (from MSB to LSB)\\n    let index = 30;\\n    let node = this.root;\\n    while(index >= 0) {\\n      // create a mask, for index 30, it\\'ll be Math.pow(2, 30)\\n      let mask = 1 << index;\\n      // get the bit value at current position, Bitwise AND will\\n      // be positive if the bit is set, and 0 if it is unset.\\n      let bit = (number & mask) > 0 ? 1 : 0;\\n      if(!node.has(bit)) {\\n        node.set(bit, new Map());\\n      }\\n      node = node.get(bit);\\n      index--;\\n    }\\n  }\\n\\n  // tries to find number in Trie, if not, then the closest\\n  // possible\\n  search(number) {\\n    let ans = 0;\\n    let index = 30;\\n    let node = this.root;\\n    while(index >= 0) {\\n      let mask = 1 << index;\\n      let bit = (number & mask) > 0 ? 1 : 0;\\n      // found bit in Trie, proceed further\\n      if (node.has(bit)) {\\n        node = node.get(bit);\\n\\n      // bit is not present in Trie, proceed with\\n      // what is present there then\\n      } else {\\n        bit = bit === 0 ? 1 : 0\\n        node = node.get(bit);\\n      }\\n\\n      if (bit === 1) {\\n        ans = ans + mask;\\n      }\\n      index--;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n0 ^ x = x\\nx ^ x = x\\n```\n```\\nvar findMaximumXOR = function(nums) {\\n  let trie = new Trie();\\n  let root = trie.root;\\n  \\n  // build a bitwise trie using all the numbers in nums\\n  for(let num of nums) {\\n    trie.insert(num);\\n  }\\n  \\n  let ans = 0;\\n  let INTEGER_MAX = Math.pow(2, 31) - 1;\\n  for(let num of nums) {\\n    let target = num ^ INTEGER_MAX;\\n    let found = trie.search(target);\\n    ans = Math.max(ans, num ^ found);\\n  }\\n  return ans;\\n};\\n\\nclass Trie {\\n  root = new Map();\\n  \\n  // inserts binary representation of a number\\n  insert(number) {\\n    // for a 32 bit signed integer, there will be 31 bits.\\n    // So we start at 30 and go down to 0. (from MSB to LSB)\\n    let index = 30;\\n    let node = this.root;\\n    while(index >= 0) {\\n      // create a mask, for index 30, it\\'ll be Math.pow(2, 30)\\n      let mask = 1 << index;\\n      // get the bit value at current position, Bitwise AND will\\n      // be positive if the bit is set, and 0 if it is unset.\\n      let bit = (number & mask) > 0 ? 1 : 0;\\n      if(!node.has(bit)) {\\n        node.set(bit, new Map());\\n      }\\n      node = node.get(bit);\\n      index--;\\n    }\\n  }\\n\\n  // tries to find number in Trie, if not, then the closest\\n  // possible\\n  search(number) {\\n    let ans = 0;\\n    let index = 30;\\n    let node = this.root;\\n    while(index >= 0) {\\n      let mask = 1 << index;\\n      let bit = (number & mask) > 0 ? 1 : 0;\\n      // found bit in Trie, proceed further\\n      if (node.has(bit)) {\\n        node = node.get(bit);\\n\\n      // bit is not present in Trie, proceed with\\n      // what is present there then\\n      } else {\\n        bit = bit === 0 ? 1 : 0\\n        node = node.get(bit);\\n      }\\n\\n      if (bit === 1) {\\n        ans = ans + mask;\\n      }\\n      index--;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852397,
                "title": "c-2-solutions-trie-solution-hashing-solution-easy-intuitive-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t* We have to maximize the bits from left to right. Basically try to make the left ones \\'1\\'\\n\\t* Let\\'s say we have maximized till i-1th bit (31, 30, ... i-1, i, ....0) and say we have got\\n\\t* a ans = m till now (11011..ith...000000). We can now only check the pairs, which on XOR\\n\\t* gives us the same as m till i-1th bit. We want the ith bit to be 1, greedy m = 11011...1..000\\n\\t* It might or might not be possible to get. Let\\'s check:\\n\\t* Add all the nos in a set. Use the fact that if a^b=c ==> a^c=b. So num1^num2 = ans ==> num1^ans = num2\\n\\t* Think of it similar to (a+b=c) problem. Where you have to find pairs, given c.\\n\\t* Iterarate on nums and check if there is some number in our set such that it has same starting i bits as ans^numi = k,\\n\\t* How to do that? Rather than inserting nums in set, insert nums&(11111..till_i_th..00000) in the set. Done!!!!\\n\\t*/\\n\\n\\tint n;\\n\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\tn = nums.size();\\n\\n\\t\\tint ans = 0, mask = 0;\\n\\t\\tfor (int i = 31; i >= 0; --i) {\\n\\t\\t\\tmask = mask | (1 << i);\\n\\t\\t\\tint greedyAns = (ans | (1 << i));\\n\\t\\t\\t//Check if possible\\n\\t\\t\\tunordered_set<int> s;\\n\\t\\t\\tfor (auto &num : nums) {\\n\\t\\t\\t\\t//We basically insert with first i bits conserved and the rest of the bits are 0 after i\\n\\t\\t\\t\\ts.insert(num & mask);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto &prefix : s) {\\n\\t\\t\\t\\tif (s.find(greedyAns ^ prefix) != s.end()) {\\n\\t\\t\\t\\t\\tans = greedyAns;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\nBelow is the standard solution using trie\\n```\\n#define trav(a, x) for(auto& a : x)\\nclass trie {\\npublic:\\n\\ttrie* left;\\n\\ttrie* right;\\n\\tint val;\\n\\n\\ttrie(int val) {\\n\\t\\tthis->left = NULL;\\n\\t\\tthis->right = NULL;\\n\\t\\tthis->val = val;\\n\\t}\\n\\n\\tvoid add(int num) {\\n\\t\\ttrie* temp = this;\\n\\t\\tfor (int i = 31; i >= 0; --i) {\\n\\t\\t\\tint bit = ((1 << i) & num) != 0;\\n\\t\\t\\tif (bit) {\\n\\t\\t\\t\\tif (temp->right) {\\n\\t\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp->right = new trie(1);\\n\\t\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (temp->left) {\\n\\t\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp->left = new trie(0);\\n\\t\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n};\\n\\nclass Solution {\\npublic:\\n\\tSolution() {\\n\\t\\tios::sync_with_stdio(false);\\n\\t\\tcin.tie(NULL);\\n\\t\\tcout.tie(NULL);\\n\\t}\\n\\n\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\tauto temp = new trie(2);\\n\\t\\tint n = nums.size();\\n\\n\\t\\ttrav(elem, nums) {\\n\\t\\t\\ttemp->add(elem);\\n\\t\\t}\\n\\n\\t\\tint ans = 0;\\n\\t\\ttrav(elem, nums) {\\n\\t\\t\\tauto mover = temp;\\n\\t\\t\\tint maxXorFor = 0;\\n\\n\\t\\t\\tfor (int i = 31; i >= 0; --i) {\\n\\t\\t\\t\\tint bit = ((1 << i) & elem) != 0;\\n\\t\\t\\t\\tint bitToAdd = 0;\\n\\t\\t\\t\\tif (bit) {\\n\\t\\t\\t\\t\\t//Look for 0\\n\\t\\t\\t\\t\\tbitToAdd = (mover->left != NULL);\\n\\t\\t\\t\\t\\tif (bitToAdd) mover = mover->left;\\n\\t\\t\\t\\t\\telse mover = mover->right;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t//Look for 1 as 0^1=1\\n\\t\\t\\t\\t\\tbitToAdd = (mover->right != NULL);\\n\\t\\t\\t\\t\\tif (bitToAdd) mover = mover->right;\\n\\t\\t\\t\\t\\telse mover = mover->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxXorFor = ((bitToAdd << i) | (maxXorFor));\\n\\t\\t\\t}\\n\\t\\t\\tans = max(maxXorFor, ans);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t* We have to maximize the bits from left to right. Basically try to make the left ones \\'1\\'\\n\\t* Let\\'s say we have maximized till i-1th bit (31, 30, ... i-1, i, ....0) and say we have got\\n\\t* a ans = m till now (11011..ith...000000). We can now only check the pairs, which on XOR\\n\\t* gives us the same as m till i-1th bit. We want the ith bit to be 1, greedy m = 11011...1..000\\n\\t* It might or might not be possible to get. Let\\'s check:\\n\\t* Add all the nos in a set. Use the fact that if a^b=c ==> a^c=b. So num1^num2 = ans ==> num1^ans = num2\\n\\t* Think of it similar to (a+b=c) problem. Where you have to find pairs, given c.\\n\\t* Iterarate on nums and check if there is some number in our set such that it has same starting i bits as ans^numi = k,\\n\\t* How to do that? Rather than inserting nums in set, insert nums&(11111..till_i_th..00000) in the set. Done!!!!\\n\\t*/\\n\\n\\tint n;\\n\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\tn = nums.size();\\n\\n\\t\\tint ans = 0, mask = 0;\\n\\t\\tfor (int i = 31; i >= 0; --i) {\\n\\t\\t\\tmask = mask | (1 << i);\\n\\t\\t\\tint greedyAns = (ans | (1 << i));\\n\\t\\t\\t//Check if possible\\n\\t\\t\\tunordered_set<int> s;\\n\\t\\t\\tfor (auto &num : nums) {\\n\\t\\t\\t\\t//We basically insert with first i bits conserved and the rest of the bits are 0 after i\\n\\t\\t\\t\\ts.insert(num & mask);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto &prefix : s) {\\n\\t\\t\\t\\tif (s.find(greedyAns ^ prefix) != s.end()) {\\n\\t\\t\\t\\t\\tans = greedyAns;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\n#define trav(a, x) for(auto& a : x)\\nclass trie {\\npublic:\\n\\ttrie* left;\\n\\ttrie* right;\\n\\tint val;\\n\\n\\ttrie(int val) {\\n\\t\\tthis->left = NULL;\\n\\t\\tthis->right = NULL;\\n\\t\\tthis->val = val;\\n\\t}\\n\\n\\tvoid add(int num) {\\n\\t\\ttrie* temp = this;\\n\\t\\tfor (int i = 31; i >= 0; --i) {\\n\\t\\t\\tint bit = ((1 << i) & num) != 0;\\n\\t\\t\\tif (bit) {\\n\\t\\t\\t\\tif (temp->right) {\\n\\t\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp->right = new trie(1);\\n\\t\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (temp->left) {\\n\\t\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp->left = new trie(0);\\n\\t\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n};\\n\\nclass Solution {\\npublic:\\n\\tSolution() {\\n\\t\\tios::sync_with_stdio(false);\\n\\t\\tcin.tie(NULL);\\n\\t\\tcout.tie(NULL);\\n\\t}\\n\\n\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\tauto temp = new trie(2);\\n\\t\\tint n = nums.size();\\n\\n\\t\\ttrav(elem, nums) {\\n\\t\\t\\ttemp->add(elem);\\n\\t\\t}\\n\\n\\t\\tint ans = 0;\\n\\t\\ttrav(elem, nums) {\\n\\t\\t\\tauto mover = temp;\\n\\t\\t\\tint maxXorFor = 0;\\n\\n\\t\\t\\tfor (int i = 31; i >= 0; --i) {\\n\\t\\t\\t\\tint bit = ((1 << i) & elem) != 0;\\n\\t\\t\\t\\tint bitToAdd = 0;\\n\\t\\t\\t\\tif (bit) {\\n\\t\\t\\t\\t\\t//Look for 0\\n\\t\\t\\t\\t\\tbitToAdd = (mover->left != NULL);\\n\\t\\t\\t\\t\\tif (bitToAdd) mover = mover->left;\\n\\t\\t\\t\\t\\telse mover = mover->right;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t//Look for 1 as 0^1=1\\n\\t\\t\\t\\t\\tbitToAdd = (mover->right != NULL);\\n\\t\\t\\t\\t\\tif (bitToAdd) mover = mover->right;\\n\\t\\t\\t\\t\\telse mover = mover->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxXorFor = ((bitToAdd << i) | (maxXorFor));\\n\\t\\t\\t}\\n\\t\\t\\tans = max(maxXorFor, ans);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 849682,
                "title": "maximum-xor-python3-using-tries",
                "content": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        bin_list = [\"{0:b}\".format(el) for el in nums]\\n        max_len = len(max(bin_list, key = lambda x: len(x)))\\n        bin_list = [\"0\"*(max_len - len(el)) + el for el in bin_list]\\n        ans = float(\\'-inf\\')\\n        # create a trie and for each representation try to find the exact opposite as much as possible\\n        trie = {}\\n        for word in bin_list:\\n            parent = trie\\n            for char in (word):\\n                if char in parent:\\n                    parent = parent[char]\\n                else:\\n                    parent[char] = {}\\n                    parent = parent[char]\\n        # now for each item in binary_list, try to find the opposite\\n        ans = float(\\'-inf\\')\\n        for word in bin_list:\\n            parent = trie\\n            curr = \\'\\'\\n            for idx, char in enumerate(word):\\n                to_find = \\'1\\' if char == \\'0\\' else \\'0\\'\\n                if to_find in parent:\\n                    curr += to_find\\n                    parent = parent[to_find]\\n                else:\\n                    curr += char\\n                    parent = parent[char]\\n                if idx == len(word) - 1:\\n                    ans = max(ans, int(word, 2) ^ int(curr, 2) )\\n        return ans  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        bin_list = [\"{0:b}\".format(el) for el in nums]\\n        max_len = len(max(bin_list, key = lambda x: len(x)))\\n        bin_list = [\"0\"*(max_len - len(el)) + el for el in bin_list]\\n        ans = float(\\'-inf\\')\\n        # create a trie and for each representation try to find the exact opposite as much as possible\\n        trie = {}\\n        for word in bin_list:\\n            parent = trie\\n            for char in (word):\\n                if char in parent:\\n                    parent = parent[char]\\n                else:\\n                    parent[char] = {}\\n                    parent = parent[char]\\n        # now for each item in binary_list, try to find the opposite\\n        ans = float(\\'-inf\\')\\n        for word in bin_list:\\n            parent = trie\\n            curr = \\'\\'\\n            for idx, char in enumerate(word):\\n                to_find = \\'1\\' if char == \\'0\\' else \\'0\\'\\n                if to_find in parent:\\n                    curr += to_find\\n                    parent = parent[to_find]\\n                else:\\n                    curr += char\\n                    parent = parent[char]\\n                if idx == len(word) - 1:\\n                    ans = max(ans, int(word, 2) ^ int(curr, 2) )\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 849153,
                "title": "max-xor-pair-using-tries-c",
                "content": "left pointer denotes a zero and right denotes a one.\\n```\\n\\nclass Node{\\n   \\n    public:\\n     Node*left;\\n    Node*right;   \\n};\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    void insert(int a,Node*root){\\n        \\n         Node*curr=root;\\n        \\n         for(int i=31;i>=0;i--){\\n              int last_bit=(a>>i) &1;\\n               if(last_bit==0){\\n\\n                 if(curr->left==NULL){\\n                     \\n                     curr->left=new Node();\\n                     \\n                 }\\n                   curr=curr->left;\\n               \\n               \\n               }else{\\n                   if(curr->right==NULL){\\n                       curr->right=new Node();\\n                   }\\n                   curr=curr->right;\\n               }\\n         }\\n        return;\\n        \\n    }\\n    \\n    \\n    \\n    int max_xor(int a,Node*root,vector<int> nums){\\n        Node*curr=root;\\n        int max_xor_val=INT_MIN;\\n        int curr_xor=0;\\n        for(int i=31;i>=0;i--){\\n            \\n            int last_bit=(a>>i)&1;\\n            if(last_bit==0){\\n                //if bit is 0 then we try to look for a bit which is 1 in the trie to maximize xor\\n                if(curr->right){\\n                    curr=curr->right;\\n                    curr_xor+=(int)pow(2,i);\\n                }else{\\n                    curr=curr->left;\\n                }\\n                \\n            }else{\\n\\t\\t\\t//if bit is 1 then we try to look for a bit which is 0 in the trie to maximize xor\\n                if(curr->left){\\n                    curr=curr->left;\\n                    curr_xor+=(int)pow(2,i);\\n                }else{\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        max_xor_val=max(curr_xor,max_xor_val);\\n        return max_xor_val;    \\n    }\\n    \\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        Node*root=new Node();\\n        int n=nums.size();\\n        int result=INT_MIN;\\n        if(n==0){\\n            return 0;\\n        }\\n        for(int i=0;i<n;i++){\\n          insert(nums[i],root);\\n          int ans=max_xor(nums[i],root,nums);\\n          result=max(result,ans);\\n        \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Node{\\n   \\n    public:\\n     Node*left;\\n    Node*right;   \\n};\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    void insert(int a,Node*root){\\n        \\n         Node*curr=root;\\n        \\n         for(int i=31;i>=0;i--){\\n              int last_bit=(a>>i) &1;\\n               if(last_bit==0){\\n\\n                 if(curr->left==NULL){\\n                     \\n                     curr->left=new Node();\\n                     \\n                 }\\n                   curr=curr->left;\\n               \\n               \\n               }else{\\n                   if(curr->right==NULL){\\n                       curr->right=new Node();\\n                   }\\n                   curr=curr->right;\\n               }\\n         }\\n        return;\\n        \\n    }\\n    \\n    \\n    \\n    int max_xor(int a,Node*root,vector<int> nums){\\n        Node*curr=root;\\n        int max_xor_val=INT_MIN;\\n        int curr_xor=0;\\n        for(int i=31;i>=0;i--){\\n            \\n            int last_bit=(a>>i)&1;\\n            if(last_bit==0){\\n                //if bit is 0 then we try to look for a bit which is 1 in the trie to maximize xor\\n                if(curr->right){\\n                    curr=curr->right;\\n                    curr_xor+=(int)pow(2,i);\\n                }else{\\n                    curr=curr->left;\\n                }\\n                \\n            }else{\\n\\t\\t\\t//if bit is 1 then we try to look for a bit which is 0 in the trie to maximize xor\\n                if(curr->left){\\n                    curr=curr->left;\\n                    curr_xor+=(int)pow(2,i);\\n                }else{\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        max_xor_val=max(curr_xor,max_xor_val);\\n        return max_xor_val;    \\n    }\\n    \\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        Node*root=new Node();\\n        int n=nums.size();\\n        int result=INT_MIN;\\n        if(n==0){\\n            return 0;\\n        }\\n        for(int i=0;i<n;i++){\\n          insert(nums[i],root);\\n          int ans=max_xor(nums[i],root,nums);\\n          result=max(result,ans);\\n        \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292560,
                "title": "prefix-tree-thinking-process",
                "content": ">Intuitively, \\n```\\nfor i 0 .. n\\n  for j i+1 .. n\\n    overallMax = max(overallMall, nums[i] ^ nums[j])\\n```\\n> That takes O(n^2) time.\\n\\n> However, O(n) time is required. \\n> \\n> In other words, we have to enable nums[i] to know **which element paired with itself can form the maximum XOR**. Then we calculate the maximum XOR for each num and aggregate the overall maximum.\\n\\n\\n> Given nums[i], how does the target element (paired with nums[i] that makes the maximum XOR) look like?\\nThe target element should share shortest common prefixes  with nums[i].\\n\\n> How do we tell which element shares the shortest common prefixes with nums[i]?\\n> Prefix tree\\n\\n> What is a node in the prefix tree?\\n> zero means the bit is not set\\n> one means the bit is set\\n> the height of a node indicates which bit it is\\n\\n```\\nclass Solution {\\n    private Node root;\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        root = new Node();\\n        \\n        // Build a trie from nums\\n        for (int num : nums) {\\n            insert(num);\\n        }\\n        \\n        int overallMax = Integer.MIN_VALUE;\\n        // Search for num in the trie, and get its maximum XOR to update the overal maximum\\n        for (int num : nums) {\\n            overallMax = Math.max(overallMax, search(num));\\n        }\\n        \\n        return overallMax;        \\n    }\\n    \\n    private void insert(int num) {\\n        Node ptr = root;\\n        // i indicates bit position for the rightmost bit is at position 0\\n        // i also indicates node\\'s depth in trie, i.e. the length of the path from root to the end\\n        for (int i = 31; i >= 0; i--) {\\n            int val = (num >> i) & 1;\\n            if (val == 1) {\\n                if (ptr.one == null) {\\n                    ptr.one = new Node();\\n                }\\n                ptr = ptr.one;\\n            } else {\\n                if (ptr.zero == null) {\\n                    ptr.zero = new Node();\\n                }\\n                ptr = ptr.zero;\\n            }\\n        }\\n    }\\n    \\n    private int search(int num) {\\n        Node ptr = root;\\n        int maxXOR = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int val = (num >> i) & 1;\\n            if (val == 1) {\\n                if (ptr.zero != null) {\\n                    ptr = ptr.zero;\\n                    maxXOR += (1 << i);\\n                } else {\\n                    ptr = ptr.one;\\n                }\\n            } else {\\n                if (ptr.one != null) {\\n                    ptr = ptr.one;\\n                    maxXOR += (1 << i);\\n                } else {\\n                    ptr = ptr.zero;\\n                }\\n            }\\n        }\\n        return maxXOR;\\n    }\\n    \\n    class Node {\\n        Node zero;\\n        Node one;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfor i 0 .. n\\n  for j i+1 .. n\\n    overallMax = max(overallMall, nums[i] ^ nums[j])\\n```\n```\\nclass Solution {\\n    private Node root;\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        root = new Node();\\n        \\n        // Build a trie from nums\\n        for (int num : nums) {\\n            insert(num);\\n        }\\n        \\n        int overallMax = Integer.MIN_VALUE;\\n        // Search for num in the trie, and get its maximum XOR to update the overal maximum\\n        for (int num : nums) {\\n            overallMax = Math.max(overallMax, search(num));\\n        }\\n        \\n        return overallMax;        \\n    }\\n    \\n    private void insert(int num) {\\n        Node ptr = root;\\n        // i indicates bit position for the rightmost bit is at position 0\\n        // i also indicates node\\'s depth in trie, i.e. the length of the path from root to the end\\n        for (int i = 31; i >= 0; i--) {\\n            int val = (num >> i) & 1;\\n            if (val == 1) {\\n                if (ptr.one == null) {\\n                    ptr.one = new Node();\\n                }\\n                ptr = ptr.one;\\n            } else {\\n                if (ptr.zero == null) {\\n                    ptr.zero = new Node();\\n                }\\n                ptr = ptr.zero;\\n            }\\n        }\\n    }\\n    \\n    private int search(int num) {\\n        Node ptr = root;\\n        int maxXOR = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int val = (num >> i) & 1;\\n            if (val == 1) {\\n                if (ptr.zero != null) {\\n                    ptr = ptr.zero;\\n                    maxXOR += (1 << i);\\n                } else {\\n                    ptr = ptr.one;\\n                }\\n            } else {\\n                if (ptr.one != null) {\\n                    ptr = ptr.one;\\n                    maxXOR += (1 << i);\\n                } else {\\n                    ptr = ptr.zero;\\n                }\\n            }\\n        }\\n        return maxXOR;\\n    }\\n    \\n    class Node {\\n        Node zero;\\n        Node one;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91048,
                "title": "python-trie-one-pass-through-input-array",
                "content": "```\\nclass Solution(object):\\n    def findMaximumXOR(self, nums):\\n        def Trie(): \\n            return collections.defaultdict(Trie)\\n        \\n        root = Trie()\\n        best = 0\\n        \\n        for num in nums:\\n            candidate = 0\\n            cur = this = root\\n            for i in range(32)[::-1]:\\n                curBit = num >> i & 1\\n                this = this[curBit]\\n                if curBit ^ 1 in cur:\\n                    candidate += 1 << i\\n                    cur = cur[curBit ^ 1]\\n                else:\\n                    cur = cur[curBit]\\n            best = max(candidate, best)\\n        return best\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMaximumXOR(self, nums):\\n        def Trie(): \\n            return collections.defaultdict(Trie)\\n        \\n        root = Trie()\\n        best = 0\\n        \\n        for num in nums:\\n            candidate = 0\\n            cur = this = root\\n            for i in range(32)[::-1]:\\n                curBit = num >> i & 1\\n                this = this[curBit]\\n                if curBit ^ 1 in cur:\\n                    candidate += 1 << i\\n                    cur = cur[curBit ^ 1]\\n                else:\\n                    cur = cur[curBit]\\n            best = max(candidate, best)\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765613,
                "title": "maximum-xor-of-two-numbers-in-an-array",
                "content": "**Very simple trie code please upvote**\\n```\\n\\nstruct Node{\\n  Node*links[2];\\n  bool isContains(int bit){\\n    return (links[bit] != NULL);\\n  }\\n  void put(int bit , Node* node){\\n    links[bit] = node;\\n  }\\n  \\n  Node* get(int bit)\\n  {\\n    return links[bit];\\n  }\\n};\\n\\nclass Trie{\\n  \\n  private:\\n  \\n   Node* root;\\n  \\n  public:\\n  Trie(){\\n    root = new Node();\\n  }\\n  \\n  void insert(int num)\\n  {\\n    Node* node = root;\\n    int maxnum =0 ;\\n    for(int i = 31 ; i>=0 ; i-- ){\\n       int bit = (num >> i) & 1;\\n       if(!node->isContains(bit)){\\n         node->put(bit , new Node());\\n       }\\n      node = node->get(bit);\\n    }\\n  }\\n  \\n  public:\\n  \\n  int getMax(int num){\\n    Node* node = root;\\n    int maxnum =0;\\n    for(int i = 31 ;i >=0; i--){\\n      int bit = (num >> i) & 1;\\n\\t  // search for all opposite bit they will give maximun xor (1^0) == 1 or (0^1) ==1\\n\\t  // if we not find opposite bit continue with the original bit\\n      if(node->isContains(!bit)){\\n        maxnum = maxnum | (1<<i);\\n        node = node->get(!bit);\\n      }else{\\n        node = node->get(bit);\\n      }\\n    }\\n    return maxnum;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie node;\\n        for(auto it : nums) node.insert(it);\\n        int maxi = 0;\\n      // loop over all the elements find max\\n       for(auto it : nums){\\n         maxi = max(maxi , node.getMax(it));\\n       }\\n      return maxi;\\n      return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct Node{\\n  Node*links[2];\\n  bool isContains(int bit){\\n    return (links[bit] != NULL);\\n  }\\n  void put(int bit , Node* node){\\n    links[bit] = node;\\n  }\\n  \\n  Node* get(int bit)\\n  {\\n    return links[bit];\\n  }\\n};\\n\\nclass Trie{\\n  \\n  private:\\n  \\n   Node* root;\\n  \\n  public:\\n  Trie(){\\n    root = new Node();\\n  }\\n  \\n  void insert(int num)\\n  {\\n    Node* node = root;\\n    int maxnum =0 ;\\n    for(int i = 31 ; i>=0 ; i-- ){\\n       int bit = (num >> i) & 1;\\n       if(!node->isContains(bit)){\\n         node->put(bit , new Node());\\n       }\\n      node = node->get(bit);\\n    }\\n  }\\n  \\n  public:\\n  \\n  int getMax(int num){\\n    Node* node = root;\\n    int maxnum =0;\\n    for(int i = 31 ;i >=0; i--){\\n      int bit = (num >> i) & 1;\\n\\t  // search for all opposite bit they will give maximun xor (1^0) == 1 or (0^1) ==1\\n\\t  // if we not find opposite bit continue with the original bit\\n      if(node->isContains(!bit)){\\n        maxnum = maxnum | (1<<i);\\n        node = node->get(!bit);\\n      }else{\\n        node = node->get(bit);\\n      }\\n    }\\n    return maxnum;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie node;\\n        for(auto it : nums) node.insert(it);\\n        int maxi = 0;\\n      // loop over all the elements find max\\n       for(auto it : nums){\\n         maxi = max(maxi , node.getMax(it));\\n       }\\n      return maxi;\\n      return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723749,
                "title": "c-o-31-n-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int xor_arr(vector <int> & nums){\\n        int mx = 0;\\n        //Max Value\\n        int mask = 0;\\n        // Prefix Mask -> 10000, 11000, 11100, 11110, 11111\\n        set <int> se;\\n        \\n        for(int bit=30;bit >=0;--bit){\\n            mask |= (1 << bit);\\n            for(int i=0;i<nums.size();++i){\\n                se.insert(nums[i] & mask);\\n                //this is important such that binary representation of num (from nums) only includes till\\n                //ith bit.\\n            }\\n            \\n            int newMax = mx | (1 << bit);\\n            // Check whether we can improve mx value by turning on the ith bit in mx\\n            // such that newMax is obtained\\n            // if a^b = x then a^x = b;\\n            for(auto prefix : se){\\n                \\n               if(se.count(newMax ^ prefix)){\\n                    mx = newMax;\\n                    break;\\n                }\\n            }\\n            \\n            se.clear();\\n        }\\n        return mx;\\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        return xor_arr(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xor_arr(vector <int> & nums){\\n        int mx = 0;\\n        //Max Value\\n        int mask = 0;\\n        // Prefix Mask -> 10000, 11000, 11100, 11110, 11111\\n        set <int> se;\\n        \\n        for(int bit=30;bit >=0;--bit){\\n            mask |= (1 << bit);\\n            for(int i=0;i<nums.size();++i){\\n                se.insert(nums[i] & mask);\\n                //this is important such that binary representation of num (from nums) only includes till\\n                //ith bit.\\n            }\\n            \\n            int newMax = mx | (1 << bit);\\n            // Check whether we can improve mx value by turning on the ith bit in mx\\n            // such that newMax is obtained\\n            // if a^b = x then a^x = b;\\n            for(auto prefix : se){\\n                \\n               if(se.count(newMax ^ prefix)){\\n                    mx = newMax;\\n                    break;\\n                }\\n            }\\n            \\n            se.clear();\\n        }\\n        return mx;\\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        return xor_arr(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723185,
                "title": "javascript-slow-but-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/9867eb02-9c67-424d-9850-d4a92bddd499_1643295179.0336132.png)\\n```    \\nlet set = [...new Set(nums)]\\nif(set.length === 1) return 0\\nlet max = set[0]^set[1]\\nfor(let i = 0;i<set.length;i++){\\n\\tfor(let j=i+1;j<set.length;j++){\\n\\t   max = Math.max(set[i]^set[j], max)\\n\\t}   \\n}\\nreturn max",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/9867eb02-9c67-424d-9850-d4a92bddd499_1643295179.0336132.png)\\n```    \\nlet set = [...new Set(nums)]\\nif(set.length === 1) return 0\\nlet max = set[0]^set[1]\\nfor(let i = 0;i<set.length;i++){\\n\\tfor(let j=i+1;j<set.length;j++){\\n\\t   max = Math.max(set[i]^set[j], max)\\n\\t}   \\n}\\nreturn max",
                "codeTag": "Unknown"
            },
            {
                "id": 1397500,
                "title": "c-small-and-effective-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& arr) {\\n        \\n        int maxx = 0,n = arr.size(), mask = 0;\\n        set<int> s;\\n        for (int i = 30; i >= 0; i--) {\\n            mask |= (1 << i);\\n\\n            for (int i = 0; i < n; ++i) \\n                s.insert(arr[i] & mask);\\n\\n            int newMaxx = maxx | (1 << i);\\n            for (int prefix : se) {\\n                 if (se.count(newMaxx ^ prefix)) {\\n                    maxx = newMaxx;\\n                    break;\\n                }\\n            }\\n            se.clear();\\n        }\\n    return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& arr) {\\n        \\n        int maxx = 0,n = arr.size(), mask = 0;\\n        set<int> s;\\n        for (int i = 30; i >= 0; i--) {\\n            mask |= (1 << i);\\n\\n            for (int i = 0; i < n; ++i) \\n                s.insert(arr[i] & mask);\\n\\n            int newMaxx = maxx | (1 << i);\\n            for (int prefix : se) {\\n                 if (se.count(newMaxx ^ prefix)) {\\n                    maxx = newMaxx;\\n                    break;\\n                }\\n            }\\n            se.clear();\\n        }\\n    return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833833,
                "title": "20-line-java-2ms-sort-two-pointer",
                "content": "Based on \\nInvariant 1: If every 1 bit in a is also 1 in b (a & ~b = 0), then a ^ b = b - a\\nInvariant 2: For a given number x in nums, pick y in nums that maximize x ^ y, y must be next to x ^ o.\\n  (can be proved with proof by contradition)\\n```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int o = 0;\\n        for (int n : nums) {\\n            o |= n;\\n        }\\n        int max = 0;\\n        int i = 0, j = nums.length - 1;\\n        while (i < j) {\\n            max = Math.max(max, nums[i] ^ nums[j]);\\n            if (o - nums[i] > nums[j]) { // Equivalent to: nums[i] ^ o > nums[j]\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int o = 0;\\n        for (int n : nums) {\\n            o |= n;\\n        }\\n        int max = 0;\\n        int i = 0, j = nums.length - 1;\\n        while (i < j) {\\n            max = Math.max(max, nums[i] ^ nums[j]);\\n            if (o - nums[i] > nums[j]) { // Equivalent to: nums[i] ^ o > nums[j]\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358189,
                "title": "java-o-n-solution-with-chinese-explanation-video",
                "content": "Video:\\nhttps://youtu.be/blsm1fA9JHQ\\n```\\n/*\\n    [3, 10, 5, 25, 2, 8] = [00011, 01010, 00101, 11001, 00010, 01000]\\n    a^b=c, a^c=b,\\n    a^b=max, a^max=b\\n    mask = 10000 -> [00000, 00000, 00000, 10000, 00000, 00000], maximum = 10000 ? true \\n    mask = 11000 -> [00000, 01000, 00000, 11000, 00000, 01000], maximum = 11000 ? true\\n    mask = 11100 -> [00000, 01000, 00100, 11000, 00000, 01000], maximum = 11100 ? true\\n    mask = 11110 -> [00010, 01010, 00100, 11000, 00010, 01000], maximum = 11110 ? false -> maximum = 11100\\n    mask = 11111 -> [00011, 01010, 00101, 11001, 00010, 01000], maximum = 11101 ? false -> maximum = 11100\\n    maximum = 11100 = 28\\n    \\n*/\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int maximum = 0;\\n        int mask = 0;\\n        for(int i = 30; i >= 0; i--) {\\n            int one = 1 << i;\\n            mask = mask | one;\\n            HashSet<Integer> set = new HashSet<>();\\n            for(int num : nums) set.add(mask & num);\\n            for(int val : set) {\\n                if(set.contains(val ^ (maximum | one))) {\\n                    maximum = maximum | one;\\n                    break;\\n                }\\n            }\\n        }\\n        return maximum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    [3, 10, 5, 25, 2, 8] = [00011, 01010, 00101, 11001, 00010, 01000]\\n    a^b=c, a^c=b,\\n    a^b=max, a^max=b\\n    mask = 10000 -> [00000, 00000, 00000, 10000, 00000, 00000], maximum = 10000 ? true \\n    mask = 11000 -> [00000, 01000, 00000, 11000, 00000, 01000], maximum = 11000 ? true\\n    mask = 11100 -> [00000, 01000, 00100, 11000, 00000, 01000], maximum = 11100 ? true\\n    mask = 11110 -> [00010, 01010, 00100, 11000, 00010, 01000], maximum = 11110 ? false -> maximum = 11100\\n    mask = 11111 -> [00011, 01010, 00101, 11001, 00010, 01000], maximum = 11101 ? false -> maximum = 11100\\n    maximum = 11100 = 28\\n    \\n*/\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int maximum = 0;\\n        int mask = 0;\\n        for(int i = 30; i >= 0; i--) {\\n            int one = 1 << i;\\n            mask = mask | one;\\n            HashSet<Integer> set = new HashSet<>();\\n            for(int num : nums) set.add(mask & num);\\n            for(int val : set) {\\n                if(set.contains(val ^ (maximum | one))) {\\n                    maximum = maximum | one;\\n                    break;\\n                }\\n            }\\n        }\\n        return maximum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276621,
                "title": "c-bit-manipulation-solution-with-o-n-time-and-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    // \\u65F6\\u95F4\\u590D\\u6742\\u5EA6o(31*n) = o(n)\\uFF0C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6o(n)\\n    int findMaximumXOR(vector<int>& nums) {\\n        int mask = 0; // mask = 1111..1000..00\\uFF0C\\u8868\\u793A\\u6700\\u9AD8\\u4F4D\\u5230\\u7B2Ci\\u4F4D\\u4E3A1\\uFF0C\\u5176\\u4F59\\u4F4D\\u4E3A0\\n        int test_max = 0;\\n        int max = 0;\\n        unordered_set<int> s; // set\\u8BB0\\u5F55\\u7684\\u662F\\u5143\\u7D20\\u4E2D\\u7B2Ci\\u4F4D\\u4E3A1\\u7684\\u6240\\u6709\\u60C5\\u51B5\\uFF0C\\u4F8B\\u5982mask = 11...1000\\uFF0C nums = [12, 10, 7] = [1100, 1010, 0111]\\uFF0C\\u90A3\\u4E48s = [1000, 1000, 0000]\\uFF0C\\u56E0\\u4E3A\\u53EA\\u670912\\u548C10\\u7684\\u7B2C4\\u4F4D\\u662F\\u4E3A1\\n        for(int i = 30; i >= 0; --i){\\n            mask |= 1 << i;\\n            for(int num : nums){\\n                s.insert(num & mask);\\n            }\\n            // \\u5982\\u679Cmax\\u7684\\u7B2Ci\\u4F4D\\u4E3A1\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A1\\u80AF\\u5B9A\\u7531\\u67D0\\u4E24\\u4E2A\\u5143\\u7D20\\u7684\\u7B2Ci\\u4F4D\\u7684\\u5F02\\u6216\\u751F\\u6210\\n            // \\u6240\\u4EE5\\u7528\\u4E00\\u4E2Atest_max\\u6765\\u6D4B\\u8BD5\\u7B2Ci\\u4F4D\\u662F\\u5426\\u4E3A1\\uFF0Ctest_max == a ^ b\\uFF0C\\u5176\\u4E2Da\\u548Cb\\u90FD\\u662Fs\\u4E2D\\u7684\\u5143\\u7D20\\uFF0C\\n            // \\u518D\\u7531\\u5F02\\u6216\\u7684\\u6027\\u8D28\\uFF0Cc = a ^ b\\uFF0C\\u5219c ^ b = a ^ b ^ b = a ^ (b ^ b) = a\\uFF0C\\u5373a = c ^ b\\n            // test_max == a ^ b\\u53EF\\u4EE5\\u8F6C\\u6362\\u4E3A\\u5224\\u65ADtest_max ^ a\\u662F\\u5426\\u5728s\\u4E2D\\n            test_max = max | 1 << i; \\n            for(int s_val : s){\\n                if(s.find(s_val ^ test_max) != s.end()){\\n                    max = test_max; // test_max\\u6EE1\\u8DB3\\u8981\\u6C42\\uFF0C\\u5219\\u66F4\\u65B0max\\n                    break;\\n                }\\n            }\\n            s.clear();\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // \\u65F6\\u95F4\\u590D\\u6742\\u5EA6o(31*n) = o(n)\\uFF0C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6o(n)\\n    int findMaximumXOR(vector<int>& nums) {\\n        int mask = 0; // mask = 1111..1000..00\\uFF0C\\u8868\\u793A\\u6700\\u9AD8\\u4F4D\\u5230\\u7B2Ci\\u4F4D\\u4E3A1\\uFF0C\\u5176\\u4F59\\u4F4D\\u4E3A0\\n        int test_max = 0;\\n        int max = 0;\\n        unordered_set<int> s; // set\\u8BB0\\u5F55\\u7684\\u662F\\u5143\\u7D20\\u4E2D\\u7B2Ci\\u4F4D\\u4E3A1\\u7684\\u6240\\u6709\\u60C5\\u51B5\\uFF0C\\u4F8B\\u5982mask = 11...1000\\uFF0C nums = [12, 10, 7] = [1100, 1010, 0111]\\uFF0C\\u90A3\\u4E48s = [1000, 1000, 0000]\\uFF0C\\u56E0\\u4E3A\\u53EA\\u670912\\u548C10\\u7684\\u7B2C4\\u4F4D\\u662F\\u4E3A1\\n        for(int i = 30; i >= 0; --i){\\n            mask |= 1 << i;\\n            for(int num : nums){\\n                s.insert(num & mask);\\n            }\\n            // \\u5982\\u679Cmax\\u7684\\u7B2Ci\\u4F4D\\u4E3A1\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A1\\u80AF\\u5B9A\\u7531\\u67D0\\u4E24\\u4E2A\\u5143\\u7D20\\u7684\\u7B2Ci\\u4F4D\\u7684\\u5F02\\u6216\\u751F\\u6210\\n            // \\u6240\\u4EE5\\u7528\\u4E00\\u4E2Atest_max\\u6765\\u6D4B\\u8BD5\\u7B2Ci\\u4F4D\\u662F\\u5426\\u4E3A1\\uFF0Ctest_max == a ^ b\\uFF0C\\u5176\\u4E2Da\\u548Cb\\u90FD\\u662Fs\\u4E2D\\u7684\\u5143\\u7D20\\uFF0C\\n            // \\u518D\\u7531\\u5F02\\u6216\\u7684\\u6027\\u8D28\\uFF0Cc = a ^ b\\uFF0C\\u5219c ^ b = a ^ b ^ b = a ^ (b ^ b) = a\\uFF0C\\u5373a = c ^ b\\n            // test_max == a ^ b\\u53EF\\u4EE5\\u8F6C\\u6362\\u4E3A\\u5224\\u65ADtest_max ^ a\\u662F\\u5426\\u5728s\\u4E2D\\n            test_max = max | 1 << i; \\n            for(int s_val : s){\\n                if(s.find(s_val ^ test_max) != s.end()){\\n                    max = test_max; // test_max\\u6EE1\\u8DB3\\u8981\\u6C42\\uFF0C\\u5219\\u66F4\\u65B0max\\n                    break;\\n                }\\n            }\\n            s.clear();\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91058,
                "title": "31ms-o-n-java-solution-using-trie",
                "content": "We add the number into the trie and find the max possible XOR result at the same time.\\nNode.set() method will set the new node in the trie if needed and return the new node.\\nAfter setting the node, find the opposite bit in the trie to maximize the possible XOR result.\\n\\n```\\npublic class Solution {\\n    public class Node {\\n        Node one;\\n        Node zero;\\n        Node() {\\n            this.one = null;\\n            this.zero = null;\\n        }\\n        Node set(int n) {\\n            if (n == 0) {\\n                if (this.one == null) this.one = new Node();\\n                return this.one;\\n            }\\n            if (this.zero == null) this.zero = new Node();\\n            return this.zero;\\n        }\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        Node root = new Node();\\n        int re = 0;\\n        for (int num : nums) {\\n            int digit = num;\\n            int tmp = 0;\\n            Node setNode = root;\\n            Node findNode = root;\\n            int pos = 30;\\n            while (pos >= 0) {\\n                digit = (num >> pos) & 1;\\n                setNode = setNode.set(digit);\\n                if (digit == 1) {\\n                    if (findNode.one != null) {\\n                        tmp = tmp | (1 << pos);\\n                        findNode = findNode.one;\\n                    } else {\\n                        findNode = findNode.zero;\\n                    }\\n                } else {\\n                    if (findNode.zero != null) {\\n                        tmp = tmp | (1 << pos);\\n                        findNode = findNode.zero;\\n                    } else {\\n                        findNode = findNode.one;\\n                    }\\n                }\\n                pos--;\\n            }\\n            re = Math.max(re, tmp);\\n        }\\n        return re;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public class Node {\\n        Node one;\\n        Node zero;\\n        Node() {\\n            this.one = null;\\n            this.zero = null;\\n        }\\n        Node set(int n) {\\n            if (n == 0) {\\n                if (this.one == null) this.one = new Node();\\n                return this.one;\\n            }\\n            if (this.zero == null) this.zero = new Node();\\n            return this.zero;\\n        }\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        Node root = new Node();\\n        int re = 0;\\n        for (int num : nums) {\\n            int digit = num;\\n            int tmp = 0;\\n            Node setNode = root;\\n            Node findNode = root;\\n            int pos = 30;\\n            while (pos >= 0) {\\n                digit = (num >> pos) & 1;\\n                setNode = setNode.set(digit);\\n                if (digit == 1) {\\n                    if (findNode.one != null) {\\n                        tmp = tmp | (1 << pos);\\n                        findNode = findNode.one;\\n                    } else {\\n                        findNode = findNode.zero;\\n                    }\\n                } else {\\n                    if (findNode.zero != null) {\\n                        tmp = tmp | (1 << pos);\\n                        findNode = findNode.zero;\\n                    } else {\\n                        findNode = findNode.one;\\n                    }\\n                }\\n                pos--;\\n            }\\n            re = Math.max(re, tmp);\\n        }\\n        return re;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91051,
                "title": "ugly-but-straight-forward-python-o-n-trie-solution",
                "content": "Ugly but straight forward Python Trie solution, first build a Trie with all the nums; then try to \"pass\" each num in nums through that Trie, \\nif the path bifurcates at a node, took the opposite route,and update the current XOR result by adding 1 to the current bit.\\n```\\nclass Solution(object):\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        head=[None,None]\\n        for num in nums:\\n            node=head\\n            for bit in range(31,-1,-1):\\n                chd=int(bool(num&(1<<bit)))\\n                if node[chd]==None:\\n                    NewNode=[None,None]\\n                    node[chd]=NewNode\\n                    node=NewNode\\n                else:\\n                    node=node[chd]\\n        maxXor=0\\n        for num in nums:\\n            node=head\\n            curXor=0\\n            for bit in range(31,-1,-1):\\n                chd=int(bool(num&(1<<bit)))\\n                if node[1^chd]:\\n                    curXor|=1<<bit\\n                    node=node[1^chd]\\n                else:\\n                    node=node[chd] \\n            maxXor=max(maxXor,curXor)\\n            \\n        return maxXor\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        head=[None,None]\\n        for num in nums:\\n            node=head\\n            for bit in range(31,-1,-1):\\n                chd=int(bool(num&(1<<bit)))\\n                if node[chd]==None:\\n                    NewNode=[None,None]\\n                    node[chd]=NewNode\\n                    node=NewNode\\n                else:\\n                    node=node[chd]\\n        maxXor=0\\n        for num in nums:\\n            node=head\\n            curXor=0\\n            for bit in range(31,-1,-1):\\n                chd=int(bool(num&(1<<bit)))\\n                if node[1^chd]:\\n                    curXor|=1<<bit\\n                    node=node[1^chd]\\n                else:\\n                    node=node[chd] \\n            maxXor=max(maxXor,curXor)\\n            \\n        return maxXor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91122,
                "title": "java-simple-greedy-bit-manipulation-solution-o-2-n-time-with-explanation-without-hashmap",
                "content": "Hi there! I am posting my recursive solution based on bit manipulation. The idea is strightforward. Let us think about the resultant number. Well, it is clear that, in order to, maximize the resultant number, we have to maximize the number of set bits with higher order. In other words, starting from the left most possible bit position we check if there is a pair of numbers, such that their bits in the current position will   XOR\\'ed up to 1. Obviously there are only two options to satisfy that condition 1,0 or 0,1 for each bit position. Thus, we always divide the numbers into two parts, those that has set bits in current position and those that has zero bits in current position. Consequently if we can divide the numbers in such a way, it means we can obtain set bit by some combination in the current position. Otherwise, we decrease factor of two ( bit position) while we can\\'t divide the numbers and we didn\\'t reach the last bit position. For example \\n```\\n                       {1,2,3} <- bit position 1\\n                        /    \\\\\\n                    {1}      {2, 3} <- bit position 0\\n                    / \\\\        /  \\\\\\n                  X   {1}   {2}   {3}    \\n```\\nIn the example above, given array {1,2,3} we can start from bit position 1, because it is the highest bit order in current array. Then we divide it according to the values of current bit. Correspondingly {1} has 0 bit in position 1, whereas 2 and 3 have set bits. It means our resultant number has set bit in position 1. Next we divide the halves into halves similarly for bit position 0. Here you can see that array {1} does not have numbers which bits in position 0 are not set, but has a number which has set bit in that position({1}). In turn the right part is divided to {2} and {3} correspondingly, because 2 has 0 bit in 0th position and 3 has set bit in 0th position. That fact means that, we can also XOR 1 with 2 and get set bit in position 1, therefore the answer is 3 = 2^1+2^0;\\n Actually the running time of the algorithm isO(n^2) and it is slow. Even very naive solution is faster than that.\\n```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0;\\n        if(nums == null || nums.length == 0) return 0;\\n        List<Integer> left = new ArrayList<>(), right = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            max= Math.max(max, nums[i]);\\n        }\\n        int p = 31;\\n        while(p>0 && (max & (1<<p)) == 0) p--;\\n        int fact = 0;\\n        while(p>=0 && (left.isEmpty() || right.isEmpty())){\\n            fact = 1<<p;\\n            for(int i = 0;i<nums.length;i++){\\n                if((nums[i] & fact) == 0){\\n                    left.add(nums[i]);\\n                } else {\\n                    right.add(nums[i]);\\n                }\\n            }\\n            p--;\\n        }\\n        if(left.isEmpty() || right.isEmpty()) fact = 0;\\n        // System.out.println(fact);\\n        return fact+maxXOR(p, left, right);\\n    }\\n    \\n    public int maxXOR(int p, List<Integer> left, List<Integer> right){\\n        if(p<0) return 0;\\n        // int fact;\\n        List<Integer> leftZero  = new ArrayList<>(), rightZero  = new ArrayList<>();\\n        List<Integer> leftOne = new ArrayList<>(), rightOne = new ArrayList<>();\\n        int fact = 1<<p;\\n        \\n        while(p>=0 && ((leftZero.isEmpty() || rightOne.isEmpty()) && (leftOne.isEmpty() || rightZero.isEmpty()))){\\n            fact = 1<<p;\\n            leftZero.clear();\\n            leftOne.clear();\\n            rightZero.clear();\\n            rightOne.clear();\\n            fill(fact, left, leftZero, leftOne);\\n            fill(fact, right, rightZero, rightOne);\\n            p--;\\n        }\\n        if(((leftZero.isEmpty() || rightOne.isEmpty()) && (leftOne.isEmpty() || rightZero.isEmpty()))) {\\n            return 0;\\n        }\\n        // System.out.println(\"+\"+fact);\\n        return fact+Math.max(maxXOR(p, leftZero, rightOne), maxXOR(p, rightZero, leftOne)); \\n    }\\n    \\n    public void fill(int fact, List<Integer> list, List<Integer> zero, List<Integer> one){\\n        for(Integer num:list){\\n            if((fact & num) == 0) {\\n                zero.add(num);\\n            } else {\\n                one.add(num);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n                       {1,2,3} <- bit position 1\\n                        /    \\\\\\n                    {1}      {2, 3} <- bit position 0\\n                    / \\\\        /  \\\\\\n                  X   {1}   {2}   {3}    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3160999,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans=0,mask=0;\\n        unordered_set<int>st;\\n        for(int i=31;i>=0;i--){\\n            mask|=(1<<i);\\n            int temp=ans|(1<<i);\\n            for (int j = 0; j < nums.size(); j++) {\\n                int num = nums[j] & mask;\\n                if (st.find(temp ^ num)!=st.end()) {\\n                    ans = temp;\\n                    break;\\n                }\\n                st.insert(num);\\n            }\\n            st.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans=0,mask=0;\\n        unordered_set<int>st;\\n        for(int i=31;i>=0;i--){\\n            mask|=(1<<i);\\n            int temp=ans|(1<<i);\\n            for (int j = 0; j < nums.size(); j++) {\\n                int num = nums[j] & mask;\\n                if (st.find(temp ^ num)!=st.end()) {\\n                    ans = temp;\\n                    break;\\n                }\\n                st.insert(num);\\n            }\\n            st.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766722,
                "title": "c-trie-data-structure-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Node{\\n\\n\\t\\tpublic:\\n\\t\\tNode* links[2];\\n\\t};\\n\\tclass Trie{\\n\\n\\t\\tpublic:\\n\\t\\tNode* root;\\n\\t\\tTrie(){\\n\\t\\t\\troot=new Node();\\n\\t\\t}\\n\\t\\tvoid insert(int num){\\n\\t\\t\\tNode* node=root;\\n\\t\\t\\tfor(int i=31; i>=0; i--){\\n\\t\\t\\t\\tint bit=(num>>i)&1;\\n\\t\\t\\t\\tif(!node->links[bit]){\\n\\t\\t\\t\\t\\tnode->links[bit]=new Node();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnode=node->links[bit];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxnum(int num){\\n\\t\\t\\tNode* node=root;\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tfor(int i=31; i>=0; i--){\\n\\t\\t\\t\\tint bit=(num>>i)&1;\\n\\t\\t\\t\\tif(!node->links[1-bit]){\\n\\t\\t\\t\\t\\tnode=node->links[bit];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tmaxi=maxi|(1<<i);\\n\\t\\t\\t\\t\\tnode=node->links[1-bit];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n\\n\\tclass Solution {\\n\\n\\t\\tpublic:\\n\\t\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tTrie trie;\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\ttrie.insert(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\tans=max(ans, trie.maxnum(nums[i]));\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\n\\n\\t\\tpublic:\\n\\t\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tTrie trie;\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\ttrie.insert(nums[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2060921,
                "title": "very-intuitive-clean-code-in-c-using-trie-and-without-map",
                "content": "```\\nclass Node {\\n    private:\\n    Node* links[2];\\n    public:\\n    bool containsKey(int bit) {\\n        return links[bit] != nullptr;\\n    }\\n    void put(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n    Node* root;\\n    public:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node* node = root;\\n        for(int i=31; i>=0; i--) {\\n            int bit = (num >> i) & 1;\\n            if(!node->containsKey(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    int findMax(int num) {\\n        Node* node = root;\\n        int maxHere = 0;\\n        for(int i=31; i>=0; i--) {\\n            int bit = (num >> i) & 1;\\n            if(node->containsKey(!bit)) {\\n                maxHere |= (1 << i);\\n                node = node->get(!bit);\\n            } else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxHere;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie;\\n        int ans = 0;\\n        for(auto it : nums) {\\n            trie.insert(it);\\n            ans = max(ans, trie.findMax(it));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Node {\\n    private:\\n    Node* links[2];\\n    public:\\n    bool containsKey(int bit) {\\n        return links[bit] != nullptr;\\n    }\\n    void put(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n    Node* root;\\n    public:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node* node = root;\\n        for(int i=31; i>=0; i--) {\\n            int bit = (num >> i) & 1;\\n            if(!node->containsKey(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    int findMax(int num) {\\n        Node* node = root;\\n        int maxHere = 0;\\n        for(int i=31; i>=0; i--) {\\n            int bit = (num >> i) & 1;\\n            if(node->containsKey(!bit)) {\\n                maxHere |= (1 << i);\\n                node = node->get(!bit);\\n            } else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxHere;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie;\\n        int ans = 0;\\n        for(auto it : nums) {\\n            trie.insert(it);\\n            ans = max(ans, trie.findMax(it));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723730,
                "title": "java-binary-trie-explained",
                "content": "**Idea:**\\n* A binary number is maximized by having max set (1) bits\\n* XOR result is 1 if bits are opposite else 0. This means the maximum result will be achieved with operands a and b when a and b have the maximum number of opposite bits at the most significant places (as left as possible). Such a pair will give max XOR result\\n* So for each query, we need to find the best possible match available stepping down bit by bit. This can be done most efficiently with a Trie\\n* To search in trie, we need to know what is the max possible XOR for any number (say a). Ideally we\\'d want max result to be `Integer.MAX_VALUE`. We\\'ll use [XOR properties](https://accu.org/journals/overload/20/109/lewin_1915/) to find the operand\\n```\\na ^ b = Integer.MAX_VALUE\\n=> b ^ a = Integer.MAX_VALUE           (Commutative property)\\n=> b ^ a ^ a = Integer.MAX_VALUE ^ a   (Apply XOR a both sides) \\n=> b ^ (a ^ a) = Integer.MAX_VALUE ^ a (Associative property)\\n=> b ^ 0 = Integer.MAX_VALUE ^ a       (Self Inverse property)\\n=> b = Integer.MAX_VALUE ^ a           (Identity Element property)\\n\\nso for maximum possible result, we need to XOR a with Integer.MAX_VALUE ^ a\\n```\\n* Create a trie and insert all the numbers in it. \\n* This trie will have depth = 31 since we have ints which are of 31 value bits + 1 sign bit. Ignore the sign bit. Also notice that this is a binary tree with left (zero) and right (one) children nodes \\n* Query:\\n\\t* Isolate each bit using a mask\\n\\t* If the bit is 0 and\\n\\t\\t* current node has a `one/right` child, it means this is a 1 bit, so include this bit in the answer. Move to this node.\\n\\t\\t* current node doesn\\'t have `one` child , then move to the `zero/left` child\\n\\t* Vice versa if bit is 1\\n\\t \\n![image](https://assets.leetcode.com/users/images/74b4d4ae-ef0a-48e8-87fc-e98d8e733966_1643282166.397064.png) \\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int findMaximumXOR(int[] nums) {\\n\\tvar trie = new Trie();\\n\\tArrays.stream(nums)\\n\\t\\t  .forEach(trie::insert);\\n\\n\\tvar max = 0;\\n\\tfor (var num : nums)\\n\\t\\tmax = Math.max(max, num ^ trie.query(Integer.MAX_VALUE ^ num));\\n\\treturn max;\\n}\\n\\nprivate static class Trie {\\n\\n\\tprivate static final int[] MASKS = new int[31];\\n\\tprivate static class Node {\\n\\t\\tprivate Node zero;\\n\\t\\tprivate Node one;\\n\\t}\\n\\t\\n\\tprivate final Node root = new Node();\\n\\t\\n\\tstatic {\\n\\t\\tIntStream.range(0, 31)\\n\\t\\t\\t\\t .forEach(i -> MASKS[i] = 1 << i);\\n\\t}\\n\\n\\tpublic Trie() {}\\n\\n\\tpublic void insert(int n) {\\n\\t\\tvar bitIndex = 30;\\n\\t\\tvar current = root;\\n\\n\\t\\twhile (bitIndex >= 0) {\\n\\t\\t\\tvar bit = (MASKS[bitIndex--] & n) == 0 ? 0 : 1;\\n\\n\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\tif (current.zero == null)\\n\\t\\t\\t\\t\\tcurrent.zero = new Node();\\n\\t\\t\\t\\tcurrent = current.zero;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (current.one == null)\\n\\t\\t\\t\\t\\tcurrent.one = new Node();\\n\\t\\t\\t\\tcurrent = current.one;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate int query(int n) {\\n\\t\\tvar bitIndex = 30;\\n\\t\\tvar current = root;\\n\\t\\tvar result = 0;\\n\\n\\t\\twhile (bitIndex >= 0) {\\n\\t\\t\\tvar bit = (n & MASKS[bitIndex]) == 0 ? 0 : 1;\\n\\n\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\tif (current.zero == null) {\\n\\t\\t\\t\\t\\tcurrent = current.one;\\n\\t\\t\\t\\t\\tresult |= MASKS[bitIndex];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcurrent = current.zero;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (current.one == null) {\\n\\t\\t\\t\\t\\tcurrent = current.zero;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcurrent = current.one;\\n\\t\\t\\t\\t\\tresult |= MASKS[bitIndex];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tbitIndex--;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\na ^ b = Integer.MAX_VALUE\\n=> b ^ a = Integer.MAX_VALUE           (Commutative property)\\n=> b ^ a ^ a = Integer.MAX_VALUE ^ a   (Apply XOR a both sides) \\n=> b ^ (a ^ a) = Integer.MAX_VALUE ^ a (Associative property)\\n=> b ^ 0 = Integer.MAX_VALUE ^ a       (Self Inverse property)\\n=> b = Integer.MAX_VALUE ^ a           (Identity Element property)\\n\\nso for maximum possible result, we need to XOR a with Integer.MAX_VALUE ^ a\\n```\n```\\npublic int findMaximumXOR(int[] nums) {\\n\\tvar trie = new Trie();\\n\\tArrays.stream(nums)\\n\\t\\t  .forEach(trie::insert);\\n\\n\\tvar max = 0;\\n\\tfor (var num : nums)\\n\\t\\tmax = Math.max(max, num ^ trie.query(Integer.MAX_VALUE ^ num));\\n\\treturn max;\\n}\\n\\nprivate static class Trie {\\n\\n\\tprivate static final int[] MASKS = new int[31];\\n\\tprivate static class Node {\\n\\t\\tprivate Node zero;\\n\\t\\tprivate Node one;\\n\\t}\\n\\t\\n\\tprivate final Node root = new Node();\\n\\t\\n\\tstatic {\\n\\t\\tIntStream.range(0, 31)\\n\\t\\t\\t\\t .forEach(i -> MASKS[i] = 1 << i);\\n\\t}\\n\\n\\tpublic Trie() {}\\n\\n\\tpublic void insert(int n) {\\n\\t\\tvar bitIndex = 30;\\n\\t\\tvar current = root;\\n\\n\\t\\twhile (bitIndex >= 0) {\\n\\t\\t\\tvar bit = (MASKS[bitIndex--] & n) == 0 ? 0 : 1;\\n\\n\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\tif (current.zero == null)\\n\\t\\t\\t\\t\\tcurrent.zero = new Node();\\n\\t\\t\\t\\tcurrent = current.zero;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (current.one == null)\\n\\t\\t\\t\\t\\tcurrent.one = new Node();\\n\\t\\t\\t\\tcurrent = current.one;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate int query(int n) {\\n\\t\\tvar bitIndex = 30;\\n\\t\\tvar current = root;\\n\\t\\tvar result = 0;\\n\\n\\t\\twhile (bitIndex >= 0) {\\n\\t\\t\\tvar bit = (n & MASKS[bitIndex]) == 0 ? 0 : 1;\\n\\n\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\tif (current.zero == null) {\\n\\t\\t\\t\\t\\tcurrent = current.one;\\n\\t\\t\\t\\t\\tresult |= MASKS[bitIndex];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcurrent = current.zero;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (current.one == null) {\\n\\t\\t\\t\\t\\tcurrent = current.zero;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcurrent = current.one;\\n\\t\\t\\t\\t\\tresult |= MASKS[bitIndex];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tbitIndex--;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723228,
                "title": "easy-all-possible-solutions-trie-map-o-n-efficient",
                "content": "### **1. APPROACH USING MAP `[Accepted] \\u2248 1200ms, Slow Compared to 2nd Solution: -`**\\n### **EXPLANATION : -**\\n* **`For a 1 bit number maximum set bits in the binary representation of the number will be 1`**\\n    **`for a 2 bit number maximum set bits in the binary representation of the number will be 11`**\\n    **`for a 3 bit number maximum set bits in the binary representation of the number will be 111`**\\n    **`for a 4 bit number maximum set bits in the binary representation of the number will be 1111`**\\n   **`and so on \\u2026\\u2026`**\\n\\t\\n*   **`Now, for a 32 bit number we have 32 bits in memory, so in order to find the largest possible value`**\\n    **`of an XOR operation,  the value of XOR should have most of the bits set (i.e. 1)`**\\n    **`starting from the left to right.`**\\n\\n    **`Here, the desired order of set bits is left to right just because we need largest possible value.`**\\n    **`For example:`**\\n    **`Binary Representation of` 2 is 0010**\\n    **`Binary Representation of` 8 is 1000**\\n\\n    **`So, we can observe that both 2 and 8 have one set bit but the set bit of eight is`**\\n    **`more left than set bit of 2 and hence 8 > 2.`**\\n\\n    **`So the desired order will be left to right.`**\\n    **`Now, for getting the maximum number of set bits starting from leftmost bit,`**\\n    **`we use mask to keep the prefix of every number of i\\u2019th bit.`**\\n\\n*  **`Now bitwise and of mask and array element will give the prefix of the number.`**\\n    **`These prefixes will be stored in a set in order to ignore the repeated values.`**\\n\\n\\t**-> Now we use the important property of XOR:**\\n    **`A ^ B = C`**\\n    **`A ^ C = B`**\\n    **In similar fashion, we can say that**\\n    **`prefix ^ set = candidate`**\\n    **`prefix ^ candidate = set`**\\n    **`Here, we can consider candidate as one of the possible answers.`**\\n\\t**So, `candidate= ans |(1<<i)` gives the maximum possible output we can get in the i\\u2019th iteration.**\\n    **`Hence, if xor of any two elements in the set s is equal to ans , we update the ans to candidate.`**\\n\\n```\\n```\\n**C++ CODE :-**\\n```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int N = nums.size();\\n        int resMax = 0, mask = 0;\\n        set<int> s;\\n        for(int i = 31; i >= 0; --i){\\n            // create a mask \\n            mask = mask | (1 << i);\\n            // iterate over the array nums to check the left most digits\\n            for(int j = 0; j < N; ++j)\\n                s.insert(mask & nums[j]);\\n            \\n            // now, we have to find the pair which will give us maxXor == (a ^ b)\\n            int candidate = resMax | (1 << i);\\n            for(auto prefix : s){\\n                if(s.count(prefix ^ candidate)){\\n                    resMax = candidate;\\n                    break;\\n                }\\n            }\\n            // clear the set for the next iteration\\n            s.clear();\\n        }\\n        return resMax;\\n    }\\n};\\n```\\n**Time  Complexity : `O(N * log(M)) \\u2248 O(N)`, where N : is the size of the array\\nSpace Complexity :` O(log(M))`, Where M : is the maximum number present in the array**\\n\\n```\\n```\\n### **2. APPROACH USING TRIE `[Accepted] \\u2248 250ms, Efficient Solution : -`**\\n**Idea : `This question is Same as finding Maximum XOR of Two Numbers in given two Array`**\\n\\t\\t\\t   **`And the idea is same as map solution, use bit mask & traverse from back of every digit.`**\\n```\\nstruct TrieNode{\\n    TrieNode *links[2];\\n    bool containsKey(int bit){\\n        return (links[bit] != NULL);\\n    }\\n\\n    TrieNode *get(int bit){\\n        return links[bit];\\n    }\\n\\n    void put(int bit, TrieNode* node){\\n        links[bit] = node;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    TrieNode *root;\\npublic:\\n    Trie(){\\n        root = new TrieNode();\\n    }\\npublic:\\n    void insert(int num){\\n        TrieNode* node = root;\\n        for(int i = 31; i >= 0; --i){\\n            int bit = (num >> i) & 1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit, new TrieNode());\\n            }\\n            // if it contains key in trie, move to the next node reference\\n            node = node->get(bit);\\n        }\\n    }\\npublic:\\n    int getMax(int num){\\n        TrieNode *node = root;\\n        int maxNum = 0;\\n        for(int i = 31; i >= 0; --i){\\n            int bit = (num >> i) & 1;\\n            // if bit is opposite of the current bit. i.e. (1 - currBit) == 1/0 \\n            if(node->containsKey(1 - bit)){\\n                // if contains opposite, we can definitely make MaxNum 1 \\n                maxNum = maxNum | (1 << i);\\n                node = node->get(1 - bit);\\n            }else      // if it\\'s a same bit as curr\\n                node = node->get(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int N = nums.size();\\n        Trie trie;                  // make a trie object\\n        for(auto &x : nums) trie.insert(x);\\n        \\n        // traverse again in the nums for the second num to be xor\\n        int res = 0;\\n        for(auto &x : nums) res = max(res, trie.getMax(x));\\n        return res;\\n    }\\n};\\n```\\n**Time  Complexity : `O(N * 32)`, where N : is the size of the array**\\n**Space Complexity : `O(N * 32)`**\\n\\n\\nIf you find any mistakes pls, drop a comment\\n& If it makes any sense **Please Upvote :)**",
                "solutionTags": [
                    "C",
                    "Trie",
                    "Bitmask"
                ],
                "code": "```\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int N = nums.size();\\n        int resMax = 0, mask = 0;\\n        set<int> s;\\n        for(int i = 31; i >= 0; --i){\\n            // create a mask \\n            mask = mask | (1 << i);\\n            // iterate over the array nums to check the left most digits\\n            for(int j = 0; j < N; ++j)\\n                s.insert(mask & nums[j]);\\n            \\n            // now, we have to find the pair which will give us maxXor == (a ^ b)\\n            int candidate = resMax | (1 << i);\\n            for(auto prefix : s){\\n                if(s.count(prefix ^ candidate)){\\n                    resMax = candidate;\\n                    break;\\n                }\\n            }\\n            // clear the set for the next iteration\\n            s.clear();\\n        }\\n        return resMax;\\n    }\\n};\\n```\n```\\n```\n```\\nstruct TrieNode{\\n    TrieNode *links[2];\\n    bool containsKey(int bit){\\n        return (links[bit] != NULL);\\n    }\\n\\n    TrieNode *get(int bit){\\n        return links[bit];\\n    }\\n\\n    void put(int bit, TrieNode* node){\\n        links[bit] = node;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    TrieNode *root;\\npublic:\\n    Trie(){\\n        root = new TrieNode();\\n    }\\npublic:\\n    void insert(int num){\\n        TrieNode* node = root;\\n        for(int i = 31; i >= 0; --i){\\n            int bit = (num >> i) & 1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit, new TrieNode());\\n            }\\n            // if it contains key in trie, move to the next node reference\\n            node = node->get(bit);\\n        }\\n    }\\npublic:\\n    int getMax(int num){\\n        TrieNode *node = root;\\n        int maxNum = 0;\\n        for(int i = 31; i >= 0; --i){\\n            int bit = (num >> i) & 1;\\n            // if bit is opposite of the current bit. i.e. (1 - currBit) == 1/0 \\n            if(node->containsKey(1 - bit)){\\n                // if contains opposite, we can definitely make MaxNum 1 \\n                maxNum = maxNum | (1 << i);\\n                node = node->get(1 - bit);\\n            }else      // if it\\'s a same bit as curr\\n                node = node->get(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int N = nums.size();\\n        Trie trie;                  // make a trie object\\n        for(auto &x : nums) trie.insert(x);\\n        \\n        // traverse again in the nums for the second num to be xor\\n        int res = 0;\\n        for(auto &x : nums) res = max(res, trie.getMax(x));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723031,
                "title": "c-528-ms-brute-force-with-exit-optimization-not-the-best-solution",
                "content": "The answer cannot be larger than the biggest number with all bits set to the right of the highest set bit. So... sort the array descending, run a brute force comparison, quit when your maximum is larger than any possible remaining maximum. You can create a test case that causes dismal performance.\\n\\n```\\n\\npublic class Solution {\\n    \\n    public int SetAllBitsToRightOfHighest(int num){\\n        num |= num >> 1;\\n        num |= num >> 2;  \\n        num |= num >> 4; \\n        num |= num >> 8;\\n        num |= num >> 16;\\n        return num;\\n    }\\n    \\n    public int FindMaximumXOR(int[] nums) {\\n        \\n        Array.Sort(nums, (a, b) => b - a);\\n        \\n        int answer = 0;\\n        for(int i = 0; i < nums.Length; i++){\\n            if(answer >= SetAllBitsToRightOfHighest(nums[i])) break;\\n            for(int j = i + 1; j < nums.Length; j++){\\n                int test = nums[i] ^ nums[j];\\n                if(test > answer) answer = test;\\n            }\\n        }\\n        \\n        return answer;\\n    }    \\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    \\n    public int SetAllBitsToRightOfHighest(int num){\\n        num |= num >> 1;\\n        num |= num >> 2;  \\n        num |= num >> 4; \\n        num |= num >> 8;\\n        num |= num >> 16;\\n        return num;\\n    }\\n    \\n    public int FindMaximumXOR(int[] nums) {\\n        \\n        Array.Sort(nums, (a, b) => b - a);\\n        \\n        int answer = 0;\\n        for(int i = 0; i < nums.Length; i++){\\n            if(answer >= SetAllBitsToRightOfHighest(nums[i])) break;\\n            for(int j = i + 1; j < nums.Length; j++){\\n                int test = nums[i] ^ nums[j];\\n                if(test > answer) answer = test;\\n            }\\n        }\\n        \\n        return answer;\\n    }    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331164,
                "title": "trie-solution-self-explanatory-code",
                "content": "```\\nclass node{\\n    public:\\n    node*left;\\n    node*right;\\n    node(){\\n        this->left=NULL;\\n        this->right=NULL;\\n    }\\n};\\nclass Solution {\\npublic:\\n    node*root=new node();\\n    void insert(int num){\\n        node*curr=root;\\n        for(int i=31;i>=0;i--){\\n            int mask=1<<i;\\n            int ithbit=mask&num;\\n            if(ithbit==0){\\n                if(curr->left==NULL){\\n                    curr->left=new node();\\n                     curr=curr->left;\\n                }else{\\n                    curr=curr->left;\\n                }\\n            }else{\\n                 if(curr->right==NULL){\\n                    curr->right=new node();\\n                     curr=curr->right;\\n                }else{\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n    \\n    }\\n    int search(int num){\\n        int maxpossible=INT_MAX^num;\\n        int ans=0;\\n        node*curr=root;\\n        for(int i=31;i>=0;i--){\\n            int mask=1<<i;\\n            int ithbit=mask&maxpossible;\\n            if(ithbit==0){\\n                if(curr->left==NULL){\\n                    ans=ans|mask;\\n                    curr=curr->right;\\n                }else{\\n                    curr=curr->left;\\n                }\\n                \\n            }else{\\n                if(curr->right==NULL){\\n                   curr=curr->left;\\n                }else{\\n                    ans=ans|mask;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    void preorder(node*r){\\n        if(r==NULL){\\n            return;\\n        }\\n        if(r->left){cout<<0<<\" \"; preorder(r->left);}\\n        if(r->right){cout<<1<<\" \";preorder(r->right);}\\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=INT_MIN;\\n        // insert(5);\\n        for(int i=0;i<n;i++){\\n            insert(nums[i]);  \\n         }\\n        // preorder(root);\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,nums[i]^search(nums[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass node{\\n    public:\\n    node*left;\\n    node*right;\\n    node(){\\n        this->left=NULL;\\n        this->right=NULL;\\n    }\\n};\\nclass Solution {\\npublic:\\n    node*root=new node();\\n    void insert(int num){\\n        node*curr=root;\\n        for(int i=31;i>=0;i--){\\n            int mask=1<<i;\\n            int ithbit=mask&num;\\n            if(ithbit==0){\\n                if(curr->left==NULL){\\n                    curr->left=new node();\\n                     curr=curr->left;\\n                }else{\\n                    curr=curr->left;\\n                }\\n            }else{\\n                 if(curr->right==NULL){\\n                    curr->right=new node();\\n                     curr=curr->right;\\n                }else{\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n    \\n    }\\n    int search(int num){\\n        int maxpossible=INT_MAX^num;\\n        int ans=0;\\n        node*curr=root;\\n        for(int i=31;i>=0;i--){\\n            int mask=1<<i;\\n            int ithbit=mask&maxpossible;\\n            if(ithbit==0){\\n                if(curr->left==NULL){\\n                    ans=ans|mask;\\n                    curr=curr->right;\\n                }else{\\n                    curr=curr->left;\\n                }\\n                \\n            }else{\\n                if(curr->right==NULL){\\n                   curr=curr->left;\\n                }else{\\n                    ans=ans|mask;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    void preorder(node*r){\\n        if(r==NULL){\\n            return;\\n        }\\n        if(r->left){cout<<0<<\" \"; preorder(r->left);}\\n        if(r->right){cout<<1<<\" \";preorder(r->right);}\\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=INT_MIN;\\n        // insert(5);\\n        for(int i=0;i<n;i++){\\n            insert(nums[i]);  \\n         }\\n        // preorder(root);\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,nums[i]^search(nums[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1237669,
                "title": "using-trie",
                "content": "```\\nclass Solution {\\npublic:\\n    class Trie\\n    {\\n        public:\\n           Trie *child[2];\\n           int val = 0;\\n    };\\n\\n    \\n    void insert(int x, Trie *root){\\n    \\t\\n        Trie* curr=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (x >> i) & 1;\\n            if(curr->child[bit] == NULL)\\n                curr->child[bit] = new Trie();\\n            \\n            curr = curr->child[bit];\\n        }\\n        curr->val = x;\\n        \\n    }\\n    \\n    int findAns(int x, Trie *root)\\n    {\\n        Trie* curr = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (x >> i) & 1;\\n           \\n            if(curr->child[!bit]!=NULL)\\n                curr = curr->child[!bit];\\n           \\n            else if(curr->child[bit]!=NULL)\\n                curr=curr->child[bit];\\n        }\\n        return curr->val;  \\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        \\n        int ans = INT_MIN;\\n        \\n        Trie* root = new Trie();\\n        \\n        for(auto n:nums)\\n            insert(n, root);\\n        \\n        \\n        for(auto n:nums)\\n            ans = max(ans, n ^ findAns(n, root));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class Trie\\n    {\\n        public:\\n           Trie *child[2];\\n           int val = 0;\\n    };\\n\\n    \\n    void insert(int x, Trie *root){\\n    \\t\\n        Trie* curr=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (x >> i) & 1;\\n            if(curr->child[bit] == NULL)\\n                curr->child[bit] = new Trie();\\n            \\n            curr = curr->child[bit];\\n        }\\n        curr->val = x;\\n        \\n    }\\n    \\n    int findAns(int x, Trie *root)\\n    {\\n        Trie* curr = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (x >> i) & 1;\\n           \\n            if(curr->child[!bit]!=NULL)\\n                curr = curr->child[!bit];\\n           \\n            else if(curr->child[bit]!=NULL)\\n                curr=curr->child[bit];\\n        }\\n        return curr->val;  \\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        \\n        int ans = INT_MIN;\\n        \\n        Trie* root = new Trie();\\n        \\n        for(auto n:nums)\\n            insert(n, root);\\n        \\n        \\n        for(auto n:nums)\\n            ans = max(ans, n ^ findAns(n, root));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078924,
                "title": "java-bit-manipulation-trie-o-n",
                "content": "\\n    public class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tint data;\\n\\t\\t\\tNode[] children;\\n\\n\\t\\t\\tpublic Node(int data) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.children = new Node[2];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(-1);\\n\\t\\t}\\n\\n\\t\\t// O(32)\\n\\t\\tpublic void addWord(int num) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = 30; i >= 0; i--) {\\n\\t\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\t\\tint bit = num & mask;\\n\\t\\t\\t\\tbit = (bit != 0) ? 1 : 0;\\n\\t\\t\\t\\tNode temp = curr.children[bit];\\n\\t\\t\\t\\tif (temp == null){\\n\\t\\t\\t\\t\\ttemp = new Node(bit);\\n                    curr.children[bit] = temp;\\n                }\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// O(32)\\n\\t\\tpublic int searchWord(int num) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor (int i = 30; i >= 0; i--) {\\n\\t\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\t\\tint bit = num & mask;\\n\\t\\t\\t\\tbit = (bit != 0) ? 1 : 0;\\n\\t\\t\\t\\tint toggle = bit ^ 1;\\n\\t\\t\\t\\tNode temp = curr.children[toggle];\\n\\t\\t\\t\\tif (temp != null) {\\n\\t\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t\\t\\tans |= mask;\\n\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\tcurr = curr.children[bit];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(n)\\n\\t// Trie\\n\\tpublic int findMaximumXOR(int[] nums) {\\n\\n\\t\\tTrie trie = new Trie();\\n\\t\\tint max = 0;\\n\\t\\tfor (int num : nums)\\n\\t\\t\\ttrie.addWord(num);\\n        \\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tint ans = trie.searchWord(num);\\n\\t\\t\\tmax = Math.max(ans, max);\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tint data;\\n\\t\\t\\tNode[] children;\\n\\n\\t\\t\\tpublic Node(int data) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.children = new Node[2];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(-1);\\n\\t\\t}\\n\\n\\t\\t// O(32)\\n\\t\\tpublic void addWord(int num) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = 30; i >= 0; i--) {\\n\\t\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\t\\tint bit = num & mask;\\n\\t\\t\\t\\tbit = (bit != 0) ? 1 : 0;\\n\\t\\t\\t\\tNode temp = curr.children[bit];\\n\\t\\t\\t\\tif (temp == null){\\n\\t\\t\\t\\t\\ttemp = new Node(bit);\\n                    curr.children[bit] = temp;\\n                }\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// O(32)\\n\\t\\tpublic int searchWord(int num) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor (int i = 30; i >= 0; i--) {\\n\\t\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\t\\tint bit = num & mask;\\n\\t\\t\\t\\tbit = (bit != 0) ? 1 : 0;\\n\\t\\t\\t\\tint toggle = bit ^ 1;\\n\\t\\t\\t\\tNode temp = curr.children[toggle];\\n\\t\\t\\t\\tif (temp != null) {\\n\\t\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t\\t\\tans |= mask;\\n\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\tcurr = curr.children[bit];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(n)\\n\\t// Trie\\n\\tpublic int findMaximumXOR(int[] nums) {\\n\\n\\t\\tTrie trie = new Trie();\\n\\t\\tint max = 0;\\n\\t\\tfor (int num : nums)\\n\\t\\t\\ttrie.addWord(num);\\n        \\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tint ans = trie.searchWord(num);\\n\\t\\t\\tmax = Math.max(ans, max);\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 954451,
                "title": "explanation-trie-approach",
                "content": "**TC -- O(N)\\nSC -- O(1)  //32 is constant**\\n\\n#### Approach :- Here, we are creating Trie of 1/0 representing all numbers by consuming less space and efficient searching. When we have 0 bit in our hand we are looking for 1 bit greddily to make maximum XOR and vice-versa.\\n# \\n\\n```\\nclass TrieNode {\\npublic:\\n\\tTrieNode *left;\\n\\tTrieNode *right;\\n};\\n\\nvoid insertNode(int n, TrieNode *head) {\\n\\tTrieNode *curr = head;\\n\\tfor (int i = 31; i >= 0; i--) {\\n\\n\\t\\tint bit = (n >> i) & 1;\\n\\n\\t\\tif (bit == 0) {\\n\\t\\t\\tif (!curr->left) {\\n\\t\\t\\t\\tcurr->left = new TrieNode();\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr->left;\\n\\t\\t}\\n\\n\\t\\telse {\\n\\t\\t\\tif (!curr->right) {\\n\\t\\t\\t\\tcurr->right = new TrieNode();\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr->right;\\n\\t\\t}\\n\\n\\t}\\n}\\n\\nclass Solution {\\npublic:\\n\\tint findMaximumXORHelper(vector<int>& nums, TrieNode *head, int size) {\\n\\t\\tint maXOR = INT_MIN;\\n\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tint value = nums[i];\\n\\t\\t\\tTrieNode *curr = head;\\n\\t\\t\\tint currXOR = 0;\\n\\n\\t\\t\\tfor (int j = 31; j >= 0; j--) {\\n\\n\\t\\t\\t\\tint bit = (value >> j) & 1;\\n\\n\\t\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\t\\tif (curr->right) {\\n\\t\\t\\t\\t\\t\\tcurrXOR += 1 << j;\\n\\t\\t\\t\\t\\t\\tcurr = curr->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tcurr = curr->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif (curr->left) {\\n\\t\\t\\t\\t\\t\\tcurrXOR += 1 << j;\\n\\t\\t\\t\\t\\t\\tcurr = curr->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tcurr = curr->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaXOR = max(maXOR, currXOR);\\n\\t\\t}\\n\\t\\treturn maXOR;\\n\\t}\\n\\n\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\tTrieNode *head = new TrieNode();\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tinsertNode(nums[i], head);\\n\\t\\t}\\n\\n\\t\\treturn findMaximumXORHelper(nums, head, nums.size());\\n\\t}\\n};\\n```\\n***Hope this helped you, use comment if you have any doubt...***\\n**For more deatil :-** [Maximum XOR of Two Numbers in an Array](https://www.youtube.com/watch?v=wSgrc98d2lI)",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n\\tTrieNode *left;\\n\\tTrieNode *right;\\n};\\n\\nvoid insertNode(int n, TrieNode *head) {\\n\\tTrieNode *curr = head;\\n\\tfor (int i = 31; i >= 0; i--) {\\n\\n\\t\\tint bit = (n >> i) & 1;\\n\\n\\t\\tif (bit == 0) {\\n\\t\\t\\tif (!curr->left) {\\n\\t\\t\\t\\tcurr->left = new TrieNode();\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr->left;\\n\\t\\t}\\n\\n\\t\\telse {\\n\\t\\t\\tif (!curr->right) {\\n\\t\\t\\t\\tcurr->right = new TrieNode();\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr->right;\\n\\t\\t}\\n\\n\\t}\\n}\\n\\nclass Solution {\\npublic:\\n\\tint findMaximumXORHelper(vector<int>& nums, TrieNode *head, int size) {\\n\\t\\tint maXOR = INT_MIN;\\n\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tint value = nums[i];\\n\\t\\t\\tTrieNode *curr = head;\\n\\t\\t\\tint currXOR = 0;\\n\\n\\t\\t\\tfor (int j = 31; j >= 0; j--) {\\n\\n\\t\\t\\t\\tint bit = (value >> j) & 1;\\n\\n\\t\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\t\\tif (curr->right) {\\n\\t\\t\\t\\t\\t\\tcurrXOR += 1 << j;\\n\\t\\t\\t\\t\\t\\tcurr = curr->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tcurr = curr->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif (curr->left) {\\n\\t\\t\\t\\t\\t\\tcurrXOR += 1 << j;\\n\\t\\t\\t\\t\\t\\tcurr = curr->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tcurr = curr->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaXOR = max(maXOR, currXOR);\\n\\t\\t}\\n\\t\\treturn maXOR;\\n\\t}\\n\\n\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\tTrieNode *head = new TrieNode();\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tinsertNode(nums[i], head);\\n\\t\\t}\\n\\n\\t\\treturn findMaximumXORHelper(nums, head, nums.size());\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853939,
                "title": "java-o-n-time-explained-greedy-approach",
                "content": "Given a array of integers find the maximum xor..\\n1. Do xor of each element with another and update the max value as and when you find a value.\\n2. In the end return it.\\n\\nint ans = 0;\\n\\tfor(int n:nums){\\n\\tfor(int n1:nums){\\n\\t\\tans = Math.max(ans, n^n1);\\n\\t}\\n\\t}\\n\\treturn ans;\\n\\t\\n\\nOR ---------------\\n\\t\\n```import java.util.*;\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        \\n        int mask = 0, ans = 0, greedyPossibility = 0;\\n        Set<Integer> set;\\n        for(int i=31;i>-1;i--){\\n                mask = mask |  1<< i ;\\n\\t\\t\\t\\t\\n                set = new HashSet<>();\\n                for(int n:nums)\\n                    set.add(mask & n);\\n            \\n                greedyPossibility = ans | (1 << i);\\n\\t\\t\\t\\t\\n         //\\n            Iterator<Integer> it = set.iterator();\\n               while(it.hasNext()){\\n                    if(set.contains(greedyPossibility^it.next())){\\n                        ans = greedyPossibility;\\n                        break;\\n                    }\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n\\nWhat we are doing here is GREEDY approach.\\n\\nWe want XOR to be as large as possible...  i.e. so we\\'ll try to find a pair in the numbers whose XOR creates a large number. \\nAs we know,\\n10000 > 01111 (i.e. for same number of bits in a number, if we could find a XOR of pairs such that XOR creates 1 as MSB, not caring about its other bits, then we are good to go with this number. (i.e. the XOR of the  prefix of 2 numbers if gives 1, then we choose it.)\\nBasically,\\nSo if a pair let\\'s say 10000 and 11111 gives XOR=> 01111 and\\nanother let\\'s say      01111 and 11111 gives XOR -> 10000 ... so here we choose this pair.\\n\\n\\ni.e we only care if we are able to get XOR of 2 numbers where MSB is 1. If we find it, we have a large number. And so on we\\'ll try to do for next bits starting from left to right.\\n\\nPrefix means the starting part of a number/word. Hence, first we only get the prefix of all numbers. By masking with a number like 10000.\\nIf prefixes of 2 number prefixes gives us 1 (followed by zeroes or any bits), we take it and this is our answer.\\n\\nIteration 1\\nSay, we get numbers prefixes in the set as {0000,1000} i.e. the possibility of all kinds of prefixes (most significant bit, single bit)  from nums array.\\nSo the greedyPossibility is = 0 | 1<<4 i.e 1000 (this is what we want).\\nIf any 2 number prefixes gives greedyPossibility. Then we are sure answer will have 4th bit as 1. Hence ans = 1000 for now.\\n\\nIteration 2\\nSay, we get number prefixes( now 2 most signifcant bits), as. {0000,1100,0100,1000), now we know ans is 1000 i.e. our 4th bit can be one.. but can we get 3rd bit also one i.e. can greedyPossibility be 1000 | 1<<3 i.e. 1100.\\nIf any 2 number prefixes gives greedyPossibility, Then we are sure answer will have 3rd bit as 1. Hence ans =greedyPossibility = 1100 for now.\\n\\nIteration 3\\nSay , we get number prefixes(now 3 most signifcant bits) of all numbers as {0000, 1110, 1100, 0010, 0100}, now we know ans is 1100 i.e. our 4th and 3rd bit are 1, but can we have 2nd bit also one i.e. can answer be =ans | 1<<2 i.e. 1110. \\nIf any 2 number prefixes (from set) gives greedyPossibility, then we are sure answer will have 2nd bit as 1. If not then our 2nd bit stays 0. And our answer for now is 1100.\\n\\nand so on.\\n",
                "solutionTags": [],
                "code": "```import java.util.*;\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        \\n        int mask = 0, ans = 0, greedyPossibility = 0;\\n        Set<Integer> set;\\n        for(int i=31;i>-1;i--){\\n                mask = mask |  1<< i ;\\n\\t\\t\\t\\t\\n                set = new HashSet<>();\\n                for(int n:nums)\\n                    set.add(mask & n);\\n            \\n                greedyPossibility = ans | (1 << i);\\n\\t\\t\\t\\t\\n         //\\n            Iterator<Integer> it = set.iterator();\\n               while(it.hasNext()){\\n                    if(set.contains(greedyPossibility^it.next())){\\n                        ans = greedyPossibility;\\n                        break;\\n                    }\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850364,
                "title": "c-solution-hashset-and-trie",
                "content": "## HashSet\\n**Idea**\\nIn order to get the maximum XOR result (assuem it is```currMax```), I will want the MSD (most significant digit) of  ```currMax```  be 1 when iterate the digits from left to right, because 1XXX is always larger than 0XXX and 11XX is always larger than 10XX.\\n\\nWith this in mind, we will greedily try to find 2 numbers such that their XOR result at current position is 1. Now the questions becomes how to find the two numbers. As we know if a ^ b = c, then a ^ c = b. Assume a and b are the two numbers (num1, num2) we are looking for and c is  ```currMax```. In order to check whether currMax exist, we can first assume currMax exists, then we can check whether num2 exist since ```num1 ^ currMax = num2```, if num2 exists, then currMax exists.\\n\\nWhen at position ```i```, we only care about digits between MSD and i, so we can use a mask to only keep digits between i and MSD. The mask will be 1000000....0, 1100000....0, 1110000....0, ..., 1111111....10. Using ```mask = mask | 1 << i``` can help get correct mask for each position.\\n\\n**Example**\\n Input: [3,10,5,25,2,8] = [00011, 01010, 00101, 11001, 00010, 01000] \\n \\n* i = 4, mask = 10000, set = [00000, 00000, 00000, 10000, 00000, 00000], wishMax = 10000 (exist), currMax = 10000\\n* i = 3, mask = 11000, set = [00000, 01000, 00000, 11000, 00000, 01000], wishMax = 11000 (exist), currMax = 11000\\n* i = 2, mask = 11100, set = [00000, 01000, 00100, 11000, 00000, 01000], wishMax = 11100 (exist), currMax = 11100\\n* i = 1, mask = 11110, set = [00010, 01010, 00100, 11000, 00010, 01000], wishMax = 11110 (not exist), currMax = 11100\\n* i = 0, mask = 11111, set = [00011, 01010, 00101, 11001, 00010, 01000], wishMax = 11101 (not exist), currMax = 11100\\n\\n**Solution: HashSet**\\n``` \\npublic class Solution {\\n    public int FindMaximumXOR(int[] nums) {\\n        \\n        int currMax = 0;\\n        int mask = 0;\\n        \\n        for(int i = 31; i >=0; i--)\\n        {\\n            // get mask at each position\\n            mask = mask | 1 << i;\\n            \\n            // store digits between MSD and i in hashset\\n            HashSet<int> set = new HashSet<int>();\\n            foreach(int num in nums)\\n                set.Add(num & mask);\\n            \\n            // check whether can find two numbers such that their XOR result at position i is 1.\\n            int wishMax = currMax | 1 << i;\\n            foreach(int n in set)\\n            {\\n                if(set.Contains(n ^ wishMax))\\n                {\\n                    currMax = wishMax;\\n                    break;\\n                }\\n            }        \\n        }\\n        \\n        return currMax;\\n    }\\n}\\n```\\n\\n## Trie\\n**Idea**\\nFor each num, we will try to do XOR operation between current MSD and all other numbers at corresponding position. We first construct a Trie data structure to store all the numbers in binary format, then for each digit we will first try to get its flip digit to do XOR operation in order to get the maximum XOR result. We use a global variable to keep updating the maximum XOR result.\\n\\n**Solution: Trie**\\n```\\npublic class Solution {\\n    \\n    public class TrieNode\\n    {\\n        public TrieNode[] Children; \\n        \\n        public TrieNode()\\n        {\\n            Children = new TrieNode[2];\\n        }\\n    }\\n    \\n    public int FindMaximumXOR(int[] nums) {\\n        \\n        // build the Trie\\n        TrieNode root = new TrieNode();\\n        \\n        foreach(int num in nums)\\n        {\\n            TrieNode curr = root;\\n            \\n            for(int i = 31; i >= 0; i--)\\n            {\\n                int currBit = (num & (1 << i)) == 0? 0 : 1;\\n                if(curr.Children[currBit] == null)\\n                {\\n                    curr.Children[currBit] = new TrieNode(); \\n                }\\n                \\n                curr = curr.Children[currBit];\\n            }\\n        }      \\n        \\n        // find the maximum XOR\\n        int res = 0;\\n        foreach(int num in nums)\\n        {\\n            TrieNode curr = root;\\n            int currMax = 0;\\n            \\n            for(int i = 31; i >= 0; i--)\\n            {\\n                int currBit = (num & (1 << i)) == 0? 0 : 1;\\n                int flipBit = currBit ^ 1;\\n\\n                if(curr.Children[flipBit] != null)\\n                {\\n                    currMax += 1 << i;\\n                    curr = curr.Children[flipBit];\\n                }\\n                else\\n                    curr = curr.Children[currBit];\\n            }\\n            \\n            res = Math.Max(res, currMax);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```currMax```\n```currMax```\n```currMax```\n```num1 ^ currMax = num2```\n```i```\n```mask = mask | 1 << i```\n``` \\npublic class Solution {\\n    public int FindMaximumXOR(int[] nums) {\\n        \\n        int currMax = 0;\\n        int mask = 0;\\n        \\n        for(int i = 31; i >=0; i--)\\n        {\\n            // get mask at each position\\n            mask = mask | 1 << i;\\n            \\n            // store digits between MSD and i in hashset\\n            HashSet<int> set = new HashSet<int>();\\n            foreach(int num in nums)\\n                set.Add(num & mask);\\n            \\n            // check whether can find two numbers such that their XOR result at position i is 1.\\n            int wishMax = currMax | 1 << i;\\n            foreach(int n in set)\\n            {\\n                if(set.Contains(n ^ wishMax))\\n                {\\n                    currMax = wishMax;\\n                    break;\\n                }\\n            }        \\n        }\\n        \\n        return currMax;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    \\n    public class TrieNode\\n    {\\n        public TrieNode[] Children; \\n        \\n        public TrieNode()\\n        {\\n            Children = new TrieNode[2];\\n        }\\n    }\\n    \\n    public int FindMaximumXOR(int[] nums) {\\n        \\n        // build the Trie\\n        TrieNode root = new TrieNode();\\n        \\n        foreach(int num in nums)\\n        {\\n            TrieNode curr = root;\\n            \\n            for(int i = 31; i >= 0; i--)\\n            {\\n                int currBit = (num & (1 << i)) == 0? 0 : 1;\\n                if(curr.Children[currBit] == null)\\n                {\\n                    curr.Children[currBit] = new TrieNode(); \\n                }\\n                \\n                curr = curr.Children[currBit];\\n            }\\n        }      \\n        \\n        // find the maximum XOR\\n        int res = 0;\\n        foreach(int num in nums)\\n        {\\n            TrieNode curr = root;\\n            int currMax = 0;\\n            \\n            for(int i = 31; i >= 0; i--)\\n            {\\n                int currBit = (num & (1 << i)) == 0? 0 : 1;\\n                int flipBit = currBit ^ 1;\\n\\n                if(curr.Children[flipBit] != null)\\n                {\\n                    currMax += 1 << i;\\n                    curr = curr.Children[flipBit];\\n                }\\n                else\\n                    curr = curr.Children[currBit];\\n            }\\n            \\n            res = Math.Max(res, currMax);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849356,
                "title": "rust-trie-solution",
                "content": "```rust\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 2],\\n}\\n\\nimpl Solution {\\n    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {\\n        let mut trie: Trie = Default::default();\\n        for &num in nums.iter() {\\n            let mut node = &mut trie;\\n            for i in (0..31).rev() {\\n                let bit = ((num >> i) & 1) as usize;\\n                node = node.children[bit].get_or_insert_with(Default::default);\\n            }\\n        }\\n        let mut answer = 0;\\n        for &num in nums.iter() {\\n            let mut max = 0;\\n            let mut node = &trie;\\n            for i in (0..31).rev() {\\n                let bit = ((num >> i) & 1) as usize;\\n                if let Some(n) = &node.children[1 - bit] {\\n                    max |= 1 << i;\\n                    node = n;\\n                } else {\\n                    node = &node.children[bit].as_ref().unwrap();\\n                }\\n            }\\n            answer = std::cmp::max(answer, max);\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Trie"
                ],
                "code": "```rust\\n#[derive(Default)]\\nstruct Trie {\\n    children: [Option<Box<Trie>>; 2],\\n}\\n\\nimpl Solution {\\n    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {\\n        let mut trie: Trie = Default::default();\\n        for &num in nums.iter() {\\n            let mut node = &mut trie;\\n            for i in (0..31).rev() {\\n                let bit = ((num >> i) & 1) as usize;\\n                node = node.children[bit].get_or_insert_with(Default::default);\\n            }\\n        }\\n        let mut answer = 0;\\n        for &num in nums.iter() {\\n            let mut max = 0;\\n            let mut node = &trie;\\n            for i in (0..31).rev() {\\n                let bit = ((num >> i) & 1) as usize;\\n                if let Some(n) = &node.children[1 - bit] {\\n                    max |= 1 << i;\\n                    node = n;\\n                } else {\\n                    node = &node.children[bit].as_ref().unwrap();\\n                }\\n            }\\n            answer = std::cmp::max(answer, max);\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849130,
                "title": "421-maximum-xor-of-two-numbers-in-an-array-solution",
                "content": "My solution\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaximumXOR = function(nums) {\\n    var sum = 0;\\n    var minValue = 0;\\n    for (var i = 1; i < nums.length; i++) {\\n        if ((nums[minValue] ^ nums[i]) > sum ) {\\n            sum = nums[minValue] ^ nums[i];\\n            if (i === nums.length-1) {\\n                minValue++;\\n                i = minValue;\\n            }\\n        }else if (i === nums.length-1) {\\n            minValue++;\\n            i = minValue;\\n        }\\n    }\\n    return sum;\\n};\\n```\\nFaster Learned from [here](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/91049/Java-O(n)-solution-using-bit-manipulation-and-HashMap)\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaximumXOR = function(nums) {\\n    var max = 0;\\n    var mask = 0;\\n    \\n    for (let i = 31; i >= 0; i--) {\\n        mask = mask | ( 1 << i);\\n        const set = new Set();\\n        for (let n of nums) {\\n            set.add(n & mask);\\n        }\\n        let temp = max | (1 << i);\\n        for (let prefix of set) {\\n            if (set.has(temp ^ prefix)) {\\n                max = temp;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaximumXOR = function(nums) {\\n    var sum = 0;\\n    var minValue = 0;\\n    for (var i = 1; i < nums.length; i++) {\\n        if ((nums[minValue] ^ nums[i]) > sum ) {\\n            sum = nums[minValue] ^ nums[i];\\n            if (i === nums.length-1) {\\n                minValue++;\\n                i = minValue;\\n            }\\n        }else if (i === nums.length-1) {\\n            minValue++;\\n            i = minValue;\\n        }\\n    }\\n    return sum;\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaximumXOR = function(nums) {\\n    var max = 0;\\n    var mask = 0;\\n    \\n    for (let i = 31; i >= 0; i--) {\\n        mask = mask | ( 1 << i);\\n        const set = new Set();\\n        for (let n of nums) {\\n            set.add(n & mask);\\n        }\\n        let temp = max | (1 << i);\\n        for (let prefix of set) {\\n            if (set.has(temp ^ prefix)) {\\n                max = temp;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849060,
                "title": "c-clean-and-easy-to-understand-code-standard-trie-data-structure",
                "content": "```\\nclass Trie {\\npublic:\\n    Trie() \\n    {\\n        next[0] = next[1] = nullptr;\\n    }\\n    \\n\\t// destructor has a huge impact to run time.\\n    ~Trie()\\n    {\\n        if (next[0]) {\\n            delete next[0];\\n        }\\n        \\n        if (next[1]) {\\n            delete next[1];\\n        }\\n    }\\n    \\n    void insert(int n) {\\n        Trie* cur = this;\\n        \\n        for (int i = 31; i >= 0; --i) {\\n            if (n & (1 << i)) {\\n                if (!cur->next[1]) {\\n                    cur->next[1] = new Trie();\\n                }\\n                cur = cur->next[1];\\n            } else {\\n                if (!cur->next[0]) {\\n                    cur->next[0] = new Trie();\\n                }\\n                cur = cur->next[0];\\n            }\\n        }\\n        \\n        cur->val = n;\\n    }\\n    \\n    int findOpposite(int n) {\\n        Trie* cur = this;\\n        \\n        for (int i = 31; i >= 0; --i) {\\n            if (n & (1 << i)) {\\n                if (cur->next[0]) {\\n                    cur = cur->next[0];\\n                } else {\\n                    cur = cur->next[1];\\n                }\\n            } else {\\n                if (cur->next[1]) {\\n                    cur = cur->next[1];\\n                } else {\\n                    cur = cur->next[0];\\n                }\\n            }\\n        }\\n        \\n        return cur->val;\\n    }\\nprivate:\\n    int val;\\n    Trie* next[2];\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        Trie root;\\n        \\n        for (auto n : nums) {\\n            root.insert(n);\\n        }\\n        \\n        for (auto n : nums) {\\n            ans = max(ans, n ^ root.findOpposite(n));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\npublic:\\n    Trie() \\n    {\\n        next[0] = next[1] = nullptr;\\n    }\\n    \\n\\t// destructor has a huge impact to run time.\\n    ~Trie()\\n    {\\n        if (next[0]) {\\n            delete next[0];\\n        }\\n        \\n        if (next[1]) {\\n            delete next[1];\\n        }\\n    }\\n    \\n    void insert(int n) {\\n        Trie* cur = this;\\n        \\n        for (int i = 31; i >= 0; --i) {\\n            if (n & (1 << i)) {\\n                if (!cur->next[1]) {\\n                    cur->next[1] = new Trie();\\n                }\\n                cur = cur->next[1];\\n            } else {\\n                if (!cur->next[0]) {\\n                    cur->next[0] = new Trie();\\n                }\\n                cur = cur->next[0];\\n            }\\n        }\\n        \\n        cur->val = n;\\n    }\\n    \\n    int findOpposite(int n) {\\n        Trie* cur = this;\\n        \\n        for (int i = 31; i >= 0; --i) {\\n            if (n & (1 << i)) {\\n                if (cur->next[0]) {\\n                    cur = cur->next[0];\\n                } else {\\n                    cur = cur->next[1];\\n                }\\n            } else {\\n                if (cur->next[1]) {\\n                    cur = cur->next[1];\\n                } else {\\n                    cur = cur->next[0];\\n                }\\n            }\\n        }\\n        \\n        return cur->val;\\n    }\\nprivate:\\n    int val;\\n    Trie* next[2];\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        Trie root;\\n        \\n        for (auto n : nums) {\\n            root.insert(n);\\n        }\\n        \\n        for (auto n : nums) {\\n            ans = max(ans, n ^ root.findOpposite(n));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804241,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {\\n        (0..=31)\\n            .rev()\\n            .scan(0, |mask, i| {\\n                *mask = *mask | 1 << i;\\n                Some((*mask, 1 << i))\\n            })\\n            .fold(0, |result, (mask, bit)| {\\n                let greedy = result | bit;\\n                let s: HashSet<i32> = HashSet::from_iter(nums.iter().map(|n| n & mask));\\n                s.iter()\\n                    .find(|&left_part| s.contains(&(left_part ^ greedy)))\\n                    .map(|_| greedy)\\n                    .unwrap_or(result)\\n            })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {\\n        (0..=31)\\n            .rev()\\n            .scan(0, |mask, i| {\\n                *mask = *mask | 1 << i;\\n                Some((*mask, 1 << i))\\n            })\\n            .fold(0, |result, (mask, bit)| {\\n                let greedy = result | bit;\\n                let s: HashSet<i32> = HashSet::from_iter(nums.iter().map(|n| n & mask));\\n                s.iter()\\n                    .find(|&left_part| s.contains(&(left_part ^ greedy)))\\n                    .map(|_| greedy)\\n                    .unwrap_or(result)\\n            })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777215,
                "title": "python-standard-trie-implementation-using-a-trienode-class",
                "content": "There are several excellent questions using Trie data structure at Leetcode. The implementations share great simiarlities. It is therefore useful to list (some of) them here for a better comparision and understanding. The functions of inserting words and searching if a prefix or a word exists in the trie are standard. What makes it trickier is to use ```Depth First Search (DFS)``` to extract the entire words under certain constraint conditions. It takes some time to settle in eventually.  \\n\\n**421. Maximum XOR of Two Numbers in an Array**\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert_word(self, word):\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n        node.is_word = True\\n    \\n    def opposite_bit(self, bit):\\n        if bit == \\'0\\':\\n            return \\'1\\'\\n        elif bit == \\'1\\':\\n            return \\'0\\'\\n        \\n    def find_max_xor(self, cand_num):\\n        node = self.root\\n        bit_num = bin(cand_num)[2:].zfill(32)\\n        max_xor = \\'\\'\\n        for bit in bit_num:\\n            oppo_bit = self.opposite_bit(bit)\\n            if oppo_bit in node.children:\\n                max_xor += oppo_bit\\n                node = node.children[oppo_bit]\\n            else:\\n                max_xor += bit\\n                node = node.children[bit]\\n\\n        return int(max_xor, 2) ^ cand_num\\n            \\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        # construct the trie\\n        for num in nums:\\n            bit_num = bin(num)[2:].zfill(32)\\n            self.insert_word(bit_num)\\n        \\n        max_xor_num = float(\\'-inf\\')\\n        for num in nums:\\n            max_xor_num = max(max_xor_num, self.find_max_xor(num))\\n            \\n        return max_xor_num\\n```\\n**208. Implement Trie (Prefix Tree)** the generic implementation of the trie.\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def insert(self, word: str) -> None:\\n        \"\"\"\\n        Inserts a word into the trie.\\n        \"\"\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n        node.is_word = True\\n       \\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the trie.\\n        \"\"\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                return False\\n            node = node.children[ch]\\n        return node.is_word\\n            \\n    def startsWith(self, prefix: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that starts with the given prefix.\\n        \"\"\"\\n        node = self.root\\n        for ch in prefix:\\n            if ch not in node.children:\\n                return False\\n            node = node.children[ch]\\n        return True\\n```\\n\\n**211. Add and Search Word - Data structure design**\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root =  TrieNode()\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n            \\n        node.is_word = True\\n        \\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        node = self.root\\n        return self.dfs(node, 0, word)\\n        \\n    def dfs(self, node, index, word):\\n        if len(word) == index:\\n            return node.is_word\\n        \\n        if word[index] == \\'.\\':\\n            for ch in node.children:\\n                if self.dfs(node.children[ch], index + 1, word):\\n                    return True\\n                \\n        if word[index] in node.children:\\n            return self.dfs(node.children[word[index]], index + 1, word)\\n        \\n        return False\\n```\\n**676. Implement Magic Dictionary**\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.is_word = False\\n        \\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n    \\n    def insert_word(self, word):\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n            \\n        node.is_word = True\\n\\n    def buildDict(self, dict: List[str]) -> None:\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"\\n        for word in dict:\\n            self.insert_word(word)\\n        \\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n        return self.dfs(self.root, 0, word, 0)\\n    \\n    def dfs(self, node, index, word, count): # count of mismatch\\n        if count > 1:\\n            return False\\n        \\n        if len(word) == index:\\n            return node.is_word and count == 1\\n        \\n        for ch in node.children:\\n            if self.dfs(node.children[ch], index + 1, word, count + (word[index] != ch)):\\n                return True\\n            \\n        return False\\n```\\n\\n**1268. Search Suggestions System**\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n            \\n        node.is_word = True\\n        \\n    def startsWith(self, prefix): # return top three matches if exist\\n        node = self.root\\n        top_three = []\\n        for ch in prefix:\\n            if ch not in node.children:\\n                return []\\n            node = node.children[ch]\\n            \\n        return self.dfs(node, prefix, [])\\n            \\n    \\n    def dfs(self, node, prefix, words):\\n        if node.is_word:\\n            words.append(prefix)\\n            \\n        for ch in node.children:\\n            self.dfs(node.children[ch], prefix + ch, words)\\n        return words\\n        \\n        \\nclass Solution:\\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\\n        \\n        products.sort()\\n        trie = Trie()\\n        for product in products:\\n            trie.insert(product)\\n        \\n        res = []\\n        for i in range(len(searchWord)):\\n            res.append(trie.startsWith(searchWord[:i+1])[:3])\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```Depth First Search (DFS)```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert_word(self, word):\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n        node.is_word = True\\n    \\n    def opposite_bit(self, bit):\\n        if bit == \\'0\\':\\n            return \\'1\\'\\n        elif bit == \\'1\\':\\n            return \\'0\\'\\n        \\n    def find_max_xor(self, cand_num):\\n        node = self.root\\n        bit_num = bin(cand_num)[2:].zfill(32)\\n        max_xor = \\'\\'\\n        for bit in bit_num:\\n            oppo_bit = self.opposite_bit(bit)\\n            if oppo_bit in node.children:\\n                max_xor += oppo_bit\\n                node = node.children[oppo_bit]\\n            else:\\n                max_xor += bit\\n                node = node.children[bit]\\n\\n        return int(max_xor, 2) ^ cand_num\\n            \\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        # construct the trie\\n        for num in nums:\\n            bit_num = bin(num)[2:].zfill(32)\\n            self.insert_word(bit_num)\\n        \\n        max_xor_num = float(\\'-inf\\')\\n        for num in nums:\\n            max_xor_num = max(max_xor_num, self.find_max_xor(num))\\n            \\n        return max_xor_num\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def insert(self, word: str) -> None:\\n        \"\"\"\\n        Inserts a word into the trie.\\n        \"\"\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n        node.is_word = True\\n       \\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the trie.\\n        \"\"\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                return False\\n            node = node.children[ch]\\n        return node.is_word\\n            \\n    def startsWith(self, prefix: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that starts with the given prefix.\\n        \"\"\"\\n        node = self.root\\n        for ch in prefix:\\n            if ch not in node.children:\\n                return False\\n            node = node.children[ch]\\n        return True\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root =  TrieNode()\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n            \\n        node.is_word = True\\n        \\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        node = self.root\\n        return self.dfs(node, 0, word)\\n        \\n    def dfs(self, node, index, word):\\n        if len(word) == index:\\n            return node.is_word\\n        \\n        if word[index] == \\'.\\':\\n            for ch in node.children:\\n                if self.dfs(node.children[ch], index + 1, word):\\n                    return True\\n                \\n        if word[index] in node.children:\\n            return self.dfs(node.children[word[index]], index + 1, word)\\n        \\n        return False\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.is_word = False\\n        \\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n    \\n    def insert_word(self, word):\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n            \\n        node.is_word = True\\n\\n    def buildDict(self, dict: List[str]) -> None:\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"\\n        for word in dict:\\n            self.insert_word(word)\\n        \\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n        return self.dfs(self.root, 0, word, 0)\\n    \\n    def dfs(self, node, index, word, count): # count of mismatch\\n        if count > 1:\\n            return False\\n        \\n        if len(word) == index:\\n            return node.is_word and count == 1\\n        \\n        for ch in node.children:\\n            if self.dfs(node.children[ch], index + 1, word, count + (word[index] != ch)):\\n                return True\\n            \\n        return False\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n            \\n        node.is_word = True\\n        \\n    def startsWith(self, prefix): # return top three matches if exist\\n        node = self.root\\n        top_three = []\\n        for ch in prefix:\\n            if ch not in node.children:\\n                return []\\n            node = node.children[ch]\\n            \\n        return self.dfs(node, prefix, [])\\n            \\n    \\n    def dfs(self, node, prefix, words):\\n        if node.is_word:\\n            words.append(prefix)\\n            \\n        for ch in node.children:\\n            self.dfs(node.children[ch], prefix + ch, words)\\n        return words\\n        \\n        \\nclass Solution:\\n    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\\n        \\n        products.sort()\\n        trie = Trie()\\n        for product in products:\\n            trie.insert(product)\\n        \\n        res = []\\n        for i in range(len(searchWord)):\\n            res.append(trie.startsWith(searchWord[:i+1])[:3])\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334261,
                "title": "c-bit-mask-if-a-b-c-then-a-b-c",
                "content": "```\\npublic class Solution \\n{\\n    public int FindMaximumXOR(int[] nums) \\n    {\\n        // All positive so we can start with 30\\n        // no more than 31 so we can use an integer for the mask\\n        // if a^b=c then a=b^c\\n\\n        var mask = 0;\\n\\n        for (int i = 30; i >= 0; i--)\\n        {\\n            var contain1Set = new HashSet<int>();\\n            var contain0Set = new HashSet<int>();\\n            foreach (var number in nums)\\n            {\\n                if ((number >> i & 1) == 1)\\n                {\\n                    // i + 1 means the last one.\\n                    contain1Set.Add(number >> (i + 1));\\n                }\\n                else\\n                {\\n                    contain0Set.Add(number >> (i + 1));\\n                }\\n            }\\n\\n            if (contain1Set.Count == 0 || contain0Set.Count == 0) continue;\\n\\n            // get zero one\\n            foreach (var numberWithMask in contain0Set)\\n            {\\n                var belongTo1Set = ((mask >> (i + 1)) ^ numberWithMask);\\n\\n                if (contain1Set.Contains(belongTo1Set))\\n                {\\n                    mask |= (1 << i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int FindMaximumXOR(int[] nums) \\n    {\\n        // All positive so we can start with 30\\n        // no more than 31 so we can use an integer for the mask\\n        // if a^b=c then a=b^c\\n\\n        var mask = 0;\\n\\n        for (int i = 30; i >= 0; i--)\\n        {\\n            var contain1Set = new HashSet<int>();\\n            var contain0Set = new HashSet<int>();\\n            foreach (var number in nums)\\n            {\\n                if ((number >> i & 1) == 1)\\n                {\\n                    // i + 1 means the last one.\\n                    contain1Set.Add(number >> (i + 1));\\n                }\\n                else\\n                {\\n                    contain0Set.Add(number >> (i + 1));\\n                }\\n            }\\n\\n            if (contain1Set.Count == 0 || contain0Set.Count == 0) continue;\\n\\n            // get zero one\\n            foreach (var numberWithMask in contain0Set)\\n            {\\n                var belongTo1Set = ((mask >> (i + 1)) ^ numberWithMask);\\n\\n                if (contain1Set.Contains(belongTo1Set))\\n                {\\n                    mask |= (1 << i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176009,
                "title": "clean-java-solution-using-trie",
                "content": "```\\nclass Solution {\\n    TreeNode root;\\n    class TreeNode {\\n        int val;\\n        public TreeNode[] children;\\n        public TreeNode(){\\n            children = new TreeNode[2];\\n        }\\n    }\\n    public void insert(int word) {\\n        TreeNode cur = root;\\n        for(int i=31;i>=0;i--) {\\n            int j = ((word >>>i)&1) == 0?0:1;\\n            TreeNode child = cur.children[j];\\n            child = child == null?new TreeNode():child;\\n            cur.children[j] = child;\\n            cur = child;\\n        }\\n        cur.val = word;\\n    }\\n    public int getLarget(int prefix) {\\n        TreeNode cur = root;\\n        for(int i=31;i>=0;i--) {\\n            int j = ((prefix >>>i)&1 ) == 0?1:0;\\n            if(cur.children[j] == null) j = 1-j;\\n            TreeNode child = cur.children[j];\\n            cur = child;\\n        }\\n        return cur.val;\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        root = new TreeNode();\\n        for(int x:nums) insert(x);\\n        int max = 0;\\n        for(int x:nums) {\\n            max = Math.max(max,x^getLarget(x));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode root;\\n    class TreeNode {\\n        int val;\\n        public TreeNode[] children;\\n        public TreeNode(){\\n            children = new TreeNode[2];\\n        }\\n    }\\n    public void insert(int word) {\\n        TreeNode cur = root;\\n        for(int i=31;i>=0;i--) {\\n            int j = ((word >>>i)&1) == 0?0:1;\\n            TreeNode child = cur.children[j];\\n            child = child == null?new TreeNode():child;\\n            cur.children[j] = child;\\n            cur = child;\\n        }\\n        cur.val = word;\\n    }\\n    public int getLarget(int prefix) {\\n        TreeNode cur = root;\\n        for(int i=31;i>=0;i--) {\\n            int j = ((prefix >>>i)&1 ) == 0?1:0;\\n            if(cur.children[j] == null) j = 1-j;\\n            TreeNode child = cur.children[j];\\n            cur = child;\\n        }\\n        return cur.val;\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        root = new TreeNode();\\n        for(int x:nums) insert(x);\\n        int max = 0;\\n        for(int x:nums) {\\n            max = Math.max(max,x^getLarget(x));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160562,
                "title": "hashset-based-python-o-n-solution-with-explanatory-comments",
                "content": "```\\nclass Solution(object):\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        best = 0\\n        mask = 0\\n        for i in range(31, -1, -1): # O(n) for each bit. Going highest to lowest ensures we find max.\\n            mask = mask | (1 << i)\\n            s = {n & mask for n in nums} # fill a set full of prefixes of all the nums\\n            \\n            # The best known so far is only a prefix, but that\\'s definitely the prefix we want\\n            # because 2^n > 2^(n-1) + ... 2^0. Ideally we can set the ith bit too, so try. If\\n            # some prefix ^ some other prefix = guess, then we\\'re gucci because that prefix is\\n            # possible with the given numbers. Equivalently guess ^ some prefix = other prefix,\\n            # which we can check faster because of the magic of hash sets.\\n            guess = best | (1 << i)\\n            for prefix in s:\\n                if guess ^ prefix in s:\\n                    best = guess\\n                    break\\n                    \\n        return best",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        best = 0\\n        mask = 0\\n        for i in range(31, -1, -1): # O(n) for each bit. Going highest to lowest ensures we find max.\\n            mask = mask | (1 << i)\\n            s = {n & mask for n in nums}",
                "codeTag": "Java"
            },
            {
                "id": 147017,
                "title": "1-c-trie-solution-2-c-bitmanipulation-solution",
                "content": "TRIE:\\n```\\n#define MAX 31\\nstruct trie{\\n    int num;\\n    trie *child[2];\\n};\\ntrie* newnode(){\\n    trie *temp = new trie;\\n    temp->child[0]=temp->child[1]=NULL;\\n    temp->num = 0;\\n    return temp;\\n}\\nvoid insert(trie* root,int n){\\n   // trie *temp = root;\\n    for(int i=MAX;i>=0;i--){\\n        bool res = ((n)&(1<<i));\\n        if(root->child[res]==NULL)root->child[res]=newnode();\\n        root=root->child[res];\\n    }\\n    root->num = n;\\n    return;\\n}\\nint fxor(trie *root,int n){\\n    //trie *temp = root;\\n    for(int i=MAX;i>=0;i--){\\n        bool res = ((n)&(1<<i));\\n        if(root->child[1-res]!=NULL)root=root->child[1-res];\\n        else if(root->child[res]!=NULL)root=root->child[res];\\n    }\\n    return (root->num)^(n);\\n}\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        trie *root = newnode();\\n        insert(root,nums[0]);\\n        int res = 0;\\n        for(int i=1;i<nums.size();i++){\\n            int val = fxor(root,nums[i]);\\n            res = max(res,val);\\n            insert(root,nums[i]);\\n        }\\n        return res;\\n       \\n    }\\n};\\n```\\nBitmanip:\\n```\\nint maxi = 0,mask = 0;\\n        for(int i=31;i>=0;i--){\\n            mask = mask|(1<<i);\\n            set <int> s;\\n            for(int j=0;j<nums.size();j++){\\n                s.insert(mask&nums[j]);\\n            }\\n            int temp = maxi|(1<<i);\\n            for(int j=0;j<s.size();j++){\\n                if(s.find(temp ^ s[j])!=s.end()){\\n                    maxi = temp;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n\\t\\t\\t\\t```\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\n#define MAX 31\\nstruct trie{\\n    int num;\\n    trie *child[2];\\n};\\ntrie* newnode(){\\n    trie *temp = new trie;\\n    temp->child[0]=temp->child[1]=NULL;\\n    temp->num = 0;\\n    return temp;\\n}\\nvoid insert(trie* root,int n){\\n   // trie *temp = root;\\n    for(int i=MAX;i>=0;i--){\\n        bool res = ((n)&(1<<i));\\n        if(root->child[res]==NULL)root->child[res]=newnode();\\n        root=root->child[res];\\n    }\\n    root->num = n;\\n    return;\\n}\\nint fxor(trie *root,int n){\\n    //trie *temp = root;\\n    for(int i=MAX;i>=0;i--){\\n        bool res = ((n)&(1<<i));\\n        if(root->child[1-res]!=NULL)root=root->child[1-res];\\n        else if(root->child[res]!=NULL)root=root->child[res];\\n    }\\n    return (root->num)^(n);\\n}\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        trie *root = newnode();\\n        insert(root,nums[0]);\\n        int res = 0;\\n        for(int i=1;i<nums.size();i++){\\n            int val = fxor(root,nums[i]);\\n            res = max(res,val);\\n            insert(root,nums[i]);\\n        }\\n        return res;\\n       \\n    }\\n};\\n```\n```\\nint maxi = 0,mask = 0;\\n        for(int i=31;i>=0;i--){\\n            mask = mask|(1<<i);\\n            set <int> s;\\n            for(int j=0;j<nums.size();j++){\\n                s.insert(mask&nums[j]);\\n            }\\n            int temp = maxi|(1<<i);\\n            for(int j=0;j<s.size();j++){\\n                if(s.find(temp ^ s[j])!=s.end()){\\n                    maxi = temp;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 91078,
                "title": "5-line-c-o-n-solution-with-comments-on-time-complexity-about-o-n-vs-o-n-log-max-nums",
                "content": "This is my C++ version inspired by @StefanPochmann 's [Python solution](https://discuss.leetcode.com/topic/63299/python-6-lines-bit-by-bit).\\n\\n**Note:** Only ***distinct values*** in the original array `nums` matter to the final result.\\n\\nSo there is a minor difference in the commented code section where we could use a hash set `noDup` to store only distinct values from the original array `nums`. And `nums` can be abandoned from now on.\\n\\nThis minor change uses an extra `O(N)` pass to reduce inner loop length to build prefix hash set `pre` from `N` to `noDup.size()` for 32 times. Depending on exact test cases, this may or may not reduce running time.\\n\\nFor OJ's test cases, I can see a total running time reduction from about 318ms to 282ms.\\n\\n**Brief Explanation of Algorithm:** The goal is to find the maximum value `res = n1^n2`, where `n1, n2` in array `nums[]`. Note that the value of `res` is always dominated by its higher bit values, so we try to get the maximum `i`-position bit of `res` one by one (`i = 31` to `0`).\\n\\nIn the loop, `i` is the current bit location we try to build, `res` is the intermediate result with first `31-i` most significant bit positions already build to maximum `res` and with `i`-position initialized as `0`. To maximize `res`, it is equivalent to ask whether we could find `p1, p2` in the first `32-i` position prefixes from `nums[]` (i.e., `pre`) such that \\n* `p1^p2 = res^1` (note `res^1` is to only set `1` to last bit of `res` and keep others unchanged),\\n\\nand this is equivalent to `p1 = res^1^p2`, which means `p1` is in hashset `pre` for some `p2` also in `pre`.\\n\\nIf we could find such `p1, p2` in `pre`, we can build the maximum first `32-i` bits as `++res`, otherwise, still `res` unchanged. Repeat this process until all 32 bits are built.\\n```\\n    int findMaximumXOR(vector<int>& nums) {\\n        //unordered_set<int> noDup(nums.begin(), nums.end()); // remove duplicates\\n        for (int i = 31, res = 0; ; res<<=1) {\\n            unordered_set<int> pre;\\n            for (int a : nums /*noDup*/) pre.insert(a >> i);\\n            for (int p : pre) if (pre.count(res^1^p) && ++res) break;\\n            if (!i--) return res;\\n        }\\n    }       \\n```\\n**Comments on Time Complexity:** Either way, the algorithm above should have `O(N)`. Whether the outer loop length `32` should be counted as `O(log max(nums[]))` which contributes to an overall `O(N log max(nums[]))` time complexity depends on how the range condition `0 <= nums[i] < 2^31` is perceived, in my opinion: \\n* If it is considered as an *essential constraint* by the problem, then `32` should be considered as a constant.\\n* If it is perceived as a derived constraint due to the range of `int` type as in many common programming language, then the `32` is just the consequence of the data type limitation which is a non-essential condition from the original problem, so the factor `log max(nums[])` will come to play as an impact on the algorithm.\\n\\nFor example, if the problem did not explicitly state condition `0 <= nums[i] < 2^31` but only given `vector<int> nums` as the input argument of the method, then clearly, I would say the factor `log max(nums[])` definitely contributes to the complexity because the range of `int` is not imposed by the problem itself but simply due to how the data is represented. \\n\\nIf you consider this problem as a pure math question (i.e., all positive integers as input data), then the `log` factor will become clear. Just like many coding problems where we say `O(N), O(N^2)`, etc complexity, we certainly did not mean to put an upper bound on array size `N` simply due to language/computing resource limitations.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n    int findMaximumXOR(vector<int>& nums) {\\n        //unordered_set<int> noDup(nums.begin(), nums.end()); // remove duplicates\\n        for (int i = 31, res = 0; ; res<<=1) {\\n            unordered_set<int> pre;\\n            for (int a : nums /*noDup*/) pre.insert(a >> i);\\n            for (int p : pre) if (pre.count(res^1^p) && ++res) break;\\n            if (!i--) return res;\\n        }\\n    }       \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91124,
                "title": "java-bit-manipulation-and-divide-into-two-groups",
                "content": "```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n       int max = Integer.MIN_VALUE;\\n       int highBit = 0, count = 0;\\n       for(int num: nums) max = Math.max(max, num);\\n       while(count<=31){\\n           if((max & (1<<count)) != 0) highBit = count;\\n           count++;\\n       }\\n       List<Integer> isOne = new ArrayList<>();\\n       List<Integer> notOne = new ArrayList<>();\\n       \\n       for(int num: nums){\\n           if(((num>>highBit) & 1) == 1) isOne.add(num);\\n           else notOne.add(num);\\n       }\\n       \\n       return recur(isOne, notOne, highBit-1);\\n    }\\n    private int recur(List<Integer> isOne, List<Integer> notOne, int highBit){\\n        if(isOne.size()==1 && notOne.size()==1) return isOne.get(0) ^ notOne.get(0);\\n        \\n        List<Integer> l11 = new ArrayList<>();\\n        List<Integer> l10 = new ArrayList<>();\\n        List<Integer> l01 = new ArrayList<>();\\n        List<Integer> l00 = new ArrayList<>();\\n        \\n        for(int num: isOne){\\n            if(((num>>highBit) & 1) != 0) l11.add(num);\\n            else l10.add(num);\\n        }\\n        \\n        for(int num: notOne){\\n            if(((num>>highBit) & 1) != 0) l01.add(num);\\n            else l00.add(num);\\n        }\\n        \\n        int max = 0;\\n        if(l11.size()!=0 && l00.size()!=0) max = recur(l11, l00, highBit-1);\\n        if(l10.size()!=0 && l01.size()!=0) max = Math.max(max, recur(l10,l01,highBit-1));\\n        return max;\\n    }\\n}\\n\\n```\\n\\nTime: O(nlog(HighestBit))\\n\\nWelcome any improvement suggestion and welcome to find bugs.\\n\\nThanks!",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n       int max = Integer.MIN_VALUE;\\n       int highBit = 0, count = 0;\\n       for(int num: nums) max = Math.max(max, num);\\n       while(count<=31){\\n           if((max & (1<<count)) != 0) highBit = count;\\n           count++;\\n       }\\n       List<Integer> isOne = new ArrayList<>();\\n       List<Integer> notOne = new ArrayList<>();\\n       \\n       for(int num: nums){\\n           if(((num>>highBit) & 1) == 1) isOne.add(num);\\n           else notOne.add(num);\\n       }\\n       \\n       return recur(isOne, notOne, highBit-1);\\n    }\\n    private int recur(List<Integer> isOne, List<Integer> notOne, int highBit){\\n        if(isOne.size()==1 && notOne.size()==1) return isOne.get(0) ^ notOne.get(0);\\n        \\n        List<Integer> l11 = new ArrayList<>();\\n        List<Integer> l10 = new ArrayList<>();\\n        List<Integer> l01 = new ArrayList<>();\\n        List<Integer> l00 = new ArrayList<>();\\n        \\n        for(int num: isOne){\\n            if(((num>>highBit) & 1) != 0) l11.add(num);\\n            else l10.add(num);\\n        }\\n        \\n        for(int num: notOne){\\n            if(((num>>highBit) & 1) != 0) l01.add(num);\\n            else l00.add(num);\\n        }\\n        \\n        int max = 0;\\n        if(l11.size()!=0 && l00.size()!=0) max = recur(l11, l00, highBit-1);\\n        if(l10.size()!=0 && l01.size()!=0) max = Math.max(max, recur(l10,l01,highBit-1));\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715309,
                "title": "python-trie-solution-easy-to-understand",
                "content": "```\\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n        self.m=0\\n    \\n    def insert(self,word):\\n        node=self.root\\n        for ch in word:\\n            if ch not in node:\\n                node[ch]={}\\n            node=node[ch]\\n        \\n    def compare(self,word,i):\\n        node=self.root\\n        t=\"\"\\n        a,b=\\'0\\',\\'1\\'\\n        for ch in word:\\n            if ch==a and b in node:\\n                t+=b\\n                node=node[b]\\n            elif ch==b and a in node:\\n                t+=a\\n                node=node[a]\\n            else:\\n                t+=ch\\n                node=node[ch]\\n        self.m=max(self.m,int(t,2)^i)\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        trie=Trie()\\n        for i in nums:\\n            word=\"{:032b}\".format(i)\\n            trie.insert(word)\\n        for i in nums:\\n            word=\"{:032b}\".format(i)\\n            trie.compare(word,i)\\n        return trie.m\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Trie",
                    "Bitmask"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n        self.m=0\\n    \\n    def insert(self,word):\\n        node=self.root\\n        for ch in word:\\n            if ch not in node:\\n                node[ch]={}\\n            node=node[ch]\\n        \\n    def compare(self,word,i):\\n        node=self.root\\n        t=\"\"\\n        a,b=\\'0\\',\\'1\\'\\n        for ch in word:\\n            if ch==a and b in node:\\n                t+=b\\n                node=node[b]\\n            elif ch==b and a in node:\\n                t+=a\\n                node=node[a]\\n            else:\\n                t+=ch\\n                node=node[ch]\\n        self.m=max(self.m,int(t,2)^i)\\n\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        trie=Trie()\\n        for i in nums:\\n            word=\"{:032b}\".format(i)\\n            trie.insert(word)\\n        for i in nums:\\n            word=\"{:032b}\".format(i)\\n            trie.compare(word,i)\\n        return trie.m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714281,
                "title": "easy-solution-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    Node* links[2];\\n    public:\\n    bool containsKey(int bit)\\n    {\\n        return links[bit]!=NULL;\\n    }\\n    void put(int bit,Node* node)\\n    {\\n        links[bit]=node;\\n    }\\n    Node* get(int bit)\\n    {\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n    Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!node->containsKey(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n\\n        }\\n    }\\n    int getMax(int num)\\n    {\\n        Node* node=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(node->containsKey(1-bit))\\n            {\\n                maxNum=maxNum|(1<<i);\\n                node=node->get(1-bit);\\n            }\\n            else{\\n                node=node->get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        Trie trie;\\n        for(auto it:nums)\\n        {\\n            trie.insert(it);\\n        }\\n    \\n        int maxi=0;\\n        for(auto it:nums)\\n        {\\n            maxi=max(maxi,trie.getMax(it));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[2];\\n    public:\\n    bool containsKey(int bit)\\n    {\\n        return links[bit]!=NULL;\\n    }\\n    void put(int bit,Node* node)\\n    {\\n        links[bit]=node;\\n    }\\n    Node* get(int bit)\\n    {\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n    Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!node->containsKey(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n\\n        }\\n    }\\n    int getMax(int num)\\n    {\\n        Node* node=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(node->containsKey(1-bit))\\n            {\\n                maxNum=maxNum|(1<<i);\\n                node=node->get(1-bit);\\n            }\\n            else{\\n                node=node->get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        Trie trie;\\n        for(auto it:nums)\\n        {\\n            trie.insert(it);\\n        }\\n    \\n        int maxi=0;\\n        for(auto it:nums)\\n        {\\n            maxi=max(maxi,trie.getMax(it));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844042,
                "title": "c-trie-solution-with-comments-faster-than-98",
                "content": "**Intuition**: So here we are trying to create a Trie for numbers given in the array in their Binary representation.\\n**Intuition for maximum xor** : so we know that for xor to return 1 bit has to be different , so we are trying to find the opposite bit for the particular number and it is possible that we don\\'t find the opposite bit then just go to same bit only , basically we are trying to find as much as different bits that we find ,because that gives us more number of 1s in xor that leads to maximization of xor\\n```\\nclass TrieNode{\\n    public:\\n    TrieNode *children[2];\\n    TrieNode()\\n    {\\n        this->children[0]=NULL;\\n        this->children[1]=NULL;\\n    }\\n};\\nclass Trie{\\n    private:\\n        TrieNode *root;\\n    public:\\n    Trie(){\\n     root = new TrieNode();\\n     \\n    }\\n    \\n    void insert(int num){\\n        TrieNode* node=root;\\n        \\n        for(int i=31;i>=0;i--){\\n            int bit =  (num>>i)&1;\\n\\t\\t\\t\\tif(node->children[bit]==NULL){       \\n                node->children[bit] = new TrieNode();\\n            }\\n            node = node->children[bit];\\n        }\\n    }\\n    int getMax(int num){\\n        TrieNode* node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(node->children[1-bit]){      //checking if the compliment bit is present in the trie\\n                node = node->children[1-bit];  //if present then just go to that node\\n                maxi = maxi | (1<<i); //and at that bit mark xor as 1 , because at this place both numbers have different bits\\n            }\\n            else{\\n                node = node->children[bit];   //if compliment bit not present then just go to that same bit only in the search , that in future we got bits that are different than the bits of this particular number\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie t;\\n        for(auto i:nums){\\n            t.insert(i);   //inserting every number into Trie\\n        }\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi = max(maxi,t.getMax(i));      //for each number in the array , try to find the number inside the array only. that give us maximum xor.\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```\\nUpvote if you got the solution.Thanks",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\n    public:\\n    TrieNode *children[2];\\n    TrieNode()\\n    {\\n        this->children[0]=NULL;\\n        this->children[1]=NULL;\\n    }\\n};\\nclass Trie{\\n    private:\\n        TrieNode *root;\\n    public:\\n    Trie(){\\n     root = new TrieNode();\\n     \\n    }\\n    \\n    void insert(int num){\\n        TrieNode* node=root;\\n        \\n        for(int i=31;i>=0;i--){\\n            int bit =  (num>>i)&1;\\n\\t\\t\\t\\tif(node->children[bit]==NULL){       \\n                node->children[bit] = new TrieNode();\\n            }\\n            node = node->children[bit];\\n        }\\n    }\\n    int getMax(int num){\\n        TrieNode* node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(node->children[1-bit]){      //checking if the compliment bit is present in the trie\\n                node = node->children[1-bit];  //if present then just go to that node\\n                maxi = maxi | (1<<i); //and at that bit mark xor as 1 , because at this place both numbers have different bits\\n            }\\n            else{\\n                node = node->children[bit];   //if compliment bit not present then just go to that same bit only in the search , that in future we got bits that are different than the bits of this particular number\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie t;\\n        for(auto i:nums){\\n            t.insert(i);   //inserting every number into Trie\\n        }\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi = max(maxi,t.getMax(i));      //for each number in the array , try to find the number inside the array only. that give us maximum xor.\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485371,
                "title": "c-using-trie",
                "content": "# Method 1\\n\\n```\\nclass TrieNode\\n{\\npublic:\\n    TrieNode *children[2];\\n    TrieNode()\\n    {\\n        children[0] = NULL;\\n        children[1] = NULL;\\n    }\\n};\\n\\nclass Trie\\n{\\npublic:\\n    TrieNode *root;\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(int n)\\n    {\\n        TrieNode *node=root;\\n        for (int i = 31; i >= 0; i--)\\n        {\\n            int index = ((n >> i) & (1));\\n\\n            if (node->children[index] != NULL)\\n            {\\n                node = node->children[index];\\n            }\\n            else\\n            {\\n                TrieNode *child = new TrieNode();\\n                node->children[index] = child;\\n                 node = node->children[index];\\n            }\\n        }\\n    }\\n\\n    int maxXor(int n)\\n    {\\n        TrieNode *node=root;\\n        int ans = 0;\\n        for (int i = 31; i >= 0; i--)\\n        {\\n            int index = ((n >> i) & (1));\\n\\n            if (node->children[1 - index] != NULL)\\n            {\\n                node = node->children[1 - index];\\n                ans += (1 << i);\\n            }\\n            else\\n            {\\n                node = node->children[index];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nclass Solution\\n{\\npublic:\\n    int findMaximumXOR(vector<int> &arr)\\n    {\\n\\n        int N = arr.size();\\n        if (N == 1)\\n            return 0;\\n        Trie *Node = new Trie();\\n        int ans = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            Node->insert(arr[i]);\\n        }\\n\\n        for (int i = 0; i < N; i++)\\n        {\\n            ans = max(ans, Node->maxXor(arr[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Method 2\\n\\n\\n```\\nclass TrieNode{\\n    public:\\n        TrieNode*children[2];\\n        TrieNode(){\\n            for(int i=0;i<2;i++){\\n                children[i]=NULL;\\n            }\\n        }\\n\\n};\\n\\n\\nclass Trie {\\npublic:\\n    TrieNode*root;\\n    Trie(){\\n        root=new TrieNode();\\n    }\\n       void insertUtil(TrieNode*&root,int n,int m){\\n        if(m<0){\\n            return;\\n        }\\n        int index=((n>>m)&(1));\\n        TrieNode*child;\\n        if(root->children[index]!=NULL){\\n         child=root->children[index];\\n        }\\n        else{\\n            child=new TrieNode();\\n           root->children[index]=child;\\n        }\\n        return insertUtil(child,n,m-1);\\n    }\\n    \\n    void insert(int n){\\n       insertUtil(root,n,31);\\n    }\\n    \\n    \\n    \\n    int maxXor(TrieNode*root,int n,int m){\\n        if(m<0){\\n            return 0;\\n        }\\n        int index=((n>>m)&(1));\\n        int ans=0;\\n        TrieNode*child;\\n        if(root->children[1-index]!=NULL){\\n         child=root->children[1-index];\\n         ans+=(1<<m);\\n        }else{\\n            child=root->children[index];\\n        }\\n        return ans+maxXor(child,n,m-1);\\n    }\\n    \\n    \\n    int mx(int n){\\n        return maxXor(root,n,31);\\n    }\\n    \\n    \\n};\\nclass Solution\\n{\\n    public:\\n   int findMaximumXOR(vector<int>& arr)\\n    {\\n        \\n        int N=arr.size();\\n       if(N==1)return 0;\\n        Trie* Node=new Trie();int ans=0;\\n        for(int i=0;i<N;i++){\\n            Node->insert(arr[i]);\\n        }\\n        \\n        \\n         for(int i=0;i<N;i++){\\n           ans=max(ans,Node->mx(arr[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode\\n{\\npublic:\\n    TrieNode *children[2];\\n    TrieNode()\\n    {\\n        children[0] = NULL;\\n        children[1] = NULL;\\n    }\\n};\\n\\nclass Trie\\n{\\npublic:\\n    TrieNode *root;\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(int n)\\n    {\\n        TrieNode *node=root;\\n        for (int i = 31; i >= 0; i--)\\n        {\\n            int index = ((n >> i) & (1));\\n\\n            if (node->children[index] != NULL)\\n            {\\n                node = node->children[index];\\n            }\\n            else\\n            {\\n                TrieNode *child = new TrieNode();\\n                node->children[index] = child;\\n                 node = node->children[index];\\n            }\\n        }\\n    }\\n\\n    int maxXor(int n)\\n    {\\n        TrieNode *node=root;\\n        int ans = 0;\\n        for (int i = 31; i >= 0; i--)\\n        {\\n            int index = ((n >> i) & (1));\\n\\n            if (node->children[1 - index] != NULL)\\n            {\\n                node = node->children[1 - index];\\n                ans += (1 << i);\\n            }\\n            else\\n            {\\n                node = node->children[index];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nclass Solution\\n{\\npublic:\\n    int findMaximumXOR(vector<int> &arr)\\n    {\\n\\n        int N = arr.size();\\n        if (N == 1)\\n            return 0;\\n        Trie *Node = new Trie();\\n        int ans = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            Node->insert(arr[i]);\\n        }\\n\\n        for (int i = 0; i < N; i++)\\n        {\\n            ans = max(ans, Node->maxXor(arr[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass TrieNode{\\n    public:\\n        TrieNode*children[2];\\n        TrieNode(){\\n            for(int i=0;i<2;i++){\\n                children[i]=NULL;\\n            }\\n        }\\n\\n};\\n\\n\\nclass Trie {\\npublic:\\n    TrieNode*root;\\n    Trie(){\\n        root=new TrieNode();\\n    }\\n       void insertUtil(TrieNode*&root,int n,int m){\\n        if(m<0){\\n            return;\\n        }\\n        int index=((n>>m)&(1));\\n        TrieNode*child;\\n        if(root->children[index]!=NULL){\\n         child=root->children[index];\\n        }\\n        else{\\n            child=new TrieNode();\\n           root->children[index]=child;\\n        }\\n        return insertUtil(child,n,m-1);\\n    }\\n    \\n    void insert(int n){\\n       insertUtil(root,n,31);\\n    }\\n    \\n    \\n    \\n    int maxXor(TrieNode*root,int n,int m){\\n        if(m<0){\\n            return 0;\\n        }\\n        int index=((n>>m)&(1));\\n        int ans=0;\\n        TrieNode*child;\\n        if(root->children[1-index]!=NULL){\\n         child=root->children[1-index];\\n         ans+=(1<<m);\\n        }else{\\n            child=root->children[index];\\n        }\\n        return ans+maxXor(child,n,m-1);\\n    }\\n    \\n    \\n    int mx(int n){\\n        return maxXor(root,n,31);\\n    }\\n    \\n    \\n};\\nclass Solution\\n{\\n    public:\\n   int findMaximumXOR(vector<int>& arr)\\n    {\\n        \\n        int N=arr.size();\\n       if(N==1)return 0;\\n        Trie* Node=new Trie();int ans=0;\\n        for(int i=0;i<N;i++){\\n            Node->insert(arr[i]);\\n        }\\n        \\n        \\n         for(int i=0;i<N;i++){\\n           ans=max(ans,Node->mx(arr[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436684,
                "title": "python3-solution-bit-maniputlation",
                "content": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        cmax = 0\\n        for i in range(31, -1, -1):\\n            tmp = cmax | (1 << i)\\n            S = set(tmp & j for j in nums)\\n            if any(j ^ tmp in S for j in S): \\n                cmax = tmp\\n        return cmax\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        cmax = 0\\n        for i in range(31, -1, -1):\\n            tmp = cmax | (1 << i)\\n            S = set(tmp & j for j in nums)\\n            if any(j ^ tmp in S for j in S): \\n                cmax = tmp\\n        return cmax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320617,
                "title": "c-trie-binary-tree-structure",
                "content": "\\tclass TrieNode{\\n\\t\\tpublic :\\n\\t\\t\\tTrieNode* left;\\n\\t\\t\\tTrieNode* right;\\n\\n\\t\\t\\tTrieNode(){\\n\\t\\t\\t\\tleft = nullptr;\\n\\t\\t\\t\\tright = nullptr;\\n\\t\\t\\t}\\n\\t};\\n\\n\\tclass Trie{\\n\\t\\tTrieNode* root;\\n\\n\\t\\tpublic :\\n\\t\\t\\tTrie(){\\n\\t\\t\\t\\troot = new TrieNode();        \\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid Insert(int num){\\n\\t\\t\\t\\tTrieNode* curr = root;\\n\\t\\t\\t\\tfor(int i = 31 ; i >= 0 ; i--){\\n\\t\\t\\t\\t   int bit = (1 << i)&num;\\n\\t\\t\\t\\t   if(bit == 0){\\n\\t\\t\\t\\t\\t  if(curr -> left == nullptr){\\n\\t\\t\\t\\t\\t\\t curr -> left = new TrieNode();\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  curr = curr -> left;\\n\\t\\t\\t\\t   }else{\\n\\t\\t\\t\\t\\t  if(curr -> right == nullptr){\\n\\t\\t\\t\\t\\t\\t curr -> right = new TrieNode();\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  curr = curr -> right;\\n\\t\\t\\t\\t   }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint MaxXorPair(int n , vector<int> v){\\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\t\\t\\t\\tInsert(v[i]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint Xor = INT_MIN;\\n\\t\\t\\t\\tfor(int i = 0 ;i < n ; i++){\\n\\t\\t\\t\\t\\tint curr_xor = 0;\\n\\t\\t\\t\\t\\tTrieNode* curr = root;\\n\\t\\t\\t\\t\\tfor(int j = 31 ;j >= 0 ; j--){\\n\\t\\t\\t\\t\\t\\tint bit = (1 << j) & v[i];\\n\\t\\t\\t\\t\\t\\tif(bit == 0){\\n\\t\\t\\t\\t\\t\\t\\tif(curr -> right != nullptr){\\n\\t\\t\\t\\t\\t\\t\\t\\tcurr_xor += (1 << j);\\n\\t\\t\\t\\t\\t\\t\\t\\tcurr = curr -> right;\\n\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t\\tcurr = curr -> left;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\tif(curr -> left != nullptr){\\n\\t\\t\\t\\t\\t\\t\\t\\tcurr_xor += (1 << j);\\n\\t\\t\\t\\t\\t\\t\\t\\tcurr = curr -> left;\\n\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t\\tcurr = curr -> right;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tXor = max(Xor , curr_xor);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn Xor;\\n\\t\\t\\t}\\n\\t};\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\t\\t Trie t;\\n\\t\\t\\t return t.MaxXorPair(nums.size() , nums);    \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\t\\t Trie t;\\n\\t\\t\\t return t.MaxXorPair(nums.size() , nums);    \\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2171134,
                "title": "c-efficient-solution-tries-bit-magic",
                "content": "\\n42 / 42 test cases passed.\\n**Status:** Accepted\\n**Runtime:** 304 ms\\n**Memory Usage:** 64.3 MB\\n```\\nstruct Node{\\n  Node* links[2];\\n    \\n    bool containsKey(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    Node* getNode(int bit){\\n        return links[bit];\\n    }\\n    void putNode(int bit,Node* node){\\n        links[bit]=node;\\n    }\\n};\\n\\nclass Trie{\\n  private : Node* root;\\n  public:\\n    Trie(){\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        root=new Node();\\n    }\\n    \\n    void insert(int& num){\\n        Node* node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=!!((num>>i) & 1);\\n            if(!node->containsKey(bit))\\n                node->putNode(bit, new Node());\\n            node=node->getNode(bit);\\n        }\\n    }\\n    \\n    int getMaxXOR(int num){\\n        Node* node=root;\\n        \\n        int maxNum=0;\\n        for(int i=31;i>=0;i--){\\n            int bit = !!((num>>i) & 1);\\n            if(node->containsKey(!bit)){\\n                maxNum |= (1<<i);\\n                node=node->getNode(!bit);\\n            }\\n            else node=node->getNode(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie *trie = new Trie();\\n        for(int &x : nums) trie->insert(x);\\n        int maxi=0;\\n        \\n        for(int &x: nums) maxi=max(maxi, trie->getMaxXOR(x));\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nstruct Node{\\n  Node* links[2];\\n    \\n    bool containsKey(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    Node* getNode(int bit){\\n        return links[bit];\\n    }\\n    void putNode(int bit,Node* node){\\n        links[bit]=node;\\n    }\\n};\\n\\nclass Trie{\\n  private : Node* root;\\n  public:\\n    Trie(){\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        root=new Node();\\n    }\\n    \\n    void insert(int& num){\\n        Node* node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=!!((num>>i) & 1);\\n            if(!node->containsKey(bit))\\n                node->putNode(bit, new Node());\\n            node=node->getNode(bit);\\n        }\\n    }\\n    \\n    int getMaxXOR(int num){\\n        Node* node=root;\\n        \\n        int maxNum=0;\\n        for(int i=31;i>=0;i--){\\n            int bit = !!((num>>i) & 1);\\n            if(node->containsKey(!bit)){\\n                maxNum |= (1<<i);\\n                node=node->getNode(!bit);\\n            }\\n            else node=node->getNode(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie *trie = new Trie();\\n        for(int &x : nums) trie->insert(x);\\n        int maxi=0;\\n        \\n        for(int &x: nums) maxi=max(maxi, trie->getMaxXOR(x));\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011173,
                "title": "classic-trie",
                "content": "**Intuition:** \\n\\nBrute Force:\\nWe can used two for loops and try out all pairs . Complexity - O(N^2)\\n\\n**General Concept**\\n\\n*This is an important concept and can be used for variety of concepts .*\\n\\nWe know if `a^b = c` then `a^c = b` . We can use this approach to find efficient solution .\\n\\nSuppose we know 2 numbers A and B, so our question reduces to find max number C such that `A ^ B = C` \\nConsider binary representation of both numbers ( suppose A = 0100111 and some B as 0100010 and we have to find C)\\nlet C = `XXXXXXX` and X can be 0/1 \\nand using the property `a^c = b`\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tA   0 1 0 0 1 1 1 \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tC   X X X X X X X\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\nNow for maximising C let see each bit from MSB , since A\\'s bit is 0, so  max C can be 1XXXXXX , now this is possible only if B has 1 at that respective bit , since B has 0 at that bit so C cannot have 0 at that bit so C so far is 0XXXXXX\\n\\nNow see second MSB , A\\'s bit is 1 and C was 0XXXXXX, so for max C we can have 01XXXXX, now this is possible only if B has 1 at that respective bit, and B has 1 at bit so C can have 1 at bit so C became 01XXXXX.\\n\\nWe keep on repeating this and we can find max C .\\n\\n**How to implement this**\\n\\nIf this was a single number we can cehck it bit by bit. But if there are N numbers ie. given N numbers and a given number B, find max XOR possible .\\n\\nThe main problem is, if we have assumed a possible bit for C, then that bit is possible only if any N number at that position has that bit.\\n\\n1) We can possible use a hashMap and iterate on these N numbers and find all numbers which has our possible bit for C. For next check we have to use these numbers and increment the count of numbers which has frequency equal to the bit position as if bit position is equal to frequency it means it has satisfied conditions for previous bits .\\n\\n2) We can also use trie for this . We can store all N numbers in trie, Now for C= XXXXXX if we assume MSB as 1 ie C= 1XXXXX then search in trie if 1 exists or not , if it exists then move pointer to next reference trie,  now C=1XXXXX, now suppose 2nd MSB as 11XXXX and check if 1 is there or not , if suppose there is no 1 then make this as 0 and place the reference pointer to 0 as 1 was not present .\\n\\n\\n**Extending the solution for this problem**\\n\\nThis question has now became extension to the above problem, just we are not given another number B it is same as element of the array \\n\\nSolution: \\n\\n```\\nstruct Node {\\n    Node * links[2] ;\\n    bool flag = false; \\n    \\n    bool containsKey(int bit){\\n        return links[bit] != NULL ;\\n    }\\n    void putKey(int bit , Node * node){\\n        links[bit] = node ;\\n    }\\n    Node * nextNode(int bit){\\n        return links[bit] ;\\n    }\\n    void setEnd(){\\n        flag = true ;\\n    }\\n};\\nclass Trie {\\n    private: Node* root ;\\n    public:  \\n    Trie(){\\n        root = new Node() ;\\n    }\\n    void insert(int n){\\n        Node * node = root ;\\n        for(int i = 31 ;i>=0 ; i--){\\n            int bit = (n>>i) & 1 ;\\n            if(!node->containsKey(bit)){\\n                node->putKey(bit, new Node()) ;\\n            }\\n            node = node->nextNode(bit) ;\\n        }\\n        node->setEnd();\\n    }\\n    int search(int n){\\n        Node * node = root ;\\n        int ans = 0 ;\\n        for(int i = 31 ;i>=0; i--){\\n            int bit = (n>>i) & 1 ;\\n            if(node->containsKey(1-bit)){\\n                ans = ans ^ (1<<i) ;\\n                node = node->nextNode(1-bit);\\n            }\\n            else {\\n                node = node->nextNode(bit);\\n            }\\n        }\\n        return ans ;\\n    }  \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie ;\\n        for(auto it: nums){\\n            trie.insert(it);\\n        }\\n        int ans  = 0 ;\\n        for(auto it: nums){\\n            ans = max(ans, trie.search(it)) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n    Node * links[2] ;\\n    bool flag = false; \\n    \\n    bool containsKey(int bit){\\n        return links[bit] != NULL ;\\n    }\\n    void putKey(int bit , Node * node){\\n        links[bit] = node ;\\n    }\\n    Node * nextNode(int bit){\\n        return links[bit] ;\\n    }\\n    void setEnd(){\\n        flag = true ;\\n    }\\n};\\nclass Trie {\\n    private: Node* root ;\\n    public:  \\n    Trie(){\\n        root = new Node() ;\\n    }\\n    void insert(int n){\\n        Node * node = root ;\\n        for(int i = 31 ;i>=0 ; i--){\\n            int bit = (n>>i) & 1 ;\\n            if(!node->containsKey(bit)){\\n                node->putKey(bit, new Node()) ;\\n            }\\n            node = node->nextNode(bit) ;\\n        }\\n        node->setEnd();\\n    }\\n    int search(int n){\\n        Node * node = root ;\\n        int ans = 0 ;\\n        for(int i = 31 ;i>=0; i--){\\n            int bit = (n>>i) & 1 ;\\n            if(node->containsKey(1-bit)){\\n                ans = ans ^ (1<<i) ;\\n                node = node->nextNode(1-bit);\\n            }\\n            else {\\n                node = node->nextNode(bit);\\n            }\\n        }\\n        return ans ;\\n    }  \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie ;\\n        for(auto it: nums){\\n            trie.insert(it);\\n        }\\n        int ans  = 0 ;\\n        for(auto it: nums){\\n            ans = max(ans, trie.search(it)) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991276,
                "title": "java-c-python-javascript-php-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Node {\\n    HashMap<Integer, Node> children;\\n    Node() {\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie {\\n    Node root;\\n    \\n    Trie() {\\n        this.root = new Node();\\n    }\\n    \\n    public void insert(int[] A) {\\n        for(int num : A) {\\n            Node curr = this.root;\\n            for(int i=31;i>=0;i--) {\\n                int currBit = (num >> i) & 1;\\n                if(!curr.children.containsKey(currBit)) \\n                    curr.children.put(currBit, new Node());\\n                curr = curr.children.get(currBit);\\n            }\\n        }\\n    }\\n}\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        Trie trie = new Trie();\\n        trie.insert(nums);\\n        \\n        int max = 0;\\n\\n        for(int num : nums) {\\n            Node curr = trie.root;\\n            int currSum = 0;\\n            for(int i=31;i>=0;i--) {\\n                int requiredBit = 1-((num >> i) & 1); // if A[i] is 0, we need 1 and if A[i] is 1, we need 0. Thus, 1 - A[i]\\n                if(curr.children.containsKey(requiredBit)) {\\n                    currSum |= (1<<i); // set ith bit of curr result\\n                    curr = curr.children.get(requiredBit);\\n                } else {\\n                    curr = curr.children.get(1-requiredBit);\\n                }\\n            }\\n            max = Math.max(max, currSum); // get max number\\n        }\\n        return max;\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    struct node{\\n        // val at the leaf is value of path from root to leaf\\n        int val;\\n        // two links, 0 and 1, for each bit\\n        struct node* link[2];\\n        node(){\\n            val=0;\\n            link[0]=link[1]=NULL;\\n        }\\n    };\\n    struct node* start=new node();\\n    \\n    void insertTrie(int x){\\n    \\t// straightforward insertion from msb to lsb\\n        struct node* ptr=start;\\n        for(int i=31;i>=0;i--){\\n            bool curbit=(x&(1<<i));\\n            if(ptr->link[curbit]==NULL)\\n                ptr->link[curbit]=new node();\\n            ptr=ptr->link[curbit];\\n        }\\n        ptr->val=x;\\n    }\\n    \\n    int checkTrie(int x){\\n    \\t// checking from msb to lsb(least significat bit)\\n        struct node* ptr=start;\\n        for(int i=31;i>=0;i--){\\n            bool curbit=(x&(1<<i));\\n            // if curbit is 1,see if we can have a number with that bit 0 to maximize the xor\\n            if(ptr->link[1-curbit]!=NULL)\\n                ptr=ptr->link[1-curbit];\\n            // if not then proceed with curbit\\n            else if(ptr->link[curbit]!=NULL)\\n                ptr=ptr->link[curbit];\\n        }\\n        return ptr->val;    \\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans=0,n=nums.size();\\n        if(nums.size()<2) return 0;\\n        insertTrie(nums[0]);\\n        for(int i=1;i<n;i++){\\n        \\t// for nums[i], we are finding element in nums[0 to i-1] with which it\\'s xor will be max\\n            ans=max(ans,nums[i]^checkTrie(nums[i]));\\n            // add nums[i] to the trie\\n            insertTrie(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()                        # children nodes\\n        self.val = 0                                  # end value \\n\\nclass Trie:\\n    def __init__(self, n):\\n        self.root = TrieNode()                        # root node\\n        self.n = n                                    # max length of all numbers\\n        \\n    def add_num(self, num):\\n        node = self.root \\n        for shift in range(self.n, -1, -1):           # only shift self.n bits \\n            val = 1 if num & (1 << shift) else 0      # verify bit from left to right \\n            if val not in node.children:\\n                node.children[val] = TrieNode()\\n            node = node.children[val]\\n        node.val = num\\n        \\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        max_len = len(bin(max(nums))) - 2             # get max length of all numbers\\' binary\\n        trie = Trie(max_len)\\n        for num in nums: trie.add_num(num)            # build trie\\n            \\n        ans = 0\\n        for num in nums:                              # for each num, find the number which can create max value with num using XOR\\n            node = trie.root \\n            for shift in range(max_len, -1, -1):\\n                val = 1 if num & (1 << shift) else 0  # verify bit from left to right\\n                node = node.children[1-val] if 1-val in node.children else node.children[val] # try opposite bit first, otherwise use same bit\\n            ans = max(ans, num ^ node.val)            # maintain maximum\\n        return ans    \\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar findMaximumXOR = function(nums) {\\n    let max = 0;\\n    for (let i = 31; i >= 0; --i) {   // we start from 31 as we have 32 bit integers\\n        const mask = (~0 >>> i) << i; // this is just i 1s followed by zeros: 1100..00 for i = 2\\n        const set = new Set();  // using set for constant access time, as o/w need to loop through the array and would have had O(N\\u02C62) time\\n        for (let num of nums) {\\n            set.add(num & mask); // adding the prefixes of all nums to the lookup set to check if we have a candidate\\n        }\\n        const maxCandidate = max | 1 << i; // we wand to check if in our set there are two numbers that xored will give us the best possible previous result with a 1 at the end. If yes, we will update the best possible result with 1, if not with 0.\\n        for (let num of set) {\\n            const another = maxCandidate ^ num; // this is the number we need to have num ^another === maxCandidate\\n            if (set.has(another)) { // if we have such, update maxCandidate => add 1 at the end. If not - in the next iteration i will increment, and as we did not add the 1, we will have 0 at this position.\\n                max = maxCandidate;\\n                break;\\n            }\\n        }\\n    }\\n    return max; // as we went from left to right all bits, the maxCandidate is as well the maximum.\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***PHP***\\n```\\nfunction findMaximumXOR($nums) {\\n\\t\\t$len = count($nums)-1;\\n\\t\\trsort($nums);\\n\\t\\t$maxLen = strlen(decbin($nums[0]));\\n\\t\\t$max=0;\\n\\t\\tfor ($i=0; $i<=$len; $i++) {\\n\\t\\t\\tif (strlen(decbin($nums[$i]))<$maxLen) break;\\n\\t\\t\\tfor ($j=$i+1; $j<=$len; $j++) {\\n\\t\\t\\t\\t$temp = $nums[$i] ^ $nums[$j];\\n\\t\\t\\t\\tif ($temp>$max) {\\n\\t\\t\\t\\t\\t$max=$temp;\\n\\t\\t\\t\\t\\t$maxLen=strlen((decbin($max)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn $max;\\n\\t}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    class Node {\\n        var zero: Node? = nil\\n        var one: Node? = nil\\n        \\n        var isLeaf: Bool {\\n            return zero == nil && one == nil\\n        }\\n    }\\n    \\n    //invariant: all branches have the same depth\\n    struct Trie {\\n        let root: Node = Node()\\n        let maxDigits: Int\\n        \\n        init(_ maxNum: Int) {\\n            maxDigits = maxNum.bitWidth - maxNum.leadingZeroBitCount\\n        }\\n        \\n        func insert(_ num: Int) {\\n            var currentNode = root\\n            \\n            for i in stride(from: maxDigits, to: 0, by: -1) {\\n                if num & (1 << (i-1)) == 0 {\\n                    if currentNode.zero == nil {\\n                        currentNode.zero = Node()\\n                    }\\n                    currentNode = currentNode.zero!\\n                } else {\\n                    if currentNode.one == nil {\\n                        currentNode.one = Node()\\n                    }\\n                    currentNode = currentNode.one!\\n                }\\n            }\\n        }\\n        \\n        //returns at least 0\\n        func getMax() -> Int {\\n            return getMaxRec(root,root,0)\\n        }\\n        \\n        func getMaxRec(_ n1: Node?, _ n2: Node?, _ startingValue: Int) -> Int {\\n            guard let n1 = n1 else {return 0}\\n            guard let n2 = n2 else {return 0}\\n            \\n            //base case:\\n            //using the invariant, we are at the bottom of the tree, so return the startingValue\\n            guard !(n1.isLeaf && n2.isLeaf) else {return startingValue}\\n            \\n            let newVal = startingValue << 1\\n            var val1 = getMaxRec(n1.one, n2.zero, newVal + 1)\\n            var val2 = getMaxRec(n1.zero, n2.one, newVal + 1)\\n            let best = max(val1,val2)\\n            \\n            if best > 0 {\\n                return best\\n            } else {\\n                val1 = getMaxRec(n1.one, n2.one, newVal + 0)\\n                val2 = getMaxRec(n1.zero, n2.zero, newVal + 0)\\n                return max(val1,val2)\\n            }\\n        }\\n    }\\n    \\n    func findMaximumXOR(_ nums: [Int]) -> Int {\\n        //if you remove the next two lines and update the maxDigits of the trie as you go, you can get the runtime down to 760ms (from 1162ms), but it adds a lot of complexity, so I\\'m not including it in this post.\\n        guard nums.count > 1 else {return 0}\\n        let maxNum = nums.max()!\\n\\n        let trie = Trie(maxNum)\\n        \\n        for num in nums {\\n            trie.insert(num)\\n        }\\n        \\n        return trie.getMax()\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Node {\\n    HashMap<Integer, Node> children;\\n    Node() {\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie {\\n    Node root;\\n    \\n    Trie() {\\n        this.root = new Node();\\n    }\\n    \\n    public void insert(int[] A) {\\n        for(int num : A) {\\n            Node curr = this.root;\\n            for(int i=31;i>=0;i--) {\\n                int currBit = (num >> i) & 1;\\n                if(!curr.children.containsKey(currBit)) \\n                    curr.children.put(currBit, new Node());\\n                curr = curr.children.get(currBit);\\n            }\\n        }\\n    }\\n}\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        Trie trie = new Trie();\\n        trie.insert(nums);\\n        \\n        int max = 0;\\n\\n        for(int num : nums) {\\n            Node curr = trie.root;\\n            int currSum = 0;\\n            for(int i=31;i>=0;i--) {\\n                int requiredBit = 1-((num >> i) & 1); // if A[i] is 0, we need 1 and if A[i] is 1, we need 0. Thus, 1 - A[i]\\n                if(curr.children.containsKey(requiredBit)) {\\n                    currSum |= (1<<i); // set ith bit of curr result\\n                    curr = curr.children.get(requiredBit);\\n                } else {\\n                    curr = curr.children.get(1-requiredBit);\\n                }\\n            }\\n            max = Math.max(max, currSum); // get max number\\n        }\\n        return max;\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    struct node{\\n        // val at the leaf is value of path from root to leaf\\n        int val;\\n        // two links, 0 and 1, for each bit\\n        struct node* link[2];\\n        node(){\\n            val=0;\\n            link[0]=link[1]=NULL;\\n        }\\n    };\\n    struct node* start=new node();\\n    \\n    void insertTrie(int x){\\n    \\t// straightforward insertion from msb to lsb\\n        struct node* ptr=start;\\n        for(int i=31;i>=0;i--){\\n            bool curbit=(x&(1<<i));\\n            if(ptr->link[curbit]==NULL)\\n                ptr->link[curbit]=new node();\\n            ptr=ptr->link[curbit];\\n        }\\n        ptr->val=x;\\n    }\\n    \\n    int checkTrie(int x){\\n    \\t// checking from msb to lsb(least significat bit)\\n        struct node* ptr=start;\\n        for(int i=31;i>=0;i--){\\n            bool curbit=(x&(1<<i));\\n            // if curbit is 1,see if we can have a number with that bit 0 to maximize the xor\\n            if(ptr->link[1-curbit]!=NULL)\\n                ptr=ptr->link[1-curbit];\\n            // if not then proceed with curbit\\n            else if(ptr->link[curbit]!=NULL)\\n                ptr=ptr->link[curbit];\\n        }\\n        return ptr->val;    \\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans=0,n=nums.size();\\n        if(nums.size()<2) return 0;\\n        insertTrie(nums[0]);\\n        for(int i=1;i<n;i++){\\n        \\t// for nums[i], we are finding element in nums[0 to i-1] with which it\\'s xor will be max\\n            ans=max(ans,nums[i]^checkTrie(nums[i]));\\n            // add nums[i] to the trie\\n            insertTrie(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()                        # children nodes\\n        self.val = 0                                  # end value \\n\\nclass Trie:\\n    def __init__(self, n):\\n        self.root = TrieNode()                        # root node\\n        self.n = n                                    # max length of all numbers\\n        \\n    def add_num(self, num):\\n        node = self.root \\n        for shift in range(self.n, -1, -1):           # only shift self.n bits \\n            val = 1 if num & (1 << shift) else 0      # verify bit from left to right \\n            if val not in node.children:\\n                node.children[val] = TrieNode()\\n            node = node.children[val]\\n        node.val = num\\n        \\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        max_len = len(bin(max(nums))) - 2             # get max length of all numbers\\' binary\\n        trie = Trie(max_len)\\n        for num in nums: trie.add_num(num)            # build trie\\n            \\n        ans = 0\\n        for num in nums:                              # for each num, find the number which can create max value with num using XOR\\n            node = trie.root \\n            for shift in range(max_len, -1, -1):\\n                val = 1 if num & (1 << shift) else 0  # verify bit from left to right\\n                node = node.children[1-val] if 1-val in node.children else node.children[val] # try opposite bit first, otherwise use same bit\\n            ans = max(ans, num ^ node.val)            # maintain maximum\\n        return ans    \\n```\n```\\n```\n```\\n```\n```\\nvar findMaximumXOR = function(nums) {\\n    let max = 0;\\n    for (let i = 31; i >= 0; --i) {   // we start from 31 as we have 32 bit integers\\n        const mask = (~0 >>> i) << i; // this is just i 1s followed by zeros: 1100..00 for i = 2\\n        const set = new Set();  // using set for constant access time, as o/w need to loop through the array and would have had O(N\\u02C62) time\\n        for (let num of nums) {\\n            set.add(num & mask); // adding the prefixes of all nums to the lookup set to check if we have a candidate\\n        }\\n        const maxCandidate = max | 1 << i; // we wand to check if in our set there are two numbers that xored will give us the best possible previous result with a 1 at the end. If yes, we will update the best possible result with 1, if not with 0.\\n        for (let num of set) {\\n            const another = maxCandidate ^ num; // this is the number we need to have num ^another === maxCandidate\\n            if (set.has(another)) { // if we have such, update maxCandidate => add 1 at the end. If not - in the next iteration i will increment, and as we did not add the 1, we will have 0 at this position.\\n                max = maxCandidate;\\n                break;\\n            }\\n        }\\n    }\\n    return max; // as we went from left to right all bits, the maxCandidate is as well the maximum.\\n};\\n```\n```\\n```\n```\\n```\n```\\nfunction findMaximumXOR($nums) {\\n\\t\\t$len = count($nums)-1;\\n\\t\\trsort($nums);\\n\\t\\t$maxLen = strlen(decbin($nums[0]));\\n\\t\\t$max=0;\\n\\t\\tfor ($i=0; $i<=$len; $i++) {\\n\\t\\t\\tif (strlen(decbin($nums[$i]))<$maxLen) break;\\n\\t\\t\\tfor ($j=$i+1; $j<=$len; $j++) {\\n\\t\\t\\t\\t$temp = $nums[$i] ^ $nums[$j];\\n\\t\\t\\t\\tif ($temp>$max) {\\n\\t\\t\\t\\t\\t$max=$temp;\\n\\t\\t\\t\\t\\t$maxLen=strlen((decbin($max)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn $max;\\n\\t}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    class Node {\\n        var zero: Node? = nil\\n        var one: Node? = nil\\n        \\n        var isLeaf: Bool {\\n            return zero == nil && one == nil\\n        }\\n    }\\n    \\n    //invariant: all branches have the same depth\\n    struct Trie {\\n        let root: Node = Node()\\n        let maxDigits: Int\\n        \\n        init(_ maxNum: Int) {\\n            maxDigits = maxNum.bitWidth - maxNum.leadingZeroBitCount\\n        }\\n        \\n        func insert(_ num: Int) {\\n            var currentNode = root\\n            \\n            for i in stride(from: maxDigits, to: 0, by: -1) {\\n                if num & (1 << (i-1)) == 0 {\\n                    if currentNode.zero == nil {\\n                        currentNode.zero = Node()\\n                    }\\n                    currentNode = currentNode.zero!\\n                } else {\\n                    if currentNode.one == nil {\\n                        currentNode.one = Node()\\n                    }\\n                    currentNode = currentNode.one!\\n                }\\n            }\\n        }\\n        \\n        //returns at least 0\\n        func getMax() -> Int {\\n            return getMaxRec(root,root,0)\\n        }\\n        \\n        func getMaxRec(_ n1: Node?, _ n2: Node?, _ startingValue: Int) -> Int {\\n            guard let n1 = n1 else {return 0}\\n            guard let n2 = n2 else {return 0}\\n            \\n            //base case:\\n            //using the invariant, we are at the bottom of the tree, so return the startingValue\\n            guard !(n1.isLeaf && n2.isLeaf) else {return startingValue}\\n            \\n            let newVal = startingValue << 1\\n            var val1 = getMaxRec(n1.one, n2.zero, newVal + 1)\\n            var val2 = getMaxRec(n1.zero, n2.one, newVal + 1)\\n            let best = max(val1,val2)\\n            \\n            if best > 0 {\\n                return best\\n            } else {\\n                val1 = getMaxRec(n1.one, n2.one, newVal + 0)\\n                val2 = getMaxRec(n1.zero, n2.zero, newVal + 0)\\n                return max(val1,val2)\\n            }\\n        }\\n    }\\n    \\n    func findMaximumXOR(_ nums: [Int]) -> Int {\\n        //if you remove the next two lines and update the maxDigits of the trie as you go, you can get the runtime down to 760ms (from 1162ms), but it adds a lot of complexity, so I\\'m not including it in this post.\\n        guard nums.count > 1 else {return 0}\\n        let maxNum = nums.max()!\\n\\n        let trie = Trie(maxNum)\\n        \\n        for num in nums {\\n            trie.insert(num)\\n        }\\n        \\n        return trie.getMax()\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792240,
                "title": "c-one-pass-version-using-trie",
                "content": "For each number in the array, calculate the max XOR value of current number with all previous numbers while inserting current number into the trie. Can be done in one pass.\\n```\\nstruct Node\\n{\\n    Node* left;\\n    Node* right;\\n    Node() : left(nullptr), right(nullptr) {}\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int> &nums) {\\n        int maxXOR = 0;\\n        Node* root = new Node();\\n        for(auto num: nums){\\n            Node* cur = root; // for building the trie\\n\\t\\t\\tNode* q = root; // for calculating current XOR\\n            int curXOR = 0;\\n            for(int h=31; h>=0; h--){ // inserting trie node from MSB for each num\\n                if((num & (1<<h))==0){\\n                    cur = cur->left ? cur->left : cur->left = new Node(); // inserting new node if not exists\\n                    curXOR |= q->right ? 1<<h : 0; // updating current XOR value\\n                    q = q->right ? q->right : q->left; \\n                }\\n                else{\\n                    cur = cur->right ? cur->right : cur->right = new Node();\\n                    curXOR |= q->left ? 1<<h : 0;\\n                    q = q->left ? q->left : q->right;\\n                }\\n            }\\n            maxXOR = max(maxXOR,curXOR);\\n        }\\n        return maxXOR;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node\\n{\\n    Node* left;\\n    Node* right;\\n    Node() : left(nullptr), right(nullptr) {}\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int> &nums) {\\n        int maxXOR = 0;\\n        Node* root = new Node();\\n        for(auto num: nums){\\n            Node* cur = root; // for building the trie\\n\\t\\t\\tNode* q = root; // for calculating current XOR\\n            int curXOR = 0;\\n            for(int h=31; h>=0; h--){ // inserting trie node from MSB for each num\\n                if((num & (1<<h))==0){\\n                    cur = cur->left ? cur->left : cur->left = new Node(); // inserting new node if not exists\\n                    curXOR |= q->right ? 1<<h : 0; // updating current XOR value\\n                    q = q->right ? q->right : q->left; \\n                }\\n                else{\\n                    cur = cur->right ? cur->right : cur->right = new Node();\\n                    curXOR |= q->left ? 1<<h : 0;\\n                    q = q->left ? q->left : q->right;\\n                }\\n            }\\n            maxXOR = max(maxXOR,curXOR);\\n        }\\n        return maxXOR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729306,
                "title": "c-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/0bbcd9fd-bf10-46a6-98b3-beee11cc930f_1643478394.6876035.png)\\n\\n\\n```\\n//structure of the trie node\\n\\nstruct Node{\\n    Node* links[2];\\n};\\n\\n\\nclass Trie{\\n    private:\\n  Node* root;\\n    public:\\n    Trie(){\\n        root=new Node();\\n        \\n    }\\n    public:\\n\\t\\n\\t//trie insertion\\n\\t\\n\\t\\n    void insert(int num)\\n    {\\n        Node* node= root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int index= (num>>i) &1;\\n        if(node->links[index]==NULL)\\n        {\\n            node->links[index]=new Node();\\n            \\n        }\\n            node=node->links[index];\\n        }\\n    }\\n    \\n    public:\\n\\t// to find the max xor value, and then check if that value is present in trie, if so return it.\\n    int getMax(int num)\\n    {\\n        Node* node=root;\\n        int maxnum=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bin =(num>>i)&1;\\n            int index=!bin;\\n            if(node->links[index]!=NULL)\\n            {\\n                maxnum= maxnum|(1<<i);\\n                node=node->links[index];\\n            }\\n            else{\\n                node=node->links[bin];\\n            }\\n            \\n        }\\n        return maxnum;\\n    }\\n    \\n    \\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n      \\n        int  maxi=0;\\n        Trie trie;\\n        for(auto it:nums)\\n        trie.insert(it);\\n        for(auto it:nums)\\n        {\\n            maxi=max(maxi,trie.getMax(it));\\n        }\\n        return maxi;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n      \\n        int  maxi=0;\\n        Trie trie;\\n        for(auto it:nums)\\n        trie.insert(it);\\n        for(auto it:nums)\\n        {\\n            maxi=max(maxi,trie.getMax(it));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1724881,
                "title": "js-100-time-o-n-left-to-right-actually-o-32n",
                "content": "First things first, XOR is a \"strict OR\" - given A and B, it will be true, if only A is true, or only B is true. Both cannot be true at the same time, as well as none being false is false.\\n**A.       B.     result**\\ntrue    true   false\\ntrue    false  true\\nfalse   true   true\\nfalse   false  false\\n\\nWe want to buid the answer bit wise from left to right.\\n\\nFirst interprete all numbers as bit sequences:\\n00101\\n11001\\n10110\\n\\nThen looking at this matrix, go left to right and find the first column where there are both 1s and 0s.\\n In binaries same as in decimals the larger lefter digit means larger number. Thus, we can assume that the answer must have a 1 in the most left column with both 1s and 0s.\\nThen, we continue with the next column, and see that there are also 0s and 1s, but we want to have such a combination, that will give us as well 1 on the previous step. No such combination is present, so we assume, that the next number has to be 0.\\nAt step 3, we again see 0s and 1s, and try fo find their combination, that has 10 before that. There is such, so the best so far is 101.\\nWe continue to step 4, see that can build 1011.\\nAnd at step 5, se can build 10111.\\nthis is the result.\\n\\nIt is kind of dynamic programming, where at each step k + 1, we know the best anwser for the previous step k, and try to build the best answer for step k+1.\\n\\nHere is the code:\\n\\n```\\nvar findMaximumXOR = function(nums) {\\n    let max = 0;\\n    for (let i = 31; i >= 0; --i) {   // we start from 31 as we have 32 bit integers\\n        const mask = (~0 >>> i) << i; // this is just i 1s followed by zeros: 1100..00 for i = 2\\n        const set = new Set();  // using set for constant access time, as o/w need to loop through the array and would have had O(N\\u02C62) time\\n        for (let num of nums) {\\n            set.add(num & mask); // adding the prefixes of all nums to the lookup set to check if we have a candidate\\n        }\\n        const maxCandidate = max | 1 << i; // we wand to check if in our set there are two numbers that xored will give us the best possible previous result with a 1 at the end. If yes, we will update the best possible result with 1, if not with 0.\\n        for (let num of set) {\\n            const another = maxCandidate ^ num; // this is the number we need to have num ^another === maxCandidate\\n            if (set.has(another)) { // if we have such, update maxCandidate => add 1 at the end. If not - in the next iteration i will increment, and as we did not add the 1, we will have 0 at this position.\\n                max = maxCandidate;\\n                break;\\n            }\\n        }\\n    }\\n    return max; // as we went from left to right all bits, the maxCandidate is as well the maximum.\\n};\\n```\\n\\nAs a further improvement, we can probably get rid of the Set here, by building up a lookup BST for all the bits from left to right, and save some space with that, as creating a Set on each iteration is not very nice. Such a tree can be also built in linear time with quickSelect through all the bits.\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMaximumXOR = function(nums) {\\n    let max = 0;\\n    for (let i = 31; i >= 0; --i) {   // we start from 31 as we have 32 bit integers\\n        const mask = (~0 >>> i) << i; // this is just i 1s followed by zeros: 1100..00 for i = 2\\n        const set = new Set();  // using set for constant access time, as o/w need to loop through the array and would have had O(N\\u02C62) time\\n        for (let num of nums) {\\n            set.add(num & mask); // adding the prefixes of all nums to the lookup set to check if we have a candidate\\n        }\\n        const maxCandidate = max | 1 << i; // we wand to check if in our set there are two numbers that xored will give us the best possible previous result with a 1 at the end. If yes, we will update the best possible result with 1, if not with 0.\\n        for (let num of set) {\\n            const another = maxCandidate ^ num; // this is the number we need to have num ^another === maxCandidate\\n            if (set.has(another)) { // if we have such, update maxCandidate => add 1 at the end. If not - in the next iteration i will increment, and as we did not add the 1, we will have 0 at this position.\\n                max = maxCandidate;\\n                break;\\n            }\\n        }\\n    }\\n    return max; // as we went from left to right all bits, the maxCandidate is as well the maximum.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724341,
                "title": "c-solution-o-nlogn-and-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        \\n        int maxAns = 0 ;\\n    \\n\\n        for(int i = 31 ; i >= 0 ; i--) {\\n            maxAns = maxAns << 1;\\n            set <int> s;\\n            \\n            for(int j = 0 ;  j < nums.size() ; j++) {\\n\\t\\t\\t// take i bits from msb\\n                s.insert((nums[j] >> i));\\n            }\\n            // try to append all 1s to ans only then max will be there\\n            int newAns = maxAns | 1;\\n            \\n            for(int j : s) {\\n                \\n\\t\\t\\t\\t// is xor of newAns with currelement present in set then only i can achieve the curr xor as 1 * 0 = 1 and 0 ^ 1  =1\\n                if(s.count(j ^ newAns)) {\\n                    maxAns = newAns;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        \\n        return maxAns;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        \\n        int maxAns = 0 ;\\n    \\n\\n        for(int i = 31 ; i >= 0 ; i--) {\\n            maxAns = maxAns << 1;\\n            set <int> s;\\n            \\n            for(int j = 0 ;  j < nums.size() ; j++) {\\n\\t\\t\\t// take i bits from msb\\n                s.insert((nums[j] >> i));\\n            }\\n            // try to append all 1s to ans only then max will be there\\n            int newAns = maxAns | 1;\\n            \\n            for(int j : s) {\\n                \\n\\t\\t\\t\\t// is xor of newAns with currelement present in set then only i can achieve the curr xor as 1 * 0 = 1 and 0 ^ 1  =1\\n                if(s.count(j ^ newAns)) {\\n                    maxAns = newAns;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        \\n        return maxAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724113,
                "title": "python-bit-by-bit-with-comments",
                "content": "```\\nclass Solution:\\n    \\n    \\n    def findMaximumNaive(self,  nums: List[int]) -> int:\\n        \\n        \"\"\"\\n        O(N^2)\\n        \"\"\"\\n        runningMax = 0\\n        N = len(nums)\\n        \\n        for i in range(N-1):\\n            for j in range(i+1, N): \\n                runningMax = max(runningMax, nums[i] ^ nums[j])\\n            \\n        return runningMax\\n    \\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        \"\"\"\\n        \\n        mashup of hamming distance like problems and 2sum.\\n        \\n        take advantage of the 32 bit representation of the numbers in question\\n        \\n        generate mask bits starting 100000000, 110000000.... 111111111\\n            \\n        we want 1 on the lsb (on the left side)\\n        so we iterate a full 32 bits and set up\\n        \\n        find pair -> find max possible xor till ith index\\n        \\n       note the commutative group properties (with action = xor)\\n        a^b = c; b^c = a; a^c = b\\n        where:\\n        a = prefix of arr[j] till ith\\n        b = maxPossible xor till ith-1 + set ith bit\\n        \\n        This is important since we\\'re asking is there 2 numbers with the prefix.\\n        \\n        Time: O(32N) -> O(N)\\n        \\n        \"\"\"\\n\\n        maximum = 0\\n        mask = 0\\n        \\n        for i in range(30, -1, -1):\\n            one = 1 << i\\n            mask = mask | one   \\n            \\n            # generate prefixes with bitwise mask for ith bit\\n            prefixes = set()\\n            for num in nums:\\n                # bitwise and clear except relevent bits in mask\\n                prefixes.add(mask & num)\\n                \\n            # corresponds to ith bit of maximum\\n            test = maximum | one\\n            \\n            # now traverse the prefixes, asking, is there two numbers with a opposite \\n            # prefix?\\n            for prefix in prefixes:\\n                # like two sum\\n                # confirm that we have two numbers with the opposite bits\\n                if prefix ^ test in prefixes:\\n                    maximum = test\\n                    break\\n                    \\n        return maximum\\n    \\n    \\n\\n    \\n    ```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \\n    def findMaximumNaive(self,  nums: List[int]) -> int:\\n        \\n        \"\"\"\\n        O(N^2)\\n        \"\"\"\\n        runningMax = 0\\n        N = len(nums)\\n        \\n        for i in range(N-1):\\n            for j in range(i+1, N): \\n                runningMax = max(runningMax, nums[i] ^ nums[j])\\n            \\n        return runningMax\\n    \\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        \"\"\"\\n        \\n        mashup of hamming distance like problems and 2sum.\\n        \\n        take advantage of the 32 bit representation of the numbers in question\\n        \\n        generate mask bits starting 100000000, 110000000.... 111111111\\n            \\n        we want 1 on the lsb (on the left side)\\n        so we iterate a full 32 bits and set up\\n        \\n        find pair -> find max possible xor till ith index\\n        \\n       note the commutative group properties (with action = xor)\\n        a^b = c; b^c = a; a^c = b\\n        where:\\n        a = prefix of arr[j] till ith\\n        b = maxPossible xor till ith-1 + set ith bit\\n        \\n        This is important since we\\'re asking is there 2 numbers with the prefix.\\n        \\n        Time: O(32N) -> O(N)\\n        \\n        \"\"\"\\n\\n        maximum = 0\\n        mask = 0\\n        \\n        for i in range(30, -1, -1):\\n            one = 1 << i\\n            mask = mask | one   \\n            \\n            # generate prefixes with bitwise mask for ith bit\\n            prefixes = set()\\n            for num in nums:\\n                # bitwise and clear except relevent bits in mask\\n                prefixes.add(mask & num)\\n                \\n            # corresponds to ith bit of maximum\\n            test = maximum | one\\n            \\n            # now traverse the prefixes, asking, is there two numbers with a opposite \\n            # prefix?\\n            for prefix in prefixes:\\n                # like two sum\\n                # confirm that we have two numbers with the opposite bits\\n                if prefix ^ test in prefixes:\\n                    maximum = test\\n                    break\\n                    \\n        return maximum\\n    \\n    \\n\\n    \\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 1723802,
                "title": "c-trie-implementation",
                "content": "```\\n#define debug(x) cout<<#x<<\":\"<<x<<endl;\\nstruct Node{\\nprivate:\\n    Node* links[2];\\npublic:\\n    Node(){\\n        links[0] = links[1] = NULL;\\n    }\\n    \\n    bool containsKey(int bit){\\n\\t\\treturn (links[bit] != NULL);\\n    }\\n    \\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n    \\n    void put(int bit,Node* new_node){\\n        links[bit] = new_node;\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    \\n    void insert(int num){\\n        Node* node = this->root;\\n        for(int i=31;i>=0;i--){\\n            // check bit is set or not\\n            int bit = ((1 << i)&num) ? 1 : 0;\\n            if(!node->containsKey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    \\n    int getMax(int num){\\n        Node* node = this->root;\\n        int max = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = ((1 << i)&num) ? 1 : 0;\\n            if(node->containsKey(1-bit)){\\n                max = ((1 << i) | max);\\n                node = node->get(1-bit);\\n            }else{\\n                node = node->get(bit);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie;\\n        for(auto& val:nums){\\n            trie.insert(val);\\n        }\\n        int ans = 0;\\n        for(auto& val:nums){\\n            ans = max(ans,trie.getMax(val));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define debug(x) cout<<#x<<\":\"<<x<<endl;\\nstruct Node{\\nprivate:\\n    Node* links[2];\\npublic:\\n    Node(){\\n        links[0] = links[1] = NULL;\\n    }\\n    \\n    bool containsKey(int bit){\\n\\t\\treturn (links[bit] != NULL);\\n    }\\n    \\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n    \\n    void put(int bit,Node* new_node){\\n        links[bit] = new_node;\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    \\n    void insert(int num){\\n        Node* node = this->root;\\n        for(int i=31;i>=0;i--){\\n            // check bit is set or not\\n            int bit = ((1 << i)&num) ? 1 : 0;\\n            if(!node->containsKey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    \\n    int getMax(int num){\\n        Node* node = this->root;\\n        int max = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = ((1 << i)&num) ? 1 : 0;\\n            if(node->containsKey(1-bit)){\\n                max = ((1 << i) | max);\\n                node = node->get(1-bit);\\n            }else{\\n                node = node->get(bit);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie;\\n        for(auto& val:nums){\\n            trie.insert(val);\\n        }\\n        int ans = 0;\\n        for(auto& val:nums){\\n            ans = max(ans,trie.getMax(val));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1723608,
                "title": "concise-cpp-solution-o-n-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        int mask=0,max=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            mask=mask|(1<<i);\\n            set<int>st;\\n            // inserting MCB in set \\n            for(auto j:nums)\\n            {\\n                st.insert(mask&j);\\n            }\\n            // take a temp which is mcb \\n            int tmp=max|(1<<i);\\n            for(auto k:st)\\n            {\\n                // we do tmp^k , if it exists in set \\n                // we break that and make max=temp;\\n                if(st.find(tmp^k) != st.end())\\n                {\\n                    max=tmp;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n/*\\n public int findMaximumXOR(int[] nums) \\n {\\n        int maxResult = 0; \\n        int mask = 0;\\n//         The maxResult is a record of the largest XOR we got so far. if it\\'s 11100 at i = 2, it means \\n//         before we reach the last two bits, 11100 is the biggest XOR we have, and we\\'re going to explore\\n//         whether we can get another two \\'1\\'s and put them into maxResult\\n        \\n//         This is a greedy part, since we\\'re looking for the largest XOR, we start \\n//         from the very begining, aka, the 31st postition of bits.\\n        for (int i = 31; i >= 0; i--) {\\n            \\n            //The mask will grow like  100..000 , 110..000, 111..000,  then 1111...111\\n            //for each iteration, we only care about the left parts\\n            mask = mask | (1 << i);\\n            \\n            Set<Integer> set = new HashSet<>();\\n            for (int num : nums) {\\n                \\n               // we only care about the left parts, for example, if i = 2, then we have\\n               //  {1100, 1000, 0100, 0000} from {1110, 1011, 0111, 0010}\\n                int leftPartOfNum = num & mask;\\n                set.add(leftPartOfNum);\\n            }\\n            \\n            // if i = 1 and before this iteration, the maxResult we have now is 1100, \\n            // my wish is the maxResult will grow to 1110, so I will try to find a candidate\\n            // which can give me the greedyTry;\\n            int greedyTry = maxResult | (1 << i);\\n            \\n            for (int leftPartOfNum : set) {\\n                //This is the most tricky part, coming from a fact that if a ^ b = c, then a ^ c = b;\\n                // now we have the \\'c\\', which is greedyTry, and we have the \\'a\\', which is leftPartOfNum\\n                // If we hope the formula a ^ b = c to be valid, then we need the b, \\n                // and to get b, we need a ^ c, if a ^ c exisited in our set, then we\\'re good to go\\n                int anotherNum = leftPartOfNum ^ greedyTry;\\n                if (set.contains(anotherNum)) {\\n                    maxResult= greedyTry;\\n                    break;\\n                }\\n            }\\n            \\n            // If unfortunately, we didn\\'t get the greedyTry, we still have our max, \\n            // So after this iteration, the max will stay at 1100.\\n        }\\n        \\n        return maxResult;\\n    }\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        int mask=0,max=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            mask=mask|(1<<i);\\n            set<int>st;\\n            // inserting MCB in set \\n            for(auto j:nums)\\n            {\\n                st.insert(mask&j);\\n            }\\n            // take a temp which is mcb \\n            int tmp=max|(1<<i);\\n            for(auto k:st)\\n            {\\n                // we do tmp^k , if it exists in set \\n                // we break that and make max=temp;\\n                if(st.find(tmp^k) != st.end())\\n                {\\n                    max=tmp;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n/*\\n public int findMaximumXOR(int[] nums) \\n {\\n        int maxResult = 0; \\n        int mask = 0;\\n//         The maxResult is a record of the largest XOR we got so far. if it\\'s 11100 at i = 2, it means \\n//         before we reach the last two bits, 11100 is the biggest XOR we have, and we\\'re going to explore\\n//         whether we can get another two \\'1\\'s and put them into maxResult\\n        \\n//         This is a greedy part, since we\\'re looking for the largest XOR, we start \\n//         from the very begining, aka, the 31st postition of bits.\\n        for (int i = 31; i >= 0; i--) {\\n            \\n            //The mask will grow like  100..000 , 110..000, 111..000,  then 1111...111\\n            //for each iteration, we only care about the left parts\\n            mask = mask | (1 << i);\\n            \\n            Set<Integer> set = new HashSet<>();\\n            for (int num : nums) {\\n                \\n               // we only care about the left parts, for example, if i = 2, then we have\\n               //  {1100, 1000, 0100, 0000} from {1110, 1011, 0111, 0010}\\n                int leftPartOfNum = num & mask;\\n                set.add(leftPartOfNum);\\n            }\\n            \\n            // if i = 1 and before this iteration, the maxResult we have now is 1100, \\n            // my wish is the maxResult will grow to 1110, so I will try to find a candidate\\n            // which can give me the greedyTry;\\n            int greedyTry = maxResult | (1 << i);\\n            \\n            for (int leftPartOfNum : set) {\\n                //This is the most tricky part, coming from a fact that if a ^ b = c, then a ^ c = b;\\n                // now we have the \\'c\\', which is greedyTry, and we have the \\'a\\', which is leftPartOfNum\\n                // If we hope the formula a ^ b = c to be valid, then we need the b, \\n                // and to get b, we need a ^ c, if a ^ c exisited in our set, then we\\'re good to go\\n                int anotherNum = leftPartOfNum ^ greedyTry;\\n                if (set.contains(anotherNum)) {\\n                    maxResult= greedyTry;\\n                    break;\\n                }\\n            }\\n            \\n            // If unfortunately, we didn\\'t get the greedyTry, we still have our max, \\n            // So after this iteration, the max will stay at 1100.\\n        }\\n        \\n        return maxResult;\\n    }\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502938,
                "title": "c-trie",
                "content": "```\\nclass Node{\\n    public:\\n    Node * left;\\n    Node * right;\\n    Node()\\n    {\\n        left=NULL;\\n        right=NULL;\\n    }\\n};\\nclass Trie{\\n    public:\\n    Node *root;\\n    Trie(){\\n        root = new Node;\\n    }\\n    void insert(int n){\\n        Node * temp = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (n>>i)&1;\\n            if(bit==0){\\n                if(temp->left==NULL){\\n                    temp->left = new Node();\\n                }\\n                temp = temp->left;\\n            }\\n            else\\n            {\\n                if(temp->right==NULL){\\n                    temp->right = new Node();\\n                }\\n                temp = temp->right;\\n            }\\n        }\\n    }\\n    int max_xor_helper(int value){\\n        Node * temp = root;\\n        int current_ans = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (value>>i)&1;\\n            if(bit==0){\\n                if(temp->right==NULL){\\n                    temp = temp->left;\\n                }\\n                else{\\n                    current_ans+= (1<<i);\\n                    temp = temp->right;\\n                }\\n            }\\n            else{\\n                if(temp->left==NULL){\\n                    temp = temp->right;\\n                }\\n                else{\\n                    temp = temp->left;\\n                    current_ans+= (1<<i);\\n                }\\n            }\\n        }\\n        return current_ans;\\n    }\\n    int max_xor(vector<int> nums)\\n    {\\n        int result = 0;\\n        int length = nums.size();\\n        for(int i=0;i<length;i++)\\n        {\\n            int value = nums[i];\\n            insert(value);\\n            int curr = max_xor_helper(value);\\n            result = max(result,curr);\\n        }\\n        return result;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie t;\\n        return t.max_xor(nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node{\\n    public:\\n    Node * left;\\n    Node * right;\\n    Node()\\n    {\\n        left=NULL;\\n        right=NULL;\\n    }\\n};\\nclass Trie{\\n    public:\\n    Node *root;\\n    Trie(){\\n        root = new Node;\\n    }\\n    void insert(int n){\\n        Node * temp = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (n>>i)&1;\\n            if(bit==0){\\n                if(temp->left==NULL){\\n                    temp->left = new Node();\\n                }\\n                temp = temp->left;\\n            }\\n            else\\n            {\\n                if(temp->right==NULL){\\n                    temp->right = new Node();\\n                }\\n                temp = temp->right;\\n            }\\n        }\\n    }\\n    int max_xor_helper(int value){\\n        Node * temp = root;\\n        int current_ans = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (value>>i)&1;\\n            if(bit==0){\\n                if(temp->right==NULL){\\n                    temp = temp->left;\\n                }\\n                else{\\n                    current_ans+= (1<<i);\\n                    temp = temp->right;\\n                }\\n            }\\n            else{\\n                if(temp->left==NULL){\\n                    temp = temp->right;\\n                }\\n                else{\\n                    temp = temp->left;\\n                    current_ans+= (1<<i);\\n                }\\n            }\\n        }\\n        return current_ans;\\n    }\\n    int max_xor(vector<int> nums)\\n    {\\n        int result = 0;\\n        int length = nums.size();\\n        for(int i=0;i<length;i++)\\n        {\\n            int value = nums[i];\\n            insert(value);\\n            int curr = max_xor_helper(value);\\n            result = max(result,curr);\\n        }\\n        return result;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie t;\\n        return t.max_xor(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498521,
                "title": "c-trie",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct Node{\\n        Node* arr[2];\\n        int val;\\n    };\\n    \\n    Node* root=new Node();\\n    \\n    void insert(int n){\\n        Node* temp=root;\\n        for(int i=31;i>=0;i--){\\n            bool bitVal=n & (1<<i);\\n            if(temp->arr[bitVal]==NULL){\\n               Node* newNode = new Node();\\n               temp->arr[bitVal]=newNode; \\n            }\\n            temp=temp->arr[bitVal];\\n        }\\n        temp->val=n;\\n    }\\n    \\n    int findMaxXor(int n){\\n        Node* temp=root;\\n        for(int i=31;i>=0;i--){\\n            bool bitVal=n & (1<<i);\\n            if(temp->arr[!bitVal]!=NULL)\\n                temp=temp->arr[!bitVal]; \\n            else if(temp->arr[bitVal]!=NULL)\\n                temp=temp->arr[bitVal];\\n            else\\n                return INT_MIN;\\n        }\\n        return n^temp->val;\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        Node* temp=root;\\n        int maxXor=INT_MIN;\\n        int n=nums.size();\\n        if(n<2)\\n            return 0;\\n        insert(nums[0]);\\n        for(int i=1;i<n;i++){\\n            maxXor=max(maxXor, findMaxXor(nums[i]));\\n            insert(nums[i]);\\n        }\\n        return maxXor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct Node{\\n        Node* arr[2];\\n        int val;\\n    };\\n    \\n    Node* root=new Node();\\n    \\n    void insert(int n){\\n        Node* temp=root;\\n        for(int i=31;i>=0;i--){\\n            bool bitVal=n & (1<<i);\\n            if(temp->arr[bitVal]==NULL){\\n               Node* newNode = new Node();\\n               temp->arr[bitVal]=newNode; \\n            }\\n            temp=temp->arr[bitVal];\\n        }\\n        temp->val=n;\\n    }\\n    \\n    int findMaxXor(int n){\\n        Node* temp=root;\\n        for(int i=31;i>=0;i--){\\n            bool bitVal=n & (1<<i);\\n            if(temp->arr[!bitVal]!=NULL)\\n                temp=temp->arr[!bitVal]; \\n            else if(temp->arr[bitVal]!=NULL)\\n                temp=temp->arr[bitVal];\\n            else\\n                return INT_MIN;\\n        }\\n        return n^temp->val;\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        Node* temp=root;\\n        int maxXor=INT_MIN;\\n        int n=nums.size();\\n        if(n<2)\\n            return 0;\\n        insert(nums[0]);\\n        for(int i=1;i<n;i++){\\n            maxXor=max(maxXor, findMaxXor(nums[i]));\\n            insert(nums[i]);\\n        }\\n        return maxXor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262578,
                "title": "c-can-t-believe-i-did-this-question-with-a-trie",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string toBinary(int n)\\n    {\\n        string r;\\n        while ( n != 0 ) {\\n            r = ( n % 2 == 0 ? \"0\" : \"1\" ) + r;\\n            n /= 2;\\n        }\\n        return string(31-r.length(),\\'0\\') + r;\\n    }\\n    \\n    int toInt( string s ) \\n    {\\n        int result = 0;\\n        int exp = 0;\\n        for ( int i=s.length()-1; i>=0; i-- ) {\\n            result += (s[i]-\\'0\\') * pow(2, exp++);\\n        }\\n        return result;\\n    }\\n    \\n    class Node \\n    {\\n    public:\\n        char val;\\n        Node* child[2];\\n        bool isEnd;\\n        \\n        Node( char value ) {\\n            val = value;\\n            child[0] = NULL;\\n            child[1] = NULL;\\n        }\\n    };\\n    \\n    Node* root = new Node(\\' \\');\\n    \\n    void insertInTrie( string word )\\n    {   \\n        Node* cur = root;\\n        for ( char ch : word ) {\\n            if ( cur == NULL || cur->child[ch-\\'0\\'] == NULL ) {\\n                cur->child[ch-\\'0\\'] = new Node(ch);\\n            }\\n            cur = cur->child[ch-\\'0\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    int xorval ( string number ) \\n    {\\n        Node* cur = root;\\n        string result = \"\";\\n        for ( char ch : number ) {\\n            if ( ch == \\'0\\' && cur->child[1] ) {\\n                result += \\'1\\';\\n                cur = cur->child[1];\\n            }\\n            else if ( ch == \\'1\\' && cur->child[0] ) {\\n                result += \\'1\\';\\n                cur = cur->child[0];\\n            }\\n            else {\\n                result += \\'0\\';\\n                cur = cur->child[ch-\\'0\\'];\\n            }\\n        }\\n        return toInt(result);\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        for ( int n : nums ) {\\n            insertInTrie(toBinary(n));\\n        }\\n        int maxXor = INT_MIN;\\n        for ( int n : nums ) {\\n            int curXor = xorval(toBinary(n));\\n            maxXor = max(curXor, maxXor);\\n        }\\n        return maxXor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string toBinary(int n)\\n    {\\n        string r;\\n        while ( n != 0 ) {\\n            r = ( n % 2 == 0 ? \"0\" : \"1\" ) + r;\\n            n /= 2;\\n        }\\n        return string(31-r.length(),\\'0\\') + r;\\n    }\\n    \\n    int toInt( string s ) \\n    {\\n        int result = 0;\\n        int exp = 0;\\n        for ( int i=s.length()-1; i>=0; i-- ) {\\n            result += (s[i]-\\'0\\') * pow(2, exp++);\\n        }\\n        return result;\\n    }\\n    \\n    class Node \\n    {\\n    public:\\n        char val;\\n        Node* child[2];\\n        bool isEnd;\\n        \\n        Node( char value ) {\\n            val = value;\\n            child[0] = NULL;\\n            child[1] = NULL;\\n        }\\n    };\\n    \\n    Node* root = new Node(\\' \\');\\n    \\n    void insertInTrie( string word )\\n    {   \\n        Node* cur = root;\\n        for ( char ch : word ) {\\n            if ( cur == NULL || cur->child[ch-\\'0\\'] == NULL ) {\\n                cur->child[ch-\\'0\\'] = new Node(ch);\\n            }\\n            cur = cur->child[ch-\\'0\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    int xorval ( string number ) \\n    {\\n        Node* cur = root;\\n        string result = \"\";\\n        for ( char ch : number ) {\\n            if ( ch == \\'0\\' && cur->child[1] ) {\\n                result += \\'1\\';\\n                cur = cur->child[1];\\n            }\\n            else if ( ch == \\'1\\' && cur->child[0] ) {\\n                result += \\'1\\';\\n                cur = cur->child[0];\\n            }\\n            else {\\n                result += \\'0\\';\\n                cur = cur->child[ch-\\'0\\'];\\n            }\\n        }\\n        return toInt(result);\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        for ( int n : nums ) {\\n            insertInTrie(toBinary(n));\\n        }\\n        int maxXor = INT_MIN;\\n        for ( int n : nums ) {\\n            int curXor = xorval(toBinary(n));\\n            maxXor = max(curXor, maxXor);\\n        }\\n        return maxXor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209605,
                "title": "trie-based-simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct node\\n    {\\n    node* arr[2];\\n    };\\n    \\n\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        \\n        vector<int>v;\\n        v=nums;\\n        \\n        \\n        \\n        node* root=new node();\\n        int ans=0;\\n        \\n        //-------------------Trie Construction-----------------------------------------\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int a[32]={0};\\n            int c=31;\\n            while(nums[i]>0)\\n            {\\n                a[c]=nums[i]%2;\\n                nums[i]/=2;\\n                c--;\\n            }\\n            \\n            node* root1=root;\\n            for(int i=0;i<=31;i++)\\n            {\\n                if(root1->arr[a[i]]==NULL)\\n                {\\n                    root1->arr[a[i]]=new node();\\n                }\\n                root1=root1->arr[a[i]];\\n            }         \\n        }\\n        \\n      //--------------------------------------------------------------------------------  \\n        \\n       \\n        for(int i=0;i<v.size();i++)\\n        {\\n\\n            int an=0;\\n           int a[32]={0};\\n            int c=31;\\n            while(v[i]>0)\\n            {\\n                a[c]=v[i]%2;\\n                v[i]/=2;\\n                c--;\\n            }\\n            \\n               node* root1=root;\\n        c=0;\\n        while(c<=31)\\n        {\\n            if(root1->arr[abs(1-a[c])]!=NULL)\\n            {\\n                root1=root1->arr[abs(1-a[c])];\\n                an+=pow(2,31-c);\\n            }\\n            \\n            else\\n            {\\n                  root1=root1->arr[a[c]];\\n            }\\n\\n             c++;\\n        }\\n        \\n        \\n        ans=max(ans,an);\\n        }\\n        \\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct node\\n    {\\n    node* arr[2];\\n    };\\n    \\n\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        \\n        vector<int>v;\\n        v=nums;\\n        \\n        \\n        \\n        node* root=new node();\\n        int ans=0;\\n        \\n        //-------------------Trie Construction-----------------------------------------\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int a[32]={0};\\n            int c=31;\\n            while(nums[i]>0)\\n            {\\n                a[c]=nums[i]%2;\\n                nums[i]/=2;\\n                c--;\\n            }\\n            \\n            node* root1=root;\\n            for(int i=0;i<=31;i++)\\n            {\\n                if(root1->arr[a[i]]==NULL)\\n                {\\n                    root1->arr[a[i]]=new node();\\n                }\\n                root1=root1->arr[a[i]];\\n            }         \\n        }\\n        \\n      //--------------------------------------------------------------------------------  \\n        \\n       \\n        for(int i=0;i<v.size();i++)\\n        {\\n\\n            int an=0;\\n           int a[32]={0};\\n            int c=31;\\n            while(v[i]>0)\\n            {\\n                a[c]=v[i]%2;\\n                v[i]/=2;\\n                c--;\\n            }\\n            \\n               node* root1=root;\\n        c=0;\\n        while(c<=31)\\n        {\\n            if(root1->arr[abs(1-a[c])]!=NULL)\\n            {\\n                root1=root1->arr[abs(1-a[c])];\\n                an+=pow(2,31-c);\\n            }\\n            \\n            else\\n            {\\n                  root1=root1->arr[a[c]];\\n            }\\n\\n             c++;\\n        }\\n        \\n        \\n        ans=max(ans,an);\\n        }\\n        \\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151136,
                "title": "c-simple-trie-solution-faster-than-93",
                "content": "approach - for current array number , we\\'ll try to find it\\'s max xor pair number by maximizing 1 in msb of xor pair result . \\nfirst we insert number in the trie in its binary form , then we find max xor for current number, then compare curr ans with max obtained till now and then update accordingly.\\nwhile searching for current max xor ,  we see the current msb and try to find complementary bit , if we find complementary bit then we add pow(2,position of current bit) otherwise we dont.\\n```\\nclass Node{\\n public:\\n    Node* left; //for 0\\n    Node* right; //for 1\\n};\\n\\nclass Trie{\\npublic:\\n    \\n    Node* root ;\\n    \\n    Trie(){\\n        root = new Node() ;\\n    }\\n    \\n    void insert(int num){\\n        Node* temp = root ;\\n        \\n        //32 bit number\\n        for(int i=31 ; i>=0 ; i--){\\n            int bit = (num>>i)&1 ;\\n            \\n            if(bit==0){\\n                if(!temp->left){\\n                    temp->left = new Node() ;\\n                }\\n                \\n                temp=temp->left ;\\n            }else{\\n                //bit is 1\\n                if(!temp->right){\\n                    temp->right = new Node() ;\\n                }\\n                temp=temp->right ;\\n            }\\n        }\\n        \\n    }\\n    \\n    int max_xor_helper(int num){\\n        Node* temp = root ;\\n        \\n        int curr_ans = 0 ;\\n        \\n        for(int i=31 ; i>=0 ; i--){\\n            int bit = (num>>i)&1 ;\\n            \\n            if(bit==0){\\n                //find complementary bit 1 ;\\n                if(temp->right){\\n                    curr_ans += (1<<i) ;\\n                    temp=temp->right ;\\n                }else{\\n                    temp=temp->left ;\\n                }\\n            }else{\\n                //bit is 1 , find 0 \\n                if(temp->left){\\n                    curr_ans += (1<<i) ;\\n                    temp=temp->left ;\\n                }else{\\n                    temp=temp->right ;\\n                }\\n            }\\n        }\\n        \\n        return curr_ans ;\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie* t = new Trie() ;\\n        \\n        int ans = 0 ;\\n        \\n        for(int i=0 ; i<nums.size() ;i++){\\n            t->insert(nums[i]) ;\\n            int curr_xor = t->max_xor_helper(nums[i]) ;\\n            ans = max(curr_xor , ans) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node{\\n public:\\n    Node* left; //for 0\\n    Node* right; //for 1\\n};\\n\\nclass Trie{\\npublic:\\n    \\n    Node* root ;\\n    \\n    Trie(){\\n        root = new Node() ;\\n    }\\n    \\n    void insert(int num){\\n        Node* temp = root ;\\n        \\n        //32 bit number\\n        for(int i=31 ; i>=0 ; i--){\\n            int bit = (num>>i)&1 ;\\n            \\n            if(bit==0){\\n                if(!temp->left){\\n                    temp->left = new Node() ;\\n                }\\n                \\n                temp=temp->left ;\\n            }else{\\n                //bit is 1\\n                if(!temp->right){\\n                    temp->right = new Node() ;\\n                }\\n                temp=temp->right ;\\n            }\\n        }\\n        \\n    }\\n    \\n    int max_xor_helper(int num){\\n        Node* temp = root ;\\n        \\n        int curr_ans = 0 ;\\n        \\n        for(int i=31 ; i>=0 ; i--){\\n            int bit = (num>>i)&1 ;\\n            \\n            if(bit==0){\\n                //find complementary bit 1 ;\\n                if(temp->right){\\n                    curr_ans += (1<<i) ;\\n                    temp=temp->right ;\\n                }else{\\n                    temp=temp->left ;\\n                }\\n            }else{\\n                //bit is 1 , find 0 \\n                if(temp->left){\\n                    curr_ans += (1<<i) ;\\n                    temp=temp->left ;\\n                }else{\\n                    temp=temp->right ;\\n                }\\n            }\\n        }\\n        \\n        return curr_ans ;\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie* t = new Trie() ;\\n        \\n        int ans = 0 ;\\n        \\n        for(int i=0 ; i<nums.size() ;i++){\\n            t->insert(nums[i]) ;\\n            int curr_xor = t->max_xor_helper(nums[i]) ;\\n            ans = max(curr_xor , ans) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143009,
                "title": "javascript-solution-trie-clean",
                "content": "I didn\\'t not have much time to spend on this. If I was on an interview it would be really hard to solve this without knowing the solution in advance.\\n\\nRuntime: 532 ms, faster than 28.77% of JavaScript online submissions for Maximum XOR of Two Numbers in an Array.\\nMemory Usage: 70.4 MB, less than 19.18% of JavaScript online submissions for Maximum XOR of Two Numbers in an Array.\\n\\n\\n```\\nconst invert = ch => {\\n  return ch === \\'0\\' ? \\'1\\' : \\'0\\'\\n}\\n\\nclass Trie {\\n  constructor() {\\n    this.nodes = new Map()\\n  }\\n  \\n  add(num) {\\n    let nodes = this.nodes\\n    for (const ch of num) {\\n      const next = nodes.get(ch) ?? new Map()\\n      nodes.set(ch, next)\\n      nodes = next\\n    }\\n  }\\n  \\n  maxXor(num) {\\n    let ret = []\\n    let nodes = this.nodes\\n    for (const ch of num) {\\n      const key = nodes.has(invert(ch)) ? invert(ch) : ch\\n      ret.push(key)\\n      nodes = nodes.get(key)\\n    }\\n    ret = ret.join(\\'\\')\\n    ret = parseInt(ret, 2)\\n    num = parseInt(num, 2)\\n    return ret ^ num\\n  }\\n  \\n}\\n\\nconst findMaximumXOR = nums => {\\n  let ret = 0\\n  const len = Math.max(...nums).toString(2).length\\n  let trie = new Trie()\\n  for (let i = 0; i < nums.length; i++) {\\n    nums[i] = nums[i].toString(2).padStart(len, 0)\\n    trie.add(nums[i])\\n  }\\n  for (const num of nums) {\\n    ret = Math.max(trie.maxXor(num), ret)\\n  }  \\n  return ret\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\nconst invert = ch => {\\n  return ch === \\'0\\' ? \\'1\\' : \\'0\\'\\n}\\n\\nclass Trie {\\n  constructor() {\\n    this.nodes = new Map()\\n  }\\n  \\n  add(num) {\\n    let nodes = this.nodes\\n    for (const ch of num) {\\n      const next = nodes.get(ch) ?? new Map()\\n      nodes.set(ch, next)\\n      nodes = next\\n    }\\n  }\\n  \\n  maxXor(num) {\\n    let ret = []\\n    let nodes = this.nodes\\n    for (const ch of num) {\\n      const key = nodes.has(invert(ch)) ? invert(ch) : ch\\n      ret.push(key)\\n      nodes = nodes.get(key)\\n    }\\n    ret = ret.join(\\'\\')\\n    ret = parseInt(ret, 2)\\n    num = parseInt(num, 2)\\n    return ret ^ num\\n  }\\n  \\n}\\n\\nconst findMaximumXOR = nums => {\\n  let ret = 0\\n  const len = Math.max(...nums).toString(2).length\\n  let trie = new Trie()\\n  for (let i = 0; i < nums.length; i++) {\\n    nums[i] = nums[i].toString(2).padStart(len, 0)\\n    trie.add(nums[i])\\n  }\\n  for (const num of nums) {\\n    ret = Math.max(trie.maxXor(num), ret)\\n  }  \\n  return ret\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077929,
                "title": "java-trie-bit-maniupulation-time-complexity-o-n",
                "content": "```\\nclass Node{\\n    Node left;\\n    Node right;\\n    int val;\\n    Node(){\\n        this.left = null;\\n        this.right = null;\\n        // this.val = 0;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    \\n    // add a number to the Node\\n    void insert(int n, Node head)\\n    {\\n        Node current = head;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            // get the LSB\\n            int bit = (n >> i) & 1;\\n            if ( bit == 0 )\\n            {\\n                if ( current.left == null )\\n                    current.left = new Node();\\n                \\n                current = current.left;\\n            }else{\\n                if ( current.right == null )\\n                    current.right = new Node();\\n                \\n                current = current.right;\\n            }\\n        }\\n    }\\n    \\n    \\n    int findPair(int n, Node head)\\n    {\\n        Node current = head;\\n        int xor = 0;\\n        \\n        for(int i = 31; i >= 0; i--)\\n        {\\n            // get the LSB\\n            int bit = (n >> i) & 1;\\n            if ( bit == 1 )\\n            {\\n                if ( current.left != null ){\\n                    current = current.left;\\n                    xor += Math.pow(2, i);\\n                }\\n                else\\n                    current = current.right;\\n            }else{\\n                \\n                if ( current.right != null ){\\n                    xor += Math.pow(2, i);\\n                    current = current.right;\\n                }\\n                else\\n                    current = current.left;\\n            }\\n        }\\n        \\n    \\n        return xor;\\n    }\\n    \\n    \\n    public int findMaximumXOR(int[] nums) {\\n        \\n        // a number that is complement to that number is the \\n        // maximum xor for that number\\n        \\n        Node head = new Node();\\n        \\n        for(int n : nums)\\n            insert(n, head);\\n        \\n        // find the maximum xor pair\\n        \\n        int max = 0;\\n        \\n        for(int i =0; i< nums.length; i++)\\n        {\\n            int temp = findPair(nums[i], head);\\n            max = Math.max(max, temp);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node{\\n    Node left;\\n    Node right;\\n    int val;\\n    Node(){\\n        this.left = null;\\n        this.right = null;\\n        // this.val = 0;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    \\n    // add a number to the Node\\n    void insert(int n, Node head)\\n    {\\n        Node current = head;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            // get the LSB\\n            int bit = (n >> i) & 1;\\n            if ( bit == 0 )\\n            {\\n                if ( current.left == null )\\n                    current.left = new Node();\\n                \\n                current = current.left;\\n            }else{\\n                if ( current.right == null )\\n                    current.right = new Node();\\n                \\n                current = current.right;\\n            }\\n        }\\n    }\\n    \\n    \\n    int findPair(int n, Node head)\\n    {\\n        Node current = head;\\n        int xor = 0;\\n        \\n        for(int i = 31; i >= 0; i--)\\n        {\\n            // get the LSB\\n            int bit = (n >> i) & 1;\\n            if ( bit == 1 )\\n            {\\n                if ( current.left != null ){\\n                    current = current.left;\\n                    xor += Math.pow(2, i);\\n                }\\n                else\\n                    current = current.right;\\n            }else{\\n                \\n                if ( current.right != null ){\\n                    xor += Math.pow(2, i);\\n                    current = current.right;\\n                }\\n                else\\n                    current = current.left;\\n            }\\n        }\\n        \\n    \\n        return xor;\\n    }\\n    \\n    \\n    public int findMaximumXOR(int[] nums) {\\n        \\n        // a number that is complement to that number is the \\n        // maximum xor for that number\\n        \\n        Node head = new Node();\\n        \\n        for(int n : nums)\\n            insert(n, head);\\n        \\n        // find the maximum xor pair\\n        \\n        int max = 0;\\n        \\n        for(int i =0; i< nums.length; i++)\\n        {\\n            int temp = findPair(nums[i], head);\\n            max = Math.max(max, temp);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026105,
                "title": "java-greedy-approach",
                "content": "```\\nclass Solution {\\n        public int findMaximumXOR(int[] nums) {\\n            // greedy approach\\n            // try to find any combi that xor to a 1 on the left as early as possible as any 1 on the left of a binary digit is bigger than a digit having all ones on the right\\n           int mask = 0; \\n            int max = 0;\\n            \\n            for (int i = 31; i>=0 ;i--) {\\n               mask = mask | (1 << i);\\n               \\n                Set<Integer> set = new HashSet<>();\\n                \\n                for(int num: nums) {\\n                    set.add(mask & num);     \\n                }\\n                \\n               \\n                int greedyGuess = max | (1 << i);\\n                // try to find a pair that is able to  become the greedyguess after xor \\n                for (int num: set ) {\\n                    int otherNumRequired =  num ^ greedyGuess ; // a xor b = c means b = a xor c \\n                    if (set.contains(otherNumRequired)) {\\n                        max = greedyGuess;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            return max;\\n        } \\n} \\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int findMaximumXOR(int[] nums) {\\n            // greedy approach\\n            // try to find any combi that xor to a 1 on the left as early as possible as any 1 on the left of a binary digit is bigger than a digit having all ones on the right\\n           int mask = 0; \\n            int max = 0;\\n            \\n            for (int i = 31; i>=0 ;i--) {\\n               mask = mask | (1 << i);\\n               \\n                Set<Integer> set = new HashSet<>();\\n                \\n                for(int num: nums) {\\n                    set.add(mask & num);     \\n                }\\n                \\n               \\n                int greedyGuess = max | (1 << i);\\n                // try to find a pair that is able to  become the greedyguess after xor \\n                for (int num: set ) {\\n                    int otherNumRequired =  num ^ greedyGuess ; // a xor b = c means b = a xor c \\n                    if (set.contains(otherNumRequired)) {\\n                        max = greedyGuess;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            return max;\\n        } \\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 995110,
                "title": "easy-c-video-solution-explained-trie-solution",
                "content": "Video Solution: https://youtu.be/eKkSVTQxchA\\n\\n```\\nclass trieNode{\\n  public:\\n    trieNode *child[2];\\n    \\n    trieNode(){\\n        for(int i=0;i<2;i++)child[i]=NULL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    void insert(int x,trieNode *head){\\n        for(int i=31;i>=0;i--){\\n            int val=(x>>i) & 1;\\n            \\n            if(head->child[val]==NULL)head->child[val]=new trieNode();\\n            \\n            head=head->child[val];\\n        }\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        trieNode * root=new trieNode();\\n        for(int i=0;i<nums.size();i++){\\n            insert(nums[i],root);\\n        }\\n        int maxx=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int cur=0;\\n            \\n            trieNode *head=root;\\n            \\n            long long p=(1L<<31);\\n            for(int j=31;j>=0;j--){\\n                int val=(nums[i]>>j) & 1;\\n                \\n                if(head->child[!val]!=NULL){\\n                    head=head->child[!val];\\n                    cur+=p;\\n                }else{\\n                    head=head->child[val];\\n                }\\n                p=p>>1;\\n            }\\n            maxx=max(maxx,cur);\\n        }\\n        \\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass trieNode{\\n  public:\\n    trieNode *child[2];\\n    \\n    trieNode(){\\n        for(int i=0;i<2;i++)child[i]=NULL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    void insert(int x,trieNode *head){\\n        for(int i=31;i>=0;i--){\\n            int val=(x>>i) & 1;\\n            \\n            if(head->child[val]==NULL)head->child[val]=new trieNode();\\n            \\n            head=head->child[val];\\n        }\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        trieNode * root=new trieNode();\\n        for(int i=0;i<nums.size();i++){\\n            insert(nums[i],root);\\n        }\\n        int maxx=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int cur=0;\\n            \\n            trieNode *head=root;\\n            \\n            long long p=(1L<<31);\\n            for(int j=31;j>=0;j--){\\n                int val=(nums[i]>>j) & 1;\\n                \\n                if(head->child[!val]!=NULL){\\n                    head=head->child[!val];\\n                    cur+=p;\\n                }else{\\n                    head=head->child[val];\\n                }\\n                p=p>>1;\\n            }\\n            maxx=max(maxx,cur);\\n        }\\n        \\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926965,
                "title": "c-trie",
                "content": "```\\nclass Trie\\n{\\n public: Trie*child[2];\\n  Trie()\\n    {child[0]=NULL;\\nchild[1]=NULL;\\n    }\\n};\\nclass Solution {\\npublic:\\n    Trie* root=new Trie();\\n    void insert(int num)\\n    {\\n    Trie*temp=root;\\n     for(int i=31;i>=0;i--)\\n     {\\n    int val=(num & (1<<i));\\n         if(val)val=1;\\n       if(temp->child[val]==NULL)\\n       {\\n          temp->child[val]=new Trie();\\n           \\n       }\\n         temp=temp->child[val];\\n     }\\n    }\\n    void findmax(int num,int &maxx)\\n    {\\n        int ans=0;\\n        Trie*temp=root;\\n      for(int i=31;i>=0;i--)\\n      {\\n         int val=(num & (1<<i));\\n          if(val)val=1;\\n          if(temp->child[!val])\\n          {\\n             ans+=(1<<i);\\n             temp=temp->child[!val];\\n          }\\n          else\\n              temp=temp->child[val];\\n      }\\n        maxx=max(maxx,ans);\\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        for(auto j:nums)\\n        {\\n           insert(j); \\n        }\\n        int maxx=0;\\n        for(auto j:nums)\\n            findmax(j,maxx);\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie\\n{\\n public: Trie*child[2];\\n  Trie()\\n    {child[0]=NULL;\\nchild[1]=NULL;\\n    }\\n};\\nclass Solution {\\npublic:\\n    Trie* root=new Trie();\\n    void insert(int num)\\n    {\\n    Trie*temp=root;\\n     for(int i=31;i>=0;i--)\\n     {\\n    int val=(num & (1<<i));\\n         if(val)val=1;\\n       if(temp->child[val]==NULL)\\n       {\\n          temp->child[val]=new Trie();\\n           \\n       }\\n         temp=temp->child[val];\\n     }\\n    }\\n    void findmax(int num,int &maxx)\\n    {\\n        int ans=0;\\n        Trie*temp=root;\\n      for(int i=31;i>=0;i--)\\n      {\\n         int val=(num & (1<<i));\\n          if(val)val=1;\\n          if(temp->child[!val])\\n          {\\n             ans+=(1<<i);\\n             temp=temp->child[!val];\\n          }\\n          else\\n              temp=temp->child[val];\\n      }\\n        maxx=max(maxx,ans);\\n    }\\n    int findMaximumXOR(vector<int>& nums) {\\n        for(auto j:nums)\\n        {\\n           insert(j); \\n        }\\n        int maxx=0;\\n        for(auto j:nums)\\n            findmax(j,maxx);\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871544,
                "title": "java-o-n-hashset-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0, mask = 0;\\n        for(int i = 31; i >= 0; i--){\\n            mask = ~((1 << i) - 1);\\n            int tmp = max | (1 << i);\\n            Set<Integer> set = new HashSet<Integer>();\\n            for(int num: nums){\\n                int val = num & mask;\\n                if(set.contains(tmp ^ val))\\n                    max = Math.max(max, tmp);\\n                set.add(val);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int max = 0, mask = 0;\\n        for(int i = 31; i >= 0; i--){\\n            mask = ~((1 << i) - 1);\\n            int tmp = max | (1 << i);\\n            Set<Integer> set = new HashSet<Integer>();\\n            for(int num: nums){\\n                int val = num & mask;\\n                if(set.contains(tmp ^ val))\\n                    max = Math.max(max, tmp);\\n                set.add(val);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861552,
                "title": "c-using-trie",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct Node {\\n        Node *left;\\n        Node *right;\\n    };\\n    void insert(int n, Node* root){\\n        Node* curr=root;\\n        for (int i=31;i>=0;i--){\\n            int b = ((n>>i)&(1));\\n            if (b==0){\\n                if (!curr->left)\\n                     curr->left=new Node();\\n                curr=curr->left;\\n            }\\n            else {\\n                if (!curr->right)\\n                    curr->right=new Node();\\n                curr=curr->right;\\n            }\\n        }\\n    }\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Node* root= new Node();\\n        for (int n:nums) insert(n,root);\\n        int max_xor=0;\\n        for (int n:nums) {\\n            int curr_xor=0;\\n            Node* curr=root;\\n            for (int i=31;i>=0;i--){\\n                int b=((1<<i)&n);\\n                if (b==0){\\n                    if (curr->right){\\n                        curr_xor+=(1<<i);\\n                        curr=curr->right;\\n                    }\\n                    else curr=curr->left;\\n                }\\n                else {\\n                    if (curr->left){\\n                        curr_xor+=(1<<i);\\n                        curr=curr->left;\\n                    }\\n                    else curr=curr->right;\\n\\n                }\\n            }\\n            max_xor=max(max_xor,curr_xor);\\n        }\\n        return max_xor;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Node {\\n        Node *left;\\n        Node *right;\\n    };\\n    void insert(int n, Node* root){\\n        Node* curr=root;\\n        for (int i=31;i>=0;i--){\\n            int b = ((n>>i)&(1));\\n            if (b==0){\\n                if (!curr->left)\\n                     curr->left=new Node();\\n                curr=curr->left;\\n            }\\n            else {\\n                if (!curr->right)\\n                    curr->right=new Node();\\n                curr=curr->right;\\n            }\\n        }\\n    }\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Node* root= new Node();\\n        for (int n:nums) insert(n,root);\\n        int max_xor=0;\\n        for (int n:nums) {\\n            int curr_xor=0;\\n            Node* curr=root;\\n            for (int i=31;i>=0;i--){\\n                int b=((1<<i)&n);\\n                if (b==0){\\n                    if (curr->right){\\n                        curr_xor+=(1<<i);\\n                        curr=curr->right;\\n                    }\\n                    else curr=curr->left;\\n                }\\n                else {\\n                    if (curr->left){\\n                        curr_xor+=(1<<i);\\n                        curr=curr->left;\\n                    }\\n                    else curr=curr->right;\\n\\n                }\\n            }\\n            max_xor=max(max_xor,curr_xor);\\n        }\\n        return max_xor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850340,
                "title": "c-from-brute-force-to-using-trie-data-structure",
                "content": "***Brute Force*** [ Don\\'t Submit this Solution , it will give Time Limit Exeeded ]\\n```\\n\\nclass Solution {\\npublic:     \\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                int curr = nums[i] ^ nums[j];\\n                if (curr > res)\\n                    res = curr;\\n            }\\n        }\\n        return res;        \\n    }\\n};\\n\\n```\\n\\n***Using Trie Data Structure***\\n```\\nclass trieNode{\\npublic:\\n    trieNode *left;\\n    trieNode *right;\\n};\\n\\n/*\\n \\n _insert() function is used to insert the binary digits in Binary Search Tree\\n The main approach will be\\n 1] If the binary digit is \\'0\\' , then add it to the left\\n 2] If the binary digit is \\'1\\' , then add it to the right\\n \\n*/\\n\\ntrieNode* _insert(int value, trieNode* head){\\n    trieNode* cur = head;\\n    for(int i = 31; i>=0; i--){\\n        int bit  = (value>>i)&1;\\n        if(bit == 0){  \\n            if(!cur->left)\\n                cur->left = new trieNode();\\n            cur = cur->left;\\n        }\\n        else{\\n            if(!cur->right)\\n                cur->right = new trieNode();\\n            cur = cur->right;\\n        }\\n    }\\n    return head;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int xorVal(trieNode* head, vector<int> & nums){\\n        int maxVal = INT_MIN;\\n\\n        for(int j = 0; j<nums.size();j++){\\n            int curXor = 0;\\n            int value = nums[j];\\n            trieNode* cur = head;\\n\\n            for(int i = 31; i>=0; i--){\\n                int bit  = (value>>i)&1;\\n                if(bit == 0){\\n                    if(cur->right){\\n                        curXor += pow(2,i);\\n                        cur = cur->right;\\n                    }\\n                    else\\n                        cur = cur->left;\\n                }\\n                else{\\n                    if(cur->left){\\n                        curXor += pow(2,i);\\n                        cur = cur->left;\\n                    }\\n                    else\\n                        cur = cur->right;\\n                }\\n            }\\n            maxVal = max(maxVal, curXor);\\n        }\\n        return maxVal;\\n    }\\n\\n                                      \\n    int findMaximumXOR(vector<int>& nums) {\\n        trieNode* head = new trieNode();\\n        \\n        for(int j = 0; j<nums.size();j++)\\n            head = _insert(nums[j], head);\\n\\n        return xorVal(head, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:     \\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                int curr = nums[i] ^ nums[j];\\n                if (curr > res)\\n                    res = curr;\\n            }\\n        }\\n        return res;        \\n    }\\n};\\n\\n```\n```\\nclass trieNode{\\npublic:\\n    trieNode *left;\\n    trieNode *right;\\n};\\n\\n/*\\n \\n _insert() function is used to insert the binary digits in Binary Search Tree\\n The main approach will be\\n 1] If the binary digit is \\'0\\' , then add it to the left\\n 2] If the binary digit is \\'1\\' , then add it to the right\\n \\n*/\\n\\ntrieNode* _insert(int value, trieNode* head){\\n    trieNode* cur = head;\\n    for(int i = 31; i>=0; i--){\\n        int bit  = (value>>i)&1;\\n        if(bit == 0){  \\n            if(!cur->left)\\n                cur->left = new trieNode();\\n            cur = cur->left;\\n        }\\n        else{\\n            if(!cur->right)\\n                cur->right = new trieNode();\\n            cur = cur->right;\\n        }\\n    }\\n    return head;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int xorVal(trieNode* head, vector<int> & nums){\\n        int maxVal = INT_MIN;\\n\\n        for(int j = 0; j<nums.size();j++){\\n            int curXor = 0;\\n            int value = nums[j];\\n            trieNode* cur = head;\\n\\n            for(int i = 31; i>=0; i--){\\n                int bit  = (value>>i)&1;\\n                if(bit == 0){\\n                    if(cur->right){\\n                        curXor += pow(2,i);\\n                        cur = cur->right;\\n                    }\\n                    else\\n                        cur = cur->left;\\n                }\\n                else{\\n                    if(cur->left){\\n                        curXor += pow(2,i);\\n                        cur = cur->left;\\n                    }\\n                    else\\n                        cur = cur->right;\\n                }\\n            }\\n            maxVal = max(maxVal, curXor);\\n        }\\n        return maxVal;\\n    }\\n\\n                                      \\n    int findMaximumXOR(vector<int>& nums) {\\n        trieNode* head = new trieNode();\\n        \\n        for(int j = 0; j<nums.size();j++)\\n            head = _insert(nums[j], head);\\n\\n        return xorVal(head, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850143,
                "title": "rust-bitfiddling-v-short-explanation",
                "content": "You use a 32-bit bitmask to snag nums in the initial array that have bits set to the left of bit `i` . Put these bits in a set.\\n\\nIf two numbers in the set differ on the `i`th bit then the solution should have the `i`th bit set.\\n\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {\\n        let nums = nums.into_iter().map(|x| x as u32).collect::<Vec<u32>>();\\n        let mut mask = 0u32;\\n        let mut max = 0u32;\\n        for i in (0..=31).rev() {\\n            let potential_bit = max | (1 << i);\\n            mask |= 1 << i;\\n            let mut bits: HashSet<u32> = HashSet::new();\\n            for n in nums.iter() {\\n                bits.insert((*n as u32) & mask);\\n            }\\n            for b in bits.iter() {\\n                if bits.contains(&(b ^ potential_bit)) {\\n                    max = potential_bit;\\n                    break;\\n                } \\n            }\\n        }\\n        max as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {\\n        let nums = nums.into_iter().map(|x| x as u32).collect::<Vec<u32>>();\\n        let mut mask = 0u32;\\n        let mut max = 0u32;\\n        for i in (0..=31).rev() {\\n            let potential_bit = max | (1 << i);\\n            mask |= 1 << i;\\n            let mut bits: HashSet<u32> = HashSet::new();\\n            for n in nums.iter() {\\n                bits.insert((*n as u32) & mask);\\n            }\\n            for b in bits.iter() {\\n                if bits.contains(&(b ^ potential_bit)) {\\n                    max = potential_bit;\\n                    break;\\n                } \\n            }\\n        }\\n        max as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850078,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 96 ms, faster than 22.81% of Go online submissions for Maximum XOR of Two Numbers in an Array.\\nMemory Usage: 6.8 MB, less than 63.16% of Go online submissions for Maximum XOR of Two Numbers in an Array.\\n\\n```go\\nfunc findMaximumXOR(nums []int) int {\\n    res := 0\\n    for i := 31; i >= 0; i-- {\\n        // before res = 00001101\\n        res <<= 1\\n        // after  res = 00011010\\n        pre := make(map[int]bool)\\n        for _, n := range nums { pre[n >> i] = true }\\n        // res ^ 1, max res can be 00011011\\n        // a ^ b = res <=> a ^ res = b\\n        // try to find if b exist or not.\\n        for p := range pre { if pre[res ^ 1 ^ p] { res += 1; break } }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc findMaximumXOR(nums []int) int {\\n    res := 0\\n    for i := 31; i >= 0; i-- {\\n        // before res = 00001101\\n        res <<= 1\\n        // after  res = 00011010\\n        pre := make(map[int]bool)\\n        for _, n := range nums { pre[n >> i] = true }\\n        // res ^ 1, max res can be 00011011\\n        // a ^ b = res <=> a ^ res = b\\n        // try to find if b exist or not.\\n        for p := range pre { if pre[res ^ 1 ^ p] { res += 1; break } }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849818,
                "title": "python-two-solutions-o-n-time-each",
                "content": "First, I want to thank DBabichev for his solution https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/849128/Python-O(32n)-solution-explained which guided my solution.\\n\\nThe idea of O(N) solution is the same as in the post above: we build the answer in the binary representation digit by digit. We know that there are at most 32 zero-one digits in the final answer. First, we determine if 1 can be in the rightmost position. If yes, it will be part of the largest digit. Then, we proceed to the second digit, etc. It should look as follows where I put stars instead of unknown digits which are not part of the prefix.\\nIteration 1. `guess=1**..*` (32 digits in total)\\nIteration 2. If for iteration 1, we found that 1 can be on the place 32 in the previous iteration, then we would like to check if we can get `guess=11**...*`. If we found that 1 can not be, then we need to check if `guess=01**...*` (here we enforce 32 digits in all numbers) is possible for the answer.\\nAnd so on...\\n\\nSince we would like to use XOR for the masks above with numbers, instead of `*`, we write zeros. Also, To get coding easier, let us use binary operations to obtain numbers above.\\nIteration 1. `guess = 100..0=1<<31` (32 digits in total) and we get `ans =0**...*` or ans=`1**...*`.\\nIteration 2. `guess = ans  |  (1<<30)` (we want to clarify if the next digit to `ans` is zero or one)\\nIteration 3. `guess = ans  |  (1 << 29)`\\n\\nNow, it is high time to figure out if our guess is correct. Specifically, we want to find out if there are two numbers, say, `m` and `n`, such that the prefix of `m ^ n` is as `guess`. It would be if and only if at each digit when `guess` is zero,  `m^n` has ones. (take a moment to realize it, it is the central point). In other words, we need to check if\\n``` (m^n) & guess = guess.```\\nManipulating the equation, we get that we need to check if `(m & guess) ^ (n &guess) == guess`. Equivalently, ```m & guess = guess ^(n ^ guess)```.\\n\\nThe final code follows.\\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(31, -1, -1):\\n            guess = ans | (1 << i)\\n            # is there such digit, i.e., can we get prefix guess\\n            # note that guess is the largest suffix potentially possible.\\n            # Then, the prefix of m ^ n is guess if and only if (m & guess) ^ (n & guess) == guess\\n            prefixes = {guess & n for n in nums}\\n            # note that (m & guess) ^ (n & guess) == guess is equivalent to\\n            # n & guess == guess ^ (m&guess)            \\n            if any((guess ^ pref) in prefixes for pref in prefixes):\\n                ans = guess\\n        return ans\\n```\\nThe time and space complexity is O(N).\\n\\nNote that one may come up with another O(N) solution. Note that it is TIME LIMIT EXCEEDED. There are finitely many potential answers -- from 0 to 2^32 - 1. Moreover, the answer should satisfy `m ^ n = ans` or, equivalently, `m = ans ^ n`. The code follows.\\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n\\t\\t# TIME LIMIT EXCEEDED\\n        nums = set(nums)\\n        for ans in range(1 << 31 - 1, -1, -1):\\n            for n in nums:\\n                if ans ^ n in nums:\\n                    return ans\\n```\\nIt is very straightforward, and has O(N) time and space complexity",
                "solutionTags": [],
                "code": "``` (m^n) & guess = guess.```\n```m & guess = guess ^(n ^ guess)```\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(31, -1, -1):\\n            guess = ans | (1 << i)\\n            # is there such digit, i.e., can we get prefix guess\\n            # note that guess is the largest suffix potentially possible.\\n            # Then, the prefix of m ^ n is guess if and only if (m & guess) ^ (n & guess) == guess\\n            prefixes = {guess & n for n in nums}\\n            # note that (m & guess) ^ (n & guess) == guess is equivalent to\\n            # n & guess == guess ^ (m&guess)            \\n            if any((guess ^ pref) in prefixes for pref in prefixes):\\n                ans = guess\\n        return ans\\n```\n```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n\\t\\t# TIME LIMIT EXCEEDED\\n        nums = set(nums)\\n        for ans in range(1 << 31 - 1, -1, -1):\\n            for n in nums:\\n                if ans ^ n in nums:\\n                    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849362,
                "title": "python-set-and-trie",
                "content": "We view the numbers as binary strings, padded to the left with zeros up to `max_bin_len` which is the length of the longest binary representation we have for the numbers in our list. \\n\\nIn the first solution we iteratively check the possibility of a xor operation resulting in prefix ending with 1. If we find it, we look for possibility of prefix 11 during next iteration, oterwise we look for prefix 01, and so on we keep adding to the prefix. This way we build our `max_xor` trying to get 1 in as many positions as possible starting with the leftmost position and going right. Using the set data structure we limit the runtime to `O(max_bin_len * N)`.\\n```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tmax_bin_len = len(bin(max(nums))) - 2  # binary strgins start with 0b\\n\\tmax_xor = 0\\n\\tfor prefix_len in range(1, max_bin_len + 1):\\n\\t\\tmax_xor <<= 1\\n\\t\\tcur_xor = max_xor | 1\\n\\t\\tshift = max_bin_len - prefix_len\\n\\t\\tprefixes = {n >> shift for n in nums}\\n\\t\\tfound_match = any(cur_xor ^ prefix in prefixes for prefix in prefixes)\\n\\t\\tmax_xor |= found_match\\n\\treturn max_xor\\n```\\nIn the second solution we build the binary trie and every time we add a number to it we calculate the max xor value we can get with the values already present in trie. For this we iteratively check for the existence of the bit that is the opposite of the one we are currently adding to trie. Every addition / max xor value calculation takes `O(max_bin_len)` time and we do `N` of them, which results in runtime `O(max_bin_len * N)`.\\n```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tmax_bin_len = len(bin(max(nums))) - 2  # binary strgins start with 0b\\n\\n\\ttrie = {}\\n\\tnums = [[(n >> i) & 1 for i in range(max_bin_len - 1, -1, -1)] for n in nums] # converting each number to bit sequence of max length\\n\\tmax_xor = 0\\n\\n\\tfor num_bits in nums:\\n\\t\\tcur_node = trie\\n\\t\\txor_node = trie\\n\\t\\tcur_val = 0\\n\\t\\tfor bit in num_bits:\\n\\t\\t\\tif bit not in cur_node:\\n\\t\\t\\t\\tcur_node[bit] = {}\\n\\t\\t\\tcur_node = cur_node[bit]\\n\\t\\t\\txor_bit = 1 - bit\\n\\t\\t\\tcur_val <<= 1\\n\\t\\t\\tif xor_bit in xor_node:\\n\\t\\t\\t\\txor_node = xor_node[xor_bit]\\n\\t\\t\\t\\tcur_val |= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\txor_node = xor_node[bit]\\n\\t\\tmax_xor = max(max_xor, cur_val)\\n\\treturn max_xor\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie",
                    "Ordered Set"
                ],
                "code": "```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tmax_bin_len = len(bin(max(nums))) - 2  # binary strgins start with 0b\\n\\tmax_xor = 0\\n\\tfor prefix_len in range(1, max_bin_len + 1):\\n\\t\\tmax_xor <<= 1\\n\\t\\tcur_xor = max_xor | 1\\n\\t\\tshift = max_bin_len - prefix_len\\n\\t\\tprefixes = {n >> shift for n in nums}\\n\\t\\tfound_match = any(cur_xor ^ prefix in prefixes for prefix in prefixes)\\n\\t\\tmax_xor |= found_match\\n\\treturn max_xor\\n```\n```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tmax_bin_len = len(bin(max(nums))) - 2  # binary strgins start with 0b\\n\\n\\ttrie = {}\\n\\tnums = [[(n >> i) & 1 for i in range(max_bin_len - 1, -1, -1)] for n in nums] # converting each number to bit sequence of max length\\n\\tmax_xor = 0\\n\\n\\tfor num_bits in nums:\\n\\t\\tcur_node = trie\\n\\t\\txor_node = trie\\n\\t\\tcur_val = 0\\n\\t\\tfor bit in num_bits:\\n\\t\\t\\tif bit not in cur_node:\\n\\t\\t\\t\\tcur_node[bit] = {}\\n\\t\\t\\tcur_node = cur_node[bit]\\n\\t\\t\\txor_bit = 1 - bit\\n\\t\\t\\tcur_val <<= 1\\n\\t\\t\\tif xor_bit in xor_node:\\n\\t\\t\\t\\txor_node = xor_node[xor_bit]\\n\\t\\t\\t\\tcur_val |= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\txor_node = xor_node[bit]\\n\\t\\tmax_xor = max(max_xor, cur_val)\\n\\treturn max_xor\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 849197,
                "title": "beats-93-time-short-and-easy-trie-solution",
                "content": "```\\nclass Trie{\\n    public :\\n    int data;\\n    Trie *pos[2];\\n\\n    Trie(){\\n        data = 0;\\n        pos[0] = pos[1] = NULL;\\n    }\\n};\\n\\nclass Solution {\\n    void add( Trie *root , int data ){\\n        Trie * temp = root ; // We are assuming 32bits so we are extracting Bits from the MSB even it is 0 in most cases but it will handle larger cases\\n        for( int i = 31 ; i >= 0 ; i-- ){   \\n            bool v = ( data >> i ) & 1;  // Extracting Current Bit\\n            if( temp->pos[ v ] == NULL )  // If Current bit is Not Present then create a Node\\n                temp->pos[v] = new Trie();\\n            temp = temp->pos[v];    // traverse the node\\n        }\\n        temp->data = data;  // Adding Element to the Leaf Node so that we can do XOR of Elements \\n    }  // Above step helps us to remove unnecessary Sum in Finding Max Xor \\n    \\n    int maxXor( Trie *root , int data ){\\n        Trie *temp = root;   // Taking temporary Variable to traverse \\n        for( int i = 31 ; i >= 0 ; i-- ){\\n            bool v = ( data >> i ) & 1; // Extracting Current Bit\\n            if( temp->pos[ 1-v ] != NULL )  // Always got to opposite of current Set Bit if it exist( it will maximize your Value )\\n                 temp = temp->pos[1-v] ;\\n            else                     // other wise Go to the same Bit ( No change in value )\\n                temp = temp->pos[v];\\n        }\\n        return temp->data ^ data ; // Directly doing XOR \\n    }\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        Trie *root = new Trie();  // Intializng Root of Trie Data Structure\\n        for( auto &e : nums ){\\n            add(root , e );  // Adding Nodes for Number\\n            ans = max( ans , maxXor( root , e ));//  Storing XOR of max value\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Trie",
                    "Bitmask"
                ],
                "code": "class Solution {\\n    void add( Trie *root , int data ){\\n        Trie * temp = root ; // We are assuming 32bits so we are extracting Bits from the MSB even it is 0 in most cases but it will handle larger cases\\n        for( int i = 31 ; i >= 0 ; i-- ){   \\n            bool v = ( data >> i ) & 1;  // Extracting Current Bit\\n            if( temp->pos[ v ] == NULL )  // If Current bit is Not Present then create a Node\\n                temp->pos[v] = new Trie();\\n            temp = temp->pos[v];    // traverse the node\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 826625,
                "title": "trie-java-solution-video-link",
                "content": "For Concept Understanding\\nhttps://www.youtube.com/watch?v=6QSLMWgBnv4\\n\\n\\n```\\nclass Solution {\\n    \\n    private class TrieNode {\\n        TrieNode left = null; // left points to 0 \\n        TrieNode right = null; // right points to 1\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        TrieNode root = new TrieNode(); \\n        \\n        // Constructing the Trie\\n        for (int num : nums) {\\n            TrieNode curr = root;\\n            for (int i=31; i >= 0; i--) {\\n                int bit = (num >>> i) & 1;\\n                if (bit == 0) {\\n                    if (curr.left == null) {\\n                        curr.left = new TrieNode();\\n                    }\\n                    curr = curr.left;\\n                } else {\\n                    if (curr.right == null) {\\n                        curr.right = new TrieNode();\\n                    }\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        // Query on Trie\\n        for (int num : nums) {\\n            TrieNode curr = root;\\n            int currSum = 0;\\n            for (int i=31; i>=0; i--) {\\n                int bit = (num >>> i) & 1;\\n                if (bit == 0) {\\n                    if (curr.right != null) {\\n                        currSum += (int)(Math.pow(2, i));\\n                        // currSum += (1 >> i);\\n                        curr = curr.right;\\n                    } else {\\n                        curr = curr.left;\\n                    }\\n                }\\n                else {\\n                    if (curr.left != null) {\\n                        currSum += (int)(Math.pow(2, i));\\n                        // // currSum += (1 >> i);\\n                        curr = curr.left;\\n                    } else {\\n                        curr = curr.right;\\n                    }\\n                }\\n            }\\n            max = Math.max(currSum, max);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private class TrieNode {\\n        TrieNode left = null; // left points to 0 \\n        TrieNode right = null; // right points to 1\\n    }\\n    \\n    public int findMaximumXOR(int[] nums) {\\n        TrieNode root = new TrieNode(); \\n        \\n        // Constructing the Trie\\n        for (int num : nums) {\\n            TrieNode curr = root;\\n            for (int i=31; i >= 0; i--) {\\n                int bit = (num >>> i) & 1;\\n                if (bit == 0) {\\n                    if (curr.left == null) {\\n                        curr.left = new TrieNode();\\n                    }\\n                    curr = curr.left;\\n                } else {\\n                    if (curr.right == null) {\\n                        curr.right = new TrieNode();\\n                    }\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        // Query on Trie\\n        for (int num : nums) {\\n            TrieNode curr = root;\\n            int currSum = 0;\\n            for (int i=31; i>=0; i--) {\\n                int bit = (num >>> i) & 1;\\n                if (bit == 0) {\\n                    if (curr.right != null) {\\n                        currSum += (int)(Math.pow(2, i));\\n                        // currSum += (1 >> i);\\n                        curr = curr.right;\\n                    } else {\\n                        curr = curr.left;\\n                    }\\n                }\\n                else {\\n                    if (curr.left != null) {\\n                        currSum += (int)(Math.pow(2, i));\\n                        // // currSum += (1 >> i);\\n                        curr = curr.left;\\n                    } else {\\n                        curr = curr.right;\\n                    }\\n                }\\n            }\\n            max = Math.max(currSum, max);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824313,
                "title": "swift-2-solutions-bit-by-bit-greedy-and-trie",
                "content": "Bit by bit\\n```\\nfunc findMaximumXOR(_ nums: [Int]) -> Int {\\n\\tvar max = 0, mask = 0\\n\\n\\tfor i in stride(from: 31, through: 0, by: -1) {\\n\\t\\tmask |= 1 << i\\n\\n\\t\\tvar prefixes = Set<Int>()\\n\\t\\tfor num in nums {\\n\\t\\t\\tprefixes.insert(num & mask)\\n\\t\\t}\\n\\n\\t\\tlet idealMax = max | 1 << i\\n\\t\\tfor prefix in prefixes {\\n\\t\\t\\tif prefixes.contains(idealMax ^ prefix) {\\n\\t\\t\\t\\tmax = idealMax\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn max\\n}\\n```\\n\\nTrie\\n```\\nclass TrieNode {\\n    var children: [TrieNode?] = Array(repeating: nil, count: 2) // index 0 for 0 bits and 1 for 1 bits\\n}\\n\\nclass Solution {\\n    func findMaximumXOR(_ nums: [Int]) -> Int {\\n        let root = TrieNode()\\n        \\n        // build trie \\n        for num in nums {\\n            var node = root\\n            for i in stride(from: 30, through: 0, by: -1) {\\n                let curBit = (num >> i) & 1 // either 0 or 1\\n                if node.children[curBit] == nil {\\n                    node.children[curBit] = TrieNode()\\n                }\\n                node = node.children[curBit]! // if 0 go children[0], 1 go children[1]\\n            }\\n        }\\n        \\n        var globalMax = Int.min\\n        for num in nums {\\n            var node = root\\n            var curMax = 0\\n            for i in stride(from: 30, through: 0, by: -1) {\\n                let curBit = (num >> i) & 1\\n                if let counterPart = node.children[curBit ^ 1] {\\n                    curMax += 1 << i\\n                    node = counterPart\\n                } else {\\n                    node = node.children[curBit]!\\n                }\\n            }\\n            globalMax = max(globalMax, curMax)\\n        }\\n        \\n        return globalMax\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findMaximumXOR(_ nums: [Int]) -> Int {\\n\\tvar max = 0, mask = 0\\n\\n\\tfor i in stride(from: 31, through: 0, by: -1) {\\n\\t\\tmask |= 1 << i\\n\\n\\t\\tvar prefixes = Set<Int>()\\n\\t\\tfor num in nums {\\n\\t\\t\\tprefixes.insert(num & mask)\\n\\t\\t}\\n\\n\\t\\tlet idealMax = max | 1 << i\\n\\t\\tfor prefix in prefixes {\\n\\t\\t\\tif prefixes.contains(idealMax ^ prefix) {\\n\\t\\t\\t\\tmax = idealMax\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn max\\n}\\n```\n```\\nclass TrieNode {\\n    var children: [TrieNode?] = Array(repeating: nil, count: 2) // index 0 for 0 bits and 1 for 1 bits\\n}\\n\\nclass Solution {\\n    func findMaximumXOR(_ nums: [Int]) -> Int {\\n        let root = TrieNode()\\n        \\n        // build trie \\n        for num in nums {\\n            var node = root\\n            for i in stride(from: 30, through: 0, by: -1) {\\n                let curBit = (num >> i) & 1 // either 0 or 1\\n                if node.children[curBit] == nil {\\n                    node.children[curBit] = TrieNode()\\n                }\\n                node = node.children[curBit]! // if 0 go children[0], 1 go children[1]\\n            }\\n        }\\n        \\n        var globalMax = Int.min\\n        for num in nums {\\n            var node = root\\n            var curMax = 0\\n            for i in stride(from: 30, through: 0, by: -1) {\\n                let curBit = (num >> i) & 1\\n                if let counterPart = node.children[curBit ^ 1] {\\n                    curMax += 1 << i\\n                    node = counterPart\\n                } else {\\n                    node = node.children[curBit]!\\n                }\\n            }\\n            globalMax = max(globalMax, curMax)\\n        }\\n        \\n        return globalMax\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795098,
                "title": "c-16ms-runtime-o-n-solution-beats-100-of-submissions",
                "content": "TRUST ME, the code looks complicated, but its really easy to understand. I have made it as readable as possible.\\nMy code, works by using the concept of binary trees. Except, that the node do not need to store any value. I have defined a simple structure with 2 simple pointers, left and right. The left pointer indicates the bit value 0, and the right pointer indicates the bit value 1. So here are the steps that I followed,\\n* 1. First, we find the maximum value from the list by scanning through the array once, I have used the variable name \"max\" for this purpose.\\n* 2. Next, we find the index of the highest possible 1 bit in the max variable. I have used the variable name \"maxbit\" for this purpose.\\n* 3. We then construct a Binary tree from the input array and create a left node if we encounter a 0, and create a right node if we encounter a 1. We do this for all the numbers provided in the input array.\\n* 4. The binary tree gives us a base model that we can now work upon. Now, to find the 2 numbers that gives us the maximum XOR, we have to find 2 complimentary bits, or in other words, 2 complimentary branches for the current node. Let me explain this in detail.\\n* 5. We first initialise 2 pointers to traverse the binary tree, I have used the names \"pt1\" and \"pt2\" for this purpose. In the beginning, both these pointers are assigned to the head or as I have called it, the \"begin\" node. If both pointers move in opposite directions, then we can have the highest possible XORed value, since XOR provides a 1 bit for a complimentary input.\\n* 6. Now lets look at the available options that we have to work with, let me create a table that provides all the possible options available for these pointers, \\n*                           pt1                                          pt2                                    Action\\n*                  Only left node available                       Only left node available              Move pt1 left and pt2 left. (As there isnt any other option available)\\n*                  Only left node available                      Only Right node available              Move pt1 left and pt2 right. (As these are complimentary operations, we add 1 bit at the current index of the answer)\\n*                  Only left node available                   Both left and Right node available        Move pt1 left and pt2 right. (As these are complimentary operations, we add 1 bit at the current index of the answer)\\n*                  Only Right node available                      Only left node available              Move pt1 right and pt2 left. (As these are complimentary operations, we add 1 bit at the current index of the answer)\\n*                  Only Right node available                      Only Right node available             Move pt1 right and pt2 right. (As there isnt any other option available)\\n*                  Only Right node available                  Both left and Right node available        Move pt1 right and pt2 left. (As these are complimentary operations, we add 1 bit at the current index of the answer)\\n*                Both left and Right node available                Only left node available             Move pt1 right and pt2 left. (As these are complimentary operations, we add 1 bit at the current index of the answer)\\n*                Both left and Right node available                Only right node available            Move pt1 left and pt2 right. (As these are complimentary operations, we add 1 bit at the current index of the answer)\\n*                Both left and Right node available          Both left and Right node available     We use recursion here, by first moving pt1 left and pt2 right, and then pt1 right and pt2 left.\\n*  7. In the last option, we can see that, as we do not have any clue of where to move, so we test both the options available to us. We first move pt1 left and pt2 right, get the answer for this choice, and then move pt1 right and pt2 left and capture the answer. We then compare the results and pick the maximum value. As this is a recursive call, we end the loop here. \\n*  8. Here, the path followed by pt1, corresponds to the first value that needs to be XORed, and the path followed by pt2 corresponds to the second value. In case you need to find these values, We can create 2 more variables in the \"findMaxXOR\" function and capture the path followed by pt1 and pt2, we can then XOR these 2 values to get the final result. In fact, this is exactly what I had done previously, before realising that there was a better alternative. \\n*  9. I would like to urge you to read my code, the \"addnode\" function isn\\'t important to understand the concept, just assume that it creates a new node and returns the node with both left and right values equal to NULL.\\n\\t# Code\\n```\\n#define MAX (1000)\\n\\nstruct node{\\n    struct node * left;\\n    struct node * right;\\n};\\n\\n\\nstruct node * arr;\\nstruct node * addnode(int *size, int *maxsize)\\n{\\n    if((*size) >= (*maxsize))\\n    {\\n        (*maxsize) += MAX;\\n        arr = (struct node *)malloc((*maxsize) * sizeof(struct node));\\n    }\\n    (arr + ((*size) % MAX))->left = NULL;\\n    (arr + ((*size) % MAX))->right = NULL;\\n    (*size) += 1;\\n    return (arr + (((*size) - 1) % MAX));\\n}\\n\\nint findMaxXOR(struct node *pt1, struct node *pt2, int maxbit);\\n\\nint findMaximumXOR(int* nums, int numsSize){\\n    if(numsSize < 2)\\n        return 0;\\n    int max = 0;\\n    for(int i = 0 ; i < numsSize ; i++)\\n        if(nums[max] < nums[i])\\n            max = i;\\n\\n    int maxbit = 30;\\n    for(maxbit = 0 ; maxbit < 31 ; maxbit++)\\n        if((nums[max] >> maxbit) == 1)\\n            break;\\n\\n    int nodesize = 0, nodemaxsize = 0;\\n    arr = NULL;\\n    struct node *begin = addnode(&nodesize, &nodemaxsize);\\n    \\n    for(int i = 0 ; i < numsSize; i++)\\n    {\\n        struct node *temp = begin;\\n        for(int j = maxbit; j >= 0 ; j--)\\n        {\\n            if((1 << j) & nums[i])\\n            {\\n                if(temp->right == NULL)\\n                    temp->right = addnode(&nodesize, &nodemaxsize);\\n                temp = temp->right;\\n            }\\n            else\\n            {\\n                if(temp->left == NULL)\\n                    temp->left = addnode(&nodesize, &nodemaxsize);\\n                temp = temp->left;\\n            }\\n        }\\n    }\\n\\n    int ans = findMaxXOR(begin, begin, maxbit);\\n    \\n    free(begin);\\n    \\n    return ans;\\n}\\n    \\n    \\nint findMaxXOR(struct node *pt1, struct node *pt2, int index)\\n{\\n    int ans = 0;\\n    while(index >= 0)\\n    {\\n        int pt1State = 0, pt2State = 0;\\n        if(pt1->left != NULL)\\n            pt1State = 1;\\n        if(pt1->right != NULL)\\n            pt1State += 2;\\n        if(pt2->left != NULL)\\n            pt2State = 1;\\n        if(pt2->right != NULL)\\n            pt2State += 2;\\n        switch(pt1State)      //if pt1State\\'s value is 1, then only left node is avaibale, if 2, then only right node is available, if 3, then both are available. (for pt1)\\n        {\\n            case 1:\\n                pt1 = pt1->left;\\n                if(pt2State == 1)\\n                    pt2 = pt2->left;\\n                else\\n                {\\n                    pt2 = pt2->right;\\n                    ans |= (1 << index);   //As pt1 and pt2\\'s action is complimentary, we add 1 to the index of the answer variable.\\n                }\\n                break;\\n            case 2:\\n                pt1 = pt1->right;\\n                if(pt2State == 2)\\n                    pt2 = pt2->right;\\n                else\\n                {\\n                    pt2 = pt2->left;\\n                    ans |= (1 << index);   //As pt1 and pt2\\'s action is complimentary, we add 1 to the index of the answer variable.\\n                }\\n                break;\\n            case 3:\\n                ans |= (1 << index);   //As pt1 and pt2\\'s action is complimentary, we add 1 to the index of the answer variable.\\n                switch(pt2State)\\n                {\\n                    case 1:\\n                        pt1 = pt1->right;\\n                        pt2 = pt2->left;\\n                        break;\\n                    case 2:\\n                        pt1 = pt1->left;\\n                        pt2 = pt2->right;\\n                        break;\\n                    case 3:\\n                        {\\n                            if(pt1 == pt2)                        //check for starting condition, where both pt1 and pt2 are equal to \"begin\"\\n                                return (findMaxXOR(pt1->left, pt2->right, index - 1) | ans);\\n                            \\n                            int ans1 = findMaxXOR(pt1->left, pt2->right, index - 1);\\n                            int ans2 = findMaxXOR(pt1->right, pt2->left, index - 1);\\n                            if(ans1 > ans2)\\n                                return (ans1 | ans);\\n                            else\\n                                return (ans2 | ans);\\n                        }\\n                        break;\\n                }\\n                break;\\n        }\\n        index--;\\n    }\\n    return ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#define MAX (1000)\\n\\nstruct node{\\n    struct node * left;\\n    struct node * right;\\n};\\n\\n\\nstruct node * arr;\\nstruct node * addnode(int *size, int *maxsize)\\n{\\n    if((*size) >= (*maxsize))\\n    {\\n        (*maxsize) += MAX;\\n        arr = (struct node *)malloc((*maxsize) * sizeof(struct node));\\n    }\\n    (arr + ((*size) % MAX))->left = NULL;\\n    (arr + ((*size) % MAX))->right = NULL;\\n    (*size) += 1;\\n    return (arr + (((*size) - 1) % MAX));\\n}\\n\\nint findMaxXOR(struct node *pt1, struct node *pt2, int maxbit);\\n\\nint findMaximumXOR(int* nums, int numsSize){\\n    if(numsSize < 2)\\n        return 0;\\n    int max = 0;\\n    for(int i = 0 ; i < numsSize ; i++)\\n        if(nums[max] < nums[i])\\n            max = i;\\n\\n    int maxbit = 30;\\n    for(maxbit = 0 ; maxbit < 31 ; maxbit++)\\n        if((nums[max] >> maxbit) == 1)\\n            break;\\n\\n    int nodesize = 0, nodemaxsize = 0;\\n    arr = NULL;\\n    struct node *begin = addnode(&nodesize, &nodemaxsize);\\n    \\n    for(int i = 0 ; i < numsSize; i++)\\n    {\\n        struct node *temp = begin;\\n        for(int j = maxbit; j >= 0 ; j--)\\n        {\\n            if((1 << j) & nums[i])\\n            {\\n                if(temp->right == NULL)\\n                    temp->right = addnode(&nodesize, &nodemaxsize);\\n                temp = temp->right;\\n            }\\n            else\\n            {\\n                if(temp->left == NULL)\\n                    temp->left = addnode(&nodesize, &nodemaxsize);\\n                temp = temp->left;\\n            }\\n        }\\n    }\\n\\n    int ans = findMaxXOR(begin, begin, maxbit);\\n    \\n    free(begin);\\n    \\n    return ans;\\n}\\n    \\n    \\nint findMaxXOR(struct node *pt1, struct node *pt2, int index)\\n{\\n    int ans = 0;\\n    while(index >= 0)\\n    {\\n        int pt1State = 0, pt2State = 0;\\n        if(pt1->left != NULL)\\n            pt1State = 1;\\n        if(pt1->right != NULL)\\n            pt1State += 2;\\n        if(pt2->left != NULL)\\n            pt2State = 1;\\n        if(pt2->right != NULL)\\n            pt2State += 2;\\n        switch(pt1State)      //if pt1State\\'s value is 1, then only left node is avaibale, if 2, then only right node is available, if 3, then both are available. (for pt1)\\n        {\\n            case 1:\\n                pt1 = pt1->left;\\n                if(pt2State == 1)\\n                    pt2 = pt2->left;\\n                else\\n                {\\n                    pt2 = pt2->right;\\n                    ans |= (1 << index);   //As pt1 and pt2\\'s action is complimentary, we add 1 to the index of the answer variable.\\n                }\\n                break;\\n            case 2:\\n                pt1 = pt1->right;\\n                if(pt2State == 2)\\n                    pt2 = pt2->right;\\n                else\\n                {\\n                    pt2 = pt2->left;\\n                    ans |= (1 << index);   //As pt1 and pt2\\'s action is complimentary, we add 1 to the index of the answer variable.\\n                }\\n                break;\\n            case 3:\\n                ans |= (1 << index);   //As pt1 and pt2\\'s action is complimentary, we add 1 to the index of the answer variable.\\n                switch(pt2State)\\n                {\\n                    case 1:\\n                        pt1 = pt1->right;\\n                        pt2 = pt2->left;\\n                        break;\\n                    case 2:\\n                        pt1 = pt1->left;\\n                        pt2 = pt2->right;\\n                        break;\\n                    case 3:\\n                        {\\n                            if(pt1 == pt2)                        //check for starting condition, where both pt1 and pt2 are equal to \"begin\"\\n                                return (findMaxXOR(pt1->left, pt2->right, index - 1) | ans);\\n                            \\n                            int ans1 = findMaxXOR(pt1->left, pt2->right, index - 1);\\n                            int ans2 = findMaxXOR(pt1->right, pt2->left, index - 1);\\n                            if(ans1 > ans2)\\n                                return (ans1 | ans);\\n                            else\\n                                return (ans2 | ans);\\n                        }\\n                        break;\\n                }\\n                break;\\n        }\\n        index--;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 714547,
                "title": "c-o-n-using-trie",
                "content": "```csharp\\npublic class Solution \\n{\\n    public class TrieNode\\n    {\\n        public TrieNode[] Children = new TrieNode[2];\\n    }\\n    \\n    public int FindMaximumXOR(int[] nums) \\n    {\\n        TrieNode root = new TrieNode();\\n                \\n        foreach(var num in nums)\\n        {\\n            TrieNode node = root;\\n            for(int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num & (1 << i)) != 0 ? 1 : 0;              \\n                if(node.Children[bit] == null)\\n                {\\n                    node.Children[bit] = new TrieNode();\\n                }\\n                    \\n                node = node.Children[bit];                    \\n            }\\n        }\\n        \\n        int result = int.MinValue;\\n        \\n        foreach(var num in nums)\\n        {\\n            TrieNode node = root;\\n            int xorValue = 0;\\n            for(int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num & (1 << i)) != 0 ? 1 : 0;\\n                int flipBit = bit == 0 ? 1 : 0;\\n                \\n                if(node.Children[flipBit] != null)\\n                {\\n                    xorValue += (1 << i);                    \\n                    node = node.Children[flipBit];\\n                }\\n                else\\n                {\\n                    node = node.Children[bit];                        \\n                }\\n            }\\n            \\n            result = Math.Max(result, xorValue);\\n        }\\n                \\n        return result;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public class TrieNode\\n    {\\n        public TrieNode[] Children = new TrieNode[2];\\n    }\\n    \\n    public int FindMaximumXOR(int[] nums) \\n    {\\n        TrieNode root = new TrieNode();\\n                \\n        foreach(var num in nums)\\n        {\\n            TrieNode node = root;\\n            for(int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num & (1 << i)) != 0 ? 1 : 0;              \\n                if(node.Children[bit] == null)\\n                {\\n                    node.Children[bit] = new TrieNode();\\n                }\\n                    \\n                node = node.Children[bit];                    \\n            }\\n        }\\n        \\n        int result = int.MinValue;\\n        \\n        foreach(var num in nums)\\n        {\\n            TrieNode node = root;\\n            int xorValue = 0;\\n            for(int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num & (1 << i)) != 0 ? 1 : 0;\\n                int flipBit = bit == 0 ? 1 : 0;\\n                \\n                if(node.Children[flipBit] != null)\\n                {\\n                    xorValue += (1 << i);                    \\n                    node = node.Children[flipBit];\\n                }\\n                else\\n                {\\n                    node = node.Children[bit];                        \\n                }\\n            }\\n            \\n            result = Math.Max(result, xorValue);\\n        }\\n                \\n        return result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577467,
                "title": "c-clean-solution-using-binary-tree-trie",
                "content": "General Idea:\\n\\n1. Create a binary tree (depth = 31) from given array elements, where each leaf-node represents a number in nums[]\\n\\n2. On path from root to a leaf, at depth i, going right means i-th MSB is 1 in binary representation of the number at the leaf. Similarly, going left means i-th MSB is 0.\\n\\n3. Take two pointers a and b, initialize both with root. Let {m, n} is solution. a\\'s task is to reach m and b\\'s task is to reach n;\\n\\n4. Let node x is the first node from top to have both left and right child. a goes to x->left and b goes to x->right.\\n\\n4. At any depth, if a goes to left, b should go to right. Similiarly, if a goes to right, b should go to left. If both are possible, try both and return maximum of both.\\n\\n5. Calculate and return XOR (a->val, b->val) on reaching leaf nodes.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\n\\n\\nclass Solution {\\npublic:\\n    // Insert n as a leaf node in tree according to its binary representation\\n    void insertNode(TreeNode* root, int n)\\n    {\\n        TreeNode *curr = root;\\n        int val = n;\\n        for(int i=30; i>=0; i--)\\n        {\\n            int q = n / (int)pow(2, i);\\n            n = n % (int)pow(2, i);\\n            // (30-i)th MSB is 0, hence go to left at depth (30-i) from root\\n            if(q == 0)\\n            {\\n                if(curr->left == 0)\\n                    curr->left = new TreeNode(0);\\n                curr = curr->left;\\n            }            \\n            // (30-i)th MSB is 1, hence go to right at depth (30-i) from root\\n            else\\n            {\\n                if(curr->right == 0)\\n                    curr->right = new TreeNode(1);\\n                curr = curr->right;\\n            }\\n        }\\n        curr->val = val;\\n    }\\n    \\n    int solve(TreeNode *a, TreeNode *b)\\n    {\\n        // We reach a leaf node\\n        if(a->left == NULL and a->right == NULL)\\n            return a->val ^ b->val;\\n        \\n        int ans = 0;\\n        if(a->left != NULL)\\n        {\\n            if(b->right != NULL)\\n                ans = max(ans, solve(a->left, b->right));\\n            else \\n                ans = max(ans, solve(a->left, b->left));\\n        }\\n        if(a->right != NULL)\\n        {\\n            if(b->left != NULL)\\n                ans = max(ans, solve(a->right, b->left));\\n            else \\n                ans = max(ans, solve(a->right, b->right));\\n        }\\n        return ans;\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        TreeNode* root = new TreeNode(0);\\n        for(int i=0; i<nums.size(); i++)\\n            insertNode(root, nums[i]);\\n        TreeNode *a = root;\\n        TreeNode *b = root;\\n        return solve(a, b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\n\\n\\nclass Solution {\\npublic:\\n    // Insert n as a leaf node in tree according to its binary representation\\n    void insertNode(TreeNode* root, int n)\\n    {\\n        TreeNode *curr = root;\\n        int val = n;\\n        for(int i=30; i>=0; i--)\\n        {\\n            int q = n / (int)pow(2, i);\\n            n = n % (int)pow(2, i);\\n            // (30-i)th MSB is 0, hence go to left at depth (30-i) from root\\n            if(q == 0)\\n            {\\n                if(curr->left == 0)\\n                    curr->left = new TreeNode(0);\\n                curr = curr->left;\\n            }            \\n            // (30-i)th MSB is 1, hence go to right at depth (30-i) from root\\n            else\\n            {\\n                if(curr->right == 0)\\n                    curr->right = new TreeNode(1);\\n                curr = curr->right;\\n            }\\n        }\\n        curr->val = val;\\n    }\\n    \\n    int solve(TreeNode *a, TreeNode *b)\\n    {\\n        // We reach a leaf node\\n        if(a->left == NULL and a->right == NULL)\\n            return a->val ^ b->val;\\n        \\n        int ans = 0;\\n        if(a->left != NULL)\\n        {\\n            if(b->right != NULL)\\n                ans = max(ans, solve(a->left, b->right));\\n            else \\n                ans = max(ans, solve(a->left, b->left));\\n        }\\n        if(a->right != NULL)\\n        {\\n            if(b->left != NULL)\\n                ans = max(ans, solve(a->right, b->left));\\n            else \\n                ans = max(ans, solve(a->right, b->right));\\n        }\\n        return ans;\\n    }\\n    \\n    int findMaximumXOR(vector<int>& nums) {\\n        TreeNode* root = new TreeNode(0);\\n        for(int i=0; i<nums.size(); i++)\\n            insertNode(root, nums[i]);\\n        TreeNode *a = root;\\n        TreeNode *b = root;\\n        return solve(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577313,
                "title": "c-easy-to-understand",
                "content": "```\\nclass node {\\npublic:\\n    node *next[2];\\n    node() {\\n        for(int i = 0; i < 2; i++) next[i] = NULL;\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    /** Initialize your data structure here. */\\n    node *root;\\n    Trie() {\\n        root = new node();\\n    }\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(int num) {\\n        node *current = root;\\n        for(int i = 30; i >= 0; i--) {\\n            bool b = (num >> i) & 1;\\n            if(current->next[b] == NULL) {\\n                current->next[b] = new node();\\n            }\\n            current = current->next[b];\\n        }\\n    }\\n    int query(int num) {\\n        int ans = 0;\\n        node *current = root;\\n        for(int i = 30; i >= 0 && current; i--) {\\n            bool b = (num >> i) & 1;\\n            if(current->next[!b]) {\\n                ans = ans | (1 << i);\\n                current = current->next[!b];\\n            } else {\\n                current = current->next[b];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        Trie *tree = new Trie();\\n        for(int x : nums) {\\n            ans = max(ans, tree->query(x));\\n            tree->insert(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass node {\\npublic:\\n    node *next[2];\\n    node() {\\n        for(int i = 0; i < 2; i++) next[i] = NULL;\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    /** Initialize your data structure here. */\\n    node *root;\\n    Trie() {\\n        root = new node();\\n    }\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(int num) {\\n        node *current = root;\\n        for(int i = 30; i >= 0; i--) {\\n            bool b = (num >> i) & 1;\\n            if(current->next[b] == NULL) {\\n                current->next[b] = new node();\\n            }\\n            current = current->next[b];\\n        }\\n    }\\n    int query(int num) {\\n        int ans = 0;\\n        node *current = root;\\n        for(int i = 30; i >= 0 && current; i--) {\\n            bool b = (num >> i) & 1;\\n            if(current->next[!b]) {\\n                ans = ans | (1 << i);\\n                current = current->next[!b];\\n            } else {\\n                current = current->next[b];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        Trie *tree = new Trie();\\n        for(int x : nums) {\\n            ans = max(ans, tree->query(x));\\n            tree->insert(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536880,
                "title": "c-trie",
                "content": "```\\nstruct Node{\\n    Node* next[2];\\n    Node(){\\n        for(int i=0;i<2;i++)\\n            next[i] = NULL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ret= 0;\\n        Node * root = new Node();\\n        for(int num : nums){\\n            Node* node = root;\\n            Node* xornode = root;\\n            int ans = 0;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int index = (num >> i)&1;\\n                //insert\\n                if(node->next[index]!=NULL)\\n                    node = node->next[index];\\n                else{\\n                    node->next[index] = new Node();\\n                    node = node->next[index];\\n                }\\n                //xormax\\n                int op = 1 - index;\\n                if(xornode->next[op]!=NULL)\\n                {\\n                    xornode = xornode->next[op];\\n                    ans += pow(2, i);\\n                } \\n                else\\n                    xornode = xornode->next[index];   \\n            }\\n            ret = max(ans, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n    Node* next[2];\\n    Node(){\\n        for(int i=0;i<2;i++)\\n            next[i] = NULL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        int ret= 0;\\n        Node * root = new Node();\\n        for(int num : nums){\\n            Node* node = root;\\n            Node* xornode = root;\\n            int ans = 0;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int index = (num >> i)&1;\\n                //insert\\n                if(node->next[index]!=NULL)\\n                    node = node->next[index];\\n                else{\\n                    node->next[index] = new Node();\\n                    node = node->next[index];\\n                }\\n                //xormax\\n                int op = 1 - index;\\n                if(xornode->next[op]!=NULL)\\n                {\\n                    xornode = xornode->next[op];\\n                    ans += pow(2, i);\\n                } \\n                else\\n                    xornode = xornode->next[index];   \\n            }\\n            ret = max(ans, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462573,
                "title": "trie-python-simple",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.fin_val = -1\\n    \\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n        \\n    def insert(self, val):\\n        ptr = self.root\\n        for x in range(31, -1, -1):\\n            digit = 1 if (val & 1 << x) else 0\\n            if digit not in ptr.children:\\n                ptr.children[digit] = TrieNode()\\n            ptr = ptr.children[digit]\\n        ptr.fin_val = val\\n\\n\\n    def max_xor(self, A):\\n        g_max = 0\\n        for x in range(len(A)):\\n            ptr = self.root\\n            curr = A[x]\\n            for y in range(31, -1, -1):\\n                digit = 1 if (curr & 1 << y) else 0\\n                if digit == 0:\\n                    if 1 in ptr.children:\\n                        ptr = ptr.children[1]\\n                    else:\\n                        ptr = ptr.children[0]\\n                else:\\n                    if 0 in ptr.children:\\n                        ptr = ptr.children[0]\\n                    else:\\n                        ptr = ptr.children[1]\\n            g_max = max(g_max, ptr.fin_val ^ curr)\\n        return g_max\\n            \\n        \\n        \\nclass Solution:\\n    # @param A : list of integers\\n    # @return an integer\\n    def findMaximumXOR(self, A):\\n        t = Trie()\\n        for x in A:\\n            t.insert(x)\\n        return t.max_xor(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.fin_val = -1\\n    \\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n        \\n    def insert(self, val):\\n        ptr = self.root\\n        for x in range(31, -1, -1):\\n            digit = 1 if (val & 1 << x) else 0\\n            if digit not in ptr.children:\\n                ptr.children[digit] = TrieNode()\\n            ptr = ptr.children[digit]\\n        ptr.fin_val = val\\n\\n\\n    def max_xor(self, A):\\n        g_max = 0\\n        for x in range(len(A)):\\n            ptr = self.root\\n            curr = A[x]\\n            for y in range(31, -1, -1):\\n                digit = 1 if (curr & 1 << y) else 0\\n                if digit == 0:\\n                    if 1 in ptr.children:\\n                        ptr = ptr.children[1]\\n                    else:\\n                        ptr = ptr.children[0]\\n                else:\\n                    if 0 in ptr.children:\\n                        ptr = ptr.children[0]\\n                    else:\\n                        ptr = ptr.children[1]\\n            g_max = max(g_max, ptr.fin_val ^ curr)\\n        return g_max\\n            \\n        \\n        \\nclass Solution:\\n    # @param A : list of integers\\n    # @return an integer\\n    def findMaximumXOR(self, A):\\n        t = Trie()\\n        for x in A:\\n            t.insert(x)\\n        return t.max_xor(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445886,
                "title": "c-trie-solution",
                "content": "```\\npublic class Solution\\n    {\\n        private class TrieNode\\n        {\\n            public readonly TrieNode[] Next = new TrieNode[2];\\n        }\\n\\n        private class Trie\\n        {\\n            public readonly TrieNode Root = new TrieNode();\\n\\n            private void AddValue(TrieNode node, int val, int idx)\\n            {\\n                if (idx == -1)\\n                {\\n                    return;\\n                }\\n\\n                int bit = ((val & (1 << idx)) >> idx);\\n                \\n                if (node.Next[bit] == null)\\n                {\\n                    node.Next[bit] = new TrieNode();\\n                }\\n\\n                AddValue(node.Next[bit], val, idx - 1);\\n            }\\n\\n            public void Insert(int val)\\n            {\\n                AddValue(Root, val, 31);\\n            }\\n        }\\n\\n        private void Helper(TrieNode node, ref int res, int currentNumber, int bitNumber)\\n        {\\n            if (bitNumber < 0)\\n            {\\n                return;\\n            }\\n\\n            int bitInCurrNumber = ((currentNumber & (1 << bitNumber)) >> bitNumber);\\n            int opposite = (bitInCurrNumber + 1) % 2;\\n\\n            if (node.Next[bitInCurrNumber] == null && node.Next[opposite] == null)\\n            {\\n                res |= (currentNumber & ((1 << (bitNumber + 1)) - 1));\\n                return;\\n            }\\n\\n            if (node.Next[opposite] != null)\\n            {\\n                res |= (1 << bitNumber);\\n                Helper(node.Next[opposite], ref res, currentNumber, bitNumber - 1);\\n                return;\\n            }\\n\\n            Helper(node.Next[bitInCurrNumber], ref res, currentNumber, bitNumber - 1);\\n        }\\n\\n        public int FindMaximumXOR(int[] nums)\\n        {\\n            Trie trie = new Trie();\\n\\n            foreach (var num in nums)\\n            {\\n                trie.Insert(num);\\n            }\\n\\n            int res = 0;\\n\\n            foreach (var num in nums)\\n            {\\n                int candidate = 0;\\n                Helper(trie.Root, ref candidate, num, 31);\\n                res = Math.Max(res, candidate);\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n    {\\n        private class TrieNode\\n        {\\n            public readonly TrieNode[] Next = new TrieNode[2];\\n        }\\n\\n        private class Trie\\n        {\\n            public readonly TrieNode Root = new TrieNode();\\n\\n            private void AddValue(TrieNode node, int val, int idx)\\n            {\\n                if (idx == -1)\\n                {\\n                    return;\\n                }\\n\\n                int bit = ((val & (1 << idx)) >> idx);\\n                \\n                if (node.Next[bit] == null)\\n                {\\n                    node.Next[bit] = new TrieNode();\\n                }\\n\\n                AddValue(node.Next[bit], val, idx - 1);\\n            }\\n\\n            public void Insert(int val)\\n            {\\n                AddValue(Root, val, 31);\\n            }\\n        }\\n\\n        private void Helper(TrieNode node, ref int res, int currentNumber, int bitNumber)\\n        {\\n            if (bitNumber < 0)\\n            {\\n                return;\\n            }\\n\\n            int bitInCurrNumber = ((currentNumber & (1 << bitNumber)) >> bitNumber);\\n            int opposite = (bitInCurrNumber + 1) % 2;\\n\\n            if (node.Next[bitInCurrNumber] == null && node.Next[opposite] == null)\\n            {\\n                res |= (currentNumber & ((1 << (bitNumber + 1)) - 1));\\n                return;\\n            }\\n\\n            if (node.Next[opposite] != null)\\n            {\\n                res |= (1 << bitNumber);\\n                Helper(node.Next[opposite], ref res, currentNumber, bitNumber - 1);\\n                return;\\n            }\\n\\n            Helper(node.Next[bitInCurrNumber], ref res, currentNumber, bitNumber - 1);\\n        }\\n\\n        public int FindMaximumXOR(int[] nums)\\n        {\\n            Trie trie = new Trie();\\n\\n            foreach (var num in nums)\\n            {\\n                trie.Insert(num);\\n            }\\n\\n            int res = 0;\\n\\n            foreach (var num in nums)\\n            {\\n                int candidate = 0;\\n                Helper(trie.Root, ref candidate, num, 31);\\n                res = Math.Max(res, candidate);\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404504,
                "title": "python-o-n-trie-solution-w-comments-and-explanations",
                "content": "The goal is to find 2 numbers in num that will produce the largest XOR, e.g. a number that has the most 1\\'s to the left in its binary representation.  We can do this by first building a trie that represents the binary form of the numbers in nums, then, for each num in nums, traverse the trie to find the number that will produce the largest XOR with it.\\n\\n```python\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        # need to know the largest binary representation\\n\\t\\t# bin prepends \\'0b\\', ignore\\n\\t\\tL = len(bin(max(nums))) - 2\\n\\n\\t\\t# preprocess step - left-pad zeros to ensure each number has L bits\\n\\t\\t# (x >> i) & 1 produces the bit at position i for number x\\n\\t\\t# x\\'s value is moved right by i bits, we & 1 to produce 0 or 1\\n\\t\\t# e.g., if L = 5, then 3 = [0, 0, 0, 1, 1], so the steps to get there are:\\n\\t\\t# (3 >> 4) & 1 = 0\\n\\t\\t# (3 >> 3) & 1 = 0\\n\\t\\t# (3 >> 2) & 1 = 0\\n\\t\\t# (3 >> 1) & 1 = 1\\n\\t\\t# (3 >> 0) & 1 = 1\\n\\t\\tnums_bits = [[(x >> i) & 1 for i in reversed(range(L))] for x in nums]\\n\\t\\troot = {}\\n\\t\\t# build the trie\\n\\t\\tfor num, bits in zip(nums, nums_bits):\\n\\t\\t\\tnode = root\\n\\t\\t\\tfor bit in bits:\\n\\t\\t\\t\\tnode = node.setdefault(bit, {})\\n\\t\\t\\tnode[\"#\"] = num\\n\\n\\t\\tmax_xor = 0\\n\\t\\tfor num, bits in zip(nums, nums_bits):\\n\\t\\t\\tnode = root\\n\\t\\t\\t# we want to find the node that will produce the largest XOR with num\\n\\t\\t\\tfor bit in bits:\\n\\t\\t\\t\\t# our goal is to find the opposite bit, e.g. bit = 0, we want 1\\n\\t\\t\\t\\t# this is our goal because we want as many 1\\'s as possible\\n\\t\\t\\t\\ttoggled_bit = 1 - bit\\n\\t\\t\\t\\tif toggled_bit in node:\\n\\t\\t\\t\\t\\tnode = node[toggled_bit]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnode = node[bit]\\n\\t\\t\\t# we\\'re at a leaf node, now we can do the XOR computation\\n\\t\\t\\tmax_xor = max(max_xor, node[\"#\"] ^ num)\\n\\n\\n        return max_xor\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```python\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        # need to know the largest binary representation\\n\\t\\t# bin prepends \\'0b\\', ignore\\n\\t\\tL = len(bin(max(nums))) - 2\\n\\n\\t\\t# preprocess step - left-pad zeros to ensure each number has L bits\\n\\t\\t# (x >> i) & 1 produces the bit at position i for number x\\n\\t\\t# x\\'s value is moved right by i bits, we & 1 to produce 0 or 1\\n\\t\\t# e.g., if L = 5, then 3 = [0, 0, 0, 1, 1], so the steps to get there are:\\n\\t\\t# (3 >> 4) & 1 = 0\\n\\t\\t# (3 >> 3) & 1 = 0\\n\\t\\t# (3 >> 2) & 1 = 0\\n\\t\\t# (3 >> 1) & 1 = 1\\n\\t\\t# (3 >> 0) & 1 = 1\\n\\t\\tnums_bits = [[(x >> i) & 1 for i in reversed(range(L))] for x in nums]\\n\\t\\troot = {}\\n\\t\\t# build the trie\\n\\t\\tfor num, bits in zip(nums, nums_bits):\\n\\t\\t\\tnode = root\\n\\t\\t\\tfor bit in bits:\\n\\t\\t\\t\\tnode = node.setdefault(bit, {})\\n\\t\\t\\tnode[\"#\"] = num\\n\\n\\t\\tmax_xor = 0\\n\\t\\tfor num, bits in zip(nums, nums_bits):\\n\\t\\t\\tnode = root\\n\\t\\t\\t# we want to find the node that will produce the largest XOR with num\\n\\t\\t\\tfor bit in bits:\\n\\t\\t\\t\\t# our goal is to find the opposite bit, e.g. bit = 0, we want 1\\n\\t\\t\\t\\t# this is our goal because we want as many 1\\'s as possible\\n\\t\\t\\t\\ttoggled_bit = 1 - bit\\n\\t\\t\\t\\tif toggled_bit in node:\\n\\t\\t\\t\\t\\tnode = node[toggled_bit]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnode = node[bit]\\n\\t\\t\\t# we\\'re at a leaf node, now we can do the XOR computation\\n\\t\\t\\tmax_xor = max(max_xor, node[\"#\"] ^ num)\\n\\n\\n        return max_xor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368265,
                "title": "trie-way-and-hashmap-way-detailed-explanation",
                "content": "**HashMap way (84ms)**\\nWe use hashmap to store first k bits of all numbers.\\nSuppose we already know the first k-1 bits max result is \"xxx\", then the next bit max can be \"xxx1\" or \"xxx0\". How do we know which one? Let\\'s suppose it is \"xxx1\", then XOR it with every item in the hashmap, if the result exists in hashmap, that means there exists some number \"a\" and \"b\" in the hashmap that makes \"xxx1 ^ a = b\", then we have:\\nxxx1^a=b \\n=> xxx1^a^a=b^a \\n=> xxx1=b^a \\n=> a^b = xxx1\\nthis means we can find some number \"a\" and \"b\" in the hashmap that XOR equals \"xxx1\". Then \"xxx1\" is the best value we can use for the next iteration. On the other hand if we we can\\'t find such \"a\" and \"b\" in hashmap, then we have to use \"xxx0\" for the next iteration. \\nIterate k from 32 to 1, for each new k, clean and rebuild the HashMap. We should be able to get the final result when k reaches one.\\n```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tres=0\\n\\tfor k in range(31,-1,-1):\\n\\t\\thash1=set()\\n\\t\\tres<<=1\\n\\t\\tmaybeNextRes=res+1\\n\\t\\tfor n in nums:\\n\\t\\t\\ttmp=n>>k\\n\\t\\t\\tif maybeNextRes^tmp in hash1:\\n\\t\\t\\t\\tres=maybeNextRes\\n\\t\\t\\t\\tbreak\\n\\t\\t\\thash1.add(tmp)\\n\\treturn res\\n```\\n\\n\\n**Trie Way (450ms)** \\nPut all numbers into a 0/1 binary tree. There are many threads already explaining how such tree looks like. But not many explained how to use it. You shouldn\\'t directly walk through this tree to find final result, because this will involve muti-possibilities and recursion. Instead, you pick up one number from the original list, comparing it against the tree to find the max XOR result of this number. Such kind of compare is single-roaded inside the tree and takes only O(32). It is not the final result though, it only represents the max XOR result of the picked number. But if you do so for every number, you can find the best result.\\nThis way can be further optimized to one-pass. You can find max XOR of a number when the tree is still building, no need to wait whole tree to finish building. Just find a number\\'s max XOR inside the half-build tree, and insert this number into the tree. If this number\\'s max XOR counterpart is not inside the tree yet, it must arrive later to the tree and XOR with it. You won\\'t miss it.\\n```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tT=lambda: collections.defaultdict(T)\\n\\troot=T()\\n\\tres=0\\n\\tfor n in nums:\\n\\t\\tcur1=cur2=root\\n\\t\\tcurRes=0\\n\\t\\tfor k in range(31,-1,-1):\\n\\t\\t\\tcurRes<<=1\\n\\t\\t\\tbit1=n>>k&1\\n\\t\\t\\tbit2=bit1^1\\n\\t\\t\\tcur1=cur1[bit1]\\n\\t\\t\\tif bit2 in cur2:\\n\\t\\t\\t\\tcurRes+=1\\n\\t\\t\\t\\tcur2=cur2[bit2]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur2=cur2[bit1]\\n\\t\\tres=max(res,curRes)\\n\\treturn res\\n```\\n\\nBoth hashmap way and tree way takes O(32n) time and O(n) space. The tree way is in theory faster and takes less memory. But in this problem, the hashmap way is much faster, possibly because of the tree manipulation overhead.",
                "solutionTags": [],
                "code": "```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tres=0\\n\\tfor k in range(31,-1,-1):\\n\\t\\thash1=set()\\n\\t\\tres<<=1\\n\\t\\tmaybeNextRes=res+1\\n\\t\\tfor n in nums:\\n\\t\\t\\ttmp=n>>k\\n\\t\\t\\tif maybeNextRes^tmp in hash1:\\n\\t\\t\\t\\tres=maybeNextRes\\n\\t\\t\\t\\tbreak\\n\\t\\t\\thash1.add(tmp)\\n\\treturn res\\n```\n```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tT=lambda: collections.defaultdict(T)\\n\\troot=T()\\n\\tres=0\\n\\tfor n in nums:\\n\\t\\tcur1=cur2=root\\n\\t\\tcurRes=0\\n\\t\\tfor k in range(31,-1,-1):\\n\\t\\t\\tcurRes<<=1\\n\\t\\t\\tbit1=n>>k&1\\n\\t\\t\\tbit2=bit1^1\\n\\t\\t\\tcur1=cur1[bit1]\\n\\t\\t\\tif bit2 in cur2:\\n\\t\\t\\t\\tcurRes+=1\\n\\t\\t\\t\\tcur2=cur2[bit2]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur2=cur2[bit1]\\n\\t\\tres=max(res,curRes)\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 357009,
                "title": "16ms-beats-99-runtime-and-100-memory-nlogn-binary-search",
                "content": "Find out the max xor number, we can come out:\\n1. Numbers with max bit 1 will be one of the max xor operand.\\n  Ex: 12, 86, 52, 58, 13, 63, 64, 18, 40, 73, 44, 94  ==> 64 (100-0000), 73(100-1001), 85(101-0110), 94(101-1110) have same max bit\\n2. If have max bit number, the possible max number will be filled with 1 in binary\\n  Ex: 64, 73, 85, 94, the possible max number is 127 (111-1111)\\n\\nFor (1), We can sort the array, find the numbers with max bit easily.\\nFor (2), We can use complement operand and binary search to find out the nearest number.\\n\\nSo, Iterate numbers found from (1), then use binary search to find nearest number by complement number.\\nthe algorithm will be NlogN\\n\\n![image](https://assets.leetcode.com/users/jiawei24/image_1565614768.png)\\n\\n\\n\\'\\'\\'\\n\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 3) {\\n            if (n <= 1) return 0;\\n            else if (n == 2) return nums[0] ^ nums[1];\\n        }\\n        sort(nums.begin(), nums.end());\\n        int mx = nums[n-1];\\n        int max_bit = 31;\\n        for (; max_bit >= 0; max_bit--)\\n            if (mx & (0x1 << max_bit))\\n                break;\\n\\n        long mask = (0x1L << (max_bit+1))-1;\\n        int max_bit_val = 0x1 << max_bit;\\n        int res = 0, last = INT_MAX;\\n        for (int i = n-1; i > 0; i--) {\\n            int v = nums[i];\\n            if ((v & max_bit_val) == 0) break;\\n            if (v == last) continue;\\n            int target = (~v) & mask;\\n            int l = 0, r = i-1;\\n            bool found = false;\\n            while (l+1 < r) {\\n                int mid = (l+r)/2;\\n                if (nums[mid] == target) {\\n                    return v ^ target;\\n                } else if (nums[mid] > target)\\n                    r = mid;\\n                else\\n                    l = mid;\\n            }\\n\\n            int mm = max(v ^ nums[l], v ^ nums[r]);\\n            res = max(res, mm);\\n            last = v;\\n        }\\n\\n        return res;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Find out the max xor number, we can come out:\\n1. Numbers with max bit 1 will be one of the max xor operand.\\n  Ex: 12, 86, 52, 58, 13, 63, 64, 18, 40, 73, 44, 94  ==> 64 (100-0000), 73(100-1001), 85(101-0110), 94(101-1110) have same max bit\\n2. If have max bit number, the possible max number will be filled with 1 in binary\\n  Ex: 64, 73, 85, 94, the possible max number is 127 (111-1111)\\n\\nFor (1), We can sort the array, find the numbers with max bit easily.\\nFor (2), We can use complement operand and binary search to find out the nearest number.\\n\\nSo, Iterate numbers found from (1), then use binary search to find nearest number by complement number.\\nthe algorithm will be NlogN\\n\\n![image](https://assets.leetcode.com/users/jiawei24/image_1565614768.png)\\n\\n\\n\\'\\'\\'\\n\\n    int findMaximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 3) {\\n            if (n <= 1) return 0;\\n            else if (n == 2) return nums[0] ^ nums[1];\\n        }\\n        sort(nums.begin(), nums.end());\\n        int mx = nums[n-1];\\n        int max_bit = 31;\\n        for (; max_bit >= 0; max_bit--)\\n            if (mx & (0x1 << max_bit))\\n                break;\\n\\n        long mask = (0x1L << (max_bit+1))-1;\\n        int max_bit_val = 0x1 << max_bit;\\n        int res = 0, last = INT_MAX;\\n        for (int i = n-1; i > 0; i--) {\\n            int v = nums[i];\\n            if ((v & max_bit_val) == 0) break;\\n            if (v == last) continue;\\n            int target = (~v) & mask;\\n            int l = 0, r = i-1;\\n            bool found = false;\\n            while (l+1 < r) {\\n                int mid = (l+r)/2;\\n                if (nums[mid] == target) {\\n                    return v ^ target;\\n                } else if (nums[mid] > target)\\n                    r = mid;\\n                else\\n                    l = mid;\\n            }\\n\\n            int mm = max(v ^ nums[l], v ^ nums[r]);\\n            res = max(res, mm);\\n            last = v;\\n        }\\n\\n        return res;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 319712,
                "title": "transparent-javascript-solution-with-trie",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaximumXOR = function(nums) {\\n    \\n    const trie = makeTrie(nums)\\n    \\n    let max = 0\\n    \\n    for (const num of nums) {\\n        max = Math.max(max, search(trie, num))\\n    }\\n    \\n    return max\\n};\\n\\nfunction makeTrie (nums) {\\n    \\n    const root = {}\\n    \\n    for (const num of nums) {\\n        let node = root\\n        for (let i = 30; i >= 0; i--) {\\n            const bit = (num >> i) & 1\\n            node[bit] = node[bit] || {}\\n            node = node[bit]\\n        }\\n    }\\n    \\n    return root\\n}\\n\\nfunction search (trie, num) {\\n    \\n    let xor = 0\\n    \\n    let node = trie    \\n    \\n    for (let i = 30; i >= 0; i--) {\\n        \\n        const bit = (num >> i) & 1\\n        \\n        if (node[1-bit]) {\\n            xor += 2 ** i\\n            node = node[1-bit]\\n        } else {\\n            node = node[bit]\\n        }\\n    }\\n    \\n    return xor\\n}",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaximumXOR = function(nums) {\\n    \\n    const trie = makeTrie(nums)\\n    \\n    let max = 0\\n    \\n    for (const num of nums) {\\n        max = Math.max(max, search(trie, num))\\n    }\\n    \\n    return max\\n};\\n\\nfunction makeTrie (nums) {\\n    \\n    const root = {}\\n    \\n    for (const num of nums) {\\n        let node = root\\n        for (let i = 30; i >= 0; i--) {\\n            const bit = (num >> i) & 1\\n            node[bit] = node[bit] || {}\\n            node = node[bit]\\n        }\\n    }\\n    \\n    return root\\n}\\n\\nfunction search (trie, num) {\\n    \\n    let xor = 0\\n    \\n    let node = trie    \\n    \\n    for (let i = 30; i >= 0; i--) {\\n        \\n        const bit = (num >> i) & 1\\n        \\n        if (node[1-bit]) {\\n            xor += 2 ** i\\n            node = node[1-bit]\\n        } else {\\n            node = node[bit]\\n        }\\n    }\\n    \\n    return xor\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 309683,
                "title": "recursive-in-place-c-solution-with-o-n-time-and-o-1-extra-space",
                "content": "* We can solve the problem if we have the numbers sorted and progressively choose the two parts (from a1 to a2, and from b1 to b2) with different 0/1 value from high to low bit. In fact, we do not need to sort all, but only the part that can contribute to the result.\\n* Use the original vector. No extra memory is needed except the recursion stack. \\n* beat 97% for time, 94% for memory.\\n```\\nclass Solution {\\npublic:\\n\\tint res = 0;\\n\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\tpartitionHelper(nums, 0, nums.size(), 0, nums.size(), 31);\\n\\t\\treturn res;\\n\\t}\\n\\tvoid partitionHelper(vector<int>& nums, int a1, int a2, int b1, int b2, int pos) {\\n\\t\\tif (a1 == a2 || b1 == b2) return;\\n\\t\\tif (pos == 0) {\\n\\t\\t\\tfor (int i = a1; i < a2; ++i) {\\n\\t\\t\\t\\tfor (int j = b1; j < b2; ++j) {\\n\\t\\t\\t\\t\\tres = max(res, nums[i] ^ nums[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// move the numbers with pos bit 1 to the front\\n\\t\\tint i = a1, j = a1;\\n\\t\\tfor (; i < a2; ++i) {\\n\\t\\t\\tif ((nums[i] >> pos) & 1) {\\n\\t\\t\\t\\tswap(nums[j++], nums[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// move the numbers with pos bit 0 to the back\\n\\t\\tint n = b2-1, m = n;\\n\\t\\tfor (; n >= b1; --n) {\\n\\t\\t\\tif (!(nums[n] >> pos & 1)) {\\n\\t\\t\\t\\tswap(nums[m--], nums[n]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (a1 == j && b1 == m+1 || a2 == j && b2 == m + 1) {\\n\\t\\t\\tpartitionHelper(nums, a1, a2, b1, b2, pos - 1);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tpartitionHelper(nums, a1, j, m + 1, b2, pos - 1);\\n\\t\\t\\tpartitionHelper(nums, j, a2, b1, m + 1, pos - 1);\\n\\t\\t}\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint res = 0;\\n\\tint findMaximumXOR(vector<int>& nums) {\\n\\t\\tpartitionHelper(nums, 0, nums.size(), 0, nums.size(), 31);\\n\\t\\treturn res;\\n\\t}\\n\\tvoid partitionHelper(vector<int>& nums, int a1, int a2, int b1, int b2, int pos) {\\n\\t\\tif (a1 == a2 || b1 == b2) return;\\n\\t\\tif (pos == 0) {\\n\\t\\t\\tfor (int i = a1; i < a2; ++i) {\\n\\t\\t\\t\\tfor (int j = b1; j < b2; ++j) {\\n\\t\\t\\t\\t\\tres = max(res, nums[i] ^ nums[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// move the numbers with pos bit 1 to the front\\n\\t\\tint i = a1, j = a1;\\n\\t\\tfor (; i < a2; ++i) {\\n\\t\\t\\tif ((nums[i] >> pos) & 1) {\\n\\t\\t\\t\\tswap(nums[j++], nums[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// move the numbers with pos bit 0 to the back\\n\\t\\tint n = b2-1, m = n;\\n\\t\\tfor (; n >= b1; --n) {\\n\\t\\t\\tif (!(nums[n] >> pos & 1)) {\\n\\t\\t\\t\\tswap(nums[m--], nums[n]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (a1 == j && b1 == m+1 || a2 == j && b2 == m + 1) {\\n\\t\\t\\tpartitionHelper(nums, a1, a2, b1, b2, pos - 1);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tpartitionHelper(nums, a1, j, m + 1, b2, pos - 1);\\n\\t\\t\\tpartitionHelper(nums, j, a2, b1, m + 1, pos - 1);\\n\\t\\t}\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227280,
                "title": "easy-java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int ans = 0, mask = 0;\\n        for (int x = 31; x >= 0; x--) {\\n            mask |= (1 << x);\\n            HashSet<Integer> set = new HashSet<>();\\n            int temp = ans | (1 << x);\\n            for (int i = 0; i < nums.length; i++) {\\n                int num = nums[i] & mask;\\n                if (set.contains(temp ^ num)) {\\n                    ans = temp;\\n                    break;\\n                }\\n                set.add(num);\\n            }\\n        }     \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        int ans = 0, mask = 0;\\n        for (int x = 31; x >= 0; x--) {\\n            mask |= (1 << x);\\n            HashSet<Integer> set = new HashSet<>();\\n            int temp = ans | (1 << x);\\n            for (int i = 0; i < nums.length; i++) {\\n                int num = nums[i] & mask;\\n                if (set.contains(temp ^ num)) {\\n                    ans = temp;\\n                    break;\\n                }\\n                set.add(num);\\n            }\\n        }     \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132580,
                "title": "python-trie-o-n",
                "content": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        root = {}\\n        tree = root\\n        output = float(\"-inf\")\\n        \\n        # Build N-ary tree\\n        for num in nums:\\n            binaryStr = format(num, \\'b\\').zfill(31)\\n            for bit in binaryStr:\\n                if tree.get(bit) == None:\\n                    tree[bit] = {}\\n            \\n                tree = tree[bit]\\n            \\n            tree[\"value\"] = num\\n            \\n            # Reset back to root\\n            tree = root\\n            \\n            # Search trie for possible new max\\n            for bit in binaryStr:\\n                if bit == \"0\" and tree.get(\"1\"):\\n                    tree = tree[\"1\"] \\n                elif bit == \"1\" and tree.get(\"0\"):\\n                    tree = tree[\"0\"]\\n                else:\\n                    tree = tree[bit]\\n            \\n            output = max(tree[\"value\"] ^ num, output)\\n            tree = root\\n        \\n        return output\\n            ",
                "solutionTags": [],
                "code": "class Solution:\\n    def findMaximumXOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        root = {}",
                "codeTag": "Java"
            },
            {
                "id": 91062,
                "title": "golang-solution-using-trie",
                "content": "The important thing to note is, we don't need to return a pair of indices of a result but just need a result of XOR.\\n\\nBecause a number of bits in integer is constant (in Go, leetcode has 32-bit integer environment), we can first build a Trie which has all possible bits (0 or 1) in each digit (from `31` to `0` th) among all elements in an array.\\n\\nThen we can again iterate through the array and for each element, we will traverse the Trie so that `XOR` of each digit should have maximum value. Obviously, the more significant bit has `1`, a result of `XOR` becomes bigger.\\n\\nI also recommend try to solve this variant as well. We need an additional trick to solve this.\\nhttp://www.geeksforgeeks.org/find-the-maximum-subarray-xor-in-a-given-array/\\n\\n```\\nfunc findMaximumXOR(nums []int) int {\\n    root := NewNode()\\n    \\n    // build trie\\n    for _, num := range nums {\\n        cur := root\\n        for i := 31; i >= 0; i-- {\\n            flag := (num >> uint(i)) & 1\\n            if cur.Children[flag] == nil {\\n                cur.Children[flag] = NewNode()\\n            }\\n            cur = cur.Children[flag]\\n        }\\n    }\\n    \\n    // search maximum\\n    max := 0\\n    for _, num := range nums {\\n        cur, val := root, 0\\n        for i := 31; i >= 0; i-- {\\n            flag := (num >> uint(i)) & 1\\n            switch {\\n            case flag == 1 && cur.Children[0] != nil, flag == 0 && cur.Children[1] != nil:\\n                val += 1 << uint(i)\\n                cur = cur.Children[1 & ^flag] // just reversing flag\\n            default:\\n                cur = cur.Children[flag]\\n            }\\n        }\\n        if val > max {\\n            max = val\\n        }\\n    }\\n    return max\\n}\\n\\ntype TNode struct {\\n    Children [2]*TNode\\n}\\n\\nfunc NewNode() *TNode {\\n    return &TNode{Children: [2]*TNode{nil, nil}}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findMaximumXOR(nums []int) int {\\n    root := NewNode()\\n    \\n    // build trie\\n    for _, num := range nums {\\n        cur := root\\n        for i := 31; i >= 0; i-- {\\n            flag := (num >> uint(i)) & 1\\n            if cur.Children[flag] == nil {\\n                cur.Children[flag] = NewNode()\\n            }\\n            cur = cur.Children[flag]\\n        }\\n    }\\n    \\n    // search maximum\\n    max := 0\\n    for _, num := range nums {\\n        cur, val := root, 0\\n        for i := 31; i >= 0; i-- {\\n            flag := (num >> uint(i)) & 1\\n            switch {\\n            case flag == 1 && cur.Children[0] != nil, flag == 0 && cur.Children[1] != nil:\\n                val += 1 << uint(i)\\n                cur = cur.Children[1 & ^flag] // just reversing flag\\n            default:\\n                cur = cur.Children[flag]\\n            }\\n        }\\n        if val > max {\\n            max = val\\n        }\\n    }\\n    return max\\n}\\n\\ntype TNode struct {\\n    Children [2]*TNode\\n}\\n\\nfunc NewNode() *TNode {\\n    return &TNode{Children: [2]*TNode{nil, nil}}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91093,
                "title": "java-o-n-recursion-solution-36ms",
                "content": "This solution only supports an input array with unique elements. You can easily achieve that by filtering the input array with hashset.\\n```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++) {\\n            left.add(nums[i]);\\n            right.add(nums[i]);\\n        }\\n        return helper(left, right, 1<<30);\\n        \\n    }\\n    public int helper(List<Integer> left, List<Integer> right, int bit) {\\n        if(left.size()==0||right.size()==0) return 0;\\n        if(left.size()==1||right.size()==1) {\\n            int max = 0;\\n            for(Integer l: left) {\\n                for(Integer r: right) {\\n                    max = Math.max(max, l^r);\\n                }\\n            }\\n            return max;\\n        }\\n        List<Integer> oneLeft = new ArrayList<>();\\n        List<Integer> zeroLeft = new ArrayList<>();\\n        List<Integer> oneRight = new ArrayList<>();\\n        List<Integer> zeroRight = new ArrayList<>();\\n        while((oneLeft.size()==0||zeroRight.size()==0)&&(oneRight.size()==0||zeroLeft.size()==0)&&bit!=0) {\\n            oneLeft = new ArrayList<>();\\n            zeroLeft = new ArrayList<>();\\n            oneRight = new ArrayList<>();\\n            zeroRight = new ArrayList<>();\\n            for(Integer i:left) {\\n                if((i&bit)==0) zeroLeft.add(i);\\n                else oneLeft.add(i);\\n            }\\n            for(Integer i:right) {\\n                if((i&bit)==0) zeroRight.add(i);\\n                else oneRight.add(i);\\n            }\\n            bit >>= 1;\\n        }\\n        return Math.max(helper(oneLeft, zeroRight, bit), helper(zeroLeft, oneRight, bit));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMaximumXOR(int[] nums) {\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++) {\\n            left.add(nums[i]);\\n            right.add(nums[i]);\\n        }\\n        return helper(left, right, 1<<30);\\n        \\n    }\\n    public int helper(List<Integer> left, List<Integer> right, int bit) {\\n        if(left.size()==0||right.size()==0) return 0;\\n        if(left.size()==1||right.size()==1) {\\n            int max = 0;\\n            for(Integer l: left) {\\n                for(Integer r: right) {\\n                    max = Math.max(max, l^r);\\n                }\\n            }\\n            return max;\\n        }\\n        List<Integer> oneLeft = new ArrayList<>();\\n        List<Integer> zeroLeft = new ArrayList<>();\\n        List<Integer> oneRight = new ArrayList<>();\\n        List<Integer> zeroRight = new ArrayList<>();\\n        while((oneLeft.size()==0||zeroRight.size()==0)&&(oneRight.size()==0||zeroLeft.size()==0)&&bit!=0) {\\n            oneLeft = new ArrayList<>();\\n            zeroLeft = new ArrayList<>();\\n            oneRight = new ArrayList<>();\\n            zeroRight = new ArrayList<>();\\n            for(Integer i:left) {\\n                if((i&bit)==0) zeroLeft.add(i);\\n                else oneLeft.add(i);\\n            }\\n            for(Integer i:right) {\\n                if((i&bit)==0) zeroRight.add(i);\\n                else oneRight.add(i);\\n            }\\n            bit >>= 1;\\n        }\\n        return Math.max(helper(oneLeft, zeroRight, bit), helper(zeroLeft, oneRight, bit));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91118,
                "title": "little-advice-about-the-problem-definition",
                "content": "I think maybe it's better to change the method declaration from\\n```\\nint findMaximumXOR(vector<int>& nums) {}\\n```\\nto\\n```\\nint findMaximumXOR(vector<unsigned int>& nums) {}\\n```\\nsince 0 <= a[i] < 2^32.",
                "solutionTags": [],
                "code": "```\\nint findMaximumXOR(vector<int>& nums) {}\\n```\n```\\nint findMaximumXOR(vector<unsigned int>& nums) {}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015029,
                "title": "striver-s-code-using-trie",
                "content": "# Complexity\\n- Time complexity : $$O(32*n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nstruct Node {\\n    Node* child[2];\\n\\n    bool containsKey(int bit) {\\n        return (child[bit] != NULL); // checks if this bit is present or not\\n    }\\n\\n    void put(int bit, Node* node) {\\n        child[bit] = node;\\n    }\\n\\n    Node* get(int bit) {\\n        return child[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\n\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    void insert(int num) {\\n        Node* node = root;\\n        for(int i=31 ; i>=0 ; i--) {\\n            int bit = (num>>i) & 1;\\n            if(!node->containsKey(bit)) {\\n                node->put(bit,new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n\\n    int getMax(int num) {\\n        Node* node = root;\\n        int maxNum = 0;\\n\\n        for(int i=31 ; i>=0 ; i--) {\\n            int bit = (num>>i) & 1;\\n            if(node->containsKey(1-bit)) {\\n                maxNum = maxNum | (1<<i);\\n                node = node->get(1-bit);\\n            }\\n            else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie;\\n        for(auto &ele:nums) {\\n            trie.insert(ele);\\n        }\\n\\n        int maxi = 0;\\n        for(auto &ele:nums) {\\n            maxi = max(maxi,trie.getMax(ele));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node {\\n    Node* child[2];\\n\\n    bool containsKey(int bit) {\\n        return (child[bit] != NULL); // checks if this bit is present or not\\n    }\\n\\n    void put(int bit, Node* node) {\\n        child[bit] = node;\\n    }\\n\\n    Node* get(int bit) {\\n        return child[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\n\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    void insert(int num) {\\n        Node* node = root;\\n        for(int i=31 ; i>=0 ; i--) {\\n            int bit = (num>>i) & 1;\\n            if(!node->containsKey(bit)) {\\n                node->put(bit,new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n\\n    int getMax(int num) {\\n        Node* node = root;\\n        int maxNum = 0;\\n\\n        for(int i=31 ; i>=0 ; i--) {\\n            int bit = (num>>i) & 1;\\n            if(node->containsKey(1-bit)) {\\n                maxNum = maxNum | (1<<i);\\n                node = node->get(1-bit);\\n            }\\n            else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie;\\n        for(auto &ele:nums) {\\n            trie.insert(ele);\\n        }\\n\\n        int maxi = 0;\\n        for(auto &ele:nums) {\\n            maxi = max(maxi,trie.getMax(ele));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965614,
                "title": "python-bitwise-solution",
                "content": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        try: l = int(log2(max(nums)))\\n        except: l = 1\\n\\n        mask, res = 0, 0\\n\\n        for i in range(l, -1, -1):\\n            mask |= 1 << i\\n            S = set(mask & num for num in nums)\\n            temp = res | 1 << i\\n\\n            for num in S:\\n                if num ^ temp in S:\\n                    res = temp\\n                    break\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaximumXOR(self, nums: List[int]) -> int:\\n        try: l = int(log2(max(nums)))\\n        except: l = 1\\n\\n        mask, res = 0, 0\\n\\n        for i in range(l, -1, -1):\\n            mask |= 1 << i\\n            S = set(mask & num for num in nums)\\n            temp = res | 1 << i\\n\\n            for num in S:\\n                if num ^ temp in S:\\n                    res = temp\\n                    break\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919546,
                "title": "c-trie-data-structure-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne approach to solve this problem is to use a trie data structure. A trie is a tree-like data structure that stores a set of strings. Each node in the trie represents a single character in a string, and the path from the root to a leaf node represents a complete string.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the maximum XOR of two numbers in the given array, we can use a trie to store the binary representation of each number. Then, we can iterate through the trie and for each node, we can check if there is a complementary node at the same depth (i.e., a node with a value that would result in a XOR of 1 when combined with the current node). If such a node exists, we can update the maximum XOR.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n * 32), where n is the number of integers in the input array nums.\\n\\nThis is because the first loop that inserts the binary representation of each number into the trie takes O(n) time, and the second loop that finds the maximum XOR takes O(n) time. Within each of these loops, there is an additional loop that iterates through the bits of each number, which takes O(32) time because there are 32 bits in an integer.\\n\\nTherefore, the overall time complexity is O(n * 32).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(n * 32), where n is the number of integers in the input array nums.\\n\\nThis is because the trie data structure used in this code stores one node for each bit of each number in the input array. Since there are n numbers in the input array and each number has 32 bits, the total number of nodes in the trie is n * 32.\\n\\nTherefore, the space complexity of this code is O(n * 32).\\n# Code\\n```\\npublic class Solution {\\n    public class TrieNode\\n    {\\n        public TrieNode[] children;\\n        public TrieNode()\\n        {\\n            children = new TrieNode[2];\\n        }\\n    } \\n    public int FindMaximumXOR(int[] nums)\\n    {\\n        TrieNode root = new TrieNode();\\n\\n        // Insert the binary representation of each number into the trie\\n        foreach (int num in nums)\\n        {\\n            TrieNode curr = root;\\n            for (int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num >> i) & 1;\\n                if (curr.children[bit] == null)\\n                {\\n                    curr.children[bit] = new TrieNode();\\n                }\\n                curr = curr.children[bit];\\n            }\\n        }\\n\\n        int maxXOR = int.MinValue;\\n\\n        // Find the maximum XOR by iterating through the trie and checking for complementary nodes\\n        foreach (int num in nums)\\n        {\\n            TrieNode curr = root;\\n            int currXOR = 0;\\n            for (int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num >> i) & 1;\\n                if (curr.children[bit ^ 1] != null)\\n                {\\n                    currXOR += (1 << i);\\n                    curr = curr.children[bit ^ 1];\\n                }\\n                else\\n                {\\n                    curr = curr.children[bit];\\n                }\\n            }\\n            maxXOR = Math.Max(maxXOR, currXOR);\\n        }\\n\\n        return maxXOR;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public class TrieNode\\n    {\\n        public TrieNode[] children;\\n        public TrieNode()\\n        {\\n            children = new TrieNode[2];\\n        }\\n    } \\n    public int FindMaximumXOR(int[] nums)\\n    {\\n        TrieNode root = new TrieNode();\\n\\n        // Insert the binary representation of each number into the trie\\n        foreach (int num in nums)\\n        {\\n            TrieNode curr = root;\\n            for (int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num >> i) & 1;\\n                if (curr.children[bit] == null)\\n                {\\n                    curr.children[bit] = new TrieNode();\\n                }\\n                curr = curr.children[bit];\\n            }\\n        }\\n\\n        int maxXOR = int.MinValue;\\n\\n        // Find the maximum XOR by iterating through the trie and checking for complementary nodes\\n        foreach (int num in nums)\\n        {\\n            TrieNode curr = root;\\n            int currXOR = 0;\\n            for (int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num >> i) & 1;\\n                if (curr.children[bit ^ 1] != null)\\n                {\\n                    currXOR += (1 << i);\\n                    curr = curr.children[bit ^ 1];\\n                }\\n                else\\n                {\\n                    curr = curr.children[bit];\\n                }\\n            }\\n            maxXOR = Math.Max(maxXOR, currXOR);\\n        }\\n\\n        return maxXOR;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841376,
                "title": "simple-trie-solution",
                "content": "```\\nclass Node{\\npublic:\\n    Node *links[2];\\n    bool containsKey(int n){\\n        return (links[n]!=NULL);\\n    }\\n    \\n    Node* get(int n){\\n        return links[n];\\n    }\\n    void put(int n, Node *node){\\n        links[n]=node;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node *root;\\npublic:\\n    Trie(){\\n        root=new Node();\\n    }\\npublic:\\n    void insert(int num){\\n        Node* node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit, new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\npublic:\\n    int getMax(int num){\\n        Node* node=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;            \\n            if(node->containsKey(1-bit)){\\n                maxNum=maxNum|(1<<i);\\n                node=node->get(1-bit);\\n            }\\n            else{\\n                node=node->get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }    \\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie;\\n        for(auto &x:nums){\\n            trie.insert(x);\\n        }\\n        int maxi=0;\\n        for(auto &x:nums){\\n            maxi=max(maxi,trie.getMax(x));\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie trie;\\n        for(auto &x:nums){\\n            trie.insert(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2460606,
                "title": "a-detailed-explanation-feel-free-to-ask-any-doubt-please-upvote-me",
                "content": "\\nThere are Four basic step to do\\n\\n1. First we\\'ve to make **class** node which store left node (when we get 0 we\\'ll make left node )or right node(when we get 1 we\\'ll make right node ).\\n2. Then we make **insert** function to make trie which store each bit(bit find by shift operator (for example ---\\n           1. we get n= 1 which is 0001\\n           2.then we find mask of that which is[1<<i] let i is 4 so 1 is left shifted by 4 time (1<<4) then no                     is 1000\\n          3.AND of mask and number will give first bit 0001 & 1000 = 0 we get 0 we make left node)\\n          on second iteration  mask will 0100 this is also give 0. again on third iteration mask will 0010 this is also give 0 on fourth iteration mask will 0001 will give 1 when we get 1 on MSB we make right node and update the temperory  node ) by which we will get all bit node contain in number .\\n3.  Then we make  **maxXorPairHelper** Function  which help us to find maxium xor for given Number , number  MSB bit is 1 then we treverse in left to find 0  if MSB is 1 then we find treverse in right to get MSB digit 1(because same bit xor will give 0 or and diffrent bit will give 1).\\n4.  And in the last  **findMaximumXOR** function use insert or maxXorPairhelper function to give use maximum xor in vector.\\n\\n```\\nclass node {\\npublic:\\n\\tint data;\\n\\tnode* left;\\n\\tnode* right;\\n\\tnode() {\\n\\t\\tleft = right = NULL;\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    node *root =new node();\\n    //for insertion in trie datastructure\\n    void insert(int n) {\\n\\t\\tnode* temp = root;\\n\\t\\tfor (int i = 31; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tint bit = (n & (1 << i)) ?  1 : 0; \\n\\t\\t\\tif (bit == 1) {\\n\\t\\t\\t\\tif (!temp->right) {\\n\\t\\t\\t\\t\\ttemp->right = new node();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (!temp->left) {\\n\\t\\t\\t\\t\\ttemp->left = new node();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// after inserting each bit of number in trie then we fill data with that\\n\\t\\ttemp->data = n;\\n\\t}\\n    \\tint maxXorPairHelper(int n) {\\n\\t\\tnode* temp = root;\\n\\t\\tfor (int i = 31 ; i >= 0 ; i--) {\\n\\t\\t\\tint bit = (n & (1 << i)) ? 1 : 0;\\n\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\tif (temp->right) {\\n\\t\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (temp->left) {\\n\\t\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn temp->data ^ n;\\n\\t}\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n       \\tint ans = INT_MIN;\\n\\t\\tfor (int i = 0; i < nums.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tinsert(nums[i]);\\n\\t\\t\\tint t = maxXorPairHelper(nums[i]);\\n\\t\\t\\tans = max(ans, t);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t} \\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass node {\\npublic:\\n\\tint data;\\n\\tnode* left;\\n\\tnode* right;\\n\\tnode() {\\n\\t\\tleft = right = NULL;\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    node *root =new node();\\n    //for insertion in trie datastructure\\n    void insert(int n) {\\n\\t\\tnode* temp = root;\\n\\t\\tfor (int i = 31; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tint bit = (n & (1 << i)) ?  1 : 0; \\n\\t\\t\\tif (bit == 1) {\\n\\t\\t\\t\\tif (!temp->right) {\\n\\t\\t\\t\\t\\ttemp->right = new node();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (!temp->left) {\\n\\t\\t\\t\\t\\ttemp->left = new node();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// after inserting each bit of number in trie then we fill data with that\\n\\t\\ttemp->data = n;\\n\\t}\\n    \\tint maxXorPairHelper(int n) {\\n\\t\\tnode* temp = root;\\n\\t\\tfor (int i = 31 ; i >= 0 ; i--) {\\n\\t\\t\\tint bit = (n & (1 << i)) ? 1 : 0;\\n\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\tif (temp->right) {\\n\\t\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (temp->left) {\\n\\t\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn temp->data ^ n;\\n\\t}\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n       \\tint ans = INT_MIN;\\n\\t\\tfor (int i = 0; i < nums.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tinsert(nums[i]);\\n\\t\\t\\tint t = maxXorPairHelper(nums[i]);\\n\\t\\t\\tans = max(ans, t);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360467,
                "title": "solution-using-bit-manipulation-and-trie-in-java-o-n",
                "content": "* main trick is to create a trie of binary repesentation of every no in the array \\n```\\nclass Node {\\n    Node[] links;\\n    \\n    Node(){\\n        links = new Node[2];\\n    }\\n    \\n    boolean containsKey(int idx){\\n        return links[idx] != null;\\n    }\\n    \\n    Node get(int idx){\\n        return links[idx];\\n    }\\n    \\n    void put(int idx, Node node){\\n        links[idx] = node;\\n    }\\n}\\n\\nclass Trie{\\n    Node root;\\n    \\n    Trie(){\\n        root = new Node();\\n    }\\n    \\n    public void insert(int n){\\n        Node curr = root;\\n        for(int i = 31; i >= 0 ; i--){\\n            int bit = getBit(n, i);\\n            if(!curr.containsKey(bit)){\\n                curr.put(bit, new Node());\\n            }\\n            curr = curr.get(bit);\\n        }\\n    }\\n    \\n   public int getMax(int x){\\n        Node curr = root;\\n        int res = 0;\\n        for(int i = 31; i >= 0; i--){\\n            int bit = getBit(x, i);\\n            int reqBit = 1 - bit;\\n            if(curr.containsKey(reqBit)){\\n                res = res | (1 << i);\\n                curr = curr.get(reqBit);\\n            }else\\n                curr = curr.get(bit);\\n        }\\n        return res;\\n    }    \\n    \\n    private int getBit(int n, int i){\\n        return ((n >> i) & 1);\\n    }  \\n}\\n\\nclass Solution {\\n    Trie trie;\\n    \\n    Solution(){\\n        trie = new Trie();\\n    }\\n              \\n    public int findMaximumXOR(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int num : nums){\\n            trie.insert(num);\\n        }\\n        \\n        for(int num: nums){\\n            max = Math.max(max, trie.getMax(num));\\n        }\\n        return max;\\n    }       \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    Node[] links;\\n    \\n    Node(){\\n        links = new Node[2];\\n    }\\n    \\n    boolean containsKey(int idx){\\n        return links[idx] != null;\\n    }\\n    \\n    Node get(int idx){\\n        return links[idx];\\n    }\\n    \\n    void put(int idx, Node node){\\n        links[idx] = node;\\n    }\\n}\\n\\nclass Trie{\\n    Node root;\\n    \\n    Trie(){\\n        root = new Node();\\n    }\\n    \\n    public void insert(int n){\\n        Node curr = root;\\n        for(int i = 31; i >= 0 ; i--){\\n            int bit = getBit(n, i);\\n            if(!curr.containsKey(bit)){\\n                curr.put(bit, new Node());\\n            }\\n            curr = curr.get(bit);\\n        }\\n    }\\n    \\n   public int getMax(int x){\\n        Node curr = root;\\n        int res = 0;\\n        for(int i = 31; i >= 0; i--){\\n            int bit = getBit(x, i);\\n            int reqBit = 1 - bit;\\n            if(curr.containsKey(reqBit)){\\n                res = res | (1 << i);\\n                curr = curr.get(reqBit);\\n            }else\\n                curr = curr.get(bit);\\n        }\\n        return res;\\n    }    \\n    \\n    private int getBit(int n, int i){\\n        return ((n >> i) & 1);\\n    }  \\n}\\n\\nclass Solution {\\n    Trie trie;\\n    \\n    Solution(){\\n        trie = new Trie();\\n    }\\n              \\n    public int findMaximumXOR(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int num : nums){\\n            trie.insert(num);\\n        }\\n        \\n        for(int num: nums){\\n            max = Math.max(max, trie.getMax(num));\\n        }\\n        return max;\\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335682,
                "title": "using-trie-c-please-upvote-if-you-like",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n      Node*links[2];\\n      bool containsKey(int bit){\\n          return (links[bit]!=NULL);\\n      }\\n      Node * get(int bit){\\n          return links[bit];      \\n        }\\n    void put(int bit , Node *node){\\n        links[bit] = node;\\n    }\\n};\\nclass Trie{\\n    \\nprivate :\\n    Node * root;\\npublic :\\n    Trie(){\\n       root =new Node() ;\\n    }\\npublic :\\n    void insert(int num){\\n        Node * node = root ;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num >> i) & 1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\npublic : \\n    int getMax(int num){\\n        Node * node = root;\\n        int maxi =  0;\\n        for(int i = 31;i >=0 ;i--){\\n            int bit = (num >> i) & 1;\\n            if(node->containsKey(!bit)){\\n                maxi = maxi | (1<<i);\\n                node = node->get(!bit);\\n            }else{\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxi;\\n    }\\n    \\n};\\nint findMaximumXOR(vector<int>& arr1) {\\n      Trie trie;\\n    for(auto &it :arr1){\\n        trie.insert(it);\\n    }\\n    \\n    int maxim = 0 ;\\n    for(auto  &it : arr1){\\n      maxim = max(maxim , trie.getMax(it));\\n    }\\n    return maxim;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n      Node*links[2];\\n      bool containsKey(int bit){\\n          return (links[bit]!=NULL);\\n      }\\n      Node * get(int bit){\\n          return links[bit];      \\n        }\\n    void put(int bit , Node *node){\\n        links[bit] = node;\\n    }\\n};\\nclass Trie{\\n    \\nprivate :\\n    Node * root;\\npublic :\\n    Trie(){\\n       root =new Node() ;\\n    }\\npublic :\\n    void insert(int num){\\n        Node * node = root ;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num >> i) & 1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\npublic : \\n    int getMax(int num){\\n        Node * node = root;\\n        int maxi =  0;\\n        for(int i = 31;i >=0 ;i--){\\n            int bit = (num >> i) & 1;\\n            if(node->containsKey(!bit)){\\n                maxi = maxi | (1<<i);\\n                node = node->get(!bit);\\n            }else{\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxi;\\n    }\\n    \\n};\\nint findMaximumXOR(vector<int>& arr1) {\\n      Trie trie;\\n    for(auto &it :arr1){\\n        trie.insert(it);\\n    }\\n    \\n    int maxim = 0 ;\\n    for(auto  &it : arr1){\\n      maxim = max(maxim , trie.getMax(it));\\n    }\\n    return maxim;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306272,
                "title": "c-solution-trie-with-detailed-explanation",
                "content": "```\\nclass TrieNode\\n{\\npublic:\\n    TrieNode* child[2];\\n};\\n\\nclass BitWiseTrie\\n{\\npublic:\\n    TrieNode* root;\\n    \\n    BitWiseTrie()\\n    {\\n        root = new TrieNode();\\n    }\\n    \\n    // O(L) = O(32) = O(1)\\n    void insert(int num)\\n    {\\n        int currBit = 0;\\n        TrieNode* currNode = root;       \\n        \\n        for (int i = 31; i >= 0; i--)\\n        {\\n            // Right shift i times to move the i-th bit to the leftmost position\\n            // &1 --> get the bit value\\n            currBit = (num >> i) & 1;\\n            \\n            if (currNode->child[currBit] == nullptr)\\n            {\\n                currNode->child[currBit] = new TrieNode();\\n            }\\n            \\n            currNode = currNode->child[currBit];\\n        }\\n    }\\n    \\n    // O(L) = O(32) = O(1)\\n    int findMaxXOR(int num)\\n    {\\n        int maxXOR = 0;\\n        int currBit = 0;\\n        TrieNode* currNode = root;  \\n        \\n        for (int i = 31; i >= 0; i--)\\n        {\\n            // Right shift i to move the i-th bit to the leftmost position\\n            // &1 --> get the bit value\\n            currBit = (num >> i) & 1;\\n            \\n            // Opposite bit exists --> XOR = 1\\n            if (currNode->child[!currBit])\\n            {\\n                // Move the resulting 1 to the i-th position\\n                // by left shifting i \\n                maxXOR += (1 << i);\\n                \\n                // Move forward to the opposite-bit node\\n                currNode = currNode->child[!currBit];\\n            }\\n            // Opposite bit doesn\\'t exist\\n            else\\n            {\\n                // Move forward to the same-bit node\\n                currNode = currNode->child[currBit];\\n            }\\n        }\\n        \\n        return maxXOR;\\n    }\\n};\\n\\nclass Solution \\n{\\npublic:\\n    // T = O(N*L + N*L) = O(N*32 + N*32) = O(N)\\n    // S = O(2^L) = O(2^32) = O(1)\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        // Insert each number as binary number to the trie\\n        BitWiseTrie trie;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            trie.insert(nums[i]);\\n        }\\n        \\n        // For each number, find its max XOR \\n        int maxXOR = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            maxXOR = max(maxXOR, trie.findMaxXOR(nums[i]));\\n        }\\n        \\n        // Return the global max XOR\\n        return maxXOR;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode\\n{\\npublic:\\n    TrieNode* child[2];\\n};\\n\\nclass BitWiseTrie\\n{\\npublic:\\n    TrieNode* root;\\n    \\n    BitWiseTrie()\\n    {\\n        root = new TrieNode();\\n    }\\n    \\n    // O(L) = O(32) = O(1)\\n    void insert(int num)\\n    {\\n        int currBit = 0;\\n        TrieNode* currNode = root;       \\n        \\n        for (int i = 31; i >= 0; i--)\\n        {\\n            // Right shift i times to move the i-th bit to the leftmost position\\n            // &1 --> get the bit value\\n            currBit = (num >> i) & 1;\\n            \\n            if (currNode->child[currBit] == nullptr)\\n            {\\n                currNode->child[currBit] = new TrieNode();\\n            }\\n            \\n            currNode = currNode->child[currBit];\\n        }\\n    }\\n    \\n    // O(L) = O(32) = O(1)\\n    int findMaxXOR(int num)\\n    {\\n        int maxXOR = 0;\\n        int currBit = 0;\\n        TrieNode* currNode = root;  \\n        \\n        for (int i = 31; i >= 0; i--)\\n        {\\n            // Right shift i to move the i-th bit to the leftmost position\\n            // &1 --> get the bit value\\n            currBit = (num >> i) & 1;\\n            \\n            // Opposite bit exists --> XOR = 1\\n            if (currNode->child[!currBit])\\n            {\\n                // Move the resulting 1 to the i-th position\\n                // by left shifting i \\n                maxXOR += (1 << i);\\n                \\n                // Move forward to the opposite-bit node\\n                currNode = currNode->child[!currBit];\\n            }\\n            // Opposite bit doesn\\'t exist\\n            else\\n            {\\n                // Move forward to the same-bit node\\n                currNode = currNode->child[currBit];\\n            }\\n        }\\n        \\n        return maxXOR;\\n    }\\n};\\n\\nclass Solution \\n{\\npublic:\\n    // T = O(N*L + N*L) = O(N*32 + N*32) = O(N)\\n    // S = O(2^L) = O(2^32) = O(1)\\n    int findMaximumXOR(vector<int>& nums) \\n    {\\n        // Insert each number as binary number to the trie\\n        BitWiseTrie trie;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            trie.insert(nums[i]);\\n        }\\n        \\n        // For each number, find its max XOR \\n        int maxXOR = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            maxXOR = max(maxXOR, trie.findMaxXOR(nums[i]));\\n        }\\n        \\n        // Return the global max XOR\\n        return maxXOR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302636,
                "title": "python-trie-solution",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, string):\\n        cur = self.root\\n        for word in string:\\n            if word not in cur.children:\\n                cur.children[word] = TrieNode()\\n            cur = cur.children[word]\\n            \\n    def search(self, string):\\n        self.binary = {\\'1\\':\\'0\\', \\'0\\':\\'1\\'}\\n        cur = self.root\\n        temp = \\'\\'\\n        for word in string:\\n            if not cur.children:\\n                break\\n            \\n            if self.binary[word] in cur.children:\\n                cur = cur.children[self.binary[word]]\\n                temp += self.binary[word]\\n            \\n            else:\\n                cur = cur.children[word]\\n                temp += word\\n        \\n        \\n        return int(temp, 2) if temp else int(string, 2)\\n        \\n\\nclass Solution:\\n    def findMaximumXOR(self, num):\\n        trie = Trie()\\n        length = len(bin(max(num))[2:])\\n        ANS = float(\"-inf\")\\n        for n in num:\\n            binary = bin(n)[2:]\\n            binary = (length - len(binary))*\\'0\\' + binary\\n            ANS = max(ANS, n ^ trie.search(binary)) \\n            trie.insert(binary)\\n        \\n        return ANS\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, string):\\n        cur = self.root\\n        for word in string:\\n            if word not in cur.children:\\n                cur.children[word] = TrieNode()\\n            cur = cur.children[word]\\n            \\n    def search(self, string):\\n        self.binary = {\\'1\\':\\'0\\', \\'0\\':\\'1\\'}\\n        cur = self.root\\n        temp = \\'\\'\\n        for word in string:\\n            if not cur.children:\\n                break\\n            \\n            if self.binary[word] in cur.children:\\n                cur = cur.children[self.binary[word]]\\n                temp += self.binary[word]\\n            \\n            else:\\n                cur = cur.children[word]\\n                temp += word\\n        \\n        \\n        return int(temp, 2) if temp else int(string, 2)\\n        \\n\\nclass Solution:\\n    def findMaximumXOR(self, num):\\n        trie = Trie()\\n        length = len(bin(max(num))[2:])\\n        ANS = float(\"-inf\")\\n        for n in num:\\n            binary = bin(n)[2:]\\n            binary = (length - len(binary))*\\'0\\' + binary\\n            ANS = max(ANS, n ^ trie.search(binary)) \\n            trie.insert(binary)\\n        \\n        return ANS\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287172,
                "title": "70-tc-and-50-sc-easy-python-solution-with-clear-approach",
                "content": "1. Insert every num in the tree, and make sure that they have equal number of bits, with leading zeros.\\n2. Then try every num, and find what will be the max xor of it with any other num in the array. And come up with the max xor of all.\\n3. And thats done, like, if the current digit is 1, chech if 0 is avlbl at that place in the trie, and vice versa. If it is, the xor will have 1 at that bit, else 0.\\n```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tclass Trie:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = dict()\\n\\t\\tdef insert(self, s):\\n\\t\\t\\tc = self.root\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif(i not in c):\\n\\t\\t\\t\\t\\tc[i] = dict() \\n\\t\\t\\t\\tc = c[i]\\n\\t\\t\\n\\tt = Trie()\\n\\textra = \\'\\'.join([\\'0\\'] * 31)\\n\\tfor num in nums:\\n\\t\\tb = (extra + bin(num)[2:])[-31:]\\n\\t\\tt.insert(b)\\n\\tans = 0\\n\\tfor num in nums:\\n\\t\\tb = (extra + bin(num)[2:])[-31:]\\n\\t\\tc = t.root\\n\\t\\ttemp = 0\\n\\t\\tfor d in b:\\n\\t\\t\\tif(d == \"1\" and \"0\" in c):\\n\\t\\t\\t\\ttemp = 2*temp + 1\\n\\t\\t\\t\\tc = c[\"0\"]\\n\\t\\t\\telif(d == \"0\" and \"1\" in c):\\n\\t\\t\\t\\ttemp = 2*temp + 1\\n\\t\\t\\t\\tc = c[\"1\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tc = c[d]\\n\\t\\t\\t\\ttemp *= 2\\n\\t\\tans = max(temp, ans)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\ndef findMaximumXOR(self, nums: List[int]) -> int:\\n\\tclass Trie:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = dict()\\n\\t\\tdef insert(self, s):\\n\\t\\t\\tc = self.root\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif(i not in c):\\n\\t\\t\\t\\t\\tc[i] = dict() \\n\\t\\t\\t\\tc = c[i]\\n\\t\\t\\n\\tt = Trie()\\n\\textra = \\'\\'.join([\\'0\\'] * 31)\\n\\tfor num in nums:\\n\\t\\tb = (extra + bin(num)[2:])[-31:]\\n\\t\\tt.insert(b)\\n\\tans = 0\\n\\tfor num in nums:\\n\\t\\tb = (extra + bin(num)[2:])[-31:]\\n\\t\\tc = t.root\\n\\t\\ttemp = 0\\n\\t\\tfor d in b:\\n\\t\\t\\tif(d == \"1\" and \"0\" in c):\\n\\t\\t\\t\\ttemp = 2*temp + 1\\n\\t\\t\\t\\tc = c[\"0\"]\\n\\t\\t\\telif(d == \"0\" and \"1\" in c):\\n\\t\\t\\t\\ttemp = 2*temp + 1\\n\\t\\t\\t\\tc = c[\"1\"]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tc = c[d]\\n\\t\\t\\t\\ttemp *= 2\\n\\t\\tans = max(temp, ans)\\n\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265321,
                "title": "cpp-easy-soln-trie-solution-with-class-faster-then-90",
                "content": "```\\nstruct Node{\\n  Node* links[2];\\n    \\n    bool iscontains(int bit)\\n    {\\n        return links[bit]!=NULL;\\n    }\\n    \\n    void put(int bit,Node* node)\\n    {\\n        links[bit]=node;\\n    }\\n    \\n    Node* get(int bit)\\n    {\\n        return links[bit];\\n    }\\n        \\n};\\nclass Trie{\\n  private: Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    \\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        \\n        for(int i=31;i>=0;--i)\\n        {\\n            int bit=num>>i &1;\\n            if(!node->iscontains(bit))\\n                node->put(bit,new Node());\\n            \\n            node=node->get(bit);\\n        }\\n    }\\n    int getmax(int num)\\n    {\\n        Node* node=root;\\n        int mx=0;\\n        for(int i=31;i>=0;--i)\\n        {\\n            int bit=num>>i &1;\\n            if(node->iscontains(1-bit))\\n            {\\n                mx=mx|1<<i;\\n                node=node->get(1-bit);\\n            }\\n            else\\n            node=node->get(bit);\\n        }\\n        return mx;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie t;\\n        for(auto &it:nums)\\n            t.insert(it);\\n        \\n        int mx=0;\\n        \\n        for(auto &it:nums)\\n            mx=max(mx,t.getmax(it));\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n  Node* links[2];\\n    \\n    bool iscontains(int bit)\\n    {\\n        return links[bit]!=NULL;\\n    }\\n    \\n    void put(int bit,Node* node)\\n    {\\n        links[bit]=node;\\n    }\\n    \\n    Node* get(int bit)\\n    {\\n        return links[bit];\\n    }\\n        \\n};\\nclass Trie{\\n  private: Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    \\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        \\n        for(int i=31;i>=0;--i)\\n        {\\n            int bit=num>>i &1;\\n            if(!node->iscontains(bit))\\n                node->put(bit,new Node());\\n            \\n            node=node->get(bit);\\n        }\\n    }\\n    int getmax(int num)\\n    {\\n        Node* node=root;\\n        int mx=0;\\n        for(int i=31;i>=0;--i)\\n        {\\n            int bit=num>>i &1;\\n            if(node->iscontains(1-bit))\\n            {\\n                mx=mx|1<<i;\\n                node=node->get(1-bit);\\n            }\\n            else\\n            node=node->get(bit);\\n        }\\n        return mx;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie t;\\n        for(auto &it:nums)\\n            t.insert(it);\\n        \\n        int mx=0;\\n        \\n        for(auto &it:nums)\\n            mx=max(mx,t.getmax(it));\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204201,
                "title": "brute-force-with-trie",
                "content": "create a trie of all the numbers in left to right binary way i.e for num =6 it\\'ll be 1->1->0 once all the element are inserted re-iterated the same array and due to xor property check the opposite sign of whatever you are currently seeing in trie to get `1` \\n\\n\\n```\\nstruct TrieNode{\\n    TrieNode* link[2];\\n    bool end;\\n    bool contains_key(int key)\\n    {\\n        return(link[key]!=NULL);\\n    }\\n\\n     TrieNode* get(int bit)\\n    {\\n        return link[bit];\\n    }\\n\\n    void set(int bit)\\n    {\\n        link[bit] = new TrieNode();\\n    }\\n    \\n};\\n\\n\\nclass Trie{\\n    TrieNode* node;\\n    public:\\n        Trie(){\\n            node = new TrieNode();\\n        }\\n    \\n        void insert(int num)\\n        {\\n            TrieNode* curr = node;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int bit = (num>>i) & 1;\\n                if(!curr->contains_key(bit)) curr->set(bit);\\n                curr = curr->link[bit];\\n            }\\n            curr->end = true;\\n        }\\n\\n        int find_max(int num)\\n        {\\n            TrieNode* curr = node;\\n            int res  = 0;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int bit = (num>>i) & 1;\\n                if(curr->get(1-bit))\\n                {\\n                    res = res | (1<<i);\\n                    curr = curr->link[1-bit];\\n                }\\n                else\\n                    curr = curr->link[bit];\\n\\n            }\\n            return res;\\n\\n        }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie *node = new Trie();\\n        for(auto i: nums)\\n        {\\n            node->insert(i);\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i:nums)\\n        {\\n            res = max(res,node->find_max(i));\\n        }\\n        \\n        return res;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct TrieNode{\\n    TrieNode* link[2];\\n    bool end;\\n    bool contains_key(int key)\\n    {\\n        return(link[key]!=NULL);\\n    }\\n\\n     TrieNode* get(int bit)\\n    {\\n        return link[bit];\\n    }\\n\\n    void set(int bit)\\n    {\\n        link[bit] = new TrieNode();\\n    }\\n    \\n};\\n\\n\\nclass Trie{\\n    TrieNode* node;\\n    public:\\n        Trie(){\\n            node = new TrieNode();\\n        }\\n    \\n        void insert(int num)\\n        {\\n            TrieNode* curr = node;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int bit = (num>>i) & 1;\\n                if(!curr->contains_key(bit)) curr->set(bit);\\n                curr = curr->link[bit];\\n            }\\n            curr->end = true;\\n        }\\n\\n        int find_max(int num)\\n        {\\n            TrieNode* curr = node;\\n            int res  = 0;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int bit = (num>>i) & 1;\\n                if(curr->get(1-bit))\\n                {\\n                    res = res | (1<<i);\\n                    curr = curr->link[1-bit];\\n                }\\n                else\\n                    curr = curr->link[bit];\\n\\n            }\\n            return res;\\n\\n        }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findMaximumXOR(vector<int>& nums) {\\n        Trie *node = new Trie();\\n        for(auto i: nums)\\n        {\\n            node->insert(i);\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i:nums)\\n        {\\n            res = max(res,node->find_max(i));\\n        }\\n        \\n        return res;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564760,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1564659,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1567512,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1857574,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1568717,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1566416,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1565992,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1957377,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1718702,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1569550,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1564760,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1564659,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1567512,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1857574,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1568717,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1566416,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1565992,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1957377,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1718702,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1569550,
                "content": [
                    {
                        "username": "Petersburg",
                        "content": "Feels like a hard...."
                    },
                    {
                        "username": "cdz__29",
                        "content": "definitely does"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I had absolutely no idea how to even approach this... how are we expected to do this exactly?"
                    },
                    {
                        "username": "C0deBlooded",
                        "content": "Am I the only one who thinks, it should be in Hard category?"
                    },
                    {
                        "username": "shivanigam",
                        "content": "wish this question had only 41 testcases\\n"
                    },
                    {
                        "username": "XArceus0406",
                        "content": "Feels Like hard.\\nIf Any one Have any Explaination for this Please Comment. Or any link will also do."
                    },
                    {
                        "username": "cqrbala",
                        "content": "Check out the following video : https://www.youtube.com/watch?v=EIhAwfHubE8&list=PLgUwDviBIf0pcIDCZnxhv0LkHf5KzG9zp&index=6\\n\\nHas a really great explanation and live implementation as well."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Prefixes in HashSet \n\n  \n**Approach 2:** Bitwise Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "just_hands13",
                        "content": "Given a non-empty array of numbers, a0, a1, a2, \\u2026 , an-1, where 0 \\u2264 ai < 231.\\n\\nFind the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\\n\\nCould you do this in O(n) runtime?\\n\\nmy answer  - \"No\"\\nafter reading discussion - \"Yes\""
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "This should be a Hard Problem... Very Time Consuming"
                    },
                    {
                        "username": "akbarbuneri",
                        "content": "Trie data structures are often used for storing and searching for words in a dictionary or a large corpus of text. They are particularly useful for tasks such as autocomplete and spelling correction, where it is necessary to quickly find all words that start with a given prefix.\\n\\nFor example, consider a spelling correction tool that uses a trie to store a dictionary of valid words. When a user types in a word, the spelling correction tool can use the trie to quickly find all words in the dictionary that start with the same prefix as the typed word. It can then use this list of words to suggest corrections or autocomplete the typed word.\\n\\nTries are also used in some networking applications, such as routing table lookups, to quickly find the best route for a packet of data based on its destination address.\\n\\nOverall, trie data structures are useful for efficiently storing and searching for data that can be represented as strings or sequences of items. They are particularly well-suited for searching for data based on prefixes, and can be faster than other data structures such as hash tables or binary search trees for certain types of queries."
                    },
                    {
                        "username": "fatref",
                        "content": "A real life example!!!"
                    },
                    {
                        "username": "pallavshah",
                        "content": "https://www.ritambhara.in/maximum-xor-value-of-two-elements/"
                    }
                ]
            },
            {
                "id": 1934343,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 1727672,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 1575656,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 1571698,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 1567534,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 1570169,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 1570168,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 1574278,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 2072981,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 2066984,
                "content": [
                    {
                        "username": "BholaBro",
                        "content": "am i the only one who is getting blank test case and blank output as last testcase ? \\nbecause of that i m not able to submit bcoz function return int."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "same here\\n"
                    },
                    {
                        "username": "adilasanis",
                        "content": "How can you think of using Trie here :( "
                    },
                    {
                        "username": "c4tdog",
                        "content": "each number is a sequence of \\'0\\' and \\'1\\'s. to get a max XOR value you need to find 2 numbers with opposite values in the same bit positions (0 xor 1 = 1). It\\'s easy to do using Trie."
                    },
                    {
                        "username": "eneagoe",
                        "content": "Does anyone have a hint on how to approach the problem of finding the kth largest XOR of a pair of numbers in an array?"
                    },
                    {
                        "username": "cdz__29",
                        "content": "hey can you please share a link to that question?"
                    },
                    {
                        "username": "Malevolence",
                        "content": "Actually I used python to solve.\\nI tried two methods, one is I wrote a Trie, the other is I use set .Of course the time complexity is O(32 * n), but I both got TLE.\\n\\nI know we can write like some posts to save time, and this can pass.\\n**But I still don't think directly using trie and result TLE is suitable for a medium problem.**"
                    },
                    {
                        "username": "M0han_kumar",
                        "content": "the title says it all. Go code now"
                    },
                    {
                        "username": "evermost",
                        "content": "What does \\n\"Find the maximum result of ai XOR aj, where 0 \\u2264 i, j < n.\"\\n\\nmean?\\n\\nThanks!"
                    },
                    {
                        "username": "Ceay",
                        "content": "I looked at a couple of solutions and I am not persuaded that they are indeed O(n). The tries approach uses search and insert that are both O(log(n)). The most voted Python solution, while indeed a great implementation that I am jealous about, is O(32n), or O(log(max(n)) n).\\n\\nIf we restrict the problem to numbers below 2^31 (as in the problem), then any solution becomes O(n) by applying list(set(nums)) first. That list(set(nums)) is exactly O(n). After the function, the list has max len of 2^31  and thus any algorithm on it is O(1) by definition.\\n\\nWhat are your thoughs? What am I missing?"
                    },
                    {
                        "username": "adiya",
                        "content": "https://medium.com/@adiya.tb/421-maximum-xor-of-two-numbers-in-an-array-c3ade7d0300d"
                    },
                    {
                        "username": "mciobanu",
                        "content": "Perhaps there are other approaches, but, as far as I can tell, \"trie\" seems to dominate the solutions. I thought I\\'d post my [alternative](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/4092075/pretty-fast-beats-97-4-on-time-and-doesn-t-use-a-trie/), which is pretty fast (beats 97.4% on time and 98.85% on space), and doesn\\'t use a trie. And it can be further optimized, as it does a lot of unnecessary searches. A major drawback is that it\\'s pretty long. And it might be pretty hard to comprehend (I have an idea on how to improve the explanation, but I spent too much time on this anyway). Still, it\\'s a different approach that is quite fast as it is."
                    },
                    {
                        "username": "durvorezbariq",
                        "content": "Should make less rigid Time limit conditions for Python... Trie solution gives TLE"
                    }
                ]
            },
            {
                "id": 2044149,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            },
            {
                "id": 2037996,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            },
            {
                "id": 2020680,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            },
            {
                "id": 2017337,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            },
            {
                "id": 1973421,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            },
            {
                "id": 1958643,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            },
            {
                "id": 1930432,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            },
            {
                "id": 1906884,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            },
            {
                "id": 1901403,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            },
            {
                "id": 1824069,
                "content": [
                    {
                        "username": "Filthy_Toad",
                        "content": "Why memory allotted is so limited?"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "why do such questions exist"
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "C# runtime is unnecessary strict. I passed Case #42 just by switching from `Dictionary<bool, Node>` to `Node[2]` array for the trie node children."
                    },
                    {
                        "username": "maxim-dovydenok",
                        "content": "My trie JS solution fails with MLE, most of Trie JS solutions posted by others also fail with MLE at the moment, did memory limits change recently? Should it be possible to solve it using Trie (this problem is part of Trie Explore card)? 200,000 numbers test case fails even if I use length 2 array for each node\n\nUpdate: I implemented trie solution where each node contains not one bit, but 4 bits :)"
                    },
                    {
                        "username": "ilcegor",
                        "content": "hmm... Why time limit exeedes when I am using trie method? Anyone`ve noticed that?"
                    },
                    {
                        "username": "prashantjaat652",
                        "content": "Very lengthy and difficult to implement. Definitely a hard problem."
                    },
                    {
                        "username": "cqrbala",
                        "content": "`int bit = (num >> i) & 1;\\nint bit = num & (1 << i);`\\n\\nTo check if the ith bit is set, both the above expressions are valid but did anyone else run into an out of bounds error when they used the second expression ?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "In python, I cannot avoid MLE by using trie..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Trie based solution gives TLE.Runtime is unnecessarily strict for a medium level problem"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is Trie solution so slow?"
                    }
                ]
            }
        ]
    }
]