[
    {
        "title": "Finding the Topic of Each Post",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568744,
                "content": [
                    {
                        "username": "arjunsuri",
                        "content": "WITH post_split AS (SELECT post_id, value split_word \\nFROM Posts  \\n    CROSS APPLY STRING_SPLIT(content, \\' \\')), #split your string \\n\\npost_topics AS (select distinct post_id, topic_id\\nFROM post_split p \\nLEFT JOIN Keywords k on LOWER(k.word) = LOWER(p.split_word)\\n) #match split words with Keywords table\\n\\n\\nselect post_id, isnull(string_agg(topic_id, \\',\\') WITHIN GROUP(ORDER BY topic_id ),\\'Ambiguous!\\') topic\\nfrom post_topics\\ngroup by post_id #concatenate the results"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum White Tiles After Covering With Carpets",
        "question_content": "<p>You are given a <strong>0-indexed binary</strong> string <code>floor</code>, which represents the colors of tiles on a floor:</p>\n\n<ul>\n\t<li><code>floor[i] = &#39;0&#39;</code> denotes that the <code>i<sup>th</sup></code> tile of the floor is colored <strong>black</strong>.</li>\n\t<li>On the other hand, <code>floor[i] = &#39;1&#39;</code> denotes that the <code>i<sup>th</sup></code> tile of the floor is colored <strong>white</strong>.</li>\n</ul>\n\n<p>You are also given <code>numCarpets</code> and <code>carpetLen</code>. You have <code>numCarpets</code> <strong>black</strong> carpets, each of length <code>carpetLen</code> tiles. Cover the tiles with the given carpets such that the number of <strong>white</strong> tiles still visible is <strong>minimum</strong>. Carpets may overlap one another.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of white tiles still visible.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png\" style=\"width: 400px; height: 73px;\" />\n<pre>\n<strong>Input:</strong> floor = &quot;10110101&quot;, numCarpets = 2, carpetLen = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> \nThe figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\nNo other way of covering the tiles with the carpets can leave less than 2 white tiles visible.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex2.png\" style=\"width: 353px; height: 123px;\" />\n<pre>\n<strong>Input:</strong> floor = &quot;11111&quot;, numCarpets = 2, carpetLen = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> \nThe figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\nNote that the carpets are able to overlap one another.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= carpetLen &lt;= floor.length &lt;= 1000</code></li>\n\t<li><code>floor[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n\t<li><code>1 &lt;= numCarpets &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1863955,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\n`dp[i][k]` means that,\\nusing `k` tiles to cover the first `i` tiles\\nthe minimum number of white tiles still visible.\\n\\n\\nFor each tile `s[i]`, we heve two options,\\nOne option is doing nothing, `jump` this tile,\\n`jump = dp[i - 1][k] + int(s[i - 1])`\\nThe other option is covering this tile\\n`cover = dp[i - l][k - 1]`\\n\\nThen we take the minimum result of two options:\\n`dp[i][k] = min(jump, cover)`\\n\\nFinally after explore all combination of `(i,k)`,\\nwe return `dp[n][nc]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(NC)`\\nSpace `O(NC)`\\nwhere `N = floor.length` and `C = numCarpets`.\\nSpace can be optimized to `O(N)`.\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumWhiteTiles(String s, int nc, int l) {\\n        int n = s.length(), dp[][] = new int[n + 1][nc + 1];\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s.charAt(i - 1) - \\'0\\';\\n                int cover = k > 0 ? dp[Math.max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = Math.min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumWhiteTiles(string s, int nc, int l) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(nc + 1));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s[i - 1] - \\'0\\';\\n                int cover = k > 0 ? dp[max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\\n\\n**Python3**\\n```py\\n    def minimumWhiteTiles(self, A, k, l):\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if i <= 0: return 0\\n            return min(int(A[i - 1]) + dp(i - 1, k), dp(i - l, k - 1) if k else 1000)\\n            \\n        return dp(len(A), k) \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumWhiteTiles(String s, int nc, int l) {\\n        int n = s.length(), dp[][] = new int[n + 1][nc + 1];\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s.charAt(i - 1) - \\'0\\';\\n                int cover = k > 0 ? dp[Math.max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = Math.min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\n```cpp\\n    int minimumWhiteTiles(string s, int nc, int l) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(nc + 1));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s[i - 1] - \\'0\\';\\n                int cover = k > 0 ? dp[max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\n```py\\n    def minimumWhiteTiles(self, A, k, l):\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if i <= 0: return 0\\n            return min(int(A[i - 1]) + dp(i - 1, k), dp(i - l, k - 1) if k else 1000)\\n            \\n        return dp(len(A), k) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1864150,
                "title": "c-solution-top-down-dynamic-programming-recursion-memoization",
                "content": "Iterate over string `floor`:\\n\\n- At each index `pos` in the string `floor` we have two options:\\n\\n    - Use a carpet, that starts from the index `pos` and ends at `pos + carpetLength - 1`. All tiles in this part will change to black, hence move to index `pos + carpetLength`\\n    - Skip the index and move to next index `pos + 1`. This time the tile at index `pos` will be unchanged, thus add `1` to the answer if it\\'s a white tile.\\n\\n- After either of the options, recursively move to the next index. Return the minimum of the above two options.\\n\\nBase Case:\\n\\n- If we have traversed the whole string `floor`, then no white tiles present. Hence return `0`.\\n- If we have used all the available carpets, then the remaining string will not change. Hence return the number of `1`\\'s in the remaining string. (Store the number of `1`s for the suffix `[i, N]` in the array `suffix` beforehand, instead of finding it again and again).\\n\\nThere will be repeated subproblems corresponding to index (`pos`) and the number of carpet used (`used`). Hence store the result in the table `dp` and use it to answer repeated problems insetad of going into recursion.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int suffix[1001];\\n\\n    void findSuffixSum(string& floor) {\\n        int n = floor.size();\\n        \\n        suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int solve(string& floor, int numCarpets, int carpetLen, int pos, int used) {\\n        if (pos >= floor.size()) {\\n            return 0;\\n        } else if (used == numCarpets) {\\n            return suffix[pos];\\n        }\\n        \\n        if (dp[pos][used] != -1) {\\n            return dp[pos][used];\\n        }\\n\\n        return dp[pos][used] = min(solve(floor, numCarpets, carpetLen, pos + carpetLen, used + 1),\\n                      (floor[pos] == \\'1\\') + solve(floor, numCarpets, carpetLen, pos + 1, used));\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        memset(dp, -1, sizeof(dp));\\n        findSuffixSum(floor);\\n        \\n        return solve(floor, numCarpets, carpetLen, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int suffix[1001];\\n\\n    void findSuffixSum(string& floor) {\\n        int n = floor.size();\\n        \\n        suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int solve(string& floor, int numCarpets, int carpetLen, int pos, int used) {\\n        if (pos >= floor.size()) {\\n            return 0;\\n        } else if (used == numCarpets) {\\n            return suffix[pos];\\n        }\\n        \\n        if (dp[pos][used] != -1) {\\n            return dp[pos][used];\\n        }\\n\\n        return dp[pos][used] = min(solve(floor, numCarpets, carpetLen, pos + carpetLen, used + 1),\\n                      (floor[pos] == \\'1\\') + solve(floor, numCarpets, carpetLen, pos + 1, used));\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        memset(dp, -1, sizeof(dp));\\n        findSuffixSum(floor);\\n        \\n        return solve(floor, numCarpets, carpetLen, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863872,
                "title": "python-short-dp-explained",
                "content": "Problem constraints will help you to understand that this problem can be solved with `dp`. Let the state `dp(i, t)` be minimum number of white tiles when we allowed to use `t` number of carpets such that their right (and hence all carpets) lies in `[0, i]`. Then each moment of time we have option to take carpet or do not take it:\\n1. If we take, previous state is `dp(i - L, t - 1)`.\\n2. If we do not take it, previous state is `dp(i - 1, t) + `int(floor[i] == \"1\")`.\\n\\n#### Complexity\\nIt is `O(n^2)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, k, L):\\n        @lru_cache(None)\\n        def dp(i, t):\\n            if t < 0: return float(\"inf\")\\n            if i < 0: return 0\\n            return min(dp(i - L, t - 1), dp(i - 1, t) + int(floor[i] == \"1\"))\\n        \\n        return dp(len(floor) - 1, k)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, k, L):\\n        @lru_cache(None)\\n        def dp(i, t):\\n            if t < 0: return float(\"inf\")\\n            if i < 0: return 0\\n            return min(dp(i - L, t - 1), dp(i - 1, t) + int(floor[i] == \"1\"))\\n        \\n        return dp(len(floor) - 1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863912,
                "title": "dp-detailed-explanation-with-commented-code",
                "content": "Imagine we are covering the floor with carpets from left to right. At any point in this exercise, we will be at some point i and have carpetsRemaining carpets remaining. At this point we are only concerned with covering the floor from i to n - 1. \\nIn other words i can say that the state at any point is fully defined by (current position, carpets remaining)\\n\\nWhen we are standing at index i, we have 2 choices\\n\\t* either skip this tile and leave it uncovered\\n\\t* use one carpet starting from here.\\n\\nFirst off, If we are currently on a black tile, it makes no sense to start a new carpet here, so we just move one step to the right. (whatever white tiles we cover by starting here, we can cover from i + 1 and possibly more)\\nNow that we are on a white tile, \\n\\t* If we apply option 1 and skip this tile, we would expose 1 white tile and continue the exercise from tile i + 1 with the same number of carpets remaining\\n\\t* If we apply option 2 and start a new carpet here, we would use one carpet and continue the exercise from tile i + carpetLen.\\n\\twe would obviously want to take the option which would expose the minumum number of white tiles. \\n\\nIf f( i , carpetsRemaining ) represents the minimum number if white tiles exposed for the floor from i to n - 1 with carpetsRemaining carpets remaining, \\n//base cases\\n* if( i >= n) then ans = 0. ( we have fully covered the floor and are standing to the right of it)\\n* if( carpetsRemaining == 0 ) then ans = number of zeroes from i to n - 1. (We dont have any more carpets and will expose everything here on out)\\n```\\n\\tif(i >= a.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif(carpets_left == 0) {\\n\\t\\treturn suffix[i];      //suffix[i] = number of white tiles from index i to n (can be calculated using a simple for loop)\\n\\t}\\n```\\n//recursive cases\\n* if( floor[i] == BLACK ) then ans = f ( i + 1, carpetsRemaining). (Just ignore this tile, continue from next index)\\n* if( floor[i] == WHITE ) then ans = Max of\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t* 1 + f( i + 1, carpetsRemaining)      (expose this tile, hence + 1, and continue with same number of carpets)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t* f( i + carpetLen, carpetsRemaining - 1 )      (start a new carpet here, skip carpetLen tiles, but have 1 less carpet)\\n\\n```\\n\\t // first check if this state has already been visited, if so return the answer already computed\\n\\tif(dp[i][carpets_left] != UNVISITED) {      \\n\\t\\treturn dp[i][carpets_left];\\n\\t}\\n\\tif(a[i] == BLACK) {\\n\\t\\t//this tile is black, skip it\\n\\t\\tdp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t}\\n\\telse {\\n\\t\\t//start carpet here\\n\\t\\tint start_carpet_here = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n\\t\\t//dont start carpet here\\n\\t\\tint dont_start_carpet_here = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t\\tdp[i][carpets_left] = Math.min(start_carpet_here, dont_start_carpet_here);\\n\\t}\\n\\n\\treturn dp[i][carpets_left];\\n```\\n\\nThere are (n * numCarpets) states, we momoize the result for each state in a 2D array.\\nTime Complexity: O(n * numCarpets)\\nSpace Complexity: O(n * numCarpets)\\n\\nFull Code:\\n```\\nclass Solution {\\n    private static final int UNVISITED = -1;\\n    private static final char BLACK = \\'0\\';\\n    private static final char WHITE = \\'1\\';\\n\\n    private int f(int i, int carpets_left, char[] a, int[][] dp, int[] suffix, int carpetLen) {\\n        if(i >= a.length) {\\n            return 0;\\n        }\\n        if(carpets_left == 0) {\\n            return suffix[i];\\n        }\\n        if(dp[i][carpets_left] != UNVISITED) {\\n            return dp[i][carpets_left];\\n        }\\n        if(a[i] == BLACK) {\\n            dp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n        }\\n        else {\\n            //start carpet here\\n            int start = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n            //dont start carpet here\\n            int dont = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\n            dp[i][carpets_left] = Math.min(start, dont);\\n        }\\n\\n        return dp[i][carpets_left];\\n    }\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.length();\\n        char[] a = floor.toCharArray();\\n        \\n        //calculating the suffix array\\n        int[] suffix = new int[n + 1];\\n        for(int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1];\\n            if(a[i] == WHITE) {\\n                suffix[i] ++;\\n            }\\n        }\\n        \\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for(int[] row : dp) {\\n            Arrays.fill(row, UNVISITED);\\n        }\\n\\n        return f(0, numCarpets, a, dp, suffix, carpetLen);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tif(i >= a.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif(carpets_left == 0) {\\n\\t\\treturn suffix[i];      //suffix[i] = number of white tiles from index i to n (can be calculated using a simple for loop)\\n\\t}\\n```\n```\\n\\t // first check if this state has already been visited, if so return the answer already computed\\n\\tif(dp[i][carpets_left] != UNVISITED) {      \\n\\t\\treturn dp[i][carpets_left];\\n\\t}\\n\\tif(a[i] == BLACK) {\\n\\t\\t//this tile is black, skip it\\n\\t\\tdp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t}\\n\\telse {\\n\\t\\t//start carpet here\\n\\t\\tint start_carpet_here = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n\\t\\t//dont start carpet here\\n\\t\\tint dont_start_carpet_here = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t\\tdp[i][carpets_left] = Math.min(start_carpet_here, dont_start_carpet_here);\\n\\t}\\n\\n\\treturn dp[i][carpets_left];\\n```\n```\\nclass Solution {\\n    private static final int UNVISITED = -1;\\n    private static final char BLACK = \\'0\\';\\n    private static final char WHITE = \\'1\\';\\n\\n    private int f(int i, int carpets_left, char[] a, int[][] dp, int[] suffix, int carpetLen) {\\n        if(i >= a.length) {\\n            return 0;\\n        }\\n        if(carpets_left == 0) {\\n            return suffix[i];\\n        }\\n        if(dp[i][carpets_left] != UNVISITED) {\\n            return dp[i][carpets_left];\\n        }\\n        if(a[i] == BLACK) {\\n            dp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n        }\\n        else {\\n            //start carpet here\\n            int start = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n            //dont start carpet here\\n            int dont = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\n            dp[i][carpets_left] = Math.min(start, dont);\\n        }\\n\\n        return dp[i][carpets_left];\\n    }\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.length();\\n        char[] a = floor.toCharArray();\\n        \\n        //calculating the suffix array\\n        int[] suffix = new int[n + 1];\\n        for(int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1];\\n            if(a[i] == WHITE) {\\n                suffix[i] ++;\\n            }\\n        }\\n        \\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for(int[] row : dp) {\\n            Arrays.fill(row, UNVISITED);\\n        }\\n\\n        return f(0, numCarpets, a, dp, suffix, carpetLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863967,
                "title": "memory-optimized-dp",
                "content": "It feels like there could be some clever way to lay carpets, but there isn\\'t. We need to search for an optimal solution.\\n\\n> Note: problem constrains give it away.\\n\\nWe start with the top-down approach, and then convert it to the bottom-up one. By analyzing the tabulation, we can reduce the memory usage to O(n). The runtime for the final, memory-optimized bottom-up approach is 120 ms.\\n\\n#### Top-Down\\nFor the search, we can skip positions with black tiles.\\n**C++**\\n```cpp\\nint dp[1001][1001] = {};\\nint dfs(string &floor, int i, int n, int len) {\\n    if (n < 0)\\n        return floor.size();\\n    if (floor.size() - i <= n * len)\\n        return 0;\\n    if (floor[i] == \\'0\\')\\n        return dfs(floor, i + 1, n, len);\\n    if (dp[i][n] == 0)\\n        dp[i][n] = 1 + min(1 + dfs(floor, i + 1, n, len), dfs(floor, i + len, n - 1, len)); \\n    return dp[i][n] - 1;\\n}\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    return dfs(floor, 0, numCarpets, len);\\n} \\n```\\n\\n#### Bottom-Up\\n**C++**\\n```cpp\\nint dp[1001][1001] = {};\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    for (int i = floor.size() - 1; i >= 0; --i) {\\n        dp[i][0] = dp[i + 1][0] + (floor[i] == \\'1\\');\\n        for (int c = 1; c <= numCarpets; ++c)\\n            dp[i][c] = min(dp[i + 1][c] + (floor[i] == \\'1\\'), dp[min(1000, i + len)][c - 1]);\\n    }\\n    return dp[0][numCarpets];\\n}  \\n```\\n\\n#### Memory-Optimized Bottom-Up DP\\nWe can rearrange loops from the solution above so that the first loop iterates through carpets. That way, we only need to store tabulation values for the current and previous step. \\n\\n**C++**\\n```cpp\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    int sz = floor.size(), dp[2][1001] = {};\\n    for (int i = 0; i < sz; ++i)\\n        dp[0][i + 1] += dp[0][i] + (floor[i] == \\'1\\');  \\n    for (int c = 1; c <= numCarpets; ++c)\\n        for (int i = 0; i < sz; ++i)\\n            dp[c % 2][i + 1] = min(dp[c % 2][i] + (floor[i] == \\'1\\'),\\n                dp[(c + 1) % 2][max(0, i + 1 - len)]);\\n    return dp[numCarpets % 2][sz];\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[1001][1001] = {};\\nint dfs(string &floor, int i, int n, int len) {\\n    if (n < 0)\\n        return floor.size();\\n    if (floor.size() - i <= n * len)\\n        return 0;\\n    if (floor[i] == \\'0\\')\\n        return dfs(floor, i + 1, n, len);\\n    if (dp[i][n] == 0)\\n        dp[i][n] = 1 + min(1 + dfs(floor, i + 1, n, len), dfs(floor, i + len, n - 1, len)); \\n    return dp[i][n] - 1;\\n}\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    return dfs(floor, 0, numCarpets, len);\\n} \\n```\n```cpp\\nint dp[1001][1001] = {};\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    for (int i = floor.size() - 1; i >= 0; --i) {\\n        dp[i][0] = dp[i + 1][0] + (floor[i] == \\'1\\');\\n        for (int c = 1; c <= numCarpets; ++c)\\n            dp[i][c] = min(dp[i + 1][c] + (floor[i] == \\'1\\'), dp[min(1000, i + len)][c - 1]);\\n    }\\n    return dp[0][numCarpets];\\n}  \\n```\n```cpp\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    int sz = floor.size(), dp[2][1001] = {};\\n    for (int i = 0; i < sz; ++i)\\n        dp[0][i + 1] += dp[0][i] + (floor[i] == \\'1\\');  \\n    for (int c = 1; c <= numCarpets; ++c)\\n        for (int i = 0; i < sz; ++i)\\n            dp[c % 2][i + 1] = min(dp[c % 2][i] + (floor[i] == \\'1\\'),\\n                dp[(c + 1) % 2][max(0, i + 1 - len)]);\\n    return dp[numCarpets % 2][sz];\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863927,
                "title": "c-easy-to-understand-with-explanation-and-optimizations-dp",
                "content": "Hello, while it may seem like a difficult one, the fourth question can be done with an almost bruteforce approach with some optimizations.\\n\\nLet dp[i][j] denote the maximum number of ones we can cover with i carpets till index j(**with current carpet ending exactly at index j**). Assuming that the current carpet ends at exactly j *greatly simplifies* the problem\\n\\nNow, dp[i][j]= number of ones in string[j:j-len]+ max(dp[i-1][j-len], dp[i-1][j-len-1],....dp[i-1][0])\\n\\nOptimizations:\\nWe store this max part of previous iteration of i till j-len in a helper variable. (prevmax)\\nWe use prefix sum array to calculate number of white blocks in a range in O(1) time\\nWe only need the ith and i-1th rows of the dp array, so space can be reduced (didn\\'t do it due to time constraints during contest)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int dp[1001][1001]={0};\\n        int pre[1000]={0};\\n        if(floor[0]==\\'1\\')pre[0]=1;\\n        for(int i=1;i<floor.size();i++){\\n            pre[i]+=pre[i-1];\\n            if(floor[i]==\\'1\\')pre[i]++;\\n        }\\n        for(int i=1;i<=numCarpets;i++){\\n            int prevmax=0;\\n            for(int j=0;j<floor.size();j++){\\n                if(j<carpetLen) dp[i][j]=pre[j];\\n                else{\\n                    prevmax=max(prevmax,dp[i-1][j-carpetLen]);\\n                    dp[i][j]=pre[j]-pre[j-carpetLen]+prevmax;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<floor.size();i++)ans=max(ans,dp[numCarpets][i]);\\n        return pre[floor.size()-1]-ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int dp[1001][1001]={0};\\n        int pre[1000]={0};\\n        if(floor[0]==\\'1\\')pre[0]=1;\\n        for(int i=1;i<floor.size();i++){\\n            pre[i]+=pre[i-1];\\n            if(floor[i]==\\'1\\')pre[i]++;\\n        }\\n        for(int i=1;i<=numCarpets;i++){\\n            int prevmax=0;\\n            for(int j=0;j<floor.size();j++){\\n                if(j<carpetLen) dp[i][j]=pre[j];\\n                else{\\n                    prevmax=max(prevmax,dp[i-1][j-carpetLen]);\\n                    dp[i][j]=pre[j]-pre[j-carpetLen]+prevmax;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<floor.size();i++)ans=max(ans,dp[numCarpets][i]);\\n        return pre[floor.size()-1]-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864377,
                "title": "java-knapsack-solution",
                "content": "```\\nclass Solution {\\n    int pref[];\\n\\n    public int minimumWhiteTiles(String floor, int tot, int len) {\\n        char a[] = floor.toCharArray();\\n        this.pref = new int[a.length];\\n        int c = 0;\\n        this.dp = new int[a.length + 1][tot + 1];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == \\'1\\') c++;\\n            pref[i] = c;\\n        }\\n        return pref[a.length - 1] - solve(0, a, tot, len);  // total ones - max removed\\n    }\\n\\n    int dp[][];\\n\\n    private int solve(int index, char a[], int tot, int len) {\\n        if (index >= a.length || tot == 0) {\\n            return 0;\\n        }\\n        if (dp[index][tot] != -1) return dp[index][tot];\\n        int ones = pref[Math.min(index + len - 1, a.length - 1)] - (index == 0 ? 0 : pref[index - 1]);\\n        int take = ones + solve(index + len, a, tot - 1, len);  // either take it and add one\\'s count in that subsegment\\n        int dont = solve(index + 1, a, tot, len);  // or dont \\n        return dp[index][tot] = Math.max(take, dont);  // return max of both\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int pref[];\\n\\n    public int minimumWhiteTiles(String floor, int tot, int len) {\\n        char a[] = floor.toCharArray();\\n        this.pref = new int[a.length];\\n        int c = 0;\\n        this.dp = new int[a.length + 1][tot + 1];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == \\'1\\') c++;\\n            pref[i] = c;\\n        }\\n        return pref[a.length - 1] - solve(0, a, tot, len);  // total ones - max removed\\n    }\\n\\n    int dp[][];\\n\\n    private int solve(int index, char a[], int tot, int len) {\\n        if (index >= a.length || tot == 0) {\\n            return 0;\\n        }\\n        if (dp[index][tot] != -1) return dp[index][tot];\\n        int ones = pref[Math.min(index + len - 1, a.length - 1)] - (index == 0 ? 0 : pref[index - 1]);\\n        int take = ones + solve(index + len, a, tot - 1, len);  // either take it and add one\\'s count in that subsegment\\n        int dont = solve(index + 1, a, tot, len);  // or dont \\n        return dp[index][tot] = Math.max(take, dont);  // return max of both\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863879,
                "title": "c-fixed-length-sliding-window-dp",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Fixed-length Sliding Window + DP\\n\\n**Intuition**:\\n\\n1. Use a sliding window of length `carpetLen` to compute a `cover` array where `cover[i]` is the number of white tiles covered by a carpet placed ending at `floor[i]`.\\n2. Use DP to calculate the maximum coverable white tiles using `numCarpets` carpets.\\n\\n**Algorithm**:\\n\\n**Fixed-length Sliding Window**:\\n\\nKeep a rolling sum `white` as the number of white tiles within the sliding window.\\n\\nFor each `i` in range `[0, N)`, we:\\n* increment `white` if `s[i] == \\'1\\'`\\n* decrement `white` if `s[i - len] == \\'1\\'`\\n* Set `cover[i] = white`.\\n\\n**DP**:\\n\\nLet `dp[i][j + 1]` be the maximum number of coverable white tiles where `1 <= i <= numCarpet` is number of carpets used and `0 <= j < N` is the last index where we can place carpet.\\n\\nAll `dp` values are initialized as `0`s.\\n\\nFor each `dp[i][j + 1]`, we have two options:\\n1. Don\\'t place carpet at index `j`. `dp[i][j+1] = dp[i][j]`\\n2. Place carpet ending at index `j` covering `cover[j]` white tiles. And we can place `i-1` carpets at or before `j-carpetLen`. So, `dp[i][j+1] = dp[i-1][j-carpetLen+1] + cover[j]`.\\n\\n```\\ndp[i][j + 1] = max(\\n                    dp[i][j],                                                                   // don\\'t place carpet at index `j`\\n                    (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]      // place carpet at index `j`\\n                  )\\n```\\n\\n`dp[numCarpet][N]` is the maximum number of white titles coverable. The answer is the number of total white tiles minus `dp[numCarpet][N]`. \\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N * numCarpet)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<vector<int>> dp(numCarpet + 1, vector<int>(N + 1));\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                dp[i][j + 1] = max(dp[i][j], (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n        }\\n        return sum - dp[numCarpet][N];\\n    }\\n};\\n```\\n\\nWe can reduce the space complexity to `O(N)` by using rolling arrays.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            vector<int> next(N + 1);\\n            for (int j = 0; j < N; ++j) {\\n                next[j + 1] = max(next[j], (j - carpetLen + 1 >= 0 ? dp[j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n            swap(dp, next);\\n        }\\n        return sum - dp[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j + 1] = max(\\n                    dp[i][j],                                                                   // don\\'t place carpet at index `j`\\n                    (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]      // place carpet at index `j`\\n                  )\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N * numCarpet)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<vector<int>> dp(numCarpet + 1, vector<int>(N + 1));\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                dp[i][j + 1] = max(dp[i][j], (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n        }\\n        return sum - dp[numCarpet][N];\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            vector<int> next(N + 1);\\n            for (int j = 0; j < N; ++j) {\\n                next[j + 1] = max(next[j], (j - carpetLen + 1 >= 0 ? dp[j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n            swap(dp, next);\\n        }\\n        return sum - dp[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864445,
                "title": "c-knapsack-memoization",
                "content": "```\\nclass Solution {\\n    int n;\\n    vector<int> suffix;\\n    vector<vector<int>> memo;\\npublic:\\n    \\n    int doit(string& floor, int carp, int len, int ind) {\\n        if (ind >= n)   return 0;\\n        if (carp == 0)  return suffix[ind]; // if no carpets are left then all the white tiles from current index to the last will be visible\\n        if (memo[carp][ind] != -1)  return memo[carp][ind];\\n        int a = doit(floor, carp-1, len, ind+len); // carpet is used\\n        int b = doit(floor, carp, len, ind+1) + (floor[ind] == \\'1\\'); // carpet is not used\\n        return memo[carp][ind] = min(a, b);\\n    }\\n        \\n    int minimumWhiteTiles(string floor, int carp, int len) {\\n        \\n        n = size(floor);\\n        suffix.resize(n+1, 0);\\n        memo.resize(carp+1, vector<int>(n+1, -1));\\n        suffix[n-1] = (floor[n-1] == \\'1\\');\\n        for (int i=n-2; ~i; i--)\\n            suffix[i] = suffix[i+1] + (floor[i] == \\'1\\');\\n        \\n        return doit(floor, carp, len, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    vector<int> suffix;\\n    vector<vector<int>> memo;\\npublic:\\n    \\n    int doit(string& floor, int carp, int len, int ind) {\\n        if (ind >= n)   return 0;\\n        if (carp == 0)  return suffix[ind]; // if no carpets are left then all the white tiles from current index to the last will be visible\\n        if (memo[carp][ind] != -1)  return memo[carp][ind];\\n        int a = doit(floor, carp-1, len, ind+len); // carpet is used\\n        int b = doit(floor, carp, len, ind+1) + (floor[ind] == \\'1\\'); // carpet is not used\\n        return memo[carp][ind] = min(a, b);\\n    }\\n        \\n    int minimumWhiteTiles(string floor, int carp, int len) {\\n        \\n        n = size(floor);\\n        suffix.resize(n+1, 0);\\n        memo.resize(carp+1, vector<int>(n+1, -1));\\n        suffix[n-1] = (floor[n-1] == \\'1\\');\\n        for (int i=n-2; ~i; i--)\\n            suffix[i] = suffix[i+1] + (floor[i] == \\'1\\');\\n        \\n        return doit(floor, carp, len, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864242,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int recur(string &s, int numCarpets, int len, int i, vector<vector < int>> &dp, vector< int > &sufOnes)\\n        {\\n            if (i >= s.size())\\n                return 0;\\n            if (numCarpets == 0)\\n                return sufOnes[i];\\n\\n            if (dp[i][numCarpets] != -1)\\n            {\\n                return dp[i][numCarpets];\\n            }\\n            if (s[i] == \\'0\\')\\n            {\\n                dp[i][numCarpets] = recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n            }\\n            else\\n            {\\n               \\t//start carpet here\\n                int start = recur(s, numCarpets - 1, len, i + len, dp, sufOnes);\\n               \\t//dont start carpet here\\n                int dont = 1 + recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n\\n                dp[i][numCarpets] = min(start, dont);\\n            }\\n\\n            return dp[i][numCarpets];\\n        }\\n    int minimumWhiteTiles(string s, int n, int len)\\n    {\\n        int nn = s.size() + 1, mm = n + 1;\\n        vector<int> sufOnes(s.size() + 1, 0);\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            sufOnes[i] = sufOnes[i + 1];\\n            if (s[i] == \\'1\\')\\n            {\\n                sufOnes[i]++;\\n            }\\n        }\\n        vector<vector < int>> dp(nn, vector<int> (mm, -1));\\n        return recur(s, n, len, 0, dp, sufOnes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int recur(string &s, int numCarpets, int len, int i, vector<vector < int>> &dp, vector< int > &sufOnes)\\n        {\\n            if (i >= s.size())\\n                return 0;\\n            if (numCarpets == 0)\\n                return sufOnes[i];\\n\\n            if (dp[i][numCarpets] != -1)\\n            {\\n                return dp[i][numCarpets];\\n            }\\n            if (s[i] == \\'0\\')\\n            {\\n                dp[i][numCarpets] = recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n            }\\n            else\\n            {\\n               \\t//start carpet here\\n                int start = recur(s, numCarpets - 1, len, i + len, dp, sufOnes);\\n               \\t//dont start carpet here\\n                int dont = 1 + recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n\\n                dp[i][numCarpets] = min(start, dont);\\n            }\\n\\n            return dp[i][numCarpets];\\n        }\\n    int minimumWhiteTiles(string s, int n, int len)\\n    {\\n        int nn = s.size() + 1, mm = n + 1;\\n        vector<int> sufOnes(s.size() + 1, 0);\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            sufOnes[i] = sufOnes[i + 1];\\n            if (s[i] == \\'1\\')\\n            {\\n                sufOnes[i]++;\\n            }\\n        }\\n        vector<vector < int>> dp(nn, vector<int> (mm, -1));\\n        return recur(s, n, len, 0, dp, sufOnes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863886,
                "title": "c-dp-memoization",
                "content": "```\\n\\tvector<vector<int>> dp;\\n    int func(int i,string& s,int car,int len){\\n        if(i>=s.size()) return 0;\\n        if(dp[i][car]!=-1) return dp[i][car];\\n        if(s[i]==\\'0\\') return dp[i][car]=func(i+1,s,car,len);\\n        else{ \\n            int ans=INT_MAX;\\n            ans=1+func(i+1,s,car,len);\\n            if(car>0) ans=min(ans,func(i+len,s,car-1,len));\\n            return dp[i][car]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string s, int car, int len) {\\n        dp=vector<vector<int>>(s.size(),vector<int>(car+1,-1));\\n        return func(0,s,car,len);\\n    }",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\n\\tvector<vector<int>> dp;\\n    int func(int i,string& s,int car,int len){\\n        if(i>=s.size()) return 0;\\n        if(dp[i][car]!=-1) return dp[i][car];\\n        if(s[i]==\\'0\\') return dp[i][car]=func(i+1,s,car,len);\\n        else{ \\n            int ans=INT_MAX;\\n            ans=1+func(i+1,s,car,len);\\n            if(car>0) ans=min(ans,func(i+len,s,car-1,len));\\n            return dp[i][car]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string s, int car, int len) {\\n        dp=vector<vector<int>>(s.size(),vector<int>(car+1,-1));\\n        return func(0,s,car,len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1872882,
                "title": "python-readable-and-easy-understand-bottom-up-dp-solution-in-python",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        if carpetLen*numCarpets >= n:\\n            return 0\\n        floorlist = []\\n        for i in floor:\\n            if i == \\'1\\':\\n                floorlist.append(1)\\n            else:\\n                floorlist.append(0)\\n        dp=[[0] * n for i in range(numCarpets)]\\n        \\n        for i in range(carpetLen, n):\\n            dp[0][i] = min(floorlist[i] + dp[0][i-1], sum(floorlist[:i - carpetLen + 1]))\\n        for j in range(1, numCarpets):\\n            for i in range(carpetLen * j, n):\\n                dp[j][i] = min(floorlist[i] + dp[j][i - 1], dp[j - 1][i - carpetLen])\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        if carpetLen*numCarpets >= n:\\n            return 0\\n        floorlist = []\\n        for i in floor:\\n            if i == \\'1\\':\\n                floorlist.append(1)\\n            else:\\n                floorlist.append(0)\\n        dp=[[0] * n for i in range(numCarpets)]\\n        \\n        for i in range(carpetLen, n):\\n            dp[0][i] = min(floorlist[i] + dp[0][i-1], sum(floorlist[:i - carpetLen + 1]))\\n        for j in range(1, numCarpets):\\n            for i in range(carpetLen * j, n):\\n                dp[j][i] = min(floorlist[i] + dp[j][i - 1], dp[j - 1][i - carpetLen])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332778,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int dfs(string &floor, int Carpets, int Len, int idx, vector<vector<int>> &dp)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n        int val = 0;\\n        if(dp[idx][Carpets] != -1) return dp[idx][Carpets];\\n        if(Carpets == 0)\\n        {\\n            for(int i = idx; i < floor.size(); i++)\\n                if(floor[i] == \\'1\\') val++;\\n        }\\n        else\\n        {\\n            if(floor[idx] == \\'0\\')\\n                val = dfs(floor, Carpets, Len, idx+1, dp);\\n            else\\n            {\\n                val = min(1+dfs(floor, Carpets, Len, idx+1, dp), dfs(floor, Carpets-1, Len, idx+Len, dp));\\n            }\\n        }\\n        return dp[idx][Carpets] = val;\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> dp(n+1, vector<int> (numCarpets+1, -1));\\n        return dfs(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(string &floor, int Carpets, int Len, int idx, vector<vector<int>> &dp)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n        int val = 0;\\n        if(dp[idx][Carpets] != -1) return dp[idx][Carpets];\\n        if(Carpets == 0)\\n        {\\n            for(int i = idx; i < floor.size(); i++)\\n                if(floor[i] == \\'1\\') val++;\\n        }\\n        else\\n        {\\n            if(floor[idx] == \\'0\\')\\n                val = dfs(floor, Carpets, Len, idx+1, dp);\\n            else\\n            {\\n                val = min(1+dfs(floor, Carpets, Len, idx+1, dp), dfs(floor, Carpets-1, Len, idx+Len, dp));\\n            }\\n        }\\n        return dp[idx][Carpets] = val;\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> dp(n+1, vector<int> (numCarpets+1, -1));\\n        return dfs(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864204,
                "title": "recursion-memoization-time-saver-trick",
                "content": "```\\nclass Solution {\\npublic: \\n    int dp[1001][1001];\\n    int helper(string &floor, int idx, int numCarpets, int len)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n\\t\\t\\t\\n        int &ans = dp[idx][numCarpets]; //reference variable so that we dont have to write this again \\n        \\n        if(ans != -1) //if state already calculated no need to calculate again directly return its value\\n            return ans;\\n        \\n        int op1 = INT_MAX, op2 = INT_MAX;\\n\\t\\t//when you dont use a new carpet from the current index\\n        op1 = (floor[idx] == \\'1\\') + helper(floor, idx+1, numCarpets, len);\\n\\t\\t//when you use a new carpet from the current index\\n        if(numCarpets > 0)\\n        op2 = helper(floor, idx+len, numCarpets-1, len);\\n        return ans = min(op1, op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetlen) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(floor, 0, numCarpets, carpetlen);\\n    }\\n};\\n\\n```\\nThe question could be solved in a recursive manner where you just need to know the index and the number of carpets left, now at any index we have two options either we can use the available carpets or we can leave this index as it is. We can consider both options and return the minimum of both the available options.\\n\\nI have used a trick that is I used a reference variable to store dp[idx][numCarpets], now imagine those questions where we have 3 or 4 states and we don\\'t want those dp[][][] states again and again. We can simply use reference variables and we can use them our code to save sometime in competitions.\\n\\nPlease upvote if you have learnt anything from this post.",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int dp[1001][1001];\\n    int helper(string &floor, int idx, int numCarpets, int len)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n\\t\\t\\t\\n        int &ans = dp[idx][numCarpets]; //reference variable so that we dont have to write this again \\n        \\n        if(ans != -1) //if state already calculated no need to calculate again directly return its value\\n            return ans;\\n        \\n        int op1 = INT_MAX, op2 = INT_MAX;\\n\\t\\t//when you dont use a new carpet from the current index\\n        op1 = (floor[idx] == \\'1\\') + helper(floor, idx+1, numCarpets, len);\\n\\t\\t//when you use a new carpet from the current index\\n        if(numCarpets > 0)\\n        op2 = helper(floor, idx+len, numCarpets-1, len);\\n        return ans = min(op1, op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetlen) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(floor, 0, numCarpets, carpetlen);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863913,
                "title": "python-dynamic-programming-prefix-sum-solution-explained",
                "content": "So this is a dynamic programming question with a trick.\\nYou can guess it using the given constraints.\\nThe solution can be divided into two parts:\\n*  Recursively find ways to use carpets to cover the floor \\n* Optimize using **Prefix Sum** to find the number of white tiles present between two indices of the floor\\n\\nPlease read through the comments for better understanding!\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\tn = len(floor)\\n\\t\\t#Using memo table to store predefined computations\\n        memo = [[-1 for x in range(numCarpets+1)] for x in range(len(floor)+1)] \\n        def solve(N,numCarpets):\\n\\t\\t\\t#Base Case\\n            if N>=n:\\n                return 0\\n\\t\\t\\t#If calculated previously use that solution\\n            if memo[N][numCarpets]!=-1:\\n                return memo[N][numCarpets]\\n\\t\\t\\t\\t\\n            used = 0 # If you use the carpet\\n            notused = 0 # If you donot use the carpet\\n\\t\\t\\t\\n            if floor[N]==\\'1\\': # We might use the carpet in this part\\n                if numCarpets>0: #Whether we even have some carpets or not\\n\\t\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\t\\tOptimization Part\\n\\t\\t\\t\\t\\tWe are finding the number of ones present in this part of the floor.\\n\\t\\t\\t\\t\\tprefix[lastInd] - Number of ones till lastInd\\n\\t\\t\\t\\t\\tprefix[N] - Number of ones till Nth Index.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tTheir difference gives us how many ones present between the two.\\n\\t\\t\\t\\t    \"\"\"\\n                    lastInd = min(N+carpetLen,len(floor)) \\n                    ans = prefix[lastInd] - prefix[N]\\n                    \\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tFind the max if we use or donot use carpet at this index\\n\\t\\t\\t\\t\\tIf we do we add  --- ans and decrement remaining carpets\\n\\t\\t\\t\\t\\telse we donot\\n\\t\\t\\t\\t\\t\"\"\"\\n                    used = max(solve(N+carpetLen,numCarpets-1)+ans,solve(N+1,numCarpets))\\n                            \\n                else:\\n                    used = 0\\n            \\n            else:\\n\\t\\t\\t#If we donot use the carpet although I feel this might be redundant code\\n                notused = solve(N+1,numCarpets)\\n            \\n\\t\\t\\t#Using max function to find the number of white tiles removed\\n            memo[N][numCarpets] = max(used,notused)\\n            return memo[N][numCarpets]\\n\\t\\t\\n\\t\\t#Total White tiles\\n        ones = 0\\n        for x in floor:\\n            if x == \\'1\\':\\n                ones+=1\\n        \\n\\t\\t#Using Prefix array to store number of ones till i th index\\n        prefix = [0]*(n+1)\\n        for i in range(1,n+1):\\n            if floor[i-1]==\\'1\\':\\n                prefix[i] = prefix[i-1]+1\\n            else:\\n                prefix[i] = prefix[i-1]\\n\\t\\t\\t\\t\\n       \\n        removed = solve(0,numCarpets)\\n        \\n        return ones-removed\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\tn = len(floor)\\n\\t\\t#Using memo table to store predefined computations\\n        memo = [[-1 for x in range(numCarpets+1)] for x in range(len(floor)+1)] \\n        def solve(N,numCarpets):\\n\\t\\t\\t#Base Case\\n            if N>=n:\\n                return 0\\n\\t\\t\\t#If calculated previously use that solution\\n            if memo[N][numCarpets]!=-1:\\n                return memo[N][numCarpets]\\n\\t\\t\\t\\t\\n            used = 0 # If you use the carpet\\n            notused = 0 # If you donot use the carpet\\n\\t\\t\\t\\n            if floor[N]==\\'1\\': # We might use the carpet in this part\\n                if numCarpets>0: #Whether we even have some carpets or not\\n\\t\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\t\\tOptimization Part\\n\\t\\t\\t\\t\\tWe are finding the number of ones present in this part of the floor.\\n\\t\\t\\t\\t\\tprefix[lastInd] - Number of ones till lastInd\\n\\t\\t\\t\\t\\tprefix[N] - Number of ones till Nth Index.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tTheir difference gives us how many ones present between the two.\\n\\t\\t\\t\\t    \"\"\"\\n                    lastInd = min(N+carpetLen,len(floor)) \\n                    ans = prefix[lastInd] - prefix[N]\\n                    \\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tFind the max if we use or donot use carpet at this index\\n\\t\\t\\t\\t\\tIf we do we add  --- ans and decrement remaining carpets\\n\\t\\t\\t\\t\\telse we donot\\n\\t\\t\\t\\t\\t\"\"\"\\n                    used = max(solve(N+carpetLen,numCarpets-1)+ans,solve(N+1,numCarpets))\\n                            \\n                else:\\n                    used = 0\\n            \\n            else:\\n\\t\\t\\t#If we donot use the carpet although I feel this might be redundant code\\n                notused = solve(N+1,numCarpets)\\n            \\n\\t\\t\\t#Using max function to find the number of white tiles removed\\n            memo[N][numCarpets] = max(used,notused)\\n            return memo[N][numCarpets]\\n\\t\\t\\n\\t\\t#Total White tiles\\n        ones = 0\\n        for x in floor:\\n            if x == \\'1\\':\\n                ones+=1\\n        \\n\\t\\t#Using Prefix array to store number of ones till i th index\\n        prefix = [0]*(n+1)\\n        for i in range(1,n+1):\\n            if floor[i-1]==\\'1\\':\\n                prefix[i] = prefix[i-1]+1\\n            else:\\n                prefix[i] = prefix[i-1]\\n\\t\\t\\t\\t\\n       \\n        removed = solve(0,numCarpets)\\n        \\n        return ones-removed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889364,
                "title": "dynamic-programming-based-solution-recursion-memoization-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int min(int a, int b)\\n    {\\n        if(a<b) return a;\\n        return b;\\n    }\\n    \\n    int func(string &floor, int numCarpets, int &carpetLen, int i, vector<int> &prefix)\\n    {\\n        //Base Cases\\n        if(i>=floor.size())\\n            return 0;\\n        if(numCarpets==0)\\n            return 0;\\n        \\n        //Memoization\\n        if(dp[i][numCarpets]!=-1)\\n            return dp[i][numCarpets];\\n        \\n        //Check if current tile is black, if it is then skip it\\n        if(floor[i]==\\'0\\')\\n            return dp[i][numCarpets]=func(floor, numCarpets, carpetLen, i+1, prefix);\\n        \\n        //temp stores the value of index where pointer i should point after the carpet covers white tiles \\n        //sometimes i+len can place you out of scope of prefix array that\\'s why floor.size() is also considered\\n        int temp=min(i+carpetLen, floor.size())-1;\\n        int white=prefix[temp];\\n        if(i!=0) // i==0 is not fit for this condition(no elements before index 0)\\n            white-=prefix[i-1]; // this line gives exact number of white tiles in between(covered by carpet)\\n        /*Suppose 1 0 1 1 0 1 0 1 is the input floor array and carpetLen =2. Prefix array would be 1 1 2 3 3 4 4 5.\\n        Let us suppose  i=2 then \\n        temp=i+carpetLen-1 temp=2+2-1 temp=4-1 temp=3  \\n        white=prefix[temp] white=prefix[3] white=3 \\n        white=white-prefix[i-1]= white=3-prefix[2-1]= white=3-prefix[1] white=3-1 white=2*/\\n        \\n        \\n        int pick=white+func(floor,numCarpets-1,carpetLen, i+carpetLen, prefix); //when you use a new carpet from the current index\\n        int notpick=func(floor,numCarpets,carpetLen, i+1, prefix); //when you dont use a new carpet from the current index\\n        \\n        return dp[i][numCarpets]=max(pick, notpick); //maximum number of white tiles that can be covered by the carpet\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        //for faster i/p o/p\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        //prefix array is used to store total number of white tiles till current index\\n        vector<int>prefix(floor.size()); \\n        if(floor[0]==\\'1\\')\\n            prefix[0]=1;\\n        else\\n            prefix[0]=0;\\n        \\n        for(int i=1; i<floor.size(); i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        \\n        if(prefix[floor.size()-1]==0)\\n            return 0;\\n        \\n        // minimum number of white tiles still visible = total number of white tiles - maximum number of white tiles that can be covered by the carpet\\n        return prefix[floor.size()-1]-func(floor, numCarpets, carpetLen, 0, prefix); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int min(int a, int b)\\n    {\\n        if(a<b) return a;\\n        return b;\\n    }\\n    \\n    int func(string &floor, int numCarpets, int &carpetLen, int i, vector<int> &prefix)\\n    {\\n        //Base Cases\\n        if(i>=floor.size())\\n            return 0;\\n        if(numCarpets==0)\\n            return 0;\\n        \\n        //Memoization\\n        if(dp[i][numCarpets]!=-1)\\n            return dp[i][numCarpets];\\n        \\n        //Check if current tile is black, if it is then skip it\\n        if(floor[i]==\\'0\\')\\n            return dp[i][numCarpets]=func(floor, numCarpets, carpetLen, i+1, prefix);\\n        \\n        //temp stores the value of index where pointer i should point after the carpet covers white tiles \\n        //sometimes i+len can place you out of scope of prefix array that\\'s why floor.size() is also considered\\n        int temp=min(i+carpetLen, floor.size())-1;\\n        int white=prefix[temp];\\n        if(i!=0) // i==0 is not fit for this condition(no elements before index 0)\\n            white-=prefix[i-1]; // this line gives exact number of white tiles in between(covered by carpet)\\n        /*Suppose 1 0 1 1 0 1 0 1 is the input floor array and carpetLen =2. Prefix array would be 1 1 2 3 3 4 4 5.\\n        Let us suppose  i=2 then \\n        temp=i+carpetLen-1 temp=2+2-1 temp=4-1 temp=3  \\n        white=prefix[temp] white=prefix[3] white=3 \\n        white=white-prefix[i-1]= white=3-prefix[2-1]= white=3-prefix[1] white=3-1 white=2*/\\n        \\n        \\n        int pick=white+func(floor,numCarpets-1,carpetLen, i+carpetLen, prefix); //when you use a new carpet from the current index\\n        int notpick=func(floor,numCarpets,carpetLen, i+1, prefix); //when you dont use a new carpet from the current index\\n        \\n        return dp[i][numCarpets]=max(pick, notpick); //maximum number of white tiles that can be covered by the carpet\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        //for faster i/p o/p\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        //prefix array is used to store total number of white tiles till current index\\n        vector<int>prefix(floor.size()); \\n        if(floor[0]==\\'1\\')\\n            prefix[0]=1;\\n        else\\n            prefix[0]=0;\\n        \\n        for(int i=1; i<floor.size(); i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        \\n        if(prefix[floor.size()-1]==0)\\n            return 0;\\n        \\n        // minimum number of white tiles still visible = total number of white tiles - maximum number of white tiles that can be covered by the carpet\\n        return prefix[floor.size()-1]-func(floor, numCarpets, carpetLen, 0, prefix); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863869,
                "title": "python3-dp-accepted-is-my-runtime-analysis-correct-o-2-n",
                "content": "Below is accepted.\\n\\nI struggle with figuring out runtime for DP problems, can someone help? \\nIs it O(2^N)? My reasoning being that at each backtrack calll, you either cover the piano, or you don\\'t. That\\'s 2 choices with at most N steps/piano tiles.\\n\\nAlso what would be the best way to manually memoize the results without using @lru_cache here?\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets * carpetLen >= len(floor):\\n            return 0\\n        \\n        white_to_right = [0] * len(floor)\\n        for i in range(len(floor)-1, -1, -1):\\n            if i == len(floor) - 1:\\n                white_to_right[i] = 1 if floor[i] == \\'1\\' else 0\\n            else:\\n                white_to_right[i] = white_to_right[i+1]\\n                white_to_right[i] += 1 if floor[i] == \\'1\\' else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def backtrack(index, remaining):\\n            if index >= len(floor):\\n                return 0\\n            \\n            if remaining == 0:\\n                return white_to_right[index]\\n            \\n            # cover carpet starting at this index\\n            cover_now = backtrack(index + carpetLen, remaining - 1)\\n\\n            # no-op, cover at next index\\n            cover_later = backtrack(index + 1, remaining)\\n            cover_later += 1 if floor[index] == \\'1\\' else 0\\n            \\n            return min(cover_now, cover_later)\\n\\n        return backtrack(0, numCarpets)\\n\\n",
                "solutionTags": [],
                "code": "Below is accepted.\\n\\nI struggle with figuring out runtime for DP problems, can someone help? \\nIs it O(2^N)? My reasoning being that at each backtrack calll, you either cover the piano, or you don\\'t. That\\'s 2 choices with at most N steps/piano tiles.\\n\\nAlso what would be the best way to manually memoize the results without using @lru_cache here?\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets * carpetLen >= len(floor):\\n            return 0\\n        \\n        white_to_right = [0] * len(floor)\\n        for i in range(len(floor)-1, -1, -1):\\n            if i == len(floor) - 1:\\n                white_to_right[i] = 1 if floor[i] == \\'1\\' else 0\\n            else:\\n                white_to_right[i] = white_to_right[i+1]\\n                white_to_right[i] += 1 if floor[i] == \\'1\\' else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def backtrack(index, remaining):\\n            if index >= len(floor):\\n                return 0\\n            \\n            if remaining == 0:\\n                return white_to_right[index]\\n            \\n            # cover carpet starting at this index\\n            cover_now = backtrack(index + carpetLen, remaining - 1)\\n\\n            # no-op, cover at next index\\n            cover_later = backtrack(index + 1, remaining)\\n            cover_later += 1 if floor[index] == \\'1\\' else 0\\n            \\n            return min(cover_now, cover_later)\\n\\n        return backtrack(0, numCarpets)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1985493,
                "title": "c-0-1-knapsack",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][1001];\\n    int solve(string& floor,int idx,int n,int car,int len,vector<int>&prefix)\\n    {\\n        if(idx==n || car==0)\\n            return 0;\\n        \\n        if(dp[idx][car]!=-1)\\n            return dp[idx][car];\\n        \\n        int range=min(idx+len-1,n-1);\\n        int cnt=prefix[range];\\n        \\n        if(idx>0)\\n            cnt-=prefix[idx-1];\\n        \\n        int pick=cnt+solve(floor,min(idx+len,n),n,car-1,len,prefix);\\n        int skip=solve(floor,idx+1,n,car,len,prefix);\\n        return dp[idx][car]=max(pick,skip);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int Carpet, int carpetLen) {       \\n        \\n        memset(dp,-1,sizeof dp);\\n        int n=floor.size();\\n        vector<int>prefix(n,0);\\n        int cnt=0;\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(floor[i]==\\'1\\')\\n                cnt++;\\n            \\n            prefix[i]=cnt;\\n        \\n        }\\n        return cnt-solve(floor,0,floor.size(),Carpet,carpetLen,prefix);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][1001];\\n    int solve(string& floor,int idx,int n,int car,int len,vector<int>&prefix)\\n    {\\n        if(idx==n || car==0)\\n            return 0;\\n        \\n        if(dp[idx][car]!=-1)\\n            return dp[idx][car];\\n        \\n        int range=min(idx+len-1,n-1);\\n        int cnt=prefix[range];\\n        \\n        if(idx>0)\\n            cnt-=prefix[idx-1];\\n        \\n        int pick=cnt+solve(floor,min(idx+len,n),n,car-1,len,prefix);\\n        int skip=solve(floor,idx+1,n,car,len,prefix);\\n        return dp[idx][car]=max(pick,skip);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int Carpet, int carpetLen) {       \\n        \\n        memset(dp,-1,sizeof dp);\\n        int n=floor.size();\\n        vector<int>prefix(n,0);\\n        int cnt=0;\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(floor[i]==\\'1\\')\\n                cnt++;\\n            \\n            prefix[i]=cnt;\\n        \\n        }\\n        return cnt-solve(floor,0,floor.size(),Carpet,carpetLen,prefix);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880725,
                "title": "java-top-down-dynamic-programming-memoization",
                "content": "Solution:\\n```\\nclass Solution {\\n    Map<String, Integer> cache;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        cache = new HashMap<>();\\n        return helper(floor, 0, numCarpets, carpetLen);\\n    }\\n    \\n    public int helper(String floor, int position, int numCarpets, int carpetLen) {\\n        if (position >= floor.length()) {\\n            return 0;\\n        }\\n        \\n        if (floor.length() - position <= numCarpets * carpetLen) {\\n            return 0;\\n        }\\n        \\n        String key = position + \", \" + numCarpets;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        if (numCarpets == 0) {\\n            int output = floor.charAt(position) - \\'0\\' + helper(floor, position + 1, 0, carpetLen);\\n            \\n            cache.put(key, output);\\n            return output;\\n        }\\n        \\n        int output = Math.min(floor.charAt(position) - \\'0\\' + helper(floor, position + 1, numCarpets, carpetLen), helper(floor, position + carpetLen, numCarpets - 1, carpetLen));\\n        \\n        cache.put(key, output);\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> cache;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        cache = new HashMap<>();\\n        return helper(floor, 0, numCarpets, carpetLen);\\n    }\\n    \\n    public int helper(String floor, int position, int numCarpets, int carpetLen) {\\n        if (position >= floor.length()) {\\n            return 0;\\n        }\\n        \\n        if (floor.length() - position <= numCarpets * carpetLen) {\\n            return 0;\\n        }\\n        \\n        String key = position + \", \" + numCarpets;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        if (numCarpets == 0) {\\n            int output = floor.charAt(position) - \\'0\\' + helper(floor, position + 1, 0, carpetLen);\\n            \\n            cache.put(key, output);\\n            return output;\\n        }\\n        \\n        int output = Math.min(floor.charAt(position) - \\'0\\' + helper(floor, position + 1, numCarpets, carpetLen), helper(floor, position + carpetLen, numCarpets - 1, carpetLen));\\n        \\n        cache.put(key, output);\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877103,
                "title": "dynamic-programming-based-solution-recursion-memoization-c-clean-code",
                "content": "# Code :\\n\\n```\\n class Solution {\\n    vector<int> whiteCount; // Stores no. of white tiles from ith index till the end\\n    \\n\\t// Count number of white tile from index till end \\n\\t// Suffix sum of no. of white tiles\\n    void countTiles(string& floor, int n) {\\n        whiteCount.resize(n+2, 0);\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            whiteCount[i] = whiteCount[i+1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int uncoveredWhiteTiles(string& floor, vector<vector<int>>& dp, int numCarpets, int idx, int carpetLen, int n) {\\n        \\n\\t\\t// If we reach the end, then no white is remaining\\n\\t\\t// Assuming that all previous white tiles are covered already using carpets\\n        if(idx >= n) {\\n            return 0;\\n        }\\n\\t\\t// If no carpet is available, then all the white tiles from current index\\n\\t\\t// Till the end are uncovered. Hence return its count\\n        if(numCarpets == 0) {\\n            return whiteCount[idx];\\n        }\\n        \\n\\t\\t// If we have some value for current state in DP table, then return it\\n        if(dp[idx][numCarpets] != -1) return dp[idx][numCarpets];\\n        \\n        int countWhites = n;\\n        \\n        // We have two choices at this point\\n\\t\\t// Choice 1 : Use a carpet starting from current index till carpetLen\\n\\t\\t// Choice 2 : Do no use any carpet, and move to next index. \\n\\t\\t// But if current tile is white then count it as uncovered\\n        countWhites = min(\\n            uncoveredWhiteTiles(floor, dp, numCarpets-1, idx+carpetLen, carpetLen, n),\\n            uncoveredWhiteTiles(floor, dp, numCarpets, idx+1, carpetLen, n) + (floor[idx] == \\'1\\')\\n        );\\n        \\n\\t\\t// Return minimum count of uncovered white tiles using one of the two choices\\n        return dp[idx][numCarpets] = countWhites;\\n    }\\n    \\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        countTiles(floor, n);\\n        vector<vector<int>> dp(n+1, vector<int>(numCarpets+1, -1));\\n         \\n        return uncoveredWhiteTiles(floor, dp, numCarpets, 0, carpetLen, n);\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N*M)` \\n* Space : `O(N*M)`\\n\\t* N : length of `floor` string\\n\\t* M : number of carpets available\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n    vector<int> whiteCount; // Stores no. of white tiles from ith index till the end\\n    \\n\\t// Count number of white tile from index till end \\n\\t// Suffix sum of no. of white tiles\\n    void countTiles(string& floor, int n) {\\n        whiteCount.resize(n+2, 0);\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            whiteCount[i] = whiteCount[i+1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int uncoveredWhiteTiles(string& floor, vector<vector<int>>& dp, int numCarpets, int idx, int carpetLen, int n) {\\n        \\n\\t\\t// If we reach the end, then no white is remaining\\n\\t\\t// Assuming that all previous white tiles are covered already using carpets\\n        if(idx >= n) {\\n            return 0;\\n        }\\n\\t\\t// If no carpet is available, then all the white tiles from current index\\n\\t\\t// Till the end are uncovered. Hence return its count\\n        if(numCarpets == 0) {\\n            return whiteCount[idx];\\n        }\\n        \\n\\t\\t// If we have some value for current state in DP table, then return it\\n        if(dp[idx][numCarpets] != -1) return dp[idx][numCarpets];\\n        \\n        int countWhites = n;\\n        \\n        // We have two choices at this point\\n\\t\\t// Choice 1 : Use a carpet starting from current index till carpetLen\\n\\t\\t// Choice 2 : Do no use any carpet, and move to next index. \\n\\t\\t// But if current tile is white then count it as uncovered\\n        countWhites = min(\\n            uncoveredWhiteTiles(floor, dp, numCarpets-1, idx+carpetLen, carpetLen, n),\\n            uncoveredWhiteTiles(floor, dp, numCarpets, idx+1, carpetLen, n) + (floor[idx] == \\'1\\')\\n        );\\n        \\n\\t\\t// Return minimum count of uncovered white tiles using one of the two choices\\n        return dp[idx][numCarpets] = countWhites;\\n    }\\n    \\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        countTiles(floor, n);\\n        vector<vector<int>> dp(n+1, vector<int>(numCarpets+1, -1));\\n         \\n        return uncoveredWhiteTiles(floor, dp, numCarpets, 0, carpetLen, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874969,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7e91381aab0f51486f380f703245463c99fed635) for solutions of biweekly 74. \\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        @cache\\n        def fn(i, n):\\n            \"\"\"Return min while tiles at k with n carpets left.\"\"\"\\n            if n < 0: return inf \\n            if i >= len(floor): return 0 \\n            if floor[i] == \\'1\\': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))\\n            return fn(i+1, n)\\n        \\n        return fn(0, numCarpets)\\n```\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = [[0]*(1 + numCarpets) for _ in range(len(floor)+1)]\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(0, numCarpets+1): \\n                if floor[i] == \\'1\\': \\n                    dp[i][j] = 1 + dp[i+1][j] \\n                    if j: \\n                        if i+carpetLen >= len(floor): dp[i][j] = 0 \\n                        else: dp[i][j] = min(dp[i+carpetLen][j-1], dp[i][j])\\n                else: dp[i][j] = dp[i+1][j]\\n        return dp[0][numCarpets]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        @cache\\n        def fn(i, n):\\n            \"\"\"Return min while tiles at k with n carpets left.\"\"\"\\n            if n < 0: return inf \\n            if i >= len(floor): return 0 \\n            if floor[i] == \\'1\\': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))\\n            return fn(i+1, n)\\n        \\n        return fn(0, numCarpets)\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = [[0]*(1 + numCarpets) for _ in range(len(floor)+1)]\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(0, numCarpets+1): \\n                if floor[i] == \\'1\\': \\n                    dp[i][j] = 1 + dp[i+1][j] \\n                    if j: \\n                        if i+carpetLen >= len(floor): dp[i][j] = 0 \\n                        else: dp[i][j] = min(dp[i+carpetLen][j-1], dp[i][j])\\n                else: dp[i][j] = dp[i+1][j]\\n        return dp[0][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866410,
                "title": "java-solution-100-faster-using-dp-tabulation",
                "content": "Explatation in comments.\\nPlease **Upvote** if you undrstand this.\\n...\\nclass Solution {\\n\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n\\t\\n\\t\\tchar[] arr = floor.toCharArray();\\n\\t\\t\\n\\t\\tint n = arr.length;\\n\\t\\t//using dp\\n\\t\\t\\n\\t\\tint[][] dp = new int[numCarpets + 1][n + 1];\\n\\t\\t//dp[i][j] -> no of whites in arr(0, i) when j carpet is used\\n\\t\\t//row -> number of carpets\\n\\t\\t//columns -> arr / floor\\n        \\n        for(int i = 0; i <= numCarpets; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(i == 0)\\n                    dp[i][j] = dp[i][j - 1] + (arr[j - 1] - \\'0\\');\\n                else if(j <= carpetLen)//cover all floor\\n                    dp[i][j] = 0;\\n                else{\\n                    int w = Math.min(dp[i - 1][j - carpetLen], dp[i - 1][j]);\\n                    //minimum no of whites if only j - 1 carpet is used already\\n\\t\\t\\t\\t\\t//we want to minimize whites by using or not using jth carpet\\n                    \\n                    //dp[i][j - 1] -> minimum no of moves if we used i carpets already\\n\\t\\t\\t\\t\\t//arr[j - 1] - \\'0\\' -> adds white count for j - 1 th char\\n\\t\\t\\t\\t\\t\\n                    int min = Math.min(w, dp[i][j - 1] + (arr[j - 1] - \\'0\\'));\\n                    //minimum whites in any case\\n                    \\n                    dp[i][j] = min;//update\\n                }\\n            }\\n        }\\n        \\n        return dp[numCarpets][n];\\n    }\\n}\\n...",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n\\t\\n\\t\\tchar[] arr = floor.toCharArray();\\n\\t\\t\\n\\t\\tint n = arr.length;\\n\\t\\t//using dp\\n\\t\\t\\n\\t\\tint[][] dp = new int[numCarpets + 1][n + 1];\\n\\t\\t//dp[i][j] -> no of whites in arr(0, i) when j carpet is used\\n\\t\\t//row -> number of carpets\\n\\t\\t//columns -> arr / floor\\n        \\n        for(int i = 0; i <= numCarpets; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(i == 0)\\n                    dp[i][j] = dp[i][j - 1] + (arr[j - 1] - \\'0\\');\\n                else if(j <= carpetLen)//cover all floor\\n                    dp[i][j] = 0;\\n                else{\\n                    int w = Math.min(dp[i - 1][j - carpetLen], dp[i - 1][j]);\\n                    //minimum no of whites if only j - 1 carpet is used already\\n\\t\\t\\t\\t\\t//we want to minimize whites by using or not using jth carpet\\n                    \\n                    //dp[i][j - 1] -> minimum no of moves if we used i carpets already\\n\\t\\t\\t\\t\\t//arr[j - 1] - \\'0\\' -> adds white count for j - 1 th char\\n\\t\\t\\t\\t\\t\\n                    int min = Math.min(w, dp[i][j - 1] + (arr[j - 1] - \\'0\\'));\\n                    //minimum whites in any case\\n                    \\n                    dp[i][j] = min;//update\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1866351,
                "title": "simple-solution-in-java-concise-and-elegant-with-memoization",
                "content": "```\\nclass Solution {\\n    private int[][] dp;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        this.dp = new int[floor.length()+1][numCarpets+1];\\n        for(int i=0; i<floor.length(); i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        char[] str = floor.toCharArray();\\n        return find(0, str, numCarpets, carpetLen);\\n    }\\n    \\n    // Find the minimum number of white tiles visible\\n    private int find(int index, char[] floor, int numCarpets, int carpetLen){\\n        if(numCarpets < 0) return Integer.MAX_VALUE;\\n        if(index >= floor.length) return 0;\\n        \\n        if(dp[index][numCarpets] != -1){\\n            return dp[index][numCarpets];\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        // If current tile is black, move to the next\\n        if(floor[index] == \\'0\\'){\\n            min = find(index+1, floor, numCarpets, carpetLen);\\n        }\\n        \\n        // If current tile is white, two options, cover the current white tile or not \\n        if(floor[index] == \\'1\\'){\\n            min = Math.min(min, find(index + carpetLen, floor, numCarpets - 1, carpetLen));\\n            min = Math.min(min, 1 + find(index + 1, floor, numCarpets, carpetLen));\\n        }\\n        \\n        dp[index][numCarpets] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] dp;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        this.dp = new int[floor.length()+1][numCarpets+1];\\n        for(int i=0; i<floor.length(); i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        char[] str = floor.toCharArray();\\n        return find(0, str, numCarpets, carpetLen);\\n    }\\n    \\n    // Find the minimum number of white tiles visible\\n    private int find(int index, char[] floor, int numCarpets, int carpetLen){\\n        if(numCarpets < 0) return Integer.MAX_VALUE;\\n        if(index >= floor.length) return 0;\\n        \\n        if(dp[index][numCarpets] != -1){\\n            return dp[index][numCarpets];\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        // If current tile is black, move to the next\\n        if(floor[index] == \\'0\\'){\\n            min = find(index+1, floor, numCarpets, carpetLen);\\n        }\\n        \\n        // If current tile is white, two options, cover the current white tile or not \\n        if(floor[index] == \\'1\\'){\\n            min = Math.min(min, find(index + carpetLen, floor, numCarpets - 1, carpetLen));\\n            min = Math.min(min, 1 + find(index + 1, floor, numCarpets, carpetLen));\\n        }\\n        \\n        dp[index][numCarpets] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864848,
                "title": "c-dynamic-programing-solution-time-o-n-2-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int n, int k) {\\n        \\n        int m= a.size();\\n        \\n        vector<int> v(m+1,0),h;\\n        \\n        v[0] = 0;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            v[i] = v[i-1];\\n            if(a[i-1]==\\'1\\')\\n                v[i]++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            h = v;\\n            v[0] = 0;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(a[j-1]==\\'1\\')\\n                {   \\n                    if(j>=k)\\n                        v[j] = min(h[j-k],v[j-1]+1);\\n                    else\\n                        v[j] = 0;\\n                }\\n                else\\n                    v[j] = v[j-1];\\n            }\\n        } \\n        \\n        return v[m];\\n         \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int n, int k) {\\n        \\n        int m= a.size();\\n        \\n        vector<int> v(m+1,0),h;\\n        \\n        v[0] = 0;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            v[i] = v[i-1];\\n            if(a[i-1]==\\'1\\')\\n                v[i]++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            h = v;\\n            v[0] = 0;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(a[j-1]==\\'1\\')\\n                {   \\n                    if(j>=k)\\n                        v[j] = min(h[j-k],v[j-1]+1);\\n                    else\\n                        v[j] = 0;\\n                }\\n                else\\n                    v[j] = v[j-1];\\n            }\\n        } \\n        \\n        return v[m];\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864331,
                "title": "python-dp-inspired-by-kadane-algo-and-buy-sell-stock-iv",
                "content": "I. Intuition:\\nThe key idea is that we find the maximum tiles can be covered with one carpet (at a time).\\n\\nFor the example:\\n`floor = \"10110101\"`\\n`numCarpets=2`\\n`carpetLen=2`\\n\\nWith numCapets = 2, that means we will have 2 carpets to use. \\nFirst, we find the maximum tiles that the first carpet can cover.\\n`dp[first_carpet] = [0, 1, 1, 1, 2, 2, 2, 2, 2]`\\nWe can say that at the end of 9th floor, with one carpet, we can cover at most 2 tiles. Now we store the maximum tiles can be covered with one carpet in `prev_state`\\nSecond, we now need to find the maxmimum tiles that the second carpet can cover. Then we take the sum of max tiles that the first carpet cover with the max tiles that the second carpet can cover. \\n`dp[second_carpet] = [0, 1, 1, 2, 3, 3, 3, 3, 3]`\\n\\nII. Resources:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solution/627971\\n\\nIII. Code:\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n \\n        updated_floor = [0]*(len(floor)+1)\\n        running = 0\\n        for index, tiles in enumerate(floor):\\n            if tiles == \\'1\\':\\n                running += 1\\n            updated_floor[index+1] = running\\n  \\n        prev_state = [0]*(len(floor)+1)\\n        for i in range(numCarpets):\\n            dp = [0]*(len(floor)+1)\\n            for j in range(len(dp)-1):\\n                if floor[j] == \\'1\\':\\n                    \\n                    dp[j+1] = max(prev_state[j+1], prev_state[max(j+1-carpetLen, 0)] + updated_floor[j+1]-updated_floor[max(j+1-carpetLen, 0)], dp[j])\\n                    \\n                else:\\n                    dp[j+1] = max(prev_state[j+1], dp[j])\\n                    \\n            prev_state = dp\\n   \\n        return updated_floor[-1] - dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n \\n        updated_floor = [0]*(len(floor)+1)\\n        running = 0\\n        for index, tiles in enumerate(floor):\\n            if tiles == \\'1\\':\\n                running += 1\\n            updated_floor[index+1] = running\\n  \\n        prev_state = [0]*(len(floor)+1)\\n        for i in range(numCarpets):\\n            dp = [0]*(len(floor)+1)\\n            for j in range(len(dp)-1):\\n                if floor[j] == \\'1\\':\\n                    \\n                    dp[j+1] = max(prev_state[j+1], prev_state[max(j+1-carpetLen, 0)] + updated_floor[j+1]-updated_floor[max(j+1-carpetLen, 0)], dp[j])\\n                    \\n                else:\\n                    dp[j+1] = max(prev_state[j+1], dp[j])\\n                    \\n            prev_state = dp\\n   \\n        return updated_floor[-1] - dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864235,
                "title": "neat-and-clean-recursion-memoization-easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    string s;\\n    int n;\\n    int prefix[1001];\\n    int len;\\n    int dp[1001][1001];\\n    int solve(int index, int carpet) {\\n        if(carpet <= 0 || index >= n)\\n            return 0;\\n        if(dp[index][carpet] != -1)\\n            return dp[index][carpet];\\n        int x = 0;\\n        if(index)\\n            x = prefix[index - 1];\\n        int y = prefix[min(index + len - 1, n)];\\n        return dp[index][carpet] = max(solve(index + 1, carpet), y - x + solve(index + len, carpet - 1));\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        s = floor;\\n        n = s.length();\\n        len = carpetLen;\\n        memset(dp, -1, sizeof(dp));\\n        prefix[0] = (s[0] == \\'1\\');\\n        for(int i = 1; i < n; ++i)\\n            prefix[i] = prefix[i-1] + (s[i] == \\'1\\');\\n        prefix[n] = prefix[n-1];\\n        int ans = solve(0, numCarpets);\\n        return max(0, prefix[n] - ans);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    string s;\\n    int n;\\n    int prefix[1001];\\n    int len;\\n    int dp[1001][1001];\\n    int solve(int index, int carpet) {\\n        if(carpet <= 0 || index >= n)\\n            return 0;\\n        if(dp[index][carpet] != -1)\\n            return dp[index][carpet];\\n        int x = 0;\\n        if(index)\\n            x = prefix[index - 1];\\n        int y = prefix[min(index + len - 1, n)];\\n        return dp[index][carpet] = max(solve(index + 1, carpet), y - x + solve(index + len, carpet - 1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1864225,
                "title": "python3-simple-bottom-up-dp-solution",
                "content": "```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for k in range(1, numCarpets+1):\\n            for i in range(1, n+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[-1][numCarpets]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for k in range(1, numCarpets+1):\\n            for i in range(1, n+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[-1][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864167,
                "title": "classical-dp-memoization-similiar-to-0-1-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pre;\\n    int n;\\n    vector<vector<int>> dp;\\n    int fun(int i,string &f,int nc,int len){\\n        \\n        if(i >= n) return 0;\\n        if(nc == 0){\\n            return pre[n-1] - (i == 0 ? 0 : pre[i-1]);\\n        }\\n        if(dp[i][nc] != -1) return dp[i][nc];\\n        int left = fun(i+len,f,nc-1,len);\\n        int right = (f[i] == \\'1\\' ? 1 : 0) + fun(i+1,f,nc,len);\\n        \\n        return dp[i][nc] = min(left,right);\\n        \\n    }\\n    int minimumWhiteTiles(string f, int nc, int len) {\\n        \\n        n = f.size();\\n        pre = vector<int> (n);\\n        dp = vector<vector<int>> (n,vector<int> (nc+1,-1));\\n        pre[0] = (f[0] == \\'1\\' ? 1 : 0);\\n        for(int i=1;i<n;i++){\\n            pre[i] = (f[i] == \\'1\\' ? 1 : 0) + pre[i-1];\\n        }\\n        \\n        return fun(0,f,nc,len);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pre;\\n    int n;\\n    vector<vector<int>> dp;\\n    int fun(int i,string &f,int nc,int len){\\n        \\n        if(i >= n) return 0;\\n        if(nc == 0){\\n            return pre[n-1] - (i == 0 ? 0 : pre[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1864077,
                "title": "problem-analysis-with-formula-dynamic-programming-tabulation-approach",
                "content": "## At first glance\\n\\nLet\\'s analyze the problem at hand before writing the code. We are given the following inputs:\\n\\n - **Floor**, which is a string of characters `0` and `1` only.\\n\\t - **0** denotes a black tile.\\n\\t - **1** denotes a white tile.\\n - **Number of Carpets**, the number of carpets we can place.\\n - **Length of Carpet**, the range of a carpet to make everything black.\\n\\nThe problem is about *minimizing* the number of white tiles. Note the keyword \\'minimizing\\', which already tells us that this is going to be an optimization problem. You might have guessed it, dynamic programming is the answer to this problem. In specific, we will be using the *tabulation* approach.\\n\\n<br>\\n\\n## Problem Analysis\\n\\n*Note*: From this point forward, we will be referring the **Number of Carpets** as **R** (remaining carpets), **Length of Carpet** as **L** and the **Floor** as **F**.\\n\\nIn order to find minimum number of white tile possible, we need to find the optimal formula for minimizing the white tile count. After further inspection, we can see that at any index ***i***, we have two possible options:\\n\\n - Place a carpet on index ***i***, if and only if **R > 0**.\\n - Skip the current index.\\n\\nThis gives us the following optimal formula (denoted as ***opt***):\\n\\n![image](https://assets.leetcode.com/users/images/2145aad6-6484-40c5-b3f2-e352decf6ff4_1647705757.213423.png)\\n\\n## Implementation\\n\\nA reference implementation in C++ is given below:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int L) {\\n        vector<vector<int>> opt(floor.size() + 1, vector<int>(numCarpets + 1, 0));\\n\\n        for (int i = (int) floor.size() - 1; i >= 0; i--) {\\n            int F_i = floor[i] - \\'0\\';\\n\\n            for (int R = 0; R <= numCarpets; R++) {\\n\\n                if (R == 0)\\n                    opt[i][R] = F_i + opt[i + 1][R];\\n                else if (i + L >= floor.size())\\n                    opt[i][R] = 0;\\n                else\\n                    opt[i][R] = min(F_i + opt[i + 1][R], opt[i + L][R - 1]);\\n            }\\n        }\\n\\n        return opt[0][numCarpets];\\n    }\\n};\\n```\\n\\nThis runs in **pseudo-polynomial time O(|F| \\xD7 R)** and has a space complexity **O(|F| \\xD7 R)**. Note that this is *not polynomial*, but [pseudo-polynomial](https://en.wikipedia.org/wiki/Pseudo-polynomial_time).\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int L) {\\n        vector<vector<int>> opt(floor.size() + 1, vector<int>(numCarpets + 1, 0));\\n\\n        for (int i = (int) floor.size() - 1; i >= 0; i--) {\\n            int F_i = floor[i] - \\'0\\';\\n\\n            for (int R = 0; R <= numCarpets; R++) {\\n\\n                if (R == 0)\\n                    opt[i][R] = F_i + opt[i + 1][R];\\n                else if (i + L >= floor.size())\\n                    opt[i][R] = 0;\\n                else\\n                    opt[i][R] = min(F_i + opt[i + 1][R], opt[i + L][R - 1]);\\n            }\\n        }\\n\\n        return opt[0][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864073,
                "title": "c-simple-recursive-memoization-easy-to-think-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minCover(string& s, int index, int numCarpets, int len){\\n        if(index >= s.length())     // if index >= s.length(), then there is no tiles present.\\n            return 0;\\n        if(dp[index][numCarpets] != -1)     // State of the dp is represented by current index and no of Carpets remaining\\n            return dp[index][numCarpets];\\n        int res1 = INT_MAX;\\n        if(numCarpets > 0)\\n            res1 = minCover(s, index + len, numCarpets-1, len);     // If carpet is still remaining, we can try covering tiles in the range [index, index + len - 1]\\n        int res2 = minCover(s, index+1, numCarpets, len);       // finding min no of white tiles visible if we doesn\\'t cover the tile on this particular index\\n        if(s[index] == \\'1\\')                 // white tile present at index, so if we don\\'t cover those tile, then add corresponding count to res2\\n            res2++;\\n        return dp[index][numCarpets] = min(res1, res2);   // finally we choose the minimum from the above two case\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length(), vector<int>(numCarpets+1, -1));\\n        return minCover(floor, 0, numCarpets, carpetLen);\\n    }\\n};\\n```\\n***If you find this helpful, please show some love in the form of upvote***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minCover(string& s, int index, int numCarpets, int len){\\n        if(index >= s.length())     // if index >= s.length(), then there is no tiles present.\\n            return 0;\\n        if(dp[index][numCarpets] != -1)     // State of the dp is represented by current index and no of Carpets remaining\\n            return dp[index][numCarpets];\\n        int res1 = INT_MAX;\\n        if(numCarpets > 0)\\n            res1 = minCover(s, index + len, numCarpets-1, len);     // If carpet is still remaining, we can try covering tiles in the range [index, index + len - 1]\\n        int res2 = minCover(s, index+1, numCarpets, len);       // finding min no of white tiles visible if we doesn\\'t cover the tile on this particular index\\n        if(s[index] == \\'1\\')                 // white tile present at index, so if we don\\'t cover those tile, then add corresponding count to res2\\n            res2++;\\n        return dp[index][numCarpets] = min(res1, res2);   // finally we choose the minimum from the above two case\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length(), vector<int>(numCarpets+1, -1));\\n        return minCover(floor, 0, numCarpets, carpetLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613914,
                "title": "python-top-down-dp-almost-one-liner",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, nums: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dfs(i, rem):\\n            return 0 if i >= len(nums) else min((1 if nums[i]==\\'1\\' else 0) + dfs(i+1, rem), dfs(i+carpetLen, rem-1) if rem and nums[i]==\\'1\\' else float(\\'inf\\'))\\n        \\n        return dfs(0, numCarpets)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, nums: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dfs(i, rem):\\n            return 0 if i >= len(nums) else min((1 if nums[i]==\\'1\\' else 0) + dfs(i+1, rem), dfs(i+carpetLen, rem-1) if rem and nums[i]==\\'1\\' else float(\\'inf\\'))\\n        \\n        return dfs(0, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191050,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(string &s, int num, int len, int i, vector<vector<int>>&dp){\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        if(num==0){\\n            int count = 0;\\n        for(int j = i; j<=s.length()-1;j++){\\n            if(s[j]==\\'1\\'){\\n                count++;\\n            }\\n\\n        } \\n                       return count;\\n        }\\n        if(dp[i][num]!=-1){\\n            return dp[i][num];\\n        }\\n        if(s[i]==\\'0\\'){\\n            return dp[i][num] = helper(s,num,len,i+1,dp);\\n        }\\n        int mn = i + len-1;\\n        if(mn >= s.length()){\\n            mn = s.length()-1;\\n        }\\n    \\n        return dp[i][num] = min(helper(s,num-1,len,i+len,dp),1+helper(s,num,len,i+1,dp));\\n    }\\n    \\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.length()+1, vector<int>(numCarpets+1,-1));\\n        return helper(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(string &s, int num, int len, int i, vector<vector<int>>&dp){\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        if(num==0){\\n            int count = 0;\\n        for(int j = i; j<=s.length()-1;j++){\\n            if(s[j]==\\'1\\'){\\n                count++;\\n            }\\n\\n        } \\n                       return count;\\n        }\\n        if(dp[i][num]!=-1){\\n            return dp[i][num];\\n        }\\n        if(s[i]==\\'0\\'){\\n            return dp[i][num] = helper(s,num,len,i+1,dp);\\n        }\\n        int mn = i + len-1;\\n        if(mn >= s.length()){\\n            mn = s.length()-1;\\n        }\\n    \\n        return dp[i][num] = min(helper(s,num-1,len,i+len,dp),1+helper(s,num,len,i+1,dp));\\n    }\\n    \\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.length()+1, vector<int>(numCarpets+1,-1));\\n        return helper(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153754,
                "title": "python-2-liner-using-lambda-function-and-lru-cache",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, x: str, n: int, cl: int) -> int:\\n        f=lru_cache(None)(lambda i,n: 0 if i>=len(x) else min((1 if x[i]==\\'1\\' else 0)+f(i+1,n),(inf if n==0 else f(i+cl,n-1))))\\n        return f(0,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, x: str, n: int, cl: int) -> int:\\n        f=lru_cache(None)(lambda i,n: 0 if i>=len(x) else min((1 if x[i]==\\'1\\' else 0)+f(i+1,n),(inf if n==0 else f(i+cl,n-1))))\\n        return f(0,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115070,
                "title": "c-dp-bottom-up-dp-similar-to-knapsack",
                "content": "Please upvote\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int len) {\\n        int n=floor.size();\\n        int x=numCarpets;\\n        floor=\\'#\\'+floor;//so that ith row of dp matches with the ith character\\n        vector<vector<int>> dp(n+1,vector<int>(x+1,0));\\n        dp[0][0]=0;\\n        for(int i=0;i<=x;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=n;i++){\\n            dp[i][0]=dp[i-1][0]+(floor[i]==\\'1\\');\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=x;j++){\\n                if(j>=1){\\n\\t\\t\\t\\t//if we have atleast 1 carpet or even more\\n\\t\\t\\t\\t//then we can use\\n\\t\\t\\t\\t//however before usuing at i also check if i-len>=0\\n                    if(i-len>=0){\\n                        dp[i][j]=min(dp[i-len][j-1],dp[i-1][j]+(floor[i]==\\'1\\'));\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t//if we do not have any carpet\\n                    dp[i][j]=dp[i-1][j]+(floor[i]==\\'1\\');\\n                }\\n            }\\n        }\\n        return dp[n][x];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int len) {\\n        int n=floor.size();\\n        int x=numCarpets;\\n        floor=\\'#\\'+floor;//so that ith row of dp matches with the ith character\\n        vector<vector<int>> dp(n+1,vector<int>(x+1,0));\\n        dp[0][0]=0;\\n        for(int i=0;i<=x;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=n;i++){\\n            dp[i][0]=dp[i-1][0]+(floor[i]==\\'1\\');\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=x;j++){\\n                if(j>=1){\\n\\t\\t\\t\\t//if we have atleast 1 carpet or even more\\n\\t\\t\\t\\t//then we can use\\n\\t\\t\\t\\t//however before usuing at i also check if i-len>=0\\n                    if(i-len>=0){\\n                        dp[i][j]=min(dp[i-len][j-1],dp[i-1][j]+(floor[i]==\\'1\\'));\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t//if we do not have any carpet\\n                    dp[i][j]=dp[i-1][j]+(floor[i]==\\'1\\');\\n                }\\n            }\\n        }\\n        return dp[n][x];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052637,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= numCarpets; j++) {\\n                if (floor.charAt(i - 1) == \\'1\\') dp[i][j] = dp[i - 1][j] + 1;\\n                else dp[i][j] = dp[i - 1][j];\\n                if (j > 0) dp[i][j] = Math.min(dp[i][j], dp[Math.max(0, i - carpetLen)][j - 1]);\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= numCarpets; j++) {\\n                if (floor.charAt(i - 1) == \\'1\\') dp[i][j] = dp[i - 1][j] + 1;\\n                else dp[i][j] = dp[i - 1][j];\\n                if (j > 0) dp[i][j] = Math.min(dp[i][j], dp[Math.max(0, i - carpetLen)][j - 1]);\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880957,
                "title": "scala",
                "content": "```\\nimport scala.math.min\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  private val Black = \\'0\\'\\n\\n  def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = floor\\n    .indices\\n    .zip(floor.map(_ - Black).scanRight(0)(_ + _))\\n    .toMap\\n    .withDefaultValue(0)\\n    .pipe { (1 to numCarpets)\\n      .foldLeft(_) { case (previousNumWhiteTiles, _) => floor\\n        .indices\\n        .foldRight(Map[Int, Int]().withDefaultValue(0)) { case (i, currentNumWhiteTiles) =>\\n          currentNumWhiteTiles + \\n            (i -> min(floor(i) - Black + currentNumWhiteTiles(i + 1), previousNumWhiteTiles(i + carpetLen)))\\n        }\\n      }\\n      .apply(0)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.math.min\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  private val Black = \\'0\\'\\n\\n  def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = floor\\n    .indices\\n    .zip(floor.map(_ - Black).scanRight(0)(_ + _))\\n    .toMap\\n    .withDefaultValue(0)\\n    .pipe { (1 to numCarpets)\\n      .foldLeft(_) { case (previousNumWhiteTiles, _) => floor\\n        .indices\\n        .foldRight(Map[Int, Int]().withDefaultValue(0)) { case (i, currentNumWhiteTiles) =>\\n          currentNumWhiteTiles + \\n            (i -> min(floor(i) - Black + currentNumWhiteTiles(i + 1), previousNumWhiteTiles(i + carpetLen)))\\n        }\\n      }\\n      .apply(0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1879842,
                "title": "java-simple-memiozation",
                "content": "```\\nclass Solution {\\n    int[] suff;\\n    Integer[][] dp;\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {    \\n        if (carpetLen == floor.length()) {\\n            return 0;\\n        }\\n        dp = new Integer[floor.length()][numCarpets + 1];\\n        //  suff[i] = number of white tiles in s[i....]\\n\\t\\tsuff = cumulative(floor);\\n        return helper(floor, numCarpets, carpetLen, 0);\\n    }\\n    \\n\\t//  normal suffix array\\n    public int[] cumulative(String s) {\\n        int[] suff = new int[s.length()];\\n        suff[s.length() - 1] = (s.charAt(s.length() - 1) == \\'0\\' ? 0 : 1);\\n        for (int i = s.length() - 2; i >= 0; i--) {\\n            suff[i] = suff[i + 1] + (s.charAt(i) == \\'0\\' ? 0 : 1);\\n        }\\n        return suff;\\n    }\\n    \\n    public int helper(String s, int n, int k, int idx) {\\n        \\n        //  no more floors remaining so no white carpets need to be covered\\n        if (idx >= s.length()) {\\n            return 0;\\n        }\\n        \\n        if (dp[idx][n] != null) {\\n            return dp[idx][n];\\n        }\\n        \\n        //  floors remaining but carpets exhausted\\n        if (n == 0) {\\n            return suff[idx];\\n        }\\n        \\n        //  this is already black skip this floor\\n        if (s.charAt(idx) == \\'0\\') {\\n            return helper(s, n, k, idx + 1);\\n        }\\n        \\n        //  now we have two choices whether to leave this white\\n        //  as it is or cover this in black\\n        \\n        \\n        //  if covering this and any other black floor in range as black\\n        int answer = helper(s, n - 1, k, idx + k);\\n        \\n        //  leaving this as white as it was\\n        answer = Math.min(answer, helper(s, n, k, idx + 1) + 1);\\n        return dp[idx][n] = answer;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] suff;\\n    Integer[][] dp;\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {    \\n        if (carpetLen == floor.length()) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1879319,
                "title": "why-my-bottom-up-code-is-giving-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    // int memo(int i, int j, vector<int>& pref, int cl,\\n    //          vector<vector<int>>& dp)\\n    // {\\n    //     if(i >= pref.size() || j <= 0)\\n    //         return 0;\\n    //     if(dp[i][j] != -1)\\n    //         return dp[i][j];\\n    //     else\\n    //     {\\n    //         dp[i][j] = max(memo(i+cl, j-1, pref, cl, dp)\\n    //                        + pref[i], \\n    //                        memo(i+1, j, pref, cl, dp));\\n    //     }\\n    //     return dp[i][j];\\n    // }\\n    int minimumWhiteTiles(string& f, int n, int cl) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        int tot = 0;\\n        for(auto x : f)\\n            if(x == \\'1\\')\\n                tot++;\\n        vector<int> pref(f.size(), 0);\\n        int x = f.size() - 1;\\n        for(int i = 0; i < cl; i++, x--)\\n        {\\n            if(x < f.size() - 1)\\n                pref[x] = pref[x+1];\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n        }\\n        int y = f.size() - 1;\\n        while(x >= 0)\\n        {\\n            pref[x] = pref[x+1];\\n            if(f[y] == \\'1\\')\\n                pref[x]--;\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n            x--;\\n            y--;\\n        }\\n        for(int i = 0; i <= f.size(); i++)\\n            dp[i][0] = 0;\\n        for(int j = 0; j <= n; j++)\\n            dp[f.size()][j] = 0;\\n        for(int i = f.size()-1; i >= 0; i--)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                dp[i][j] = max(dp[i+1][j],\\n                               dp[min(i+cl,int(f.size()-1))][j-1]\\n                               + pref[i]);\\n            }\\n        }\\n        return tot > dp[0][n] ? tot - dp[0][n] : 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int memo(int i, int j, vector<int>& pref, int cl,\\n    //          vector<vector<int>>& dp)\\n    // {\\n    //     if(i >= pref.size() || j <= 0)\\n    //         return 0;\\n    //     if(dp[i][j] != -1)\\n    //         return dp[i][j];\\n    //     else\\n    //     {\\n    //         dp[i][j] = max(memo(i+cl, j-1, pref, cl, dp)\\n    //                        + pref[i], \\n    //                        memo(i+1, j, pref, cl, dp));\\n    //     }\\n    //     return dp[i][j];\\n    // }\\n    int minimumWhiteTiles(string& f, int n, int cl) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        int tot = 0;\\n        for(auto x : f)\\n            if(x == \\'1\\')\\n                tot++;\\n        vector<int> pref(f.size(), 0);\\n        int x = f.size() - 1;\\n        for(int i = 0; i < cl; i++, x--)\\n        {\\n            if(x < f.size() - 1)\\n                pref[x] = pref[x+1];\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n        }\\n        int y = f.size() - 1;\\n        while(x >= 0)\\n        {\\n            pref[x] = pref[x+1];\\n            if(f[y] == \\'1\\')\\n                pref[x]--;\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n            x--;\\n            y--;\\n        }\\n        for(int i = 0; i <= f.size(); i++)\\n            dp[i][0] = 0;\\n        for(int j = 0; j <= n; j++)\\n            dp[f.size()][j] = 0;\\n        for(int i = f.size()-1; i >= 0; i--)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                dp[i][j] = max(dp[i+1][j],\\n                               dp[min(i+cl,int(f.size()-1))][j-1]\\n                               + pref[i]);\\n            }\\n        }\\n        return tot > dp[0][n] ? tot - dp[0][n] : 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876280,
                "title": "c-dp-heavily-commented",
                "content": "```\\nclass Solution {\\n    \\nprivate:\\n    int dp[1001][1001];\\n    int suffix[1001];\\npublic:\\n    int recur(string &floor,int numCarpets,int carpetLen,int idx)\\n    {\\n        //Base Cases\\n        if(idx>=floor.size())\\n            return 0;\\n    \\n        if(numCarpets==0)\\n            return suffix[idx];\\n        \\n        //Memoization\\n        if(dp[idx][numCarpets]!=-1)\\n            return dp[idx][numCarpets];\\n        \\n        //Check if current tile is white,\\n        //We need to add 1 because we are skipping\\n        int op1=(floor[idx]==\\'1\\')+recur(floor,numCarpets,carpetLen,idx+1);\\n        //We are using one carpet and hence we jump directly \\n        //by carpetLen moves\\n        int op2=recur(floor,numCarpets-1,carpetLen,idx+carpetLen);\\n        return dp[idx][numCarpets]=min(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n       int n=floor.size();\\n       memset(dp,-1,sizeof dp);\\n        \\n       /*We make a suffix array which will tell \\n       us count of white tiles after current tile\\n       (including current tile also), we need to do this step\\n       else we will get TLE */\\n       suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n        return recur(floor,numCarpets,carpetLen,0);\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\nprivate:\\n    int dp[1001][1001];\\n    int suffix[1001];\\npublic:\\n    int recur(string &floor,int numCarpets,int carpetLen,int idx)\\n    {\\n        //Base Cases\\n        if(idx>=floor.size())\\n            return 0;\\n    \\n        if(numCarpets==0)\\n            return suffix[idx];\\n        \\n        //Memoization\\n        if(dp[idx][numCarpets]!=-1)\\n            return dp[idx][numCarpets];\\n        \\n        //Check if current tile is white,\\n        //We need to add 1 because we are skipping\\n        int op1=(floor[idx]==\\'1\\')+recur(floor,numCarpets,carpetLen,idx+1);\\n        //We are using one carpet and hence we jump directly \\n        //by carpetLen moves\\n        int op2=recur(floor,numCarpets-1,carpetLen,idx+carpetLen);\\n        return dp[idx][numCarpets]=min(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n       int n=floor.size();\\n       memset(dp,-1,sizeof dp);\\n        \\n       /*We make a suffix array which will tell \\n       us count of white tiles after current tile\\n       (including current tile also), we need to do this step\\n       else we will get TLE */\\n       suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n        return recur(floor,numCarpets,carpetLen,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870498,
                "title": "java-simple-top-down-dp-with-explanation",
                "content": "Basically we consider each suffix from ```floor[0...I]``` using ```J``` carpets. There are 2 transition options to consider and minimize over for this building upon \"smaller\"* subproblems.\\n\\nCase 1: We use a carpet that ends at ```I```th position. So this means we simply need ```subproblem(I-carpetLen, J-1)``` because all tiles from ```I-carpetLen + 1``` to ```I``` now have 0 white tiles due to spending 1 carpet so we are at pos ```I - carpetLen``` with 1 less carpet.\\n\\nCase 2: We do not use a carpet that ends at ```I```th position. So the ```I```th tile is uncovered. So this tile has to be included towards count of white tiles so add ```floor(I) == 0? 1 : 0```. And then we\\'re left with ```subproblem(I-1, J)``` as we haven\\'t spent any carpets.\\n\\nThat is ```subproblem(I, J) = Min(subproblem(I-carpetLen, J-1), subproblem(I-1, J) + floor(I) == 0? 1 : 0)```\\n\\n\\\\* \"smaller\" in sense that subproblem(I\\', J\\') < subproblem(I, J) if I\\' <= I and J\\' <= J and not case that (I\\', J\\') = (I, J)\\n\\nThere are a few edge cases that should be easily understandable from code below.\\nCode:\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // memo[I][J] = subproblem of floor[0...I] with J numCarpets.\\n        // so I range from 0...(floor.len - 1) so floor.len possibilities\\n        // and J range from 0 ... numCarpets so numCarpets+1 possibilities\\n        Integer[][] memo = new Integer[floor.length()][numCarpets + 1];\\n        return dfs(floor.length() - 1, numCarpets, carpetLen, memo, floor);\\n    }\\n    \\n    // precond. i and j both >=0. don\\'t add check at start, instead maintain this\\n    private int dfs(int i, int j, int carpetLen, Integer[][] memo, String floor) {\\n        //if (i < 0 || j < 0) {\\n            //return 0;\\n        //}\\n        if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        // case 1: only when have at least 1 carpet to work with so let one extend and end at I\\n        if (j > 0) {\\n            if (i - carpetLen >= 0) {\\n                min = Math.min(min, dfs(i - carpetLen, j-1, carpetLen, memo, floor));\\n            } else {\\n                // have enough carpet to span all of [0...i] so no while tiles visible\\n                memo[i][j] = 0;\\n                return 0;\\n            }\\n        }\\n        // case 2: tile does not extend till here\\n        if (i > 0) {\\n            min = Math.min(min, dfs(i-1, j, carpetLen, memo, floor) + ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        } else {\\n            min = Math.min(min, ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        }\\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```floor[0...I]```\n```J```\n```I```\n```subproblem(I-carpetLen, J-1)```\n```I-carpetLen + 1```\n```I```\n```I - carpetLen```\n```I```\n```I```\n```floor(I) == 0? 1 : 0```\n```subproblem(I-1, J)```\n```subproblem(I, J) = Min(subproblem(I-carpetLen, J-1), subproblem(I-1, J) + floor(I) == 0? 1 : 0)```\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // memo[I][J] = subproblem of floor[0...I] with J numCarpets.\\n        // so I range from 0...(floor.len - 1) so floor.len possibilities\\n        // and J range from 0 ... numCarpets so numCarpets+1 possibilities\\n        Integer[][] memo = new Integer[floor.length()][numCarpets + 1];\\n        return dfs(floor.length() - 1, numCarpets, carpetLen, memo, floor);\\n    }\\n    \\n    // precond. i and j both >=0. don\\'t add check at start, instead maintain this\\n    private int dfs(int i, int j, int carpetLen, Integer[][] memo, String floor) {\\n        //if (i < 0 || j < 0) {\\n            //return 0;\\n        //}\\n        if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        // case 1: only when have at least 1 carpet to work with so let one extend and end at I\\n        if (j > 0) {\\n            if (i - carpetLen >= 0) {\\n                min = Math.min(min, dfs(i - carpetLen, j-1, carpetLen, memo, floor));\\n            } else {\\n                // have enough carpet to span all of [0...i] so no while tiles visible\\n                memo[i][j] = 0;\\n                return 0;\\n            }\\n        }\\n        // case 2: tile does not extend till here\\n        if (i > 0) {\\n            min = Math.min(min, dfs(i-1, j, carpetLen, memo, floor) + ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        } else {\\n            min = Math.min(min, ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        }\\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866616,
                "title": "java-solution-top-down-dp-2-approaches",
                "content": "**Explanation :**\\n\\nHere, I want to showcase 2 approaches for solving the problem using memoization :\\n\\t\\t1. counting the minimum number of exposed white tiles using `suffix-sum` and\\n\\t\\t2. counting the maximum number of white tiles covered by the given carpets and subtracting this from the total number of white tiles to get the exposed white tiles using `prefix-sum`\\n\\n**Approach 1 :**\\n\\n```\\npublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] suffixSum = new int[floor.length()];\\n        suffixSum[floor.length() - 1] = (floor.charAt(floor.length() - 1) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = floor.length() - 2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i + 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n\\n        return coverTilesDP(floor, 0, carpetLen, numCarpets, dp, suffixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] suffixSum) {\\n        if (idx >= str.length()) {\\n            return 0;\\n        } else if (numCarpets == 0) {\\n            return suffixSum[idx];\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\t\\t\\n        // include\\n        int min1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, suffixSum);\\n        // exclude\\n        int min2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, suffixSum) + (str.charAt(idx) == \\'1\\' ? 1 : 0);\\n\\n        return dp[idx][numCarpets] = Math.min(min1, min2);\\n    }\\n```\\n\\n**Approach 2 :**\\n\\n```\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] prefixSum = new int[floor.length()];\\n        prefixSum[0] = (floor.charAt(0) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = 1; i < floor.length(); i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n        return prefixSum[floor.length() - 1] - coverTilesDP(floor, 0, carpetLen,\\n                                                            numCarpets, dp, prefixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] prefixSum) {\\n        if (idx >= str.length() || numCarpets == 0) {\\n            return 0;\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\n        // include\\n        int max1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, prefixSum) +\\n                   (prefixSum[Math.min(idx + carpetLen - 1, prefixSum.length - 1)] - (idx >= 1 ? prefixSum[idx - 1] : 0));\\n        // exclude\\n        int max2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, prefixSum);\\n\\n        return dp[idx][numCarpets] = Math.max(max1, max2);\\n    }\\n```\\n\\n**PS -** Any suggestions or improvements are most welcome.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] suffixSum = new int[floor.length()];\\n        suffixSum[floor.length() - 1] = (floor.charAt(floor.length() - 1) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = floor.length() - 2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i + 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n\\n        return coverTilesDP(floor, 0, carpetLen, numCarpets, dp, suffixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] suffixSum) {\\n        if (idx >= str.length()) {\\n            return 0;\\n        } else if (numCarpets == 0) {\\n            return suffixSum[idx];\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\t\\t\\n        // include\\n        int min1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, suffixSum);\\n        // exclude\\n        int min2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, suffixSum) + (str.charAt(idx) == \\'1\\' ? 1 : 0);\\n\\n        return dp[idx][numCarpets] = Math.min(min1, min2);\\n    }\\n```\n```\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] prefixSum = new int[floor.length()];\\n        prefixSum[0] = (floor.charAt(0) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = 1; i < floor.length(); i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n        return prefixSum[floor.length() - 1] - coverTilesDP(floor, 0, carpetLen,\\n                                                            numCarpets, dp, prefixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] prefixSum) {\\n        if (idx >= str.length() || numCarpets == 0) {\\n            return 0;\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\n        // include\\n        int max1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, prefixSum) +\\n                   (prefixSum[Math.min(idx + carpetLen - 1, prefixSum.length - 1)] - (idx >= 1 ? prefixSum[idx - 1] : 0));\\n        // exclude\\n        int max2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, prefixSum);\\n\\n        return dp[idx][numCarpets] = Math.max(max1, max2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865413,
                "title": "top-down-c-solution-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int explore(int i,string &floor,int numCarpets, int &carpetLen, vector<vector<int>> &dp)\\n    {\\n        if(i==floor.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[i][numCarpets]!=-1)\\n        {\\n            return dp[i][numCarpets];\\n        }\\n        \\n        int ans=0;\\n        //Put carpet here only if you have 1 or more carpet left\\n            if(i+carpetLen<=floor.length()&&numCarpets>0)\\n            {\\n                ans+=carpetLen+explore(i+carpetLen,floor,numCarpets-1,carpetLen,dp);\\n            }\\n            else if(numCarpets>0)\\n            {      //When current index+ carpet length > floor.length\\n                 ans+=floor.length()-i;\\n            }\\n        \\n        \\n        //Dont put carpert here\\n        if(floor[i]==\\'0\\')\\n        {   //If current carpet is black\\n            ans=max(ans,1+explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        else\\n        {\\n            ans=max(ans,explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        \\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.length();\\n        //Store number of maximum black carpet from  index\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        //Explore will return maximum number of black carpet \\n\\t\\t//we just subtract it from floor length to get \\n\\t\\t//minimum number of white carpet\\n        return n-explore(0,floor,numCarpets,carpetLen,dp);\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int explore(int i,string &floor,int numCarpets, int &carpetLen, vector<vector<int>> &dp)\\n    {\\n        if(i==floor.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[i][numCarpets]!=-1)\\n        {\\n            return dp[i][numCarpets];\\n        }\\n        \\n        int ans=0;\\n        //Put carpet here only if you have 1 or more carpet left\\n            if(i+carpetLen<=floor.length()&&numCarpets>0)\\n            {\\n                ans+=carpetLen+explore(i+carpetLen,floor,numCarpets-1,carpetLen,dp);\\n            }\\n            else if(numCarpets>0)\\n            {      //When current index+ carpet length > floor.length\\n                 ans+=floor.length()-i;\\n            }\\n        \\n        \\n        //Dont put carpert here\\n        if(floor[i]==\\'0\\')\\n        {   //If current carpet is black\\n            ans=max(ans,1+explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        else\\n        {\\n            ans=max(ans,explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        \\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.length();\\n        //Store number of maximum black carpet from  index\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        //Explore will return maximum number of black carpet \\n\\t\\t//we just subtract it from floor length to get \\n\\t\\t//minimum number of white carpet\\n        return n-explore(0,floor,numCarpets,carpetLen,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865216,
                "title": "java-simple-solution-with-explaination",
                "content": "I was having the problem to think but got intuition of DP by seeing constraints. But Now how to implement DP what will be the variables to play . Basically think on which variables you are dependent;\\nYes You have to travel the complete the floor string so this variable is changing and second the number of carpet is changing. \\ncarpet length is constant .\\nThis is similar to knapsack yes , here each carpet has value that is length. \\nAt each index you have two choice either use carpet or don\\'t use it;\\nif already black skip and move forward\\nif white you can use carpet or you can leave white (thus cnt will be increased)\\n\\nif all carpet are used and still floor is not completed just return number of white tiles are left;\\nbelow is the code\\n\\n\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // we have to cover the tiles  we first see the color if it is black \\n        // we leave if its white we have option to jump or we cover it;\\n        int dp[][]= new int[floor.length()+1][numCarpets+1];\\n        for(int a[]: dp){\\n            Arrays.fill(a, -1);\\n        }\\n        return helper( 0, numCarpets, carpetLen, dp, floor);\\n    }\\n    public int helper(int i, int nc, int l, int[][] dp, String s){\\n        \\n        if(i>= s.length()) return 0;\\n        if(nc<=0){\\n            int cnt=0;\\n            for(int j= i; j<s.length(); j++){\\n                if(s.charAt(j)==\\'1\\'){\\n                    cnt++;\\n                }\\n            }\\n            return cnt;\\n        }\\n        \\n        if(dp[i][nc]!=-1) return dp[i][nc];\\n        \\n        \\n        if(s.charAt(i)==\\'0\\'){\\n            return dp[i][nc]= helper(i+1, nc,l , dp , s);\\n        }\\n        else{\\n            int jump= 1+ helper(i+1, nc, l, dp, s);\\n            int cover= helper(i+ l, nc-1, l, dp, s);\\n            \\n            return dp[i][nc]= Math.min(jump, cover);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // we have to cover the tiles  we first see the color if it is black \\n        // we leave if its white we have option to jump or we cover it;\\n        int dp[][]= new int[floor.length()+1][numCarpets+1];\\n        for(int a[]: dp){\\n            Arrays.fill(a, -1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1865059,
                "title": "dp-edge-case-optimization-with-explanations",
                "content": "Two edge cases can be handled explicitly before running DP:\\n(1) `if numCarpets * carpetLen >= n`, i.e. the totally length of carpets altogether is longer than the length of `floor`, return 0 immediately;\\n(2) `if carpetLen == 1`, then the problem becomes trivial and we can cover the carpets \"greedily\". Adding this edge check is particularly useful for a few long test cases (as it would save half of the time for such cases), which does help to get AC for this problem.\\nThe rest of the code deals with the general cases by using DP, where `dp[i][j]` represents the minimum white tiles after covering with `j` carpets for first `i` tiles.\\nPlease upvote if you find this solution helpful.\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t# edge case handling\\n        if numCarpets * carpetLen >= n:\\n            return 0\\n        if carpetLen == 1:\\n            return max(sum([int(c) for c in floor]) - numCarpets, 0)\\n\\t\\t# DP initialization\\n        dp = [[None] * (numCarpets + 1) for _ in range(n + 1)]\\n        for j in range(numCarpets + 1):\\n            dp[0][j] = 0\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + int(floor[i - 1])\\n\\t\\t# DP transition formula\\n        for i in range(1, n + 1):\\n            for j in range(1, numCarpets + 1):\\n                dp[i][j] = min(dp[i - 1][j] + int(floor[i - 1]), dp[max(i - carpetLen, 0)][j - 1])\\n        return dp[n][numCarpets]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t# edge case handling\\n        if numCarpets * carpetLen >= n:\\n            return 0\\n        if carpetLen == 1:\\n            return max(sum([int(c) for c in floor]) - numCarpets, 0)\\n\\t\\t# DP initialization\\n        dp = [[None] * (numCarpets + 1) for _ in range(n + 1)]\\n        for j in range(numCarpets + 1):\\n            dp[0][j] = 0\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + int(floor[i - 1])\\n\\t\\t# DP transition formula\\n        for i in range(1, n + 1):\\n            for j in range(1, numCarpets + 1):\\n                dp[i][j] = min(dp[i - 1][j] + int(floor[i - 1]), dp[max(i - carpetLen, 0)][j - 1])\\n        return dp[n][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864943,
                "title": "c-easy-to-understand-memoization-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int solve(string &floor,int i,int n,int l,vector<int> &prefix)\\n    {\\n        if(i>=floor.size()||n==0)\\n        return 0;\\n        if(dp[i][n]!=-1)\\n        return dp[i][n];\\n        if(floor[i]==\\'0\\')\\n        return dp[i][n]=solve(floor,i+1,n,l,prefix);\\n        int x=min((int)(floor.size()),(int)(i+l))-1;\\n        int white=prefix[x];\\n        if(i!=0)\\n        white-=prefix[i-1];\\n        int ans1=white+solve(floor,i+l,n-1,l,prefix);\\n        int ans2=solve(floor,i+1,n,l,prefix);\\n        return dp[i][n]=max(ans1,ans2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<int> prefix(n);\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=numCarpets;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        if(floor[0]==\\'1\\')\\n        prefix[0]=1;\\n        else\\n        prefix[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        int total_white=prefix[n-1];\\n        if(total_white==0)\\n        return 0;\\n        return total_white-solve(floor,0,numCarpets,carpetLen,prefix);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int solve(string &floor,int i,int n,int l,vector<int> &prefix)\\n    {\\n        if(i>=floor.size()||n==0)\\n        return 0;\\n        if(dp[i][n]!=-1)\\n        return dp[i][n];\\n        if(floor[i]==\\'0\\')\\n        return dp[i][n]=solve(floor,i+1,n,l,prefix);\\n        int x=min((int)(floor.size()),(int)(i+l))-1;\\n        int white=prefix[x];\\n        if(i!=0)\\n        white-=prefix[i-1];\\n        int ans1=white+solve(floor,i+l,n-1,l,prefix);\\n        int ans2=solve(floor,i+1,n,l,prefix);\\n        return dp[i][n]=max(ans1,ans2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<int> prefix(n);\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=numCarpets;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        if(floor[0]==\\'1\\')\\n        prefix[0]=1;\\n        else\\n        prefix[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        int total_white=prefix[n-1];\\n        if(total_white==0)\\n        return 0;\\n        return total_white-solve(floor,0,numCarpets,carpetLen,prefix);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864915,
                "title": "c-dp-recursion-memorization-easy-to-understand",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int carpetLen, fLen;\\n    vector<int> sum;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int numCar, string& floor){\\n        if(pos >= fLen){\\n            return 0;\\n        }\\n        \\n        if(numCar == 0){\\n            return 0;\\n        }\\n        \\n        int &ret = dp[pos][numCar];\\n        \\n        if(ret != -1){\\n            return ret;\\n        }\\n        \\n        int taken = 0, notTaken = 0;\\n        int fSum = 0, lSum = 0;\\n        \\n        fSum = pos > 0 ? sum[pos - 1] : 0;\\n        lSum = pos + carpetLen > fLen ? sum[fLen - 1] : sum[pos + carpetLen - 1];\\n        \\n        taken = lSum - fSum + solve(pos + carpetLen,  numCar - 1, floor);\\n        notTaken = solve(pos + 1, numCar, floor);\\n        \\n        return ret = max(taken, notTaken);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        fLen = floor.size();\\n        this->carpetLen = carpetLen;\\n        sum.resize(fLen + 1, 0);\\n        dp.resize(fLen + 1, vector<int> (numCarpets + 1, -1));\\n        sum[0] = floor[0] - \\'0\\';\\n        \\n        for(int i = 1; i < fLen; i++){\\n            sum[i] = sum[i - 1] + (floor[i] - \\'0\\');\\n        }\\n        \\n        return sum[fLen - 1] - solve(0, numCarpets, floor);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int carpetLen, fLen;\\n    vector<int> sum;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int numCar, string& floor){\\n        if(pos >= fLen){\\n            return 0;\\n        }\\n        \\n        if(numCar == 0){\\n            return 0;\\n        }\\n        \\n        int &ret = dp[pos][numCar];\\n        \\n        if(ret != -1){\\n            return ret;\\n        }\\n        \\n        int taken = 0, notTaken = 0;\\n        int fSum = 0, lSum = 0;\\n        \\n        fSum = pos > 0 ? sum[pos - 1] : 0;\\n        lSum = pos + carpetLen > fLen ? sum[fLen - 1] : sum[pos + carpetLen - 1];\\n        \\n        taken = lSum - fSum + solve(pos + carpetLen,  numCar - 1, floor);\\n        notTaken = solve(pos + 1, numCar, floor);\\n        \\n        return ret = max(taken, notTaken);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        fLen = floor.size();\\n        this->carpetLen = carpetLen;\\n        sum.resize(fLen + 1, 0);\\n        dp.resize(fLen + 1, vector<int> (numCarpets + 1, -1));\\n        sum[0] = floor[0] - \\'0\\';\\n        \\n        for(int i = 1; i < fLen; i++){\\n            sum[i] = sum[i - 1] + (floor[i] - \\'0\\');\\n        }\\n        \\n        return sum[fLen - 1] - solve(0, numCarpets, floor);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864513,
                "title": "java-using-dynamic-programming-simple-solution",
                "content": "First, if numCarpets * carpetLen > floor.size(), the answer is always 0 because the entire floor can be covered.\\nOtherwise,This problem can be solved by using dynamic programming.\\nThe variables in the DP are\\n1. length of confirmed Floor (starting from the left end at 0)\\n2. number of carpets used\\n\\nThe spatial computational complexity of a 2-dimensional array using the above variables is O(1e6).\\n\\nPlease see the image below for a sample transition with floor = \"10110\", numCarpets = 2, carpetLen = 2.\\n![image](https://assets.leetcode.com/users/images/20a2a6f5-af47-40d4-a972-6e2e000d96e3_1647710851.003477.png)\\n\\nThe red arrow shows the transition when the carpet is pulled.\\n`dp[i+cl][j+1] = Math.min(dp[i+cl][j+1], dp[i][j]);`\\n\\u203B Math.min(i+cl,f.length) is used in my code because the index could exceed floor.size().\\n\\nThe black arrow is the transition if the carpet is not pulled.\\nIf the next floor is white, increase the value by +1 from the current value.\\n`dp[i+1][j] = Math.min(dp[i+1][j], dp[i][j] + floor[i]);`\\n\\nWe have solved this problem by performing two different transitions for each item in the dp array.\\n\\nex) the gray items and arrows are not valid, we can show that there is no transition from dp[0][0] to dp[1][0],dp[1][1] for example, because the length of the carpet is more than 2.\\n\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        //1. Redefine for variable name shortening\\n        int ln = floor.length();\\n        int nc = numCarpets;\\n        int cl = carpetLen;\\n        \\n        //2. Return 0 if all floors can be covered from carpet length * number of carpets.\\n        char[] f = floor.toCharArray();\\n        int cover = numCarpets * carpetLen;\\n        if(cover >= f.length) return 0;\\n        \\n        \\n        //3. Dynamic Programming\\n        int[][] dp = new int[ln+1][nc+1];\\n        for(int i = 0; i <= ln; i++) Arrays.fill(dp[i],f.length);\\n        dp[0][0] = 0;\\n        for(int i = 0; i < ln; i++){\\n            int plus = f[i]-\\'0\\';\\n            for(int j = 0; j <= nc; j++){\\n                dp[i+1][j] = Math.min(dp[i+1][j],dp[i][j] + plus);\\n                if(j != nc) dp[Math.min(i+cl,f.length)][j+1] = Math.min(dp[Math.min(i+cl,f.length)][j+1], dp[i][j]);\\n            }\\n        }\\n        return dp[ln][nc];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        //1. Redefine for variable name shortening\\n        int ln = floor.length();\\n        int nc = numCarpets;\\n        int cl = carpetLen;\\n        \\n        //2. Return 0 if all floors can be covered from carpet length * number of carpets.\\n        char[] f = floor.toCharArray();\\n        int cover = numCarpets * carpetLen;\\n        if(cover >= f.length) return 0;\\n        \\n        \\n        //3. Dynamic Programming\\n        int[][] dp = new int[ln+1][nc+1];\\n        for(int i = 0; i <= ln; i++) Arrays.fill(dp[i],f.length);\\n        dp[0][0] = 0;\\n        for(int i = 0; i < ln; i++){\\n            int plus = f[i]-\\'0\\';\\n            for(int j = 0; j <= nc; j++){\\n                dp[i+1][j] = Math.min(dp[i+1][j],dp[i][j] + plus);\\n                if(j != nc) dp[Math.min(i+cl,f.length)][j+1] = Math.min(dp[Math.min(i+cl,f.length)][j+1], dp[i][j]);\\n            }\\n        }\\n        return dp[ln][nc];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864481,
                "title": "c-dp-house-robber",
                "content": "This problem can be converted to [house robber](https://leetcode.com/problems/house-robber/) then solved by dynamic programming.\\nWhen the total length of carpet is equal to or exceed the length of the floor, there should be no white left. When it\\'s not, we should always looking for non-overlapping solution as at least one of the optimal solution doesn\\'t include overlapping. The reason is that we can always rearrange carpets to not overlap and covering all the original tiles and some more.\\nSo we can calculate how many white tiles can be covered starting from each position, the problem is to select ```numCarpet``` of positions, with minimum distance of any two position is ```carpetLen```, to get the maximum sum. It\\'s equivalent to house robber except that we not only can\\'t rob consecutive houses, we can\\'t rob houses within some given distance ```carpetLen```. Also we have a fixed amount of house we have to rob, so instead of a 1D DP as we did in house robber, a standard 2D DP approach should suffice. See annotation for details.\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n\\t\\t//too many carpets, cover all the floor\\n        int l = floor.size();\\n        if(numCarpets*carpetLen>=l) {return 0;}\\n\\t\\t\\n        // sliding window to calculate how many white tiles can be covered for a carpet starting at position i\\n        int white = 0;             // number of total white tiles on the floor\\n        int m = l-carpetLen+1;     // number of possible carpet starting position\\n        vector<int> cover(m,0);    // number of white tiles covered for a carpet starting at each position\\n        for(int i=0; i<carpetLen; i++){\\n            cover[0] += (floor[i]==\\'1\\');\\n            white += (floor[i]==\\'1\\');\\n        }\\n        for(int i=1; i<m; i++){\\n            cover[i] = cover[i-1] - (floor[i-1]==\\'1\\') + (floor[i+carpetLen-1]==\\'1\\');\\n            white += (floor[i+carpetLen-1]==\\'1\\');\\n        }\\n\\t\\t\\n        // dp to find the maximum sum of numCarpets elements from cover[0:m-1], \\n\\t\\t// with any of the two elements having minimum distance of carpetLen\\n\\t\\t// dp[k][i] stands for the maximum sum for k elements in cover[0:i]\\n        vector<vector<int>> dp(numCarpets+1, vector<int>(m,0));\\n        dp[1][0] = cover[0];\\n        for(int i=1; i<m; i++){\\n            dp[1][i] = max(dp[1][i-1],cover[i]);\\n        }\\n        for(int carpet=2; carpet<=numCarpets; carpet++){\\n            for(int i=(carpet-1)*carpetLen; i<m; i++){\\n\\t\\t\\t\\t// either we don\\'t select current element, \\n\\t\\t\\t\\t// or we select current element and limit the range of last selected element before i-carpetLen\\n                dp[carpet][i] = max(dp[carpet][i-1],cover[i]+dp[carpet-1][i-carpetLen]);\\n            }\\n        }\\n        return white-dp[numCarpets][m-1];\\n    }\\n};\\n```\\nThis solution should be able to optimized to O(N) space complexity by using two 1D vectors.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```numCarpet```\n```carpetLen```\n```carpetLen```\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n\\t\\t//too many carpets, cover all the floor\\n        int l = floor.size();\\n        if(numCarpets*carpetLen>=l) {return 0;}\\n\\t\\t\\n        // sliding window to calculate how many white tiles can be covered for a carpet starting at position i\\n        int white = 0;             // number of total white tiles on the floor\\n        int m = l-carpetLen+1;     // number of possible carpet starting position\\n        vector<int> cover(m,0);    // number of white tiles covered for a carpet starting at each position\\n        for(int i=0; i<carpetLen; i++){\\n            cover[0] += (floor[i]==\\'1\\');\\n            white += (floor[i]==\\'1\\');\\n        }\\n        for(int i=1; i<m; i++){\\n            cover[i] = cover[i-1] - (floor[i-1]==\\'1\\') + (floor[i+carpetLen-1]==\\'1\\');\\n            white += (floor[i+carpetLen-1]==\\'1\\');\\n        }\\n\\t\\t\\n        // dp to find the maximum sum of numCarpets elements from cover[0:m-1], \\n\\t\\t// with any of the two elements having minimum distance of carpetLen\\n\\t\\t// dp[k][i] stands for the maximum sum for k elements in cover[0:i]\\n        vector<vector<int>> dp(numCarpets+1, vector<int>(m,0));\\n        dp[1][0] = cover[0];\\n        for(int i=1; i<m; i++){\\n            dp[1][i] = max(dp[1][i-1],cover[i]);\\n        }\\n        for(int carpet=2; carpet<=numCarpets; carpet++){\\n            for(int i=(carpet-1)*carpetLen; i<m; i++){\\n\\t\\t\\t\\t// either we don\\'t select current element, \\n\\t\\t\\t\\t// or we select current element and limit the range of last selected element before i-carpetLen\\n                dp[carpet][i] = max(dp[carpet][i-1],cover[i]+dp[carpet-1][i-carpetLen]);\\n            }\\n        }\\n        return white-dp[numCarpets][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864442,
                "title": "c-dp-solution-memoization-100-fast-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &hash, int &num, int &len, int i, int j, vector<vector<int>> &dp){\\n        int n = hash.size();\\n        if (j >= num or i >= n)  return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n//     Dont want to put the carpet on the ith place\\n        int not_take = solve(hash, num, len, i+1, j, dp);\\n//     Want to put the carpet on the ith place and the corresponding value which it gives is added\\n        int take = hash[i] + solve(hash, num, len, i+len, j+1, dp);\\n        \\n        return dp[i][j] = max(not_take, take);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        int n = floor.size();\\n        if (num*len >= n)   return 0;    \\n        int var = 0, count = 0;\\n        for (int i = 0;i < n;i++)   count += (floor[i] == \\'1\\');\\n        if (count == n){\\n            return (n - (num*len));\\n        }\\n//     hash stores that if we put the carpet at the ith position \\n//     then how much white space i\\'ll cover\\n        vector<int> hash(n);\\n        for (int i = n-1;i >= 0;i--){\\n            if (floor[i] == \\'1\\'){\\n                var += 1;\\n            }\\n            if (i+len < n and floor[i+len] == \\'1\\'){\\n                var -= 1;\\n            }\\n            hash[i] = var;\\n        }\\n//     dp[i][j] stores if i am on the ith index and jth carpet is used \\n//     then how much maximum white spaces i\\'ll cover\\n        vector<vector<int>> dp(n, vector<int> (num, -1));\\n//     solve gives me the maximus white i can cover with carpet using the num number of carpets \\n//     of length len\\n        int temp = solve(hash, num, len, 0, 0, dp);\\n        return count - temp;\\n    }\\n};\\n```\\nComment below if you have any doubt\\nPlease upvote if you like\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &hash, int &num, int &len, int i, int j, vector<vector<int>> &dp){\\n        int n = hash.size();\\n        if (j >= num or i >= n)  return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n//     Dont want to put the carpet on the ith place\\n        int not_take = solve(hash, num, len, i+1, j, dp);\\n//     Want to put the carpet on the ith place and the corresponding value which it gives is added\\n        int take = hash[i] + solve(hash, num, len, i+len, j+1, dp);\\n        \\n        return dp[i][j] = max(not_take, take);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        int n = floor.size();\\n        if (num*len >= n)   return 0;    \\n        int var = 0, count = 0;\\n        for (int i = 0;i < n;i++)   count += (floor[i] == \\'1\\');\\n        if (count == n){\\n            return (n - (num*len));\\n        }\\n//     hash stores that if we put the carpet at the ith position \\n//     then how much white space i\\'ll cover\\n        vector<int> hash(n);\\n        for (int i = n-1;i >= 0;i--){\\n            if (floor[i] == \\'1\\'){\\n                var += 1;\\n            }\\n            if (i+len < n and floor[i+len] == \\'1\\'){\\n                var -= 1;\\n            }\\n            hash[i] = var;\\n        }\\n//     dp[i][j] stores if i am on the ith index and jth carpet is used \\n//     then how much maximum white spaces i\\'ll cover\\n        vector<vector<int>> dp(n, vector<int> (num, -1));\\n//     solve gives me the maximus white i can cover with carpet using the num number of carpets \\n//     of length len\\n        int temp = solve(hash, num, len, 0, 0, dp);\\n        return count - temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864395,
                "title": "c-solution-memo-recursive-prefix-array",
                "content": "So , Here i changed the question instead of finding the minimum no of white tiles after placing k tiles , I am trying to find the maximum white tiles i can cover with the  k tiles and return the answer after subtracting with the  intital  no of white tiles present in the string.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    vector<int>prefix;\\n    int helper(int idx,int k,string& floor,int len){\\n        if(idx >= floor.size())return 0;\\n        if(dp[idx][k] != -1)return dp[idx][k];\\n        int op1 = helper(idx + 1,k,floor,len);\\n        int op2 = 0;\\n        if(floor[idx] == \\'1\\' && k > 0){\\n            int sz = min(idx + len,(int)floor.size());\\n            int y = prefix[sz - 1];\\n            if(idx - 1 >= 0){\\n                y -= prefix[idx - 1];\\n            }\\n            op2 = y + helper(idx + len,k - 1,floor,len);\\n        }\\n        return dp[idx][k] = max(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int cnt = 0;\\n        int n = floor.size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i =0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\')cnt++;\\n        }\\n        prefix.resize(n + 1,0);\\n        prefix[0] = (floor[0] == \\'1\\');\\n        for(int i =1;i<=n;i++){\\n            if(floor[i] == \\'1\\'){\\n                prefix[i] = prefix[i - 1] + 1;\\n            }\\n            else prefix[i] = prefix[i - 1];\\n        }\\n        if(cnt == 0)return 0;\\n        return cnt - helper(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    vector<int>prefix;\\n    int helper(int idx,int k,string& floor,int len){\\n        if(idx >= floor.size())return 0;\\n        if(dp[idx][k] != -1)return dp[idx][k];\\n        int op1 = helper(idx + 1,k,floor,len);\\n        int op2 = 0;\\n        if(floor[idx] == \\'1\\' && k > 0){\\n            int sz = min(idx + len,(int)floor.size());\\n            int y = prefix[sz - 1];\\n            if(idx - 1 >= 0){\\n                y -= prefix[idx - 1];\\n            }\\n            op2 = y + helper(idx + len,k - 1,floor,len);\\n        }\\n        return dp[idx][k] = max(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int cnt = 0;\\n        int n = floor.size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i =0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\')cnt++;\\n        }\\n        prefix.resize(n + 1,0);\\n        prefix[0] = (floor[0] == \\'1\\');\\n        for(int i =1;i<=n;i++){\\n            if(floor[i] == \\'1\\'){\\n                prefix[i] = prefix[i - 1] + 1;\\n            }\\n            else prefix[i] = prefix[i - 1];\\n        }\\n        if(cnt == 0)return 0;\\n        return cnt - helper(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864304,
                "title": "python3-dp-o-n-numcarpets-solution-got-a-tle-is-this-intended",
                "content": "My solution is given as\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = dict() # i, num_carpets remaining -> num white\\n        n = len(floor)\\n        for i in range(n+1)[::-1]:\\n            for j in range(numCarpets+1):\\n                if i == n:\\n                    dp[(i,j)] = 0\\n                    continue\\n                \\n                if floor[i] == \\'0\\':\\n                    dp[(i,j)] = dp[(i+1,j)]\\n                else:\\n                    dp[(i,j)] = 1+dp[(i+1,j)] \\n                    if j > 0:\\n                        dp[(i,j)] = min(dp[(i,j)], dp[(min(i+carpetLen, n),j-1)])\\n        \\n        return dp[(0, numCarpets)]\\n```\\nShould I make it more faster? \\nIs this intended?",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = dict() # i, num_carpets remaining -> num white\\n        n = len(floor)\\n        for i in range(n+1)[::-1]:\\n            for j in range(numCarpets+1):\\n                if i == n:\\n                    dp[(i,j)] = 0\\n                    continue\\n                \\n                if floor[i] == \\'0\\':\\n                    dp[(i,j)] = dp[(i+1,j)]\\n                else:\\n                    dp[(i,j)] = 1+dp[(i+1,j)] \\n                    if j > 0:\\n                        dp[(i,j)] = min(dp[(i,j)], dp[(min(i+carpetLen, n),j-1)])\\n        \\n        return dp[(0, numCarpets)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864125,
                "title": "dp-intuition-with-explaination",
                "content": "**Intuition**\\n\\n\\nlets suppose are at ith index.\\n\\nsuppose we are at index i and with j carpets\\ndp[i][j] denotes minimum number of uncovered white cells from 0 to i with j \\ncarpets.\\n\\n1. if number of carpets = 0 dp[i][j] = number of carpets from 0 to i.\\n\\n\\nsuppose we are at index i and with j carpets\\n1. we dont put carpet. in this case number of uncovered white cells will be \\nnumber of uncovered white cells at i-1 +  1 (if ith cell is )\\ndp[i][j]  = dp[i-1][j] + 1 if ith carpet is red;\\n\\n\\n2. if we are placing carpet (j>0) such that ith is the last cell covered.\\n\\ni-carpetlength < 0 that means we are fulling covering from 0 to i.\\n[i][j] = 0\\n\\ni-carpetlength >= 0 that means we are covering from\\ni-carpetlength+1 to i and number of carpet left are j-1\\n\\nso dp[i][j] = dp[i-carpetlength][j-1] // cells i-carpetlength+1 to i is covered\\n\\nat last we will take minimmum of both the values \\ndp[i][j]  = min(dp[i-1][j]) + 1 if ith carpet is red, 0 if i-carpetlength < 0 else dp[i-carpetlength][j-1]\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1));\\n        int ans = 0;\\n        vector<int>freq(n);\\n        for(int i = 0;i<n;i++)\\n        {\\n            ans += floor[i]-\\'0\\';\\n            freq[i] = ans;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<=numCarpets;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = freq[i];\\n                    continue;\\n                }\\n                if(i-carpetLen < 0)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else if(i-carpetLen >= 0)\\n                {\\n                    dp[i][j] = dp[i-carpetLen][j-1];\\n                }\\n                int value = 0;\\n                if(i>0)\\n                {\\n                        value += floor[i]-\\'0\\';\\n                      dp[i][j] = min(dp[i-1][j] + value ,dp[i][j]);\\n                }\\n                else\\n                {\\n                      value += floor[i]-\\'0\\';\\n                    dp[i][j] = min(value ,dp[i][j]);\\n                }\\n          }\\n           \\n        }\\n        return dp[n-1][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1));\\n        int ans = 0;\\n        vector<int>freq(n);\\n        for(int i = 0;i<n;i++)\\n        {\\n            ans += floor[i]-\\'0\\';\\n            freq[i] = ans;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<=numCarpets;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = freq[i];\\n                    continue;\\n                }\\n                if(i-carpetLen < 0)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else if(i-carpetLen >= 0)\\n                {\\n                    dp[i][j] = dp[i-carpetLen][j-1];\\n                }\\n                int value = 0;\\n                if(i>0)\\n                {\\n                        value += floor[i]-\\'0\\';\\n                      dp[i][j] = min(dp[i-1][j] + value ,dp[i][j]);\\n                }\\n                else\\n                {\\n                      value += floor[i]-\\'0\\';\\n                    dp[i][j] = min(value ,dp[i][j]);\\n                }\\n          }\\n           \\n        }\\n        return dp[n-1][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864052,
                "title": "python-dp-memoization-solution",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets*carpetLen >= len(floor):\\n            return 0\\n        l = list(map(int,list(floor)))\\n        dp = [[-1]*(numCarpets+1) for j in range(len(l))]\\n        \\n        def rec(i,n):\\n            nonlocal l\\n            if n == 0 or i >= len(l):\\n                return sum(l[i:])\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            dp[i][n] = min(rec(i+carpetLen,n-1),rec(i+1,n)+l[i])\\n            return dp[i][n]\\n        \\n        return rec(0,numCarpets)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets*carpetLen >= len(floor):\\n            return 0\\n        l = list(map(int,list(floor)))\\n        dp = [[-1]*(numCarpets+1) for j in range(len(l))]\\n        \\n        def rec(i,n):\\n            nonlocal l\\n            if n == 0 or i >= len(l):\\n                return sum(l[i:])\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            dp[i][n] = min(rec(i+carpetLen,n-1),rec(i+1,n)+l[i])\\n            return dp[i][n]\\n        \\n        return rec(0,numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864031,
                "title": "dp-memorization-easy-to-understand-solution-c-o-n-2-time-and-o-n-2-space",
                "content": "We can solve this problem by using standard concepts of solving a 2-d DP problem.\\nFor each tile, we have two options --\\ni) We place a the carpet starting from the current tile\\nii) We do not place a carpet\\n\\nFurther, here is an observations to be made\\n-- Placing carpet starting from a black tile is not feasible. SO before placing a carpet, we will check whether the current tile is white or not.\\n\\n\\nBelow is the code for the approach explained above. Lines have been commented in order to understand better.\\n\\n```\\nint solve(string &a,int i,int j,int k,int len,vector<vector<long long int>> &dp)\\n{\\n    \\n    // dp states --\\n    //     i --> represents the index of the tiles\\n    //     j --> represents the number of black carpets used\\n    \\n    if(i>=a.size())\\n    {\\n        // base case\\n        return 0;\\n    }\\n    \\n    if(dp[i][j]!=-1)\\n    {\\n        // since the current tile is already black, no need of covering it\\n        \\n        return dp[i][j];\\n    }\\n    \\n    \\n    if(a[i]==\\'1\\')\\n    {\\n        // the current tile is white in color, so we have two options\\n        \\n        int op1=INT_MAX,op2=INT_MAX;\\n        \\n        // option 1 - place carpet\\n        \\n        if(j<k) // we can only place carpets if we have some remaining black carpets\\n            op1=solve(a,i+len,j+1,k,len,dp);\\n        \\n        // option 2 - dont place the carpet\\n        op2=1+solve(a,i+1,j,k,len,dp);\\n        \\n        \\n        return dp[i][j]=min(op1,op2);\\n    }\\n    \\n    return dp[i][j]=solve(a,i+1,j,k,len,dp);\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int k, int len) {\\n        \\n        // creating a two dimensional dp array\\n        vector<vector<long long int>> dp(a.size()+10,vector<long long int>(k+10,-1));\\n        \\n        return solve(a,0,0,k,len,dp);\\n        \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint solve(string &a,int i,int j,int k,int len,vector<vector<long long int>> &dp)\\n{\\n    \\n    // dp states --\\n    //     i --> represents the index of the tiles\\n    //     j --> represents the number of black carpets used\\n    \\n    if(i>=a.size())\\n    {\\n        // base case\\n        return 0;\\n    }\\n    \\n    if(dp[i][j]!=-1)\\n    {\\n        // since the current tile is already black, no need of covering it\\n        \\n        return dp[i][j];\\n    }\\n    \\n    \\n    if(a[i]==\\'1\\')\\n    {\\n        // the current tile is white in color, so we have two options\\n        \\n        int op1=INT_MAX,op2=INT_MAX;\\n        \\n        // option 1 - place carpet\\n        \\n        if(j<k) // we can only place carpets if we have some remaining black carpets\\n            op1=solve(a,i+len,j+1,k,len,dp);\\n        \\n        // option 2 - dont place the carpet\\n        op2=1+solve(a,i+1,j,k,len,dp);\\n        \\n        \\n        return dp[i][j]=min(op1,op2);\\n    }\\n    \\n    return dp[i][j]=solve(a,i+1,j,k,len,dp);\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int k, int len) {\\n        \\n        // creating a two dimensional dp array\\n        vector<vector<long long int>> dp(a.size()+10,vector<long long int>(k+10,-1));\\n        \\n        return solve(a,0,0,k,len,dp);\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863972,
                "title": "python3-dp-solution-in-o-mn-time-and-o-n-space",
                "content": "# dp solution:\\n* `dp[i][j]` represents for the max number of covered white tiles within `floor[:j + 1]` using `i` carpets\\n* `dp[i][j] = max(max(dp[i][k] for k in range(j)), white count in floor[j - carpetLen : j + 1] + dp[i - 1][j - carpetLen])`\\n```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n    n = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n\\t\\t\\n    dp = [[0] * (n) for _ in range(numCarpets + 1)]\\n    for i in range(1, numCarpets + 1):\\n        max_ = 0\\n        for j in range(n):\\n            # i carpets\\n            # cover [0:j + 1] floor\\n            if j - carpetLen < 0:\\n                dp[i][j] = cnt_white[j]\\n            else:\\n                dp[i][j] = max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[i - 1][j - carpetLen])\\n                max_ = dp[i][j]\\n    return cnt - dp[-1][-1]\\n```\\n\\n# optimization:\\nsince `dp[i]` only depend on `dp[i-1]`, we cound reduce space complexity to `O(N)`\\n```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n\\tn = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n    dp = [0] * (n)\\n    for i in range(1, numCarpets + 1):\\n        nxt = []\\n        max_ = 0\\n        for j in range(n):\\n            if j - carpetLen < 0:\\n                nxt.append(cnt_white[j])\\n            else:\\n                nxt.append(max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[j - carpetLen]))\\n                max_ = nxt[-1]\\n        dp = nxt\\n    return cnt - dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n    n = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n\\t\\t\\n    dp = [[0] * (n) for _ in range(numCarpets + 1)]\\n    for i in range(1, numCarpets + 1):\\n        max_ = 0\\n        for j in range(n):\\n            # i carpets\\n            # cover [0:j + 1] floor\\n            if j - carpetLen < 0:\\n                dp[i][j] = cnt_white[j]\\n            else:\\n                dp[i][j] = max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[i - 1][j - carpetLen])\\n                max_ = dp[i][j]\\n    return cnt - dp[-1][-1]\\n```\n```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n\\tn = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n    dp = [0] * (n)\\n    for i in range(1, numCarpets + 1):\\n        nxt = []\\n        max_ = 0\\n        for j in range(n):\\n            if j - carpetLen < 0:\\n                nxt.append(cnt_white[j])\\n            else:\\n                nxt.append(max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[j - carpetLen]))\\n                max_ = nxt[-1]\\n        dp = nxt\\n    return cnt - dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1863921,
                "title": "python3-2d-dp-solution-explained",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        \"\"\"\\n        dp(pos, numC) -> returns min number of white tiles seen from pos to the end of the floor\\n                         if we have numC number of carpets left\\n        \\n        if numC > 0, i.e. we have some carpets remaining:\\n            if the tile at index pos is white, then we have two choices, \\n                either place a carpet from pos to pos + carpetLen - 1\\n                or skip this tile, so number of white tiles increases by one, and calculate the minimum answer from index\\n                pos + 1\\n            else\\n                no need to cover this tile, we can move ahead\\n        else:\\n            we cannot cover any more white tiles\\n            so return number of white tiles from pos to the end of floor\\n        \\n        \\n        time complexity : O(numCarpets * len(floor)) ~ O(n^2)\\n        \"\"\"\\n    \\n        @lru_cache(None) \\n        def dp(pos, numC):\\n            if pos >= n:\\n                return 0\\n            \\n            if numC > 0:\\n                if floor[pos] == \"1\":\\n                    return min(1 + dp(pos + 1, numC), dp(pos + carpetLen, numC - 1))\\n                else:\\n                    return dp(pos + 1, numC)\\n            else:\\n                return ones[pos]\\n                \\n        \\n        n = len(floor)\\n        \\n        #ones[i] stores the number of white tiles from index i to the end of floor \\n        ones = [0 for i in range(n)]\\n        ones[-1] = (floor[-1] == \"1\")\\n        \\n        for i in range(n-2, -1, -1):\\n            ones[i] = ones[i+1] + (floor[i] == \"1\")\\n            \\n            \\n        return dp(0, numCarpets)\\n                \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        \"\"\"\\n        dp(pos, numC) -> returns min number of white tiles seen from pos to the end of the floor\\n                         if we have numC number of carpets left\\n        \\n        if numC > 0, i.e. we have some carpets remaining:\\n            if the tile at index pos is white, then we have two choices, \\n                either place a carpet from pos to pos + carpetLen - 1\\n                or skip this tile, so number of white tiles increases by one, and calculate the minimum answer from index\\n                pos + 1\\n            else\\n                no need to cover this tile, we can move ahead\\n        else:\\n            we cannot cover any more white tiles\\n            so return number of white tiles from pos to the end of floor\\n        \\n        \\n        time complexity : O(numCarpets * len(floor)) ~ O(n^2)\\n        \"\"\"\\n    \\n        @lru_cache(None) \\n        def dp(pos, numC):\\n            if pos >= n:\\n                return 0\\n            \\n            if numC > 0:\\n                if floor[pos] == \"1\":\\n                    return min(1 + dp(pos + 1, numC), dp(pos + carpetLen, numC - 1))\\n                else:\\n                    return dp(pos + 1, numC)\\n            else:\\n                return ones[pos]\\n                \\n        \\n        n = len(floor)\\n        \\n        #ones[i] stores the number of white tiles from index i to the end of floor \\n        ones = [0 for i in range(n)]\\n        ones[-1] = (floor[-1] == \"1\")\\n        \\n        for i in range(n-2, -1, -1):\\n            ones[i] = ones[i+1] + (floor[i] == \"1\")\\n            \\n            \\n        return dp(0, numCarpets)\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863880,
                "title": "c-with-comments-dp",
                "content": "```dp[idx][rem]``` wil store  maximum tiles we can cover from ```idx to last index``` if we are at index ```idx``` with ```rem``` amount of carpet\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>tile;\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string f, int num, int len) {\\n        int sz=f.size(),totalWHiteTiles=0;\\n        for(int i=0;i<sz;i++){\\n            if(f[i]==\\'1\\')\\n                totalWHiteTiles++;\\n            tile.push_back(totalWHiteTiles);\\n        }\\n        dp.resize(sz,vector<int>(num+1,-1));\\n        return totalWHiteTiles-helper(f,0,num,len);\\n    }\\n    int helper(string &floor,int idx,int rem,int &len){\\n        if(idx>=floor.size() || rem==0)\\n            return 0;\\n        if(dp[idx][rem]!=-1)\\n            return dp[idx][rem];\\n        int sz=floor.size();\\n        // don\\'t start covering the tiles from here\\n        int a=helper(floor,idx+1,rem,len);\\n        // start covering the  tiles from here\\n        int b=helper(floor,idx+len,rem-1,len);\\n        // last index where the carpet can go if we start coering from here\\n        int lastIdx=idx+len-1;\\n        // calculating how many tiles we will civer if we start from here\\n        b+=tile[lastIdx>=sz?(sz-1):lastIdx]-tile[idx];\\n        if(floor[idx]==\\'1\\')\\n            b++;\\n        dp[idx][rem]=max(a,b);\\n        return dp[idx][rem];\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```dp[idx][rem]```\n```idx to last index```\n```idx```\n```rem```\n```\\nclass Solution {\\npublic:\\n    vector<int>tile;\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string f, int num, int len) {\\n        int sz=f.size(),totalWHiteTiles=0;\\n        for(int i=0;i<sz;i++){\\n            if(f[i]==\\'1\\')\\n                totalWHiteTiles++;\\n            tile.push_back(totalWHiteTiles);\\n        }\\n        dp.resize(sz,vector<int>(num+1,-1));\\n        return totalWHiteTiles-helper(f,0,num,len);\\n    }\\n    int helper(string &floor,int idx,int rem,int &len){\\n        if(idx>=floor.size() || rem==0)\\n            return 0;\\n        if(dp[idx][rem]!=-1)\\n            return dp[idx][rem];\\n        int sz=floor.size();\\n        // don\\'t start covering the tiles from here\\n        int a=helper(floor,idx+1,rem,len);\\n        // start covering the  tiles from here\\n        int b=helper(floor,idx+len,rem-1,len);\\n        // last index where the carpet can go if we start coering from here\\n        int lastIdx=idx+len-1;\\n        // calculating how many tiles we will civer if we start from here\\n        b+=tile[lastIdx>=sz?(sz-1):lastIdx]-tile[idx];\\n        if(floor[idx]==\\'1\\')\\n            b++;\\n        dp[idx][rem]=max(a,b);\\n        return dp[idx][rem];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845101,
                "title": "easy-intuitive-solution-using-recursion-and-memoization",
                "content": "# Intuition\\nwe will try to put carpet on every white tile where it exists till\\nour number of carpets are over.\\n\\n# Approach\\nif we find a white tile we will put a carpet based on the length of\\nthe carpet and look for more white tile and put carpet over them too,\\nif the number of carpet is over we cant do anything at that case we \\nhave to count the white tiles. If it is black tile we ignore it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size(),vector<int>(numCarpets+1,-1));\\n        return solve(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    int solve(int i,string &floor, int numCarpets, int &carpetLen,vector<vector<int>>&dp){\\n        if(i == floor.size()) return 0;\\n        if(dp[i][numCarpets] != -1) return dp[i][numCarpets];\\n\\n        if(floor[i] == \\'1\\'){\\n            int putCarpet=INT_MAX;\\n            if(numCarpets!=0) \\n            {\\n               int temp= floor.size();\\n                putCarpet = solve( min(temp,i+carpetLen),floor,numCarpets-1,carpetLen,dp);\\n            }\\n\\n            int notput=1+solve(i+1,floor,numCarpets,carpetLen,dp);\\n\\n            return dp[i][numCarpets] = min(putCarpet,notput);\\n\\n        }else{\\n            //ignore black tiles\\n            return dp[i][numCarpets] =solve(i+1,floor,numCarpets,carpetLen,dp);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size(),vector<int>(numCarpets+1,-1));\\n        return solve(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    int solve(int i,string &floor, int numCarpets, int &carpetLen,vector<vector<int>>&dp){\\n        if(i == floor.size()) return 0;\\n        if(dp[i][numCarpets] != -1) return dp[i][numCarpets];\\n\\n        if(floor[i] == \\'1\\'){\\n            int putCarpet=INT_MAX;\\n            if(numCarpets!=0) \\n            {\\n               int temp= floor.size();\\n                putCarpet = solve( min(temp,i+carpetLen),floor,numCarpets-1,carpetLen,dp);\\n            }\\n\\n            int notput=1+solve(i+1,floor,numCarpets,carpetLen,dp);\\n\\n            return dp[i][numCarpets] = min(putCarpet,notput);\\n\\n        }else{\\n            //ignore black tiles\\n            return dp[i][numCarpets] =solve(i+1,floor,numCarpets,carpetLen,dp);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843439,
                "title": "dp-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int f(int ind,int count,string  &s,int carpetlen,vector<vector<int>>&dp){\\n        if(count<0)return -1e9;\\n        if(ind >= s.size())return 0;\\n\\n        if(dp[ind][count]!=-1)return dp[ind][count];\\n        int color = -1e9;\\n        int notcolor = -1e9;\\n        if(s[ind] == \\'0\\'){\\n            notcolor = 1 + f(ind+1,count,s,carpetlen,dp);//we donot need to color this index as it is laredy black \\n        }\\n        else if(s[ind] == \\'1\\'){\\n            notcolor = f(ind+1,count,s,carpetlen,dp);\\n            if(ind+carpetlen >=s.size()){\\n                color=(s.size() - ind);\\n            }\\n            else color=carpetlen;\\n            color+=f(ind+carpetlen,count-1,s,carpetlen,dp);//color means we are coloring \\n        }\\n\\n        return dp[ind][count] = max(color,notcolor);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        int count = numCarpets;\\n        vector<vector<int>>dp(n,vector<int>(count+1,-1));\\n        int k = f(0,count,floor,carpetLen,dp);\\n        cout<<k<<endl;\\n        return n - k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int f(int ind,int count,string  &s,int carpetlen,vector<vector<int>>&dp){\\n        if(count<0)return -1e9;\\n        if(ind >= s.size())return 0;\\n\\n        if(dp[ind][count]!=-1)return dp[ind][count];\\n        int color = -1e9;\\n        int notcolor = -1e9;\\n        if(s[ind] == \\'0\\'){\\n            notcolor = 1 + f(ind+1,count,s,carpetlen,dp);//we donot need to color this index as it is laredy black \\n        }\\n        else if(s[ind] == \\'1\\'){\\n            notcolor = f(ind+1,count,s,carpetlen,dp);\\n            if(ind+carpetlen >=s.size()){\\n                color=(s.size() - ind);\\n            }\\n            else color=carpetlen;\\n            color+=f(ind+carpetlen,count-1,s,carpetlen,dp);//color means we are coloring \\n        }\\n\\n        return dp[ind][count] = max(color,notcolor);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        int count = numCarpets;\\n        vector<vector<int>>dp(n,vector<int>(count+1,-1));\\n        int k = f(0,count,floor,carpetLen,dp);\\n        cout<<k<<endl;\\n        return n - k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3784168,
                "title": "0-1-knapsack-pick-not-pick-easy-to-read-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,l;\\nint numCarpets;\\nint dp[1000+1][1000+1];\\n    int solve(string &floor, int ind, int rem){\\n        if(ind>=n) return 0;\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        if(floor[ind]==\\'1\\'){\\n           int pick=INT_MAX,not_pick=INT_MAX;\\n\\n            if(rem) pick=solve(floor,ind+l,rem-1);\\n            not_pick=1+solve(floor,ind+1,rem);\\n            return dp[ind][rem]=min(op1,op2);\\n        }\\n        return dp[ind][rem]=solve(floor,ind+1,rem);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n=floor.size(), l=carpetLen;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(floor,0,numCarpets);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,l;\\nint numCarpets;\\nint dp[1000+1][1000+1];\\n    int solve(string &floor, int ind, int rem){\\n        if(ind>=n) return 0;\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        if(floor[ind]==\\'1\\'){\\n           int pick=INT_MAX,not_pick=INT_MAX;\\n\\n            if(rem) pick=solve(floor,ind+l,rem-1);\\n            not_pick=1+solve(floor,ind+1,rem);\\n            return dp[ind][rem]=min(op1,op2);\\n        }\\n        return dp[ind][rem]=solve(floor,ind+1,rem);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n=floor.size(), l=carpetLen;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(floor,0,numCarpets);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776595,
                "title": "dp-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,string &s,int k,int len,vector<int> &pre,vector<vector<int>> &dp){\\n        int n = s.size();\\n        if(i>=n) return 0;\\n        \\n        if(dp[i][k]!=-1) return dp[i][k];\\n        \\n        int tk=-1e9,ksum=0;\\n        ksum=(i+len<=n)?(pre[i+len]-pre[i]):(pre[n]-pre[i]);\\n        \\n        if(k>0 and s[i]==\\'1\\') tk = ksum+solve(i+len,s,k-1,len,pre,dp);\\n        int nottk = 0+solve(i+1,s,k,len,pre,dp);\\n        \\n        return dp[i][k]=max(tk,nottk);\\n    }\\n    int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        int n = s.size();\\n        vector<int> pre(n+1,0);\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,-1));\\n        for(int i=1;i<=n;i++) {\\n            pre[i]=pre[i-1];\\n            if(s[i-1]==\\'1\\') pre[i]+=1;\\n        }\\n        \\n        return pre[n]-solve(0,s,numCarpets,carpetLen,pre,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,string &s,int k,int len,vector<int> &pre,vector<vector<int>> &dp){\\n        int n = s.size();\\n        if(i>=n) return 0;\\n        \\n        if(dp[i][k]!=-1) return dp[i][k];\\n        \\n        int tk=-1e9,ksum=0;\\n        ksum=(i+len<=n)?(pre[i+len]-pre[i]):(pre[n]-pre[i]);\\n        \\n        if(k>0 and s[i]==\\'1\\') tk = ksum+solve(i+len,s,k-1,len,pre,dp);\\n        int nottk = 0+solve(i+1,s,k,len,pre,dp);\\n        \\n        return dp[i][k]=max(tk,nottk);\\n    }\\n    int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        int n = s.size();\\n        vector<int> pre(n+1,0);\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,-1));\\n        for(int i=1;i<=n;i++) {\\n            pre[i]=pre[i-1];\\n            if(s[i-1]==\\'1\\') pre[i]+=1;\\n        }\\n        \\n        return pre[n]-solve(0,s,numCarpets,carpetLen,pre,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763375,
                "title": "my-solution",
                "content": "```\\n/**\\n * the dynamic programming solution is employed.\\n *\\n * `dp[carpets][tiles]` stands for the minimum number of while tiles\\n * when `carpets` carpets have been covered in the tile range [0, tiles),\\n * 0 inclusive, `tiles` exclusive.\\n * where `carpets` is in the range [0, `numCarpets`], both inclusive\\n *       `tiles` is in the range [0, `floor.size()`], both inclusive\\n *\\n * initial:\\n * if `carpets` == 0\\n * 1. if tiles == 0,\\n *    dp[carpets][tiles] = 0\\n * 2. if tiles > 0,\\n *    dp[carpets][tiles] = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n *\\n * induction:\\n * 1. if tiles == 0\\n *    dp[carpets][tiles] = 0\\n * 2. otherwise\\n * 2.1. let `covered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is covered by a carpet\\n *      covered = dp[carpets - 1][max(0, tiles - carpetLen)]\\n * 2.2. let `uncovered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is not covered by a carpet,\\n *      uncovered = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n * dp[carpets][tiles] = min(covered, uncovered)\\n *\\n * target:\\n * dp[numCarpets][floor.size()]\\n *\\n * Time Complexity: O(numCarpets * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `floor`\\n */\\nclass Solution {\\n public:\\n  int minimumWhiteTiles(const string &floor, const int numCarpets, const int carpetLen) {\\n    constexpr int range = 2;\\n    constexpr char white = \\'1\\';\\n    const int n = static_cast<int>(floor.size());\\n    int dp[range][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int tiles = 1; tiles < n + 1; ++tiles) {\\n      dp[previous][tiles] = dp[previous][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n    }\\n    \\n    for (int carpets = 1; carpets < numCarpets + 1; ++carpets) {\\n      for (int tiles = 1; tiles < n + 1; ++tiles) {\\n        const int covered = dp[previous][max(0, tiles - carpetLen)];\\n        const int uncovered = dp[current][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n        dp[current][tiles] = min(covered, uncovered);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    \\n    return dp[previous][n];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * the dynamic programming solution is employed.\\n *\\n * `dp[carpets][tiles]` stands for the minimum number of while tiles\\n * when `carpets` carpets have been covered in the tile range [0, tiles),\\n * 0 inclusive, `tiles` exclusive.\\n * where `carpets` is in the range [0, `numCarpets`], both inclusive\\n *       `tiles` is in the range [0, `floor.size()`], both inclusive\\n *\\n * initial:\\n * if `carpets` == 0\\n * 1. if tiles == 0,\\n *    dp[carpets][tiles] = 0\\n * 2. if tiles > 0,\\n *    dp[carpets][tiles] = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n *\\n * induction:\\n * 1. if tiles == 0\\n *    dp[carpets][tiles] = 0\\n * 2. otherwise\\n * 2.1. let `covered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is covered by a carpet\\n *      covered = dp[carpets - 1][max(0, tiles - carpetLen)]\\n * 2.2. let `uncovered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is not covered by a carpet,\\n *      uncovered = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n * dp[carpets][tiles] = min(covered, uncovered)\\n *\\n * target:\\n * dp[numCarpets][floor.size()]\\n *\\n * Time Complexity: O(numCarpets * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `floor`\\n */\\nclass Solution {\\n public:\\n  int minimumWhiteTiles(const string &floor, const int numCarpets, const int carpetLen) {\\n    constexpr int range = 2;\\n    constexpr char white = \\'1\\';\\n    const int n = static_cast<int>(floor.size());\\n    int dp[range][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int tiles = 1; tiles < n + 1; ++tiles) {\\n      dp[previous][tiles] = dp[previous][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n    }\\n    \\n    for (int carpets = 1; carpets < numCarpets + 1; ++carpets) {\\n      for (int tiles = 1; tiles < n + 1; ++tiles) {\\n        const int covered = dp[previous][max(0, tiles - carpetLen)];\\n        const int uncovered = dp[current][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n        dp[current][tiles] = min(covered, uncovered);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    \\n    return dp[previous][n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729027,
                "title": "c-java-memoization-commented",
                "content": "## Code\\n```C++ []\\nclass Solution {\\npublic:\\n\\n    #define WHITE \\'1\\'\\n    \\n    vector<vector<int>> dp;\\n    int n, c;\\n    \\n    int solve(string &floor, int ind, int rem){\\n\\n        // Reached end - No white tiles visible\\n        if(ind >= n) return 0;\\n\\n        // Checking cache\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        int res = 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n        \\n        // Don\\'t cover this tile \\n        // If its a white tile, one white tile is visible already\\n        res = (floor[ind] == WHITE) + solve(floor, ind + 1, rem);\\n        \\n        // Cover this tile if its a white tile and carpets are still remaining\\n        if(floor[ind] == WHITE and rem) res = min(res, solve(floor, ind + c, rem - 1));\\n        \\n        // Caching\\n        return dp[ind][rem] = res;\\n        \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n = floor.length(), c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = vector<vector<int>> (n + 1, vector<int> (numCarpets + 1, -1));\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n\\n    private static final char WHITE = \\'1\\';\\n    private int[][] dp;\\n    private int n, c;\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        n = floor.length();\\n        c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = new int[n + 1][numCarpets + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n\\n    private int solve(String floor, int ind, int rem) {\\n        // Reached end - No white tiles visible\\n        if (ind >= n) {\\n            return 0;\\n        }\\n\\n        // Checking cache\\n        if (dp[ind][rem] != -1) {\\n            return dp[ind][rem];\\n        }\\n\\n        int res = (int) 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n\\n        // Don\\'t cover this tile\\n        // If it\\'s a white tile, one white tile is visible already\\n        res = (floor.charAt(ind) == WHITE ? 1 : 0) + solve(floor, ind + 1, rem);\\n\\n        // Cover this tile if it\\'s a white tile and carpets are still remaining\\n        if (floor.charAt(ind) == WHITE && rem > 0) {\\n            res = Math.min(res, solve(floor, ind + c, rem - 1));\\n        }\\n\\n        // Caching\\n        dp[ind][rem] = res;\\n        return res;\\n    }\\n}\\n\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    #define WHITE \\'1\\'\\n    \\n    vector<vector<int>> dp;\\n    int n, c;\\n    \\n    int solve(string &floor, int ind, int rem){\\n\\n        // Reached end - No white tiles visible\\n        if(ind >= n) return 0;\\n\\n        // Checking cache\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        int res = 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n        \\n        // Don\\'t cover this tile \\n        // If its a white tile, one white tile is visible already\\n        res = (floor[ind] == WHITE) + solve(floor, ind + 1, rem);\\n        \\n        // Cover this tile if its a white tile and carpets are still remaining\\n        if(floor[ind] == WHITE and rem) res = min(res, solve(floor, ind + c, rem - 1));\\n        \\n        // Caching\\n        return dp[ind][rem] = res;\\n        \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n = floor.length(), c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = vector<vector<int>> (n + 1, vector<int> (numCarpets + 1, -1));\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n\\n    private static final char WHITE = \\'1\\';\\n    private int[][] dp;\\n    private int n, c;\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        n = floor.length();\\n        c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = new int[n + 1][numCarpets + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n\\n    private int solve(String floor, int ind, int rem) {\\n        // Reached end - No white tiles visible\\n        if (ind >= n) {\\n            return 0;\\n        }\\n\\n        // Checking cache\\n        if (dp[ind][rem] != -1) {\\n            return dp[ind][rem];\\n        }\\n\\n        int res = (int) 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n\\n        // Don\\'t cover this tile\\n        // If it\\'s a white tile, one white tile is visible already\\n        res = (floor.charAt(ind) == WHITE ? 1 : 0) + solve(floor, ind + 1, rem);\\n\\n        // Cover this tile if it\\'s a white tile and carpets are still remaining\\n        if (floor.charAt(ind) == WHITE && rem > 0) {\\n            res = Math.min(res, solve(floor, ind + c, rem - 1));\\n        }\\n\\n        // Caching\\n        dp[ind][rem] = res;\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727529,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "```dp[i][j]``` is minimum number of visible white tiles in the first ```i``` tiles ([0, i]) which are coverd by ```j``` carpets.\\nIf the tile is black, ```dp[i][j] = dp[i][j-1] + 1```.\\nIf the tile is white, we have 2 choices,\\none is using a carpet to to cover it, ```dp[i][j] = dp[i-1][j-carpetLen]```.\\nAnother is not to cover it, ```dp[i][j] = dp[i][j-1] + 1```.\\nWe select minimum choice, ```dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])```.\\n\\nAt first, there is no carpet, so ```dp[0][j]``` is number of white tiles in the first ```j``` tiles.\\n\\ntc and sc are O(numCarpets * len(floor))\\n\\n### python\\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n\\t\\t\\n\\t\\t# floor are covered by carpets entirely\\n        if numCarpets * carpetLen >= size: return 0\\n\\t\\t\\n        dp  = [[0] * size for _ in range(numCarpets+1)]\\n\\t\\t\\n\\t\\t# At first, there is no carpet\\n\\t\\t# dp[0][j] is number of white tiles in the first j tiles\\n        dp[0][0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i])\\n        \\n        for i in range(1, numCarpets+1):\\n\\t\\t\\t# there have i carpets, it can covered i * carpetLen tiles, \\n\\t\\t\\t# so dp[i][0...i * carpetLen-1] are 0\\n\\t\\t\\t\\n            for j in range(i * carpetLen, size):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# min(not to cover, use a carpet to cover j-th tile)\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])\\n        return dp[numCarpets][-1]\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int size = floor.size();\\n        if (numCarpets * carpetLen >= size) return 0;\\n        vector<vector<int>> dp (numCarpets+1, vector<int>(size));\\n        dp[0][0] = (\\'1\\' == floor[0]);\\n        for (int i = 1; i < size; i+=1) \\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i]); \\n        for (int i = 1; i <= numCarpets; i+=1) {\\n            for (int j = i * carpetLen; j < size; j+=1) {\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen]); \\n            }\\n        }\\n        return dp[numCarpets][size-1];\\n    }\\n};\\n```\\n### space optimization\\nuse scrolling array.\\n### python\\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n        if numCarpets * carpetLen >= size: return 0\\n        dp  = [0] * size\\n        dp[0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[i] = dp[i-1] + (\\'1\\' == floor[i])\\n        for i in range(1, numCarpets+1):\\n            tmp = dp[:] # dp[i-1][j-carpetLen]\\n            dp[i * carpetLen - 1] = 0 # notice that dp[j-1]\\n            for j in range(i * carpetLen, size):\\n                dp[j] = min(dp[j-1] + (\\'1\\' == floor[j]), tmp[j-carpetLen])\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n```i```\n```j```\n```dp[i][j] = dp[i][j-1] + 1```\n```dp[i][j] = dp[i-1][j-carpetLen]```\n```dp[i][j] = dp[i][j-1] + 1```\n```dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])```\n```dp[0][j]```\n```j```\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n\\t\\t\\n\\t\\t# floor are covered by carpets entirely\\n        if numCarpets * carpetLen >= size: return 0\\n\\t\\t\\n        dp  = [[0] * size for _ in range(numCarpets+1)]\\n\\t\\t\\n\\t\\t# At first, there is no carpet\\n\\t\\t# dp[0][j] is number of white tiles in the first j tiles\\n        dp[0][0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i])\\n        \\n        for i in range(1, numCarpets+1):\\n\\t\\t\\t# there have i carpets, it can covered i * carpetLen tiles, \\n\\t\\t\\t# so dp[i][0...i * carpetLen-1] are 0\\n\\t\\t\\t\\n            for j in range(i * carpetLen, size):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# min(not to cover, use a carpet to cover j-th tile)\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])\\n        return dp[numCarpets][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int size = floor.size();\\n        if (numCarpets * carpetLen >= size) return 0;\\n        vector<vector<int>> dp (numCarpets+1, vector<int>(size));\\n        dp[0][0] = (\\'1\\' == floor[0]);\\n        for (int i = 1; i < size; i+=1) \\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i]); \\n        for (int i = 1; i <= numCarpets; i+=1) {\\n            for (int j = i * carpetLen; j < size; j+=1) {\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen]); \\n            }\\n        }\\n        return dp[numCarpets][size-1];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n        if numCarpets * carpetLen >= size: return 0\\n        dp  = [0] * size\\n        dp[0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[i] = dp[i-1] + (\\'1\\' == floor[i])\\n        for i in range(1, numCarpets+1):\\n            tmp = dp[:] # dp[i-1][j-carpetLen]\\n            dp[i * carpetLen - 1] = 0 # notice that dp[j-1]\\n            for j in range(i * carpetLen, size):\\n                dp[j] = min(dp[j-1] + (\\'1\\' == floor[j]), tmp[j-carpetLen])\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697042,
                "title": "easy-to-understand-c-recursive-memoization-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic Programming take and not take simple intuition.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolved using Dynamic Programming approach.\\nThere are 3 case , starting from the first tile \\n1. Black tile : skip and move to next tile\\n2. White tile not Take : skip and move to next tile\\n3. White tile take : use the carpet to cover and move to (curr tile + carpetLen - 1 )th tile\\nthen take the max of all.\\nWe are taking max because we have to find min uncovered tile, so max covered tile. \\n\\n# Complexity\\n- Time complexity:\\nO(floor.length() * numCarpets)\\n\\n- Space complexity:\\nO(floor.length() * numCarpets)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int i, int num, int &len, vector<int> &prefix_floor, string &floor,int &n,vector<vector<int>> &dp){\\n        if(i>=n || num==0) return 0;\\n        if(dp[i][num]!=-1) return dp[i][num];\\n        if(floor[i]==\\'0\\') return dp[i][num] = f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int notTake =  f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int bnd = min(i+len-1,n-1);\\n        int white = prefix_floor[bnd];\\n        if(i!=0) white = white - prefix_floor[i-1];\\n        int take = white + f(i+len,num-1,len,prefix_floor,floor,n,dp);\\n        return dp[i][num] = max(take,notTake);\\n    }\\n\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> prefix_floor;\\n        int count = 0;\\n        if(floor[0]==\\'1\\'){\\n            prefix_floor.push_back(1);\\n            count++;\\n        }\\n        else prefix_floor.push_back(1);\\n        for(int i=1; i<n; i++){\\n            if(floor[i]==\\'1\\'){\\n                prefix_floor.push_back(1 + prefix_floor[i-1]);\\n                count++;\\n            }\\n            else{\\n                prefix_floor.push_back(prefix_floor[i-1]);\\n            }\\n        }\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        return count-f(0,numCarpets,carpetLen,prefix_floor,floor,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(int i, int num, int &len, vector<int> &prefix_floor, string &floor,int &n,vector<vector<int>> &dp){\\n        if(i>=n || num==0) return 0;\\n        if(dp[i][num]!=-1) return dp[i][num];\\n        if(floor[i]==\\'0\\') return dp[i][num] = f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int notTake =  f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int bnd = min(i+len-1,n-1);\\n        int white = prefix_floor[bnd];\\n        if(i!=0) white = white - prefix_floor[i-1];\\n        int take = white + f(i+len,num-1,len,prefix_floor,floor,n,dp);\\n        return dp[i][num] = max(take,notTake);\\n    }\\n\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> prefix_floor;\\n        int count = 0;\\n        if(floor[0]==\\'1\\'){\\n            prefix_floor.push_back(1);\\n            count++;\\n        }\\n        else prefix_floor.push_back(1);\\n        for(int i=1; i<n; i++){\\n            if(floor[i]==\\'1\\'){\\n                prefix_floor.push_back(1 + prefix_floor[i-1]);\\n                count++;\\n            }\\n            else{\\n                prefix_floor.push_back(prefix_floor[i-1]);\\n            }\\n        }\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        return count-f(0,numCarpets,carpetLen,prefix_floor,floor,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560127,
                "title": "python-readable-and-easy-understand-dp-solution-commented-86-faster",
                "content": "# Intuition\\nIf the tile is white, put there a carpet or not.\\n\\n# Complexity\\n- Time complexity: O(n*numCarpets)\\n\\n- Space complexity: O(n*numCarpets)\\n\\n# Code\\n```\\nclass Solution(object):\\n    \\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        dp = [[0]*(numCarpets+1) for i in range(len(floor))]\\n\\n        for i in range(len(floor)):\\n            for j in range(numCarpets+1):\\n                if j == 0:              # no carpets\\n                    dp[i][j] = floor.count(\\'1\\', 0, i+1)\\n                elif floor[i] == \\'0\\':   # black tail\\n                    dp[i][j] = dp[i-1][j]\\n                elif carpetLen > i:     # the carpet is longer than the tails\\n                    dp[i][j] = 0\\n                else:                   # put a carpet or leave it visible\\n                    dp[i][j] = min(dp[i-1][j] + 1,\\n                                   dp[i-carpetLen][j-1])\\n        \\n        return dp[len(floor)-1][numCarpets]\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        dp = [[0]*(numCarpets+1) for i in range(len(floor))]\\n\\n        for i in range(len(floor)):\\n            for j in range(numCarpets+1):\\n                if j == 0:              # no carpets\\n                    dp[i][j] = floor.count(\\'1\\', 0, i+1)\\n                elif floor[i] == \\'0\\':   # black tail\\n                    dp[i][j] = dp[i-1][j]\\n                elif carpetLen > i:     # the carpet is longer than the tails\\n                    dp[i][j] = 0\\n                else:                   # put a carpet or leave it visible\\n                    dp[i][j] = min(dp[i-1][j] + 1,\\n                                   dp[i-carpetLen][j-1])\\n        \\n        return dp[len(floor)-1][numCarpets]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544325,
                "title": "python3-clean-and-concise-dp",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cl: int) -> int:\\n        \\n        n=len(floor)\\n        total=sum(int(ch) for ch in floor)\\n        \\n        @cache\\n        def f(ind,count):\\n            if ind<0 or count==0:\\n                return 0\\n            \\n            ans=floor[max(0,ind-cl+1):ind+1].count(\"1\") + f(ind-cl,count-1)\\n            ans=max(ans,f(ind-1,count))\\n            \\n            return ans\\n        \\n        return total-f(n-1,nc)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cl: int) -> int:\\n        \\n        n=len(floor)\\n        total=sum(int(ch) for ch in floor)\\n        \\n        @cache\\n        def f(ind,count):\\n            if ind<0 or count==0:\\n                return 0\\n            \\n            ans=floor[max(0,ind-cl+1):ind+1].count(\"1\") + f(ind-cl,count-1)\\n            ans=max(ans,f(ind-1,count))\\n            \\n            return ans\\n        \\n        return total-f(n-1,nc)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542793,
                "title": "python-simple-dp-solution-with-simple-explanation-in-comments",
                "content": "\\n- Space complexity:\\nO(n^2) time and space\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        # first thought is dp[i][j] = min white covering floor[i:] with j carpets of carpetLen\\n        # dp[i-1][j] = dp[i][j] if floor[i-1] is black\\n        # if floor[i-1] is white, then either we can cover it with a carpet or not\\n            # either its dp[i][j]+1 (an extra white that is uncovered) or\\n            # dp[i+carpetLen][j-1] whichever is smaller. \\n         \\n        # last row will be covering nothing on the floor with j carpets, so all 0\\n        # first column will be covering floor[i:] with 0 carpets\\n        dp = []\\n        for i in range(len(floor)): dp.append([1000]*(numCarpets+1))\\n        dp.append([0]*(numCarpets+1))\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(numCarpets, -1, -1):\\n                if floor[i] == \"0\": #black\\n                    dp[i][j] = dp[i+1][j]\\n                else: #white\\n                    uncover = dp[i+1][j] +1\\n                    upper_bound = min(i+carpetLen, len(floor)) \\n                    cover = 9999\\n                    if j-1>=0:\\n                        cover = dp[upper_bound][j-1]\\n                    dp[i][j] = min(uncover, cover)\\n        return dp[0][numCarpets]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        # first thought is dp[i][j] = min white covering floor[i:] with j carpets of carpetLen\\n        # dp[i-1][j] = dp[i][j] if floor[i-1] is black\\n        # if floor[i-1] is white, then either we can cover it with a carpet or not\\n            # either its dp[i][j]+1 (an extra white that is uncovered) or\\n            # dp[i+carpetLen][j-1] whichever is smaller. \\n         \\n        # last row will be covering nothing on the floor with j carpets, so all 0\\n        # first column will be covering floor[i:] with 0 carpets\\n        dp = []\\n        for i in range(len(floor)): dp.append([1000]*(numCarpets+1))\\n        dp.append([0]*(numCarpets+1))\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(numCarpets, -1, -1):\\n                if floor[i] == \"0\": #black\\n                    dp[i][j] = dp[i+1][j]\\n                else: #white\\n                    uncover = dp[i+1][j] +1\\n                    upper_bound = min(i+carpetLen, len(floor)) \\n                    cover = 9999\\n                    if j-1>=0:\\n                        cover = dp[upper_bound][j-1]\\n                    dp[i][j] = min(uncover, cover)\\n        return dp[0][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534474,
                "title": "dp-recursion-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(string &floor, int numCarpets, int carpetLen,int index,vector<vector<int>>&dp )\\n    {\\n        int n =floor.size();\\n        if(index>=n)return 0;\\n        if(dp[index][numCarpets]!=-1)return dp[index][numCarpets];\\n        int o1=INT_MAX;\\n        int o2=INT_MAX;\\n        if(floor[index]==\\'1\\')\\n        {\\n            o1=1+dfs(floor,numCarpets,carpetLen,index+1,dp);\\n            if(numCarpets>0)\\n            {\\n                o2=dfs(floor,numCarpets-1,carpetLen,index+carpetLen,dp);\\n            }\\n        }\\n        else\\n        {\\n           return dp[index][numCarpets]=dfs(floor,numCarpets,carpetLen,index+1,dp); \\n        }\\n        return dp[index][numCarpets]=min(o1,o2);\\n\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return dfs(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(string &floor, int numCarpets, int carpetLen,int index,vector<vector<int>>&dp )\\n    {\\n        int n =floor.size();\\n        if(index>=n)return 0;\\n        if(dp[index][numCarpets]!=-1)return dp[index][numCarpets];\\n        int o1=INT_MAX;\\n        int o2=INT_MAX;\\n        if(floor[index]==\\'1\\')\\n        {\\n            o1=1+dfs(floor,numCarpets,carpetLen,index+1,dp);\\n            if(numCarpets>0)\\n            {\\n                o2=dfs(floor,numCarpets-1,carpetLen,index+carpetLen,dp);\\n            }\\n        }\\n        else\\n        {\\n           return dp[index][numCarpets]=dfs(floor,numCarpets,carpetLen,index+1,dp); \\n        }\\n        return dp[index][numCarpets]=min(o1,o2);\\n\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return dfs(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528393,
                "title": "ruby-100",
                "content": "\\n# Code\\n```\\ndef minimum_white_tiles(floor, num_carpets, carpet_len)\\n  n = floor.length\\n  return 0 if carpet_len * num_carpets >= n\\n\\n  floor_list = floor.chars.map { |c| c == \\'1\\' ? 1 : 0 }\\n  dp = Array.new(num_carpets) { Array.new(n, 0) }\\n\\n  (carpet_len...n).each do |i|\\n    dp[0][i] = [floor_list[i] + dp[0][i - 1], floor_list[0..(i - carpet_len)].sum].min\\n  end\\n\\n  (1...num_carpets).each do |j|\\n    (carpet_len * j...n).each do |i|\\n      dp[j][i] = [floor_list[i] + dp[j][i - 1], dp[j - 1][i - carpet_len]].min\\n    end\\n  end\\n\\n  dp[-1][-1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_white_tiles(floor, num_carpets, carpet_len)\\n  n = floor.length\\n  return 0 if carpet_len * num_carpets >= n\\n\\n  floor_list = floor.chars.map { |c| c == \\'1\\' ? 1 : 0 }\\n  dp = Array.new(num_carpets) { Array.new(n, 0) }\\n\\n  (carpet_len...n).each do |i|\\n    dp[0][i] = [floor_list[i] + dp[0][i - 1], floor_list[0..(i - carpet_len)].sum].min\\n  end\\n\\n  (1...num_carpets).each do |j|\\n    (carpet_len * j...n).each do |i|\\n      dp[j][i] = [floor_list[i] + dp[j][i - 1], dp[j - 1][i - carpet_len]].min\\n    end\\n  end\\n\\n  dp[-1][-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3484473,
                "title": "c-dynamic-programming-pick-not-pick",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(string &floor, int i){\\n        int count = 0;\\n        for(int j=i;j<floor.size();j++)\\n            count += floor[j] == \\'1\\';\\n        return count;\\n    }\\n    \\n    \\n    int solve(string &floor, int num, int len, int i, vector<vector<int>> &dp){\\n        if(i >= floor.size())\\n            return 0;\\n        if(num == 0)\\n            return fun(floor,i);\\n        if(dp[i][num] != -1)\\n            return dp[i][num];\\n        int take = solve(floor,num-1,len,i+len,dp);\\n        int nottake = solve(floor,num,len,i+1,dp);\\n        if(floor[i] == \\'1\\')\\n            nottake++;\\n        return dp[i][num] = min(take,nottake);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.size()+1,vector<int> (numCarpets+1,-1));\\n        return solve(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(string &floor, int i){\\n        int count = 0;\\n        for(int j=i;j<floor.size();j++)\\n            count += floor[j] == \\'1\\';\\n        return count;\\n    }\\n    \\n    \\n    int solve(string &floor, int num, int len, int i, vector<vector<int>> &dp){\\n        if(i >= floor.size())\\n            return 0;\\n        if(num == 0)\\n            return fun(floor,i);\\n        if(dp[i][num] != -1)\\n            return dp[i][num];\\n        int take = solve(floor,num-1,len,i+len,dp);\\n        int nottake = solve(floor,num,len,i+1,dp);\\n        if(floor[i] == \\'1\\')\\n            nottake++;\\n        return dp[i][num] = min(take,nottake);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.size()+1,vector<int> (numCarpets+1,-1));\\n        return solve(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407430,
                "title": "simple-memoization-based-solution",
                "content": "# Approach\\nThree choices\\n1. Use carpet if available and necessary. In this can case jump to index + carpet length\\n2. Do not use carpet even if available and necessary. Increase count by 1 and move to next index. Here we save carpt to be used later. \\n3. Handle scenarios like no carpet available or carpet not necessary because tile is lready black. \\n\\n\\n# Complexity\\n- Time complexity: $$O(floorLength * numberOfCarpets)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(floorLength * numberOfCarpets)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] memo = new int[floor.length()][numCarpets+1];\\n        for(int[] arr : memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return solve(floor, numCarpets, carpetLen, 0, memo);\\n    }\\n\\n    int solve(String floor, int numCarpets, int carpetLen, int index, int[][] memo) {\\n        if(index >= floor.length()) {\\n            return 0;\\n        }\\n        if(memo[index][numCarpets] != -1) {\\n            return memo[index][numCarpets];\\n        }\\n        if(numCarpets > 0) {\\n            if(floor.charAt(index) == \\'0\\') {\\n                return memo[index][numCarpets] = solve(floor, numCarpets, carpetLen, index+1, memo);\\n            }\\n            else {\\n                int coveredWhite = solve(floor, numCarpets-1, carpetLen, index+carpetLen, memo);\\n                int unCoveredWhite = 1 + solve(floor, numCarpets, carpetLen, index+1, memo);\\n                return memo[index][numCarpets] = Math.min(coveredWhite, unCoveredWhite);\\n            }\\n        }\\n        else {\\n            int count = 0;\\n            for(int i = index; i < floor.length(); i++) {\\n                count = floor.charAt(i) == \\'1\\' ? count + 1 : count;\\n            }\\n            return memo[index][numCarpets] = count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] memo = new int[floor.length()][numCarpets+1];\\n        for(int[] arr : memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return solve(floor, numCarpets, carpetLen, 0, memo);\\n    }\\n\\n    int solve(String floor, int numCarpets, int carpetLen, int index, int[][] memo) {\\n        if(index >= floor.length()) {\\n            return 0;\\n        }\\n        if(memo[index][numCarpets] != -1) {\\n            return memo[index][numCarpets];\\n        }\\n        if(numCarpets > 0) {\\n            if(floor.charAt(index) == \\'0\\') {\\n                return memo[index][numCarpets] = solve(floor, numCarpets, carpetLen, index+1, memo);\\n            }\\n            else {\\n                int coveredWhite = solve(floor, numCarpets-1, carpetLen, index+carpetLen, memo);\\n                int unCoveredWhite = 1 + solve(floor, numCarpets, carpetLen, index+1, memo);\\n                return memo[index][numCarpets] = Math.min(coveredWhite, unCoveredWhite);\\n            }\\n        }\\n        else {\\n            int count = 0;\\n            for(int i = index; i < floor.length(); i++) {\\n                count = floor.charAt(i) == \\'1\\' ? count + 1 : count;\\n            }\\n            return memo[index][numCarpets] = count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356674,
                "title": "c-golang-dp",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> DP(2, vector<int>(n + carpetLen));\\n        for(int i = n - 1; i >= 0; i--) DP[0][i] += DP[0][i + 1] + floor[i] - \\'0\\';\\n        for(int i = 0; i < numCarpets; i++) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                DP[(i + 1) % 2][j] = min(DP[i % 2][j + carpetLen], DP[(i + 1) % 2][j + 1] + (floor[j] - \\'0\\')); \\n            }\\n        }\\n        return DP[numCarpets % 2][0];\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    var n int = len(floor)\\n    DP := make([][]int, 2)\\n    DP[0] = make([]int, n + carpetLen)\\n    DP[1] = make([]int, n + carpetLen)\\n    for i := n - 1; i >= 0; i-- {\\n        DP[0][i] += DP[0][i + 1] + int(floor[i] - \\'0\\')\\n    } \\n    for i := 0; i < numCarpets; i++ {\\n        for j := n - 1; j >= 0; j-- {\\n            DP[(i + 1) % 2][j] = DP[(i + 1) % 2][j + 1] + int(floor[j] - \\'0\\')\\n            if DP[i % 2][j + carpetLen] < DP[(i + 1) % 2][j] {\\n                DP[(i + 1) % 2][j] = DP[i % 2][j + carpetLen]\\n            }\\n        }\\n    }\\n    return DP[numCarpets % 2][0]\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> DP(2, vector<int>(n + carpetLen));\\n        for(int i = n - 1; i >= 0; i--) DP[0][i] += DP[0][i + 1] + floor[i] - \\'0\\';\\n        for(int i = 0; i < numCarpets; i++) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                DP[(i + 1) % 2][j] = min(DP[i % 2][j + carpetLen], DP[(i + 1) % 2][j + 1] + (floor[j] - \\'0\\')); \\n            }\\n        }\\n        return DP[numCarpets % 2][0];\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    var n int = len(floor)\\n    DP := make([][]int, 2)\\n    DP[0] = make([]int, n + carpetLen)\\n    DP[1] = make([]int, n + carpetLen)\\n    for i := n - 1; i >= 0; i-- {\\n        DP[0][i] += DP[0][i + 1] + int(floor[i] - \\'0\\')\\n    } \\n    for i := 0; i < numCarpets; i++ {\\n        for j := n - 1; j >= 0; j-- {\\n            DP[(i + 1) % 2][j] = DP[(i + 1) % 2][j + 1] + int(floor[j] - \\'0\\')\\n            if DP[i % 2][j + carpetLen] < DP[(i + 1) % 2][j] {\\n                DP[(i + 1) % 2][j] = DP[i % 2][j + carpetLen]\\n            }\\n        }\\n    }\\n    return DP[numCarpets % 2][0]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262511,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_white_tiles(floor: String, num_carpets: i32, carpet_len: i32) -> i32 {\\n        let floor = floor.as_bytes();\\n        let n = floor.len();\\n        let mut dp = vec![vec![0; num_carpets as usize + 1]; n + 1];\\n        for i in 1..=n {\\n            for k in 0..=num_carpets as usize {\\n                let jump = dp[i - 1][k] + (floor[i - 1] - b\\'0\\') as i32;\\n                let cover = if k > 0 {\\n                    dp[i.saturating_sub(carpet_len as usize)][k - 1]\\n                } else {\\n                    1000\\n                };\\n                dp[i][k] = jump.min(cover);\\n            }\\n        }\\n        dp[n][num_carpets as usize]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_white_tiles(floor: String, num_carpets: i32, carpet_len: i32) -> i32 {\\n        let floor = floor.as_bytes();\\n        let n = floor.len();\\n        let mut dp = vec![vec![0; num_carpets as usize + 1]; n + 1];\\n        for i in 1..=n {\\n            for k in 0..=num_carpets as usize {\\n                let jump = dp[i - 1][k] + (floor[i - 1] - b\\'0\\') as i32;\\n                let cover = if k > 0 {\\n                    dp[i.saturating_sub(carpet_len as usize)][k - 1]\\n                } else {\\n                    1000\\n                };\\n                dp[i][k] = jump.min(cover);\\n            }\\n        }\\n        dp[n][num_carpets as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238008,
                "title": "python-memo-recursion",
                "content": "Here I collect number of covered `1` and then return the difference between the total number of `1` and number of covered, trying to minimize the coverage which in turn minimize the difference.\\n\\n```\\nimport heapq\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        memo = [[None] * numCarpets for _ in range(len(floor))]\\n        prefix = [0] * (len(floor) + 1)\\n        for i, val in enumerate(floor):\\n            prefix[i + 1] = int(val) + prefix[i]\\n        \\n        def helper(i, k):\\n            nonlocal floor, numCarpets, carpetLen, prefix, memo\\n            \\n            if i == len(floor) or k == -1:\\n                return 0\\n            if memo[i][k] is not None:\\n                return memo[i][k]\\n            \\n            right = min(i + carpetLen, len(floor))\\n            covered = prefix[right] - prefix[i] + helper(right, k - 1)\\n            not_covered = helper(i + 1, k)\\n            memo[i][k] = max(covered,  not_covered)\\n            \\n            return memo[i][k]\\n        \\n        return prefix[-1] - helper(0, numCarpets - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        memo = [[None] * numCarpets for _ in range(len(floor))]\\n        prefix = [0] * (len(floor) + 1)\\n        for i, val in enumerate(floor):\\n            prefix[i + 1] = int(val) + prefix[i]\\n        \\n        def helper(i, k):\\n            nonlocal floor, numCarpets, carpetLen, prefix, memo\\n            \\n            if i == len(floor) or k == -1:\\n                return 0\\n            if memo[i][k] is not None:\\n                return memo[i][k]\\n            \\n            right = min(i + carpetLen, len(floor))\\n            covered = prefix[right] - prefix[i] + helper(right, k - 1)\\n            not_covered = helper(i + 1, k)\\n            memo[i][k] = max(covered,  not_covered)\\n            \\n            return memo[i][k]\\n        \\n        return prefix[-1] - helper(0, numCarpets - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214130,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        n, k = len(floor), numCarpets\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if k < 0:\\n                return float(\"inf\")\\n\\n            if i >= n:\\n                return 0\\n\\n            if floor[i] == \"1\": return min(1+dfs(i+1,k),dfs(i+carpetLen,k-1))\\n\\n            return dfs(i+1,k)\\n\\n        return dfs(0,k)\\n\\n            \\n\\n            \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        n, k = len(floor), numCarpets\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if k < 0:\\n                return float(\"inf\")\\n\\n            if i >= n:\\n                return 0\\n\\n            if floor[i] == \"1\": return min(1+dfs(i+1,k),dfs(i+carpetLen,k-1))\\n\\n            return dfs(i+1,k)\\n\\n        return dfs(0,k)\\n\\n            \\n\\n            \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191098,
                "title": "python-dp-how-to-avoid-tle",
                "content": "The thing I did to avoid TLE was, if you come to a point where the last carpetLen tiles are all 1s, you can \\'break\\' and greedily stop looking to place this next carpet after, as you won\\'t get a better result than if you place it here (or before here).\\n\\nThat\\'s in this line: \\'                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\'\\n\\n\\'\\'\\'\\nmemo={}\\n        floor = [int(floor[i]) for i in range(len(floor))]\\n        pres = [0]\\n        for i in floor:\\n            pres.append(pres[-1] + i)\\n        \\n            \\n        N=len(floor)\\n        \\n        def dp(ind,carpetsleft):\\n            nonlocal memo\\n            nonlocal pres\\n            nonlocal N\\n            \\n            if ind>=len(floor):\\n                return 0\\n            if (ind,carpetsleft) in memo:\\n                return memo[(ind,carpetsleft)]\\n            if carpetsleft ==0:\\n                return pres[-1] - pres[ind]\\n            \\n            cur = float(\\'inf\\')\\n            uncovered = 0\\n            for i in range(ind,N):\\n                \\n                cur = min(cur, uncovered + dp(i+carpetLen,carpetsleft-1))\\n                \\n                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\n                    \\n                uncovered += floor[i]\\n            \\n            memo[(ind,carpetsleft)] = cur\\n            return cur\\n\\n        return dp(0,numCarpets)\\n\\t\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "The thing I did to avoid TLE was, if you come to a point where the last carpetLen tiles are all 1s, you can \\'break\\' and greedily stop looking to place this next carpet after, as you won\\'t get a better result than if you place it here (or before here).\\n\\nThat\\'s in this line: \\'                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\'\\n\\n\\'\\'\\'\\nmemo={}\\n        floor = [int(floor[i]) for i in range(len(floor))]\\n        pres = [0]\\n        for i in floor:\\n            pres.append(pres[-1] + i)\\n        \\n            \\n        N=len(floor)\\n        \\n        def dp(ind,carpetsleft):\\n            nonlocal memo\\n            nonlocal pres\\n            nonlocal N\\n            \\n            if ind>=len(floor):\\n                return 0\\n            if (ind,carpetsleft) in memo:\\n                return memo[(ind,carpetsleft)]\\n            if carpetsleft ==0:\\n                return pres[-1] - pres[ind]\\n            \\n            cur = float(\\'inf\\')\\n            uncovered = 0\\n            for i in range(ind,N):\\n                \\n                cur = min(cur, uncovered + dp(i+carpetLen,carpetsleft-1))\\n                \\n                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\n                    \\n                uncovered += floor[i]\\n            \\n            memo[(ind,carpetsleft)] = cur\\n            return cur\\n\\n        return dp(0,numCarpets)\\n\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3156969,
                "title": "tc-o-n-number-of-carpet",
                "content": "```\\nclass Solution\\n{\\n    public:\\n      vector<int> pre;\\n        int solve(string &floor, int pos,int num, int len,vector<vector<int>> &dp)\\n        {\\n            if(pos<0)return 0;\\n            if(num==0)return pre[pos];\\n            if(dp[pos][num]!=-1)return dp[pos][num];\\n            int ans=1e9;\\n            if(floor[pos]==\\'0\\')\\n            {\\n                ans=min(ans,solve(floor,pos-1,num,len,dp));\\n            }\\n            else\\n            {\\n                ans=min(ans,min(solve(floor,pos-len,num-1,len,dp),1+solve(floor,pos-1,num,len,dp)));\\n            }\\n            return dp[pos][num]=ans;\\n            \\n        }\\n        int minimumWhiteTiles(string floor, int num, int len)\\n        {\\n            int n=floor.size();\\n            int o=0;\\n            pre.resize(n+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                if(floor[i]==\\'1\\')o++;\\n                pre[i]=o;\\n            }\\n            vector<vector<int>> dp(n+1,vector<int>(num+1,-1));\\n            return solve(floor,n-1,num,len,dp);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n      vector<int> pre;\\n        int solve(string &floor, int pos,int num, int len,vector<vector<int>> &dp)\\n        {\\n            if(pos<0)return 0;\\n            if(num==0)return pre[pos];\\n            if(dp[pos][num]!=-1)return dp[pos][num];\\n            int ans=1e9;\\n            if(floor[pos]==\\'0\\')\\n            {\\n                ans=min(ans,solve(floor,pos-1,num,len,dp));\\n            }\\n            else\\n            {\\n                ans=min(ans,min(solve(floor,pos-len,num-1,len,dp),1+solve(floor,pos-1,num,len,dp)));\\n            }\\n            return dp[pos][num]=ans;\\n            \\n        }\\n        int minimumWhiteTiles(string floor, int num, int len)\\n        {\\n            int n=floor.size();\\n            int o=0;\\n            pre.resize(n+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                if(floor[i]==\\'1\\')o++;\\n                pre[i]=o;\\n            }\\n            vector<vector<int>> dp(n+1,vector<int>(num+1,-1));\\n            return solve(floor,n-1,num,len,dp);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148659,
                "title": "dp-python-clean",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, carpetLen: int) -> int:\\n        m = len(floor)\\n        dp = [[0 for _ in range(m)] for _ in range(n + 1)]\\n        for i in range(len(dp[0])):\\n            dp[0][i] = floor[:i + 1].count(\\'1\\')\\n        for i in range(1, n + 1):\\n            for j in range(i * carpetLen, m):\\n                dp[i][j] = min(dp[i][j - 1] + (floor[j] == \\'1\\'), dp[i - 1][j - carpetLen])\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, carpetLen: int) -> int:\\n        m = len(floor)\\n        dp = [[0 for _ in range(m)] for _ in range(n + 1)]\\n        for i in range(len(dp[0])):\\n            dp[0][i] = floor[:i + 1].count(\\'1\\')\\n        for i in range(1, n + 1):\\n            for j in range(i * carpetLen, m):\\n                dp[i][j] = min(dp[i][j - 1] + (floor[j] == \\'1\\'), dp[i - 1][j - carpetLen])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086449,
                "title": "scala-top-down-dp",
                "content": "```scala\\nimport scala.collection.mutable.HashMap\\nobject Solution {\\n    def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = {\\n        def mem[I, O](f: I => O) = new HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val dp: ((Int, Int)) => Int = mem {\\n            case (i, _) if (i < 0) => 0\\n            case (i, 0) => floor.take(i + 1).count(_ == \\'1\\')\\n            case (i, j) => dp(i - carpetLen, j - 1) min dp(i - 1, j) + floor(i) - \\'0\\'\\n        }\\n        \\n        dp(floor.size - 1, numCarpets)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nimport scala.collection.mutable.HashMap\\nobject Solution {\\n    def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = {\\n        def mem[I, O](f: I => O) = new HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val dp: ((Int, Int)) => Int = mem {\\n            case (i, _) if (i < 0) => 0\\n            case (i, 0) => floor.take(i + 1).count(_ == \\'1\\')\\n            case (i, j) => dp(i - carpetLen, j - 1) min dp(i - 1, j) + floor(i) - \\'0\\'\\n        }\\n        \\n        dp(floor.size - 1, numCarpets)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3076052,
                "title": "3-lines-prefix-sum-python-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cpl: int) -> int:\\n        acc = [0] + list(accumulate(map(int, floor))) + [floor.count(\"1\")] * cpl\\n        @lru_cache(None)\\n        def dp(i, c): return 0 if c==0 or i>=len(floor) else max(dp(i+1,c), acc[i+cpl]-acc[i]+dp(i+cpl,c-1))\\n        return acc[-1] - dp(0, nc)\\n\\n\\n       \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cpl: int) -> int:\\n        acc = [0] + list(accumulate(map(int, floor))) + [floor.count(\"1\")] * cpl\\n        @lru_cache(None)\\n        def dp(i, c): return 0 if c==0 or i>=len(floor) else max(dp(i+1,c), acc[i+cpl]-acc[i]+dp(i+cpl,c-1))\\n        return acc[-1] - dp(0, nc)\\n\\n\\n       \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040120,
                "title": "easy-top-down-dp-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n//returns the min no. of white carpets ;\\n    int f(int i, int k, int kl, string &s, vector<vector<int>> & dp){\\n        //base cases\\n        if(i < 0)return 0;\\n        if(k == 0){\\n            //return all the white tiles in the string s[0...i];\\n            int ones = 0;\\n            for(int ii=0; ii<=i; ii++){\\n                ones += (s[ii]==\\'1\\');\\n            }\\n            return ones;\\n        }\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans = INT_MAX;;\\n        //we ignore;\\n        ans = f(i-1, k, kl, s, dp) + (s[i] == \\'1\\');\\n        //we cover it;\\n        ans = min(ans, f(i-kl, k-1, kl, s, dp));\\n\\n        return dp[i][k] = ans;\\n    }\\n\\n    int minimumWhiteTiles(string s, int k, int kl) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1, -1));\\n        return f(n-1, k, kl, s, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//returns the min no. of white carpets ;\\n    int f(int i, int k, int kl, string &s, vector<vector<int>> & dp){\\n        //base cases\\n        if(i < 0)return 0;\\n        if(k == 0){\\n            //return all the white tiles in the string s[0...i];\\n            int ones = 0;\\n            for(int ii=0; ii<=i; ii++){\\n                ones += (s[ii]==\\'1\\');\\n            }\\n            return ones;\\n        }\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans = INT_MAX;;\\n        //we ignore;\\n        ans = f(i-1, k, kl, s, dp) + (s[i] == \\'1\\');\\n        //we cover it;\\n        ans = min(ans, f(i-kl, k-1, kl, s, dp));\\n\\n        return dp[i][k] = ans;\\n    }\\n\\n    int minimumWhiteTiles(string s, int k, int kl) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1, -1));\\n        return f(n-1, k, kl, s, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971453,
                "title": "c-simple-recursion-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ninclude | exclude dp problems\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate a prefix array to save the loop over carplen \\nand apply DP and recusion over the prefix array\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int solve(int idx,vector<int> &arr,int k,int n,vector<vector<int>> &dp){\\n        if(n==0 || idx>=arr.size()){\\n            return 0;\\n        }\\n\\n        if(dp[idx][n]!=-1)return dp[idx][n];\\n\\n        // use \\n        int use;\\n        if(idx==0)use=arr[idx+(k-1)] + solve(idx+k,arr,k,n-1,dp);\\n        else if(idx+k>=arr.size()) use=arr.back()-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n        else use = use=arr[idx+(k-1)]-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n\\n        // skip\\n        int skip=solve(idx+1,arr,k,n,dp);\\n\\n        return dp[idx][n]=max(use,skip);\\n\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int n, int k) {\\n        int cnt=0;\\n        vector<int> arr;\\n        int sz=floor.length();\\n        vector<vector<int>> dp(sz+1,vector<int>(n+1,-1));\\n        for(auto i:floor){\\n            if(i==\\'1\\')cnt++;\\n        arr.push_back(cnt);\\n        }\\n\\n        return cnt-solve(0,arr,k,n,dp);\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    int solve(int idx,vector<int> &arr,int k,int n,vector<vector<int>> &dp){\\n        if(n==0 || idx>=arr.size()){\\n            return 0;\\n        }\\n\\n        if(dp[idx][n]!=-1)return dp[idx][n];\\n\\n        // use \\n        int use;\\n        if(idx==0)use=arr[idx+(k-1)] + solve(idx+k,arr,k,n-1,dp);\\n        else if(idx+k>=arr.size()) use=arr.back()-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n        else use = use=arr[idx+(k-1)]-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n\\n        // skip\\n        int skip=solve(idx+1,arr,k,n,dp);\\n\\n        return dp[idx][n]=max(use,skip);\\n\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int n, int k) {\\n        int cnt=0;\\n        vector<int> arr;\\n        int sz=floor.length();\\n        vector<vector<int>> dp(sz+1,vector<int>(n+1,-1));\\n        for(auto i:floor){\\n            if(i==\\'1\\')cnt++;\\n        arr.push_back(cnt);\\n        }\\n\\n        return cnt-solve(0,arr,k,n,dp);\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961259,
                "title": "java-o-numofcarpets-floorlength",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n# Code\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961258,
                "title": "java-o-numofcarpets-floorlength",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n# Code\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941866,
                "title": "c-simple-dp-fast-recursion-memoization",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, string &s,int idx, int k, int len)\\n    {\\n        int n = s.size(), ans = 0;\\n        if(idx >= n)return 0;\\n        if(dp[idx][k]!=-1)return dp[idx][k];\\n        if(s[idx] == \\'0\\')\\n        {\\n            ans = max(ans, 1 + solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        else\\n        {\\n            ans = max(ans, solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen){\\n        vector<vector<int>> dp(floor.size()+1, vector<int> (numCarpets + 1, -1));\\n        int max_cnt = solve(dp, floor, 0, numCarpets, carpetLen);\\n        return floor.size()-max_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, string &s,int idx, int k, int len)\\n    {\\n        int n = s.size(), ans = 0;\\n        if(idx >= n)return 0;\\n        if(dp[idx][k]!=-1)return dp[idx][k];\\n        if(s[idx] == \\'0\\')\\n        {\\n            ans = max(ans, 1 + solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        else\\n        {\\n            ans = max(ans, solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen){\\n        vector<vector<int>> dp(floor.size()+1, vector<int> (numCarpets + 1, -1));\\n        int max_cnt = solve(dp, floor, 0, numCarpets, carpetLen);\\n        return floor.size()-max_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927625,
                "title": "golang-dp-prefix-sum",
                "content": "```\\nfunc minimumWhiteTiles(s string, nc int, cl int) int {\\n\\tps := make([]int, 0, len(s))\\n\\tc := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == 49 {\\n\\t\\t\\tc++\\n\\t\\t}\\n\\t\\tps = append(ps, c)\\n\\t}\\n\\n\\tmem := make([][]int, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tmem[i] = make([]int, nc+1)\\n\\t\\tfor j := 0; j < nc+1; j++ {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(p, oc int) int\\n\\tdp = func(p, oc int) int {\\n\\t\\tif p >= len(s) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif oc <= 0 {\\n\\t\\t\\treturn ps[len(ps)-1] - ps[p-1]\\n\\t\\t}\\n\\t\\tif mem[p][oc] != -1 {\\n\\t\\t\\treturn mem[p][oc]\\n\\t\\t}\\n\\t\\tmem[p][oc] = 0\\n\\t\\tif s[p] == 49 {\\n\\t\\t\\tmem[p][oc] += 1 + dp(p+1, oc)\\n\\t\\t} else {\\n\\t\\t\\tmem[p][oc] += dp(p+1, oc)\\n\\t\\t}\\n\\t\\tk := dp(p+cl, oc-1)\\n\\t\\tif k < mem[p][oc] {\\n\\t\\t\\tmem[p][oc] = k\\n\\t\\t}\\n\\t\\treturn mem[p][oc]\\n\\t}\\n\\treturn dp(0, nc)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumWhiteTiles(s string, nc int, cl int) int {\\n\\tps := make([]int, 0, len(s))\\n\\tc := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == 49 {\\n\\t\\t\\tc++\\n\\t\\t}\\n\\t\\tps = append(ps, c)\\n\\t}\\n\\n\\tmem := make([][]int, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tmem[i] = make([]int, nc+1)\\n\\t\\tfor j := 0; j < nc+1; j++ {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(p, oc int) int\\n\\tdp = func(p, oc int) int {\\n\\t\\tif p >= len(s) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif oc <= 0 {\\n\\t\\t\\treturn ps[len(ps)-1] - ps[p-1]\\n\\t\\t}\\n\\t\\tif mem[p][oc] != -1 {\\n\\t\\t\\treturn mem[p][oc]\\n\\t\\t}\\n\\t\\tmem[p][oc] = 0\\n\\t\\tif s[p] == 49 {\\n\\t\\t\\tmem[p][oc] += 1 + dp(p+1, oc)\\n\\t\\t} else {\\n\\t\\t\\tmem[p][oc] += dp(p+1, oc)\\n\\t\\t}\\n\\t\\tk := dp(p+cl, oc-1)\\n\\t\\tif k < mem[p][oc] {\\n\\t\\t\\tmem[p][oc] = k\\n\\t\\t}\\n\\t\\treturn mem[p][oc]\\n\\t}\\n\\treturn dp(0, nc)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903745,
                "title": "javascript-dynamicprogramming-time-o-floor-numcarpets",
                "content": "# Complexity\\n- Time complexity:\\n$$O(floor * numCarpets)$$\\n\\n- Space complexity:\\n$$O(floor)$$\\n\\n# Code\\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let prev = Array(floor.length + 1).fill(0);\\n\\n    for (let i = 1; i <= floor.length; i++)\\n        prev[i] = prev[i - 1] + (floor[i - 1] == \"1\");\\n\\n    for (let j = 1; j <= numCarpets; j++) {\\n        const cur = Array(floor.length + 1).fill(0);\\n\\n        for (let i = 1; i <= floor.length; i++)\\n            cur[i] = Math.min(cur[i - 1] + (floor[i - 1] == \"1\"), \\n                i >= carpetLen ? prev[i - carpetLen] : 0);\\n\\n        prev = cur;\\n    }\\n    return prev.at(-1);\\n};\\n```\\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    const dp = Array.from({ length: floor.length }, \\n        () => Array(numCarpets + 1).fill(Infinity));\\n\\n    for (let i = floor.length - 1; i >= 0; i--)\\n        dp[i][0] = (i + 1 < floor.length && dp[i + 1][0]) + (floor[i] == \"1\");\\n\\n    const recursion = (index, numCarpets) => {\\n        if (index >= floor.length) return 0;\\n        if (dp[index][numCarpets] < Infinity) return dp[index][numCarpets];\\n\\n        return dp[index][numCarpets] = Math.min(\\n            (floor[index] == \"1\") + recursion(index + 1, numCarpets), \\n            recursion(index + carpetLen, numCarpets - 1)\\n        );\\n    };\\n\\n    return recursion(0, numCarpets);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let prev = Array(floor.length + 1).fill(0);\\n\\n    for (let i = 1; i <= floor.length; i++)\\n        prev[i] = prev[i - 1] + (floor[i - 1] == \"1\");\\n\\n    for (let j = 1; j <= numCarpets; j++) {\\n        const cur = Array(floor.length + 1).fill(0);\\n\\n        for (let i = 1; i <= floor.length; i++)\\n            cur[i] = Math.min(cur[i - 1] + (floor[i - 1] == \"1\"), \\n                i >= carpetLen ? prev[i - carpetLen] : 0);\\n\\n        prev = cur;\\n    }\\n    return prev.at(-1);\\n};\\n```\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    const dp = Array.from({ length: floor.length }, \\n        () => Array(numCarpets + 1).fill(Infinity));\\n\\n    for (let i = floor.length - 1; i >= 0; i--)\\n        dp[i][0] = (i + 1 < floor.length && dp[i + 1][0]) + (floor[i] == \"1\");\\n\\n    const recursion = (index, numCarpets) => {\\n        if (index >= floor.length) return 0;\\n        if (dp[index][numCarpets] < Infinity) return dp[index][numCarpets];\\n\\n        return dp[index][numCarpets] = Math.min(\\n            (floor[index] == \"1\") + recursion(index + 1, numCarpets), \\n            recursion(index + carpetLen, numCarpets - 1)\\n        );\\n    };\\n\\n    return recursion(0, numCarpets);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886735,
                "title": "dp-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n    int helper(int i,string &f,int j,int cl,vector<vector<int>>&dp){\\n        if( i>=f.size() ){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(f[i]==\\'0\\'){\\n           return dp[i][j]= helper(i+1,f,j,cl,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            ans=1+helper(i+1, f,j,cl,dp);\\n            if(j>0) ans= min(ans,helper(i+cl, f,j-1,cl,dp));\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1,-1));\\n        return helper(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int helper(int i,string &f,int j,int cl,vector<vector<int>>&dp){\\n        if( i>=f.size() ){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(f[i]==\\'0\\'){\\n           return dp[i][j]= helper(i+1,f,j,cl,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            ans=1+helper(i+1, f,j,cl,dp);\\n            if(j>0) ans= min(ans,helper(i+cl, f,j-1,cl,dp));\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1,-1));\\n        return helper(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842581,
                "title": "python-dp-pruning-o-n-2-faster-than-94",
                "content": "<code>\\n        import sys\\n        sys.setrecursionlimit(2000000)\\n\\n        n = len(floor)\\n        pre_sums = [0] * (n + 1)\\n        for i, c in enumerate(floor):\\n            pre_sums[i + 1] = pre_sums[i] + (c == \"1\")\\n\\n        @lru_cache(maxsize=None)\\n        def dp(n, k):\\n            \"\"\"\\n            dp[n,k]: \\u524Dn\\u4E2A\\u7528k\\u4E2A\\u5730\\u6BEF\\u8986\\u76D6\\uFF0C\\u6700\\u591A\\u80FD\\u8986\\u76D6\\u591A\\u5C11\\u4E2Awhite floor(1). maximum number of white floor in floor[:n] could be coverd by k carpet\\n            dp[n,k] = max(dp[n - carpetLen][k - 1] + sum(1 in floor[n - carpetLen:n]), dp[n - 1,k])\\n            \"\"\"\\n            if k == 0 or n <= 0:\\n                return 0\\n\\n            # full cover, the most import optimization. TLE -> runtime_percentile: 94%\\n            if k >= pre_sums[n] or k * carpetLen >= n:\\n                return pre_sums[n]\\n\\n            i = max(n - carpetLen, 0)\\n            return max(\\n                dp(i, k - 1) + pre_sums[n] - pre_sums[i],\\n                dp(n - 1, k)\\n            )\\n        return pre_sums[-1] - dp(len(floor), numCarpets)\\n</code>",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "<code>\\n        import sys\\n        sys.setrecursionlimit(2000000)\\n\\n        n = len(floor)\\n        pre_sums = [0] * (n + 1)\\n        for i, c in enumerate(floor):\\n            pre_sums[i + 1] = pre_sums[i] + (c == \"1\")\\n\\n        @lru_cache(maxsize=None)\\n        def dp(n, k):\\n            \"\"\"\\n            dp[n,k]: \\u524Dn\\u4E2A\\u7528k\\u4E2A\\u5730\\u6BEF\\u8986\\u76D6\\uFF0C\\u6700\\u591A\\u80FD\\u8986\\u76D6\\u591A\\u5C11\\u4E2Awhite floor(1). maximum number of white floor in floor[:n] could be coverd by k carpet\\n            dp[n,k] = max(dp[n - carpetLen][k - 1] + sum(1 in floor[n - carpetLen:n]), dp[n - 1,k])\\n            \"\"\"\\n            if k == 0 or n <= 0:\\n                return 0\\n\\n            # full cover, the most import optimization. TLE -> runtime_percentile: 94%\\n            if k >= pre_sums[n] or k * carpetLen >= n:\\n                return pre_sums[n]\\n\\n            i = max(n - carpetLen, 0)\\n            return max(\\n                dp(i, k - 1) + pre_sums[n] - pre_sums[i],\\n                dp(n - 1, k)\\n            )\\n        return pre_sums[-1] - dp(len(floor), numCarpets)\\n</code>",
                "codeTag": "Python3"
            },
            {
                "id": 2839251,
                "title": "dp-c-coin-change-problem-variant",
                "content": "\\n\\n# Approach\\ncoin change problem\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n          \\n          int w=0;\\n          int n=floor.size();\\n          vector<int>v(n+1,0);\\n          vector<vector<int>>dp(num+1,vector<int>(n+1,0));\\n          for(int i=1;i<=n;i++)\\n          {\\n              if(floor[i-1]==\\'1\\')w++;\\n              v[i]=v[i-1]+(floor[i-1]==\\'1\\');\\n              \\n          }\\n                for(int i=1;i<=num;i++)\\n                {\\n                    for(int j=1;j<=n;j++)\\n                    {\\n                        if(j<len)\\n                        {\\n                            dp[i][j]=v[j];\\n                            continue;\\n                        }\\n                    int use=v[j]-v[j-len]+dp[i-1][j-len];\\n                          \\n                    int not_use=dp[i][j-1];\\n                       dp[i][j]=max(use,not_use);\\n                    }\\n                }\\n           int maxi=0;\\n      \\n           for(int i=1;i<=n;i++)\\n           {\\n               maxi=max(maxi,dp[num][i]);\\n             \\n           }\\n    \\n           return w-maxi;\\n          \\n         //return max(0,w-rec(Len-1,floor,num,Len,v,dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n          \\n          int w=0;\\n          int n=floor.size();\\n          vector<int>v(n+1,0);\\n          vector<vector<int>>dp(num+1,vector<int>(n+1,0));\\n          for(int i=1;i<=n;i++)\\n          {\\n              if(floor[i-1]==\\'1\\')w++;\\n              v[i]=v[i-1]+(floor[i-1]==\\'1\\');\\n              \\n          }\\n                for(int i=1;i<=num;i++)\\n                {\\n                    for(int j=1;j<=n;j++)\\n                    {\\n                        if(j<len)\\n                        {\\n                            dp[i][j]=v[j];\\n                            continue;\\n                        }\\n                    int use=v[j]-v[j-len]+dp[i-1][j-len];\\n                          \\n                    int not_use=dp[i][j-1];\\n                       dp[i][j]=max(use,not_use);\\n                    }\\n                }\\n           int maxi=0;\\n      \\n           for(int i=1;i<=n;i++)\\n           {\\n               maxi=max(maxi,dp[num][i]);\\n             \\n           }\\n    \\n           return w-maxi;\\n          \\n         //return max(0,w-rec(Len-1,floor,num,Len,v,dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797559,
                "title": "c-easy-understanding-dynamic-programming",
                "content": "```\\nclass Solution {\\n    int dp[1001][1001];\\n    vector<int> suffix;\\n    int utilfunc(int i,int j,string &floor,int len)\\n    {\\n        if(i >= floor.length())\\n        {\\n            return 0;\\n        }\\n        \\n        if(j == 0)\\n        {\\n            return suffix[i];\\n        }\\n        \\n        if(dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        int ans1 = utilfunc(i+1,j,floor,len) + (floor[i] == \\'1\\');\\n        int ans2 = utilfunc(i+len,j-1,floor,len);\\n        return dp[i][j] = min(ans1,ans2);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        memset(dp,-1,sizeof(dp));\\n        int n  = floor.size();\\n        suffix.resize(n,0);\\n        suffix[n-1] = floor[n-1] == \\'1\\';\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suffix[i] += suffix[i+1] + (floor[i] == \\'1\\');\\n        }\\n        \\n        return utilfunc(0,num,floor,len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    int dp[1001][1001];\\n    vector<int> suffix;\\n    int utilfunc(int i,int j,string &floor,int len)\\n    {\\n        if(i >= floor.length())\\n        {\\n            return 0;\\n        }\\n        \\n        if(j == 0)\\n        {\\n            return suffix[i];\\n        }\\n        \\n        if(dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        int ans1 = utilfunc(i+1,j,floor,len) + (floor[i] == \\'1\\');\\n        int ans2 = utilfunc(i+len,j-1,floor,len);\\n        return dp[i][j] = min(ans1,ans2);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        memset(dp,-1,sizeof(dp));\\n        int n  = floor.size();\\n        suffix.resize(n,0);\\n        suffix[n-1] = floor[n-1] == \\'1\\';\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suffix[i] += suffix[i+1] + (floor[i] == \\'1\\');\\n        }\\n        \\n        return utilfunc(0,num,floor,len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563262,
                "title": "memoization-explained-all-possible-ways-c",
                "content": "* Let\\'s think about all possible ways...\\n\\t* we skip the \\u2B1B Black Box  ( `memo(s,num,len,i+1)` )\\n\\t* now we have \\uD83D\\uDD32 White Box -\\n\\t\\t* we choose to cover it ( `memo(s,num-1,len,i+len)` ) thus covering next **i+len-1** boxes\\n\\t\\t* we skip this box too and let\\'s add 1 to **uncovered white box collection** ( `1 + memo(s,num,len,i+1)` )\\n\\nthe minimum uncovered white boxes among all possible ways is our desired answer....\\n`UPVOTE IF YOU LIKE \\uD83D\\uDE0E\\uD83D\\uDE4C`\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return memo(floor,numCarpets,carpetLen,0);\\n    }\\n    int memo(string& s, int num, int len, int i){\\n        int n = s.size();\\n        if(i > n-1) return 0;\\n        if(num == 0){\\n            int cnt = 0;\\n            for(int j = i; j < n; ++j){\\n                if(s[j] == \\'1\\') cnt++;\\n            }\\n            return cnt;\\n        }\\n        if(dp[i][num] != -1) return dp[i][num];\\n        if(s[i] == \\'0\\') return dp[i][num] = memo(s,num,len,i+1);\\n        int cover = memo(s,num-1,len,i+len);\\n        int skip = 1 + memo(s,num,len,i+1);\\n        return dp[i][num] = min(cover,skip);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return memo(floor,numCarpets,carpetLen,0);\\n    }\\n    int memo(string& s, int num, int len, int i){\\n        int n = s.size();\\n        if(i > n-1) return 0;\\n        if(num == 0){\\n            int cnt = 0;\\n            for(int j = i; j < n; ++j){\\n                if(s[j] == \\'1\\') cnt++;\\n            }\\n            return cnt;\\n        }\\n        if(dp[i][num] != -1) return dp[i][num];\\n        if(s[i] == \\'0\\') return dp[i][num] = memo(s,num,len,i+1);\\n        int cover = memo(s,num-1,len,i+len);\\n        int skip = 1 + memo(s,num,len,i+1);\\n        return dp[i][num] = min(cover,skip);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544757,
                "title": "c-dp-memoization",
                "content": "```\\nint tiles(int i, string &floor, int numCarpets, int carpetLen,vector<vector<int>>&dp)\\n    {\\n        if(i>=floor.size()) return 0;\\n        if(numCarpets==0)\\n        {\\n            int c=0;\\n            for(;i<floor.size();i++)\\n            {\\n                if(floor[i]==\\'1\\')   c++;\\n            }\\n            return c;\\n        }\\n        if(dp[i][numCarpets]!=-1)   return dp[i][numCarpets];\\n        int ans=INT_MAX;\\n        if(floor[i]==\\'1\\')   //here if current floor index has value \\'1\\' we can  use carpet to cover 1\\'s  or we can just move forward by 1 index\\n        ans= min(tiles(i+carpetLen,floor,numCarpets-1,carpetLen,dp),1+tiles(i+1,floor,numCarpets,carpetLen,dp));\\n        else ans= tiles(i+1,floor,numCarpets,carpetLen,dp); // and if current index has value \\'0\\' we will move forward by 1 index\\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) \\n    {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n+1,vector<int>(numCarpets+1,-1));\\n        return tiles(0,floor,numCarpets,carpetLen,dp);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint tiles(int i, string &floor, int numCarpets, int carpetLen,vector<vector<int>>&dp)\\n    {\\n        if(i>=floor.size()) return 0;\\n        if(numCarpets==0)\\n        {\\n            int c=0;\\n            for(;i<floor.size();i++)\\n            {\\n                if(floor[i]==\\'1\\')   c++;\\n            }\\n            return c;\\n        }\\n        if(dp[i][numCarpets]!=-1)   return dp[i][numCarpets];\\n        int ans=INT_MAX;\\n        if(floor[i]==\\'1\\')   //here if current floor index has value \\'1\\' we can  use carpet to cover 1\\'s  or we can just move forward by 1 index\\n        ans= min(tiles(i+carpetLen,floor,numCarpets-1,carpetLen,dp),1+tiles(i+1,floor,numCarpets,carpetLen,dp));\\n        else ans= tiles(i+1,floor,numCarpets,carpetLen,dp); // and if current index has value \\'0\\' we will move forward by 1 index\\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) \\n    {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n+1,vector<int>(numCarpets+1,-1));\\n        return tiles(0,floor,numCarpets,carpetLen,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2542978,
                "title": "python-go-c-top-down-vs-bottom-up-2d-vs-1d-dp-o-mn",
                "content": "*Python* top-down 2D-DP w/ built-in memo\\n\\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    dp = functools.cache(\\n        lambda i, j: 1000 if i < 0 else 0 if j < 0\\n        else min(dp(i - 1, j - carpetLen), dp(i, j - 1) + int(floor[j]))\\n    )\\n    return dp(numCarpets, len(floor) - 1)\\n```\\n\\n*Python* bottom-up 2D-DP\\n\\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    m, n = numCarpets + 2, len(floor) + carpetLen\\n    dp, A = [[[0, 1000][not i]] * n for i in range(m)], list(map(int, floor))\\n    for i in range(1, m):\\n        for j in range(carpetLen, n):\\n            dp[i][j] = min(dp[i - 1][j - carpetLen], dp[i][j - 1] + A[j - carpetLen])\\n    return dp[-1][-1]\\n```\\n\\n*Python* bottom-up 1D-DP\\n\\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    n = len(floor) + carpetLen\\n    X, Y = [0] * carpetLen + list(itertools.accumulate(map(int, floor))), [0] * n\\n    A = list(map(int, floor))\\n    for _ in range(numCarpets):\\n        for i in range(carpetLen, n):\\n            Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen])\\n        X, Y = Y, X\\n    return X[-1]\\n```\\n\\n*Go* bottom-up 1D-DP in 94ms\\n\\n```go\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tn := len(floor)\\n\\tA := make([]int, n)\\n\\tfor i, c := range floor {\\n\\t\\tif c == \\'1\\' {\\n\\t\\t\\tA[i] = 1\\n\\t\\t}\\n\\t}\\n\\tX := make([]int, carpetLen)\\n\\tn += carpetLen\\n\\tfor i := carpetLen; i < n; i++ {\\n\\t\\tX = append(X, X[i-1]+A[i-carpetLen])\\n\\t}\\n\\tY := make([]int, n)\\n\\tfor __ := 0; __ < numCarpets; __++ {\\n\\t\\tfor i := carpetLen; i < n; i++ {\\n\\t\\t\\tY[i] = min(X[i-carpetLen], Y[i-1]+A[i-carpetLen])\\n\\t\\t}\\n\\t\\tX, Y = Y, X\\n\\t}\\n\\treturn X[n-1]\\n}\\n```\\n\\n*C++* bottom-up 1D-DP\\n\\n```c++\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n    int n = floor.size();\\n    vector<int> A(n); for (int i = 0; i < n; ++i) if (floor[i] == \\'1\\') A[i] = 1;\\n    n += carpetLen;\\n    vector<int> X(carpetLen); for (int i = carpetLen; i < n; ++i) X.push_back(X[i - 1] + A[i - carpetLen]);\\n    vector<int> Y(n);\\n    for (int _ = 0; _ < numCarpets; ++_) {\\n        for (int i = carpetLen; i < n; ++i) Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen]);\\n        swap(X, Y);\\n    }\\n    return X[n - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    dp = functools.cache(\\n        lambda i, j: 1000 if i < 0 else 0 if j < 0\\n        else min(dp(i - 1, j - carpetLen), dp(i, j - 1) + int(floor[j]))\\n    )\\n    return dp(numCarpets, len(floor) - 1)\\n```\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    m, n = numCarpets + 2, len(floor) + carpetLen\\n    dp, A = [[[0, 1000][not i]] * n for i in range(m)], list(map(int, floor))\\n    for i in range(1, m):\\n        for j in range(carpetLen, n):\\n            dp[i][j] = min(dp[i - 1][j - carpetLen], dp[i][j - 1] + A[j - carpetLen])\\n    return dp[-1][-1]\\n```\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    n = len(floor) + carpetLen\\n    X, Y = [0] * carpetLen + list(itertools.accumulate(map(int, floor))), [0] * n\\n    A = list(map(int, floor))\\n    for _ in range(numCarpets):\\n        for i in range(carpetLen, n):\\n            Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen])\\n        X, Y = Y, X\\n    return X[-1]\\n```\n```go\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tn := len(floor)\\n\\tA := make([]int, n)\\n\\tfor i, c := range floor {\\n\\t\\tif c == \\'1\\' {\\n\\t\\t\\tA[i] = 1\\n\\t\\t}\\n\\t}\\n\\tX := make([]int, carpetLen)\\n\\tn += carpetLen\\n\\tfor i := carpetLen; i < n; i++ {\\n\\t\\tX = append(X, X[i-1]+A[i-carpetLen])\\n\\t}\\n\\tY := make([]int, n)\\n\\tfor __ := 0; __ < numCarpets; __++ {\\n\\t\\tfor i := carpetLen; i < n; i++ {\\n\\t\\t\\tY[i] = min(X[i-carpetLen], Y[i-1]+A[i-carpetLen])\\n\\t\\t}\\n\\t\\tX, Y = Y, X\\n\\t}\\n\\treturn X[n-1]\\n}\\n```\n```c++\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n    int n = floor.size();\\n    vector<int> A(n); for (int i = 0; i < n; ++i) if (floor[i] == \\'1\\') A[i] = 1;\\n    n += carpetLen;\\n    vector<int> X(carpetLen); for (int i = carpetLen; i < n; ++i) X.push_back(X[i - 1] + A[i - carpetLen]);\\n    vector<int> Y(n);\\n    for (int _ = 0; _ < numCarpets; ++_) {\\n        for (int i = carpetLen; i < n; ++i) Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen]);\\n        swap(X, Y);\\n    }\\n    return X[n - 1];\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2515048,
                "title": "c-dp-o-n-m-with-prefix-sum-with-detailed-explanation",
                "content": "The first step is to clarify this sentence: \"Carpets may overlap one another.\" Of course carpets could overlap, however if there is an optimal solution where carpets overlap, there is also an optimal solution where carpets don\\'t. As the result we can disregard solutions where carpets overlap. The only exception to this is when the cumulated size of the carpets in longer than the floor, but in that case there is no visible white tile.\\n\\nSecond step is to define dp[c][i], and in the present case it\\'s the maximum number of white tiles covered by any arrangement of c carpets in between tile 1 and tile i. As the order of the carpets doesn\\'t matter (they are all the same), we can say that the first carpet is before the second carpet and so on. Which leads to the following:\\n- First carpet: k1 is the number of white tiles covered with the first carpet at position i (covering tiles from i - len + 1 to i) thus dp[1][i] = max(dp[1][i - 1], k1) as we consider the best solution so far.\\n- Second carpet: k2 is  the number of white tiles covered with the second carpet at position i, then we add the best possible number of white tiles covered with the first carpet which is dp[1][i - len] as there is no overlap. As the result dp[2][i] = max(dp[2][i - 1], k2 + dp[1][i - len].\\n\\nBy extension we obtain this definition: dp[c][i] = max(dp[c][i - 1], kc + dp[c - 1][i - len], with kc the number of white tiles covered with carpet kc.\\n\\nFine, we now have a DP algorithm, however to make it O(n * m) we need to compute kc in O(1), and this is what the prefix sum is for. Instead of iterating through the tiles within each interval [i - len + 1, i], we just need to make the difference between the prefix sum of the last tile and the prefix sum of the tile just before the considered interval.\\n\\n**O(n * m) time, O(n * m) space solution:**\\n```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> dp(carpets + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int c = 1; c <= carpets; c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[c][i] = max(dp[c][i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dp[c - 1][i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn pre[n] - dp[carpets][n];\\n\\t}\\n};\\n```\\n\\n**O(n * m) time, O(n) space solution:**\\n```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> vec(2, vector<int>(n + 1, 0));\\n\\t\\tvector<int>& dp = vec[0];\\n\\t\\tvector<int>& dx = vec[1];\\n\\t\\tfor (int c = 1; c <= carpets; swap(dp, dx), c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[i] = max(dp[i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dx[i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn pre[n] - dx[n];\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> dp(carpets + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int c = 1; c <= carpets; c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[c][i] = max(dp[c][i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dp[c - 1][i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn pre[n] - dp[carpets][n];\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> vec(2, vector<int>(n + 1, 0));\\n\\t\\tvector<int>& dp = vec[0];\\n\\t\\tvector<int>& dx = vec[1];\\n\\t\\tfor (int c = 1; c <= carpets; swap(dp, dx), c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[i] = max(dp[i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dx[i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn pre[n] - dx[n];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498730,
                "title": "dp-recursion-simple",
                "content": "class Solution {\\n    int n,m,l;\\n     vector<vector<int>>dp;\\n    int sol(int i, int j, vector<int>&v ,string& f)\\n    {\\n          if(i>= n) return 0;\\n          if(j>=m)\\n          {\\n              if(i==0) return v.back();\\n              return v.back()- v[i-1];\\n          }\\n           \\n        if(dp[i][j]!= -1) return dp[i][j];\\n        int x= sol(i+l, j+1,v,f);\\n        int y= sol(i+1,j, v,f );\\n        if(f[i]==\\'1\\') y++;\\n   //     cout<<i<<\" \"<<j<<\" \"<<x<<\" \"<<y<<\"\\\\n\";\\n        return dp[i][j]= min(x,y);\\n    }\\npublic:\\n    int minimumWhiteTiles(string f, int numCarpets, int carpetLen) {\\n        n=f.size();\\n        m=numCarpets;\\n        l=carpetLen;\\n     //   cout<<n<<\" \"<<m<<\"\\\\n\";\\n        dp.resize(n, vector<int>(m+1,-1));\\n        vector<int> v;\\n        int b=0;\\n        for(auto i:f)\\n        {\\n           b+= i-\\'0\\';\\n            v.push_back(b);\\n        }\\n        return  sol(0,0,v,f);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int n,m,l;\\n     vector<vector<int>>dp;\\n    int sol(int i, int j, vector<int>&v ,string& f)\\n    {\\n          if(i>= n) return 0;\\n          if(j>=m)\\n          {\\n              if(i==0) return v.back();\\n              return v.back()- v[i-1];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2342212,
                "title": "java-easy-solution-explained",
                "content": "```\\nclass Solution {\\n    public int f(char[] arr,int i,int n,int len,int[] whites,int dp[][])\\n    {\\n        if(i>=arr.length||n==0)//outofbounds\\n        {\\n            return 0;\\n        }\\n        if(dp[i][n]!=-1)\\n        {\\n            return dp[i][n];\\n        }\\n        if(arr[i]==\\'0\\')//black\\n        {\\n            return dp[i][n]=f(arr,i+1,n,len,whites,dp);//skip\\n        }\\n        //boundary check\\n        int l=Math.min(i+len,arr.length)-1;//if white,get the min index after add carpte\\'s len\\n        int white=whites[l];\\n        if(i!=0)\\n        {\\n            white-=whites[i-1];//if i==0 no need to diff for white tiles\\n        }\\n        int pick=white+f(arr,i+len,n-1,len,whites,dp);// either pick ->white tile+after effect of putting carpet\\n        int nopick=f(arr,i+1,n,len,whites,dp);// not picking skipping\\n        return dp[i][n]=Math.max(pick,nopick);//getting max of both\\n    }\\n    public int minimumWhiteTiles(String floor, int n, int len) {\\n        int whites[]=new int[floor.length()];//prefix sum of whites\\n        int dp[][]=new int[floor.length()+1][n+1];\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            for(int j=0;j<dp[0].length;j++)\\n            {\\n                dp[i][j]=-1;   \\n            }\\n        }\\n        char arr[]=floor.toCharArray();\\n        whites[0]=(arr[0]==\\'1\\'?1:0);// prefix sum of whites 0th ele may or maynot be white in case..\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            whites[i]=whites[i-1]+(arr[i]==\\'1\\'?1:0);//prefix sum\\n        }\\n        if(whites[floor.length()-1]==0)// after prefix sum the last ele is 0 then no whites at all return 0 simply\\n        {\\n            return 0;\\n        }\\n        return whites[floor.length()-1]-f(arr,0,n,len,whites,dp);// no.of whites required-> so total whites-used white tiles\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int f(char[] arr,int i,int n,int len,int[] whites,int dp[][])\\n    {\\n        if(i>=arr.length||n==0)//outofbounds\\n        {\\n            return 0;\\n        }\\n        if(dp[i][n]!=-1)\\n        {\\n            return dp[i][n];\\n        }\\n        if(arr[i]==\\'0\\')//black\\n        {\\n            return dp[i][n]=f(arr,i+1,n,len,whites,dp);//skip\\n        }\\n        //boundary check\\n        int l=Math.min(i+len,arr.length)-1;//if white,get the min index after add carpte\\'s len\\n        int white=whites[l];\\n        if(i!=0)\\n        {\\n            white-=whites[i-1];//if i==0 no need to diff for white tiles\\n        }\\n        int pick=white+f(arr,i+len,n-1,len,whites,dp);// either pick ->white tile+after effect of putting carpet\\n        int nopick=f(arr,i+1,n,len,whites,dp);// not picking skipping\\n        return dp[i][n]=Math.max(pick,nopick);//getting max of both\\n    }\\n    public int minimumWhiteTiles(String floor, int n, int len) {\\n        int whites[]=new int[floor.length()];//prefix sum of whites\\n        int dp[][]=new int[floor.length()+1][n+1];\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            for(int j=0;j<dp[0].length;j++)\\n            {\\n                dp[i][j]=-1;   \\n            }\\n        }\\n        char arr[]=floor.toCharArray();\\n        whites[0]=(arr[0]==\\'1\\'?1:0);// prefix sum of whites 0th ele may or maynot be white in case..\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            whites[i]=whites[i-1]+(arr[i]==\\'1\\'?1:0);//prefix sum\\n        }\\n        if(whites[floor.length()-1]==0)// after prefix sum the last ele is 0 then no whites at all return 0 simply\\n        {\\n            return 0;\\n        }\\n        return whites[floor.length()-1]-f(arr,0,n,len,whites,dp);// no.of whites required-> so total whites-used white tiles\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291254,
                "title": "java-from-tle-to-ac-both-dp",
                "content": "First up, the naive DP solution. \\n\\nThe idea is simple - let `dp[i][j] be the min white tiles if we use i carpet for subarray 0...j.` \\nFor each carpet, we try to place it at all the location, then we have the transitional state: \\n`dp[i][j] = min(dp[i-1][k-carpetLen]+count) where carpetLen <= k <= j` and count = the number of white tiles between the gap.\\n\\nNeedless to say, it got TLE.\\n```Java\\n// TLE\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[] dp = new int[floor.length()];\\n        for (int i = 0; i < floor.length(); i++){\\n            dp[i]=(i==0?0:dp[i-1])+floor.charAt(i)-\\'0\\';\\n        }\\n        for (int i = 1; i <= numCarpets; i++){\\n            for (int j = floor.length()-1; j >= 0; j--){\\n                for (int k = j,cnt=0; k >= carpetLen; k--){\\n                    dp[j]=Math.min(dp[k-carpetLen]+cnt,dp[j]);\\n                    cnt+=floor.charAt(k)-\\'0\\';\\n                }\\n                if (j<carpetLen){\\n                    dp[j]=0;\\n                }\\n            }\\n        }\\n\\n        return dp[floor.length()-1];\\n    }\\n}\\n```\\nso we have to come up with something better...\\nThis time we will consider `dp[i][j] = the min white tiles for subarray 0 ... i with j carpets used`\\nthen we should have `dp[i][j] = min(dp[i-1][j]+(1 or 0), dp[i-carpetLen][j-1])`\\nThis works.\\n\\n```Java\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[][] dp = new int[floor.length()][numCarpets+1];\\n        for (int i = 0; i < floor.length(); i++){\\n            for (int j = 0; j <= numCarpets; j++){\\n                dp[i][j]=Math.min((i==0?0:dp[i-1][j])+floor.charAt(i)-\\'0\\',j==0?1000:i<carpetLen?0:dp[i-carpetLen][j-1]);\\n            }\\n        }\\n        return dp[floor.length()-1][numCarpets];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\n// TLE\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[] dp = new int[floor.length()];\\n        for (int i = 0; i < floor.length(); i++){\\n            dp[i]=(i==0?0:dp[i-1])+floor.charAt(i)-\\'0\\';\\n        }\\n        for (int i = 1; i <= numCarpets; i++){\\n            for (int j = floor.length()-1; j >= 0; j--){\\n                for (int k = j,cnt=0; k >= carpetLen; k--){\\n                    dp[j]=Math.min(dp[k-carpetLen]+cnt,dp[j]);\\n                    cnt+=floor.charAt(k)-\\'0\\';\\n                }\\n                if (j<carpetLen){\\n                    dp[j]=0;\\n                }\\n            }\\n        }\\n\\n        return dp[floor.length()-1];\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[][] dp = new int[floor.length()][numCarpets+1];\\n        for (int i = 0; i < floor.length(); i++){\\n            for (int j = 0; j <= numCarpets; j++){\\n                dp[i][j]=Math.min((i==0?0:dp[i-1][j])+floor.charAt(i)-\\'0\\',j==0?1000:i<carpetLen?0:dp[i-carpetLen][j-1]);\\n            }\\n        }\\n        return dp[floor.length()-1][numCarpets];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247732,
                "title": "java-solution-40ms-o-n-space",
                "content": "```\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        char [] tiles = floor.toCharArray();\\n        int n = tiles.length;\\n        \\n        int [] dp = new int[n+1];\\n        \\n        int whiteTiles = 0;\\n        for(int i = 1; i<=n; i++){\\n            if(tiles[i-1]==\\'1\\') whiteTiles++;\\n            dp[i] = whiteTiles;\\n        }\\n        \\n        for(int i = 1; i<=numCarpets; i++){\\n            int [] temp = new int[n+1];\\n            for(int j = 1; j<=n; j++){\\n                temp[j] = tiles[j-1]==\\'0\\' ? temp[j-1] : Math.min(dp[Math.max(j-carpetLen, 0)], 1+temp[j-1]);\\n            }\\n            dp = temp;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        char [] tiles = floor.toCharArray();\\n        int n = tiles.length;\\n        \\n        int [] dp = new int[n+1];\\n        \\n        int whiteTiles = 0;\\n        for(int i = 1; i<=n; i++){\\n            if(tiles[i-1]==\\'1\\') whiteTiles++;\\n            dp[i] = whiteTiles;\\n        }\\n        \\n        for(int i = 1; i<=numCarpets; i++){\\n            int [] temp = new int[n+1];\\n            for(int j = 1; j<=n; j++){\\n                temp[j] = tiles[j-1]==\\'0\\' ? temp[j-1] : Math.min(dp[Math.max(j-carpetLen, 0)], 1+temp[j-1]);\\n            }\\n            dp = temp;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240116,
                "title": "linear-time-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> dp(n,  0), ndp(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            dp[i] = (i ? dp[i-1] : 0) + floor[i] - \\'0\\';\\n        }\\n        for(int i = 1; i <= numCarpets; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ndp[j] =  (j ? ndp[j-1]: 0) + floor[j] - \\'0\\';\\n                ndp[j] = (j < carpetLen) ? 0 : min(ndp[j], dp[j - carpetLen]);\\n            }\\n            dp = ndp;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> dp(n,  0), ndp(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            dp[i] = (i ? dp[i-1] : 0) + floor[i] - \\'0\\';\\n        }\\n        for(int i = 1; i <= numCarpets; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ndp[j] =  (j ? ndp[j-1]: 0) + floor[j] - \\'0\\';\\n                ndp[j] = (j < carpetLen) ? 0 : min(ndp[j], dp[j - carpetLen]);\\n            }\\n            dp = ndp;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172666,
                "title": "python-dp-prefix-sum-with-thought-process-on-optimization-when-being-asked-during-interviews",
                "content": "### Dynamic Programming + Prefix Sum\\nNote this problem is not greedy, so you get wrong answer if you get the interval for consective `1`, sort them and greedly put carpets from the longest interval. \\nBesides, this one is not a sliding window problem either. Try with this example `111010111` with `2` carpets with length of `3`. \\nThen we need iterate every possible layout with each floor, which denotes to dynamic programming.\\nFirst, let\\'s simplify the solution without optimzation. We use `dp[f][c]` represent the number of white tiles visible, and for each floor `f`, we have 2 options, put one carpet or not, which recall you the backpack problems. If we decide to put one carpet, then the result is `dp[f + length][c - 1]`, otherwise `dp[f + 1][c]`. Then we return the minimum one.\\n\\nSecondly, let\\'s observe the base case.\\n```\\n* f == n: no more floor to cover, return 0\\n* c == 0: no more tiles to use, return the number of white tiles remaining \\n```\\nFinally, let\\'s put `memoziation` on the recursive function. It looks working, but we got `TLE`. \\n\\nAlright, let\\'s optimize it. \\nFirst of all, if current `f` is black tile, we don\\'t need to cover with carpet, so we can just return `dp[f + 1][c]` if `floor[f] == \\'0\\'`.\\nSecondly, if the total length of carpet is longer than the floor, we can cover the entire floor, then the answer is `0`.\\nThridly, the time we count the remaining white tiles is linear, can we quickly get the number of white tiles given a range? prefix sum is the answer.\\n\\nLet\\'s put it all together!\\n\\n```python\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\tn = len(floor)\\n\\tpre = [0]\\n\\tfor c in floor:\\n\\t\\tpre.append(pre[-1] + int(c))\\n        \\n\\t@cache\\n\\tdef helper(f, c):\\n\\t\\tif f >= n or c * carpetLen >= n - f:\\n\\t\\t\\treturn 0\\n\\t\\tif c == 0:\\n\\t\\t\\treturn pre[-1] - pre[f]\\n\\t\\tif floor[f] == \\'0\\':\\n\\t\\t\\treturn helper(f + 1, c)\\n\\t\\treturn min(1 + helper(f + 1, c), helper(f + carpetLen, c - 1))\\n\\treturn helper(0, numCarpets)\\n```\\n\\n*Time Complexity*= **O(NC)**, N means the length of floor, the C means the number of tiles.\\n*Space Complexity* = **O(NC)**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n* f == n: no more floor to cover, return 0\\n* c == 0: no more tiles to use, return the number of white tiles remaining \\n```\n```python\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\tn = len(floor)\\n\\tpre = [0]\\n\\tfor c in floor:\\n\\t\\tpre.append(pre[-1] + int(c))\\n        \\n\\t@cache\\n\\tdef helper(f, c):\\n\\t\\tif f >= n or c * carpetLen >= n - f:\\n\\t\\t\\treturn 0\\n\\t\\tif c == 0:\\n\\t\\t\\treturn pre[-1] - pre[f]\\n\\t\\tif floor[f] == \\'0\\':\\n\\t\\t\\treturn helper(f + 1, c)\\n\\t\\treturn min(1 + helper(f + 1, c), helper(f + carpetLen, c - 1))\\n\\treturn helper(0, numCarpets)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2146064,
                "title": "java-o-m-n-dp",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int[][] dp = new int[floor.length()+1][numCarpets+1]; // minium while tile at ith position using j carpets\\n        int num = 0;\\n        \\n        for (int i = 0; i < dp.length; i++) {\\n            \\n            for (int j = 0; j < dp[i].length; j++) {\\n                if (i == 0) dp[i][j] = 0;\\n                else dp[i][j] = Integer.MAX_VALUE/2;\\n            }\\n            \\n            if (i >= 1 && floor.charAt(i-1) == \\'1\\') num++;\\n            dp[i][0] = num;\\n        }\\n        \\n        \\n        \\n      \\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 1; j<= numCarpets; j++) {\\n              \\n                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + (floor.charAt(i-1) ==\\'1\\'?1:0)); //carpet not cover ith tile\\n                \\n                dp[i][j] = Math.min(dp[i][j], (i >= carpetLen)? dp[i-carpetLen][j-1]:0); // carpet cover ith tile\\n                \\n                \\n\\n                \\n            }\\n        }\\n        \\n        return dp[dp.length-1][numCarpets];\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int[][] dp = new int[floor.length()+1][numCarpets+1]; // minium while tile at ith position using j carpets\\n        int num = 0;\\n        \\n        for (int i = 0; i < dp.length; i++) {\\n            \\n            for (int j = 0; j < dp[i].length; j++) {\\n                if (i == 0) dp[i][j] = 0;\\n                else dp[i][j] = Integer.MAX_VALUE/2;\\n            }\\n            \\n            if (i >= 1 && floor.charAt(i-1) == \\'1\\') num++;\\n            dp[i][0] = num;\\n        }\\n        \\n        \\n        \\n      \\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 1; j<= numCarpets; j++) {\\n              \\n                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + (floor.charAt(i-1) ==\\'1\\'?1:0)); //carpet not cover ith tile\\n                \\n                dp[i][j] = Math.min(dp[i][j], (i >= carpetLen)? dp[i-carpetLen][j-1]:0); // carpet cover ith tile\\n                \\n                \\n\\n                \\n            }\\n        }\\n        \\n        return dp[dp.length-1][numCarpets];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077907,
                "title": "python-top-down-approach-dp-with-prefix-sum",
                "content": "We can approach this problem using dynamic programming. Before we dive into the details of the implementation, however, let us try and grasp the intution underlying this method.\\n\\nIf we scan the string from left to right, we can make a few observations:\\n1. At each index of the string, `idx`, if we only consider the first `idx` indices, we can maintain a count of the minimum number of ones in the string if we only tile that \"window\" or substring of the original floor.\\n2. At each index, we have a choice to make -- we can either place a tile (ending at `idx` and starting at index `idx - carpetLen + 1`) or not place a tile\\n\\nIn the second case, consider each path we can take. If we do not place a tile, then we simply have more tiles left to tile the remaining floor (i.e. indices preceding `idx` from `0` to `idx - 1`, inclusive), but we may fail to cover an available tile if `floor[idx] == \\'1\\'`. If we do place a tile, then we have less tiles left to tile the remaining floor, but we are guaranteed to cover everything from `idx - carpetLen + 1` to `idx`. \\n\\nFrom here, we arrive at our dynamic programming relation, where `dp(idx, n)` represents the minimum number of remaining available tiles from indices `0` to `idx` using `n` pieces of carpet. \\n- if we the carpet we have remaining `n * carpetLen` is at least the number of available tiles, then we will not have any tiles remaining, since we can cover all tiles\\n- if we have no more carpet remaining, (i.e. `n == 0`), then we cannot tile any more pieces of the floor, so we simply return the number of available tiles preceding and including `idx`\\n- otherwise, we consider the optimal choice out of our two aforementioned cases (i.e. `dp(idx, n) = min(dp(idx - carpetLen, n - 1), dp(idx - 1, n) + floor[idx])`\\n\\nNow that we have set up this recurrence, we can use a top down dynamic programming approach to maintain intermediate results and assist in our final computation of `dp(len(floor) - 1, numCarpets)`. To calculate the number of available tiles in a given range of `floor` in constant time, a prefix sum array was built and used.\\n\\nThis method runs in `O(numCarpets * len(floor))` time, since we are able to cache intermediate results and uses `O(numCarpets * len(floor))` space.\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        prefix = [0] * (len(floor) + 1)\\n        for i in range(1, len(prefix)):\\n            prefix[i] = 1 + prefix[i - 1] if floor[i - 1] == \\'1\\' else prefix[i - 1]\\n        def ones(i, j):\\n            return prefix[j + 1] - prefix[i]\\n        @cache\\n        def dp(idx, n):\\n            if n * carpetLen >= idx + 1:\\n                return 0\\n            if idx == 0:\\n                return ones(0, 0)\\n            if n == 0:\\n                return ones(0, idx)\\n            return min(dp(idx - carpetLen, n - 1), \\n                           dp(idx - 1, n) + ones(idx, idx))\\n        return dp(len(floor) - 1, numCarpets)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        prefix = [0] * (len(floor) + 1)\\n        for i in range(1, len(prefix)):\\n            prefix[i] = 1 + prefix[i - 1] if floor[i - 1] == \\'1\\' else prefix[i - 1]\\n        def ones(i, j):\\n            return prefix[j + 1] - prefix[i]\\n        @cache\\n        def dp(idx, n):\\n            if n * carpetLen >= idx + 1:\\n                return 0\\n            if idx == 0:\\n                return ones(0, 0)\\n            if n == 0:\\n                return ones(0, idx)\\n            return min(dp(idx - carpetLen, n - 1), \\n                           dp(idx - 1, n) + ones(idx, idx))\\n        return dp(len(floor) - 1, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055688,
                "title": "c-2d-dp-few-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = (int)floor.length();\\n        if(numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(numCarpets + 1));\\n        for(int i = 0; i <= n; ++i)\\n        {\\n            for(int j = 0; j <= numCarpets; j++)\\n            {\\n                if(i == 0 and j == 0){\\n                    dp[i][j] = 0;\\n                }else if(i == 0){\\n                    dp[i][j] = 0;\\n                }else if(j == 0){\\n                    dp[i][j] = dp[i-1][j] + ((floor[i-1] == \\'1\\') ? 1 : 0);\\n                }else{\\n                    if(floor[i-1] == \\'0\\'){\\n                        dp[i][j] = dp[i-1][j];\\n                    }else{\\n                        dp[i][j] = (i - carpetLen < 0) ? 0 : dp[i-carpetLen][j-1];\\n                        dp[i][j] = min(dp[i][j], 1 + dp[i-1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = (int)floor.length();\\n        if(numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(numCarpets + 1));\\n        for(int i = 0; i <= n; ++i)\\n        {\\n            for(int j = 0; j <= numCarpets; j++)\\n            {\\n                if(i == 0 and j == 0){\\n                    dp[i][j] = 0;\\n                }else if(i == 0){\\n                    dp[i][j] = 0;\\n                }else if(j == 0){\\n                    dp[i][j] = dp[i-1][j] + ((floor[i-1] == \\'1\\') ? 1 : 0);\\n                }else{\\n                    if(floor[i-1] == \\'0\\'){\\n                        dp[i][j] = dp[i-1][j];\\n                    }else{\\n                        dp[i][j] = (i - carpetLen < 0) ? 0 : dp[i-carpetLen][j-1];\\n                        dp[i][j] = min(dp[i][j], 1 + dp[i-1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053240,
                "title": "top-down-approach-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    int solve(string &s,int k,int l,int idx){\\n        if(idx>=s.size()&&k>=0)return 0;\\n        if(k<0)return INT_MAX;\\n        if(dp[k][idx]!=-1)return dp[k][idx];\\n        if(s[idx]==\\'1\\'){\\n            return dp[k][idx]=min(1+solve(s,k,l,idx+1),solve(s,k-1,l,idx+l));\\n        }\\n        else return dp[k][idx]=solve(s,k,l,idx+1);\\n        return dp[k][idx]=INT_MAX;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(floor,numCarpets,carpetLen,0);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[1005][1005];\\n    int solve(string &s,int k,int l,int idx){\\n        if(idx>=s.size()&&k>=0)return 0;\\n        if(k<0)return INT_MAX;\\n        if(dp[k][idx]!=-1)return dp[k][idx];\\n        if(s[idx]==\\'1\\'){\\n            return dp[k][idx]=min(1+solve(s,k,l,idx+1),solve(s,k-1,l,idx+l));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2028180,
                "title": "c-easy-bottom-up-2d-dp",
                "content": "Approach / Ideas:\\n2D DP:\\nLet f[i][j] represent the min # of while tiles remaining in floor[0..i]\\nafter applying j carpets.\\nlet z be the carpet length, and c be numCarpets.\\nThen we have:\\nf[i][j] is the min of:\\n (a) f[i-1][j], if floor[i] is not white.\\n otherwise:\\n (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n\\n```\\n// 2D DP:\\n// Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n// after applying j carpets.\\n// let z be the carpet length, and c be numCarpets.\\n// Then we have:\\n// f[i][j] is the min of:\\n//  (a) f[i-1][j], if floor[i] is not white.\\n//  otherwise:\\n//  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n//  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n//\\n// TODO: Use two rolling dp-rows to reduce space complexity to O(n) from O(n*c).\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(const string& floor, int numCarpets, int carpetLen) {\\n        const int n = floor.size();\\n        const int c = numCarpets;\\n        const int z = carpetLen;\\n\\n        // enough carpets to cover all tiles?\\n        if (c * z >= n) {\\n            return 0; // all tiles, including white tiles, are covered by carpets.\\n        }\\n\\n        // prefix sum for counting the white tiles in O(1) time by using O(n) space.\\n        vector<int> prefixSum(n);\\n        {\\n            prefixSum[0] = floor[0] == \\'1\\' ? 1 : 0;\\n            for (int i = 1; i < n; ++i) {\\n                prefixSum[i] = prefixSum[i - 1] + (floor[i] == \\'1\\' ? 1 : 0);\\n            }\\n        }\\n\\n        // enough carpets for all white tiles?\\n        if (prefixSum.back() <= c) {\\n            return 0;\\n        }\\n        // Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n        // after applying j carpets.\\n        // let z be the carpet length, and c be numCarpets.\\n        vector<vector<int>> f(n, vector<int>(c + 1, n + 1));\\n        // initialize f[0][...]\\n        f[0][0] = prefixSum[0];\\n        for (int j = 1; j <= c; ++j) {\\n            f[0][j] = 0; // one carpet is enough to cover the first tile\\n        }\\n\\n        // General case\\n        // f[i][j] is the min of:\\n        //  (a) f[i-1][j], if floor[i] is not white.\\n        //  otherwise:\\n        //  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n        //  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n        for (int i = 1; i < n; ++i) {\\n            f[i][0] = prefixSum[i];\\n            for (int j = 1; j <= c; ++j) {\\n                if (IsWhiteTile(floor, i)) {\\n                    // (i-z) is the pos before the carpet whose right-side is at [i].\\n                    f[i][j] =\\n                            min(i - z >= 0 ? f[i - z][j - 1] : 0, //\\n                                1 + f[i - 1][j]);\\n                } else { // black tile --> no need to cover with carpet\\n                    f[i][j] = f[i - 1][j];\\n                }\\n            }\\n        }\\n        return f[n - 1][c];\\n    }\\n\\nprivate:\\n    static inline bool IsWhiteTile(const string& floor, int i) {\\n        return floor[i] == \\'1\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// 2D DP:\\n// Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n// after applying j carpets.\\n// let z be the carpet length, and c be numCarpets.\\n// Then we have:\\n// f[i][j] is the min of:\\n//  (a) f[i-1][j], if floor[i] is not white.\\n//  otherwise:\\n//  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n//  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n//\\n// TODO: Use two rolling dp-rows to reduce space complexity to O(n) from O(n*c).\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(const string& floor, int numCarpets, int carpetLen) {\\n        const int n = floor.size();\\n        const int c = numCarpets;\\n        const int z = carpetLen;\\n\\n        // enough carpets to cover all tiles?\\n        if (c * z >= n) {\\n            return 0; // all tiles, including white tiles, are covered by carpets.\\n        }\\n\\n        // prefix sum for counting the white tiles in O(1) time by using O(n) space.\\n        vector<int> prefixSum(n);\\n        {\\n            prefixSum[0] = floor[0] == \\'1\\' ? 1 : 0;\\n            for (int i = 1; i < n; ++i) {\\n                prefixSum[i] = prefixSum[i - 1] + (floor[i] == \\'1\\' ? 1 : 0);\\n            }\\n        }\\n\\n        // enough carpets for all white tiles?\\n        if (prefixSum.back() <= c) {\\n            return 0;\\n        }\\n        // Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n        // after applying j carpets.\\n        // let z be the carpet length, and c be numCarpets.\\n        vector<vector<int>> f(n, vector<int>(c + 1, n + 1));\\n        // initialize f[0][...]\\n        f[0][0] = prefixSum[0];\\n        for (int j = 1; j <= c; ++j) {\\n            f[0][j] = 0; // one carpet is enough to cover the first tile\\n        }\\n\\n        // General case\\n        // f[i][j] is the min of:\\n        //  (a) f[i-1][j], if floor[i] is not white.\\n        //  otherwise:\\n        //  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n        //  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n        for (int i = 1; i < n; ++i) {\\n            f[i][0] = prefixSum[i];\\n            for (int j = 1; j <= c; ++j) {\\n                if (IsWhiteTile(floor, i)) {\\n                    // (i-z) is the pos before the carpet whose right-side is at [i].\\n                    f[i][j] =\\n                            min(i - z >= 0 ? f[i - z][j - 1] : 0, //\\n                                1 + f[i - 1][j]);\\n                } else { // black tile --> no need to cover with carpet\\n                    f[i][j] = f[i - 1][j];\\n                }\\n            }\\n        }\\n        return f[n - 1][c];\\n    }\\n\\nprivate:\\n    static inline bool IsWhiteTile(const string& floor, int i) {\\n        return floor[i] == \\'1\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013213,
                "title": "c-90-dp-time-o-mn-space-o-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(\\n        string floor, \\n        int n,\\n        int k\\n    ) {\\n        int m = floor.size();\\n        if (n * k >= m) return 0;\\n        \\n        vector<int> ps(m+1);\\n        for (int i = 1; i <= m; ++i)\\n            ps[i] = ps[i-1] + (floor[i-1] == \\'1\\');\\n        \\n        vector<int> dp, dq;\\n        dp = ps;\\n        for (int i = 1; i <= n; ++i) {\\n            dq.assign(m+1, 0);\\n            for (int j = i*k+1; j <= m; ++j) {\\n                dq[j] = min(\\n                    dq[j-1]+(floor[j-1]==\\'1\\'),\\n                    dp[j-k]\\n                );\\n            }\\n            dp = dq;\\n        }\\n        \\n        return dp[m];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(\\n        string floor, \\n        int n,\\n        int k\\n    ) {\\n        int m = floor.size();\\n        if (n * k >= m) return 0;\\n        \\n        vector<int> ps(m+1);\\n        for (int i = 1; i <= m; ++i)\\n            ps[i] = ps[i-1] + (floor[i-1] == \\'1\\');\\n        \\n        vector<int> dp, dq;\\n        dp = ps;\\n        for (int i = 1; i <= n; ++i) {\\n            dq.assign(m+1, 0);\\n            for (int j = i*k+1; j <= m; ++j) {\\n                dq[j] = min(\\n                    dq[j-1]+(floor[j-1]==\\'1\\'),\\n                    dp[j-k]\\n                );\\n            }\\n            dp = dq;\\n        }\\n        \\n        return dp[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007330,
                "title": "c-dp-bottom-up-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int i, j;\\n        const int inf = 1001;\\n        int len = floor.length();\\n        vector<vector<int>> dp(len + 1, vector<int> (numCarpets + 1, inf));\\n        \\n        // Base Cases\\n        for(i = 0; i <= numCarpets; i++){\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            dp[i][0] = dp[i - 1][0] + (floor[i - 1] == \\'1\\' ? 1 : 0);\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            for(j = 1; j <= numCarpets; j++){\\n                int isWhiteTile = floor[i - 1] == \\'1\\' ? 1 : 0;\\n                \\n                dp[i][j] = dp[i - 1][j] + isWhiteTile;\\n                \\n                if(i - carpetLen >= 0){\\n                    dp[i][j] = min(dp[i][j], dp[i - carpetLen][j - 1]);\\n                }\\n                else{\\n                    dp[i][j] = min(dp[i][j], dp[0][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int i, j;\\n        const int inf = 1001;\\n        int len = floor.length();\\n        vector<vector<int>> dp(len + 1, vector<int> (numCarpets + 1, inf));\\n        \\n        // Base Cases\\n        for(i = 0; i <= numCarpets; i++){\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            dp[i][0] = dp[i - 1][0] + (floor[i - 1] == \\'1\\' ? 1 : 0);\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            for(j = 1; j <= numCarpets; j++){\\n                int isWhiteTile = floor[i - 1] == \\'1\\' ? 1 : 0;\\n                \\n                dp[i][j] = dp[i - 1][j] + isWhiteTile;\\n                \\n                if(i - carpetLen >= 0){\\n                    dp[i][j] = min(dp[i][j], dp[i - carpetLen][j - 1]);\\n                }\\n                else{\\n                    dp[i][j] = min(dp[i][j], dp[0][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986971,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t\\n\\t\\t#prefix sum of white tiles till now\\n        f = [0] * (n+1)\\n        for i in range(1, n+1):\\n            f[i] += f[i-1]\\n            if floor[i-1] == \\'1\\':\\n                f[i] += 1\\n\\t\\t\\n\\t\\t#dp over each index for different no. of tiles\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1,numCarpets+1):\\n                prevIdx = max(0, i-carpetLen)\\n                newCoverage = f[i]-f[prevIdx] + dp[prevIdx][j-1]\\n                dp[i][j] = max(dp[i-1][j], newCoverage)\\n\\t\\t\\t\\t\\n        return f[n] - dp[n][numCarpets]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t\\n\\t\\t#prefix sum of white tiles till now\\n        f = [0] * (n+1)\\n        for i in range(1, n+1):\\n            f[i] += f[i-1]\\n            if floor[i-1] == \\'1\\':\\n                f[i] += 1\\n\\t\\t\\n\\t\\t#dp over each index for different no. of tiles\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1,numCarpets+1):\\n                prevIdx = max(0, i-carpetLen)\\n                newCoverage = f[i]-f[prevIdx] + dp[prevIdx][j-1]\\n                dp[i][j] = max(dp[i-1][j], newCoverage)\\n\\t\\t\\t\\t\\n        return f[n] - dp[n][numCarpets]",
                "codeTag": "Java"
            },
            {
                "id": 1972034,
                "title": "java-bottom-up-dp-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int len = floor.length();\\n        int[][] dp = new int[numCarpets + 1][len+1];\\n        int[] prefix = new int[len];\\n        int tiles = 0, total = 0;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            tiles += floor.charAt(i) - \\'0\\'; // calculate total no of Tiles within the Carpet Length Window\\n            if(i - carpetLen >= 0) // start excluding tiles which are not in the Range anymore of the Carpet Length given\\n                tiles -= floor.charAt(i - carpetLen) - \\'0\\'; \\n            prefix[i] = tiles; // the total no of tiles covered within the Carpet Length range for current index\\n            total += floor.charAt(i) - \\'0\\';\\n        }\\n            \\n        for(int i = 1; i <= numCarpets; i++)\\n        { \\n            for(int j = 0; j < len; j++)\\n            {\\n                int doNot = dp[i][j]; // if we do not wish to cover current Tile\\n                int doTake = dp[i-1][Math.max(0, j - carpetLen + 1)] + prefix[j]; // if we do wish to cover current tile\\n                // we should go back the Carpet length & check for tiles not covered before j - carpet Length distance\\n                dp[i][j + 1] = Math.max(doTake, doNot);\\n            }\\n        }\\n        \\n        return total - dp[numCarpets][len];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int len = floor.length();\\n        int[][] dp = new int[numCarpets + 1][len+1];\\n        int[] prefix = new int[len];\\n        int tiles = 0, total = 0;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            tiles += floor.charAt(i) - \\'0\\'; // calculate total no of Tiles within the Carpet Length Window\\n            if(i - carpetLen >= 0) // start excluding tiles which are not in the Range anymore of the Carpet Length given\\n                tiles -= floor.charAt(i - carpetLen) - \\'0\\'; \\n            prefix[i] = tiles; // the total no of tiles covered within the Carpet Length range for current index\\n            total += floor.charAt(i) - \\'0\\';\\n        }\\n            \\n        for(int i = 1; i <= numCarpets; i++)\\n        { \\n            for(int j = 0; j < len; j++)\\n            {\\n                int doNot = dp[i][j]; // if we do not wish to cover current Tile\\n                int doTake = dp[i-1][Math.max(0, j - carpetLen + 1)] + prefix[j]; // if we do wish to cover current tile\\n                // we should go back the Carpet length & check for tiles not covered before j - carpet Length distance\\n                dp[i][j + 1] = Math.max(doTake, doNot);\\n            }\\n        }\\n        \\n        return total - dp[numCarpets][len];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940507,
                "title": "python3-dp-beats-100",
                "content": "Standard DP solution with a few optimizations:\\n* We will never lay a carpet starting on a black tile. We could defer laying the carpet and cover the same or more white tiles.\\n* If the next carpetLen tiles are all white, we will always lay a carpet.\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        whiteTileSegment = \\'1\\' * carpetLen\\n        \\n        # Minimum white tiles shown on tile i..len(tiles)-1 with n carpets.\\n\\t\\t@cache\\n        def dp(i, n):\\n\\t\\t    # No tiles remain.\\n            if i >= len(floor):\\n                return 0\\n            # No carpets remain, return the count of remaining white tiles.\\n            if n == 0:\\n                return floor[i:].count(\\'1\\')\\n            # Tile i is black, we will never lay a carpet starting on a black tile.\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, n)\\n            # There is enough carpet left to cover all remaining tiles.\\n            if len(floor) - i < n * carpetLen:\\n                return 0\\n            # The next carpetLen tiles are all white, we will always lay a carpet here.\\n            if floor[i:i + carpetLen] == whiteTileSegment:\\n                return dp(i + carpetLen, n - 1)\\n            \\n            dontLayCarpet = 1 + dp(i + 1, n)\\n            layCarpet = dp(i + carpetLen, n - 1)\\n            return min(dontLayCarpet, layCarpet)\\n                  \\n        return dp(0, numCarpets)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        whiteTileSegment = \\'1\\' * carpetLen\\n        \\n        # Minimum white tiles shown on tile i..len(tiles)-1 with n carpets.\\n\\t\\t@cache\\n        def dp(i, n):\\n\\t\\t    # No tiles remain.\\n            if i >= len(floor):\\n                return 0\\n            # No carpets remain, return the count of remaining white tiles.\\n            if n == 0:\\n                return floor[i:].count(\\'1\\')\\n            # Tile i is black, we will never lay a carpet starting on a black tile.\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, n)\\n            # There is enough carpet left to cover all remaining tiles.\\n            if len(floor) - i < n * carpetLen:\\n                return 0\\n            # The next carpetLen tiles are all white, we will always lay a carpet here.\\n            if floor[i:i + carpetLen] == whiteTileSegment:\\n                return dp(i + carpetLen, n - 1)\\n            \\n            dontLayCarpet = 1 + dp(i + 1, n)\\n            layCarpet = dp(i + carpetLen, n - 1)\\n            return min(dontLayCarpet, layCarpet)\\n                  \\n        return dp(0, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916981,
                "title": "very-simple-dp-solution",
                "content": "```\\n\\nclass Solution {\\n    \\n    \\n    private int[] suffix=new int[1002];\\n    \\n    private void generateSuffixArray(String floor){\\n        int c=0;\\n        for(int i=0;i<floor.length();i++){\\n            if(floor.charAt(i) == \\'1\\')\\n                c++;\\n            suffix[i]=c;\\n        }\\n    }\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        generateSuffixArray(floor);\\n        int arr[][]=new int[numCarpets+1][floor.length()];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[i].length;j++){\\n                if(i==0)\\n                    arr[i][j]=0;\\n                else{\\n                    arr[i][j]=suffix[j];\\n                    if(j-carpetLen >=0)\\n                        arr[i][j]=arr[i][j]-suffix[j-carpetLen]+arr[i-1][j-carpetLen];\\n                    if(j-1>=0)\\n                        arr[i][j]=Math.max(arr[i][j-1],arr[i][j]);\\n                }\\n\\n            }\\n\\n        }\\n        \\n        return suffix[floor.length()-1]-arr[numCarpets][floor.length()-1];\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    \\n    private int[] suffix=new int[1002];\\n    \\n    private void generateSuffixArray(String floor){\\n        int c=0;\\n        for(int i=0;i<floor.length();i++){\\n            if(floor.charAt(i) == \\'1\\')\\n                c++;\\n            suffix[i]=c;\\n        }\\n    }\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        generateSuffixArray(floor);\\n        int arr[][]=new int[numCarpets+1][floor.length()];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[i].length;j++){\\n                if(i==0)\\n                    arr[i][j]=0;\\n                else{\\n                    arr[i][j]=suffix[j];\\n                    if(j-carpetLen >=0)\\n                        arr[i][j]=arr[i][j]-suffix[j-carpetLen]+arr[i-1][j-carpetLen];\\n                    if(j-1>=0)\\n                        arr[i][j]=Math.max(arr[i][j-1],arr[i][j]);\\n                }\\n\\n            }\\n\\n        }\\n        \\n        return suffix[floor.length()-1]-arr[numCarpets][floor.length()-1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914589,
                "title": "easy-to-understand-dp",
                "content": "The idea is simple to use DP and memoization to maintain the number of covered tiles at an index i with k remaining carpets.\\n\\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let answer = Number.MAX_SAFE_INTEGER, dp = {};\\n    \\n    floor = floor.split(\\'\\');\\n    \\n    function findMaxCoveredTiles(index, carpetsLeft) {\\n        if(index >= floor.length) {\\n            return 0;\\n        }\\n        if(dp[index]) {\\n            if(dp[index][carpetsLeft] != undefined) {\\n                return dp[index][carpetsLeft];\\n            }\\n        }\\n        else {\\n            dp[index] = {};\\n        }\\n        \\n        dp[index][carpetsLeft] = Number.MIN_SAFE_INTEGER;\\n        if(carpetsLeft) {\\n            dp[index][carpetsLeft] = Math.min(carpetLen, floor.length - index) + findMaxCoveredTiles(index + carpetLen, carpetsLeft - 1);\\n        }\\n\\n        dp[index][carpetsLeft] = Math.max(dp[index][carpetsLeft], !+floor[index] + findMaxCoveredTiles(index + 1, carpetsLeft));\\n        \\n        return dp[index][carpetsLeft];\\n    }\\n    \\n    return floor.length - findMaxCoveredTiles(0, numCarpets);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let answer = Number.MAX_SAFE_INTEGER, dp = {};\\n    \\n    floor = floor.split(\\'\\');\\n    \\n    function findMaxCoveredTiles(index, carpetsLeft) {\\n        if(index >= floor.length) {\\n            return 0;\\n        }\\n        if(dp[index]) {\\n            if(dp[index][carpetsLeft] != undefined) {\\n                return dp[index][carpetsLeft];\\n            }\\n        }\\n        else {\\n            dp[index] = {};\\n        }\\n        \\n        dp[index][carpetsLeft] = Number.MIN_SAFE_INTEGER;\\n        if(carpetsLeft) {\\n            dp[index][carpetsLeft] = Math.min(carpetLen, floor.length - index) + findMaxCoveredTiles(index + carpetLen, carpetsLeft - 1);\\n        }\\n\\n        dp[index][carpetsLeft] = Math.max(dp[index][carpetsLeft], !+floor[index] + findMaxCoveredTiles(index + 1, carpetsLeft));\\n        \\n        return dp[index][carpetsLeft];\\n    }\\n    \\n    return floor.length - findMaxCoveredTiles(0, numCarpets);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907291,
                "title": "golang-search-with-memoization",
                "content": "```\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    memo := make([][]int, len(floor))\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = make([]int, numCarpets + 1)\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    return dfs(floor, numCarpets, carpetLen, 0, memo)\\n}\\n\\nfunc dfs(floor string, carp int, size int, pos int, memo [][]int) int {\\n    if pos >= len(floor) {\\n        return 0\\n    }\\n    \\n    if memo[pos][carp] != -1 {\\n        return memo[pos][carp]\\n    }\\n    \\n    res := 0\\n    if floor[pos] == \\'0\\' {\\n        res = dfs(floor, carp, size, pos + 1, memo)\\n    } else {\\n        res = 1 + dfs(floor, carp, size, pos + 1, memo)\\n        if carp > 0 {\\n            res = min(res, dfs(floor, carp - 1, size, pos + size, memo))\\n        }\\n    }  \\n    \\n    memo[pos][carp] = res\\n    \\n    return res\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    memo := make([][]int, len(floor))\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = make([]int, numCarpets + 1)\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    return dfs(floor, numCarpets, carpetLen, 0, memo)\\n}\\n\\nfunc dfs(floor string, carp int, size int, pos int, memo [][]int) int {\\n    if pos >= len(floor) {\\n        return 0\\n    }\\n    \\n    if memo[pos][carp] != -1 {\\n        return memo[pos][carp]\\n    }\\n    \\n    res := 0\\n    if floor[pos] == \\'0\\' {\\n        res = dfs(floor, carp, size, pos + 1, memo)\\n    } else {\\n        res = 1 + dfs(floor, carp, size, pos + 1, memo)\\n        if carp > 0 {\\n            res = min(res, dfs(floor, carp - 1, size, pos + size, memo))\\n        }\\n    }  \\n    \\n    memo[pos][carp] = res\\n    \\n    return res\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906286,
                "title": "java-top-down-dp-with-greedy-beats-91-43",
                "content": "```\\n    /*\\n    TLE without the \"allWhite\" check. Otherwise,\\n\\n    Runtime: 89 ms, faster than 91.43% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n    Memory Usage: 48.9 MB, less than 89.69% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n     */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] cache = new int[floor.length()][numCarpets + 1];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        char[] colors = floor.toCharArray();\\n        return minimumWhiteTiles(colors, numCarpets, carpetLen, 0, cache);\\n    }\\n\\n    private int minimumWhiteTiles(char[] colors, int numCarpets, int carpetLen, int ind, int[][] cache) {\\n        if (numCarpets * carpetLen >= colors.length - ind) {\\n            return 0;\\n        }\\n\\n        if (cache[ind][numCarpets] != -1) {\\n            return cache[ind][numCarpets];\\n        }\\n\\n        if (numCarpets == 0) {\\n            int remainingWhite = 0;\\n            for (int i = ind; i < colors.length; i++) {\\n                if (colors[i] == \\'1\\') {\\n                    remainingWhite++;\\n                }\\n            }\\n            cache[ind][numCarpets] = remainingWhite;\\n            return remainingWhite;\\n        }\\n\\n        int white = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = ind; i < colors.length; i++) {\\n            if (colors[i] == \\'1\\') { // Greedy\\n                min = Math.min(min, white + minimumWhiteTiles(colors, numCarpets - 1, carpetLen, i + carpetLen, cache));\\n                white++;\\n\\n                // Greedy\\n                if (allWhite(colors, i, carpetLen)) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        min = min == Integer.MAX_VALUE ? 0 : min;\\n        cache[ind][numCarpets] = min;\\n\\n        return min;\\n    }\\n\\n    private boolean allWhite(char[] colors, int ind, int carpetLen) {\\n        for (int j = 0; j < carpetLen && ind + j < colors.length; j++) {\\n            if (colors[ind + j] == \\'0\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n    /*\\n    TLE without the \"allWhite\" check. Otherwise,\\n\\n    Runtime: 89 ms, faster than 91.43% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n    Memory Usage: 48.9 MB, less than 89.69% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n     */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] cache = new int[floor.length()][numCarpets + 1];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        char[] colors = floor.toCharArray();\\n        return minimumWhiteTiles(colors, numCarpets, carpetLen, 0, cache);\\n    }\\n\\n    private int minimumWhiteTiles(char[] colors, int numCarpets, int carpetLen, int ind, int[][] cache) {\\n        if (numCarpets * carpetLen >= colors.length - ind) {\\n            return 0;\\n        }\\n\\n        if (cache[ind][numCarpets] != -1) {\\n            return cache[ind][numCarpets];\\n        }\\n\\n        if (numCarpets == 0) {\\n            int remainingWhite = 0;\\n            for (int i = ind; i < colors.length; i++) {\\n                if (colors[i] == \\'1\\') {\\n                    remainingWhite++;\\n                }\\n            }\\n            cache[ind][numCarpets] = remainingWhite;\\n            return remainingWhite;\\n        }\\n\\n        int white = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = ind; i < colors.length; i++) {\\n            if (colors[i] == \\'1\\') { // Greedy\\n                min = Math.min(min, white + minimumWhiteTiles(colors, numCarpets - 1, carpetLen, i + carpetLen, cache));\\n                white++;\\n\\n                // Greedy\\n                if (allWhite(colors, i, carpetLen)) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        min = min == Integer.MAX_VALUE ? 0 : min;\\n        cache[ind][numCarpets] = min;\\n\\n        return min;\\n    }\\n\\n    private boolean allWhite(char[] colors, int ind, int carpetLen) {\\n        for (int j = 0; j < carpetLen && ind + j < colors.length; j++) {\\n            if (colors[ind + j] == \\'0\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903622,
                "title": "golang-dp-solution",
                "content": "```go\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tblack, white := byte(\\'0\\'), byte(\\'1\\')\\n\\t_ = black\\n\\t_ = white\\n\\tif numCarpets*carpetLen >= len(floor) {\\n\\t\\treturn 0\\n\\t}\\n\\tdpMask := make([][]int, len(floor))\\n\\tfor i := range dpMask {\\n\\t\\tdpMask[i] = make([]int, numCarpets+1)\\n\\t}\\n\\tif floor[0] == white {\\n\\t\\tfor i := 1; i < len(dpMask[0]); i++ {\\n\\t\\t\\tdpMask[0][i] = 1\\n\\t\\t}\\n\\t}\\n\\twhiteHelper := make([]int, len(floor)+1)\\n\\tfor i := range floor {\\n\\t\\twhiteHelper[i+1] = whiteHelper[i]\\n\\t\\tif floor[i] == white {\\n\\t\\t\\twhiteHelper[i+1]++\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(floor); i++ {\\n\\t\\tfor carpets := 1; carpets <= numCarpets; carpets++ {\\n\\t\\t\\tdpMask[i][carpets] = dpMask[i-1][carpets]\\n\\t\\t\\tif i < carpetLen {\\n\\t\\t\\t\\tdpMask[i][carpets] = whiteHelper[i+1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttempWhiteMask := whiteHelper[i+1] - whiteHelper[i+1-carpetLen] + dpMask[i-carpetLen][carpets-1]\\n\\t\\t\\t\\tif tempWhiteMask > dpMask[i][carpets] {\\n\\t\\t\\t\\t\\tdpMask[i][carpets] = tempWhiteMask\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn whiteHelper[len(whiteHelper)-1] - dpMask[len(dpMask)-1][numCarpets]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tblack, white := byte(\\'0\\'), byte(\\'1\\')\\n\\t_ = black\\n\\t_ = white\\n\\tif numCarpets*carpetLen >= len(floor) {\\n\\t\\treturn 0\\n\\t}\\n\\tdpMask := make([][]int, len(floor))\\n\\tfor i := range dpMask {\\n\\t\\tdpMask[i] = make([]int, numCarpets+1)\\n\\t}\\n\\tif floor[0] == white {\\n\\t\\tfor i := 1; i < len(dpMask[0]); i++ {\\n\\t\\t\\tdpMask[0][i] = 1\\n\\t\\t}\\n\\t}\\n\\twhiteHelper := make([]int, len(floor)+1)\\n\\tfor i := range floor {\\n\\t\\twhiteHelper[i+1] = whiteHelper[i]\\n\\t\\tif floor[i] == white {\\n\\t\\t\\twhiteHelper[i+1]++\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(floor); i++ {\\n\\t\\tfor carpets := 1; carpets <= numCarpets; carpets++ {\\n\\t\\t\\tdpMask[i][carpets] = dpMask[i-1][carpets]\\n\\t\\t\\tif i < carpetLen {\\n\\t\\t\\t\\tdpMask[i][carpets] = whiteHelper[i+1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttempWhiteMask := whiteHelper[i+1] - whiteHelper[i+1-carpetLen] + dpMask[i-carpetLen][carpets-1]\\n\\t\\t\\t\\tif tempWhiteMask > dpMask[i][carpets] {\\n\\t\\t\\t\\t\\tdpMask[i][carpets] = tempWhiteMask\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn whiteHelper[len(whiteHelper)-1] - dpMask[len(dpMask)-1][numCarpets]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901600,
                "title": "python3-clear-top-down-greedy-dp-solution",
                "content": "The greedy strategy is that we always want to make the decision whether or not to start tiling at an indice with an element \\'1\\'. Then, we can apply memoization.\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, l: int) -> int:\\n        m = len(floor)\\n        \\n        @lru_cache(None)\\n        def dp(i, used):\\n            if i >= m:\\n                return 0\\n            if used < 1:\\n                return dp(i + 1, used) + (1 if floor[i] == \\'1\\' else 0)\\n            if used * l >= m - i:\\n                return 0\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, used)\\n            return min(dp(i + l, used - 1), dp(i + 1, used) + 1)\\n        \\n        res = dp(0, n)\\n        dp.cache_clear()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, l: int) -> int:\\n        m = len(floor)\\n        \\n        @lru_cache(None)\\n        def dp(i, used):\\n            if i >= m:\\n                return 0\\n            if used < 1:\\n                return dp(i + 1, used) + (1 if floor[i] == \\'1\\' else 0)\\n            if used * l >= m - i:\\n                return 0\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, used)\\n            return min(dp(i + l, used - 1), dp(i + 1, used) + 1)\\n        \\n        res = dp(0, n)\\n        dp.cache_clear()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899559,
                "title": "dp-prefix-sum-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int clen;\\n    \\n    vector<int> prefix;\\n    \\n    int dp[1001][1001];\\n    \\n    int helper(string floor, int idx, int numc){\\n        \\n        //cout << idx << \" \" << numc << endl;\\n        \\n        int n = floor.size();\\n        \\n        if(numc == 0 || idx >= n) return 0;\\n        \\n        if(dp[idx][numc] != -1) return dp[idx][numc];\\n        \\n        if(floor[idx] == \\'0\\') return dp[idx][numc] = helper(floor, idx+1, numc);\\n        \\n        int res = INT_MIN;\\n    \\n        int tillIdxCover = min(n, idx+clen);\\n        int tilesCovered = prefix[tillIdxCover-1] - prefix[idx]+1;\\n        \\n        res = max(res, tilesCovered +helper(floor, tillIdxCover, numc-1));\\n        \\n        if(tilesCovered == clen) return dp[idx][numc] = res;\\n        \\n        res = max(res, helper(floor, idx+1, numc));\\n            \\n        return dp[idx][numc] = res;\\n \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        clen = carpetLen;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\') cnt++;\\n            prefix.push_back(cnt);\\n        }\\n        \\n        if(cnt == 0) return 0;\\n        \\n        return cnt-helper(floor, 0, numCarpets);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int clen;\\n    \\n    vector<int> prefix;\\n    \\n    int dp[1001][1001];\\n    \\n    int helper(string floor, int idx, int numc){\\n        \\n        //cout << idx << \" \" << numc << endl;\\n        \\n        int n = floor.size();\\n        \\n        if(numc == 0 || idx >= n) return 0;\\n        \\n        if(dp[idx][numc] != -1) return dp[idx][numc];\\n        \\n        if(floor[idx] == \\'0\\') return dp[idx][numc] = helper(floor, idx+1, numc);\\n        \\n        int res = INT_MIN;\\n    \\n        int tillIdxCover = min(n, idx+clen);\\n        int tilesCovered = prefix[tillIdxCover-1] - prefix[idx]+1;\\n        \\n        res = max(res, tilesCovered +helper(floor, tillIdxCover, numc-1));\\n        \\n        if(tilesCovered == clen) return dp[idx][numc] = res;\\n        \\n        res = max(res, helper(floor, idx+1, numc));\\n            \\n        return dp[idx][numc] = res;\\n \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        clen = carpetLen;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\') cnt++;\\n            prefix.push_back(cnt);\\n        }\\n        \\n        if(cnt == 0) return 0;\\n        \\n        return cnt-helper(floor, 0, numCarpets);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1897112,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        if (numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int> (numCarpets + 1, INF));\\n        int white = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (floor[i] == \\'1\\') {\\n                ++white;\\n            }\\n            dp[i + 1][0] = white;\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int k = 0; k <= numCarpets; k++) {\\n                if (floor[i] == \\'0\\') {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k]);\\n                }\\n                else {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k] + 1);\\n                }\\n                if (i + carpetLen <= n && k + 1 <= numCarpets) {\\n                    dp[i + carpetLen][k + 1] = min(dp[i + carpetLen][k + 1], dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        if (numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int> (numCarpets + 1, INF));\\n        int white = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (floor[i] == \\'1\\') {\\n                ++white;\\n            }\\n            dp[i + 1][0] = white;\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int k = 0; k <= numCarpets; k++) {\\n                if (floor[i] == \\'0\\') {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k]);\\n                }\\n                else {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k] + 1);\\n                }\\n                if (i + carpetLen <= n && k + 1 <= numCarpets) {\\n                    dp[i + carpetLen][k + 1] = min(dp[i + carpetLen][k + 1], dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896751,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n        int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        vector<int> floor(carpetLen * (s.size() / carpetLen + (s.size() % carpetLen != 0)) + 1);\\n        for (int i = 1; i < floor.size(); ++i) {\\n            floor[i] = floor[i - 1] + (i <= s.size() ? s[i - 1] - \\'0\\' : 0);\\n        }\\n        \\n        int res = 0;\\n        vector<vector<int>> maxWhite(numCarpets + 1, vector<int>(floor.size()));\\n        for (int i = 1; i <= numCarpets; ++i) {\\n            for (int j = carpetLen * i; j < floor.size(); ++j) {\\n                maxWhite[i][j] = maxWhite[i][j - 1];\\n                maxWhite[i][j] = max(maxWhite[i][j], maxWhite[i - 1][j - carpetLen] + floor[j] - floor[j - carpetLen]);\\n                res = max(res, maxWhite[i][j]);\\n            }\\n        }\\n\\n        return floor.back() - res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        vector<int> floor(carpetLen * (s.size() / carpetLen + (s.size() % carpetLen != 0)) + 1);\\n        for (int i = 1; i < floor.size(); ++i) {\\n            floor[i] = floor[i - 1] + (i <= s.size() ? s[i - 1] - \\'0\\' : 0);\\n        }\\n        \\n        int res = 0;\\n        vector<vector<int>> maxWhite(numCarpets + 1, vector<int>(floor.size()));\\n        for (int i = 1; i <= numCarpets; ++i) {\\n            for (int j = carpetLen * i; j < floor.size(); ++j) {\\n                maxWhite[i][j] = maxWhite[i][j - 1];\\n                maxWhite[i][j] = max(maxWhite[i][j], maxWhite[i - 1][j - carpetLen] + floor[j] - floor[j - carpetLen]);\\n                res = max(res, maxWhite[i][j]);\\n            }\\n        }\\n\\n        return floor.back() - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896494,
                "title": "c-very-simple-solution",
                "content": "ON EVERY TIILE WE HAVE TO CHOICES \\nEITHER TO PUT THE CARPET OR MOVE AHEAD\\nWRITE THIS IN RECURRSION\\n```\\nclass Solution {\\npublic:\\n    \\n    int solver(string & floor,int nc,int cl,int i,int n,int dis[],vector<vector<int>>&dp)\\n    {\\n        \\n        \\n        if(i==0|| nc==0)\\n            return 0;\\n      \\n        if(dp[i][nc]!=-1)\\n            return dp[i][nc];\\n        \\n        int k=dis[i]-dis[max(0,i-cl)];\\n        \\n        int ans=0;\\n        ans=max(ans,solver(floor,nc-1,cl,max(0,i-cl),n,dis,dp)+k);\\n        ans=max(ans,solver(floor,nc,cl,i-1,n,dis,dp));\\n        \\n        \\n        \\n        return dp[i][nc]=ans;\\n        \\n        \\n    }\\n    int minimumWhiteTiles(string floor, int nc, int cl) {\\n        \\n        int n=floor.length();\\n        int dis[n+1];\\n        vector<vector<int>>dp(n+1,vector<int>(nc+1,-1));\\n        int total=0;\\n      \\n        dis[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(floor[i-1]==\\'1\\')\\n            {\\n                total++;\\n                dis[i]=dis[i-1]+1;\\n            }\\n            else\\n                dis[i]=dis[i-1];\\n        }\\n        \\n        \\n      \\n        return total-solver(floor,nc,cl,n,n,dis,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solver(string & floor,int nc,int cl,int i,int n,int dis[],vector<vector<int>>&dp)\\n    {\\n        \\n        \\n        if(i==0|| nc==0)\\n            return 0;\\n      \\n        if(dp[i][nc]!=-1)\\n            return dp[i][nc];\\n        \\n        int k=dis[i]-dis[max(0,i-cl)];\\n        \\n        int ans=0;\\n        ans=max(ans,solver(floor,nc-1,cl,max(0,i-cl),n,dis,dp)+k);\\n        ans=max(ans,solver(floor,nc,cl,i-1,n,dis,dp));\\n        \\n        \\n        \\n        return dp[i][nc]=ans;\\n        \\n        \\n    }\\n    int minimumWhiteTiles(string floor, int nc, int cl) {\\n        \\n        int n=floor.length();\\n        int dis[n+1];\\n        vector<vector<int>>dp(n+1,vector<int>(nc+1,-1));\\n        int total=0;\\n      \\n        dis[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(floor[i-1]==\\'1\\')\\n            {\\n                total++;\\n                dis[i]=dis[i-1]+1;\\n            }\\n            else\\n                dis[i]=dis[i-1];\\n        }\\n        \\n        \\n      \\n        return total-solver(floor,nc,cl,n,n,dis,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894976,
                "title": "c-dp-memo-prefix-sum",
                "content": "\\tclass Solution {\\n    \\n    void fillPrefix(vector<int> &pre, string &s, int n) {\\n        \\n        int p = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\')\\n                p++;\\n            \\n            pre[i] = p;\\n        }\\n    }\\n    \\n    int memo(int i, int used, string &s, int n, int nc, int l, vector<vector<int>> &dp, vector<int> &pre) {\\n        \\n        if(i >= n || nc == used)\\n            return 0;\\n        \\n        if(dp[i][used] != -1)\\n            return dp[i][used];\\n        \\n        if(s[i] == \\'0\\')\\n            dp[i][used] = memo(i + 1, used, s, n, nc, l, dp, pre);\\n        else {\\n            int ind = min(i + l - 1, n - 1);\\n            int ans = pre[ind];\\n            if(i > 0)\\n                ans -= pre[i - 1];\\n        \\n            int include = memo(i + l, used + 1, s, n, nc, l, dp, pre);\\n            int exclude = memo(i + 1, used, s, n, nc, l, dp, pre);\\n        \\n            dp[i][used] = max(include + ans, exclude);\\n        }\\n        \\n        return dp[i][used];\\n    }\\n    \\n\\tpublic:\\n    int minimumWhiteTiles(string s, int nc, int l) {\\n        \\n        int n = s.length();\\n        vector<int> pre(n, 0);\\n        fillPrefix(pre, s, n);\\n        \\n        if(pre[n - 1] == 0)\\n            return 0;\\n        \\n        vector<vector<int>> dp(n, vector<int> (nc, -1));\\n        return pre[n - 1] - memo(0, 0, s, n, nc, l, dp, pre);\\n    }\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    \\n    void fillPrefix(vector<int> &pre, string &s, int n) {\\n        \\n        int p = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\')\\n                p++;\\n            \\n            pre[i] = p;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1889341,
                "title": "c-dp-solution-bottom-up",
                "content": "```\\n        public class Solution\\n        {\\n            public int MinimumWhiteTiles(string floor, int numCarpets, int carpetLen)\\n            {\\n                int[,] m = new int[floor.Length + 1, numCarpets + 1];\\n                int count = 0;\\n\\n                //Setup first column when there is no carpets available.  \\n                for (int r = floor.Length - 1; r >= 0; r--)\\n                {\\n                    if (floor[r] == \\'1\\')\\n                    {\\n                        count++;\\n                        m[r, 0] = count;\\n                    }\\n                    else\\n                    {\\n                        m[r, 0] = m[r + 1, 0];\\n                    }\\n                }\\n\\n\\t\\t\\t\\t//Looping through each column.  Each column represents the num of available carpets.\\n                for (int c = 1; c <= numCarpets; c++)\\n                {\\n                    for (int r = floor.Length - 1; r >= 0; r--)\\n                    {\\n                        if (floor[r] == \\'0\\')\\n                        {\\n                            m[r, c] = m[r + 1, c];\\n                        }\\n                        else\\n                        {\\n                            //current tile of the floor, the cost of using the carpet.\\n\\t\\t\\t\\t\\t\\t\\t//cost means the minimum num of white tiles visible.\\n                            var a = r + carpetLen <= floor.Length ? m[r + carpetLen, c - 1] : 0;\\n\\n                            //compare it with no carpet at the current tile, Take the smaller one.\\n                            m[r, c] = Math.Min(a, m[r + 1, c] + 1);\\n                        }\\n                    }\\n                };\\n                return m[0, numCarpets];\\n\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n        public class Solution\\n        {\\n            public int MinimumWhiteTiles(string floor, int numCarpets, int carpetLen)\\n            {\\n                int[,] m = new int[floor.Length + 1, numCarpets + 1];\\n                int count = 0;\\n\\n                //Setup first column when there is no carpets available.  \\n                for (int r = floor.Length - 1; r >= 0; r--)\\n                {\\n                    if (floor[r] == \\'1\\')\\n                    {\\n                        count++;\\n                        m[r, 0] = count;\\n                    }\\n                    else\\n                    {\\n                        m[r, 0] = m[r + 1, 0];\\n                    }\\n                }\\n\\n\\t\\t\\t\\t//Looping through each column.  Each column represents the num of available carpets.\\n                for (int c = 1; c <= numCarpets; c++)\\n                {\\n                    for (int r = floor.Length - 1; r >= 0; r--)\\n                    {\\n                        if (floor[r] == \\'0\\')\\n                        {\\n                            m[r, c] = m[r + 1, c];\\n                        }\\n                        else\\n                        {\\n                            //current tile of the floor, the cost of using the carpet.\\n\\t\\t\\t\\t\\t\\t\\t//cost means the minimum num of white tiles visible.\\n                            var a = r + carpetLen <= floor.Length ? m[r + carpetLen, c - 1] : 0;\\n\\n                            //compare it with no carpet at the current tile, Take the smaller one.\\n                            m[r, c] = Math.Min(a, m[r + 1, c] + 1);\\n                        }\\n                    }\\n                };\\n                return m[0, numCarpets];\\n\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888435,
                "title": "c-easy-dp-solution",
                "content": "here when ever we incounter a white tiles then only we have to make sure have to cover it else we can continue moving over string moreover we have to insure once we incounter white tiles and used carpet to cover it then wee could easely move length of carpet step ahead as it would cover both white and black tiles \\n\\nint f(int i,string& s, int n, int l,vector<vector<int>>& dp)\\n    {\\n        if(i<0 )\\n            return 0;\\n        if(dp[i][n] != -1)\\n            return dp[i][n];\\n        int t=1e8,nt=0;\\n        nt = s[i]-\\'0\\' + f(i-1,s,n,l,dp);\\n        if(n>0 && s[i] == \\'1\\')\\n        t = f(i-l,s,n-1,l,dp);\\n        return dp[i][n] = min(t,nt);\\n    }\\n    \\n    int minimumWhiteTiles(string s, int n, int l) {\\n        \\n        int n1 = s.size();\\n        vector<vector<int>> dp(n1,vector<int>(n+1,-1));\\n        return f(n1-1,s,n,l,dp);\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "here when ever we incounter a white tiles then only we have to make sure have to cover it else we can continue moving over string moreover we have to insure once we incounter white tiles and used carpet to cover it then wee could easely move length of carpet step ahead as it would cover both white and black tiles \\n\\nint f(int i,string& s, int n, int l,vector<vector<int>>& dp)\\n    {\\n        if(i<0 )\\n            return 0;\\n        if(dp[i][n] != -1)\\n            return dp[i][n];\\n        int t=1e8,nt=0;\\n        nt = s[i]-\\'0\\' + f(i-1,s,n,l,dp);\\n        if(n>0 && s[i] == \\'1\\')\\n        t = f(i-l,s,n-1,l,dp);\\n        return dp[i][n] = min(t,nt);\\n    }\\n    \\n    int minimumWhiteTiles(string s, int n, int l) {\\n        \\n        int n1 = s.size();\\n        vector<vector<int>> dp(n1,vector<int>(n+1,-1));\\n        return f(n1-1,s,n,l,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1888259,
                "title": "presum-dp",
                "content": "My thought is very similar to the solution of this problem https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/.\\n\\nDefine dp state:\\n\\n`dp[i][j]: when use i carpet, starting from j-th floor, the maximum covered white tiles.`\\n\\nThe relation between dp states:\\n\\n`dp[i][j] = dp[i-1][j-k] + # of covered white tiles by i-th carpet.`\\n`i-1` is the number of carpet used \\n`j-k` is the maximum possible starting floor for `i-1` floors. (The best strategy is not to overlap the carpets).\\n\\nTo quickly get the # of covered white tiles by i-th carpet, we need to calculate the prefix sum of white tiles.\\n\\n\\nRemember we want to find the maximum covered white tiles.\\nIf after the i-th carpet covered tile starting from position j,\\nthe overall covered white tiles are not better than previous result,\\nprevious result should be used. So we have the following relation:\\n        \\n`dp[i][j] = max(dp[i][j], dp[i][j-1]);`\\n        \\n        \\nExample:\\n```\\nfloor:\\n1 1 0 0 0 1 0 1 0\\n        \\ncarpet len: 2, num carpets: 1\\n        \\ndp[1] = [2 2 2 2 2 2 2 2 2]\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int m = numCarpets, n = floor.length(), k = carpetLen;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        vector<int> presum(n+1, 0);\\n        floor = \"#\" + floor;\\n        int count = 0;\\n        for(int i=1; i<=n; i++) {\\n            count += (floor[i]-\\'0\\');\\n            presum[i] = presum[i-1]+(floor[i]-\\'0\\');\\n        }\\n        \\n        int ret = count;\\n        for(int i=1; i<=m && ret>0; i++) {\\n            for(int j=(i-1)*k+1; j<=n && ret>0; j++) {\\n                dp[i][j] = (i==1?0:dp[i-1][j-k]) + presum[min(n,j+k-1)] - presum[j-1];\\n                dp[i][j] = max(dp[i][j], dp[i][j-1]);\\n                ret = min(ret, count - dp[i][j]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfloor:\\n1 1 0 0 0 1 0 1 0\\n        \\ncarpet len: 2, num carpets: 1\\n        \\ndp[1] = [2 2 2 2 2 2 2 2 2]\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int m = numCarpets, n = floor.length(), k = carpetLen;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        vector<int> presum(n+1, 0);\\n        floor = \"#\" + floor;\\n        int count = 0;\\n        for(int i=1; i<=n; i++) {\\n            count += (floor[i]-\\'0\\');\\n            presum[i] = presum[i-1]+(floor[i]-\\'0\\');\\n        }\\n        \\n        int ret = count;\\n        for(int i=1; i<=m && ret>0; i++) {\\n            for(int j=(i-1)*k+1; j<=n && ret>0; j++) {\\n                dp[i][j] = (i==1?0:dp[i-1][j-k]) + presum[min(n,j+k-1)] - presum[j-1];\\n                dp[i][j] = max(dp[i][j], dp[i][j-1]);\\n                ret = min(ret, count - dp[i][j]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886286,
                "title": "easy-top-down-knapsack-solution-c",
                "content": "```\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,0));\\n        //Initialising\\n        for(int i=0;i<n;i++){\\n            if(i!=0)\\n            dp[i][0]=dp[i-1][0];\\n            if(floor[i]==\\'1\\'){\\n                dp[i][0]+=1;\\n            }\\n        }\\n        for (int j=1; j<=numCarpets;j++){ \\n            for(int i=0;i<n;i++){\\n                int skipcarpet;\\n                if(i==0)\\n                    skipcarpet=floor[i]==\\'1\\' ? 1 :0;\\n                else\\n                skipcarpet=floor[i]==\\'1\\' ? dp[i-1][j]+1 :dp[i-1][j];\\n                if(i-carpetLen>=0)\\n                dp[i][j]=min(dp[i-carpetLen][j-1], skipcarpet);  // min(usecarpet,skipcarpet)\\n                else \\n                 dp[i][j]=min(0,skipcarpet);\\n            }\\n        }\\n        \\n        return dp[n-1][numCarpets];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,0));\\n        //Initialising\\n        for(int i=0;i<n;i++){\\n            if(i!=0)\\n            dp[i][0]=dp[i-1][0];\\n            if(floor[i]==\\'1\\'){\\n                dp[i][0]+=1;\\n            }\\n        }\\n        for (int j=1; j<=numCarpets;j++){ \\n            for(int i=0;i<n;i++){\\n                int skipcarpet;\\n                if(i==0)\\n                    skipcarpet=floor[i]==\\'1\\' ? 1 :0;\\n                else\\n                skipcarpet=floor[i]==\\'1\\' ? dp[i-1][j]+1 :dp[i-1][j];\\n                if(i-carpetLen>=0)\\n                dp[i][j]=min(dp[i-carpetLen][j-1], skipcarpet);  // min(usecarpet,skipcarpet)\\n                else \\n                 dp[i][j]=min(0,skipcarpet);\\n            }\\n        }\\n        \\n        return dp[n-1][numCarpets];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1886192,
                "title": "python-top-down-passing-no-tle",
                "content": "Simple thing to speed up the code is keep a cached sum of number of white tiles remaining after index `i` so that once we have 0 carpets left it\\'s easy to figure out how many white tiles remain.\\n\\n```python\\nfrom functools import cache\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def nums(i):\\n            if i == len(floor):\\n                return 0\\n            return (floor[i] == \\'1\\') + nums(i+1)\\n        @cache\\n        def dfs(i, n):\\n            if i >= len(floor):\\n                return 0\\n            if n == 0:\\n                return nums(i)\\n            if floor[i] == \\'0\\':\\n                return dfs(i+1, n)\\n            return min(1+dfs(i+1, n), dfs(i+carpetLen, n-1))\\n        return dfs(0, numCarpets)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```python\\nfrom functools import cache\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def nums(i):\\n            if i == len(floor):\\n                return 0\\n            return (floor[i] == \\'1\\') + nums(i+1)\\n        @cache\\n        def dfs(i, n):\\n            if i >= len(floor):\\n                return 0\\n            if n == 0:\\n                return nums(i)\\n            if floor[i] == \\'0\\':\\n                return dfs(i+1, n)\\n            return min(1+dfs(i+1, n), dfs(i+carpetLen, n-1))\\n        return dfs(0, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885527,
                "title": "python-c-dp-solution",
                "content": "Step1 :\\nCalcualte the number of white tiles can be cover if we put a carpet at each position\\nStep2:\\n\\tCalculte the maximum number of tiles can be covered at each postion for carpet count = 1\\n\\tCalculte the maximum number of tiles can be covered at each postion for carpet count = 2\\n\\t....\\n\\tCalculte the maximum number of tiles can be covered at each postion for carpet count = carpetLen\\nStep3:\\n\\tTotal while tiles minus maximum tiles can be convered is the final answer\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<int> dp(floor.size());\\n        vector<int> cover;\\n        int cnt = 0;\\n        for (int i = 0;i< floor.size();i++){\\n            if (floor[i] == \\'1\\'){\\n                cnt +=1;\\n            }\\n            if (i >= carpetLen && floor[i-carpetLen] == \\'1\\'){\\n                cnt -=1;\\n            }\\n            cover.push_back(cnt);\\n        }\\n        while (numCarpets){\\n            numCarpets--;\\n            vector<int> dp2;\\n            int max_cover = 0;\\n            for (int j = 0;j<floor.size();j++){\\n                if (j >= carpetLen){\\n                    max_cover = max(max_cover,dp[j-carpetLen]);\\n                }\\n                dp2.push_back(max_cover + cover[j]);\\n            }\\n            dp = dp2;\\n        }\\n        int res = 0;\\n        for (auto &c:floor){\\n            res += ( c ==\\'1\\');\\n        }\\n        res -= *max_element(dp.begin(),dp.end());\\n        return res;\\n    }\\n};\\n```\\n\\n\\nPython\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        white = sum(c == \\'1\\' for c in floor)\\n        #dp[i] -> the maximum white tiles can be covered at position i\\n        dp = [0]*len(floor)\\n        #cover[i] -> the number of tiles can be covered if put a carpet at position i\\n        cover = []\\n        cnt = 0\\n        #calculate cover[i] (prefix)\\n        for i in range(len(floor)):\\n            if floor[i] == \\'1\\':\\n                cnt += 1\\n            if i >= carpetLen and floor[i-carpetLen] == \\'1\\':\\n                cnt -= 1\\n            cover.append(cnt)\\n        for i in range(numCarpets):\\n            max_cover = 0\\n            dp2 = []\\n            for j in range(len(floor)):\\n                #since (j-carpetLen+1)th ~ (j)th tiles can be cover if a carpet is put a postion j , \\n                #we only need to find the maximum tiles can be cover before positon (j-carpetLen) at the last round\\n                if j >= carpetLen:\\n                    max_cover = max(max_cover,dp[j-carpetLen])\\n                dp2.append(cover[j] + max_cover)\\n            dp = dp2 \\n        return white - max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<int> dp(floor.size());\\n        vector<int> cover;\\n        int cnt = 0;\\n        for (int i = 0;i< floor.size();i++){\\n            if (floor[i] == \\'1\\'){\\n                cnt +=1;\\n            }\\n            if (i >= carpetLen && floor[i-carpetLen] == \\'1\\'){\\n                cnt -=1;\\n            }\\n            cover.push_back(cnt);\\n        }\\n        while (numCarpets){\\n            numCarpets--;\\n            vector<int> dp2;\\n            int max_cover = 0;\\n            for (int j = 0;j<floor.size();j++){\\n                if (j >= carpetLen){\\n                    max_cover = max(max_cover,dp[j-carpetLen]);\\n                }\\n                dp2.push_back(max_cover + cover[j]);\\n            }\\n            dp = dp2;\\n        }\\n        int res = 0;\\n        for (auto &c:floor){\\n            res += ( c ==\\'1\\');\\n        }\\n        res -= *max_element(dp.begin(),dp.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        white = sum(c == \\'1\\' for c in floor)\\n        #dp[i] -> the maximum white tiles can be covered at position i\\n        dp = [0]*len(floor)\\n        #cover[i] -> the number of tiles can be covered if put a carpet at position i\\n        cover = []\\n        cnt = 0\\n        #calculate cover[i] (prefix)\\n        for i in range(len(floor)):\\n            if floor[i] == \\'1\\':\\n                cnt += 1\\n            if i >= carpetLen and floor[i-carpetLen] == \\'1\\':\\n                cnt -= 1\\n            cover.append(cnt)\\n        for i in range(numCarpets):\\n            max_cover = 0\\n            dp2 = []\\n            for j in range(len(floor)):\\n                #since (j-carpetLen+1)th ~ (j)th tiles can be cover if a carpet is put a postion j , \\n                #we only need to find the maximum tiles can be cover before positon (j-carpetLen) at the last round\\n                if j >= carpetLen:\\n                    max_cover = max(max_cover,dp[j-carpetLen])\\n                dp2.append(cover[j] + max_cover)\\n            dp = dp2 \\n        return white - max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885460,
                "title": "why-my-swift-code-runs-out-as-tle",
                "content": "```swft\\nclass Solution {\\n  func minimumWhiteTiles(_ floor: String, _ numCarpets: Int, _ carpetLen: Int) -> Int {\\n    let arr = Array(floor)\\n    var memo: [String: Int] = [:]\\n    func aux(_ index: Int, _ remains: Int) -> Int {\\n      let key = \"\\\\(index)-\\\\(remains)\"\\n      if memo[key] != nil {\\n        return memo[key]!\\n      }\\n      if remains < 0 {\\n        return Int.max\\n      }\\n      if index >= floor.count || remains * carpetLen >= floor.count - index {\\n        return 0\\n      }\\n      if arr[index] == \"0\" {\\n        memo[key] = aux(index + 1, remains)\\n        return memo[key]!\\n      }\\n      memo[key] = min(\\n        aux(index + carpetLen, remains - 1),\\n        1 + aux(index + 1, remains)\\n      )\\n      return memo[key]!\\n    }\\n     return aux(0, numCarpets)\\n  }\\n}\\n```\\n\\nI chaned the code to JS and used the same solution, all test cases were passed.",
                "solutionTags": [],
                "code": "```swft\\nclass Solution {\\n  func minimumWhiteTiles(_ floor: String, _ numCarpets: Int, _ carpetLen: Int) -> Int {\\n    let arr = Array(floor)\\n    var memo: [String: Int] = [:]\\n    func aux(_ index: Int, _ remains: Int) -> Int {\\n      let key = \"\\\\(index)-\\\\(remains)\"\\n      if memo[key] != nil {\\n        return memo[key]!\\n      }\\n      if remains < 0 {\\n        return Int.max\\n      }\\n      if index >= floor.count || remains * carpetLen >= floor.count - index {\\n        return 0\\n      }\\n      if arr[index] == \"0\" {\\n        memo[key] = aux(index + 1, remains)\\n        return memo[key]!\\n      }\\n      memo[key] = min(\\n        aux(index + carpetLen, remains - 1),\\n        1 + aux(index + 1, remains)\\n      )\\n      return memo[key]!\\n    }\\n     return aux(0, numCarpets)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885216,
                "title": "python-top-down",
                "content": "n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for i in range(1, n + 1):\\n            for k in range(1, numCarpets+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[n][numCarpets]",
                "solutionTags": [],
                "code": "n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for i in range(1, n + 1):\\n            for k in range(1, numCarpets+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[n][numCarpets]",
                "codeTag": "Unknown"
            },
            {
                "id": 1877990,
                "title": "java-top-down-dynamic-programming-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    private String floor;\\n    private int[] presum;\\n    /**\\n    1. define state\\n    dp[i][k]\\n    max number of white floor covered starting at index i, with k carpets left\\n    \\n    2. state transition\\n    dp[i][k] = max(\\n                dp[j][k - 1] + coveredWhiteTiles from this used carpet, \\n                the used carpet covers index (j - 1 - carpetLen) to (j - 1), (j - 1 - carpetLen) >= i\\n                  )\\n                  \\n    3. base state\\n    k = 0: dp[i][0] = 0\\n    i >= n: dp[i][k] = 0\\n    \\n    */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        this.floor = floor;\\n        this.presum = new int[n];\\n        int whiteTiles = 0;\\n        for (int i = 0; i < floor.length(); i++) {\\n            char c = floor.charAt(i);\\n            if (c == \\'1\\') {\\n                whiteTiles++;\\n            }\\n            presum[i] = whiteTiles;\\n        }\\n        int maxCovered = dp(0, numCarpets, new int[n][numCarpets + 1], carpetLen);\\n        return whiteTiles - maxCovered;\\n    }\\n    \\n    private int dp(int index, int k, int[][] memo, int len) {\\n        int n = memo.length;\\n        if (index >= n || k <= 0) {\\n            return 0;\\n        }\\n        if (memo[index][k] > 0) {\\n            return memo[index][k];\\n        }\\n        int maxCovered = 0;\\n        for (int j = index; j < n; j++) {\\n            if (floor.charAt(j) == \\'1\\') {\\n                int right = Math.min(n, j + len);\\n                int coveredWhiteTiles = presum[right - 1] - (j - 1 >= 0 ? presum[j - 1] : 0);\\n                if (coveredWhiteTiles > maxCovered) {\\n                    maxCovered = coveredWhiteTiles;\\n                    memo[index][k] = Math.max(memo[index][k], \\n                                          coveredWhiteTiles + \\n                                          dp(right, k - 1, memo, len));\\n                }\\n            }\\n        }\\n        return memo[index][k];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private String floor;\\n    private int[] presum;\\n    /**\\n    1. define state\\n    dp[i][k]\\n    max number of white floor covered starting at index i, with k carpets left\\n    \\n    2. state transition\\n    dp[i][k] = max(\\n                dp[j][k - 1] + coveredWhiteTiles from this used carpet, \\n                the used carpet covers index (j - 1 - carpetLen) to (j - 1), (j - 1 - carpetLen) >= i\\n                  )\\n                  \\n    3. base state\\n    k = 0: dp[i][0] = 0\\n    i >= n: dp[i][k] = 0\\n    \\n    */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        this.floor = floor;\\n        this.presum = new int[n];\\n        int whiteTiles = 0;\\n        for (int i = 0; i < floor.length(); i++) {\\n            char c = floor.charAt(i);\\n            if (c == \\'1\\') {\\n                whiteTiles++;\\n            }\\n            presum[i] = whiteTiles;\\n        }\\n        int maxCovered = dp(0, numCarpets, new int[n][numCarpets + 1], carpetLen);\\n        return whiteTiles - maxCovered;\\n    }\\n    \\n    private int dp(int index, int k, int[][] memo, int len) {\\n        int n = memo.length;\\n        if (index >= n || k <= 0) {\\n            return 0;\\n        }\\n        if (memo[index][k] > 0) {\\n            return memo[index][k];\\n        }\\n        int maxCovered = 0;\\n        for (int j = index; j < n; j++) {\\n            if (floor.charAt(j) == \\'1\\') {\\n                int right = Math.min(n, j + len);\\n                int coveredWhiteTiles = presum[right - 1] - (j - 1 >= 0 ? presum[j - 1] : 0);\\n                if (coveredWhiteTiles > maxCovered) {\\n                    maxCovered = coveredWhiteTiles;\\n                    memo[index][k] = Math.max(memo[index][k], \\n                                          coveredWhiteTiles + \\n                                          dp(right, k - 1, memo, len));\\n                }\\n            }\\n        }\\n        return memo[index][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872004,
                "title": "c-simple-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int get(int i,int k,string &s,int l)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int res=s[i]-\\'0\\'+get(i+1,k,s,l);\\n        if(s[i]==\\'1\\' && k>0)\\n            res=min(res,get(i+l,k-1,s,l));\\n        return dp[i][k]=res;\\n    }\\n    int minimumWhiteTiles(string &s, int k, int l) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return get(0,k,s,l);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int get(int i,int k,string &s,int l)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int res=s[i]-\\'0\\'+get(i+1,k,s,l);\\n        if(s[i]==\\'1\\' && k>0)\\n            res=min(res,get(i+l,k-1,s,l));\\n        return dp[i][k]=res;\\n    }\\n    int minimumWhiteTiles(string &s, int k, int l) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return get(0,k,s,l);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871574,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nLet `M` be the amount of carpets we are given, each of length `K`.  Then we can use prefix sums `S` to count the amount of `\\'1\\'` within the window `A[i..i + K)`, ie. from `i` inclusive to `i + K` non-inclusive to simulate carpet placements in O(1) time.  Then we have 2 possibilites to consider for each `i`<sup>th</sup> index candidate carpet placement:\\n\\n1. \\u2705 include\\n2. \\uD83D\\uDEAB exclude\\n\\nThus, we try all possibilities, keeping track the `i`<sup>th</sup> index candidate carpet placement and how many carpets we `have` (initially `M`) to formulate the optimal solution as the recursive stack unwinds.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var j = Math.min(i + K, N)\\n            var include = S[i] - S[j] + go(j, have - 1)\\n            var exclude = go(i + 1, have)\\n            return Math.max(include, exclude)\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + go(j, have - 1)\\n                var exclude = go(i + 1, have)\\n                m[k] = Math.max(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var dp = Array(N + 1) { IntArray(M + 1) { 0 } }\\n        for (have in 1..M) {\\n            for (i in N - 1 downTo 0) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + dp[j][have - 1]\\n                var exclude = dp[i + 1][have]\\n                dp[i][have] = Math.max(include, exclude)\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet minimumWhiteTiles = (A, M, K) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let j = Math.min(i + K, N);\\n        let include = S[i] - S[j] + go(j, have - 1),\\n            exclude = go(i + 1, have);\\n        return Math.max(include, exclude);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + go(j, have - 1),\\n                exclude = go(i + 1, have);\\n            m.set(k, Math.max(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let dp = [...Array(N + 1)].map(_ => Array(M + 1).fill(0));\\n    for (let have = 1; have <= M; ++have) {\\n        for (let i = N - 1; 0 <= i; --i) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + dp[j][have - 1],\\n                exclude = dp[i + 1][have];\\n            dp[i][have] = Math.max(include, exclude);\\n        }\\n    }\\n    return S[0] - S[N] - dp[0][M];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        @cache\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\\n        for have in range(1, M + 1):\\n            for i in range(N - 1, -1, -1):\\n                j = min(i + K, N)\\n                include = S[i] - S[j] + dp[j][have - 1]\\n                exclude = dp[i + 1][have]\\n                dp[i][have] = max(include, exclude)\\n        return S[0] - S[N] - dp[0][M]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                let exclude = (go.f)(go, i + 1, have);\\n                return max(include, exclude);\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\n//\\n// TODO: question -- how do capture the mutable map m within a recursive closure?\\n//\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut m = HashMap::new();\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let k = format!(\"{},{}\", i, have);\\n                if !m.contains_key(&k) {\\n                    let j = min(i + K as usize, N);\\n                    let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                    let exclude = (go.f)(go, i + 1, have);\\n                    m.insert(&k, max(include, exclude));\\n                }\\n                return *m.get(&k).unwrap();\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut dp = vec![vec![0; M as usize + 1]; N + 1];\\n        for have in 1..=M as usize {\\n            for i in (0..N).rev() {\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + dp[j][have - 1];\\n                let exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M as usize];\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto j = min(i + K, N);\\n            auto include = S[i] - S[j] + go(j, have - 1),\\n                 exclude = go(i + 1, have);\\n            return max(include, exclude);\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumWhiteTiles(string A, int M, int K, Map m = {}) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        auto key = [](auto a, auto b) {\\n            stringstream ss; ss << a << \",\" << b;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + go(j, have - 1),\\n                     exclude = go(i + 1, have);\\n                m[k] = max(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        VVI dp(N + 1, VI(M + 1, 0));\\n        for (auto have{ 1 }; have <= M; ++have) {\\n            for (auto i{ N - 1 }; 0 <= i; --i) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + dp[j][have - 1],\\n                     exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var j = Math.min(i + K, N)\\n            var include = S[i] - S[j] + go(j, have - 1)\\n            var exclude = go(i + 1, have)\\n            return Math.max(include, exclude)\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + go(j, have - 1)\\n                var exclude = go(i + 1, have)\\n                m[k] = Math.max(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var dp = Array(N + 1) { IntArray(M + 1) { 0 } }\\n        for (have in 1..M) {\\n            for (i in N - 1 downTo 0) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + dp[j][have - 1]\\n                var exclude = dp[i + 1][have]\\n                dp[i][have] = Math.max(include, exclude)\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M]\\n    }\\n}\\n```\n```\\nlet minimumWhiteTiles = (A, M, K) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let j = Math.min(i + K, N);\\n        let include = S[i] - S[j] + go(j, have - 1),\\n            exclude = go(i + 1, have);\\n        return Math.max(include, exclude);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + go(j, have - 1),\\n                exclude = go(i + 1, have);\\n            m.set(k, Math.max(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let dp = [...Array(N + 1)].map(_ => Array(M + 1).fill(0));\\n    for (let have = 1; have <= M; ++have) {\\n        for (let i = N - 1; 0 <= i; --i) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + dp[j][have - 1],\\n                exclude = dp[i + 1][have];\\n            dp[i][have] = Math.max(include, exclude);\\n        }\\n    }\\n    return S[0] - S[N] - dp[0][M];\\n};\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        @cache\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\\n        for have in range(1, M + 1):\\n            for i in range(N - 1, -1, -1):\\n                j = min(i + K, N)\\n                include = S[i] - S[j] + dp[j][have - 1]\\n                exclude = dp[i + 1][have]\\n                dp[i][have] = max(include, exclude)\\n        return S[0] - S[N] - dp[0][M]\\n```\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                let exclude = (go.f)(go, i + 1, have);\\n                return max(include, exclude);\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\n```\\n//\\n// TODO: question -- how do capture the mutable map m within a recursive closure?\\n//\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut m = HashMap::new();\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let k = format!(\"{},{}\", i, have);\\n                if !m.contains_key(&k) {\\n                    let j = min(i + K as usize, N);\\n                    let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                    let exclude = (go.f)(go, i + 1, have);\\n                    m.insert(&k, max(include, exclude));\\n                }\\n                return *m.get(&k).unwrap();\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut dp = vec![vec![0; M as usize + 1]; N + 1];\\n        for have in 1..=M as usize {\\n            for i in (0..N).rev() {\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + dp[j][have - 1];\\n                let exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M as usize];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto j = min(i + K, N);\\n            auto include = S[i] - S[j] + go(j, have - 1),\\n                 exclude = go(i + 1, have);\\n            return max(include, exclude);\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumWhiteTiles(string A, int M, int K, Map m = {}) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        auto key = [](auto a, auto b) {\\n            stringstream ss; ss << a << \",\" << b;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + go(j, have - 1),\\n                     exclude = go(i + 1, have);\\n                m[k] = max(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        VVI dp(N + 1, VI(M + 1, 0));\\n        for (auto have{ 1 }; have <= M; ++have) {\\n            for (auto i{ N - 1 }; 0 <= i; --i) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + dp[j][have - 1],\\n                     exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870731,
                "title": "c-iterative-dp-knsapsack",
                "content": "```class Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int carpetlen) {\\n      //knapsack type problem\\n      int n = floor.length() ;\\n      int dp[n+1][num+1] ;\\n      memset(dp,0,sizeof(dp)) ;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n          for(int j=0;j<=num;j++)\\n          {\\n             if(j==0) dp[i][j] = (floor[i]==\\'1\\')?dp[i+1][j]+1:dp[i+1][j] ;\\n             else if(i+carpetlen >= n) dp[i][j] = 0 ;\\n             else{\\n                 if(floor[i]==\\'0\\'){\\n                     dp[i][j] = dp[i+1][j] ;\\n                 }\\n                 else{\\n                     dp[i][j] = min(1+dp[i+1][j],dp[i+carpetlen][j-1]) ;\\n                 }\\n             }\\n          }\\n      }\\n     return dp[0][num] ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int carpetlen) {\\n      //knapsack type problem\\n      int n = floor.length() ;\\n      int dp[n+1][num+1] ;\\n      memset(dp,0,sizeof(dp)) ;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n          for(int j=0;j<=num;j++)\\n          {\\n             if(j==0) dp[i][j] = (floor[i]==\\'1\\')?dp[i+1][j]+1:dp[i+1][j] ;\\n             else if(i+carpetlen >= n) dp[i][j] = 0 ;\\n             else{\\n                 if(floor[i]==\\'0\\'){\\n                     dp[i][j] = dp[i+1][j] ;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 1870132,
                "title": "dp-solution",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp=[[0 for i in range(numCarpets+1)] for j in range(len(floor)+1)]\\n\\n        for i in range(1,len(floor)+1):\\n            if floor[i-1]==\\'1\\':\\n                dp[i][0]=dp[i-1][0]+1\\n            else:\\n                dp[i][0]=dp[i-1][0]\\n\\n        for j in range(1,numCarpets+1):\\n            for i in range(1,len(floor)+1):\\n                dp[i][j]=min(dp[max(0,i-carpetLen)][j-1],dp[i-1][j]+(floor[i-1]==\\'1\\'))\\n        return dp[-1][numCarpets]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp=[[0 for i in range(numCarpets+1)] for j in range(len(floor)+1)]\\n\\n        for i in range(1,len(floor)+1):\\n            if floor[i-1]==\\'1\\':\\n                dp[i][0]=dp[i-1][0]+1\\n            else:\\n                dp[i][0]=dp[i-1][0]\\n\\n        for j in range(1,numCarpets+1):\\n            for i in range(1,len(floor)+1):\\n                dp[i][j]=min(dp[max(0,i-carpetLen)][j-1],dp[i-1][j]+(floor[i-1]==\\'1\\'))\\n        return dp[-1][numCarpets]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870008,
                "title": "top-down-dynamic-programming-knapsack-approach",
                "content": "Time Complexity : O(n*m) where m is num of carpets\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(string &str, int n, int pos, int carpetLen, vector<int> &cnt)\\n    {\\n        if(pos >= str.length())\\n            return 0;\\n        \\n        if(n == 0)\\n            return cnt[pos];\\n        \\n        \\n        if(dp[pos][n] != -1)\\n            return dp[pos][n];\\n        \\n        int op1 = 0, op2 = 0;\\n        \\n        while(str[pos] == \\'0\\')\\n            pos++;\\n        \\n        if(pos >= str.length())\\n        {\\n            return 0;\\n        }\\n        \\n        // if(str[pos] == \\'0\\')\\n        // {\\n        //     return dp[pos][n] = solve(str, n, pos + 1, carpetLen, cnt);\\n        // }\\n        \\n        if(str[pos] == \\'1\\')\\n        {\\n            op1 = solve(str, n - 1, pos + carpetLen, carpetLen, cnt); // place the carpet\\n            \\n            op2 = 1 + solve(str, n, pos + 1, carpetLen, cnt); // did not place the carpet, so the white tile is still visisble\\n        }\\n        \\n        //cout<<op1<<\" \"<<op2<<endl;\\n        return dp[pos][n] = min(op1, op2);\\n            \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        \\n        int sz = floor.length();\\n        \\n        vector<int> cnt(sz + 1, 0);\\n        \\n        cnt[sz - 1] = (floor[sz - 1] == \\'1\\') ? 1 : 0;\\n        \\n        for(int i = sz - 2; i >= 0; i--)\\n        {\\n            cnt[i] =  cnt[i + 1] + (floor[i] == \\'1\\'); \\n        }\\n        \\n        \\n        // for(int x : cnt)\\n        //     cout<<x<<\" \";\\n        \\n        //cout<<endl;\\n        \\n        dp.resize(sz + 1, vector<int>(numCarpets + 1, -1));\\n        \\n        return solve(floor, numCarpets, 0, carpetLen, cnt);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(string &str, int n, int pos, int carpetLen, vector<int> &cnt)\\n    {\\n        if(pos >= str.length())\\n            return 0;\\n        \\n        if(n == 0)\\n            return cnt[pos];\\n        \\n        \\n        if(dp[pos][n] != -1)\\n            return dp[pos][n];\\n        \\n        int op1 = 0, op2 = 0;\\n        \\n        while(str[pos] == \\'0\\')\\n            pos++;\\n        \\n        if(pos >= str.length())\\n        {\\n            return 0;\\n        }\\n        \\n        // if(str[pos] == \\'0\\')\\n        // {\\n        //     return dp[pos][n] = solve(str, n, pos + 1, carpetLen, cnt);\\n        // }\\n        \\n        if(str[pos] == \\'1\\')\\n        {\\n            op1 = solve(str, n - 1, pos + carpetLen, carpetLen, cnt); // place the carpet\\n            \\n            op2 = 1 + solve(str, n, pos + 1, carpetLen, cnt); // did not place the carpet, so the white tile is still visisble\\n        }\\n        \\n        //cout<<op1<<\" \"<<op2<<endl;\\n        return dp[pos][n] = min(op1, op2);\\n            \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        \\n        int sz = floor.length();\\n        \\n        vector<int> cnt(sz + 1, 0);\\n        \\n        cnt[sz - 1] = (floor[sz - 1] == \\'1\\') ? 1 : 0;\\n        \\n        for(int i = sz - 2; i >= 0; i--)\\n        {\\n            cnt[i] =  cnt[i + 1] + (floor[i] == \\'1\\'); \\n        }\\n        \\n        \\n        // for(int x : cnt)\\n        //     cout<<x<<\" \";\\n        \\n        //cout<<endl;\\n        \\n        dp.resize(sz + 1, vector<int>(numCarpets + 1, -1));\\n        \\n        return solve(floor, numCarpets, 0, carpetLen, cnt);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1869875,
                "title": "java-easy-to-understand-solution-dp-recursive-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int ded = 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        for(int i = 0; i < floor.length(); i++) {\\n            if(floor.charAt(i) == \\'1\\') ded++;\\n        }\\n        if(ded == floor.length()){\\n            return ded - numCarpets*carpetLen>=0?ded-numCarpets*carpetLen:0;\\n        }\\n        \\n        if(ded == 0){\\n            return 0;\\n        }\\n        \\n        return ded - helper(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n    \\n    private int helper(String floor, int numCarpets, int carpetLen, int start, int[][] dp){\\n        if(start >= floor.length() || numCarpets==0) return 0;\\n        \\n        if(dp[numCarpets][start]!=0) return dp[numCarpets][start];\\n        \\n        int take= calc(floor, start,  start + carpetLen);\\n        if(floor.charAt(start) == \\'1\\') {\\n            return dp[numCarpets][start] = Math.max((take + helper(floor, numCarpets-1, carpetLen, start+carpetLen, dp)),\\n                           helper(floor, numCarpets, carpetLen, start+1, dp));\\n        }else if(floor.charAt(start) == \\'0\\'){\\n            return dp[numCarpets][start] = helper(floor, numCarpets, carpetLen, start+1, dp);\\n        }\\n        return dp[numCarpets][start];\\n    }\\n    \\n    private int calc(String floor, int start, int end) {\\n        int answer = 0;\\n        for(int i = start; i < end && i < floor.length() ; i++) {\\n            if(floor.charAt(i) == \\'1\\') answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int ded = 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        for(int i = 0; i < floor.length(); i++) {\\n            if(floor.charAt(i) == \\'1\\') ded++;\\n        }\\n        if(ded == floor.length()){\\n            return ded - numCarpets*carpetLen>=0?ded-numCarpets*carpetLen:0;\\n        }\\n        \\n        if(ded == 0){\\n            return 0;\\n        }\\n        \\n        return ded - helper(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n    \\n    private int helper(String floor, int numCarpets, int carpetLen, int start, int[][] dp){\\n        if(start >= floor.length() || numCarpets==0) return 0;\\n        \\n        if(dp[numCarpets][start]!=0) return dp[numCarpets][start];\\n        \\n        int take= calc(floor, start,  start + carpetLen);\\n        if(floor.charAt(start) == \\'1\\') {\\n            return dp[numCarpets][start] = Math.max((take + helper(floor, numCarpets-1, carpetLen, start+carpetLen, dp)),\\n                           helper(floor, numCarpets, carpetLen, start+1, dp));\\n        }else if(floor.charAt(start) == \\'0\\'){\\n            return dp[numCarpets][start] = helper(floor, numCarpets, carpetLen, start+1, dp);\\n        }\\n        return dp[numCarpets][start];\\n    }\\n    \\n    private int calc(String floor, int start, int end) {\\n        int answer = 0;\\n        for(int i = start; i < end && i < floor.length() ; i++) {\\n            if(floor.charAt(i) == \\'1\\') answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869157,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        char [] arr = floor.toCharArray();\\n        int [] pre = new int[arr.length];\\n        pre[0] = (arr[0]==\\'1\\'?1:0);\\n        for(int i = 1;i<arr.length;i++){\\n            if(arr[i]==\\'1\\'){\\n                pre[i] = (pre[i-1]+1);\\n            }else{\\n                pre[i] = pre[i-1];\\n            }\\n        }\\n        int [][] dp = new int[pre.length+1][numCarpets+1];\\n        for(int [] row : dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return pre[pre.length-1]-solve(pre,0,numCarpets,carpetLen,dp);\\n    }\\n    private int solve(int [] pre,int idx,int num,int carpetLen,int[][] dp){\\n        if(idx>=pre.length){\\n            return 0;\\n        }\\n        if(num<=0){\\n            return 0;\\n        }\\n        if(dp[idx][num]!=-1){\\n            return dp[idx][num];\\n        }\\n        int end = (idx+carpetLen-1>=pre.length)?pre.length-1:(idx+carpetLen-1);\\n        // place carpet at idx.\\n        int best = getSum(pre,idx,end) + solve(pre,end+1,num-1,carpetLen,dp);\\n        //dont place carpet at idx.\\n        best = Math.max(solve(pre,idx+1,num,carpetLen,dp),best);\\n        \\n        return dp[idx][num]=best;\\n    }\\n    \\n    private int getSum(int [] pre,int start,int end){\\n        if(start>0){\\n            return pre[end] - pre[start-1];\\n        }\\n        return pre[end];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        char [] arr = floor.toCharArray();\\n        int [] pre = new int[arr.length];\\n        pre[0] = (arr[0]==\\'1\\'?1:0);\\n        for(int i = 1;i<arr.length;i++){\\n            if(arr[i]==\\'1\\'){\\n                pre[i] = (pre[i-1]+1);\\n            }else{\\n                pre[i] = pre[i-1];\\n            }\\n        }\\n        int [][] dp = new int[pre.length+1][numCarpets+1];\\n        for(int [] row : dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return pre[pre.length-1]-solve(pre,0,numCarpets,carpetLen,dp);\\n    }\\n    private int solve(int [] pre,int idx,int num,int carpetLen,int[][] dp){\\n        if(idx>=pre.length){\\n            return 0;\\n        }\\n        if(num<=0){\\n            return 0;\\n        }\\n        if(dp[idx][num]!=-1){\\n            return dp[idx][num];\\n        }\\n        int end = (idx+carpetLen-1>=pre.length)?pre.length-1:(idx+carpetLen-1);\\n        // place carpet at idx.\\n        int best = getSum(pre,idx,end) + solve(pre,end+1,num-1,carpetLen,dp);\\n        //dont place carpet at idx.\\n        best = Math.max(solve(pre,idx+1,num,carpetLen,dp),best);\\n        \\n        return dp[idx][num]=best;\\n    }\\n    \\n    private int getSum(int [] pre,int start,int end){\\n        if(start>0){\\n            return pre[end] - pre[start-1];\\n        }\\n        return pre[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867874,
                "title": "debug",
                "content": "I am doing anything wrong?\\n```\\nclass Solution {\\npublic:\\n    int cl;\\n    vector<vector<int>> mp;\\n    int hideTile(vector<int> &arr, int rem, int i, int w) {\\n        if (rem == 0) return w;\\n        if (i >= arr.size()) return w;\\n        if (w <= 0) return 0;\\n        \\n        if (mp[i][rem]!=0) {\\n            return mp[i][rem];\\n        }\\n        int ind = i+cl;\\n        if (ind >= arr.size()) {\\n            ind = arr.size()-1;\\n        }\\n        \\n        int ans = hideTile(arr, rem-1, i+cl, w-(arr[ind]-arr[i]));\\n        int skipCurr = hideTile(arr, rem, i+1, w);\\n        \\n        mp[i][rem] = min(ans, skipCurr);\\n        return mp[i][rem];\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<int> pf(floor.length()+1, 0);\\n        \\n        mp = vector<vector<int>> (1002, vector<int> (1002, 0));\\n        for (int i = 0; i < floor.length(); i++) {\\n            if (floor[i] == \\'1\\') {\\n                pf[i+1] += pf[i] + 1;\\n            } else {\\n                pf[i+1] = pf[i];\\n            }\\n        }\\n        cl = carpetLen;\\n        \\n        return hideTile(pf, numCarpets , 0, pf[floor.length()]);\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int cl;\\n    vector<vector<int>> mp;\\n    int hideTile(vector<int> &arr, int rem, int i, int w) {\\n        if (rem == 0) return w;\\n        if (i >= arr.size()) return w;\\n        if (w <= 0) return 0;\\n        \\n        if (mp[i][rem]!=0) {\\n            return mp[i][rem];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1867834,
                "title": "python-dp-solution-optimized",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\t# number of white tiles up in the first i tiles\\n        c_sums=[]\\n        cur=0\\n        for x in floor:\\n            cur+=int(x)\\n            c_sums.append(cur)\\n\\n        if carpetLen == 1:\\n            return max(0,c_sums[-1]-numCarpets)\\n\\t\\t\\n\\t\\t# the minimum number of white tiles still visible when using k tiles to cover the first i tiles \\n        @cache\\n        def dp(i,k):\\n\\t\\t\\t# no tiles left\\n            if  k <= 0:\\n                return c_sums[i-1]\\n\\t\\t\\t\\t\\n            # cover all white tiles\\n            if i <= k*carpetLen:\\n                return 0\\n\\t\\t\\t\\t\\n\\t\\t\\t# everytile is white\\n            if i == c_sums[i-1]:\\n                return i-k*carpetLen\\n\\t\\t\\t\\n\\t\\t\\t# either not cover the ith(last) tile or cover it \\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1)) \\n        \\n        return dp(len(floor),numCarpets)\\n```\\nNote: without writing special cases it gives TLE which is:\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dp(i,k):            \\n            if i<=k*carpetLen:\\n                return 0\\n\\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1) if k>0 else float(\"inf\")) \\n        \\n        return dp(len(floor),numCarpets)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\t# number of white tiles up in the first i tiles\\n        c_sums=[]\\n        cur=0\\n        for x in floor:\\n            cur+=int(x)\\n            c_sums.append(cur)\\n\\n        if carpetLen == 1:\\n            return max(0,c_sums[-1]-numCarpets)\\n\\t\\t\\n\\t\\t# the minimum number of white tiles still visible when using k tiles to cover the first i tiles \\n        @cache\\n        def dp(i,k):\\n\\t\\t\\t# no tiles left\\n            if  k <= 0:\\n                return c_sums[i-1]\\n\\t\\t\\t\\t\\n            # cover all white tiles\\n            if i <= k*carpetLen:\\n                return 0\\n\\t\\t\\t\\t\\n\\t\\t\\t# everytile is white\\n            if i == c_sums[i-1]:\\n                return i-k*carpetLen\\n\\t\\t\\t\\n\\t\\t\\t# either not cover the ith(last) tile or cover it \\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1)) \\n        \\n        return dp(len(floor),numCarpets)\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dp(i,k):            \\n            if i<=k*carpetLen:\\n                return 0\\n\\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1) if k>0 else float(\"inf\")) \\n        \\n        return dp(len(floor),numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867643,
                "title": "java-top-down-tle-then-optimized-to-bottom-up",
                "content": "I have top-down solution with memoization but TLE\\n\\nThe requirement is find minimum number of white after covered by carpets\\nIdea: Ahh, If we able to find maximum white we could cover by carpets then the rest of white are minimum\\nImplement: top-down approach TLE but they show us that programming depending on 2 parameter: number of floor and number of carpet so far\\nBottom-up: call dp[i][k] is maximum white we could cover at first ith floor(include ith floor) with k carpet.\\ndp[floor.length()][numOfCarpet] is our solution, but final solution is maxWhite - dp[floor.length()][numOfCarpet]\\n\\n```\\n\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int countWhite = 0;\\n        char[] floorArr = floor.toCharArray();\\n        for(char c : floorArr) {\\n            if (c == \\'1\\') countWhite++;\\n        }\\n        \\n        int numOfWhiteSoFar = 0;\\n        int[] rangeWhite = new int[floorArr.length];\\n        for(int i = 0; i < floorArr.length; i++) {\\n            if (floorArr[i] == \\'1\\') numOfWhiteSoFar++;\\n            rangeWhite[i] = numOfWhiteSoFar;\\n        }\\n        \\n        Integer[][] cache = new Integer[numCarpets + 1][floorArr.length + 1];\\n        int max= maximumWhiteTiles(floorArr, numCarpets, carpetLen, 0, cache, rangeWhite);\\n        return countWhite - max;\\n    }\\n    \\n    private int maximumWhiteTiles(char[] floorArr, int numCarpets, int carpetLen, int start\\n                                 , Integer[][] cache, int[] rangeWhite) {\\n        \\n        // start from a index what is maximum white tiles you could cover;\\n        if (numCarpets == 0) return 0;\\n        if (start >= floorArr.length) return 0;\\n        \\n        if (cache[numCarpets][start] != null) return cache[numCarpets][start];\\n        int max = 0;\\n        for(int i = start; i < floorArr.length; i++) {\\n            int end = floorArr.length - 1 <= i + carpetLen - 1 ? floorArr.length - 1 : i + carpetLen - 1;\\n            int rangeWhileFromIToEnd = rangeWhite[end] - (i - 1 >= 0 ? rangeWhite[i - 1] : 0);\\n            int val = rangeWhileFromIToEnd + maximumWhiteTiles(floorArr, numCarpets - 1, carpetLen, i + carpetLen, cache, rangeWhite);\\n            max = Math.max(max, val);\\n        }\\n        \\n        cache[numCarpets][start] = max;\\n        return max;\\n        \\n    }\\n    \\n}\\n```\\n\\nThen I have optimized to bottom-up\\n```\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n           int numOfWhite = 0;\\n           int[] prefix = new int[floor.length()];\\n           for(int i = 0; i < floor.length(); i++) {\\n               if (floor.charAt(i) == \\'1\\') {\\n                   numOfWhite++;\\n               }\\n               prefix[i] = numOfWhite;\\n           }\\n           \\n           int[][] dp = new int[floor.length() + 1][numCarpets + 1];\\n           for(int i = 1; i <= floor.length(); i++) { /// number of floor \\n               for(int j = 1; j <= numCarpets; j++) {\\n                   dp[i][j] = (i - carpetLen >= 0 ? dp[i - carpetLen][j - 1] : 0) + \\n                       prefix[i - 1] - (i - 1 - carpetLen >= 0 ? prefix[i - 1 - carpetLen] : 0);\\n                   dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\\n               }\\n           }\\n           \\n           return numOfWhite - dp[floor.length()][numCarpets];\\n       }\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int countWhite = 0;\\n        char[] floorArr = floor.toCharArray();\\n        for(char c : floorArr) {\\n            if (c == \\'1\\') countWhite++;\\n        }\\n        \\n        int numOfWhiteSoFar = 0;\\n        int[] rangeWhite = new int[floorArr.length];\\n        for(int i = 0; i < floorArr.length; i++) {\\n            if (floorArr[i] == \\'1\\') numOfWhiteSoFar++;\\n            rangeWhite[i] = numOfWhiteSoFar;\\n        }\\n        \\n        Integer[][] cache = new Integer[numCarpets + 1][floorArr.length + 1];\\n        int max= maximumWhiteTiles(floorArr, numCarpets, carpetLen, 0, cache, rangeWhite);\\n        return countWhite - max;\\n    }\\n    \\n    private int maximumWhiteTiles(char[] floorArr, int numCarpets, int carpetLen, int start\\n                                 , Integer[][] cache, int[] rangeWhite) {\\n        \\n        // start from a index what is maximum white tiles you could cover;\\n        if (numCarpets == 0) return 0;\\n        if (start >= floorArr.length) return 0;\\n        \\n        if (cache[numCarpets][start] != null) return cache[numCarpets][start];\\n        int max = 0;\\n        for(int i = start; i < floorArr.length; i++) {\\n            int end = floorArr.length - 1 <= i + carpetLen - 1 ? floorArr.length - 1 : i + carpetLen - 1;\\n            int rangeWhileFromIToEnd = rangeWhite[end] - (i - 1 >= 0 ? rangeWhite[i - 1] : 0);\\n            int val = rangeWhileFromIToEnd + maximumWhiteTiles(floorArr, numCarpets - 1, carpetLen, i + carpetLen, cache, rangeWhite);\\n            max = Math.max(max, val);\\n        }\\n        \\n        cache[numCarpets][start] = max;\\n        return max;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867595,
                "title": "c-simple-easy-explanation-with-code-easy-to-understand",
                "content": "The most basic intuition we can get after seeing the problem is that , **for every index i ( 0 <= i < n )** in the array there are **2 possibilites** - \\n\\n**1. You put a carpet** \\n\\n    So if you decide to put carpet on ith block , then you don\\'t have to worry about the indices i , i + 1 , i + 2 ... i + len - 1. (len -> is carpet length)\\n\\t\\n   This will cost you one carpet and now you have to do the same thing from index **i + len** with **numCarpet - 1** .\\n   \\n2. **You do not put a carpet**\\n      \\n\\tNow , if the ith tile is white this will increase the **white tile count by 1**.\\n\\tAnd now you have to do the same thing from index **i + 1** with **numCarpet**.\\n\\t\\n**Your answer will be the minimum of 2 cases.**\\n\\n**Code - **\\n\\n...\\nint dp[1001][1001] ; \\n\\n  int fun(string &s , int &k , int c , int i) { \\n\\n  \\t     int n = s.length() ; \\n\\n  \\t     if (c == 0) {\\n               \\n              int x = 0 ; \\n  \\t     \\t    for (int j = i ; j < n ; j ++ ) {\\n\\n  \\t     \\t    \\t     if (s[j] == \\'1\\') x ++; \\n  \\t     \\t    }\\n\\n  \\t     \\t    return x ; \\n  \\t     }\\n\\n  \\t     if ((n - i) <= k || i >= n ) return 0 ;  \\n\\n  \\t     if (dp[c][i] != -1 ) return dp[c][i] ; \\n\\n  \\t     int q1 = fun(s , k , c - 1 , i + k) ; \\n  \\t     int q2 = ((s[i] == \\'1\\') ? 1 : 0) + fun(s , k , c , i + 1) ;\\n\\n  \\t     return dp[c][i] = min(q1,q2) ; \\n  }\\n \\n  int minimumWhiteTiles(string s, int c, int k) {\\n\\n         memset(dp , -1 , sizeof(dp)) ; \\n         return fun(s , k , c , 0); \\n    }\\n\\t...",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "The most basic intuition we can get after seeing the problem is that , **for every index i ( 0 <= i < n )** in the array there are **2 possibilites** - \\n\\n**1. You put a carpet** \\n\\n    So if you decide to put carpet on ith block , then you don\\'t have to worry about the indices i , i + 1 , i + 2 ... i + len - 1. (len -> is carpet length)\\n\\t\\n   This will cost you one carpet and now you have to do the same thing from index **i + len** with **numCarpet - 1** .\\n   \\n2. **You do not put a carpet**\\n      \\n\\tNow , if the ith tile is white this will increase the **white tile count by 1**.\\n\\tAnd now you have to do the same thing from index **i + 1** with **numCarpet**.\\n\\t\\n**Your answer will be the minimum of 2 cases.**\\n\\n**Code - **\\n\\n...\\nint dp[1001][1001] ; \\n\\n  int fun(string &s , int &k , int c , int i) { \\n\\n  \\t     int n = s.length() ; \\n\\n  \\t     if (c == 0) {\\n               \\n              int x = 0 ; \\n  \\t     \\t    for (int j = i ; j < n ; j ++ ) {\\n\\n  \\t     \\t    \\t     if (s[j] == \\'1\\') x ++; \\n  \\t     \\t    }\\n\\n  \\t     \\t    return x ; \\n  \\t     }\\n\\n  \\t     if ((n - i) <= k || i >= n ) return 0 ;  \\n\\n  \\t     if (dp[c][i] != -1 ) return dp[c][i] ; \\n\\n  \\t     int q1 = fun(s , k , c - 1 , i + k) ; \\n  \\t     int q2 = ((s[i] == \\'1\\') ? 1 : 0) + fun(s , k , c , i + 1) ;\\n\\n  \\t     return dp[c][i] = min(q1,q2) ; \\n  }\\n \\n  int minimumWhiteTiles(string s, int c, int k) {\\n\\n         memset(dp , -1 , sizeof(dp)) ; \\n         return fun(s , k , c , 0); \\n    }\\n\\t...",
                "codeTag": "Unknown"
            },
            {
                "id": 1867528,
                "title": "python-straight-forward-dp-solution-with-explanations",
                "content": "We can divide the problem into sub problems - where each sub problem is \\n**\"How many white tiles do you leave uncovered at most with n carpets starting from tile i\"**\\n\\nwe can use the array `dp[tile][carpets]` to store the results \\n\\nGiven the floor 10110101 with 2 carpets of length 2 we can start from the back (tile 7).\\n\\n0  1  2  3  4  5  6  7\\n[ ][#][ ][  ][#][ ][#][ ]  \\n\\nWith 0 carpets we would leave tile 7 uncovered => 1 white tile\\nWith 1 or 2 carpets we would cover tile 7 => 0 white tiles\\n\\nMoving backwards we can then find the minimum number of white tiles uncovered which is\\n\\n1. If the number of carpets * their length cover the whole rest of the floor - we leave 0 tiles uncovered\\n2. We have the choice of\\n\\ta. covering the current tile - then our answer is min tiles for the floor a carpets length away covered by carpet - 1 carpets **or**\\n\\tb. don\\'t cover the current tile - then our answer is the min tile for starting at the next tile with the same number of carpets + 1 if our tile is white (as this is now uncovered)\\n\\t\\nAt the end - the answer is dp[tile=0][carpets=numCarpets]\\n\\n```python\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp= [[0 for _ in range(numCarpets + 1)] for _ in range(n)]\\n\\n        dp[n - 1][0] = int(floor[-1])\\n\\n        for tile in range(n - 2, -1, -1):\\n            for carpets in range(numCarpets, -1, -1):\\n                if carpets == 0:\\n                    dp[tile][0] = dp[tile + 1][0] + int(floor[tile])\\n                elif tile + (carpets * carpetLen) >= n:\\n                    continue   # number is 0 by default\\n                else:\\n                    dp[tile][carpets] = min(dp[tile + carpetLen][carpets - 1], int(floor[tile]) + dp[tile + 1][carpets])\\n\\n        return dp[0][numCarpets]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp= [[0 for _ in range(numCarpets + 1)] for _ in range(n)]\\n\\n        dp[n - 1][0] = int(floor[-1])\\n\\n        for tile in range(n - 2, -1, -1):\\n            for carpets in range(numCarpets, -1, -1):\\n                if carpets == 0:\\n                    dp[tile][0] = dp[tile + 1][0] + int(floor[tile])\\n                elif tile + (carpets * carpetLen) >= n:\\n                    continue   # number is 0 by default\\n                else:\\n                    dp[tile][carpets] = min(dp[tile + carpetLen][carpets - 1], int(floor[tile]) + dp[tile + 1][carpets])\\n\\n        return dp[0][numCarpets]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1867148,
                "title": "fast-dp-considering-special-test-cases-and-pruning-some-branches",
                "content": "There are shorter implementations, but in order to improve the efficiency, we\\'d better consider treatments for special test cases and pruning some branches.\\n# DP with recursion\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        @lru_cache(None)\\n        def dp(start, n) -> int:\\n            \"\"\" start of index, number of remaining carpets \"\"\"\\n            if n * carpetLen >= len(floor) - start:  # enough to cover all in this region\\n                return ps[start-1]\\n\\n            if n == 0:  # no tile is used\\n                return ps[-2]\\n\\n            k = min(start + carpetLen, len(floor))\\n            return min(dp(start+1, n), dp(k, n-1)-ps[k-1]+ps[start-1])\\n\\n        return dp(0, numCarpets)\\n```\\n\\n# DP with array\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        dp = [[ps[-2]] * (1+len(floor)) for _ in range(numCarpets+1)]  # row[len(floor)] means using no carpets\\n\\n        for n in range(1, numCarpets+1):                               # start with 1 carpet\\n            row = dp[n]\\n            for i in range(len(floor)-1, -1, -1):                      # place another carpet at \"i\"\\n                k = min(i+carpetLen, len(floor))                       # the first position that \"i\" does not cover\\n                row[i] = min(dp[n][i+1], dp[n-1][k]-ps[k-1]+ps[i-1])\\n        return dp[numCarpets][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        @lru_cache(None)\\n        def dp(start, n) -> int:\\n            \"\"\" start of index, number of remaining carpets \"\"\"\\n            if n * carpetLen >= len(floor) - start:  # enough to cover all in this region\\n                return ps[start-1]\\n\\n            if n == 0:  # no tile is used\\n                return ps[-2]\\n\\n            k = min(start + carpetLen, len(floor))\\n            return min(dp(start+1, n), dp(k, n-1)-ps[k-1]+ps[start-1])\\n\\n        return dp(0, numCarpets)\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        dp = [[ps[-2]] * (1+len(floor)) for _ in range(numCarpets+1)]  # row[len(floor)] means using no carpets\\n\\n        for n in range(1, numCarpets+1):                               # start with 1 carpet\\n            row = dp[n]\\n            for i in range(len(floor)-1, -1, -1):                      # place another carpet at \"i\"\\n                k = min(i+carpetLen, len(floor))                       # the first position that \"i\" does not cover\\n                row[i] = min(dp[n][i+1], dp[n-1][k]-ps[k-1]+ps[i-1])\\n        return dp[numCarpets][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866920,
                "title": "c-o-n2",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n    int fun(int l,int num,string &s,int &ln){\\n        \\n        while(l<s.length() and s[l]==\\'0\\') l++;\\n        \\n        if(l>=s.length()) return 0;\\n        if(dp[l][num]!=-1) return dp[l][num];\\n        int ans=INT_MAX;\\n        if(num>0) ans=min(ans,fun(l+ln,num-1,s,ln));\\n        ans=min(ans,fun(l+1,num,s,ln)+1);\\n        \\n        return dp[l][num]=ans;\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length()+1,vector<int>(numCarpets+1,-1));\\n        return fun(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n    int fun(int l,int num,string &s,int &ln){\\n        \\n        while(l<s.length() and s[l]==\\'0\\') l++;\\n        \\n        if(l>=s.length()) return 0;\\n        if(dp[l][num]!=-1) return dp[l][num];\\n        int ans=INT_MAX;\\n        if(num>0) ans=min(ans,fun(l+ln,num-1,s,ln));\\n        ans=min(ans,fun(l+1,num,s,ln)+1);\\n        \\n        return dp[l][num]=ans;\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length()+1,vector<int>(numCarpets+1,-1));\\n        return fun(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866555,
                "title": "java-dp-memoization",
                "content": "1. Do Binary Search and store indices of whites tiles.\\n2. We can use DP here now where:\\ndp(floorLength, numCarpets) = max(dp(floorLength - carpetLen, numCarpets - 1) + numOfWhiteTilesInRange(floorLength - carpetLen, floorLength), dp(floorLength - carpetLen, numCarpets - 1)) -> number of white tiles covered from index 0 to floorLength using numCarpets number of carpets.\\n3. Base Conditions:\\nif (floorLength < 0 || numCarpets <= 0) return 0;\\n4. ans = whiteTiles.size() - dp(floorLength, numCarpets)\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int floorLength = floor.length();\\n        List<Integer> whiteTiles = new ArrayList<>();\\n        for (int tile = 0; tile < floorLength; tile += 1) {\\n            if (floor.charAt(tile) == \\'1\\') {\\n                whiteTiles.add(tile);\\n            }\\n        }\\n        Integer[][] dp = new Integer[floorLength][numCarpets + 1];\\n        System.out.println(minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles) + \"-\" + whiteTiles.size());\\n        return whiteTiles.size() - minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles);\\n    }\\n    \\n    private int minimumWhiteTiles(int floorLength, int numCarpets, int carpetLen, Integer[][] dp, List<Integer> whiteTiles) {\\n        if (floorLength < 0 || numCarpets <= 0) {\\n            return 0;\\n        }\\n        if (dp[floorLength][numCarpets] != null) {\\n            return dp[floorLength][numCarpets];\\n        }\\n        return dp[floorLength][numCarpets] = Math.max(minimumWhiteTiles(floorLength - carpetLen, numCarpets - 1, carpetLen, dp, whiteTiles) + numOfWhiteTilesInRange(floorLength - carpetLen, floorLength, whiteTiles), minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles));\\n    }\\n    \\n    private int numOfWhiteTilesInRange(int start, int end, List<Integer> whiteTiles) {\\n        int maxIndex = ceil(end, whiteTiles);\\n        int minIndex = ceil(start, whiteTiles);\\n        return maxIndex - minIndex;\\n    }\\n    \\n    int ceil(int idx, List<Integer> whiteTiles) {\\n        int ans = -1;\\n        int start = 0;\\n        int end = whiteTiles.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(whiteTiles.get(mid) <= idx) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int floorLength = floor.length();\\n        List<Integer> whiteTiles = new ArrayList<>();\\n        for (int tile = 0; tile < floorLength; tile += 1) {\\n            if (floor.charAt(tile) == \\'1\\') {\\n                whiteTiles.add(tile);\\n            }\\n        }\\n        Integer[][] dp = new Integer[floorLength][numCarpets + 1];\\n        System.out.println(minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles) + \"-\" + whiteTiles.size());\\n        return whiteTiles.size() - minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles);\\n    }\\n    \\n    private int minimumWhiteTiles(int floorLength, int numCarpets, int carpetLen, Integer[][] dp, List<Integer> whiteTiles) {\\n        if (floorLength < 0 || numCarpets <= 0) {\\n            return 0;\\n        }\\n        if (dp[floorLength][numCarpets] != null) {\\n            return dp[floorLength][numCarpets];\\n        }\\n        return dp[floorLength][numCarpets] = Math.max(minimumWhiteTiles(floorLength - carpetLen, numCarpets - 1, carpetLen, dp, whiteTiles) + numOfWhiteTilesInRange(floorLength - carpetLen, floorLength, whiteTiles), minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles));\\n    }\\n    \\n    private int numOfWhiteTilesInRange(int start, int end, List<Integer> whiteTiles) {\\n        int maxIndex = ceil(end, whiteTiles);\\n        int minIndex = ceil(start, whiteTiles);\\n        return maxIndex - minIndex;\\n    }\\n    \\n    int ceil(int idx, List<Integer> whiteTiles) {\\n        int ans = -1;\\n        int start = 0;\\n        int end = whiteTiles.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(whiteTiles.get(mid) <= idx) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866430,
                "title": "c-dp-pick-nonpick-technique",
                "content": "* Solve function will return the maximum number of white tiles that can be covered with carpets \\n* Therefore , Minimum Visible white tiles = Total white tiles - Value returned by Solve function\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    //returns the max number of white tiles that can be covered\\n    int solve(string &floor , int i , int carpets ,int len,vector<int>&suff ){\\n        if(i >= floor.size() || !carpets ) return 0 ;\\n        if(dp[i][carpets] != -1) return dp[i][carpets] ;\\n        \\n\\t\\t//at every index i we have two options -> lay the carpet(if tile is white) , or dont lay and move ahead\\n        int Laid = 0 , notLaid = 0 , covered = 0 ;\\n        //if the current tile is white only then lay the carpet\\n        if(floor[i] == \\'1\\'){\\n          covered = (i+len-1 >= floor.size() ? suff[suff.size()-1] : suff[i+len-1]) - (i-1>=0 ? suff[i-1] : 0 ) ;\\n          Laid = covered + solve(floor,i+len,carpets-1,len,suff) ;  \\n        } \\n        notLaid = solve(floor,i+1,carpets,len,suff) ;\\n        return dp[i][carpets] = max(Laid,notLaid) ;\\n    }\\n    int minimumWhiteTiles(string &floor, int carpets, int len ) {\\n\\n        vector<int>suff(floor.size(),0) ;\\n        //make suffix array  for O(1) access to number of white tiles between given range \\n        for(int i = 0 ; i < floor.size() ; ++i ){\\n            if(floor[i] == \\'1\\') ++suff[i];\\n            if(i!=0) suff[i] += suff[i-1] ;\\n        }\\n        \\n        memset(dp,-1,sizeof(dp)) ;\\n        return suff[suff.size()-1] - solve(floor,0,carpets,len,suff) ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    //returns the max number of white tiles that can be covered\\n    int solve(string &floor , int i , int carpets ,int len,vector<int>&suff ){\\n        if(i >= floor.size() || !carpets ) return 0 ;\\n        if(dp[i][carpets] != -1) return dp[i][carpets] ;\\n        \\n\\t\\t//at every index i we have two options -> lay the carpet(if tile is white) , or dont lay and move ahead\\n        int Laid = 0 , notLaid = 0 , covered = 0 ;\\n        //if the current tile is white only then lay the carpet\\n        if(floor[i] == \\'1\\'){\\n          covered = (i+len-1 >= floor.size() ? suff[suff.size()-1] : suff[i+len-1]) - (i-1>=0 ? suff[i-1] : 0 ) ;\\n          Laid = covered + solve(floor,i+len,carpets-1,len,suff) ;  \\n        } \\n        notLaid = solve(floor,i+1,carpets,len,suff) ;\\n        return dp[i][carpets] = max(Laid,notLaid) ;\\n    }\\n    int minimumWhiteTiles(string &floor, int carpets, int len ) {\\n\\n        vector<int>suff(floor.size(),0) ;\\n        //make suffix array  for O(1) access to number of white tiles between given range \\n        for(int i = 0 ; i < floor.size() ; ++i ){\\n            if(floor[i] == \\'1\\') ++suff[i];\\n            if(i!=0) suff[i] += suff[i-1] ;\\n        }\\n        \\n        memset(dp,-1,sizeof(dp)) ;\\n        return suff[suff.size()-1] - solve(floor,0,carpets,len,suff) ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866262,
                "title": "c-memoization-o-length-numberofcarpets",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(string &floor,int i,int n,int k,int nc,int cl,vector<vector<int>>&memo){\\n        \\n        if(i>=n)return 0;\\n        int ans1=INT_MAX;\\n        int ans2=INT_MAX;\\n        if(memo[i][k]!=-1)return memo[i][k];\\n     \\n        if(k<nc){\\n           \\n            ans1=helper(floor,i+cl,n,k+1,nc,cl,memo);\\n        }\\n       \\n        ans2=helper(floor,i+1,n,k,nc,cl,memo)+floor[i]-\\'0\\';\\n        \\n        return memo[i][k]=min(ans1,ans2);\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>memo(floor.size(),vector<int>(numCarpets+1,-1));\\n        return helper(floor,0,floor.size(),0,numCarpets,carpetLen,memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string &floor,int i,int n,int k,int nc,int cl,vector<vector<int>>&memo){\\n        \\n        if(i>=n)return 0;\\n        int ans1=INT_MAX;\\n        int ans2=INT_MAX;\\n        if(memo[i][k]!=-1)return memo[i][k];\\n     \\n        if(k<nc){\\n           \\n            ans1=helper(floor,i+cl,n,k+1,nc,cl,memo);\\n        }\\n       \\n        ans2=helper(floor,i+1,n,k,nc,cl,memo)+floor[i]-\\'0\\';\\n        \\n        return memo[i][k]=min(ans1,ans2);\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>memo(floor.size(),vector<int>(numCarpets+1,-1));\\n        return helper(floor,0,floor.size(),0,numCarpets,carpetLen,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866143,
                "title": "simple-c-dp-memoization-top-down-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int answer(string& nums , int black , int& len , int index){\\n        if(index >= nums.size())return 0;\\n        \\n        if(dp[index][black] != -1)return dp[index][black];\\n        \\n        int a = 3000 , b = 3000;\\n        \\n        if(black > 0){\\n            a = answer(nums , black - 1 , len , index + len);\\n        }\\n        b = answer(nums , black , len , index + 1);\\n        b += (nums[index] == \\'1\\');\\n        \\n        return dp[index][black] = min(a , b);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        memset(dp , -1 , sizeof(dp));\\n        return answer(floor , numCarpets , carpetLen , 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int answer(string& nums , int black , int& len , int index){\\n        if(index >= nums.size())return 0;\\n        \\n        if(dp[index][black] != -1)return dp[index][black];\\n        \\n        int a = 3000 , b = 3000;\\n        \\n        if(black > 0){\\n            a = answer(nums , black - 1 , len , index + len);\\n        }\\n        b = answer(nums , black , len , index + 1);\\n        b += (nums[index] == \\'1\\');\\n        \\n        return dp[index][black] = min(a , b);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        memset(dp , -1 , sizeof(dp));\\n        return answer(floor , numCarpets , carpetLen , 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576522,
                "content": [
                    {
                        "username": "larachicharo",
                        "content": "I was trying a greedy solution where you cover the max number of whites for every new carpet. You do this iteratively one carpet at a time. I got a Wrong Anwser, not a TLE. I can\\'t find a counter example that breaks this solution. Please help me find one.\\n\\nThanks."
                    },
                    {
                        "username": "joefreedman24",
                        "content": "Counter example set up:\\nfloor = 10111101\\nlength = 4\\nrugs = 2\\n\\nGreedy round 1: Take the rug placement that covers 4 white tiles\\nresulting floor = 10000001\\nrugs left = 1\\n\\nYou can now only cover one of the two remaining white tiles with your last rug.\\nThis leaves one white tile exposed no matter what.\\n\\nAlternatively, an ideal solution would place one rug at indices 0-3 and the other on indices 4-7.\\nThese placements only cover three each but result in a full covering of all white tiles."
                    },
                    {
                        "username": "prince3244",
                        "content": "2699/2706 test cases passed. I wanna know those 7 test cases really bad. Is there any way?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I tried doing it with recursion , but got MLE :((. \n\nEDIT: Solved it using recursion + memoization , initially i was taking a 3D dp array but solved it using 2D dp array only , you also try."
                    }
                ]
            },
            {
                "id": 1981361,
                "content": [
                    {
                        "username": "larachicharo",
                        "content": "I was trying a greedy solution where you cover the max number of whites for every new carpet. You do this iteratively one carpet at a time. I got a Wrong Anwser, not a TLE. I can\\'t find a counter example that breaks this solution. Please help me find one.\\n\\nThanks."
                    },
                    {
                        "username": "joefreedman24",
                        "content": "Counter example set up:\\nfloor = 10111101\\nlength = 4\\nrugs = 2\\n\\nGreedy round 1: Take the rug placement that covers 4 white tiles\\nresulting floor = 10000001\\nrugs left = 1\\n\\nYou can now only cover one of the two remaining white tiles with your last rug.\\nThis leaves one white tile exposed no matter what.\\n\\nAlternatively, an ideal solution would place one rug at indices 0-3 and the other on indices 4-7.\\nThese placements only cover three each but result in a full covering of all white tiles."
                    },
                    {
                        "username": "prince3244",
                        "content": "2699/2706 test cases passed. I wanna know those 7 test cases really bad. Is there any way?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I tried doing it with recursion , but got MLE :((. \n\nEDIT: Solved it using recursion + memoization , initially i was taking a 3D dp array but solved it using 2D dp array only , you also try."
                    }
                ]
            },
            {
                "id": 1968246,
                "content": [
                    {
                        "username": "larachicharo",
                        "content": "I was trying a greedy solution where you cover the max number of whites for every new carpet. You do this iteratively one carpet at a time. I got a Wrong Anwser, not a TLE. I can\\'t find a counter example that breaks this solution. Please help me find one.\\n\\nThanks."
                    },
                    {
                        "username": "joefreedman24",
                        "content": "Counter example set up:\\nfloor = 10111101\\nlength = 4\\nrugs = 2\\n\\nGreedy round 1: Take the rug placement that covers 4 white tiles\\nresulting floor = 10000001\\nrugs left = 1\\n\\nYou can now only cover one of the two remaining white tiles with your last rug.\\nThis leaves one white tile exposed no matter what.\\n\\nAlternatively, an ideal solution would place one rug at indices 0-3 and the other on indices 4-7.\\nThese placements only cover three each but result in a full covering of all white tiles."
                    },
                    {
                        "username": "prince3244",
                        "content": "2699/2706 test cases passed. I wanna know those 7 test cases really bad. Is there any way?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I tried doing it with recursion , but got MLE :((. \n\nEDIT: Solved it using recursion + memoization , initially i was taking a 3D dp array but solved it using 2D dp array only , you also try."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Sum Score of Array",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1998980,
                "content": [
                    {
                        "username": "mxquint",
                        "content": "This should be classified as an Easy problem. The complexity is not enough to be considered a medium difficulty problem."
                    },
                    {
                        "username": "vishnuvt",
                        "content": "Exactly"
                    },
                    {
                        "username": "Saurav_NITH",
                        "content": "This needs to be classified as Easy problem. "
                    }
                ]
            },
            {
                "id": 1915791,
                "content": [
                    {
                        "username": "mxquint",
                        "content": "This should be classified as an Easy problem. The complexity is not enough to be considered a medium difficulty problem."
                    },
                    {
                        "username": "vishnuvt",
                        "content": "Exactly"
                    },
                    {
                        "username": "Saurav_NITH",
                        "content": "This needs to be classified as Easy problem. "
                    }
                ]
            },
            {
                "id": 1813850,
                "content": [
                    {
                        "username": "mxquint",
                        "content": "This should be classified as an Easy problem. The complexity is not enough to be considered a medium difficulty problem."
                    },
                    {
                        "username": "vishnuvt",
                        "content": "Exactly"
                    },
                    {
                        "username": "Saurav_NITH",
                        "content": "This needs to be classified as Easy problem. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if an Array Is Consecutive",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Find Closest Number to Zero",
        "question_content": "<p>Given an integer array <code>nums</code> of size <code>n</code>, return <em>the number with the value <strong>closest</strong> to </em><code>0</code><em> in </em><code>nums</code>. If there are multiple answers, return <em>the number with the <strong>largest</strong> value</em>.</p>\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-4,-2,1,4,8]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nThe distance from -4 to 0 is |-4| = 4.\nThe distance from -2 to 0 is |-2| = 2.\nThe distance from 1 to 0 is |1| = 1.\nThe distance from 4 to 0 is |4| = 4.\nThe distance from 8 to 0 is |8| = 8.\nThus, the closest number to 0 in the array is 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,-1,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 1 and -1 are both the closest numbers to 0, so 1 being larger is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1953778,
                "title": "one-liner",
                "content": "**C++**\\n```cpp\\nint findClosestNumber(vector<int>& nums) {\\n    return *min_element(begin(nums), end(nums), [](int a, int b) {\\n        return abs(a) < abs(b) || (abs(a) == abs(b) && a > b);\\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint findClosestNumber(vector<int>& nums) {\\n    return *min_element(begin(nums), end(nums), [](int a, int b) {\\n        return abs(a) < abs(b) || (abs(a) == abs(b) && a > b);\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953923,
                "title": "one-liner",
                "content": "# **Explanation**\\nFine the max pair of `(-abs(a), a)`,\\nwhere `a` is the elements in input array.\\n\\nIt compare firstly `-abs(a)`, where it finds the minimum absolute value.\\nIf multiple result, then it compares secondely `a`, where it finds the maximum value.\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Python**\\n```py\\n    def findClosestNumber(self, A):\\n        return max([-abs(a), a] for a in A)[1] \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def findClosestNumber(self, A):\\n        return max([-abs(a), a] for a in A)[1] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1954364,
                "title": "proper-benchmarks-3-4-ms-python",
                "content": "When submitting the normal way, LeetCode reports times around 150 ms and varying quite a bit even when submitting the same solution multiple times. And by now I hope it\\'s well-known that these times usually reflect mostly the judge overhead, barely the actual solution time at all, so they\\'re pretty much useless and just misleading. In this problem, actual solution times seem to be around 4 to 16 ms, and when measured properly, the times are impressively stable. Here are my benchmark results of a few solutions (for each solution I show the best three total times out of ten):\\n```\\nfindClosestNumberB   3.40 ms   3.42 ms   3.42 ms\\nfindClosestNumberC   3.44 ms   3.44 ms   3.44 ms\\nfindClosestNumberD   3.78 ms   3.78 ms   3.78 ms\\nfindClosestNumber7   3.93 ms   3.95 ms   3.95 ms\\nfindClosestNumberA   4.03 ms   4.04 ms   4.04 ms\\nfindClosestNumber6   4.19 ms   4.20 ms   4.20 ms\\nfindClosestNumber5   4.42 ms   4.42 ms   4.44 ms\\nfindClosestNumber9   5.74 ms   5.74 ms   5.75 ms\\nfindClosestNumber4   9.64 ms   9.65 ms   9.66 ms\\nfindClosestNumber8  10.27 ms  10.31 ms  10.32 ms\\nfindClosestNumber2  11.15 ms  11.17 ms  11.17 ms\\nfindClosestNumber3  13.00 ms  13.00 ms  13.01 ms\\nfindClosestNumber1  15.04 ms  15.06 ms  15.08 ms\\n```\\nYou see I tried quite a few methods and optimizations. The fastest ones don\\'t call `abs`/`min`/`max` or any other functions but do it on their own, by keeping track of the smallest positive and largest negative number. And they try to minimize the number of comparisons/assignments, ideally just one comparison per element. If you find something even faster, I\\'m very interested.\\n\\nThe full code, which when submitted, runs every solution on every test case. And after all 224 test cases, it shows the benchmark results in stdout:\\n```\\nclass Solution:\\n    \\n    def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]\\n\\n    def findClosestNumber5(self, nums: List[int]) -> int:\\n        a = min(map(abs, nums))\\n        return a if a in nums else -a\\n\\n    def findClosestNumber6(self, nums: List[int]) -> int:\\n        a = abs(min(nums, key=abs))\\n        return a if a in nums else -a\\n\\n    def findClosestNumber7(self, nums: List[int]) -> int:\\n        x = min(nums, key=abs)\\n        return x if x >= 0 or -x not in nums else -x\\n    \\n    def findClosestNumber8(self, nums: List[int]) -> int:\\n        return min(sorted(nums, reverse=True), key=abs)\\n    \\n    def findClosestNumber9(self, nums: List[int]) -> int:        \\n        a = abs(nums[0])\\n        for x in nums:\\n            if x < 0:\\n                x = -x\\n            if x < a:\\n                a = x\\n        return a if a in nums else -a\\n        \\n    def findClosestNumberA(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if x < 0:\\n                if x > neg:\\n                    neg = x\\n            elif x < pos:\\n                pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberB(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if x < pos and neg < x:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberC(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if neg < x and x < pos:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberD(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if neg < x < pos:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumber(self, nums: List[int], timess=defaultdict(lambda: [0] * 10), testcase=[0]) -> int:\\n        name = \\'findClosestNumber\\'\\n        solutions = [getattr(self, s)\\n                     for s in dir(self)\\n                     if s.startswith(name)\\n                     and s != name]\\n        expect = dummy = object()\\n        from time import perf_counter as time\\n        for i in range(10):\\n            shuffle(solutions)\\n            for solution in solutions:\\n                start = time()\\n                result = solution(nums)\\n                end = time()\\n                if expect is dummy:\\n                    expect = result\\n                assert result == expect\\n                timess[solution.__name__][i] += end - start\\n        testcase[0] += 1\\n        if testcase[0] == 224:\\n            for name, times in sorted(timess.items(), key=lambda nt: sorted(nt[1])):\\n                print(name, *(f\\'{t*1e3:6.2f} ms\\' for t in sorted(times)[:3]))\\n            return\\n        return result\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfindClosestNumberB   3.40 ms   3.42 ms   3.42 ms\\nfindClosestNumberC   3.44 ms   3.44 ms   3.44 ms\\nfindClosestNumberD   3.78 ms   3.78 ms   3.78 ms\\nfindClosestNumber7   3.93 ms   3.95 ms   3.95 ms\\nfindClosestNumberA   4.03 ms   4.04 ms   4.04 ms\\nfindClosestNumber6   4.19 ms   4.20 ms   4.20 ms\\nfindClosestNumber5   4.42 ms   4.42 ms   4.44 ms\\nfindClosestNumber9   5.74 ms   5.74 ms   5.75 ms\\nfindClosestNumber4   9.64 ms   9.65 ms   9.66 ms\\nfindClosestNumber8  10.27 ms  10.31 ms  10.32 ms\\nfindClosestNumber2  11.15 ms  11.17 ms  11.17 ms\\nfindClosestNumber3  13.00 ms  13.00 ms  13.01 ms\\nfindClosestNumber1  15.04 ms  15.06 ms  15.08 ms\\n```\n```\\nclass Solution:\\n    \\n    def findClosestNumber1(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: (abs(x), -x))\\n    \\n    def findClosestNumber2(self, nums: List[int]) -> int:\\n        return min(nums, key=lambda x: abs(x - .1))\\n    \\n    def findClosestNumber3(self, nums: List[int]) -> int:\\n        return max((-abs(x), x) for x in nums)[1]\\n    \\n    def findClosestNumber4(self, nums: List[int]) -> int:\\n        return -min(zip(map(abs, nums), map(neg, nums)))[1]\\n\\n    def findClosestNumber5(self, nums: List[int]) -> int:\\n        a = min(map(abs, nums))\\n        return a if a in nums else -a\\n\\n    def findClosestNumber6(self, nums: List[int]) -> int:\\n        a = abs(min(nums, key=abs))\\n        return a if a in nums else -a\\n\\n    def findClosestNumber7(self, nums: List[int]) -> int:\\n        x = min(nums, key=abs)\\n        return x if x >= 0 or -x not in nums else -x\\n    \\n    def findClosestNumber8(self, nums: List[int]) -> int:\\n        return min(sorted(nums, reverse=True), key=abs)\\n    \\n    def findClosestNumber9(self, nums: List[int]) -> int:        \\n        a = abs(nums[0])\\n        for x in nums:\\n            if x < 0:\\n                x = -x\\n            if x < a:\\n                a = x\\n        return a if a in nums else -a\\n        \\n    def findClosestNumberA(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if x < 0:\\n                if x > neg:\\n                    neg = x\\n            elif x < pos:\\n                pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberB(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if x < pos and neg < x:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberC(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if neg < x and x < pos:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumberD(self, nums: List[int]) -> int:        \\n        pos = 999999\\n        neg = -pos\\n        for x in nums:\\n            if neg < x < pos:\\n                if x < 0:\\n                    neg = x\\n                else:\\n                    pos = x\\n        return pos if pos <= -neg else neg\\n        \\n    def findClosestNumber(self, nums: List[int], timess=defaultdict(lambda: [0] * 10), testcase=[0]) -> int:\\n        name = \\'findClosestNumber\\'\\n        solutions = [getattr(self, s)\\n                     for s in dir(self)\\n                     if s.startswith(name)\\n                     and s != name]\\n        expect = dummy = object()\\n        from time import perf_counter as time\\n        for i in range(10):\\n            shuffle(solutions)\\n            for solution in solutions:\\n                start = time()\\n                result = solution(nums)\\n                end = time()\\n                if expect is dummy:\\n                    expect = result\\n                assert result == expect\\n                timess[solution.__name__][i] += end - start\\n        testcase[0] += 1\\n        if testcase[0] == 224:\\n            for name, times in sorted(timess.items(), key=lambda nt: sorted(nt[1])):\\n                print(name, *(f\\'{t*1e3:6.2f} ms\\' for t in sorted(times)[:3]))\\n            return\\n        return result\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956110,
                "title": "c-solution-explained",
                "content": "*  First compare each element with INT_MAX . If lesser then update the ans variable with the element in the nums . For exapmle , in case of [-4,-2,1,4,8]\\n     *  abs(4) < abs(INT_MAX) --> so mark ans = 4 \\n     *  In next iteration abs(2) < abs(4) --> so mark ans = 2 \\n     *  iterating through the nums will finnaly give 1 as ans .\\n     \\n*  For another case when there are two possible answers  --> e.g. --> -1 , 1 \\n     *  Check for max in this case so -->  max(-1,1) --> gives 1 , which is our answer .\\n\\n\\n> Code \\n```cpp\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n//         setting the ans to maximum value of int\\n        int ans = INT_MAX ;\\n        for(int i :  nums){\\n        // checking if each value of nums is less than the max value\\n            if(abs(i) < abs(ans)){\\n                ans =  i ; //check for the lesser value\\n            }\\n            else if(abs(i) == abs(ans)){\\n                ans = max (ans,i) ; // return the maximum in cases there are multiple answers\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n\\n**First Post**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n//         setting the ans to maximum value of int\\n        int ans = INT_MAX ;\\n        for(int i :  nums){\\n        // checking if each value of nums is less than the max value\\n            if(abs(i) < abs(ans)){\\n                ans =  i ; //check for the lesser value\\n            }\\n            else if(abs(i) == abs(ans)){\\n                ans = max (ans,i) ; // return the maximum in cases there are multiple answers\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953639,
                "title": "java",
                "content": "Understanding : At max there can be two numbers with least difference, one positive and one negative.\\nIn this case, the positive number has to be considered as the answer.\\n    \\n```\\nclass Solution\\n{\\n    public int findClosestNumber(int[] nums)\\n    {\\n        int res = Integer.MAX_VALUE;\\n        for(int i: nums)\\n            if(Math.abs(i) < Math.abs(res) || i == Math.abs(res))\\n                res = i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int findClosestNumber(int[] nums)\\n    {\\n        int res = Integer.MAX_VALUE;\\n        for(int i: nums)\\n            if(Math.abs(i) < Math.abs(res) || i == Math.abs(res))\\n                res = i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953682,
                "title": "time-o-n-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mini=INT_MAX;\\n        int number=INT_MIN;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<mini)\\n            {   mini=abs(nums[i]);\\n                number=nums[i];\\n            }\\n            else if(abs(nums[i])==mini)\\n            {\\n                if(number<nums[i])\\n                    number=nums[i];\\n            }\\n        }\\n        return number;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mini=INT_MAX;\\n        int number=INT_MIN;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<mini)\\n            {   mini=abs(nums[i]);\\n                number=nums[i];\\n            }\\n            else if(abs(nums[i])==mini)\\n            {\\n                if(number<nums[i])\\n                    number=nums[i];\\n            }\\n        }\\n        return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953643,
                "title": "java-solution",
                "content": "```\\n// If absolute of n is less than min, update the closest_num \\n// If absolute of n is same of as min, update the bigger closest_num\\n\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE, closest_num = 0;\\n        for(int n : nums) {\\n            if(min > Math.abs(n)) {\\n                min = Math.abs(n);\\n                closest_num = n;\\n            } else if(min == Math.abs(n) && closest_num < n) {\\n                closest_num = n;\\n            }\\n        }\\n        return closest_num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// If absolute of n is less than min, update the closest_num \\n// If absolute of n is same of as min, update the bigger closest_num\\n\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE, closest_num = 0;\\n        for(int n : nums) {\\n            if(min > Math.abs(n)) {\\n                min = Math.abs(n);\\n                closest_num = n;\\n            } else if(min == Math.abs(n) && closest_num < n) {\\n                closest_num = n;\\n            }\\n        }\\n        return closest_num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977609,
                "title": "java-c-python-javascript-kotlin-1line-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Java***\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int smallestDis = nums[0];\\n        \\n            for (int j = 1; j < nums.length; j++) {\\n\\n                if (Math.abs(smallestDis) == (nums[j])){\\n                    smallestDis = nums[j];\\n                }\\n                if(Math.abs(nums[j]) < Math.abs(smallestDis)){\\n                    smallestDis = nums[j];\\n                }\\n            }\\n        return smallestDis;\\n    }\\n}\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m = 10 ** 6\\n        for i in nums:\\n            x = abs(i-0)\\n            if x < m:\\n                m = x\\n                val = i\\n            elif x == m and val < i:\\n                val = i\\n        return val\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n    return *min_element(begin(nums), end(nums), [](int a, int b) {\\n        return abs(a) < abs(b) || (abs(a) == abs(b) && a > b);\\n    });\\n}\\n};\\n```\\n\\n***JavaScript***\\n```\\nvar findClosestNumber = function(nums) {\\n  let closest = Infinity;\\n\\n  for (let num of nums) {\\n    if (Math.abs(num) < Math.abs(closest)) {\\n      closest = num\\n    } else if (Math.abs(num) === Math.abs(closest)) {\\n      closest = Math.max(num, closest)\\n    }\\n  }\\n\\n  return closest;\\n};\\n```\\n\\n***Kotlin***\\n```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun findClosestNumber(nums: IntArray): Int {\\n        var closest: Int? = null\\n        for (num in nums) {\\n            if (closest == null) {\\n                closest = num\\n            } else {\\n                if (abs(num) < abs(closest)) {\\n                    closest = num\\n                } else if (abs(num) == abs(closest)) {\\n                    if (num > closest) {\\n                        closest = num\\n                    }\\n                }\\n            }\\n        }\\n        return closest!!\\n    }\\n}\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int smallestDis = nums[0];\\n        \\n            for (int j = 1; j < nums.length; j++) {\\n\\n                if (Math.abs(smallestDis) == (nums[j])){\\n                    smallestDis = nums[j];\\n                }\\n                if(Math.abs(nums[j]) < Math.abs(smallestDis)){\\n                    smallestDis = nums[j];\\n                }\\n            }\\n        return smallestDis;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m = 10 ** 6\\n        for i in nums:\\n            x = abs(i-0)\\n            if x < m:\\n                m = x\\n                val = i\\n            elif x == m and val < i:\\n                val = i\\n        return val\\n```\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n    return *min_element(begin(nums), end(nums), [](int a, int b) {\\n        return abs(a) < abs(b) || (abs(a) == abs(b) && a > b);\\n    });\\n}\\n};\\n```\n```\\nvar findClosestNumber = function(nums) {\\n  let closest = Infinity;\\n\\n  for (let num of nums) {\\n    if (Math.abs(num) < Math.abs(closest)) {\\n      closest = num\\n    } else if (Math.abs(num) === Math.abs(closest)) {\\n      closest = Math.max(num, closest)\\n    }\\n  }\\n\\n  return closest;\\n};\\n```\n```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun findClosestNumber(nums: IntArray): Int {\\n        var closest: Int? = null\\n        for (num in nums) {\\n            if (closest == null) {\\n                closest = num\\n            } else {\\n                if (abs(num) < abs(closest)) {\\n                    closest = num\\n                } else if (abs(num) == abs(closest)) {\\n                    if (num > closest) {\\n                        closest = num\\n                    }\\n                }\\n            }\\n        }\\n        return closest!!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637617,
                "title": "my-clean-solution-in-java",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int ans = Integer.MIN_VALUE;\\n        \\n        for (int n : nums) {\\n            if (Math.abs(n) < min) {\\n                min = Math.abs(n);\\n                ans = n;\\n            }\\n            else if (Math.abs(n) == min) {\\n                ans = Math.max(ans, n);\\n            }\\n        }\\n        \\n        return ans;      \\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int ans = Integer.MIN_VALUE;\\n        \\n        for (int n : nums) {\\n            if (Math.abs(n) < min) {\\n                min = Math.abs(n);\\n                ans = n;\\n            }\\n            else if (Math.abs(n) == min) {\\n                ans = Math.max(ans, n);\\n            }\\n        }\\n        \\n        return ans;      \\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953644,
                "title": "simple-java-solution-with-comments-o-n-o-1",
                "content": "\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int ans=nums[0]; //assume first is nearest to zero\\n        for(int i=1;i<nums.length;i++){\\n            if(Math.abs(nums[i])<=Math.abs(ans)){ //to check other number is nearest or equal to diffrence of ans and zero\\n                if(Math.abs(nums[i])==Math.abs(ans)){ //if this number is equal nearer compare to ans then we update the answer with max value as said in question\\n                    ans=Math.max(ans,nums[i]);\\n                }else{ //if this number is nearer than ans then we update the answer\\n                    ans=nums[i];    \\n                }                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Concised Way: Thanks to @aaveshk\\n\\n  public int findClosestNumber(int[] nums) {\\n        int ans=nums[0]; //assume first is nearest to zero\\n        for(int i=1;i<nums.length;i++)\\n\\t\\t\\tif(Math.abs(nums[i]) < Math.abs(ans) || nums[i] == Math.abs(ans))\\n\\t\\t\\t\\tans = nums[i];\\n\\t\\treturn ans;\\n  }\\n\\t\\t\\t\\t\\n\\n```\\nUpvote if it\\'s helpful",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int ans=nums[0]; //assume first is nearest to zero\\n        for(int i=1;i<nums.length;i++){\\n            if(Math.abs(nums[i])<=Math.abs(ans)){ //to check other number is nearest or equal to diffrence of ans and zero\\n                if(Math.abs(nums[i])==Math.abs(ans)){ //if this number is equal nearer compare to ans then we update the answer with max value as said in question\\n                    ans=Math.max(ans,nums[i]);\\n                }else{ //if this number is nearer than ans then we update the answer\\n                    ans=nums[i];    \\n                }                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Concised Way: Thanks to @aaveshk\\n\\n  public int findClosestNumber(int[] nums) {\\n        int ans=nums[0]; //assume first is nearest to zero\\n        for(int i=1;i<nums.length;i++)\\n\\t\\t\\tif(Math.abs(nums[i]) < Math.abs(ans) || nums[i] == Math.abs(ans))\\n\\t\\t\\t\\tans = nums[i];\\n\\t\\treturn ans;\\n  }\\n\\t\\t\\t\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135483,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int: #// nums = [-4, -2, 1, 4, 8]\\n        pos, neg = [], []\\n        for item in nums:\\n            if item < 0:\\n                neg.append(item)\\n            elif item > 0:\\n                pos.append(item)\\n            else:\\n                return 0\\n                                            #// neg = [-4, -2]     pos = [1, 4, 8]       \\n        if not neg:\\n            return sorted(pos)[0]\\n        if not pos:\\n            return sorted(neg)[-1]\\n        \\n        if abs(sorted(neg)[-1]) <  sorted(pos)[0]:\\n            return sorted(neg)[-1]\\n        return sorted(pos)[0]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int: #// nums = [-4, -2, 1, 4, 8]\\n        pos, neg = [], []\\n        for item in nums:\\n            if item < 0:\\n                neg.append(item)\\n            elif item > 0:\\n                pos.append(item)\\n            else:\\n                return 0\\n                                            #// neg = [-4, -2]     pos = [1, 4, 8]       \\n        if not neg:\\n            return sorted(pos)[0]\\n        if not pos:\\n            return sorted(neg)[-1]\\n        \\n        if abs(sorted(neg)[-1]) <  sorted(pos)[0]:\\n            return sorted(neg)[-1]\\n        return sorted(pos)[0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448995,
                "title": "java-2ms-beats-98-simple-and-easy-code",
                "content": "```\\n int ans = 0  ; int closest = Integer.MAX_VALUE ; int diff = 0 ;\\n       \\n        //we used a for loop to check difference of each number from 0 ;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            int temp = nums[i];//storing value in temp ;\\n            \\n            //if number is negative then this\\n            if(temp < 0 ){\\n                 diff = 0 -temp ;\\n            }else{//else this because we want the mod value of the difference; \\n                 diff = temp - 0 ;\\n            }\\n            \\n            if(diff < closest ){\\n                closest = diff ;\\n                ans = temp ;\\n            }else if(diff == closest){//this is for checking for max value ;\\n                if(ans < temp){\\n                    ans = temp ;\\n                }\\n            }\\n            \\n        }\\n        return ans ;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n int ans = 0  ; int closest = Integer.MAX_VALUE ; int diff = 0 ;\\n       \\n        //we used a for loop to check difference of each number from 0 ;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            int temp = nums[i];//storing value in temp ;\\n            \\n            //if number is negative then this\\n            if(temp < 0 ){\\n                 diff = 0 -temp ;\\n            }else{//else this because we want the mod value of the difference; \\n                 diff = temp - 0 ;\\n            }\\n            \\n            if(diff < closest ){\\n                closest = diff ;\\n                ans = temp ;\\n            }else if(diff == closest){//this is for checking for max value ;\\n                if(ans < temp){\\n                    ans = temp ;\\n                }\\n            }\\n            \\n        }\\n        return ans ;",
                "codeTag": "Unknown"
            },
            {
                "id": 2146990,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        t = nums[0]\\n        for num in nums:\\n            if abs(num) == abs(t):\\n                t = max(t,num)\\n            elif abs(num) < abs(t):\\n                t= num\\n        return t\\n          \\n        \\n            \\n```\\nSolution",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        t = nums[0]\\n        for num in nums:\\n            if abs(num) == abs(t):\\n                t = max(t,num)\\n            elif abs(num) < abs(t):\\n                t= num\\n        return t\\n          \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953786,
                "title": "c-o-n-greedy",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-closest-number-to-zero/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& A) {\\n        int diff = INT_MAX, ans = INT_MAX;\\n        for (int n : A) {\\n            if (abs(n) < diff || (abs(n) == diff && n > ans)) {\\n                diff = abs(n);\\n                ans = n;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-closest-number-to-zero/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& A) {\\n        int diff = INT_MAX, ans = INT_MAX;\\n        for (int n : A) {\\n            if (abs(n) < diff || (abs(n) == diff && n > ans)) {\\n                diff = abs(n);\\n                ans = n;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953733,
                "title": "simple-python-solution",
                "content": "```\\ndef findClosestNumber(self, nums: List[int]) -> int:\\n\\tclosest = nums[0]\\n\\tfor a in nums: \\n\\t  if abs(closest) > abs(a):\\n\\t\\tclosest = a\\n\\t  elif abs(closest) == abs(a):\\n\\t\\tclosest = max(closest, a)\\n\\treturn closest \\n```",
                "solutionTags": [],
                "code": "```\\ndef findClosestNumber(self, nums: List[int]) -> int:\\n\\tclosest = nums[0]\\n\\tfor a in nums: \\n\\t  if abs(closest) > abs(a):\\n\\t\\tclosest = a\\n\\t  elif abs(closest) == abs(a):\\n\\t\\tclosest = max(closest, a)\\n\\treturn closest \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953739,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int x=INT_MAX,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<x)\\n            {\\n                x=abs(nums[i]);\\n                ans=nums[i];\\n            }\\n            else if(abs(nums[i])==x)\\n            {\\n                ans=max(ans,nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int x=INT_MAX,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<x)\\n            {\\n                x=abs(nums[i]);\\n                ans=nums[i];\\n            }\\n            else if(abs(nums[i])==x)\\n            {\\n                ans=max(ans,nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953649,
                "title": "java-explained-iterative-binary-search-easiest",
                "content": "The solution is **simple** to **binary search** the array and check at max the **low low+1 and low -1** due to the constraints given \\nIn case if constraints were not given then returning of arr[low] itself would have done the job\\n\\nUPVOTE coders it takes a lot of confidence to post this solution after being able to solve only one in the contest \\uD83D\\uDE12\\uD83D\\uDE12\\u2764\\n\\n```\\npublic static int findClosestNumber(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tint low=0,high=nums.length-1;\\n\\twhile(low<high){\\n\\t\\tint mid =low+(high-low)/2;\\n\\t\\tif(nums[mid]==0)return nums[mid];\\n\\t\\tif(nums[mid]>0)high=mid-1;\\n\\t\\tif(nums[mid]<0)low=mid+1;\\n\\t}\\n\\tif((low+1)<=nums.length-1\\n\\t\\t\\t&& -nums[low] == nums[low + 1])\\n\\t\\treturn nums[low+1];\\n\\n\\tif((low+1)<=nums.length-1 &&\\n\\t\\t\\t-nums[low] >= nums[low + 1])\\n\\t\\treturn nums[low+1];\\n\\n\\tif((low-1)>=0\\n\\t\\t\\t&& -nums[low-1] < nums[low] || nums[low] > nums[low] )\\n\\t\\treturn nums[low-1];\\n\\n\\treturn nums[low];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\npublic static int findClosestNumber(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tint low=0,high=nums.length-1;\\n\\twhile(low<high){\\n\\t\\tint mid =low+(high-low)/2;\\n\\t\\tif(nums[mid]==0)return nums[mid];\\n\\t\\tif(nums[mid]>0)high=mid-1;\\n\\t\\tif(nums[mid]<0)low=mid+1;\\n\\t}\\n\\tif((low+1)<=nums.length-1\\n\\t\\t\\t&& -nums[low] == nums[low + 1])\\n\\t\\treturn nums[low+1];\\n\\n\\tif((low+1)<=nums.length-1 &&\\n\\t\\t\\t-nums[low] >= nums[low + 1])\\n\\t\\treturn nums[low+1];\\n\\n\\tif((low-1)>=0\\n\\t\\t\\t&& -nums[low-1] < nums[low] || nums[low] > nums[low] )\\n\\t\\treturn nums[low-1];\\n\\n\\treturn nums[low];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420858,
                "title": "2ms-using-java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int res=0;\\n        for(int i=0;i<nums.length;i++) \\n        {\\n            if(Math.abs(nums[i])<min) \\n            {\\n                min=Math.abs(nums[i]);\\n                res=nums[i];\\n            }\\n            else if(min==Math.abs(nums[i]) && res<nums[i]) \\n            {\\n                res=nums[i];\\n            }\\n        }\\n        return res;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int res=0;\\n        for(int i=0;i<nums.length;i++) \\n        {\\n            if(Math.abs(nums[i])<min) \\n            {\\n                min=Math.abs(nums[i]);\\n                res=nums[i];\\n            }\\n            else if(min==Math.abs(nums[i]) && res<nums[i]) \\n            {\\n                res=nums[i];\\n            }\\n        }\\n        return res;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932978,
                "title": "c-int-max-easy-solution",
                "content": "# Using INT_MAX function\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n       int mn=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<=abs(mn))\\n                mn=nums[i];\\n        }\\n        return mn;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n       int mn=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i])<=abs(mn))\\n                mn=nums[i];\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494424,
                "title": "simple-js-solution-using-sort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findClosestNumber = function(nums) {\\n    nums.sort((a, b) => Math.abs(a) - Math.abs(b));\\n    if (nums.includes(Math.abs(nums[0]))) return Math.abs(nums[0]);\\n    return nums[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findClosestNumber = function(nums) {\\n    nums.sort((a, b) => Math.abs(a) - Math.abs(b));\\n    if (nums.includes(Math.abs(nums[0]))) return Math.abs(nums[0]);\\n    return nums[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032739,
                "title": "beginners-friendly-solution-using-heap-c",
                "content": "We are making a max heap and inserting all the elements of the array in pair. The first contains the absolute vale, second contains the true value of the element. We pop the top element when the size gets more than 1. We are doing this because the problem statement requires us to return only the closest one, not top 2 closest or top k closest.\\n\\nWe add an additional condition for in case we get a negative element on top. We see if the positive num of same magnitute is available in the array, if yes, then we return that, else we return whatever we got on top of our max heap.\\n\\n```\\nint findClosestNumber(vector<int>& nums) {\\n        \\n        priority_queue<pair<int,int> > pq;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({abs(nums[i]),nums[i]});\\n            if(pq.size()>1) pq.pop();\\n        }\\n        \\n        if(pq.top().second<0 && find(nums.begin(), nums.end(), pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else{\\n            return pq.top().first;\\n        }\\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "We are making a max heap and inserting all the elements of the array in pair. The first contains the absolute vale, second contains the true value of the element. We pop the top element when the size gets more than 1. We are doing this because the problem statement requires us to return only the closest one, not top 2 closest or top k closest.\\n\\nWe add an additional condition for in case we get a negative element on top. We see if the positive num of same magnitute is available in the array, if yes, then we return that, else we return whatever we got on top of our max heap.\\n\\n```\\nint findClosestNumber(vector<int>& nums) {\\n        \\n        priority_queue<pair<int,int> > pq;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({abs(nums[i]),nums[i]});\\n            if(pq.size()>1) pq.pop();\\n        }\\n        \\n        if(pq.top().second<0 && find(nums.begin(), nums.end(), pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else{\\n            return pq.top().first;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1959624,
                "title": "python-olution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m = 10 ** 6\\n        for i in nums:\\n            x = abs(i-0)\\n            if x < m:\\n                m = x\\n                val = i\\n            elif x == m and val < i:\\n                val = i\\n        return val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m = 10 ** 6\\n        for i in nums:\\n            x = abs(i-0)\\n            if x < m:\\n                m = x\\n                val = i\\n            elif x == m and val < i:\\n                val = i\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953765,
                "title": "just-linear-search-on-time-and-o-1-space-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = 1e9;\\n        for(auto &it : nums){\\n            if(abs(it) == abs(ans)){\\n                ans = max(it,ans);\\n            }\\n            else if(abs(it) < abs(ans)){\\n                ans = it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = 1e9;\\n        for(auto &it : nums){\\n            if(abs(it) == abs(ans)){\\n                ans = max(it,ans);\\n            }\\n            else if(abs(it) < abs(ans)){\\n                ans = it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656179,
                "title": "easy-python-solution",
                "content": "\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        min=1000000\\n        for i in nums:\\n            if min>abs(i):\\n                min=abs(i)\\n        if min in nums:\\n            return min\\n        else:\\n            return -1*min\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        min=1000000\\n        for i in nums:\\n            if min>abs(i):\\n                min=abs(i)\\n        if min in nums:\\n            return min\\n        else:\\n            return -1*min\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478630,
                "title": "find-closest-number-to-zero-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int i, ans=INT_MIN, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(abs(nums[i]-0)<min || (abs(nums[i]-0)==min && nums[i]>ans))\\n            {\\n                min = abs(nums[i]);\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/ae95e3ea-6c2d-4afc-b01e-eaf270bb59cc_1683046840.8975687.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int i, ans=INT_MIN, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(abs(nums[i]-0)<min || (abs(nums[i]-0)==min && nums[i]>ans))\\n            {\\n                min = abs(nums[i]);\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457646,
                "title": "c-solution-simple-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n\\n    int ans = 0;\\n    int min_dist = INT_MAX;\\n    int n=nums.size();\\n    for (int i = 0; i < n; i++)\\n    {\\n        min_dist = min(min_dist, abs(nums[i]));\\n        if (min_dist == abs(nums[i]))\\n        {\\n            if(nums[i]<0 && ans!=min_dist)\\n                    ans = nums[i];\\n            else\\n                ans = min_dist;\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n\\n    int ans = 0;\\n    int min_dist = INT_MAX;\\n    int n=nums.size();\\n    for (int i = 0; i < n; i++)\\n    {\\n        min_dist = min(min_dist, abs(nums[i]));\\n        if (min_dist == abs(nums[i]))\\n        {\\n            if(nums[i]<0 && ans!=min_dist)\\n                    ans = nums[i];\\n            else\\n                ans = min_dist;\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061835,
                "title": "c-track-closest-negative-and-positive-o-n-102ms-96",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) \\n    {\\n        var closestPositive = int.MaxValue;    \\n        var closestNegative = int.MinValue;    \\n\\n        foreach(var n in nums)\\n        {\\n            if(n >= 0)\\n                closestPositive = Math.Min(closestPositive, n);\\n            else\\n                closestNegative = Math.Max(closestNegative, n);\\n        }\\n\\n        return -closestPositive >= closestNegative ? closestPositive : closestNegative;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) \\n    {\\n        var closestPositive = int.MaxValue;    \\n        var closestNegative = int.MinValue;    \\n\\n        foreach(var n in nums)\\n        {\\n            if(n >= 0)\\n                closestPositive = Math.Min(closestPositive, n);\\n            else\\n                closestNegative = Math.Max(closestNegative, n);\\n        }\\n\\n        return -closestPositive >= closestNegative ? closestPositive : closestNegative;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996124,
                "title": "java-3-ms-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for (int n : nums) {\\n            if (min + n == 0) {\\n                min = min > 0 ? min : n;\\n            } else if (Math.abs(min) > Math.abs(n)) {\\n                min = n;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for (int n : nums) {\\n            if (min + n == 0) {\\n                min = min > 0 ? min : n;\\n            } else if (Math.abs(min) > Math.abs(n)) {\\n                min = n;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640106,
                "title": "c-priority-queue-simple-approach",
                "content": "```\\n//Firstly we make a min heap and store all the elements of array with their absolute value as a key and array element itself as the value of key.Then the value at top is the closest number to zero.\\n//if there is are multiple same keys in heap then we search the availability of its greater value in array if it is not present then we print second value otherwise first.\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({abs(nums[i]),nums[i]});\\n        }\\nif(pq.top().second<0 && find(nums.begin(),nums.end(),pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else\\n            return pq.top().first;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//Firstly we make a min heap and store all the elements of array with their absolute value as a key and array element itself as the value of key.Then the value at top is the closest number to zero.\\n//if there is are multiple same keys in heap then we search the availability of its greater value in array if it is not present then we print second value otherwise first.\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({abs(nums[i]),nums[i]});\\n        }\\nif(pq.top().second<0 && find(nums.begin(),nums.end(),pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else\\n            return pq.top().first;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637734,
                "title": "easy-java-solution-o-n-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int distance=Integer.MAX_VALUE;\\n        int max_distance=Integer.MAX_VALUE;\\nint min_no=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n                  distance=Math.abs(nums[i]);\\n                  if(distance<max_distance)\\n                  {\\n                       max_distance=distance;\\n                       min_no=nums[i];\\n                  }\\n                \\n                if(distance==max_distance)\\n                {\\n                   max_distance=distance;\\n                  min_no=Math.max(nums[i],min_no);\\n                }\\n                \\n        }\\n       return min_no;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int distance=Integer.MAX_VALUE;\\n        int max_distance=Integer.MAX_VALUE;\\nint min_no=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n                  distance=Math.abs(nums[i]);\\n                  if(distance<max_distance)\\n                  {\\n                       max_distance=distance;\\n                       min_no=nums[i];\\n                  }\\n                \\n                if(distance==max_distance)\\n                {\\n                   max_distance=distance;\\n                  min_no=Math.max(nums[i],min_no);\\n                }\\n                \\n        }\\n       return min_no;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530720,
                "title": "beginner-friendly-java-code",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE,dist=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n           if(Math.abs(nums[i])<min){  //Math.abs is a func to convert neg into pos no.\\n               min=Math.abs(nums[i]);\\n               dist=nums[i];\\n           }else if(Math.abs(nums[i])==min){\\n               if(nums[i] > dist){\\n                   dist=nums[i];\\n               }\\n               \\n           }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE,dist=0;\\n        for(int i=0;i<nums.length;i++){\\n            \\n           if(Math.abs(nums[i])<min){  //Math.abs is a func to convert neg into pos no.\\n               min=Math.abs(nums[i]);\\n               dist=nums[i];\\n           }else if(Math.abs(nums[i])==min){\\n               if(nums[i] > dist){\\n                   dist=nums[i];\\n               }\\n               \\n           }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433173,
                "title": "find-closest-number-to-zero-solution-java",
                "content": "class Solution {\\n  public int findClosestNumber(int[] nums) {\\n    int ans = 0;\\n    int min = Integer.MAX_VALUE;\\n\\n    for (final int num : nums)\\n      if (Math.abs(num) < min) {\\n        min = Math.abs(num);\\n        ans = num;\\n      } else if (Math.abs(num) == min && num > ans) {\\n        ans = num;\\n      }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n  public int findClosestNumber(int[] nums) {\\n    int ans = 0;\\n    int min = Integer.MAX_VALUE;\\n\\n    for (final int num : nums)\\n      if (Math.abs(num) < min) {\\n        min = Math.abs(num);\\n        ans = num;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2378044,
                "title": "easy-c-solution-using-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n      pair<int,int> p;\\n        int mini= abs(nums[0]);\\n        p.first = mini;\\n        p.second = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n           if(p.first>abs(nums[i])){\\n              p.first = abs(nums[i]);\\n               p.second = nums[i];\\n           }\\n            else if(p.first == abs(nums[i])){\\n                 if(p.second<nums[i]){\\n                     p.second = nums[i];\\n                 }\\n            }\\n        }\\n        \\n        return p.second;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n      pair<int,int> p;\\n        int mini= abs(nums[0]);\\n        p.first = mini;\\n        p.second = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n           if(p.first>abs(nums[i])){\\n              p.first = abs(nums[i]);\\n               p.second = nums[i];\\n           }\\n            else if(p.first == abs(nums[i])){\\n                 if(p.second<nums[i]){\\n                     p.second = nums[i];\\n                 }\\n            }\\n        }\\n        \\n        return p.second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335663,
                "title": "with-explanation-comments-time-20-ms-97-79-space-19-6-mb-90-92",
                "content": "**Like it? ->Upvote please!**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n\\t\\n        //initialize two variables, one for the number of steps from 0 & one to store the minimum value reached\\n        int step=0,min=INT_MAX,num=0;\\n        \\n        //loop over the whole array elements\\n        for(int n:nums){\\n            //get the number of steps from 0 to the current number\\n            step=abs(n);\\n            \\n            //store the min possible value\\n            if(step<min){\\n                min=step;\\n                num=n;\\n            }\\n            //if there\\'s two elements with the same number of steps-> return the max one bewteen the two numbers\\n            else if(step==min)\\n                num=max(n,num);\\n        }\\n        \\n        //return the minimum value\\n        return num;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n\\t\\n        //initialize two variables, one for the number of steps from 0 & one to store the minimum value reached\\n        int step=0,min=INT_MAX,num=0;\\n        \\n        //loop over the whole array elements\\n        for(int n:nums){\\n            //get the number of steps from 0 to the current number\\n            step=abs(n);\\n            \\n            //store the min possible value\\n            if(step<min){\\n                min=step;\\n                num=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2123218,
                "title": "python-easy-solution",
                "content": "Here I used the concept of Dictionary, since this only came to my mind during the contest.\\nFor better understanding remove the comments before the print statements and then run ur code, u will understand the ques and approach in much better way.\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        d={}\\n        for i in nums:\\n            d[i]=abs(i)\\n        \\n        dic = sorted(d.items(), key = lambda item: item[1])\\n        #print(dic)\\n        \\n        x=dic[0][1]\\n        for i in dic:\\n            #print(i[0],x)\\n            if i[0]>=0 and i[0]==x:\\n                return i[0]\\n        \\n        return dic[0][0]\\n```\\nIf u understood the code then plz.......UPVOTE...........Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        d={}\\n        for i in nums:\\n            d[i]=abs(i)\\n        \\n        dic = sorted(d.items(), key = lambda item: item[1])\\n        #print(dic)\\n        \\n        x=dic[0][1]\\n        for i in dic:\\n            #print(i[0],x)\\n            if i[0]>=0 and i[0]==x:\\n                return i[0]\\n        \\n        return dic[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011991,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int result = nums[0];\\n        \\n        for(int i = 1; i<nums.Length;i++)\\n            if(Math.Abs(nums[i]) < Math.Abs(result))\\n                result = nums[i];\\n            else if(Math.Abs(nums[i]) == Math.Abs(result))\\n                result = Math.Max(result,nums[i]);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int result = nums[0];\\n        \\n        for(int i = 1; i<nums.Length;i++)\\n            if(Math.Abs(nums[i]) < Math.Abs(result))\\n                result = nums[i];\\n            else if(Math.Abs(nums[i]) == Math.Abs(result))\\n                result = Math.Max(result,nums[i]);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004964,
                "title": "easy-to-understand-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(auto x:nums)\\n        {\\n            if(abs(x)==abs(ans))\\n                ans=max(x,ans);\\n            \\n\\t\\t\\telse if(abs(x)<abs(ans))\\n                ans=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(auto x:nums)\\n        {\\n            if(abs(x)==abs(ans))\\n                ans=max(x,ans);\\n            \\n\\t\\t\\telse if(abs(x)<abs(ans))\\n                ans=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967408,
                "title": "uisng-vector-pair-alternate-way-in-cpp",
                "content": "bool cmp(const pair<int,int> &a,const pair<int,int> &b)\\n    {\\n        return (a.second < b.second);\\n    }\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        vector<pair<int,int>> vc;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            vc.push_back({abs(nums[i]),nums[i]});\\n        \\n        sort(vc.begin(), vc.end(), cmp);\\n        int prevn=INT_MIN;\\n        int prevl=INT_MAX;\\n        for(auto i:vc)\\n        {\\n            if(i.first<=prevl)\\n            {\\n                prevl=i.first;\\n                if(prevn<i.second)\\n                {\\n                    prevn=i.second;\\n                }\\n            }\\n        }\\n        return prevn;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        vector<pair<int,int>> vc;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            vc.push_back({abs(nums[i]),nums[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1960467,
                "title": "c-easy-to-understand-approach-0-1-space-without-sorting",
                "content": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& a) {\\n       int res1,res=INT_MIN,dif=INT_MAX;\\n       for(int i=0;i<a.size();i++)\\n       {\\n           if(abs(a[i]-0)<=dif)\\n           {\\n               //here we are checking if the present difference is equal to the previous one                    //then we will select the maximum one else we will jiust update it\\n               if(dif==abs(a[i])-0)\\n                   res=max(res,a[i]);\\n               else \\n                  res=a[i];\\n               \\n               dif=abs(a[i]-0);\\n               \\n               \\n           }\\n       }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& a) {\\n       int res1,res=INT_MIN,dif=INT_MAX;\\n       for(int i=0;i<a.size();i++)\\n       {\\n           if(abs(a[i]-0)<=dif)\\n           {\\n               //here we are checking if the present difference is equal to the previous one                    //then we will select the maximum one else we will jiust update it\\n               if(dif==abs(a[i])-0)\\n                   res=max(res,a[i]);\\n               else \\n                  res=a[i];\\n               \\n               dif=abs(a[i]-0);\\n               \\n               \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1956822,
                "title": "rust-solution",
                "content": "1. One-liner with ```fold```.\\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        use std::cmp::Ordering;\\n        nums.iter()\\n            .fold((i32::MIN, i32::MAX), |(val, dist), &x| {\\n                match dist.cmp(&(x.abs())) {\\n                    Ordering::Greater => (x, x.abs()),\\n                    Ordering::Equal => (x.max(val), dist),\\n                    Ordering::Less => (val, dist),\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\\n\\n2. One-liner with ```max_by```.\\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        use std::cmp::Ordering;\\n        nums.into_iter()\\n            .max_by(|x, y| match y.abs().cmp(&(x.abs())) {\\n                Ordering::Equal => x.cmp(y),\\n                abs_cmp => abs_cmp,\\n            })\\n            .unwrap()\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```fold```\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        use std::cmp::Ordering;\\n        nums.iter()\\n            .fold((i32::MIN, i32::MAX), |(val, dist), &x| {\\n                match dist.cmp(&(x.abs())) {\\n                    Ordering::Greater => (x, x.abs()),\\n                    Ordering::Equal => (x.max(val), dist),\\n                    Ordering::Less => (val, dist),\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\n```max_by```\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        use std::cmp::Ordering;\\n        nums.into_iter()\\n            .max_by(|x, y| match y.abs().cmp(&(x.abs())) {\\n                Ordering::Equal => x.cmp(y),\\n                abs_cmp => abs_cmp,\\n            })\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956593,
                "title": "c-simple-approach-greedy-easy-to-understand",
                "content": "```\\n// for more understanding please dry run the [-1000,-1000] case;\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<n;i++){\\n            \\n            int ans=abs(nums[i])-0;\\n            mini=min(ans,mini);\\n        }\\n        if(count(nums.begin(),nums.end(),mini)){\\n            return mini;\\n        }\\n        return -mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// for more understanding please dry run the [-1000,-1000] case;\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<n;i++){\\n            \\n            int ans=abs(nums[i])-0;\\n            mini=min(ans,mini);\\n        }\\n        if(count(nums.begin(),nums.end(),mini)){\\n            return mini;\\n        }\\n        return -mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954994,
                "title": "rust-solution-one-pass-0ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold((-100001, 100001), |(res, min), &x| {\\n                if x.abs() < min {\\n                    (x, x.abs())\\n                } else if x.abs() == min {\\n                    (res.max(x), min)\\n                } else {\\n                    (res, min)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\\n\\nThe following (original) post will fail on `[2, -1, 1]`. Thanks to [@BigMih](https://leetcode.com/BigMih/) for pointing out the error in the code.\\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold((-100001, 100001), |(res, min), &x| {\\n                if x.abs() <= min {\\n                    (res.max(x), x.abs())\\n                } else {\\n                    (res, min)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold((-100001, 100001), |(res, min), &x| {\\n                if x.abs() < min {\\n                    (x, x.abs())\\n                } else if x.abs() == min {\\n                    (res.max(x), min)\\n                } else {\\n                    (res, min)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .fold((-100001, 100001), |(res, min), &x| {\\n                if x.abs() <= min {\\n                    (res.max(x), x.abs())\\n                } else {\\n                    (res, min)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953810,
                "title": "c-100-short-easy-o-n",
                "content": "```\\nint findClosestNumber(int* nums, int numsSize)\\n{\\n    int min = INT_MAX;\\n    int val = INT_MAX;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (abs(nums[i]) <= min) {\\n            min = abs(nums[i]);\\n            if (abs(val) == abs(nums[i]))\\n                val = val > nums[i] ? val : nums[i];\\n            else\\n                val = nums[i];\\n            printf(\"%d \", val);\\n        }\\n    }\\n    return val;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findClosestNumber(int* nums, int numsSize)\\n{\\n    int min = INT_MAX;\\n    int val = INT_MAX;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (abs(nums[i]) <= min) {\\n            min = abs(nums[i]);\\n            if (abs(val) == abs(nums[i]))\\n                val = val > nums[i] ? val : nums[i];\\n            else\\n                val = nums[i];\\n            printf(\"%d \", val);\\n        }\\n    }\\n    return val;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055052,
                "title": "optimized-solutions-in-c-and-java-with-clear-explanation",
                "content": "# Explaination\\n1) Initialize $$closest$$ with the first element of the array.\\n\\n2) Iterate through the array, comparing the absolute values of each element with the absolute value of $$closest$$.\\n\\n- Calculate the absolute value of $$current$$ using the $$abs()$$ function.\\n\\n- If the absolute value of the $$current$$ element is smaller than the absolute value of $$closest$$, update $$closest$$ to the current element.\\n\\n- If the absolute values are equal, compare the actual values of the $$current$$ element and $$closest$$. If the $$current$$ element is greater, update $$closest$$ to the $$current$$ element.\\n\\n3. After iterating through all elements, $$closest$$ holds the number closest to zero in terms of its absolute value.\\n\\n4. Return $$closest$$ as the result.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Cpp Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(std::vector<int>& nums) {\\n        int closest = nums[0]; \\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int current = nums[i];\\n\\n            if (abs(current) < abs(closest) || (abs(current) == abs(closest) && current > closest)) {\\n                closest = current;\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n\\n```\\n# Java Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(std::vector<int>& nums) {\\n        int closest = nums[0]; \\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int current = nums[i];\\n\\n            if (abs(current) < abs(closest) || (abs(current) == abs(closest) && current > closest)) {\\n                closest = current;\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(std::vector<int>& nums) {\\n        int closest = nums[0]; \\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int current = nums[i];\\n\\n            if (abs(current) < abs(closest) || (abs(current) == abs(closest) && current > closest)) {\\n                closest = current;\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(std::vector<int>& nums) {\\n        int closest = nums[0]; \\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int current = nums[i];\\n\\n            if (abs(current) < abs(closest) || (abs(current) == abs(closest) && current > closest)) {\\n                closest = current;\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681783,
                "title": "easy-c-solution-beginner-friendly-approach-beats-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int dist = abs(nums[i]), val = nums[i];\\n            if(dist<abs(ans))\\n                ans = val;\\n            else if(dist==abs(ans))\\n                ans = ans>val ? ans : val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int dist = abs(nums[i]), val = nums[i];\\n            if(dist<abs(ans))\\n                ans = val;\\n            else if(dist==abs(ans))\\n                ans = ans>val ? ans : val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561280,
                "title": "beginners-friendly-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(Math.abs(nums[i])< min || nums[i]== Math.abs(min) ){\\n                min=Math.abs(nums[i]);\\n                res=nums[i];\\n\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(Math.abs(nums[i])< min || nums[i]== Math.abs(min) ){\\n                min=Math.abs(nums[i]);\\n                res=nums[i];\\n\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405983,
                "title": "self-explanatory-code",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        diff = 99999999\\n        ans = 999999999\\n        for i in nums:\\n            if abs(0-i) < diff:\\n                diff = abs(0-i)\\n                ans = i\\n            if diff == abs(0-i):\\n                diff = abs(0-i)\\n                ans = max(ans, i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        diff = 99999999\\n        ans = 999999999\\n        for i in nums:\\n            if abs(0-i) < diff:\\n                diff = abs(0-i)\\n                ans = i\\n            if diff == abs(0-i):\\n                diff = abs(0-i)\\n                ans = max(ans, i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382827,
                "title": "easy-and-beginners-friendly-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntaking the positive elements and negative elements in seperate vectors\\nand sorting them...taking the last element of the negtive vector and the first element of the positive vector... finaly checking for the smallest number of those two...\\n\\nadd a comment if you have better solution\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        vector<int> pos;\\n        vector<int> neg;\\n        for(auto x: nums){\\n            if(x>0){\\n                pos.push_back(x);\\n            }\\n            else{\\n                neg.push_back(x);\\n            }\\n            if(x==0){\\n                return 0;\\n            }\\n        }\\n        if(pos.size()!=0){\\n            sort(pos.begin(),pos.end());\\n        }\\n        if(neg.size()!=0){\\n            sort(neg.begin(),neg.end());\\n        }\\n        int n=neg.size();\\n        if(pos.size()==0){\\n            return neg[n-1]; \\n        }\\n        if(neg.size()==0){\\n            return pos[0];\\n        }\\n        return abs(neg[n-1])<pos[0] ? neg[n-1]:pos[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        vector<int> pos;\\n        vector<int> neg;\\n        for(auto x: nums){\\n            if(x>0){\\n                pos.push_back(x);\\n            }\\n            else{\\n                neg.push_back(x);\\n            }\\n            if(x==0){\\n                return 0;\\n            }\\n        }\\n        if(pos.size()!=0){\\n            sort(pos.begin(),pos.end());\\n        }\\n        if(neg.size()!=0){\\n            sort(neg.begin(),neg.end());\\n        }\\n        int n=neg.size();\\n        if(pos.size()==0){\\n            return neg[n-1]; \\n        }\\n        if(neg.size()==0){\\n            return pos[0];\\n        }\\n        return abs(neg[n-1])<pos[0] ? neg[n-1]:pos[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296518,
                "title": "reduce-ternary-operators-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    return nums.reduce((acc, num) => Math.abs(num) < Math.abs(acc)\\n        ? num\\n        : Math.abs(num) === Math.abs(acc)\\n            ? Math.max(num, acc)\\n            : acc,\\n    );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    return nums.reduce((acc, num) => Math.abs(num) < Math.abs(acc)\\n        ? num\\n        : Math.abs(num) === Math.abs(acc)\\n            ? Math.max(num, acc)\\n            : acc,\\n    );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3291925,
                "title": "c-one-line-solution-using-linq",
                "content": "# Intuition\\nC# is the most handy language to write any piece of code using built in functions.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSmart LINQ Techniques\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int t=0;\\n        int m=nums.OrderBy(x=> Math.Abs((long)x-t)).ThenByDescending(x=>x).First();\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int t=0;\\n        int m=nums.OrderBy(x=> Math.Abs((long)x-t)).ThenByDescending(x=>x).First();\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281248,
                "title": "java-javascript-solution-jw",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nJava:\\n```\\npublic int findClosestNumber(int[] nums) {\\n    int res = Integer.MAX_VALUE;\\n    for (int i: nums) {\\n        if (Math.abs(i) < Math.abs(res) || i == Math.abs(res)) {\\n            res = i;\\n        }\\n    }\\n    return res;\\n}\\n```\\nJavascript:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    let res = Number.MAX_VALUE;\\n    for (let i of nums) {\\n        if (Math.abs(i) < Math.abs(res) || i === Math.abs(res)) {\\n            res = i;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\npublic int findClosestNumber(int[] nums) {\\n    int res = Integer.MAX_VALUE;\\n    for (int i: nums) {\\n        if (Math.abs(i) < Math.abs(res) || i == Math.abs(res)) {\\n            res = i;\\n        }\\n    }\\n    return res;\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    let res = Number.MAX_VALUE;\\n    for (let i of nums) {\\n        if (Math.abs(i) < Math.abs(res) || i === Math.abs(res)) {\\n            res = i;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3268168,
                "title": "simple-python-beats-93",
                "content": "# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        h=min([abs(i) for i in nums])\\n        return h if h in nums else -h\\n            \\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        h=min([abs(i) for i in nums])\\n        return h if h in nums else -h\\n            \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154753,
                "title": "go",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n\\n\\nfunc findClosestNumber(nums []int) int {\\n    closestNumber := -math.MaxInt\\n    closestAbsNumber := math.MaxInt\\n\\n    for _, num := range nums {\\n        diff := int(math.Abs(float64(num)))\\n\\n        if diff < closestAbsNumber {\\n            closestAbsNumber = diff\\n            closestNumber = num\\n        } else if diff == closestAbsNumber {\\n            closestNumber = max(closestNumber, num)\\n        }\\n    }\\n\\n    return closestNumber\\n}\\n\\n\\n// max returns larger digit\\nfunc max(num1, num2 int) int {\\n    if num1 < num2 {\\n        return num2\\n    }\\n\\n    return num1\\n} \\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\n\\nfunc findClosestNumber(nums []int) int {\\n    closestNumber := -math.MaxInt\\n    closestAbsNumber := math.MaxInt\\n\\n    for _, num := range nums {\\n        diff := int(math.Abs(float64(num)))\\n\\n        if diff < closestAbsNumber {\\n            closestAbsNumber = diff\\n            closestNumber = num\\n        } else if diff == closestAbsNumber {\\n            closestNumber = max(closestNumber, num)\\n        }\\n    }\\n\\n    return closestNumber\\n}\\n\\n\\n// max returns larger digit\\nfunc max(num1, num2 int) int {\\n    if num1 < num2 {\\n        return num2\\n    }\\n\\n    return num1\\n} \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3075368,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        a=[abs(i) for i in nums]\\n        b=[]\\n        for j in nums:\\n            if abs(j)==min(a):\\n                b.append(j)\\n        return max(b)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        a=[abs(i) for i in nums]\\n        b=[]\\n        for j in nums:\\n            if abs(j)==min(a):\\n                b.append(j)\\n        return max(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827111,
                "title": "java-find-closest-number-to-zero",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        int val=nums[0];\\n        for(int i:nums){\\n            if(i==0)return 0;\\n            if(i>0){\\n                ans=i;break;\\n            }\\n            val=i;\\n        }\\n        \\n        if(ans==0)return nums[nums.length-1];\\n        if(Math.abs(val)<ans)return val;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        int val=nums[0];\\n        for(int i:nums){\\n            if(i==0)return 0;\\n            if(i>0){\\n                ans=i;break;\\n            }\\n            val=i;\\n        }\\n        \\n        if(ans==0)return nums[nums.length-1];\\n        if(Math.abs(val)<ans)return val;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746354,
                "title": "python-easy-solution-in-o-n-tc-without-using-extra-space",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m=100000000\\n        for i in nums:\\n            if abs(m)>=abs(i):\\n                if abs(m)==abs(i):\\n                    if i>m:\\n                        m=i\\n                else:\\n                    m=i\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        m=100000000\\n        for i in nums:\\n            if abs(m)>=abs(i):\\n                if abs(m)==abs(i):\\n                    if i>m:\\n                        m=i\\n                else:\\n                    m=i\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744784,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        val=[] \\n        for i in nums:\\n            val.append([i,abs(i)])\\n        val=sorted(val,key=lambda x:(x[1],-x[0])) \\n        return val[0][0]\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        val=[] \\n        for i in nums:\\n            val.append([i,abs(i)])\\n        val=sorted(val,key=lambda x:(x[1],-x[0])) \\n        return val[0][0]\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2731715,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int findClosestNumber(vector<int>& nums) \\n    {\\n        int a = INT_MAX;\\n        int b = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n                a = min(a,i);\\n            else if(0>i)\\n                b = max(b,i);\\n            else\\n                return 0;\\n        }\\n        if(b == INT_MIN)\\n            return a;\\n        else if(a == INT_MAX)\\n            return b;\\n        else if(abs(b) < a)\\n            return b;\\n        else\\n            return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int findClosestNumber(vector<int>& nums) \\n    {\\n        int a = INT_MAX;\\n        int b = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n                a = min(a,i);\\n            else if(0>i)\\n                b = max(b,i);\\n            else\\n                return 0;\\n        }\\n        if(b == INT_MIN)\\n            return a;\\n        else if(a == INT_MAX)\\n            return b;\\n        else if(abs(b) < a)\\n            return b;\\n        else\\n            return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692024,
                "title": "javascript-92-faster",
                "content": "```\\nvar findClosestNumber = function(nums) {\\n    \\n    let closest = nums[0];\\n    let closestAbs = Math.abs(nums[0]);\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        \\n        let number = nums[i];\\n        let absNumber = Math.abs(number);\\n        \\n        if (number == 0)\\n            return 0;\\n        \\n        if (absNumber <= closestAbs) {\\n            \\n            if (absNumber < closestAbs) {\\n                \\n                closest = number;\\n                closestAbs = absNumber\\n                \\n            } else {\\n                \\n                if (closest < number) {\\n                    \\n                    closest = number;\\n                    closestAbs = absNumber\\n                    \\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    return closest;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findClosestNumber = function(nums) {\\n    \\n    let closest = nums[0];\\n    let closestAbs = Math.abs(nums[0]);\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        \\n        let number = nums[i];\\n        let absNumber = Math.abs(number);\\n        \\n        if (number == 0)\\n            return 0;\\n        \\n        if (absNumber <= closestAbs) {\\n            \\n            if (absNumber < closestAbs) {\\n                \\n                closest = number;\\n                closestAbs = absNumber\\n                \\n            } else {\\n                \\n                if (closest < number) {\\n                    \\n                    closest = number;\\n                    closestAbs = absNumber\\n                    \\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    return closest;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2669874,
                "title": "c-solution-for-bignner",
                "content": "Easy To Understand For Bignner \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n        int ans=nums[0];\\n\\n        int diff=abs(nums[0]);\\n\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]) < diff)\\n            {\\n                ans=nums[i];\\n                diff=abs(nums[i]);\\n            }\\n\\n            if(diff==abs(nums[i]) && nums[i]>ans)\\n            {\\n                ans=nums[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n        int ans=nums[0];\\n\\n        int diff=abs(nums[0]);\\n\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]) < diff)\\n            {\\n                ans=nums[i];\\n                diff=abs(nums[i]);\\n            }\\n\\n            if(diff==abs(nums[i]) && nums[i]>ans)\\n            {\\n                ans=nums[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661091,
                "title": "c-easy-solution-tc-o-n-sc-o-1",
                "content": "```\\nint findClosestNumber(vector<int>& nums) \\n    {\\n        /* answer can be two optiion\\n        if positive then minimum; a\\n        if negative then maximum; b\\n        jo minimum hoga wo return kardo;\\n        */\\n        int a = INT_MAX;\\n        int b = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n                a = min(a,i);\\n            else if(0>i)\\n                b = max(b,i);\\n            else\\n                return 0;\\n        }\\n        if(b == INT_MIN)\\n            return a;\\n        else if(a == INT_MAX)\\n            return b;\\n        else if(abs(b) < a)\\n            return b;\\n        else\\n            return a;\\n    }",
                "solutionTags": [],
                "code": "```\\nint findClosestNumber(vector<int>& nums) \\n    {\\n        /* answer can be two optiion\\n        if positive then minimum; a\\n        if negative then maximum; b\\n        jo minimum hoga wo return kardo;\\n        */\\n        int a = INT_MAX;\\n        int b = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n                a = min(a,i);\\n            else if(0>i)\\n                b = max(b,i);\\n            else\\n                return 0;\\n        }\\n        if(b == INT_MIN)\\n            return a;\\n        else if(a == INT_MAX)\\n            return b;\\n        else if(abs(b) < a)\\n            return b;\\n        else\\n            return a;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2638928,
                "title": "c-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& arr) {\\n        int temp=INT_MAX;\\n\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)\\n                return 0;\\n            if(abs(temp)>abs(arr[i])){\\n                temp=arr[i];\\n            }\\n           else if(abs(temp)==abs(arr[i]) && arr[i]>0)\\n                temp=arr[i];\\n        }\\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findClosestNumber(vector<int>& arr) {\\n        int temp=INT_MAX;\\n\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)\\n                return 0;\\n            if(abs(temp)>abs(arr[i])){\\n                temp=arr[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2440992,
                "title": "easily-understandable-c",
                "content": "```\\nTime: O(n)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int res=INT_MAX;\\n        for(auto& x: nums){\\n            if(abs(x)<abs(res))\\n                res=x;\\n            else if(abs(x)==abs(res))\\n                res=max(res,x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTime: O(n)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int res=INT_MAX;\\n        for(auto& x: nums){\\n            if(abs(x)<abs(res))\\n                res=x;\\n            else if(abs(x)==abs(res))\\n                res=max(res,x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402377,
                "title": "easy-and-clear-python-3-solution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        close=nums[0]\\n        for r in range(1,len(nums)):\\n            if abs(nums[r])<abs(close):\\n                close=nums[r]\\n            if abs(nums[r])==abs(close) and nums[r]>0:\\n                close=nums[r]\\n        return close\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        close=nums[0]\\n        for r in range(1,len(nums)):\\n            if abs(nums[r])<abs(close):\\n                close=nums[r]\\n            if abs(nums[r])==abs(close) and nums[r]>0:\\n                close=nums[r]\\n        return close\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349670,
                "title": "o-n-2ms-t-c",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        int max = -100000;\\n        int dist = 100000;\\n        for (int i: nums) {\\n            if (dist > Math.abs(i)){\\n                dist = Math.abs(i);\\n                max = i;\\n            }\\n            else if (dist == Math.abs(i)){\\n                dist = Math.abs(i);\\n                max = Math.max(max, i);\\n            }\\n        }\\n        return max;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2247852,
                "title": "simplest-solution-closest-to-zero-in-c",
                "content": "int findClosestNumber(int* nums, int numsSize){\\n    int i=0;\\n    int min=nums[i];\\n    \\n    for( i=1;i<numsSize;i++)\\n    {\\n        if(abs(nums[i])<abs(min)||nums[i]==abs(min))\\n        {\\n            min=nums[i];\\n        }\\n    }\\n    return min;\\n    \\n    \\n\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "int findClosestNumber(int* nums, int numsSize){\\n    int i=0;\\n    int min=nums[i];\\n    \\n    for( i=1;i<numsSize;i++)\\n    {\\n        if(abs(nums[i])<abs(min)||nums[i]==abs(min))\\n        {\\n            min=nums[i];\\n        }\\n    }\\n    return min;\\n    \\n    \\n\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2241418,
                "title": "3-liner-java",
                "content": "```\\npublic int findClosestNumber(int[] nums) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>(){\\n            public int compare(Integer a,Integer b){\\n                if(Math.abs(a)==Math.abs(b)) return b-a;\\n                return Integer.compare(Math.abs(a),Math.abs(b));\\n            }\\n        });\\n        for(int i:nums) heap.add(i);\\n        return heap.remove();\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int findClosestNumber(int[] nums) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>(){\\n            public int compare(Integer a,Integer b){\\n                if(Math.abs(a)==Math.abs(b)) return b-a;\\n                return Integer.compare(Math.abs(a),Math.abs(b));\\n            }\\n        });\\n        for(int i:nums) heap.add(i);\\n        return heap.remove();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2192384,
                "title": "python-solution-2-solutions",
                "content": "Approach 1:\\n\\n\\t\\tclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        num=float(\\'inf\\')\\n        nums.sort()\\n        for i in nums:\\n            if abs(i)<=num:\\n                num=abs(i)\\n                c=i\\n        return c\\n\\t\\t\\n\\t\\t\\nApproach 2:\\n\\n\\t\\tclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n            res=[abs(ele) for ele in nums]\\n            a=(min(res))\\n            if a in nums:\\n                return a\\n            else:\\n                return a*-1\\n            \\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "Approach 1:\\n\\n\\t\\tclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        num=float(\\'inf\\')\\n        nums.sort()\\n        for i in nums:\\n            if abs(i)<=num:\\n                num=abs(i)\\n                c=i\\n        return c\\n\\t\\t\\n\\t\\t\\nApproach 2:\\n\\n\\t\\tclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n            res=[abs(ele) for ele in nums]\\n            a=(min(res))\\n            if a in nums:\\n                return a\\n            else:\\n                return a*-1\\n            \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2186118,
                "title": "easy-understanding-c",
                "content": "\\n\\n\\n int findClosestNumber(vector<int>& nums) {\\n\\n        priority_queue<pair<int,int> > pq;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({abs(nums[i]),nums[i]});\\n            if(pq.size()>1) pq.pop();\\n        }\\n        \\n        if(pq.top().second<0 && find(nums.begin(), nums.end(), pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else{\\n            return pq.top().first;\\n        }\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n\\n\\n int findClosestNumber(vector<int>& nums) {\\n\\n        priority_queue<pair<int,int> > pq;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({abs(nums[i]),nums[i]});\\n            if(pq.size()>1) pq.pop();\\n        }\\n        \\n        if(pq.top().second<0 && find(nums.begin(), nums.end(), pq.top().first)==nums.end())\\n        return pq.top().second;\\n        else{\\n            return pq.top().first;\\n        }\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2175965,
                "title": "js-javascript-75-faster-easy-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findClosestNumber = function(nums) {\\n\\n  let negative = nums.filter(i => i < 0)\\n  let positives = nums.filter(i => 0 <= i)\\n\\n  let max = !negative.length ? Number.MIN_SAFE_INTEGER : negative.reduce((r, i) => Math.max(r, i))\\n  let min = !positives.length ? Number.MAX_SAFE_INTEGER : positives.reduce((r, i) => Math.min(r, i))\\n\\n  return Math.abs(min) <= Math.abs(max) ? min : max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findClosestNumber = function(nums) {\\n\\n  let negative = nums.filter(i => i < 0)\\n  let positives = nums.filter(i => 0 <= i)\\n\\n  let max = !negative.length ? Number.MIN_SAFE_INTEGER : negative.reduce((r, i) => Math.max(r, i))\\n  let min = !positives.length ? Number.MAX_SAFE_INTEGER : positives.reduce((r, i) => Math.min(r, i))\\n\\n  return Math.abs(min) <= Math.abs(max) ? min : max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137831,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n      int minDis=0;\\n      int check=Integer.MAX_VALUE;\\n      for(int i=0;i<nums.length;i++){\\n         \\n          int dis=Math.abs(nums[i]);\\n          \\n          if(nums[i]>=0 && dis<=check){\\n              check=nums[i];\\n              minDis=nums[i];\\n          }\\n          else if(nums[i]<0 && dis<check){\\n              check=-nums[i];\\n              minDis=nums[i];\\n          }\\n      }\\n        return minDis;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n      int minDis=0;\\n      int check=Integer.MAX_VALUE;\\n      for(int i=0;i<nums.length;i++){\\n         \\n          int dis=Math.abs(nums[i]);\\n          \\n          if(nums[i]>=0 && dis<=check){\\n              check=nums[i];\\n              minDis=nums[i];\\n          }\\n          else if(nums[i]<0 && dis<check){\\n              check=-nums[i];\\n              minDis=nums[i];\\n          }\\n      }\\n        return minDis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129378,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, x: List[int]) -> int:\\n        return -min((abs(i),-i) for i in x)[1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, x: List[int]) -> int:\\n        return -min((abs(i),-i) for i in x)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109818,
                "title": "easy-python-solution-for-beginners",
                "content": "```\\ndef findClosestNumber(self, nums: List[int]) -> int:\\n        m=nums[0]\\n        for i in nums:\\n            if abs(m)>=abs(i):\\n                if abs(m)==abs(i):\\n                    m=max(m,i)\\n                else:\\n                    m=i\\n        return m\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findClosestNumber(self, nums: List[int]) -> int:\\n        m=nums[0]\\n        for i in nums:\\n            if abs(m)>=abs(i):\\n                if abs(m)==abs(i):\\n                    m=max(m,i)\\n                else:\\n                    m=i\\n        return m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2108429,
                "title": "simple-approach-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int x=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n                if(abs(x)>abs(nums[i]))\\n                x=nums[i];\\n                else if(abs(x)==abs(nums[i])){\\n                    x=max(x,nums[i]);\\n                }\\n            \\n          \\n            \\n        }return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int x=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n                if(abs(x)>abs(nums[i]))\\n                x=nums[i];\\n                else if(abs(x)==abs(nums[i])){\\n                    x=max(x,nums[i]);\\n                }\\n            \\n          \\n            \\n        }return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107640,
                "title": "c-21-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(const vector<int>& nums) {\\n        int neg=-100001,pos=100001;\\n        for(auto i:nums) {\\n            if(!i) return 0;\\n            if(i<0) neg=max(neg,i);\\n            else    pos=min(pos,i);\\n        }\\n        return -neg==pos?pos:-neg<pos?neg:pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(const vector<int>& nums) {\\n        int neg=-100001,pos=100001;\\n        for(auto i:nums) {\\n            if(!i) return 0;\\n            if(i<0) neg=max(neg,i);\\n            else    pos=min(pos,i);\\n        }\\n        return -neg==pos?pos:-neg<pos?neg:pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105517,
                "title": "c-o-n-pairs",
                "content": "int findClosestNumber(vector<int>& nums) {\\n        pair<int,int>p={100000000,1000000000};\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i])<p.second){//this line for checking weather there exist lesser value then pair hold which closest to 0\\n                p={nums[i],abs(nums[i])};\\n            }\\n            if((abs(nums[i])==p.second)&&nums[i]>p.first)p={nums[i],abs(nums[i])}; this line for if there exist -2 , 2 which one to pick\\n        }\\n        return p.first;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int findClosestNumber(vector<int>& nums) {\\n        pair<int,int>p={100000000,1000000000};\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i])<p.second){//this line for checking weather there exist lesser value then pair hold which closest to 0\\n                p={nums[i],abs(nums[i])};\\n            }\\n            if((abs(nums[i])==p.second)&&nums[i]>p.first)p={nums[i],abs(nums[i])}; this line for if there exist -2 , 2 which one to pick\\n        }\\n        return p.first;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2085061,
                "title": "easy-js-solution",
                "content": "```\\n//Solution 1\\nvar findClosestNumber = function(nums) {\\n    \\n    let pos = Infinity;\\n    let neg = -Infinity;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        \\n        if( nums[i] > 0 ){\\n           if( pos > nums[i] ) \\n               pos = nums[i];               \\n        } else {\\n            if( neg < nums[i] )\\n                neg = nums[i];\\n        } \\n    }\\n    \\n    if( -neg < pos ) {\\n       return neg;\\n    }\\n    \\n    return pos;   \\n};\\n\\n//Solution 2\\nvar findClosestNumber = function(nums) {\\n    \\n    let result = nums[0];\\n    \\n    for(let i=1; i<nums.length; i++) {\\n        \\n        let mod = Math.abs(nums[i]);\\n        \\n        if( Math.abs(result)>mod ) {            \\n            result = nums[i]\\n        }\\n        \\n        if( Math.abs(result) == mod ) {\\n            if( result<nums[i] ) {\\n                result = nums[i];\\n            }\\n        }\\n    }\\n    \\n    return result;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//Solution 1\\nvar findClosestNumber = function(nums) {\\n    \\n    let pos = Infinity;\\n    let neg = -Infinity;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        \\n        if( nums[i] > 0 ){\\n           if( pos > nums[i] ) \\n               pos = nums[i];               \\n        } else {\\n            if( neg < nums[i] )\\n                neg = nums[i];\\n        } \\n    }\\n    \\n    if( -neg < pos ) {\\n       return neg;\\n    }\\n    \\n    return pos;   \\n};\\n\\n//Solution 2\\nvar findClosestNumber = function(nums) {\\n    \\n    let result = nums[0];\\n    \\n    for(let i=1; i<nums.length; i++) {\\n        \\n        let mod = Math.abs(nums[i]);\\n        \\n        if( Math.abs(result)>mod ) {            \\n            result = nums[i]\\n        }\\n        \\n        if( Math.abs(result) == mod ) {\\n            if( result<nums[i] ) {\\n                result = nums[i];\\n            }\\n        }\\n    }\\n    \\n    return result;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2042096,
                "title": "python-one-line-functional-approach",
                "content": "We need to find value with the minimum module, the biggest number of those. \\nWe could take advantage of using ``min()`` function which returns minimal value from an iterator. Also taking advantage of tuple comparison we could build tuple like ``(abs(value), -value, value)`` - so that we first compare absolute values, then negated value. The third element of the tuple is the original value, which we would like to return. \\nSo, we do the following:\\n1. Transform the array to an iterator of tuples described above\\n2. Find minimum value for this sequence. Note that for same absolute value (first tuple element) we compare the second, which is negated value of the original array element, thus we would have minimal value here for the maximum value of the array with the same absolute value.\\n3. Return the oriiginal value which is the third item of the tuple.\\n\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min([(abs(n), -n, n) for n in nums])[2]\\n```\\n\\nOr, simplifying that we could remove third tuple element, returning the second one negated:\\n\\n\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return -min([(abs(n), -n) for n in nums])[1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min([(abs(n), -n, n) for n in nums])[2]\\n```\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return -min([(abs(n), -n) for n in nums])[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976510,
                "title": "c-linq-one-line",
                "content": "```\\n    public int FindClosestNumber(int[] nums) \\n    {        \\n        return nums.Select(x => x).OrderBy(x => Math.Abs(x)).ThenByDescending(x=>x).First();\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int FindClosestNumber(int[] nums) \\n    {        \\n        return nums.Select(x => x).OrderBy(x => Math.Abs(x)).ThenByDescending(x=>x).First();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1970777,
                "title": "easy-java-solution-faster-than-70",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int smallestDis = nums[0];\\n        \\n            for (int j = 1; j < nums.length; j++) {\\n\\n                if (Math.abs(smallestDis) == (nums[j])){\\n                    smallestDis = nums[j];\\n                }\\n                if(Math.abs(nums[j]) < Math.abs(smallestDis)){\\n                    smallestDis = nums[j];\\n                }\\n            }\\n        return smallestDis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int smallestDis = nums[0];\\n        \\n            for (int j = 1; j < nums.length; j++) {\\n\\n                if (Math.abs(smallestDis) == (nums[j])){\\n                    smallestDis = nums[j];\\n                }\\n                if(Math.abs(nums[j]) < Math.abs(smallestDis)){\\n                    smallestDis = nums[j];\\n                }\\n            }\\n        return smallestDis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966803,
                "title": "ruby-one-liner-rust-port",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number(nums)\\n  nums.min_by { [_1.abs, -_1] }  \\nend\\n```\\n\\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        *nums.iter().min_by_key(|&x| (x.abs(), -x)).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number(nums)\\n  nums.min_by { [_1.abs, -_1] }  \\nend\\n```\n```\\nimpl Solution {\\n    pub fn find_closest_number(nums: Vec<i32>) -> i32 {\\n        *nums.iter().min_by_key(|&x| (x.abs(), -x)).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1966166,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        Min=nums[0]\\n        for i in range(len(nums)):\\n            if abs(Min)>abs(nums[i]):\\n                Min=nums[i]\\n            elif abs(Min)==abs(nums[i]):\\n                Min=max(Min,nums[i])\\n        return Min\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        Min=nums[0]\\n        for i in range(len(nums)):\\n            if abs(Min)>abs(nums[i]):\\n                Min=nums[i]\\n            elif abs(Min)==abs(nums[i]):\\n                Min=max(Min,nums[i])\\n        return Min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963093,
                "title": "kotlin",
                "content": "```kotlin\\n  fun findClosestNumber(numbers: IntArray): Int {\\n    var closest = numbers[0]\\n    \\n    for (number in numbers) {\\n      val distance = abs(closest) -  abs(number)\\n      \\n      when {\\n        distance == 0 -> closest = maxOf(closest, number)\\n        distance > 0 -> closest = number\\n      }\\n    }\\n    \\n    return closest\\n  }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\n  fun findClosestNumber(numbers: IntArray): Int {\\n    var closest = numbers[0]\\n    \\n    for (number in numbers) {\\n      val distance = abs(closest) -  abs(number)\\n      \\n      when {\\n        distance == 0 -> closest = maxOf(closest, number)\\n        distance > 0 -> closest = number\\n      }\\n    }\\n    \\n    return closest\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960009,
                "title": "c-easy-to-understand-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        map<int, vector<int>> m;\\n        for(auto& i : nums){\\n            m[abs(i)].push_back(i);\\n        }\\n        auto itr = m.begin();\\n        vector<int> v;\\n        v = itr->second;\\n        int l = v.size();\\n        sort(v.begin(), v.end());\\n        return v[l-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        map<int, vector<int>> m;\\n        for(auto& i : nums){\\n            m[abs(i)].push_back(i);\\n        }\\n        auto itr = m.begin();\\n        vector<int> v;\\n        v = itr->second;\\n        int l = v.size();\\n        sort(v.begin(), v.end());\\n        return v[l-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958501,
                "title": "c-simple-o-n-solution",
                "content": "```\\n\\tpublic int FindClosestNumber(int[] nums) {\\n        var maxNegative = int.MinValue + 1; // to prevent overflow exception\\n        var minPositive = int.MaxValue;\\n        for (int i=0; i<nums.Length; i++) {\\n            if (nums[i] < 0)\\n                maxNegative = Math.Max(nums[i], maxNegative);\\n            else\\n                minPositive = Math.Min(nums[i], minPositive);\\n        }\\n        return minPositive <= Math.Abs(maxNegative) ? minPositive : maxNegative;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int FindClosestNumber(int[] nums) {\\n        var maxNegative = int.MinValue + 1; // to prevent overflow exception\\n        var minPositive = int.MaxValue;\\n        for (int i=0; i<nums.Length; i++) {\\n            if (nums[i] < 0)\\n                maxNegative = Math.Max(nums[i], maxNegative);\\n            else\\n                minPositive = Math.Min(nums[i], minPositive);\\n        }\\n        return minPositive <= Math.Abs(maxNegative) ? minPositive : maxNegative;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955518,
                "title": "easy-python-solution-using-sorting",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mn=float(\"inf\")\\n        for val in nums:\\n            mn=min(mn,abs(val-0))\\n        \\n        for val in nums:\\n            if abs(val-0)==mn:\\n                ans=val\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mn=float(\"inf\")\\n        for val in nums:\\n            mn=min(mn,abs(val-0))\\n        \\n        for val in nums:\\n            if abs(val-0)==mn:\\n                ans=val\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955476,
                "title": "java-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            ans[i]=Math.abs(nums[i]);\\n        }\\n        Arrays.sort(ans);\\n        int j=0;\\n        \\n        for( int i=0;i<nums.length;i++){   \\n            if(ans[0]==Math.abs(nums[i])){\\n                if(nums[i]>0){\\n                    return nums[i];\\n                }\\n                j=i;\\n            }         \\n        }\\n        return nums[j];\\n               \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            ans[i]=Math.abs(nums[i]);\\n        }\\n        Arrays.sort(ans);\\n        int j=0;\\n        \\n        for( int i=0;i<nums.length;i++){   \\n            if(ans[0]==Math.abs(nums[i])){\\n                if(nums[i]>0){\\n                    return nums[i];\\n                }\\n                j=i;\\n            }         \\n        }\\n        return nums[j];\\n               \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954944,
                "title": "swift-o-n-solution",
                "content": "```\\nfinal class Solution {\\n    // O(n) time | O(1) space\\n    func findClosestNumber(_ nums: [Int]) -> Int {\\n        var closest = (0, Int.max) // (actualNumber, difference)\\n        \\n        for num in nums {\\n            let abs = abs(num)\\n        \\n            if abs < closest.1 {\\n                closest = (num, abs)\\n            } else if abs == closest.1 {\\n                closest = (max(num, closest.0), abs)\\n            }\\n        }\\n        \\n        return closest.0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    // O(n) time | O(1) space\\n    func findClosestNumber(_ nums: [Int]) -> Int {\\n        var closest = (0, Int.max) // (actualNumber, difference)\\n        \\n        for num in nums {\\n            let abs = abs(num)\\n        \\n            if abs < closest.1 {\\n                closest = (num, abs)\\n            } else if abs == closest.1 {\\n                closest = (max(num, closest.0), abs)\\n            }\\n        }\\n        \\n        return closest.0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954796,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int m=INT_MAX,ind=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(0-nums[i])<m){\\n                m=abs(0-nums[i]);\\n                ind=nums[i];\\n            }\\n            if(abs(0-nums[i])==m)\\n                ind=max(nums[i],ind);\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int m=INT_MAX,ind=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(0-nums[i])<m){\\n                m=abs(0-nums[i]);\\n                ind=nums[i];\\n            }\\n            if(abs(0-nums[i])==m)\\n                ind=max(nums[i],ind);\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954377,
                "title": "c-faster-than-100-sol-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/f0a83dd7-5a57-41a0-a624-e9507c75102a_1650133193.4666235.png)\\n\\n\\n```\\n#define ll long long\\n#define inf ((ll)(2e18))\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        ll mn = inf, mx = -inf;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] > 0) mn = min(mn, (ll)nums[i]);\\n            else mx = max(mx, (ll)nums[i]);\\n        }\\n        if (abs(mn) <= abs(mx)) return (int)mn;\\n        else return (int)mx;\\n    }\\n};\\n```\\n\\nPlease **Upvote** if you like my solution/approach",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\n#define inf ((ll)(2e18))\\n\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        ll mn = inf, mx = -inf;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] > 0) mn = min(mn, (ll)nums[i]);\\n            else mx = max(mx, (ll)nums[i]);\\n        }\\n        if (abs(mn) <= abs(mx)) return (int)mn;\\n        else return (int)mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954261,
                "title": "simple-python-solution",
                "content": "class Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in range(len(nums)):\\n            l.append(abs(nums[i]-0))\\n        t=min(l)\\n        if t not in nums:\\n            t=-1*t\\n                 \\n        return t\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in range(len(nums)):\\n            l.append(abs(nums[i]-0))\\n        t=min(l)\\n        if t not in nums:\\n            t=-1*t\\n                 \\n        return t\\n",
                "codeTag": "Java"
            },
            {
                "id": 1954208,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int max_val = 0;\\n        \\n        int min_close = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int ans = abs(nums[i]);\\n            \\n            if(ans < min_close)\\n            {\\n                min_close = ans;\\n                \\n                max_val = nums[i];\\n            }\\n            \\n            else if(ans == min_close)\\n            {\\n                max_val = max(max_val, nums[i]);\\n            }\\n        }\\n        \\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int max_val = 0;\\n        \\n        int min_close = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int ans = abs(nums[i]);\\n            \\n            if(ans < min_close)\\n            {\\n                min_close = ans;\\n                \\n                max_val = nums[i];\\n            }\\n            \\n            else if(ans == min_close)\\n            {\\n                max_val = max(max_val, nums[i]);\\n            }\\n        }\\n        \\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954191,
                "title": "o-n-time-and-o-1-space-complexity-easy-solution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n       \\n        closest = 0\\n        if 0 in nums:\\n            return 0\\n      \\n        for i in range(len(nums)):\\n                       \\n            if closest == 0 : \\n                closest = nums[i]\\n            elif nums[i] > 0 and nums[i] <= abs(closest):\\n                closest = nums[i]\\n            elif nums[i] < 0 and nums[i] < abs(closest) and abs(nums[i]) < abs(closest):\\n                closest = nums[i]\\n\\n        return closest\\n    \\n    \\n   \\n    ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n       \\n        closest = 0\\n        if 0 in nums:\\n            return 0\\n      \\n        for i in range(len(nums)):\\n                       \\n            if closest == 0 : \\n                closest = nums[i]\\n            elif nums[i] > 0 and nums[i] <= abs(closest):\\n                closest = nums[i]\\n            elif nums[i] < 0 and nums[i] < abs(closest) and abs(nums[i]) < abs(closest):\\n                closest = nums[i]\\n\\n        return closest\\n    \\n    \\n   \\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 1954160,
                "title": "find-closest-number-to-zero-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public int findClosestNumber(int[] nums) \\n    {\\n        int minDistance=Math.abs(nums[0]);\\n        int value=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int dist=Math.abs(nums[i]);\\n            if(dist < minDistance)\\n            {\\n                minDistance=dist;\\n                value=nums[i];\\n            }\\n            else if(dist == minDistance)\\n            {\\n                if(nums[i] > value)\\n                {\\n                    minDistance=dist;\\n                    value=nums[i];\\n                }\\n            }\\n        }\\n        return value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findClosestNumber(int[] nums) \\n    {\\n        int minDistance=Math.abs(nums[0]);\\n        int value=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int dist=Math.abs(nums[i]);\\n            if(dist < minDistance)\\n            {\\n                minDistance=dist;\\n                value=nums[i];\\n            }\\n            else if(dist == minDistance)\\n            {\\n                if(nums[i] > value)\\n                {\\n                    minDistance=dist;\\n                    value=nums[i];\\n                }\\n            }\\n        }\\n        return value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954023,
                "title": "2ms-easy-13-lines-step-by-step-dry-run",
                "content": "If you like it, pls **Upvote** :)\\n\\n## Approach:\\n\\t1. Use 2 variables: \"min\" to store minimum difference (absolute), and \"closest\" to store number closest to 0\\n\\t2. For each \"num\" in arrays nums:\\n\\t\\t- keep updating values of min and closest. \\n\\t\\t- Note: as mentioned in question; if min == diff, in that case update \"closest\" with the number which is bigger (num v/s closest).\\n## Code:\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE, closest = 0;\\n        for(int num : nums){\\n            if(num == 0){ return 0; }\\n            int diff = Math.abs(num);\\n            if(min > diff){\\n                min = diff;\\n                closest = num;   \\n            }else if(min == diff){\\n                closest = Math.max(num, closest); \\n            }\\n        }\\n        return closest;\\n    }\\n//\\n//\\n//\\n//\\n\\n## Dry Run:\\n\\tBelow are step-by-step dry run on few examples.\\n\\t--------\\n\\tinput nums = [-4, -2, 1, 4, 8]\\n\\t min: 4 > diff: 4  => closest = -4\\n\\t min: 2 > diff: 2  => closest = -2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [2, -1, 1]\\n\\t min: 2 > diff: 2  => closest = 2\\n\\t min: 1 > diff: 1  => closest = -1\\n\\t min: 1 == diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [2, 1, -1]\\n\\t min: 2 > diff: 2  => closest = 2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\t min: 1 == diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [-4, -2, 1, 0, 8]\\n\\t min: 4 > diff: 4  => closest = -4\\n\\t min: 2 > diff: 2  => closest = -2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\tnum = 0, => closest = 0\\n\\n\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "If you like it, pls **Upvote** :)\\n\\n## Approach:\\n\\t1. Use 2 variables: \"min\" to store minimum difference (absolute), and \"closest\" to store number closest to 0\\n\\t2. For each \"num\" in arrays nums:\\n\\t\\t- keep updating values of min and closest. \\n\\t\\t- Note: as mentioned in question; if min == diff, in that case update \"closest\" with the number which is bigger (num v/s closest).\\n## Code:\\n    public int findClosestNumber(int[] nums) {\\n        int min = Integer.MAX_VALUE, closest = 0;\\n        for(int num : nums){\\n            if(num == 0){ return 0; }\\n            int diff = Math.abs(num);\\n            if(min > diff){\\n                min = diff;\\n                closest = num;   \\n            }else if(min == diff){\\n                closest = Math.max(num, closest); \\n            }\\n        }\\n        return closest;\\n    }\\n//\\n//\\n//\\n//\\n\\n## Dry Run:\\n\\tBelow are step-by-step dry run on few examples.\\n\\t--------\\n\\tinput nums = [-4, -2, 1, 4, 8]\\n\\t min: 4 > diff: 4  => closest = -4\\n\\t min: 2 > diff: 2  => closest = -2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [2, -1, 1]\\n\\t min: 2 > diff: 2  => closest = 2\\n\\t min: 1 > diff: 1  => closest = -1\\n\\t min: 1 == diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [2, 1, -1]\\n\\t min: 2 > diff: 2  => closest = 2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\t min: 1 == diff: 1  => closest = 1\\n\\t--------\\n\\tinput nums = [-4, -2, 1, 0, 8]\\n\\t min: 4 > diff: 4  => closest = -4\\n\\t min: 2 > diff: 2  => closest = -2\\n\\t min: 1 > diff: 1  => closest = 1\\n\\tnum = 0, => closest = 0\\n\\n\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1953982,
                "title": "python3-this-feels-dirty",
                "content": "\\n```\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        from bisect import bisect, bisect_left\\n        l_n = len(nums)\\n        if l_n == 0:\\n            return 0\\n        if l_n == 1:\\n            return nums[0]\\n        nums.sort()\\n        pos_low = bisect_left(nums, 0)\\n        pos_high = bisect(nums, 0)\\n        # print(pos_low, pos_high, nums)\\n        if pos_low == pos_high:\\n            pos_low -= 1\\n        if pos_high >= l_n or pos_low > l_n:\\n            return nums[-1]\\n        if abs(nums[pos_low]) < abs(nums[pos_high]):\\n            res = nums[pos_low]\\n        else:\\n            res = nums[pos_high]\\n        # res = min(nums[pos_low], nums[pos_high])\\n        return res\\n```\\n\\nToo many distractions at the start with children needing attention. Single mom life.. sigh not liking how this one unfolded.",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        from bisect import bisect, bisect_left\\n        l_n = len(nums)\\n        if l_n == 0:\\n            return 0\\n        if l_n == 1:\\n            return nums[0]\\n        nums.sort()\\n        pos_low = bisect_left(nums, 0)\\n        pos_high = bisect(nums, 0)\\n        # print(pos_low, pos_high, nums)\\n        if pos_low == pos_high:\\n            pos_low -= 1\\n        if pos_high >= l_n or pos_low > l_n:\\n            return nums[-1]\\n        if abs(nums[pos_low]) < abs(nums[pos_high]):\\n            res = nums[pos_low]\\n        else:\\n            res = nums[pos_high]\\n        # res = min(nums[pos_low], nums[pos_high])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953960,
                "title": "hashmap-python",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        dic={}\\n        \\n        for i in nums:\\n            try:\\n                dic[abs(i)].append(i)\\n            except:\\n                dic[abs(i)]=[i]\\n                \\n        nums=dict(sorted(dic.items()))\\n        \\n        for i in nums:\\n            return max(nums[i])\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        dic={}\\n        \\n        for i in nums:\\n            try:\\n                dic[abs(i)].append(i)\\n            except:\\n                dic[abs(i)]=[i]\\n                \\n        nums=dict(sorted(dic.items()))\\n        \\n        for i in nums:\\n            return max(nums[i])\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953913,
                "title": "simple-easy-to-understand-brief-python-solution-o-n-time-o-1-space",
                "content": "```\\n# Time:  O(n)\\n# Space: O(1)\\n\\ndef findClosestNumber(nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    closest_num, closest_dist = float(\\'-inf\\'), float(\\'inf\\')\\n    for n in nums:\\n        if abs(n) < closest_dist:\\n            closest_dist = abs(n)\\n            closest_num = n\\n        if abs(n) == closest_dist:\\n            if n > closest_num:\\n                closest_num = n\\n            \\n    return closest_num\\n```",
                "solutionTags": [],
                "code": "```\\n# Time:  O(n)\\n# Space: O(1)\\n\\ndef findClosestNumber(nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    closest_num, closest_dist = float(\\'-inf\\'), float(\\'inf\\')\\n    for n in nums:\\n        if abs(n) < closest_dist:\\n            closest_dist = abs(n)\\n            closest_num = n\\n        if abs(n) == closest_dist:\\n            if n > closest_num:\\n                closest_num = n\\n            \\n    return closest_num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953903,
                "title": "golang-o-n-100",
                "content": "```\\nimport \"math\"\\n\\nfunc findClosestNumber(nums []int) int {\\n    min := nums[0]\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if math.Abs(float64(nums[i])) < math.Abs(float64(min)) {\\n            min = nums[i]\\n        } else if math.Abs(float64(nums[i])) == math.Abs(float64(min)) && nums[i] > min {\\n            min = nums[i]\\n        }\\n    }\\n    \\n    return min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"math\"\\n\\nfunc findClosestNumber(nums []int) int {\\n    min := nums[0]\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if math.Abs(float64(nums[i])) < math.Abs(float64(min)) {\\n            min = nums[i]\\n        } else if math.Abs(float64(nums[i])) == math.Abs(float64(min)) && nums[i] > min {\\n            min = nums[i]\\n        }\\n    }\\n    \\n    return min\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953746,
                "title": "python-3-150ms-dictionary-solution-o-n-o-n",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        d={}\\n        for i in range(len(nums)):\\n            if abs(nums[i]) in d:\\n                d[abs(nums[i])]=max(d[abs(nums[i])],nums[i])\\n            else:\\n                d[abs(nums[i])]=nums[i]\\n        return d[min(d.keys())]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        d={}\\n        for i in range(len(nums)):\\n            if abs(nums[i]) in d:\\n                d[abs(nums[i])]=max(d[abs(nums[i])],nums[i])\\n            else:\\n                d[abs(nums[i])]=nums[i]\\n        return d[min(d.keys())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953659,
                "title": "python-1-line",
                "content": "```python\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return sorted(nums, key=lambda v: (abs(v), -v))[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return sorted(nums, key=lambda v: (abs(v), -v))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094073,
                "title": "java-easy-to-understand-anyone-can-do-leetcode-2ms-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n       \\n        int close=0;\\n        for(int e: nums)\\n        {\\n            if(min>Math.abs(e))\\n            {\\n                min=Math.abs(e);\\n                close=e;\\n            }\\n\\n            else if(min == Math.abs(e) && close <e)\\n            {\\n                close = e;\\n            }\\n        }\\n        return close;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n       \\n        int close=0;\\n        for(int e: nums)\\n        {\\n            if(min>Math.abs(e))\\n            {\\n                min=Math.abs(e);\\n                close=e;\\n            }\\n\\n            else if(min == Math.abs(e) && close <e)\\n            {\\n                close = e;\\n            }\\n        }\\n        return close;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093852,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def findClosestNumber(self, nums):\\n        nums.sort(reverse=True)\\n        l=[abs(i) for i in nums]\\n        i=l.index(min(l))\\n        return nums[i]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findClosestNumber(self, nums):\\n        nums.sort(reverse=True)\\n        l=[abs(i) for i in nums]\\n        i=l.index(min(l))\\n        return nums[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085844,
                "title": "short-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int n=nums.Select(x=>Math.Abs(x)).Min();\\t\\t\\n        return Array.IndexOf(nums,n)<0?n*-1:n;         \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int n=nums.Select(x=>Math.Abs(x)).Min();\\t\\t\\n        return Array.IndexOf(nums,n)<0?n*-1:n;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084522,
                "title": "java-solution-with-helper-function-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public static int findClosestNumber(int[] nums) {\\n    int distance = Math.abs(nums[0]);\\n    int res = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n        if (distanceFromZero(nums[i]) < distance) {\\n          distance = distanceFromZero(nums[i]);\\n          res = nums[i];\\n        } else if (distanceFromZero(nums[i]) == distance && nums[i] > res) {\\n          res = nums[i];\\n        }\\n    }\\n    return res;\\n  }\\n\\n  public static int distanceFromZero(int a) {\\n    return Math.abs(a-0);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public static int findClosestNumber(int[] nums) {\\n    int distance = Math.abs(nums[0]);\\n    int res = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n        if (distanceFromZero(nums[i]) < distance) {\\n          distance = distanceFromZero(nums[i]);\\n          res = nums[i];\\n        } else if (distanceFromZero(nums[i]) == distance && nums[i] > res) {\\n          res = nums[i];\\n        }\\n    }\\n    return res;\\n  }\\n\\n  public static int distanceFromZero(int a) {\\n    return Math.abs(a-0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078122,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda ans, n: n if abs(n) < abs(ans) or n == abs(ans) else ans, nums, inf)      \\n```\\n> More readable\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        ans = inf\\n        for num in nums:\\n            if abs(num) < abs(ans) or num == abs(ans):\\n                ans = num\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda ans, n: n if abs(n) < abs(ans) or n == abs(ans) else ans, nums, inf)      \\n```\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        ans = inf\\n        for num in nums:\\n            if abs(num) < abs(ans) or num == abs(ans):\\n                ans = num\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077567,
                "title": "c-too-easy-fully-explained-without-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s a step-by-step explanation of how the code works with an example:\\n\\nLet\\'s say we have the following vector `nums`:\\n```\\nnums = [-4, 2, -7, 5, -1]\\n```\\n\\n1. Initialize `ans` to `INT_MAX`. This is done to ensure that the initial value of `ans` is greater than any possible absolute value in the vector.\\n\\n2. Start iterating through the elements of `nums` using a range-based for loop.\\n   \\n   - For the first element, `it` is set to `-4`. The absolute value of `-4` is `4`, which is less than the current value of `ans` (which is initially `INT_MAX`). So, `ans` is updated to `-4`.\\n   \\n   - For the second element, `it` is set to `2`. The absolute value of `2` is `2`, which is less than the current value of `ans` (which is now `-4`). So, `ans` is updated to `2`.\\n\\n   - For the third element, `it` is set to `-7`. The absolute value of `-7` is `7`, which is greater than the current value of `ans` (which is `2`). So, `ans` remains `2`.\\n\\n   - For the fourth element, `it` is set to `5`. The absolute value of `5` is `5`, which is greater than the current value of `ans` (which is `2`). So, `ans` remains `2`.\\n\\n   - For the fifth element, `it` is set to `-1`. The absolute value of `-1` is `1`, which is less than the current value of `ans` (which is `2`). So, `ans` is updated to `-1`.\\n\\n3. Continue looping through the remaining elements of `nums`, but no further updates are made to `ans` since none of the absolute values are closer to zero than `-1`.\\n\\n4. Finally, the loop ends, and the function returns the value of `ans`, which is `-1`. This is the closest number to zero in the given vector.\\n\\nThere\\'s a typo in the code: `return and;` should be replaced with `return ans;` to correctly return the closest number found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = INT_MAX;\\n        for(auto it:nums)\\n        {\\n            if(abs(it) < abs(ans)){\\n                ans = it;\\n            }\\n            else if(abs(it) == abs(ans)){\\n                ans = max(it,ans);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums = [-4, 2, -7, 5, -1]\\n```\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = INT_MAX;\\n        for(auto it:nums)\\n        {\\n            if(abs(it) < abs(ans)){\\n                ans = it;\\n            }\\n            else if(abs(it) == abs(ans)){\\n                ans = max(it,ans);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059870,
                "title": "python-simple-solution-find-close-number-to-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbeginner friendly Easiest python salution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nbeats 90% python users O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nbeats 94% python users O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findClosestNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smallest=nums[0]\\n        for i in nums:\\n            if abs(i) < abs(smallest):\\n                smallest=i\\n        \\n        if abs(smallest) in nums:\\n            smallest=abs(smallest)\\n\\n        return smallest\\n       \\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findClosestNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smallest=nums[0]\\n        for i in nums:\\n            if abs(i) < abs(smallest):\\n                smallest=i\\n        \\n        if abs(smallest) in nums:\\n            smallest=abs(smallest)\\n\\n        return smallest\\n       \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044402,
                "title": "o-n-time-o-1-space-simple",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# Second and Better Solution O(n)\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number(nums)\\n    \\n    gt_zero = 100001\\n    lt_zero = -100001\\n    nums.each do |num|\\n        if num == 0\\n            return 0\\n        elsif num > 0\\n            if num < gt_zero\\n                gt_zero = num\\n            end\\n        elsif num < 0\\n            if num > lt_zero\\n                lt_zero = num\\n            end\\n        end\\n    end\\n\\n    if -gt_zero >= lt_zero\\n        return gt_zero\\n    else\\n        lt_zero\\n    end \\nend\\n\\n# First Solution O(log n)\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number_old(nums)\\n   \\n    # Sort in ascending order.\\n    # O(log n)\\n    nums.sort!\\n\\n    gt_zero = nil\\n    lt_zero = nil\\n    # Binary search to find closet numbers above 0 and get its index.\\n    gt_zero_index = nums.bsearch_index{|n| n > 0}\\n    # if we have a non-nil for gt_zero_index, we can check for 0\\n    if gt_zero_index \\n        gt_zero = nums[gt_zero_index]\\n        if gt_zero_index == 0\\n            return gt_zero\\n        elsif gt_zero_index > 0\\n            lt_zero = nums[gt_zero_index - 1]\\n            if lt_zero == 0\\n                return 0\\n            end\\n        end\\n    else\\n        return nums[-1]\\n    end\\n\\n    if gt_zero and lt_zero\\n        if -gt_zero >= lt_zero\\n            return gt_zero\\n        else\\n            lt_zero\\n        end\\n    end\\nend\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Second and Better Solution O(n)\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number(nums)\\n    \\n    gt_zero = 100001\\n    lt_zero = -100001\\n    nums.each do |num|\\n        if num == 0\\n            return 0\\n        elsif num > 0\\n            if num < gt_zero\\n                gt_zero = num\\n            end\\n        elsif num < 0\\n            if num > lt_zero\\n                lt_zero = num\\n            end\\n        end\\n    end\\n\\n    if -gt_zero >= lt_zero\\n        return gt_zero\\n    else\\n        lt_zero\\n    end \\nend\\n\\n# First Solution O(log n)\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_closest_number_old(nums)\\n   \\n    # Sort in ascending order.\\n    # O(log n)\\n    nums.sort!\\n\\n    gt_zero = nil\\n    lt_zero = nil\\n    # Binary search to find closet numbers above 0 and get its index.\\n    gt_zero_index = nums.bsearch_index{|n| n > 0}\\n    # if we have a non-nil for gt_zero_index, we can check for 0\\n    if gt_zero_index \\n        gt_zero = nums[gt_zero_index]\\n        if gt_zero_index == 0\\n            return gt_zero\\n        elsif gt_zero_index > 0\\n            lt_zero = nums[gt_zero_index - 1]\\n            if lt_zero == 0\\n                return 0\\n            end\\n        end\\n    else\\n        return nums[-1]\\n    end\\n\\n    if gt_zero and lt_zero\\n        if -gt_zero >= lt_zero\\n            return gt_zero\\n        else\\n            lt_zero\\n        end\\n    end\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4041621,
                "title": "easy-c-findclosestnumber",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int num=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(abs(num)==abs(nums[i]))\\n                num=max(num,nums[i]);\\n            else if(abs(num)>abs(nums[i]))\\n                num=nums[i];\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int num=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(abs(num)==abs(nums[i]))\\n                num=max(num,nums[i]);\\n            else if(abs(num)>abs(nums[i]))\\n                num=nums[i];\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041502,
                "title": "easy-solution-c-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int num=nums[0];\\n        int diff=abs(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(diff==abs(nums[i]))\\n            {\\n                num=max(num,nums[i]);\\n            }\\n            else if(diff>abs(nums[i]))\\n            {\\n                num=nums[i];\\n                diff=abs(nums[i]);\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int num=nums[0];\\n        int diff=abs(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(diff==abs(nums[i]))\\n            {\\n                num=max(num,nums[i]);\\n            }\\n            else if(diff>abs(nums[i]))\\n            {\\n                num=nums[i];\\n                diff=abs(nums[i]);\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032763,
                "title": "easy-using-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n       int diff=INT_MAX;\\n       int ans;\\n       \\n       for(int i=0;i<nums.size();i++){\\n\\n            if(abs(nums[i])<diff){\\n                 ans=nums[i];\\n                  diff=abs(nums[i]);\\n                  \\n            }\\n            if(diff==abs(nums[i]) && nums[i]>ans){\\n                ans=nums[i];\\n            }\\n\\n       }\\n      return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        \\n       int diff=INT_MAX;\\n       int ans;\\n       \\n       for(int i=0;i<nums.size();i++){\\n\\n            if(abs(nums[i])<diff){\\n                 ans=nums[i];\\n                  diff=abs(nums[i]);\\n                  \\n            }\\n            if(diff==abs(nums[i]) && nums[i]>ans){\\n                ans=nums[i];\\n            }\\n\\n       }\\n      return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030854,
                "title": "c-o-n-solution-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int closest=10e5;\\n        int index=-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i])<closest){\\n//find the element closest to zero in terms of absolute and store index\\n                closest=abs(nums[i]);\\n                index=i;\\n            }\\n//if absolute value of that element is equivalent to the absolute value\\n//of another element, choose the index of the greater one\\n            if(abs(nums[i])==abs(nums[index])){\\n                if(nums[i]>nums[index]){\\n                    index=i;\\n                }\\n            }\\n        }\\n        return nums[index];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int closest=10e5;\\n        int index=-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i])<closest){\\n//find the element closest to zero in terms of absolute and store index\\n                closest=abs(nums[i]);\\n                index=i;\\n            }\\n//if absolute value of that element is equivalent to the absolute value\\n//of another element, choose the index of the greater one\\n            if(abs(nums[i])==abs(nums[index])){\\n                if(nums[i]>nums[index]){\\n                    index=i;\\n                }\\n            }\\n        }\\n        return nums[index];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024038,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype NumWithDistanceEntry = [number, number];\\n\\nfunction findClosestNumber(nums: number[]): number {\\n  const numsWithDistances: { [key: string | number]: number } = {};\\n\\n  nums.forEach((num) => {\\n    numsWithDistances[num] = Math.abs(0 - num);\\n  });\\n\\n  const entriesOfNumsWithDistances: NumWithDistanceEntry[] = Object.entries(\\n    numsWithDistances\\n  ).map((numWithDistance) => [Number(numWithDistance[0]), numWithDistance[1]]);\\n\\n  const sortedEntries = entriesOfNumsWithDistances.sort(\\n    (a: NumWithDistanceEntry, b: NumWithDistanceEntry) => {\\n      if (a[1] === b[1]) {\\n        if (a[0] < b[0]) return 1;\\n        if (a[0] > b[0]) return -1;\\n        return 0;\\n      } else {\\n        return a[1] - b[1];\\n      }\\n    }\\n  );\\n\\n  return sortedEntries[0][0];\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype NumWithDistanceEntry = [number, number];\\n\\nfunction findClosestNumber(nums: number[]): number {\\n  const numsWithDistances: { [key: string | number]: number } = {};\\n\\n  nums.forEach((num) => {\\n    numsWithDistances[num] = Math.abs(0 - num);\\n  });\\n\\n  const entriesOfNumsWithDistances: NumWithDistanceEntry[] = Object.entries(\\n    numsWithDistances\\n  ).map((numWithDistance) => [Number(numWithDistance[0]), numWithDistance[1]]);\\n\\n  const sortedEntries = entriesOfNumsWithDistances.sort(\\n    (a: NumWithDistanceEntry, b: NumWithDistanceEntry) => {\\n      if (a[1] === b[1]) {\\n        if (a[0] < b[0]) return 1;\\n        if (a[0] > b[0]) return -1;\\n        return 0;\\n      } else {\\n        return a[1] - b[1];\\n      }\\n    }\\n  );\\n\\n  return sortedEntries[0][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023940,
                "title": "c-basic-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            mn=min(mn, abs(nums[i]));\\n        }\\n        vector<int> closest;\\n        for(int i=0; i<nums.size(); i++){\\n            if(mn==abs(nums[i])){\\n                closest.push_back(nums[i]);\\n            }\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0; i<closest.size(); i++){\\n            mx=max(mx, closest[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            mn=min(mn, abs(nums[i]));\\n        }\\n        vector<int> closest;\\n        for(int i=0; i<nums.size(); i++){\\n            if(mn==abs(nums[i])){\\n                closest.push_back(nums[i]);\\n            }\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0; i<closest.size(); i++){\\n            mx=max(mx, closest[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014359,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 145 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.6 mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        small=nums[0]\\n        ind=0\\n        for i in range(1,len(nums)):\\n            if(abs(0-small)==abs(0-nums[i])):\\n                if(nums[ind]<nums[i]):\\n                    small=nums[i]\\n                    ind=i\\n            elif(abs(0-small)>abs(0-nums[i])):\\n                small=nums[i]\\n                ind=i\\n        return (nums[ind])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        small=nums[0]\\n        ind=0\\n        for i in range(1,len(nums)):\\n            if(abs(0-small)==abs(0-nums[i])):\\n                if(nums[ind]<nums[i]):\\n                    small=nums[i]\\n                    ind=i\\n            elif(abs(0-small)>abs(0-nums[i])):\\n                small=nums[i]\\n                ind=i\\n        return (nums[ind])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009930,
                "title": "easy-c-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int dist=INT_MAX;\\n        int closest;\\n        for(int i=0; i<nums.size();i++){\\n            if(dist==abs(nums[i])){\\n                closest=max(closest,nums[i]);\\n            }\\n            if(dist>abs(nums[i])) {\\n                dist=min(dist,abs(nums[i]));\\n                closest=nums[i];\\n            }\\n        }\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int dist=INT_MAX;\\n        int closest;\\n        for(int i=0; i<nums.size();i++){\\n            if(dist==abs(nums[i])){\\n                closest=max(closest,nums[i]);\\n            }\\n            if(dist>abs(nums[i])) {\\n                dist=min(dist,abs(nums[i]));\\n                closest=nums[i];\\n            }\\n        }\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990033,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        minval = float(\\'inf\\')\\n        resultval = None\\n        \\n        for i in nums:\\n           if abs(i-0) <= minval:\\n               minval = abs(i-0)\\n               resultval = i\\n        \\n        if resultval < 0 and resultval * -1 in nums:\\n            return resultval * -1\\n        return resultval\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        minval = float(\\'inf\\')\\n        resultval = None\\n        \\n        for i in nums:\\n           if abs(i-0) <= minval:\\n               minval = abs(i-0)\\n               resultval = i\\n        \\n        if resultval < 0 and resultval * -1 in nums:\\n            return resultval * -1\\n        return resultval\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985399,
                "title": "easiest-approach-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int miny = nums[0];\\n        for(int i = 0 ; i < nums.size() ;i++){\\n           if(abs(miny) > abs(nums[i])){\\n                miny = nums[i];\\n                \\n                cout<<miny<<endl;\\n           }\\n            else if(abs(miny) == abs(nums[i])){\\n                    miny = max(miny,nums[i]);\\n                }\\n        }\\n        return miny;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int miny = nums[0];\\n        for(int i = 0 ; i < nums.size() ;i++){\\n           if(abs(miny) > abs(nums[i])){\\n                miny = nums[i];\\n                \\n                cout<<miny<<endl;\\n           }\\n            else if(abs(miny) == abs(nums[i])){\\n                    miny = max(miny,nums[i]);\\n                }\\n        }\\n        return miny;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3985397,
                "title": "easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        //sort(nums.begin(),nums.end());\\n        int close=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(abs(nums[i])<abs(close)){\\n            close=nums[i];\\n            }\\n            else if(abs(nums[i])==abs(close)){\\n                close=max(nums[i],close);\\n            }\\n        }\\n        return close;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        //sort(nums.begin(),nums.end());\\n        int close=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(abs(nums[i])<abs(close)){\\n            close=nums[i];\\n            }\\n            else if(abs(nums[i])==abs(close)){\\n                close=max(nums[i],close);\\n            }\\n        }\\n        return close;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984552,
                "title": "super-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int numberToReturn = nums[0];\\n        int closestDistance = Math.abs(nums[0]);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int absoluteValue = Math.abs(nums[i]);\\n            if (absoluteValue < closestDistance || (absoluteValue == closestDistance && nums[i] > 0)) {\\n                closestDistance = absoluteValue;\\n                numberToReturn = nums[i];\\n            }\\n        }\\n\\n        return numberToReturn;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int numberToReturn = nums[0];\\n        int closestDistance = Math.abs(nums[0]);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int absoluteValue = Math.abs(nums[i]);\\n            if (absoluteValue < closestDistance || (absoluteValue == closestDistance && nums[i] > 0)) {\\n                closestDistance = absoluteValue;\\n                numberToReturn = nums[i];\\n            }\\n        }\\n\\n        return numberToReturn;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984173,
                "title": "c-easy-and-readable-solution-faster-than-79",
                "content": "![image.png](https://assets.leetcode.com/users/images/06cf7501-17b7-4496-99ce-563dc75270b3_1693480501.790987.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int pos = int.MaxValue;\\n        int neg = int.MinValue;\\n        foreach (int n in nums)\\n        {\\n            if (n >= 0)\\n                pos = Math.Min(pos, n);\\n            else\\n                neg = Math.Max(neg, n);\\n        }\\n        return -pos >= neg ? pos : neg;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindClosestNumber(int[] nums) {\\n        int pos = int.MaxValue;\\n        int neg = int.MinValue;\\n        foreach (int n in nums)\\n        {\\n            if (n >= 0)\\n                pos = Math.Min(pos, n);\\n            else\\n                neg = Math.Max(neg, n);\\n        }\\n        return -pos >= neg ? pos : neg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981113,
                "title": "solved-using-simple-iteration",
                "content": "# Intuition\\nThe problem ask to find the largest number with minimum distance to 0. It means we need to find largest negative or smallest positive number.\\n\\n# Approach\\nIdea is to iterate to find min number and also checking if there is positive number at the same distance from 0. If it is, then always return positive number.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int result = Integer.MAX_VALUE;\\n        for(int num: nums)\\n            if(Math.abs(num) < Math.abs(result) || num == Math.abs(result))\\n                result = num;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int result = Integer.MAX_VALUE;\\n        for(int num: nums)\\n            if(Math.abs(num) < Math.abs(result) || num == Math.abs(result))\\n                result = num;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975681,
                "title": "another-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar findClosestNumber = function(nums) {\\n  let plus = [];\\n  let minus = [];\\n  let sP = [];\\n  let sM = [];\\n\\n  if (nums == 0) {\\n    return 0;\\n  } else {\\n    for (let i = 0; i < nums.length; i++) {\\n      if (nums[i] > 0) {\\n        plus.push(nums[i]);\\n      } else {\\n        minus.push(nums[i]);\\n      }\\n    }\\n\\n    sP = plus.sort((a, b) => a - b);\\n    sM = minus.sort((a, b) => b - a);\\n\\n    if (sP.length === 0) {\\n      return sM[0];\\n    } else if (sM.length === 0) {\\n      return sP[0];\\n    } else if (Math.abs(sP[0]) > Math.abs(sM[0])) {\\n      return sM[0];\\n    } else {\\n      return sP[0];\\n    }\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar findClosestNumber = function(nums) {\\n  let plus = [];\\n  let minus = [];\\n  let sP = [];\\n  let sM = [];\\n\\n  if (nums == 0) {\\n    return 0;\\n  } else {\\n    for (let i = 0; i < nums.length; i++) {\\n      if (nums[i] > 0) {\\n        plus.push(nums[i]);\\n      } else {\\n        minus.push(nums[i]);\\n      }\\n    }\\n\\n    sP = plus.sort((a, b) => a - b);\\n    sM = minus.sort((a, b) => b - a);\\n\\n    if (sP.length === 0) {\\n      return sM[0];\\n    } else if (sM.length === 0) {\\n      return sP[0];\\n    } else if (Math.abs(sP[0]) > Math.abs(sM[0])) {\\n      return sM[0];\\n    } else {\\n      return sP[0];\\n    }\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3970639,
                "title": "solution-using-set-o-n-fast-runtime-127ms",
                "content": "![\\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0435_2023-08-28_102818728.png](https://assets.leetcode.com/users/images/b7992d70-f31d-4da5-bbff-d93b15a5ba83_1693207742.3729894.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        closest = set()\\n        cur_min = 10 ** 5 + 1\\n        for num in nums:\\n            if num < 0:\\n                tmp = -num\\n            else:\\n                tmp = num\\n            if tmp < cur_min:\\n                closest.clear()\\n                closest.add(num)\\n                cur_min = tmp\\n            elif tmp == cur_min:\\n                closest.add(num)\\n        return max(closest)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        closest = set()\\n        cur_min = 10 ** 5 + 1\\n        for num in nums:\\n            if num < 0:\\n                tmp = -num\\n            else:\\n                tmp = num\\n            if tmp < cur_min:\\n                closest.clear()\\n                closest.add(num)\\n                cur_min = tmp\\n            elif tmp == cur_min:\\n                closest.add(num)\\n        return max(closest)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969770,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int x = Integer.MAX_VALUE;\\n        int y = 0;\\n        Arrays.sort(nums);\\n        int curr = 0;\\n        for(int i:nums){\\n            curr = Math.abs(0-i);\\n            if(curr<=x){\\n                x = curr;\\n                y = i;\\n            }\\n        }\\n        // if(x==Integer.MAX_VALUE){\\n        //     x = nums[nums.length-1];\\n        // }\\n        return y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int x = Integer.MAX_VALUE;\\n        int y = 0;\\n        Arrays.sort(nums);\\n        int curr = 0;\\n        for(int i:nums){\\n            curr = Math.abs(0-i);\\n            if(curr<=x){\\n                x = curr;\\n                y = i;\\n            }\\n        }\\n        // if(x==Integer.MAX_VALUE){\\n        //     x = nums[nums.length-1];\\n        // }\\n        return y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961128,
                "title": "easy-and-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                idx=i\\n                break\\n        else:\\n            idx=-1\\n        if idx<=0:\\n            return nums[idx]\\n        else:\\n            a=nums[idx]-0\\n            b=0-nums[idx-1]\\n            if b<a:\\n                return nums[idx-1]\\n            else:\\n                return nums[idx]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                idx=i\\n                break\\n        else:\\n            idx=-1\\n        if idx<=0:\\n            return nums[idx]\\n        else:\\n            a=nums[idx]-0\\n            b=0-nums[idx-1]\\n            if b<a:\\n                return nums[idx-1]\\n            else:\\n                return nums[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960567,
                "title": "find-closest-number-to-zero",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nlet findClosestNumber = function(nums) {\\n  let a = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] == 0) {\\n      return 0;\\n    } else if (a === 0) {\\n      a = nums[i];\\n    } else if (nums[i] > 0 && nums[i] <= Math.abs(a)) {\\n      a = nums[i];\\n    } else if (nums[i] < 0 && -nums[i] < Math.abs(a)) {\\n      a = nums[i];\\n    }\\n  }\\n  return a;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nlet findClosestNumber = function(nums) {\\n  let a = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] == 0) {\\n      return 0;\\n    } else if (a === 0) {\\n      a = nums[i];\\n    } else if (nums[i] > 0 && nums[i] <= Math.abs(a)) {\\n      a = nums[i];\\n    } else if (nums[i] < 0 && -nums[i] < Math.abs(a)) {\\n      a = nums[i];\\n    }\\n  }\\n  return a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958001,
                "title": "find-closest-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n Arrays.sort(nums);\\n int des_indx=0;\\n int des_val=nums[0];\\n for(int i:nums){\\n  if(i==0) return 0;\\n  if(i>0){\\n   des_indx=i;\\n   break;   \\n  }\\n  des_val=i;\\n   }\\n   if(des_indx==0) return nums[nums.length-1];\\n   if(Math.abs(des_val)<des_indx)return des_val;\\n   return des_indx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n Arrays.sort(nums);\\n int des_indx=0;\\n int des_val=nums[0];\\n for(int i:nums){\\n  if(i==0) return 0;\\n  if(i>0){\\n   des_indx=i;\\n   break;   \\n  }\\n  des_val=i;\\n   }\\n   if(des_indx==0) return nums[nums.length-1];\\n   if(Math.abs(des_val)<des_indx)return des_val;\\n   return des_indx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956300,
                "title": "simple-js-solution-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    if(!nums || nums.length === 0) {\\n        return 0;\\n    }\\n\\n    let maxVal = Infinity;\\n    let result = Infinity;\\n    nums.forEach((item) => {\\n        if(Math.abs(item) < maxVal) {\\n            maxVal = Math.abs(item);\\n            result = item;\\n        } else if (item === maxVal && item >= 0) {\\n            maxVal = item;\\n            result = item;\\n        }\\n    }); \\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    if(!nums || nums.length === 0) {\\n        return 0;\\n    }\\n\\n    let maxVal = Infinity;\\n    let result = Infinity;\\n    nums.forEach((item) => {\\n        if(Math.abs(item) < maxVal) {\\n            maxVal = Math.abs(item);\\n            result = item;\\n        } else if (item === maxVal && item >= 0) {\\n            maxVal = item;\\n            result = item;\\n        }\\n    }); \\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954431,
                "title": "python-easyyyyyyyyy",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        destance = nums[0]\\n        for i in range(1, len(nums)):\\n            destance = min(abs(destance), abs(0 - nums[i]))\\n        if destance in nums:\\n            return destance\\n        \\n        return -destance\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        destance = nums[0]\\n        for i in range(1, len(nums)):\\n            destance = min(abs(destance), abs(0 - nums[i]))\\n        if destance in nums:\\n            return destance\\n        \\n        return -destance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952503,
                "title": "1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min(nums, key = lambda x: (abs(x), -x))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min(nums, key = lambda x: (abs(x), -x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944051,
                "title": "java-easy-to-understand-linear",
                "content": "```\\nclass Solution {\\n    \\n    public int findClosestNumber(int[] nums) {\\n        \\n        Pair pair = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            \\n            int currDistance = Math.abs(nums[i]) - 0;\\n            \\n            if (pair.distance > currDistance) {\\n                \\n                pair.num = nums[i];\\n                pair.distance = currDistance;\\n                \\n            } else if (pair.distance == currDistance) {\\n                \\n                if (pair.num < nums[i]) {\\n                    pair.num = nums[i];\\n                }\\n            }\\n        }\\n        \\n        return pair.num;\\n    }\\n    \\n    private class Pair {\\n        \\n        int num;\\n        int distance;\\n        \\n        public Pair(int num, int distance) {\\n            \\n            this.distance = distance;\\n            this.num = num;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int findClosestNumber(int[] nums) {\\n        \\n        Pair pair = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            \\n            int currDistance = Math.abs(nums[i]) - 0;\\n            \\n            if (pair.distance > currDistance) {\\n                \\n                pair.num = nums[i];\\n                pair.distance = currDistance;\\n                \\n            } else if (pair.distance == currDistance) {\\n                \\n                if (pair.num < nums[i]) {\\n                    pair.num = nums[i];\\n                }\\n            }\\n        }\\n        \\n        return pair.num;\\n    }\\n    \\n    private class Pair {\\n        \\n        int num;\\n        int distance;\\n        \\n        public Pair(int num, int distance) {\\n            \\n            this.distance = distance;\\n            this.num = num;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939522,
                "title": "c-code-easy-to-understand-and-implement-beats-in-runtime-and-memory",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Try out this way\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int findClosestNumber(vector<int>& nums) {\\n    return *min_element(nums.begin(), nums.end(), [](const int a, const int b) {\\n      return abs(a) == abs(b) ? a > b : abs(a) < abs(b);\\n    });\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int findClosestNumber(vector<int>& nums) {\\n    return *min_element(nums.begin(), nums.end(), [](const int a, const int b) {\\n      return abs(a) == abs(b) ? a > b : abs(a) < abs(b);\\n    });\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939331,
                "title": "one-liner-js-for-the-smallest-bundle-size",
                "content": "Only 100 characters needed.\\n# Code\\n```\\nvar findClosestNumber=a=>a.sort(((a,s)=>Math.abs(a)===Math.abs(s)?s-a:Math.abs(a)-Math.abs(s)))[0];\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findClosestNumber=a=>a.sort(((a,s)=>Math.abs(a)===Math.abs(s)?s-a:Math.abs(a)-Math.abs(s)))[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3939120,
                "title": "absolute-minimal-typescript-solution",
                "content": "```\\n// based on https://leetcode.com/problems/find-closest-number-to-zero/solutions/2163415/simple-javascript-typescript-solution/\\n\\nfunction findClosestNumber(nums: number[]): number {\\n    // you don\\'t have to use Number.MAX_VALUE in JS\\n    let belowZero = -Infinity;\\n    let aboveZero = Infinity;\\n    for (const num of nums) {\\n        if (num < 0) {\\n            // keep track of negative value closest to zero\\n            belowZero = Math.max(belowZero, num);\\n        } else {\\n            // keep track of positive value closest to zero\\n            aboveZero = Math.min(aboveZero, num);\\n        }\\n    }\\n    // compare which value is closest to zero, if they are equal use positive\\n    return aboveZero <= -belowZero ? aboveZero : belowZero;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// based on https://leetcode.com/problems/find-closest-number-to-zero/solutions/2163415/simple-javascript-typescript-solution/\\n\\nfunction findClosestNumber(nums: number[]): number {\\n    // you don\\'t have to use Number.MAX_VALUE in JS\\n    let belowZero = -Infinity;\\n    let aboveZero = Infinity;\\n    for (const num of nums) {\\n        if (num < 0) {\\n            // keep track of negative value closest to zero\\n            belowZero = Math.max(belowZero, num);\\n        } else {\\n            // keep track of positive value closest to zero\\n            aboveZero = Math.min(aboveZero, num);\\n        }\\n    }\\n    // compare which value is closest to zero, if they are equal use positive\\n    return aboveZero <= -belowZero ? aboveZero : belowZero;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938380,
                "title": "easy-to-understand-c-better",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { //\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mini=INT_MAX;\\n        int dis;\\n        int sign;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            dis=abs(nums[i]);\\n            mini=min(dis,mini);\\n            if(dis>mini) break;\\n            sign=nums[i];\\n        }\\n        if(w<0){\\n            mini= mini*(-1);\\n        }\\n        else if(sign>=0){\\n            mini=abs(mini);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { //\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int mini=INT_MAX;\\n        int dis;\\n        int sign;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            dis=abs(nums[i]);\\n            mini=min(dis,mini);\\n            if(dis>mini) break;\\n            sign=nums[i];\\n        }\\n        if(w<0){\\n            mini= mini*(-1);\\n        }\\n        else if(sign>=0){\\n            mini=abs(mini);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930755,
                "title": "beats-100-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int close=9999999;\\n        int ans=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int diff= 0-nums[i];\\n            if(diff<0){\\n                diff=-diff;\\n            }\\n            if(diff<close){\\n                ans=nums[i];\\n                close=diff;\\n            }\\n            if((diff==close)&& nums[i]>ans){\\n                ans=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int close=9999999;\\n        int ans=0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int diff= 0-nums[i];\\n            if(diff<0){\\n                diff=-diff;\\n            }\\n            if(diff<close){\\n                ans=nums[i];\\n                close=diff;\\n            }\\n            if((diff==close)&& nums[i]>ans){\\n                ans=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915792,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind maximum of absolute value of element and if same then replace based on value\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        dis = nums[0]\\n        for i in nums[1:]:\\n            if abs(dis)>abs(i) or (abs(dis)==abs(i) and dis<i):\\n                dis = i\\n        return dis\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        dis = nums[0]\\n        for i in nums[1:]:\\n            if abs(dis)>abs(i) or (abs(dis)==abs(i) and dis<i):\\n                dis = i\\n        return dis\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915182,
                "title": "one-liner-beats-93-81",
                "content": "# Code\\n```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min(nums, key = lambda x: (abs(x), -x))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findClosestNumber(self, nums: List[int]) -> int:\\n        return min(nums, key = lambda x: (abs(x), -x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898231,
                "title": "simple-sol-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int closestNo=nums[0];\\n      for(int i=1; i<nums.length; i++){\\n        if(Math.abs(closestNo)==(nums[i])){\\n            closestNo=nums[i];\\n        }\\n        if(Math.abs(nums[i])<Math.abs(closestNo)){\\n            closestNo=nums[i];\\n        }\\n      }\\n      return closestNo;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n       int closestNo=nums[0];\\n      for(int i=1; i<nums.length; i++){\\n        if(Math.abs(closestNo)==(nums[i])){\\n            closestNo=nums[i];\\n        }\\n        if(Math.abs(nums[i])<Math.abs(closestNo)){\\n            closestNo=nums[i];\\n        }\\n      }\\n      return closestNo;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893045,
                "title": "simple-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    nums.push(0);\\n    nums.sort((a,b)=>a-b);\\n    var ind=0;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            ind=i;\\n            break;\\n        }\\n    }\\n    var ld=Math.abs(nums[ind-1]);\\n    var rd=Math.abs(nums[ind+1]);\\n    if(ind==0)\\n    {\\n        return nums[ind+1];\\n    }\\n    if(ind==nums.length-1)\\n    {\\n        return nums[ind-1];\\n    }\\n    return ld<rd ? nums[ind-1]:nums[ind+1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findClosestNumber = function(nums) {\\n    nums.push(0);\\n    nums.sort((a,b)=>a-b);\\n    var ind=0;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            ind=i;\\n            break;\\n        }\\n    }\\n    var ld=Math.abs(nums[ind-1]);\\n    var rd=Math.abs(nums[ind+1]);\\n    if(ind==0)\\n    {\\n        return nums[ind+1];\\n    }\\n    if(ind==nums.length-1)\\n    {\\n        return nums[ind-1];\\n    }\\n    return ld<rd ? nums[ind-1]:nums[ind+1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892061,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int min=INT_MAX,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int diff=nums[i]-0;\\n            if(abs(diff)<=min){\\n                min=abs(diff);\\n                ans=diff;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int min=INT_MAX,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int diff=nums[i]-0;\\n            if(abs(diff)<=min){\\n                min=abs(diff);\\n                ans=diff;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889512,
                "title": "easy-cpp-solution-beats-90-70-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/29d91988-02b6-4856-97f7-43294ae6d22b_1691654044.1386578.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = INT_MAX;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(abs(nums[i]) == abs(ans))\\n                ans = ans > nums[i] ? ans : nums[i];\\n            else\\n                ans = abs(ans) < abs(nums[i]) ? ans : nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        int ans = INT_MAX;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(abs(nums[i]) == abs(ans))\\n                ans = ans > nums[i] ? ans : nums[i];\\n            else\\n                ans = abs(ans) < abs(nums[i]) ? ans : nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886935,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int close = 0;\\n        int afterMin = false;\\n        int negatif= true;\\n        for(int i = 0; i<nums.size()-1; i++){\\n           if(nums[i]<0){\\n               close = nums[i];\\n                if(abs(nums[i]) >= nums[i+1]){\\n                    close = nums[i+1];\\n                    negatif = false;\\n                }\\n                 afterMin = true;\\n           }else{\\n               if(afterMin){\\n                   if(negatif){\\n                       return -close;\\n                   }\\n                   return close;\\n               }\\n               return nums[i];\\n           }\\n        }\\n        return close;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int close = 0;\\n        int afterMin = false;\\n        int negatif= true;\\n        for(int i = 0; i<nums.size()-1; i++){\\n           if(nums[i]<0){\\n               close = nums[i];\\n                if(abs(nums[i]) >= nums[i+1]){\\n                    close = nums[i+1];\\n                    negatif = false;\\n                }\\n                 afterMin = true;\\n           }else{\\n               if(afterMin){\\n                   if(negatif){\\n                       return -close;\\n                   }\\n                   return close;\\n               }\\n               return nums[i];\\n           }\\n        }\\n        return close;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886829,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=99999999,s=0;\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                s=0-nums[i];\\n            }\\n            else{\\n                s=nums[i]-0;\\n            }\\n            if(min>s){\\n                min=s;}\\n        }\\n       for(int i=0;i<nums.length;i++){\\n           if(min!=nums[i]){\\n               c++;\\n           }\\n       }\\n       if(c==nums.length){\\n           return -min;\\n       }\\n       else{\\n           return  min;\\n       }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=99999999,s=0;\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                s=0-nums[i];\\n            }\\n            else{\\n                s=nums[i]-0;\\n            }\\n            if(min>s){\\n                min=s;}\\n        }\\n       for(int i=0;i<nums.length;i++){\\n           if(min!=nums[i]){\\n               c++;\\n           }\\n       }\\n       if(c==nums.length){\\n           return -min;\\n       }\\n       else{\\n           return  min;\\n       }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886828,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=99999999,s=0;\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                s=0-nums[i];\\n            }\\n            else{\\n                s=nums[i]-0;\\n            }\\n            if(min>s){\\n                min=s;}\\n        }\\n       for(int i=0;i<nums.length;i++){\\n           if(min!=nums[i]){\\n               c++;\\n           }\\n       }\\n       if(c==nums.length){\\n           return -min;\\n       }\\n       else{\\n           return  min;\\n       }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findClosestNumber(int[] nums) {\\n        int min=99999999,s=0;\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                s=0-nums[i];\\n            }\\n            else{\\n                s=nums[i]-0;\\n            }\\n            if(min>s){\\n                min=s;}\\n        }\\n       for(int i=0;i<nums.length;i++){\\n           if(min!=nums[i]){\\n               c++;\\n           }\\n       }\\n       if(c==nums.length){\\n           return -min;\\n       }\\n       else{\\n           return  min;\\n       }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879509,
                "title": "easy-to-understand",
                "content": "# Intuition\\nTheir are two condition to get the result.\\n1. Idea is to get the lowest value.\\n2. To get the max value if we find numbers with same lowest values.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    int findClosestNumber(vector<int>& nums) \\n    {\\n        int diff=INT_MAX,temp,res;\\n        for(auto num:nums)\\n        {\\n            temp=abs(num);\\n            if(temp<diff)\\n            {\\n                res=num;\\n                diff=temp;\\n            }\\n            else if(temp==diff)\\n            {\\n                if(num>0) res=num;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    int findClosestNumber(vector<int>& nums) \\n    {\\n        int diff=INT_MAX,temp,res;\\n        for(auto num:nums)\\n        {\\n            temp=abs(num);\\n            if(temp<diff)\\n            {\\n                res=num;\\n                diff=temp;\\n            }\\n            else if(temp==diff)\\n            {\\n                if(num>0) res=num;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873892,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        //Find the \"closest\" distance to zero\\n        int mini= INT_MAX;\\n        for (int i = 0; i<nums.size(); i++){\\n            mini = min(abs(nums[i]), mini);\\n        }\\n    int ans = INT_MIN;\\n        //Finding the largest value with the min distance\\n        for(int i=0; i<nums.size();i++){\\n            if(abs(nums[i])==mini){\\n                ans = max(nums[i], ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findClosestNumber(vector<int>& nums) {\\n        //Find the \"closest\" distance to zero\\n        int mini= INT_MAX;\\n        for (int i = 0; i<nums.size(); i++){\\n            mini = min(abs(nums[i]), mini);\\n        }\\n    int ans = INT_MIN;\\n        //Finding the largest value with the min distance\\n        for(int i=0; i<nums.size();i++){\\n            if(abs(nums[i])==mini){\\n                ans = max(nums[i], ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871201,
                "title": "simplest-approach-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findClosestNumber(nums: number[]): number {\\n    let closest = nums[0]\\n    let closestDistance = Math.abs(nums[0] - 0)\\n\\n    let closestPositive = null\\n    let closestNegative = null\\n\\n    for(let i = 1; i <= nums.length; i++){\\n        // returns distance in positive to caluclate closest\\n        let distance = Math.abs(nums[i] - 0)\\n        \\n        // calculate the distance\\n        if(distance < closestDistance){\\n            closestDistance = distance\\n            closest = nums[i]\\n        }\\n\\n        if(nums[i] < 0 && (nums[i] < closestNegative) || closestNegative === null ){ // negative number\\n            closestNegative = nums[i]\\n        }else if (nums[i] > 0 && (nums[i] < closestPositive || closestPositive === null)){ // positive number\\n            closestPositive = nums[i]\\n        }\\n\\n    }\\n\\n    // check if positive and negative number is same\\n    if(closestPositive && closestNegative){\\n        if(Math.abs(closestNegative) === closestPositive){\\n            return closest = closestPositive\\n        }\\n    }\\n\\n    return closest\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findClosestNumber(nums: number[]): number {\\n    let closest = nums[0]\\n    let closestDistance = Math.abs(nums[0] - 0)\\n\\n    let closestPositive = null\\n    let closestNegative = null\\n\\n    for(let i = 1; i <= nums.length; i++){\\n        // returns distance in positive to caluclate closest\\n        let distance = Math.abs(nums[i] - 0)\\n        \\n        // calculate the distance\\n        if(distance < closestDistance){\\n            closestDistance = distance\\n            closest = nums[i]\\n        }\\n\\n        if(nums[i] < 0 && (nums[i] < closestNegative) || closestNegative === null ){ // negative number\\n            closestNegative = nums[i]\\n        }else if (nums[i] > 0 && (nums[i] < closestPositive || closestPositive === null)){ // positive number\\n            closestPositive = nums[i]\\n        }\\n\\n    }\\n\\n    // check if positive and negative number is same\\n    if(closestPositive && closestNegative){\\n        if(Math.abs(closestNegative) === closestPositive){\\n            return closest = closestPositive\\n        }\\n    }\\n\\n    return closest\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1794074,
                "content": [
                    {
                        "username": "pranavk2208",
                        "content": "My output:\\n1321\\n\\nExpected Output:\\n-1321\\n\\nCan someone please explain why?"
                    },
                    {
                        "username": "raj20012017",
                        "content": "can you share your test case of your given problem?"
                    },
                    {
                        "username": "HNcodes",
                        "content": "because u might be storing only the magnitude of -1321 as ur ans"
                    },
                    {
                        "username": "Smania",
                        "content": "you should share your code, it\\'s difficult to know what your error is without knowing what is your process (probably an error while assigning an absolute value)"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `\\n\\n       class Solution {\\n             public int findClosestNumber(int[] nums) {\\n                   ArrayList<Integer> p = new ArrayList<>();\\n                   ArrayList<Integer> n = new ArrayList<>();\\n\\n                  int k = nums.length;\\n                  for(int i=0; i<k; i++){\\n                     if(nums[i] < 0){\\n                         nums[i] = nums[i]*-1;\\n                         n.add(nums[i]);\\n                    } else {\\n                        p.add(nums[i]);\\n                   }\\n               }\\n              Collections.sort(p);  \\n              Collections.sort(n);  \\n\\n             int res = 0;\\n            if(p.get(0) < n.get(0) || p.get(0) == n.get(0) ) {\\n                      res = p.get(0);\\n            } else {\\n                    res = -1*n.get(0);\\n            }\\n\\n           return res;\\n\\n            }\\n          }\\n\\n\\n`\\nCan anyone tell What\\'s wrong in this code ?   \\n\\nI am getting this error : \\njava.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 64, java.base/jdk.internal.util.Preconditions.outOfBounds\\n  at line 70, java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex\\n  at line 266, java.base/jdk.internal.util.Preconditions.checkIndex\\n  at line 361, java.base/java.util.Objects.checkIndex\\n  at line 427, java.base/java.util.ArrayList.get\\n  at line 19, Solution.findClosestNumber\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI have run this code in online compiler it runs fine but getting error on leetcode, why?\\n"
                    },
                    {
                        "username": "momen_alshouha",
                        "content": "input :\\nnums = [61488,18221,-1321,90249,-62158,55128,-93476,53905,57644,24630,89599,-95795,-14891,-60298,17690,99022,-24006,-89156,80135,-46303,18812,59924,32024,82924,-47519,-77086,1763,68618,53629,-56957,95485,99630,-7977,31164,94481,-80239,-57749,-3319,-58231,-94841,-19292,33200,-31446,-3528,2229,74241,-19992,-91852,-28073,31453,-74484,35491,38870,-9499,39838,87369,21123,-38616,-89277,-14541,-81586,-18569,-58242,-71216,10816,15086,-10519,51080,53257,-4912,-37142,-16723,-69795,54937,-24920,68970,-10010,-81717,36203,-67939,73877,-58258,-57183,36637,91518,-8492,-57476,50523,62462,73152,-9511,-66761,28333,-87163,5187]\\n\\noutput : 1321\\n\\nexpected: -1321\\n\\nCan anyone explain this test case ? i think valid output returned"
                    },
                    {
                        "username": "Aritra_9",
                        "content": " If there are multiple answers, return the number with the largest value."
                    },
                    {
                        "username": "ravi18kumar",
                        "content": "there is no such value as 1321 is  present in the array . check if you are returning the answer correctly or you are just returning the positive part of count by mistake."
                    }
                ]
            },
            {
                "id": 1976894,
                "content": [
                    {
                        "username": "pranavk2208",
                        "content": "My output:\\n1321\\n\\nExpected Output:\\n-1321\\n\\nCan someone please explain why?"
                    },
                    {
                        "username": "raj20012017",
                        "content": "can you share your test case of your given problem?"
                    },
                    {
                        "username": "HNcodes",
                        "content": "because u might be storing only the magnitude of -1321 as ur ans"
                    },
                    {
                        "username": "Smania",
                        "content": "you should share your code, it\\'s difficult to know what your error is without knowing what is your process (probably an error while assigning an absolute value)"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `\\n\\n       class Solution {\\n             public int findClosestNumber(int[] nums) {\\n                   ArrayList<Integer> p = new ArrayList<>();\\n                   ArrayList<Integer> n = new ArrayList<>();\\n\\n                  int k = nums.length;\\n                  for(int i=0; i<k; i++){\\n                     if(nums[i] < 0){\\n                         nums[i] = nums[i]*-1;\\n                         n.add(nums[i]);\\n                    } else {\\n                        p.add(nums[i]);\\n                   }\\n               }\\n              Collections.sort(p);  \\n              Collections.sort(n);  \\n\\n             int res = 0;\\n            if(p.get(0) < n.get(0) || p.get(0) == n.get(0) ) {\\n                      res = p.get(0);\\n            } else {\\n                    res = -1*n.get(0);\\n            }\\n\\n           return res;\\n\\n            }\\n          }\\n\\n\\n`\\nCan anyone tell What\\'s wrong in this code ?   \\n\\nI am getting this error : \\njava.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 64, java.base/jdk.internal.util.Preconditions.outOfBounds\\n  at line 70, java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex\\n  at line 266, java.base/jdk.internal.util.Preconditions.checkIndex\\n  at line 361, java.base/java.util.Objects.checkIndex\\n  at line 427, java.base/java.util.ArrayList.get\\n  at line 19, Solution.findClosestNumber\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI have run this code in online compiler it runs fine but getting error on leetcode, why?\\n"
                    },
                    {
                        "username": "momen_alshouha",
                        "content": "input :\\nnums = [61488,18221,-1321,90249,-62158,55128,-93476,53905,57644,24630,89599,-95795,-14891,-60298,17690,99022,-24006,-89156,80135,-46303,18812,59924,32024,82924,-47519,-77086,1763,68618,53629,-56957,95485,99630,-7977,31164,94481,-80239,-57749,-3319,-58231,-94841,-19292,33200,-31446,-3528,2229,74241,-19992,-91852,-28073,31453,-74484,35491,38870,-9499,39838,87369,21123,-38616,-89277,-14541,-81586,-18569,-58242,-71216,10816,15086,-10519,51080,53257,-4912,-37142,-16723,-69795,54937,-24920,68970,-10010,-81717,36203,-67939,73877,-58258,-57183,36637,91518,-8492,-57476,50523,62462,73152,-9511,-66761,28333,-87163,5187]\\n\\noutput : 1321\\n\\nexpected: -1321\\n\\nCan anyone explain this test case ? i think valid output returned"
                    },
                    {
                        "username": "Aritra_9",
                        "content": " If there are multiple answers, return the number with the largest value."
                    },
                    {
                        "username": "ravi18kumar",
                        "content": "there is no such value as 1321 is  present in the array . check if you are returning the answer correctly or you are just returning the positive part of count by mistake."
                    }
                ]
            },
            {
                "id": 1849770,
                "content": [
                    {
                        "username": "pranavk2208",
                        "content": "My output:\\n1321\\n\\nExpected Output:\\n-1321\\n\\nCan someone please explain why?"
                    },
                    {
                        "username": "raj20012017",
                        "content": "can you share your test case of your given problem?"
                    },
                    {
                        "username": "HNcodes",
                        "content": "because u might be storing only the magnitude of -1321 as ur ans"
                    },
                    {
                        "username": "Smania",
                        "content": "you should share your code, it\\'s difficult to know what your error is without knowing what is your process (probably an error while assigning an absolute value)"
                    },
                    {
                        "username": "Mohammed_Tanveer_Owais",
                        "content": " `\\n\\n       class Solution {\\n             public int findClosestNumber(int[] nums) {\\n                   ArrayList<Integer> p = new ArrayList<>();\\n                   ArrayList<Integer> n = new ArrayList<>();\\n\\n                  int k = nums.length;\\n                  for(int i=0; i<k; i++){\\n                     if(nums[i] < 0){\\n                         nums[i] = nums[i]*-1;\\n                         n.add(nums[i]);\\n                    } else {\\n                        p.add(nums[i]);\\n                   }\\n               }\\n              Collections.sort(p);  \\n              Collections.sort(n);  \\n\\n             int res = 0;\\n            if(p.get(0) < n.get(0) || p.get(0) == n.get(0) ) {\\n                      res = p.get(0);\\n            } else {\\n                    res = -1*n.get(0);\\n            }\\n\\n           return res;\\n\\n            }\\n          }\\n\\n\\n`\\nCan anyone tell What\\'s wrong in this code ?   \\n\\nI am getting this error : \\njava.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0\\n  at line 64, java.base/jdk.internal.util.Preconditions.outOfBounds\\n  at line 70, java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex\\n  at line 266, java.base/jdk.internal.util.Preconditions.checkIndex\\n  at line 361, java.base/java.util.Objects.checkIndex\\n  at line 427, java.base/java.util.ArrayList.get\\n  at line 19, Solution.findClosestNumber\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI have run this code in online compiler it runs fine but getting error on leetcode, why?\\n"
                    },
                    {
                        "username": "momen_alshouha",
                        "content": "input :\\nnums = [61488,18221,-1321,90249,-62158,55128,-93476,53905,57644,24630,89599,-95795,-14891,-60298,17690,99022,-24006,-89156,80135,-46303,18812,59924,32024,82924,-47519,-77086,1763,68618,53629,-56957,95485,99630,-7977,31164,94481,-80239,-57749,-3319,-58231,-94841,-19292,33200,-31446,-3528,2229,74241,-19992,-91852,-28073,31453,-74484,35491,38870,-9499,39838,87369,21123,-38616,-89277,-14541,-81586,-18569,-58242,-71216,10816,15086,-10519,51080,53257,-4912,-37142,-16723,-69795,54937,-24920,68970,-10010,-81717,36203,-67939,73877,-58258,-57183,36637,91518,-8492,-57476,50523,62462,73152,-9511,-66761,28333,-87163,5187]\\n\\noutput : 1321\\n\\nexpected: -1321\\n\\nCan anyone explain this test case ? i think valid output returned"
                    },
                    {
                        "username": "Aritra_9",
                        "content": " If there are multiple answers, return the number with the largest value."
                    },
                    {
                        "username": "ravi18kumar",
                        "content": "there is no such value as 1321 is  present in the array . check if you are returning the answer correctly or you are just returning the positive part of count by mistake."
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Lattice Points Inside a Circle",
        "question_content": "<p>Given a 2D integer array <code>circles</code> where <code>circles[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code> represents the center <code>(x<sub>i</sub>, y<sub>i</sub>)</code> and radius <code>r<sub>i</sub></code> of the <code>i<sup>th</sup></code> circle drawn on a grid, return <em>the <strong>number of lattice points</strong> </em><em>that are present inside <strong>at least one</strong> circle</em>.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A <strong>lattice point</strong> is a point with integer coordinates.</li>\n\t<li>Points that lie <strong>on the circumference of a circle</strong> are also considered to be inside it.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-11.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> circles = [[2,2,1]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nThe figure above shows the given circle.\nThe lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.\nOther points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.\nHence, the number of lattice points present inside at least one circle is 5.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-22.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> circles = [[2,2,2],[3,4,1]]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong>\nThe figure above shows the given circles.\nThere are exactly 16 lattice points which are present inside at least one circle. \nSome of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= circles.length &lt;= 200</code></li>\n\t<li><code>circles[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>1 &lt;= r<sub>i</sub> &lt;= min(x<sub>i</sub>, y<sub>i</sub>)</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1976815,
                "title": "easy-c-code",
                "content": "Let r be the radius of the circle.\\nWe iterate from -r to +r in x-direction and y-direction. So we iterate over entire integer co-ordinates of the boundary square and find if it is inside a circle or not using Euclidean distance.\\nWe insert all the co-ordinates in a set to avoid duplicates and return the size of set.\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& v) { // v is vector of circles.\\n        int n = v.size();\\n        set<pair<int,int>> s;\\n        for(int i=0;i<n;i++){\\n            int a=v[i][0],b=v[i][1],r=v[i][2];\\n            for(int x=-r;x<=r;x++){\\n                for(int y=-r;y<=r;y++){\\n                    if((x*x)+(y*y)<=(r*r)){\\n                        s.insert({x+a,y+b});\\n                    }\\n                }\\n            }\\n        }\\n        int ans = s.size();\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach in O(1) space**\\nFrom the given constraints we can notice that the lattice points lie in a certain range, where the co-ordinates are as:\\n*0<=x<=200  and 0<=y<=200*\\nSo we iterate over every point from the range and check whether, it is present in any of the circle or not.\\nSo this way, we can reduce the space complexity just by counting every point once.\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& v) { // v is vector of circles.\\n        int n = v.size();\\n        int ans = 0;\\n        for(int x=0;x<=200;x++){\\n            for(int y=0;y<=200;y++){\\n                for(int i=0;i<n;i++){\\n                    int a=v[i][0],b=v[i][1],r=v[i][2];\\n                    if((a-x)*(a-x) + (b-y)*(b-y) <= r*r){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Upvote if it helps !**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& v) { // v is vector of circles.\\n        int n = v.size();\\n        set<pair<int,int>> s;\\n        for(int i=0;i<n;i++){\\n            int a=v[i][0],b=v[i][1],r=v[i][2];\\n            for(int x=-r;x<=r;x++){\\n                for(int y=-r;y<=r;y++){\\n                    if((x*x)+(y*y)<=(r*r)){\\n                        s.insert({x+a,y+b});\\n                    }\\n                }\\n            }\\n        }\\n        int ans = s.size();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& v) { // v is vector of circles.\\n        int n = v.size();\\n        int ans = 0;\\n        for(int x=0;x<=200;x++){\\n            for(int y=0;y<=200;y++){\\n                for(int i=0;i<n;i++){\\n                    int a=v[i][0],b=v[i][1],r=v[i][2];\\n                    if((a-x)*(a-x) + (b-y)*(b-y) <= r*r){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976808,
                "title": "distance-formula-java",
                "content": "\\n    public int countLatticePoints(int[][] circles) {\\n        HashSet<String> res = new HashSet<String>();\\n        for(int[] arr : circles){\\n            int x = arr[0], y = arr[1], r = arr[2];\\n            for(int i=x-r; i<=x+r; i++)\\n                for(int j=y-r; j<=y+r; j++)\\n                    if((x-i)*(x-i) + (y-j)*(y-j) <= r*r)\\n                        res.add(i+\",\"+j);\\n        }\\n        return res.size();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int countLatticePoints(int[][] circles) {\\n        HashSet<String> res = new HashSet<String>();\\n        for(int[] arr : circles){\\n            int x = arr[0], y = arr[1], r = arr[2];\\n            for(int i=x-r; i<=x+r; i++)\\n                for(int j=y-r; j<=y+r; j++)\\n                    if((x-i)*(x-i) + (y-j)*(y-j) <= r*r)\\n                        res.add(i+\",\"+j);\\n        }\\n        return res.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1980902,
                "title": "java-c-python-o-1-space",
                "content": "Updated this post, \\nsince I noticed almost every solutions will use `set`,\\nwith extra space complexity.\\n<br>\\n# **Solution 1: Set**\\n## **Explanation**\\nFor each circle `(x, y)`,\\nenumerate `i` from `x - r` to `x + r`\\nenumerate `j` from `y - r` to `y + r`\\nCheck if `(i, j)` in this circle.\\n\\nIf so, add the point to a set `res` to de-duplicate.\\n<br>\\n\\n## **Complexity**\\nTime `O(NRR)`\\nSpace `O(XY)`\\nwhere `R = 100` is maximum radius of circles.\\n\\nActual run time depends on circles area in test cases.\\n<br>\\n\\n**Java**\\n```java\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Integer> res = new HashSet<>();\\n        for (int[] c : circles)\\n            for (int i = -c[2]; i <= c[2]; i++)\\n                for (int j = -c[2]; j <= c[2]; j++)\\n                    if (i * i + j * j <= c[2] * c[2])\\n                        res.add((c[0] + i) * 1000 + c[1] + j);\\n        return res.size();\\n    }\\n```\\n**C++**\\n```cpp\\n    int countLatticePoints(vector<vector<int>> circles) {\\n        unordered_set<int> res;\\n        for (auto& c : circles)\\n            for (int i = -c[2]; i <= c[2]; i++)\\n                for (int j = -c[2]; j <= c[2]; j++)\\n                    if (i * i + j * j <= c[2] * c[2])\\n                        res.insert((c[0] + i) * 1000 + c[1] + j);\\n        return res.size();\\n    }\\n```\\n**Python3**\\n```py\\n    def countLatticePoints(self, A: List[List[int]]) -> int:\\n        res = set()\\n        for x,y,r in A:\\n            for i in range(x - r,x + r + 1):\\n                for j in range(y - r, y + r + 1):\\n                    if (x - i) ** 2 + (y - j) ** 2 <= r * r:\\n                        res.add((i,j))\\n        return len(res)\\n```\\n\\n# **Solution 2: Check all points, O(1) space**\\n## **Explanation**\\nFor each point `(i, j)` in the plan,\\nenumerate `i` from `0` to `200`\\nenumerate `j` from `0` to `200`\\nCheck if `(i, j)` in any circle.\\n<br>\\n\\n## **Complexity**\\nSame time complexity, `O(1)` space.\\n\\nTime `O(NXY)`\\nSpace `O(1)`\\nwhere `X = 100` is the range of `xi`\\nwhere `Y = 100` is the range of `yi`\\n<br>\\n\\n**Java**\\n```java\\n    public int countLatticePoints(int[][] circles) {\\n        int res = 0;\\n        for (int i = 0; i <= 200; i++) {\\n            for (int j = 0; j <= 200; j++) {\\n                for (int[] c : circles) {\\n                    if ((c[0] - i) * (c[0] - i) + (c[1] - j) * (c[1] - j) <= c[2] * c[2]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int res = 0;\\n        for (int i = 0; i <= 200; i++)\\n            for (int j = 0; j <= 200; j++) {\\n                for (auto& c : circles) {\\n                    if ((c[0] - i) * (c[0] - i) + (c[1] - j) * (c[1] - j) <= c[2] * c[2]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Integer> res = new HashSet<>();\\n        for (int[] c : circles)\\n            for (int i = -c[2]; i <= c[2]; i++)\\n                for (int j = -c[2]; j <= c[2]; j++)\\n                    if (i * i + j * j <= c[2] * c[2])\\n                        res.add((c[0] + i) * 1000 + c[1] + j);\\n        return res.size();\\n    }\\n```\n```cpp\\n    int countLatticePoints(vector<vector<int>> circles) {\\n        unordered_set<int> res;\\n        for (auto& c : circles)\\n            for (int i = -c[2]; i <= c[2]; i++)\\n                for (int j = -c[2]; j <= c[2]; j++)\\n                    if (i * i + j * j <= c[2] * c[2])\\n                        res.insert((c[0] + i) * 1000 + c[1] + j);\\n        return res.size();\\n    }\\n```\n```py\\n    def countLatticePoints(self, A: List[List[int]]) -> int:\\n        res = set()\\n        for x,y,r in A:\\n            for i in range(x - r,x + r + 1):\\n                for j in range(y - r, y + r + 1):\\n                    if (x - i) ** 2 + (y - j) ** 2 <= r * r:\\n                        res.add((i,j))\\n        return len(res)\\n```\n```java\\n    public int countLatticePoints(int[][] circles) {\\n        int res = 0;\\n        for (int i = 0; i <= 200; i++) {\\n            for (int j = 0; j <= 200; j++) {\\n                for (int[] c : circles) {\\n                    if ((c[0] - i) * (c[0] - i) + (c[1] - j) * (c[1] - j) <= c[2] * c[2]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int res = 0;\\n        for (int i = 0; i <= 200; i++)\\n            for (int j = 0; j <= 200; j++) {\\n                for (auto& c : circles) {\\n                    if ((c[0] - i) * (c[0] - i) + (c[1] - j) * (c[1] - j) <= c[2] * c[2]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1976978,
                "title": "python-explanation-with-pictures-set",
                "content": "We only need to search lattice points within one quater circle.\\n\\n![image](https://assets.leetcode.com/users/images/b80fa9e6-d4d7-41dd-8888-fcf545791969_1650773344.8191261.png)\\n\\n**code**\\n\\n```\\ndef countLatticePoints(self, A: List[List[int]]) -> int:\\n\\tans = set()\\n\\tfor x,y,r in A:\\n\\t\\tfor cx in range(x + 1, x + r + 1):\\n\\t\\t\\tfor cy in range(y + 1, y + r + 1):\\n\\t\\t\\t\\tif (cx - x) ** 2 + (cy - y) ** 2 <= r ** 2:\\n\\t\\t\\t\\t\\tans.add((cx, cy))\\n\\t\\t\\t\\t\\tans.add((2 * x - cx, cy))\\n\\t\\t\\t\\t\\tans.add((2 * x - cx, 2 * y - cy))\\n\\t\\t\\t\\t\\tans.add((cx, 2 * y - cy))\\n\\t\\tfor cy in range(y - r, y + r + 1): ans.add((x, cy))\\n\\t\\tfor cx in range(x - r, x + r + 1): ans.add((cx, y))\\n\\treturn len(ans)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countLatticePoints(self, A: List[List[int]]) -> int:\\n\\tans = set()\\n\\tfor x,y,r in A:\\n\\t\\tfor cx in range(x + 1, x + r + 1):\\n\\t\\t\\tfor cy in range(y + 1, y + r + 1):\\n\\t\\t\\t\\tif (cx - x) ** 2 + (cy - y) ** 2 <= r ** 2:\\n\\t\\t\\t\\t\\tans.add((cx, cy))\\n\\t\\t\\t\\t\\tans.add((2 * x - cx, cy))\\n\\t\\t\\t\\t\\tans.add((2 * x - cx, 2 * y - cy))\\n\\t\\t\\t\\t\\tans.add((cx, 2 * y - cy))\\n\\t\\tfor cy in range(y - r, y + r + 1): ans.add((x, cy))\\n\\t\\tfor cx in range(x - r, x + r + 1): ans.add((cx, y))\\n\\treturn len(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1976865,
                "title": "c-easy-to-understand-set-pair",
                "content": "***Please upvote if you find it useful in any way to keep me motivated. : )***\\n```\\nclass Solution {\\npublic:\\n    void find(set<pair<int,int>>&s,vector<int>v)\\n    {\\n        int x=v[0], y=v[1], r=v[2];\\n        \\n        for(int i=x-r;i<=x+r;i++)\\n            for(int j=y-r;j<=y+r;j++)\\n                if(sqrt((x-i)*(x-i) + (y-j)*(y-j)) <= r)      //checks if distance of point from center is les than or equal to radius\\n                    s.insert({i,j});\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;     //used set to store valid points as it does not store same points again(if there are in different circles) \\n        \\n        for(int i=0;i<circles.size();i++)\\n            find(s,circles[i]);\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(set<pair<int,int>>&s,vector<int>v)\\n    {\\n        int x=v[0], y=v[1], r=v[2];\\n        \\n        for(int i=x-r;i<=x+r;i++)\\n            for(int j=y-r;j<=y+r;j++)\\n                if(sqrt((x-i)*(x-i) + (y-j)*(y-j)) <= r)      //checks if distance of point from center is les than or equal to radius\\n                    s.insert({i,j});\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;     //used set to store valid points as it does not store same points again(if there are in different circles) \\n        \\n        for(int i=0;i<circles.size();i++)\\n            find(s,circles[i]);\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977167,
                "title": "python-128-ms-beat-100",
                "content": "Given the constraint, all points are witnin the first quadrant with `x <= 200, y<= 200`. Therefore, we\\'ll just record the intervals on each `x` coordinate. Then we\\'ll just merge the intervals for each `x` coordinate.\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        intervals = [[] for _ in range(201)]\\n        for x, y, r in circles:\\n            for i in range(-r, r + 1):\\n                d = math.floor(math.sqrt(r**2 - i**2))\\n\\t\\t\\t\\t# Add [start, 0] and [end, 1] to the list of intervals.\\n                intervals[x + i].append([y - d, 0])\\n                intervals[x + i].append([y + d, 1])\\n        res = 0\\n\\n        for l in intervals:\\n            if l:\\n                l.sort()\\n\\t\\t\\t\\t# count of open intervals.\\n                count = 0\\n                for i, ind in l:\\n                    if count == 0:\\n                        s = i\\n                    if ind == 0:\\n                        count += 1\\n                    else:\\n                        count -= 1\\n                        if count == 0:\\n                            res += i - s + 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        intervals = [[] for _ in range(201)]\\n        for x, y, r in circles:\\n            for i in range(-r, r + 1):\\n                d = math.floor(math.sqrt(r**2 - i**2))\\n\\t\\t\\t\\t# Add [start, 0] and [end, 1] to the list of intervals.\\n                intervals[x + i].append([y - d, 0])\\n                intervals[x + i].append([y + d, 1])\\n        res = 0\\n\\n        for l in intervals:\\n            if l:\\n                l.sort()\\n\\t\\t\\t\\t# count of open intervals.\\n                count = 0\\n                for i, ind in l:\\n                    if count == 0:\\n                        s = i\\n                    if ind == 0:\\n                        count += 1\\n                    else:\\n                        count -= 1\\n                        if count == 0:\\n                            res += i - s + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984072,
                "title": "square-region",
                "content": "For each circle, we enumerate all lattice points of the square region. If that point is within the radius, we increase the number of points.\\n\\nWe use 2-d array (`g`) to make sure we count \"shared\" lattice points once.\\n\\n**C++**\\n```cpp\\nint countLatticePoints(vector<vector<int>>& circles) {\\n    int res = 0, g[201][201] = {};\\n    for (const auto &c : circles)\\n        for (int dx = -c[2]; dx <= c[2]; ++dx)\\n            for (int dy = -c[2]; dy <= c[2]; ++dy)\\n                if (dx * dx + dy * dy <= c[2] * c[2])\\n                    res += ++g[c[0] + dx][c[1] + dy] == 1;\\n    return res;\\n}  \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countLatticePoints(vector<vector<int>>& circles) {\\n    int res = 0, g[201][201] = {};\\n    for (const auto &c : circles)\\n        for (int dx = -c[2]; dx <= c[2]; ++dx)\\n            for (int dy = -c[2]; dy <= c[2]; ++dy)\\n                if (dx * dx + dy * dy <= c[2] * c[2])\\n                    res += ++g[c[0] + dx][c[1] + dy] == 1;\\n    return res;\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977060,
                "title": "c-easy-solution-0ms-faster",
                "content": "\\'\\'\\'\\npoints will range from \\n    x-r to x+r\\n    y-r to y+r \\n    if set already contains the points it means point are already counted and cannot be             \\n    counted   again\\n\\telse if distance of points from center is <=r insert it in set\\n\\t\\nclass Solution {\\npublic:\\n\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> se;\\n        int n=circles.size();\\n        for(int i=0;i<n;i++){\\n            for(int x1=circles[i][0]-r;x1<=circles[i][0]+r;x1++){\\n                for(int y1=circles[i][1]-r;y1<=circles[i][1]+r;y1++){\\n                    if(se.count({x1,y1}))  continue;\\n                    else if(sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1))<=(double)circles[i][2]){\\n                        se.insert({x1,y1});\\n                    }\\n                }\\n            }\\n        }\\n        return se.size();\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> se;\\n        int n=circles.size();\\n        for(int i=0;i<n;i++){\\n            for(int x1=circles[i][0]-r;x1<=circles[i][0]+r;x1++){\\n                for(int y1=circles[i][1]-r;y1<=circles[i][1]+r;y1++){\\n                    if(se.count({x1,y1}",
                "codeTag": "Java"
            },
            {
                "id": 1977036,
                "title": "why-search-in-2r-2r-square-why-not-2r-2-sqrt-r-r-x-x",
                "content": "When `r = 100` and `dx = -100`, are you still going to search `dy` from `-100` to `100`??\\nNearly all of solutions are doing\\n```\\nfor (int dx = -r; dx <= r; dx++)\\n\\tfor (int dy = -r; dy <= r; dy++) if (dx*dx+dy*dy <= r)\\n\\t{ ... }\\n```\\nWhy not\\n```\\nfor (int dx = -r; dx <= r; dx++)\\n{\\n\\tint mxdy = sqrt(r*r-dx*dx)\\n\\tfor (int dy = -mxdy; dy <= mxdy; dy++)\\n\\t{ ... }\\n}\\n```\\nFor a specific `dx`, since `dx*dx+dy*dy <= r*r`, then `dy*dy <= r*r-dx*dx`. So we just need to search `dy` from `-sqrt(r*r-dx*dx)` to `sqrt(r*r-dx*dx)`",
                "solutionTags": [],
                "code": "```\\nfor (int dx = -r; dx <= r; dx++)\\n\\tfor (int dy = -r; dy <= r; dy++) if (dx*dx+dy*dy <= r)\\n\\t{ ... }\\n```\n```\\nfor (int dx = -r; dx <= r; dx++)\\n{\\n\\tint mxdy = sqrt(r*r-dx*dx)\\n\\tfor (int dy = -mxdy; dy <= mxdy; dy++)\\n\\t{ ... }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976883,
                "title": "simple-brute-force-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        int n=circles.size(),count=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                for(int p=0;p<n;p++)\\n                {\\n                    int x=circles[p][0];\\n                    int y=circles[p][1];\\n                    int r=circles[p][2];\\n                    \\n                    if(((x-i)*(x-i)+(y-j)*(y-j))<=r*r) \\n                    {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n       \\n    }\\n};\\nGuys,plz upvote,if found helpful",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        int n=circles.size(),count=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                for(int p=0;p<n;p++)\\n                {\\n                    int x=circles[p][0];\\n                    int y=circles[p][1];\\n                    int r=circles[p][2];\\n                    \\n                    if(((x-i)*(x-i)+(y-j)*(y-j))<=r*r) \\n                    {\\n                        count++;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1986669,
                "title": "easy-cpp-solution-store-all-points-in-set",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>st;\\n        for(int i=0;i<circles.size();i++){\\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n            int xl=x-r;\\n            int xr=x+r;\\n            int yl=y-r;\\n            int yr=y+r;\\n            for(int j=xl;j<=xr;j++){\\n                for(int k=yl;k<=yr;k++){\\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=(r*r))\\n                    st.insert({j,k});\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>st;\\n        for(int i=0;i<circles.size();i++){\\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n            int xl=x-r;\\n            int xr=x+r;\\n            int yl=y-r;\\n            int yr=y+r;\\n            for(int j=xl;j<=xr;j++){\\n                for(int k=yl;k<=yr;k++){\\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=(r*r))\\n                    st.insert({j,k}",
                "codeTag": "Java"
            },
            {
                "id": 1977054,
                "title": "c-brute-force-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& nums) {\\n       set<pair<int,int>> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i][0];\\n            int y=nums[i][1];\\n            int r=nums[i][2];\\n            for(int xp=x-r;xp<=x+r;xp++)\\n            {\\n                for(int yp=y-r;yp<=y+r;yp++){\\n                // cout<<xp<<\" \"<<yp<<endl;\\n                   if( sqrt((x-xp)*(x-xp)+(y-yp)*(y-yp))<=r)\\n                        s.insert({xp,yp}); \\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& nums) {\\n       set<pair<int,int>> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i][0];\\n            int y=nums[i][1];\\n            int r=nums[i][2];\\n            for(int xp=x-r;xp<=x+r;xp++)\\n            {\\n                for(int yp=y-r;yp<=y+r;yp++){\\n                // cout<<xp<<\" \"<<yp<<endl;\\n                   if( sqrt((x-xp)*(x-xp)+(y-yp)*(y-yp))<=r)\\n                        s.insert({xp,yp}); \\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1976828,
                "title": "python-set-solution-easy",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        res = set()\\n        \\n        def point(x, y, r):\\n            nonlocal res\\n            \\n            for a in range(x-r, x+r+1):\\n                for b in range(y-r, y+r+1):\\n                    if (a-x)*(a-x) + (b-y)*(b-y) <= r*r:\\n                        res.add((a,b))\\n\\n            return res\\n            \\n        for x in circles:\\n            \\n            point(x[0],x[1],x[2])\\n            \\n        return len(res)\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        res = set()\\n        \\n        def point(x, y, r):\\n            nonlocal res\\n            \\n            for a in range(x-r, x+r+1):\\n                for b in range(y-r, y+r+1):\\n                    if (a-x)*(a-x) + (b-y)*(b-y) <= r*r:\\n                        res.add((a,b))\\n\\n            return res\\n            \\n        for x in circles:\\n            \\n            point(x[0],x[1],x[2])\\n            \\n        return len(res)\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2034508,
                "title": "count-lattice-points-inside-a-circle-c",
                "content": "```\\n# Points lie from i=(x-r to x+r) to j=(y-r to y+r)\\n# Any point that lies in the circle should follow the equation (i-x)^2+(j-y)^2<=r^2\\n# [x=2,y=2,r=1]\\n# (i : x should lie from (1,3))\\n# (j : y should lie from (1,3))\\n# ((i-x)^2+(j-y)^2<=r^2)=>add in set\\n```\\n```\\nclass Solution \\n{\\n  public:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<pair<int,int>>st;\\n        for(auto circle:circles)\\n        {\\n            int x=circle[0];\\n            int y=circle[1];\\n            int r=circle[2];\\n            for(int i=x-r;i<=r+x;i++)\\n            {\\n                for(int j=y-r;j<=r+y;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        st.insert({i,j});\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n# Points lie from i=(x-r to x+r) to j=(y-r to y+r)\\n# Any point that lies in the circle should follow the equation (i-x)^2+(j-y)^2<=r^2\\n# [x=2,y=2,r=1]\\n# (i : x should lie from (1,3))\\n# (j : y should lie from (1,3))\\n# ((i-x)^2+(j-y)^2<=r^2)=>add in set\\n```\n```\\nclass Solution \\n{\\n  public:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<pair<int,int>>st;\\n        for(auto circle:circles)\\n        {\\n            int x=circle[0];\\n            int y=circle[1];\\n            int r=circle[2];\\n            for(int i=x-r;i<=r+x;i++)\\n            {\\n                for(int j=y-r;j<=r+y;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        st.insert({i,j});\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001127,
                "title": "c-solution-with-set",
                "content": "\\n   \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        int n = circles.size();\\n        for(int i=0;i<n;i++){\\n            int a = circles[i][0],b = circles[i][1],c = circles[i][2];\\n            for(int j=c-a;j<=c+a;j++){\\n                for(int k=c-b;k<=c+b;k++){\\n                   if((j-a)*(j-a) + (k-b)*(k-b) <= c*c){\\n                       s.insert({j,k});\\n                   }\\n                }\\n            }\\n        }\\n        return s.size();\\n\\t}",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "\\n   \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        int n = circles.size();\\n        for(int i=0;i<n;i++){\\n            int a = circles[i][0],b = circles[i][1],c = circles[i][2];\\n            for(int j=c-a;j<=c+a;j++){\\n                for(int k=c-b;k<=c+b;k++){\\n                   if((j-a)*(j-a) + (k-b)*(k-b) <= c*c){\\n                       s.insert({j,k});\\n                   }\\n                }\\n            }\\n        }\\n        return s.size();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1978460,
                "title": "easiest-c-brute-force-approach",
                "content": "Check for all the points inside the circle\\n```\\nint countLatticePoints(vector<vector<int>>& c) {\\n        set <pair<int,int>> st;\\n        int n = c.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=c[i][0],y=c[i][1],r=c[i][2];\\n            for(int x1=-r;x1<=r;x1++)\\n            {\\n                for(int y1=-r;y1<=r;y1++)\\n                {\\n                    if(((x1*x1)+(y1*y1))<=(r*r))\\n                    {\\n                        st.insert({x+x1,y+y1});\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint countLatticePoints(vector<vector<int>>& c) {\\n        set <pair<int,int>> st;\\n        int n = c.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=c[i][0],y=c[i][1],r=c[i][2];\\n            for(int x1=-r;x1<=r;x1++)\\n            {\\n                for(int y1=-r;y1<=r;y1++)\\n                {\\n                    if(((x1*x1)+(y1*y1))<=(r*r))\\n                    {\\n                        st.insert({x+x1,y+y1});\\n                    }\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976953,
                "title": "using-the-right-data-structure-is-important",
                "content": "I initially used a vector in set to store the output instead of pair. That gave me TLE the whole time and I was not able to submit the code on time.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<vector<int>> s;\\n        sort(circles.begin(),circles.end());\\n        for(int i=circles.size()-1;i>=0;i--)\\n        {\\n            int xc=circles[i][0];\\n            int yc=circles[i][1];\\n            int rad=circles[i][2];\\n            \\n            for(int x=xc-rad;x<=xc+rad;x++)\\n            {\\n                for(int y=yc-rad;y<=yc+rad;y++)\\n                {\\n                    int equation= pow(x-xc,2)+pow(y-yc,2)-rad*rad;\\n                    if(equation<=0)\\n                    {\\n                        vector<int> temp{x,y};\\n                        s.insert(temp);\\n                        \\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```\\n\\n\\nThen, after the contest I used pair, and it submits perfectly fine. Important lesson learnt today.\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<pair<int,int>> s;\\n        sort(circles.begin(),circles.end());\\n        for(int i=circles.size()-1;i>=0;i--)\\n        {\\n            int xc=circles[i][0];\\n            int yc=circles[i][1];\\n            int rad=circles[i][2];\\n            \\n            for(int x=xc-rad;x<=xc+rad;x++)\\n            {\\n                for(int y=yc-rad;y<=yc+rad;y++)\\n                {\\n                    int equation= pow(x-xc,2)+pow(y-yc,2)-rad*rad;\\n                    if(equation<=0)\\n                    {\\n                        s.insert({x,y});\\n                        \\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<vector<int>> s;\\n        sort(circles.begin(),circles.end());\\n        for(int i=circles.size()-1;i>=0;i--)\\n        {\\n            int xc=circles[i][0];\\n            int yc=circles[i][1];\\n            int rad=circles[i][2];\\n            \\n            for(int x=xc-rad;x<=xc+rad;x++)\\n            {\\n                for(int y=yc-rad;y<=yc+rad;y++)\\n                {\\n                    int equation= pow(x-xc,2)+pow(y-yc,2)-rad*rad;\\n                    if(equation<=0)\\n                    {\\n                        vector<int> temp{x,y};\\n                        s.insert(temp);\\n                        \\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        set<pair<int,int>> s;\\n        sort(circles.begin(),circles.end());\\n        for(int i=circles.size()-1;i>=0;i--)\\n        {\\n            int xc=circles[i][0];\\n            int yc=circles[i][1];\\n            int rad=circles[i][2];\\n            \\n            for(int x=xc-rad;x<=xc+rad;x++)\\n            {\\n                for(int y=yc-rad;y<=yc+rad;y++)\\n                {\\n                    int equation= pow(x-xc,2)+pow(y-yc,2)-rad*rad;\\n                    if(equation<=0)\\n                    {\\n                        s.insert({x,y});\\n                        \\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976908,
                "title": "c-set-brute-force-compute-all-possible-points",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void help(set<pair<int,int>> &st,vector<int> &arr){\\n        for(int i=arr[0]-arr[2];i<=arr[0]+arr[2];i++){\\n            for(int j=arr[1]-arr[2];j<=arr[1]+arr[2];j++){\\n                int dis = ((i-arr[0])*(i-arr[0]))+((j-arr[1])*(j-arr[1]));\\n                if(dis<=(arr[2]*arr[2])){\\n                    st.insert({i,j});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& nums) {\\n        set<pair<int,int>> st;\\n        for(int i=0;i<nums.size();i++){\\n            help(st,nums[i]);\\n        }\\n        // for(auto it : st){\\n        //     cout<<it.first<<\" \"<<it.second<<\"\\\\n\";\\n        // }\\n        // cout<<\"\\\\n\";\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void help(set<pair<int,int>> &st,vector<int> &arr){\\n        for(int i=arr[0]-arr[2];i<=arr[0]+arr[2];i++){\\n            for(int j=arr[1]-arr[2];j<=arr[1]+arr[2];j++){\\n                int dis = ((i-arr[0])*(i-arr[0]))+((j-arr[1])*(j-arr[1]));\\n                if(dis<=(arr[2]*arr[2])){\\n                    st.insert({i,j});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& nums) {\\n        set<pair<int,int>> st;\\n        for(int i=0;i<nums.size();i++){\\n            help(st,nums[i]);\\n        }\\n        // for(auto it : st){\\n        //     cout<<it.first<<\" \"<<it.second<<\"\\\\n\";\\n        // }\\n        // cout<<\"\\\\n\";\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1976871,
                "title": "whats-wrong-in-this-code",
                "content": "```\\n// class Solution {\\n// public:\\n//     int countLatticePoints(vector<vector<int>>& circles) {\\n//         map<pair<int,int>,int> s;\\n//         int n=circles.size();\\n//         for(int i=0;i<n;i++){\\n//             int x=circles[i][0];\\n//             int y=circles[i][1];\\n//             int r=circles[i][2];\\n//             int q=y+r;\\n//             for(int p=x;p<=x+r;p++){\\n//                 int u=q;\\n//                 while(u>=y){\\n//                     //cout<<p<<\" \"<<u<<endl;\\n//                     s[{p,u}]=1;\\n//                     u--;\\n//                 }\\n//                 q--;\\n//             }\\n//             q=y-r;\\n//             for(int p=x;p<=x+r;p++){\\n//                 int v=q;\\n//                 while(v<=y){\\n//                     //cout<<p<<\" \"<<v<<endl;\\n//                      s[{p,v}]=1;\\n//                     v++;\\n//                 }\\n//                 q++;\\n//             }\\n//             q=y+r;\\n//             for(int p=x;p>=(x-r);p--){\\n//                 int w=q;\\n//                 while(w>=y){\\n//                     //cout<<p<<\" \"<<w<<endl;\\n//                      s[{p,w}]=1;\\n//                     w--;\\n//                 }\\n//                 q--;\\n//             }\\n//             q=y-r;\\n//             for(int p=x;p>=(x-r);p--){\\n//                 int z=q;\\n//                 while(z<=y){\\n//                     //ut<<p<<\" \"<<z<<endl;\\n//                      s[{p,z}]=1;\\n//                     z++;\\n//                 }\\n//                 q++;\\n//             }\\n            \\n//         }\\n//         return s.size();\\n//     }\\n// };\\n```",
                "solutionTags": [],
                "code": "```\\n// class Solution {\\n// public:\\n//     int countLatticePoints(vector<vector<int>>& circles) {\\n//         map<pair<int,int>,int> s;\\n//         int n=circles.size();\\n//         for(int i=0;i<n;i++){\\n//             int x=circles[i][0];\\n//             int y=circles[i][1];\\n//             int r=circles[i][2];\\n//             int q=y+r;\\n//             for(int p=x;p<=x+r;p++){\\n//                 int u=q;\\n//                 while(u>=y){\\n//                     //cout<<p<<\" \"<<u<<endl;\\n//                     s[{p,u}]=1;\\n//                     u--;\\n//                 }\\n//                 q--;\\n//             }\\n//             q=y-r;\\n//             for(int p=x;p<=x+r;p++){\\n//                 int v=q;\\n//                 while(v<=y){\\n//                     //cout<<p<<\" \"<<v<<endl;\\n//                      s[{p,v}]=1;\\n//                     v++;\\n//                 }\\n//                 q++;\\n//             }\\n//             q=y+r;\\n//             for(int p=x;p>=(x-r);p--){\\n//                 int w=q;\\n//                 while(w>=y){\\n//                     //cout<<p<<\" \"<<w<<endl;\\n//                      s[{p,w}]=1;\\n//                     w--;\\n//                 }\\n//                 q--;\\n//             }\\n//             q=y-r;\\n//             for(int p=x;p>=(x-r);p--){\\n//                 int z=q;\\n//                 while(z<=y){\\n//                     //ut<<p<<\" \"<<z<<endl;\\n//                      s[{p,z}]=1;\\n//                     z++;\\n//                 }\\n//                 q++;\\n//             }\\n            \\n//         }\\n//         return s.size();\\n//     }\\n// };\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3377736,
                "title": "worst-memory-solution-recursion-approach-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI guess you already know the question , its quite understandable .\\nI don\\'t know why i am obsessed with recursion , the first approach came to my mind after seeing most question is if i can somehow use memoization. So here is result of that.\\n# This solution uses 56.2MB of space \\nDon\\'t ask me how just see the solution you will get why.\\n![image.png](https://assets.leetcode.com/users/images/52b50289-814f-4e2c-a5bc-9ca839224059_1680589074.305046.png)\\n\\nIt\\'s okay with run time i guess beats 55%.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We start from the center and move in all four directions\\n2. If we already visited the point for current circle , we return 0\\n3. If we have already encountered the point in any other circle , we don\\'t count it\\n4. and if point is out of circle , we return 0\\n\\nPlease Suggest any methods to optimise the code.\\nThanks\\n# Code\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        circle=[]\\n        for i in circles:\\n            if i not in circle:\\n                circle.append(i)\\n        dic={}\\n        visited={}\\n        def fun(i,x,y):\\n            if (x,y) in visited:\\n                return 0\\n            if (i[0]-x)**2+(i[1]-y)**2<=i[2]**2 and (x,y) not in dic:\\n                dic[x,y]=1\\n                visited[x,y]=1\\n                return 1+fun(i,x+1,y)+fun(i,x-1,y)+fun(i,x,y+1)+fun(i,x,y-1)\\n            if (i[0]-x)**2+(i[1]-y)**2<=i[2]**2 and (x,y) not in visited:\\n                visited[x,y]=1\\n                return fun(i,x+1,y)+fun(i,x-1,y)+fun(i,x,y+1)+fun(i,x,y-1)\\n            return 0\\n        ans=0\\n        for i in (circle):\\n            ans+=fun(i,i[0],i[1])\\n            visited={}\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        circle=[]\\n        for i in circles:\\n            if i not in circle:\\n                circle.append(i)\\n        dic={}\\n        visited={}\\n        def fun(i,x,y):\\n            if (x,y) in visited:\\n                return 0\\n            if (i[0]-x)**2+(i[1]-y)**2<=i[2]**2 and (x,y) not in dic:\\n                dic[x,y]=1\\n                visited[x,y]=1\\n                return 1+fun(i,x+1,y)+fun(i,x-1,y)+fun(i,x,y+1)+fun(i,x,y-1)\\n            if (i[0]-x)**2+(i[1]-y)**2<=i[2]**2 and (x,y) not in visited:\\n                visited[x,y]=1\\n                return fun(i,x+1,y)+fun(i,x-1,y)+fun(i,x,y+1)+fun(i,x,y-1)\\n            return 0\\n        ans=0\\n        for i in (circle):\\n            ans+=fun(i,i[0],i[1])\\n            visited={}\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700250,
                "title": "python-simple-solution-distance-calculation",
                "content": "\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        res=[]\\n        for cirlcle in circles:\\n            x=cirlcle[0]\\n            y= cirlcle[1]\\n            rad = cirlcle[2]\\n            for x1 in range(x-rad,x+rad+1):\\n                for y1 in range(y-rad,y+rad+1):\\n                    if((x-x1)*(x-x1)+(y-y1)*(y-y1))<=rad*rad:\\n                            res.append((x1,y1))\\n        mylist=list(set(res))\\n        return len(mylist)\\n    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        res=[]\\n        for cirlcle in circles:\\n            x=cirlcle[0]\\n            y= cirlcle[1]\\n            rad = cirlcle[2]\\n            for x1 in range(x-rad,x+rad+1):\\n                for y1 in range(y-rad,y+rad+1):\\n                    if((x-x1)*(x-x1)+(y-y1)*(y-y1))<=rad*rad:\\n                            res.append((x1,y1))\\n        mylist=list(set(res))\\n        return len(mylist)\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342533,
                "title": "fastest-python-solution-100-100ms",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, c: List[List[int]]) -> int:\\n        ans,m=0,[0]*40401\\n        c=set(((x,y,r) for x,y,r in c))\\n        for x, y, r in c:\\n            for i in range(x-r, x+r+1):\\n                d=int(sqrt(r*r-(x-i)*(x-i)))\\n                m[i*201+y-d:i*201+y+d+1]=[1]*(d+d+1)\\n        return sum(m)\\n```\\n![image](https://assets.leetcode.com/users/images/ce8aed83-6815-4777-aa6c-d430cc4e5877_1658949289.3704836.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, c: List[List[int]]) -> int:\\n        ans,m=0,[0]*40401\\n        c=set(((x,y,r) for x,y,r in c))\\n        for x, y, r in c:\\n            for i in range(x-r, x+r+1):\\n                d=int(sqrt(r*r-(x-i)*(x-i)))\\n                m[i*201+y-d:i*201+y+d+1]=[1]*(d+d+1)\\n        return sum(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114598,
                "title": "c-convert-into-matrix-and-use-set-for-duplicate-points-easy",
                "content": "# \\tCONVERT INTO MATRIX THEN CALCULATE ONLY DISTANCE FROM CENTER\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\tint countLatticePoints(vector<vector<int>>& circles) {\\n\\t\\t\\t\\tset<pair<int,int>> s;\\n\\t\\t\\t\\tfor(int k=0; k<circles.size(); k++){\\n\\t\\t\\t\\t\\tint x = circles[k][0];\\n\\t\\t\\t\\t\\tint y = circles[k][1];\\n\\t\\t\\t\\t\\tint r = circles[k][2];\\n\\n\\t\\t\\t\\t\\tfor(int i=x-r; i<=x+r; i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=y-r; j<=y+r; j++){\\n\\t\\t\\t\\t\\t\\t\\tif((i-x)*(i-x) + (j-y)*(j-y) <= r*r){\\n\\t\\t\\t\\t\\t\\t\\t\\ts.insert({i,j});\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn s.size();\\n\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\tint countLatticePoints(vector<vector<int>>& circles) {\\n\\t\\t\\t\\tset<pair<int,int>> s;\\n\\t\\t\\t\\tfor(int k=0; k<circles.size(); k++){\\n\\t\\t\\t\\t\\tint x = circles[k][0];\\n\\t\\t\\t\\t\\tint y = circles[k][1];\\n\\t\\t\\t\\t\\tint r = circles[k][2];\\n\\n\\t\\t\\t\\t\\tfor(int i=x-r; i<=x+r; i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=y-r; j<=y+r; j++){\\n\\t\\t\\t\\t\\t\\t\\tif((i-x)*(i-x) + (j-y)*(j-y) <= r*r){\\n\\t\\t\\t\\t\\t\\t\\t\\ts.insert({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 2071611,
                "title": "java-easiest-solution-for-newbies-beats-40-percent",
                "content": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        \\n        Set<String> hashSet = new HashSet<>();\\n        \\n        for(int i=0; i<=circles.length-1;i++){\\n            int xCenter = circles[i][0];\\n            int yCenter = circles[i][1];\\n            int r  = circles[i][2];\\n            \\n            for(int x=xCenter-r; x<=xCenter+r; x++){\\n                for(int y=yCenter-r; y<=yCenter+r; y++){\\n                    if(isPointInsideCircle(x, y, xCenter, yCenter, r)){\\n                        hashSet.add(x+\",\"+y);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return hashSet.size();\\n        \\n    }\\n    \\n    public boolean isPointInsideCircle(int x, int y, int xc, int yc, int r){\\n        int distance = (x - xc) * (x - xc) + (y - yc) * (y - yc);\\n        return distance <= r * r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        \\n        Set<String> hashSet = new HashSet<>();\\n        \\n        for(int i=0; i<=circles.length-1;i++){\\n            int xCenter = circles[i][0];\\n            int yCenter = circles[i][1];\\n            int r  = circles[i][2];\\n            \\n            for(int x=xCenter-r; x<=xCenter+r; x++){\\n                for(int y=yCenter-r; y<=yCenter+r; y++){\\n                    if(isPointInsideCircle(x, y, xCenter, yCenter, r)){\\n                        hashSet.add(x+\",\"+y);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return hashSet.size();\\n        \\n    }\\n    \\n    public boolean isPointInsideCircle(int x, int y, int xc, int yc, int r){\\n        int distance = (x - xc) * (x - xc) + (y - yc) * (y - yc);\\n        return distance <= r * r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053545,
                "title": "a-simple-and-intuitive-java-solution-using-the-distance-formula",
                "content": "The idea is to iterate over all the points that lie within and on the smallest square containing a given circle.\\n\\n```\\nLet [x] and [y] be the x and y coordinates of the center of a circle and [r] be its radius.\\nThen the smallest square capable of containing the whole circle will have the following coordinates.\\n\\n(x - r, y + r)      (x + r, y + r)\\n      +-------------------+\\n\\t  |         |         |\\n\\t  |         |         |\\n\\t  |---------O---------|\\n\\t  |         |         |\\n\\t  |         |         |\\n      +-------------------+\\n(x - r, y - r)  (x + r, y - r)\\n\\nHere, [O] is the center of the circle.\\n```\\n\\nJava Solution\\n```java\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<String> answer = new HashSet<String>();\\n        \\n        for (int[] c : circles) {\\n            int x = c[0], y = c[1], r = c[2];\\n            \\n            // traversing over all the points that lie inside the smallest square capable of containing the whole circle\\n            for (int xx = x - r; xx <= x + r; xx++)\\n                for (int yy = y - r; yy <= y + r; yy++)\\n                    if ((r * r) >= ((x - xx) * (x - xx)) + ((y - yy) * (y - yy)))\\n                        answer.add(xx + \":\" + yy);\\n        }\\n        \\n        return answer.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nLet [x] and [y] be the x and y coordinates of the center of a circle and [r] be its radius.\\nThen the smallest square capable of containing the whole circle will have the following coordinates.\\n\\n(x - r, y + r)      (x + r, y + r)\\n      +-------------------+\\n\\t  |         |         |\\n\\t  |         |         |\\n\\t  |---------O---------|\\n\\t  |         |         |\\n\\t  |         |         |\\n      +-------------------+\\n(x - r, y - r)  (x + r, y - r)\\n\\nHere, [O] is the center of the circle.\\n```\n```java\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<String> answer = new HashSet<String>();\\n        \\n        for (int[] c : circles) {\\n            int x = c[0], y = c[1], r = c[2];\\n            \\n            // traversing over all the points that lie inside the smallest square capable of containing the whole circle\\n            for (int xx = x - r; xx <= x + r; xx++)\\n                for (int yy = y - r; yy <= y + r; yy++)\\n                    if ((r * r) >= ((x - xx) * (x - xx)) + ((y - yy) * (y - yy)))\\n                        answer.add(xx + \":\" + yy);\\n        }\\n        \\n        return answer.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051452,
                "title": "javascript-smallest-rectangle-that-all-circles-cover-without-set-200-points",
                "content": "> If you\\'re finding something special, never miss this!\\n\\nMy solution uses neither set nor 200-points. \\n\\nInstead, I find the `minX/maxX`&`minY/maxY` first. These 4 points determine the **MINIMUM AREA that all circles may cover**.\\nWe just have to count lattice points **within that rectangle**!\\n\\nThis method saves both time and space :)\\n```\\nvar countLatticePoints = function(circles) {\\n    let minX=minY=Infinity, maxX=maxY=-Infinity;\\n    for(let i=0; i<circles.length; i++){\\n        minX=Math.min(minX, circles[i][0]-circles[i][2]); maxX=Math.max(maxX, circles[i][0]+circles[i][2]);\\n        minY=Math.min(minY, circles[i][1]-circles[i][2]); maxY=Math.max(maxY, circles[i][1]+circles[i][2]);\\n    }\\n\\t\\n    let count=0;\\n    for(let i=minX; i<=maxX; i++){\\n        for(let j=minY; j<=maxY; j++){\\n            let find=false;\\n            for(let k=0; k<circles.length; k++){\\n                if(((i-circles[k][0])**2+(j-circles[k][1])**2)<=circles[k][2]**2){\\n                    find=true; break;\\n                }\\n            }\\n            if(find){count++};\\n        }\\n    }\\n    return count;\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nvar countLatticePoints = function(circles) {\\n    let minX=minY=Infinity, maxX=maxY=-Infinity;\\n    for(let i=0; i<circles.length; i++){\\n        minX=Math.min(minX, circles[i][0]-circles[i][2]); maxX=Math.max(maxX, circles[i][0]+circles[i][2]);\\n        minY=Math.min(minY, circles[i][1]-circles[i][2]); maxY=Math.max(maxY, circles[i][1]+circles[i][2]);\\n    }\\n\\t\\n    let count=0;\\n    for(let i=minX; i<=maxX; i++){\\n        for(let j=minY; j<=maxY; j++){\\n            let find=false;\\n            for(let k=0; k<circles.length; k++){\\n                if(((i-circles[k][0])**2+(j-circles[k][1])**2)<=circles[k][2]**2){\\n                    find=true; break;\\n                }\\n            }\\n            if(find){count++};\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015989,
                "title": "python-simple-maths",
                "content": "\\n    def valid_points(self, circles):\\n        ans, radius = set(), circles[2]\\n    \\n        for r1 in range(-radius,radius+1):\\n            for r2 in range(-radius,radius+1):\\n                x, y = circles[0] + r1, circles[1] + r2\\n                if (x - circles[0])**2 + (y - circles[1])**2 <= radius**2:\\n                    ans.add((x,y))\\n                        \\n        return ans\\n        \\n    def countLatticePoints(self, circles):\\n        arr, circles = [], list(set([tuple(i) for i in circles]))\\n        \\n        for i in circles:\\n            arr += self.valid_points(i)\\n            \\n        return len(set(arr))",
                "solutionTags": [],
                "code": "\\n    def valid_points(self, circles):\\n        ans, radius = set(), circles[2]\\n    \\n        for r1 in range(-radius,radius+1):\\n            for r2 in range(-radius,radius+1):\\n                x, y = circles[0] + r1, circles[1] + r2\\n                if (x - circles[0])**2 + (y - circles[1])**2 <= radius**2:\\n                    ans.add((x,y))\\n                        \\n        return ans\\n        \\n    def countLatticePoints(self, circles):\\n        arr, circles = [], list(set([tuple(i) for i in circles]))\\n        \\n        for i in circles:\\n            arr += self.valid_points(i)\\n            \\n        return len(set(arr))",
                "codeTag": "Python3"
            },
            {
                "id": 2004579,
                "title": "cpp-code-using-circle-properties-explained-and-hashset",
                "content": "Given the center of the circle as (a,b) and it\\'s radius as r , the equation of the circle can be written as \\n(x-a)^2 + (y-b)^2 = r^2\\nNow if another point say (x1,y1) \\n1) Is on the circumfrence of the circle then it must satisfy :\\n\\t (x1-r)^2 + (x2-r)^2 = r^2\\n2) Is inside the circumfrence of the circle then it must satisfy :\\n\\t (x1-r)^2 + (x2-r)^2 < r^2 \\n3) Is outside the circumfrence of the circle then it must satisfy :\\n\\t (x1-r)^2 + (x2-r)^2 > r^2 \\n\\nHence our answer should be the number of distinct integer points satisfying the condition 1 and 2.\\n\\nTo implement this we create a function for the equation of the circle which return true if a point lies inside or on the circumfrence of the circle. \\nThe points are stored in a hashSet to only count the distinct points in case of overlapping circles.\\n\\n```\\nclass Solution {\\npublic:\\n    bool circle(int x , int y , int c1 , int c2, int r){\\n        if((x-c1)*(x-c1) + (y-c2)*(y-c2) <= r*r) \\n            return true ;\\n        return false ;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n = circles.size() , ans = 0 ;\\n        set<pair<int,int>> set ;\\n        for(auto v : circles){\\n            int r = v[2] , x = v[0] , y = v[1]; \\n            for(int i = x-r ; i <= x+r ; i++)\\n                for(int j = y-r ; j <= y+r ; j++)\\n                    if(circle(i,j,x,y,r)){\\n                        pair<int,int> p(i,j) ;\\n                        set.insert(p) ;\\n                    }\\n        }\\n        return set.size() ;\\n    }\\n};\\n```\\n\\n*Keep solving !!*",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool circle(int x , int y , int c1 , int c2, int r){\\n        if((x-c1)*(x-c1) + (y-c2)*(y-c2) <= r*r) \\n            return true ;\\n        return false ;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n = circles.size() , ans = 0 ;\\n        set<pair<int,int>> set ;\\n        for(auto v : circles){\\n            int r = v[2] , x = v[0] , y = v[1]; \\n            for(int i = x-r ; i <= x+r ; i++)\\n                for(int j = y-r ; j <= y+r ; j++)\\n                    if(circle(i,j,x,y,r)){\\n                        pair<int,int> p(i,j) ;\\n                        set.insert(p) ;\\n                    }\\n        }\\n        return set.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989485,
                "title": "c-track-used-points-w-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        vector<vector<int>> grid(401, vector<int>(401, 0));\\n        int center_r = 200;\\n        int center_c = 200;\\n        int count = 0;\\n        for(int i = 0; i < circles.size(); i++){\\n            circles[i][0] += center_r;\\n            circles[i][1] += center_c;\\n            for(int j = circles[i][0]-circles[i][2]; j <= circles[i][0]+ circles[i][2]; j++){\\n                for(int k = circles[i][1] - circles[i][2]; k <= circles[i][1]+ circles[i][2]; k++){\\n                    if(j < 0 || k < 0 || j >= grid.size() || k >= grid[0].size()) continue;\\n                    if(grid[j][k] == 1) continue;\\n                    if(inCircle(circles[i], {j, k})){\\n                        grid[j][k]++;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\nprivate:\\n        bool inCircle(vector<int>& circle, vector<int> point){\\n            double distance = sqrt((circle[0]-point[0]) * (circle[0]-point[0]) + (circle[1]-point[1]) * (circle[1]-point[1]));\\n            if(distance <= (circle[2] + 0.00001)) return true;\\n            return false;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        vector<vector<int>> grid(401, vector<int>(401, 0));\\n        int center_r = 200;\\n        int center_c = 200;\\n        int count = 0;\\n        for(int i = 0; i < circles.size(); i++){\\n            circles[i][0] += center_r;\\n            circles[i][1] += center_c;\\n            for(int j = circles[i][0]-circles[i][2]; j <= circles[i][0]+ circles[i][2]; j++){\\n                for(int k = circles[i][1] - circles[i][2]; k <= circles[i][1]+ circles[i][2]; k++){\\n                    if(j < 0 || k < 0 || j >= grid.size() || k >= grid[0].size()) continue;\\n                    if(grid[j][k] == 1) continue;\\n                    if(inCircle(circles[i], {j, k})){\\n                        grid[j][k]++;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\nprivate:\\n        bool inCircle(vector<int>& circle, vector<int> point){\\n            double distance = sqrt((circle[0]-point[0]) * (circle[0]-point[0]) + (circle[1]-point[1]) * (circle[1]-point[1]));\\n            if(distance <= (circle[2] + 0.00001)) return true;\\n            return false;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983850,
                "title": "simple-c-solution-100-better",
                "content": "Solution: \\n\\nTime Complexity : O(N^3)\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countLatticePoints(vector<vector<int>>& circles) {\\n\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\tset<pair<int,int>> points;\\n\\t\\t\\t\\tfor(auto circle : circles){\\n\\t\\t\\t\\t\\tint x = circle[0],y = circle[1],r = circle[2];\\n\\t\\t\\t\\t\\tint ly = y-r,hy = y+r;\\n\\t\\t\\t\\t\\tfor(int i = ly; i <= hy ; i++){\\n\\t\\t\\t\\t\\t\\tdouble d = sqrt(-y*y+2*i*y+r*r-i*i);\\n\\t\\t\\t\\t\\t\\tint lx = ceil(x-d);\\n\\t\\t\\t\\t\\t\\tint hx = floor(x+d);\\n\\t\\t\\t\\t\\t\\t// cout<<i<<\" \"<<lx<<\" \"<<hx<<\\'\\\\n\\';\\n\\t\\t\\t\\t\\t\\tfor(int j = lx ; j <= hx ; j++){\\n\\t\\t\\t\\t\\t\\t\\tpoints.insert({i,j});\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn points.size();\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countLatticePoints(vector<vector<int>>& circles) {\\n\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\tset<pair<int,int>> points;\\n\\t\\t\\t\\tfor(auto circle : circles){\\n\\t\\t\\t\\t\\tint x = circle[0],y = circle[1],r = circle[2];\\n\\t\\t\\t\\t\\tint ly = y-r,hy = y+r;\\n\\t\\t\\t\\t\\tfor(int i = ly; i <= hy ; i++){\\n\\t\\t\\t\\t\\t\\tdouble d = sqrt(-y*y+2*i*y+r*r-i*i);\\n\\t\\t\\t\\t\\t\\tint lx = ceil(x-d);\\n\\t\\t\\t\\t\\t\\tint hx = floor(x+d);\\n\\t\\t\\t\\t\\t\\t// cout<<i<<\" \"<<lx<<\" \"<<hx<<\\'\\\\n\\';\\n\\t\\t\\t\\t\\t\\tfor(int j = lx ; j <= hx ; j++){\\n\\t\\t\\t\\t\\t\\t\\tpoints.insert({i,j}",
                "codeTag": "C++"
            },
            {
                "id": 1983694,
                "title": "8-lines-of-code-easy-cpp-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& C) {\\n      set<pair<int,int>> S;\\n        for(int i=0;i<C.size();i++){\\n            int a=C[i][0],b=C[i][1],x=C[i][2],l=a-x,d=b-x;\\n            for(int j=l;j<=x+a;j++)\\n            for(int k=d;k<=x+b;k++)\\n                if(pow(a-j,2)+pow(b-k,2)<=x*x) \\n                S.insert({j,k}); \\n        }\\n        return S.size();  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& C) {\\n      set<pair<int,int>> S;\\n        for(int i=0;i<C.size();i++){\\n            int a=C[i][0],b=C[i][1],x=C[i][2],l=a-x,d=b-x;\\n            for(int j=l;j<=x+a;j++)\\n            for(int k=d;k<=x+b;k++)\\n                if(pow(a-j,2)+pow(b-k,2)<=x*x) \\n                S.insert({j,k}); \\n        }\\n        return S.size();  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982893,
                "title": "simple-java-solution-50-ms-using-bounding-box",
                "content": "\\n```\\npublic int countLatticePoints(int[][] circles) {\\n       \\n        // Bounding box for overall search space\\n        // (i.e. smallest rectangle that covers all the circles)\\n        int xMin=200,xMax=-1,yMin=200,yMax=-1;\\n\\n        for(int[] c:circles){\\n            xMin = Math.min(xMin,c[0]-c[2]);\\n            xMax = Math.max(xMax,c[0]+c[2]);\\n            \\n            yMin = Math.min(yMin,c[1]-c[2]);\\n            yMax = Math.max(yMax,c[1]+c[2]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int x=xMin; x<=xMax; x++){\\n            for(int y=yMin; y<=yMax; y++){\\n                for(int[] c:circles){\\n                    if((c[0]-x)*(c[0]-x)+(c[1]-y)*(c[1]-y)<= c[2]*c[2]){ // Inside circle or not?\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countLatticePoints(int[][] circles) {\\n       \\n        // Bounding box for overall search space\\n        // (i.e. smallest rectangle that covers all the circles)\\n        int xMin=200,xMax=-1,yMin=200,yMax=-1;\\n\\n        for(int[] c:circles){\\n            xMin = Math.min(xMin,c[0]-c[2]);\\n            xMax = Math.max(xMax,c[0]+c[2]);\\n            \\n            yMin = Math.min(yMin,c[1]-c[2]);\\n            yMax = Math.max(yMax,c[1]+c[2]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int x=xMin; x<=xMax; x++){\\n            for(int y=yMin; y<=yMax; y++){\\n                for(int[] c:circles){\\n                    if((c[0]-x)*(c[0]-x)+(c[1]-y)*(c[1]-y)<= c[2]*c[2]){ // Inside circle or not?\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982427,
                "title": "rust-using-boring-for-loops-calculate-circle-intersections-by-row-395ms-3mb",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut lattice_points: HashSet<(i32, i32)> = HashSet::new();\\n      \\n        //let mut exclusive_max: i32 = 0;\\n        \\n        for circle in circles.iter() {\\n          let radius: i32 = circle[2];\\n          let center: (i32, i32) = (circle[0], circle[1]);\\n          \\n          // For each integer row in the top half of the circle,\\n          // excluding the top row which will always be a single point\\n          lattice_points.insert((center.0, center.1+radius));\\n          \\n          //println!(\"circle: {:?}\", circle);\\n          //println!(\"  top point: {:?}\", (center.0, center.1+radius));\\n          \\n          // and the center row which has no \"bottom reflection\",\\n          for height_from_center in (0..radius).rev() {\\n            \\n            //top row\\n            let y1: i32 = center.1 + height_from_center;\\n            //bottom reflection\\n            let y2: i32 = center.1 - height_from_center;\\n            \\n\\n            // Calculate where the arc of the circle crosses that row:\\n            // distance ^2 = delta_x ^2 + delta_y ^2\\n            // distance here is radius (the circle arc)\\n            // delta_y is the row we\\'re on minus the radius\\n            // delta_x will likely be a non-integer value, \\n            // so we take the floor to get the x-distance from the\\n            // center to the furthest interior integer coordinate on that row\\n\\n            let x_distance: i32 = ((radius * radius - height_from_center * height_from_center) as f64).sqrt() as i32;\\n            // and this distance can be used to calculate \\n            // the inclusive boundary lattice points at either end\\n            \\n            //print!(\"    d_x: {} ... adding: \", x_distance);\\n            \\n            for x in (center.0-x_distance..=center.0+x_distance) {\\n              lattice_points.insert((x, y1));\\n              lattice_points.insert((x, y2));\\n              //print!(\" top {:?} bot {:?} \", (x, y1), (x, y2));\\n            }\\n            \\n          }\\n          //println!(\"\");\\n          //print!(\"   adding center: \");\\n          //Add the center row\\n          for center_row_x in (center.0-radius..=center.0+radius) {\\n            lattice_points.insert((center_row_x, center.1));\\n            //print!(\" {:?}\", (center_row_x, center.1));\\n          }\\n          //println!(\"\");\\n          //Add the bottom lattice point\\n          \\n          lattice_points.insert((center.0, center.1-radius));\\n          //println!(\"  adding bottom point: {:?}\", (center.0, center.1-radius));\\n          \\n          //println!(\"--circle complete: now total {} unique lattice points\", lattice_points.len());\\n      }\\n            \\n      lattice_points.len() as i32\\n          \\n  }\\n}\\n\\n/* Testcases:\\n\\n[[2,2,1]]\\n[[2,2,2],[3,4,1]]\\n[[8,9,6]]\\n[[8,9,6],[9,8,4],[4,1,1],[8,5,1],[7,1,1],[6,7,5],[7,1,1],[7,1,1],[5,5,3]]\\n[[9,8,4],[4,1,1],[8,5,1],[7,1,1],[6,7,5],[7,1,1],[7,1,1],[5,5,3]]\\n[[9,8,4]]\\n\\n*/\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut lattice_points: HashSet<(i32, i32)> = HashSet::new();\\n      \\n        //let mut exclusive_max: i32 = 0;\\n        \\n        for circle in circles.iter() {\\n          let radius: i32 = circle[2];\\n          let center: (i32, i32) = (circle[0], circle[1]);\\n          \\n          // For each integer row in the top half of the circle,\\n          // excluding the top row which will always be a single point\\n          lattice_points.insert((center.0, center.1+radius));\\n          \\n          //println!(\"circle: {:?}\", circle);\\n          //println!(\"  top point: {:?}\", (center.0, center.1+radius));\\n          \\n          // and the center row which has no \"bottom reflection\",\\n          for height_from_center in (0..radius).rev() {\\n            \\n            //top row\\n            let y1: i32 = center.1 + height_from_center;\\n            //bottom reflection\\n            let y2: i32 = center.1 - height_from_center;\\n            \\n\\n            // Calculate where the arc of the circle crosses that row:\\n            // distance ^2 = delta_x ^2 + delta_y ^2\\n            // distance here is radius (the circle arc)\\n            // delta_y is the row we\\'re on minus the radius\\n            // delta_x will likely be a non-integer value, \\n            // so we take the floor to get the x-distance from the\\n            // center to the furthest interior integer coordinate on that row\\n\\n            let x_distance: i32 = ((radius * radius - height_from_center * height_from_center) as f64).sqrt() as i32;\\n            // and this distance can be used to calculate \\n            // the inclusive boundary lattice points at either end\\n            \\n            //print!(\"    d_x: {} ... adding: \", x_distance);\\n            \\n            for x in (center.0-x_distance..=center.0+x_distance) {\\n              lattice_points.insert((x, y1));\\n              lattice_points.insert((x, y2));\\n              //print!(\" top {:?} bot {:?} \", (x, y1), (x, y2));\\n            }\\n            \\n          }\\n          //println!(\"\");\\n          //print!(\"   adding center: \");\\n          //Add the center row\\n          for center_row_x in (center.0-radius..=center.0+radius) {\\n            lattice_points.insert((center_row_x, center.1));\\n            //print!(\" {:?}\", (center_row_x, center.1));\\n          }\\n          //println!(\"\");\\n          //Add the bottom lattice point\\n          \\n          lattice_points.insert((center.0, center.1-radius));\\n          //println!(\"  adding bottom point: {:?}\", (center.0, center.1-radius));\\n          \\n          //println!(\"--circle complete: now total {} unique lattice points\", lattice_points.len());\\n      }\\n            \\n      lattice_points.len() as i32\\n          \\n  }\\n}\\n\\n/* Testcases:\\n\\n[[2,2,1]]\\n[[2,2,2],[3,4,1]]\\n[[8,9,6]]\\n[[8,9,6],[9,8,4],[4,1,1],[8,5,1],[7,1,1],[6,7,5],[7,1,1],[7,1,1],[5,5,3]]\\n[[9,8,4],[4,1,1],[8,5,1],[7,1,1],[6,7,5],[7,1,1],[7,1,1],[5,5,3]]\\n[[9,8,4]]\\n\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980592,
                "title": "brute-force-java-solution",
                "content": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) \\n    {\\n        var count=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                boolean flag=false;\\n                for(int circle[]:circles)\\n                {\\n                    if((int)(Math.pow(i-circle[0],2)+Math.pow(j-circle[1],2))<=Math.pow(circle[2],2))\\n                    {\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(flag)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int countLatticePoints(int[][] circles) \\n    {\\n        var count=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                boolean flag=false;\\n                for(int circle[]:circles)\\n                {\\n                    if((int)(Math.pow(i-circle[0],2)+Math.pow(j-circle[1],2))<=Math.pow(circle[2],2))\\n                    {\\n                        flag=true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1980347,
                "title": "python3-interval-merging",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/c2730559a4a05cfc912d81e5d7a3d4d607079401) for solutions of weekly 290.\\n\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        intervals = [[] for _ in range(201)]\\n        for x, y, r in circles: \\n            intervals[x].append((y-r, y+r))\\n            for dx in range(1, r+1): \\n                dy = int(sqrt(r**2 - dx**2))\\n                intervals[x+dx].append((y-dy, y+dy))\\n                intervals[x-dx].append((y-dy, y+dy))\\n        \\n        ans = 0 \\n        for interval in intervals: \\n            if interval: \\n                end = -inf\\n                for i, (lo, hi) in enumerate(sorted(interval)): \\n                    if end < lo: \\n                        if i: ans += end - start + 1\\n                        start, end = lo, hi \\n                    else: end = max(end, hi)\\n                ans += end - start + 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        intervals = [[] for _ in range(201)]\\n        for x, y, r in circles: \\n            intervals[x].append((y-r, y+r))\\n            for dx in range(1, r+1): \\n                dy = int(sqrt(r**2 - dx**2))\\n                intervals[x+dx].append((y-dy, y+dy))\\n                intervals[x-dx].append((y-dy, y+dy))\\n        \\n        ans = 0 \\n        for interval in intervals: \\n            if interval: \\n                end = -inf\\n                for i, (lo, hi) in enumerate(sorted(interval)): \\n                    if end < lo: \\n                        if i: ans += end - start + 1\\n                        start, end = lo, hi \\n                    else: end = max(end, hi)\\n                ans += end - start + 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979552,
                "title": "python-clean-simple-iterator",
                "content": "```py\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        def allLattices(x: int, y: int, r: int) -> Iterator[Tuple[int, int]]:\\n            for dx in range(-r, r+1):\\n                yRange = isqrt(r*r - dx*dx)\\n                for dy in range(-yRange, yRange+1):\\n                    yield (x + dx, y + dy)\\n        \\n        s = set()\\n        for x, y, r in circles:\\n            s.update(allLattices(x, y, r))\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        def allLattices(x: int, y: int, r: int) -> Iterator[Tuple[int, int]]:\\n            for dx in range(-r, r+1):\\n                yRange = isqrt(r*r - dx*dx)\\n                for dy in range(-yRange, yRange+1):\\n                    yield (x + dx, y + dy)\\n        \\n        s = set()\\n        for x, y, r in circles:\\n            s.update(allLattices(x, y, r))\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979096,
                "title": "rust-check-every-possible-points-o-n",
                "content": "traverse every possible points.\\n\\nPoint(x, y)\\nx in -100..=200;\\ny in -100..= 200;\\n\\n```\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n        for x in -100..=200 {\\n            for y in -100..= 200 {\\n                for circle in &circles {\\n                    if let [cx, cy, r, ..] = circle[..] {\\n                        if (x-cx).pow(2) + (y-cy).pow(2) <= r.pow(2) {\\n                            ans += 1;\\n                            break;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n        for x in -100..=200 {\\n            for y in -100..= 200 {\\n                for circle in &circles {\\n                    if let [cx, cy, r, ..] = circle[..] {\\n                        if (x-cx).pow(2) + (y-cy).pow(2) <= r.pow(2) {\\n                            ans += 1;\\n                            break;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978769,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    set<pair<int,int>>st;\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n  \\n        for(int i=0;i<circles.size();i++){\\n            solve(circles[i]);\\n        }\\n        \\n        return st.size();\\n    }\\n    void solve(vector<int>&cir){\\n        int x=cir[0],y=cir[1],r=cir[2];\\n        \\n        for(int i=-r;i<=r;i++){                 //here we are considering (0,0) as origin and checking for -r to +r range \\n            for(int j=-r;j<=r;j++){             \\n                if((i*i)+(j*j)<=(r*r))               //mathematical formula\\n                    st.insert({i+x,j+y});           //as we considered (0,0) as origin first,so we need to correct it while storing \\n            }                                              //so we add x and y to get back the original values\\n        }\\n    }\\n};\\n\\n\\uD83D\\uDE4C\\uD83D\\uDC40 Please upvote if it helped !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    set<pair<int,int>>st;\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n  \\n        for(int i=0;i<circles.size();i++){\\n            solve(circles[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1978656,
                "title": "a-few-solutions",
                "content": "Return the cardinality of the set of `seen` coordinates within each circle.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countLatticePoints(A: Array<IntArray>): Int {\\n        var seen = mutableSetOf<String>()\\n        fun dist(i: Int, j: Int, u: Int, v: Int): Double {\\n            var x = Math.abs(i - u).toDouble()\\n            var y = Math.abs(j - v).toDouble()\\n            return Math.sqrt(x * x + y * y)\\n        }\\n        for ((i, j, r) in A)\\n            for (u in i - r..i + r)\\n                for (v in j - r..j + r)\\n                    if (dist(i, j, u, v) <= r)\\n                        seen.add(\"$u,$v\")\\n        return seen.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countLatticePoints = (A, seen = new Set()) => {\\n    let dist = (i, j, u, v) => {\\n        let x = Math.abs(i - u),\\n            y = Math.abs(j - v);\\n        return Math.sqrt(x * x + y * y);\\n    };\\n    for (let [i, j, r] of A)\\n        for (let u = i - r; u <= i + r; ++u)\\n            for (let v = j - r; v <= j + r; ++v)\\n                if (dist(i, j, u, v) <= r)\\n                    seen.add(`${u},${v}`);\\n    return seen.size;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countLatticePoints(self, A: List[List[int]]) -> int:\\n        seen = set()\\n        def dist(i, j, u, v):\\n            x = abs(i - u)\\n            y = abs(j - v)\\n            return sqrt(x * x + y * y)\\n        for i, j, r in A:\\n            for u in range(i - r, i + r + 1):\\n                for v in range(j - r, j + r + 1):\\n                    if dist(i, j, u, v) <= r:\\n                        seen.add(f\\'{u},{v}\\')\\n        return len(seen)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_lattice_points(A: VVI) -> i32 {\\n        let mut seen = HashSet::new();\\n        fn dist(i: i32, j: i32, u: i32, v: i32) -> f32 {\\n            let x = (i - u).abs() as f32;\\n            let y = (j - v).abs() as f32;\\n            return (x * x + y * y).sqrt();\\n        }\\n        for row in A {\\n            let (i, j, r) = (row[0], row[1], row[2]);\\n            for u in i - r..=i + r {\\n                for v in j - r..=j + r {\\n                    if dist(i, j, u, v) <= r as f32 {\\n                        seen.insert(format!(\"{}, {}\", u, v));\\n                    }\\n                }\\n            }\\n        }\\n        return seen.len() as i32;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<string>;\\n    int countLatticePoints(VVI& A, Set seen = {}) {\\n        auto dist = [](auto i, auto j, auto u, auto v) {\\n            auto x = abs(i - u),\\n                 y = abs(j - v);\\n            return sqrt(x * x + y * y);\\n        };\\n        auto key = [](auto u, auto v) {\\n            stringstream ss; ss << u << \",\" << v;\\n            return ss.str();\\n        };\\n        for (auto& row: A) {\\n            auto [i, j, r] = tie(row[0], row[1], row[2]);\\n            for (auto u{ i - r }; u <= i + r; ++u)\\n                for (auto v{ j - r }; v <= j + r; ++v)\\n                    if (dist(i, j, u, v) <= r)\\n                        seen.insert(key(u, v));\\n        }\\n        return seen.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countLatticePoints(A: Array<IntArray>): Int {\\n        var seen = mutableSetOf<String>()\\n        fun dist(i: Int, j: Int, u: Int, v: Int): Double {\\n            var x = Math.abs(i - u).toDouble()\\n            var y = Math.abs(j - v).toDouble()\\n            return Math.sqrt(x * x + y * y)\\n        }\\n        for ((i, j, r) in A)\\n            for (u in i - r..i + r)\\n                for (v in j - r..j + r)\\n                    if (dist(i, j, u, v) <= r)\\n                        seen.add(\"$u,$v\")\\n        return seen.size\\n    }\\n}\\n```\n```\\nlet countLatticePoints = (A, seen = new Set()) => {\\n    let dist = (i, j, u, v) => {\\n        let x = Math.abs(i - u),\\n            y = Math.abs(j - v);\\n        return Math.sqrt(x * x + y * y);\\n    };\\n    for (let [i, j, r] of A)\\n        for (let u = i - r; u <= i + r; ++u)\\n            for (let v = j - r; v <= j + r; ++v)\\n                if (dist(i, j, u, v) <= r)\\n                    seen.add(`${u},${v}`);\\n    return seen.size;\\n};\\n```\n```\\nclass Solution:\\n    def countLatticePoints(self, A: List[List[int]]) -> int:\\n        seen = set()\\n        def dist(i, j, u, v):\\n            x = abs(i - u)\\n            y = abs(j - v)\\n            return sqrt(x * x + y * y)\\n        for i, j, r in A:\\n            for u in range(i - r, i + r + 1):\\n                for v in range(j - r, j + r + 1):\\n                    if dist(i, j, u, v) <= r:\\n                        seen.add(f\\'{u},{v}\\')\\n        return len(seen)\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_lattice_points(A: VVI) -> i32 {\\n        let mut seen = HashSet::new();\\n        fn dist(i: i32, j: i32, u: i32, v: i32) -> f32 {\\n            let x = (i - u).abs() as f32;\\n            let y = (j - v).abs() as f32;\\n            return (x * x + y * y).sqrt();\\n        }\\n        for row in A {\\n            let (i, j, r) = (row[0], row[1], row[2]);\\n            for u in i - r..=i + r {\\n                for v in j - r..=j + r {\\n                    if dist(i, j, u, v) <= r as f32 {\\n                        seen.insert(format!(\"{}, {}\", u, v));\\n                    }\\n                }\\n            }\\n        }\\n        return seen.len() as i32;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<string>;\\n    int countLatticePoints(VVI& A, Set seen = {}) {\\n        auto dist = [](auto i, auto j, auto u, auto v) {\\n            auto x = abs(i - u),\\n                 y = abs(j - v);\\n            return sqrt(x * x + y * y);\\n        };\\n        auto key = [](auto u, auto v) {\\n            stringstream ss; ss << u << \",\" << v;\\n            return ss.str();\\n        };\\n        for (auto& row: A) {\\n            auto [i, j, r] = tie(row[0], row[1], row[2]);\\n            for (auto u{ i - r }; u <= i + r; ++u)\\n                for (auto v{ j - r }; v <= j + r; ++v)\\n                    if (dist(i, j, u, v) <= r)\\n                        seen.insert(key(u, v));\\n        }\\n        return seen.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977304,
                "title": "easy-c-solution-fully-explained",
                "content": "**FOR A POINT TO LIE INSIDE A CIRCLE, IT SHOULD FOLLOW A CERTAIN CONDITION**\\n\\nTHE CONDITION IS\\n\\n**(X-X1)^2 + (Y-Y1)^2 <= (R * R)**\\n\\nHERE X AND Y IS THE CENTER POINT OF THE CIRCLE,  X1 AND Y1 ARE ANY RANDOM POINTS\\n\\nNOW, **THE QUESTION COMES HOW TO FIND ALL X1 AND Y1 POINTS** \\n\\nNOW LET US ASSUME THAT WE ARE GIVEN A CIRCLE WITH **CENTER (2,2) AND RADIUS 2**\\n\\nNOW IF WE THINK , WHAT CAN BE THE EXTREME LEFT AND RIGHT POINTS, IT MEANS THAT THE EXTREME LEFT POINT LYING INSIDE THE CIRCLE WILL BE \\n\\nTHIS CAN BE SIMPLY CALCULATED AS **(CENTER X COORDINATE - RADIUS)**\\n(2-2) = 0       \\nTHE EXTREME RIGHT POINT WILL BE **( CENTER X COORDINATE + RADIUS)**\\n(2+2) = 4\\n\\nIT MEANS THAT X1 COORDINATE WILL LIE IN THE RANGE (0<=X1<=4)\\n\\nNOW, SIMILARLY WHAT CAN BE THE EXTREME UPWARDS AND DOWNWARDS POINTS\\n\\nEXTREME DOWNWARD POINT =  **( CENTER Y COORDINATE - RADIUS )**\\n(2-2) = 0\\nEXTREME UPWARD POINT  = **(CENTER Y COORDINATE + RADIUS)**\\n(2+2) = 4\\nIT MEANS THAT Y1 COORDINATE WILL LIE IN THE RANGE (0<=Y1<=4)\\n\\nTHE ABOVE MENTIONED THINGS CAN BE SIMPLY UNDERSTOOD WITH THE HELP OF DIAGRAM\\n\\n![image](https://assets.leetcode.com/users/images/0f3bff1a-6772-458c-93d6-ba83b37a1de7_1650777372.220716.jpeg)\\n\\nNOW, WE KNOW THAT **X1 WILL RANGE FROM 0 TO 4** AND **Y1 WILL RANGE FROM 0 TO 4**\\n\\nSO NOW WE HAVE TO TRY EVERY COMBINATION OF THE TWO RANGES AND FOR EVERY COMBINATION WE HAVE TO APPLY THIS FORMULA\\n\\n**(X-X1)^2 + (Y-Y1)^2 <= (R * R)**\\n\\nAND IF IT IS TRUE THEN WE HAVE TO JUST INSERT THE COORDINATES IN OUR SET.\\n\\nWE WILL BE CHOOSING A SET BECAUSE WE DON\\'T WANT OUR COORDINATES TO BE REPEATED FOR SOME OTHER CIRCLE\\n\\n**OUR ANS WILL BE THE SIZE OF THE SET**\\nTHE CODE IS AS FOLLOWS \\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int x,int y,int r, set<pair<int,int>>&jd )\\n    {\\n        \\n        int a = x-r;\\n        int b = x+r;\\n        \\n        int c = y-r;\\n        int d = y+r;\\n        \\n        for(int i=a; i<=b; i++)\\n        {\\n            for(int j=c; j<=d; j++)\\n            {\\n                int z = (x-i)*(x-i);\\n                int t = (y-j)*(y-j);\\n                int m = r*r;\\n                if(z+t<=m)\\n                {\\n               //     cout<<x-i<<\" \"<<y-j<<\" \"<<endl;\\n                    jd.insert(make_pair(i,j));\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n    }\\n    \\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n      \\n        set<pair<int,int>>jd;\\n        \\n        for(int i=0; i<circles.size(); i++)\\n        {\\n            \\n            int x = circles[i][0];\\n            int y = circles[i][1];\\n            int r = circles[i][2];\\n            solve(x,y,r,jd);\\n            \\n            \\n        }\\n        int ans = jd.size();\\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(int x,int y,int r, set<pair<int,int>>&jd )\\n    {\\n        \\n        int a = x-r;\\n        int b = x+r;\\n        \\n        int c = y-r;\\n        int d = y+r;\\n        \\n        for(int i=a; i<=b; i++)\\n        {\\n            for(int j=c; j<=d; j++)\\n            {\\n                int z = (x-i)*(x-i);\\n                int t = (y-j)*(y-j);\\n                int m = r*r;\\n                if(z+t<=m)\\n                {\\n               //     cout<<x-i<<\" \"<<y-j<<\" \"<<endl;\\n                    jd.insert(make_pair(i,j));\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n    }\\n    \\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n      \\n        set<pair<int,int>>jd;\\n        \\n        for(int i=0; i<circles.size(); i++)\\n        {\\n            \\n            int x = circles[i][0];\\n            int y = circles[i][1];\\n            int r = circles[i][2];\\n            solve(x,y,r,jd);\\n            \\n            \\n        }\\n        int ans = jd.size();\\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1977094,
                "title": "python-math-geometry-and-set-solution-no-brute-force",
                "content": "**Intuition**\\nInstead of checking each point in the 2-D grid, we loop through each `circle` be calculating the `x-/y-axis` boundaries using Pythagoras Theorem, and add valid lattice points into the set (to avoid duplicate counting). The final output is the number of element in the resulting set.\\n\\n\\n**Complexity**\\nTime: `O(n * 4 * max(r)^2)`, where `n=circles.length` and `max(r) <= 100`\\nSpace: `O(201 * 201)` where `201` is the largest possible size of a valid lattice point in the 2-D grid\\n\\nBelow is my slightly-modified in-contest solution. Please upvote if you find this solution helpful. Thanks!\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = set()\\n        for x, y, r in circles:\\n            for dx in range(-r, r + 1, 1):\\n                temp = math.floor(math.sqrt(r ** 2 - dx ** 2))\\n                for dy in range(-temp, temp + 1):\\n                    points.add((x + dx, y + dy))\\n        return len(points)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = set()\\n        for x, y, r in circles:\\n            for dx in range(-r, r + 1, 1):\\n                temp = math.floor(math.sqrt(r ** 2 - dx ** 2))\\n                for dy in range(-temp, temp + 1):\\n                    points.add((x + dx, y + dy))\\n        return len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977046,
                "title": "java-don-t-overthink-it-bruteforce",
                "content": "The trick to this question is Don\\'t Overthink it, just check all points. Due to the low constraint, the worst it could be is about (200)^3, which should still be accepted.\\n\\n```Java\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        int ans = 0;\\n        for (int i = 0; i < 201; i++){\\n            for (int j = 0; j < 201; j++){\\n                for (int[] c : circles){\\n                    int x = Math.abs(c[0] - i);\\n                    int y = Math.abs(c[1] - j);\\n                    if (c[2] * c[2] >= x * x + y * y){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        int ans = 0;\\n        for (int i = 0; i < 201; i++){\\n            for (int j = 0; j < 201; j++){\\n                for (int[] c : circles){\\n                    int x = Math.abs(c[0] - i);\\n                    int y = Math.abs(c[1] - j);\\n                    if (c[2] * c[2] >= x * x + y * y){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976987,
                "title": "c-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n         int ans = 0; \\n        for (int x = 0; x <=200;x++) \\n            for (int y = 0; y <=200; y++) {\\n                bool found = false; \\n                for (auto& c : circles) \\n                    if (pow(x-c[0], 2) + pow(y-c[1], 2) <= pow(c[2], 2)) \\n                        found = true; \\n                if (found) ans++; \\n            }\\n        return ans; \\n    }\\n};\\n```\\n**If Helpful PLease Like And Upvoke**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n         int ans = 0; \\n        for (int x = 0; x <=200;x++) \\n            for (int y = 0; y <=200; y++) {\\n                bool found = false; \\n                for (auto& c : circles) \\n                    if (pow(x-c[0], 2) + pow(y-c[1], 2) <= pow(c[2], 2)) \\n                        found = true; \\n                if (found) ans++; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976986,
                "title": "modified-easiest-to-imagine-100-faster",
                "content": "\\n\\nNow, corrected and modified\\n\\n```#define ll long long\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n         \\n        bool g[1000][1000];\\n        memset(g, false, sizeof g);\\n        \\n       \\n        \\n        rep(i , circles.size()){\\n          \\n              for(int p= 0; p<=  circles[i][2] ; p++ )  { \\n\\t\\t\\t  \\n\\t\\t\\t  //// x^2  + y^2 <= radius^2 , Equation of circle \\n\\t\\t\\t  \\n                for(int k=0;   (p*p)+(k*k)<= (circles[i][2]* circles[i][2]) ; k++ ){\\n\\t\\t\\t\\t\\n                    g[circles[i][0]+p] [circles[i][1]+k]=true;\\n                    \\n                     g[circles[i][0]-p] [circles[i][1]+k]=true;\\n                        \\n                     g[circles[i][0]+p] [circles[i][1]-k]=true;\\n                        \\n                     g[circles[i][0]-p] [circles[i][1]-k]=true;\\n                    \\n                      g[circles[i][0]+k] [circles[i][1]-p]=true;\\n                    \\n                     g[circles[i][0]-k] [circles[i][1]+p]=true;\\n                        \\n                     g[circles[i][0]+k] [circles[i][1]-p]=true;\\n                        \\n                     g[circles[i][0]-k] [circles[i][1]-p]=true;\\n                }\\n                    \\n                }\\n               \\n           \\n        }   \\n              ll count=0;         \\n       \\n        rep(i, 1000){\\n            rep(j, 1000){\\n                if(g[i][j]) count++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n         \\n        bool g[1000][1000];\\n        memset(g, false, sizeof g);\\n        \\n       \\n        \\n        rep(i , circles.size()){\\n          \\n              for(int p= 0; p<=  circles[i][2] ; p++ )  { \\n\\t\\t\\t  \\n\\t\\t\\t  //// x^2  + y^2 <= radius^2 , Equation of circle \\n\\t\\t\\t  \\n                for(int k=0;   (p*p)+(k*k)<= (circles[i][2]* circles[i][2]) ; k++ ){\\n\\t\\t\\t\\t\\n                    g[circles[i][0]+p] [circles[i][1]+k]=true;\\n                    \\n                     g[circles[i][0]-p] [circles[i][1]+k]=true;\\n                        \\n                     g[circles[i][0]+p] [circles[i][1]-k]=true;\\n                        \\n                     g[circles[i][0]-p] [circles[i][1]-k]=true;\\n                    \\n                      g[circles[i][0]+k] [circles[i][1]-p]=true;\\n                    \\n                     g[circles[i][0]-k] [circles[i][1]+p]=true;\\n                        \\n                     g[circles[i][0]+k] [circles[i][1]-p]=true;\\n                        \\n                     g[circles[i][0]-k] [circles[i][1]-p]=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1976974,
                "title": "java-bfs",
                "content": "Guess only I did the complex way.\\n\\n\\tclass Solution {\\n\\t\\tpublic int countLatticePoints(int[][] circles) {\\n\\t\\t\\tint[] dx = {1,-1,0,0};\\n\\t\\t\\tint[] dy = {0,0,1,-1};\\n\\t\\t\\tSet<Pair<Integer, Integer>> points = new HashSet<>();\\n\\t\\t\\tQueue<Pair<Integer, Integer>> q = new ArrayDeque<>();\\n\\t\\t\\tfor(int[] circle: circles){\\n\\t\\t\\t\\tq.offer(new Pair<>(circle[0], circle[1]));\\n\\t\\t\\t\\tpoints.add(new Pair<>(circle[0], circle[1]));\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tPair<Integer, Integer> cur = q.poll();\\n\\t\\t\\t\\tfor(int i = 0; i < 4; i++){\\n\\t\\t\\t\\t\\tPair<Integer, Integer> next = new Pair<Integer, Integer>(cur.getKey() + dx[i], cur.getValue() + dy[i]);\\n\\t\\t\\t\\t\\tif(!points.contains(next) && isValid(circles, next)){\\n\\t\\t\\t\\t\\t\\tq.offer(next);\\n\\t\\t\\t\\t\\t\\tpoints.add(next);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points.size();\\n\\t\\t}\\n\\n\\n\\t\\tprivate boolean isValid(int[][] circles, Pair<Integer, Integer> point){\\n\\t\\t\\tfor(int[] circle: circles){\\n\\t\\t\\t\\tint ox = circle[0], oy = circle[1], r = circle[2], x = point.getKey(), y = point.getValue();\\n\\t\\t\\t\\tif(Math.pow(x - ox, 2) + Math.pow(y - oy, 2) <= Math.pow(r, 2)){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countLatticePoints(int[][] circles) {\\n\\t\\t\\tint[] dx = {1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1976962,
                "title": "java-simple-solution-pythagoras-theorem",
                "content": "```\\npublic int countLatticePoints(int[][] circles) {\\n        HashSet<String> answer = new HashSet<>();\\n        for (int[] circle : circles) {\\n            int pX = circle[0];\\n            int pY = circle[1];\\n            int r = circle[2];\\n\\t\\t\\t// Try all possible integer co-oridnates\\n            for (int x = pX - r; x <= pX + r; x++) {\\n                for (int y = pY - r ; y <= pY + r; y++) {\\n\\t\\t\\t\\t   // Check validity, whether it is lattice point using Pythagoras Theorem\\n                    if (isLatticePoint(pX, pY, x, y, r)) {\\n                        answer.add(x + \",\" + y);\\n                    }\\n                }\\n            }\\n        }\\n        return answer.size();\\n    }\\n    \\n     private boolean isLatticePoint(int x1, int y1, int x2, int y2, int r) {\\n        return (x1 - x2)* (x1 - x2) + (y1 - y2) * (y1 - y2) <= r*r;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countLatticePoints(int[][] circles) {\\n        HashSet<String> answer = new HashSet<>();\\n        for (int[] circle : circles) {\\n            int pX = circle[0];\\n            int pY = circle[1];\\n            int r = circle[2];\\n\\t\\t\\t// Try all possible integer co-oridnates\\n            for (int x = pX - r; x <= pX + r; x++) {\\n                for (int y = pY - r ; y <= pY + r; y++) {\\n\\t\\t\\t\\t   // Check validity, whether it is lattice point using Pythagoras Theorem\\n                    if (isLatticePoint(pX, pY, x, y, r)) {\\n                        answer.add(x + \",\" + y);\\n                    }\\n                }\\n            }\\n        }\\n        return answer.size();\\n    }\\n    \\n     private boolean isLatticePoint(int x1, int y1, int x2, int y2, int r) {\\n        return (x1 - x2)* (x1 - x2) + (y1 - y2) * (y1 - y2) <= r*r;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976958,
                "title": "javascript-easy-solution-distance-formula-hash",
                "content": "```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n    let hash = {};\\n    for (let i = 0; i < circles.length; i++) {\\n        let circle = circles[i];\\n        let [x, y, r] = circle;\\n        \\n        for (let p = -r; p <= r; p++) {\\n            for (let q = -r; q <= r; q++) {\\n                if ((Math.pow(p, 2) + Math.pow(q, 2)) <= (Math.pow(r, 2))) {\\n                        hash[[p+x,q+y]]  = 1;\\n                }\\n            }    \\n        }\\n    }\\n    \\n    return Object.keys(hash).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n    let hash = {};\\n    for (let i = 0; i < circles.length; i++) {\\n        let circle = circles[i];\\n        let [x, y, r] = circle;\\n        \\n        for (let p = -r; p <= r; p++) {\\n            for (let q = -r; q <= r; q++) {\\n                if ((Math.pow(p, 2) + Math.pow(q, 2)) <= (Math.pow(r, 2))) {\\n                        hash[[p+x,q+y]]  = 1;\\n                }\\n            }    \\n        }\\n    }\\n    \\n    return Object.keys(hash).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976948,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans=0;\\n        set<pair<int,int>>mp;\\n        for(int i=0;i<circles.size();i++){\\n                int x=circles[i][0];            \\n                int y=circles[i][1];\\n                int r=circles[i][2];\\n            for(int o=x-r;o<=x+r;o++){\\n                for(int v=y-r;v<=y+r;v++){\\n                    int a=((x-o)*(x-o))+((y-v)*(y-v));\\n                    if(a<=r*r){\\n                        mp.insert(make_pair(o,v));\\n                    }\\n                }\\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```\\nPlease Upvote if you found this helpful!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans=0;\\n        set<pair<int,int>>mp;\\n        for(int i=0;i<circles.size();i++){\\n                int x=circles[i][0];            \\n                int y=circles[i][1];\\n                int r=circles[i][2];\\n            for(int o=x-r;o<=x+r;o++){\\n                for(int v=y-r;v<=y+r;v++){\\n                    int a=((x-o)*(x-o))+((y-v)*(y-v));\\n                    if(a<=r*r){\\n                        mp.insert(make_pair(o,v));\\n                    }\\n                }\\n            }\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976841,
                "title": "c-2249-count-lattice-points-inside-a-circle",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans = 0; \\n        for (int x = 0; x <= 200; ++x) \\n            for (int y = 0; y <= 200; ++y) {\\n                bool found = false; \\n                for (auto& c : circles) \\n                    if (pow(x-c[0], 2) + pow(y-c[1], 2) <= pow(c[2], 2)) \\n                        found = true; \\n                if (found) ++ans; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans = 0; \\n        for (int x = 0; x <= 200; ++x) \\n            for (int y = 0; y <= 200; ++y) {\\n                bool found = false; \\n                for (auto& c : circles) \\n                    if (pow(x-c[0], 2) + pow(y-c[1], 2) <= pow(c[2], 2)) \\n                        found = true; \\n                if (found) ++ans; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976806,
                "title": "c-easy-approch-fixing-the-points-which-are-possible",
                "content": "class Solution {\\npublic:\\n    \\n    int findDistance(int i, int j, int x, int y){                // find distance of i and j from center of circle\\n        int a = (x-i)*(x-i);\\n        int b = (y-j)*(y-j);\\n        return ceil(sqrt(a+b));\\n    }\\n    \\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int count = 0;\\n        \\n            for(int x = 0; x <= 200; x++){                 // moving x from 0 -> 200\\n                for(int y = 0; y <= 200; y++){             // moving y from 0 -> 200\\n                    for(auto &p: circles){                 // iterating over circles\\n                    if(findDistance(x,y,p[0],p[1]) <= p[2]){   // find Diatance of x,y from the center of ith circle\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int findDistance(int i, int j, int x, int y){                // find distance of i and j from center of circle\\n        int a = (x-i)*(x-i);\\n        int b = (y-j)*(y-j);\\n        return ceil(sqrt(a+b));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4093338,
                "title": "c-better-than-98-in-time",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        int ans=0;\\n        vector<vector<int>> lattice(201, vector<int>(201, 0));\\n\\n        for(int i=0; i<circles.size(); i++)\\n        {\\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\\n            for(int j=x-r; j<=x+r; j++)\\n            {\\n                for(int k=y-r; k<=y+r; k++)\\n                {\\n                    float dist = sqrt((x-j)*(x-j) + (y-k)*(y-k));\\n                    if(dist <= (float)r and lattice[j][k]++ == 0) ++ans;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n        int ans=0;\\n        vector<vector<int>> lattice(201, vector<int>(201, 0));\\n\\n        for(int i=0; i<circles.size(); i++)\\n        {\\n            int x = circles[i][0], y = circles[i][1], r = circles[i][2];\\n            for(int j=x-r; j<=x+r; j++)\\n            {\\n                for(int k=y-r; k<=y+r; k++)\\n                {\\n                    float dist = sqrt((x-j)*(x-j) + (y-k)*(y-k));\\n                    if(dist <= (float)r and lattice[j][k]++ == 0) ++ans;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090358,
                "title": "simple-distance",
                "content": "# Approach\\nMake sure you call #uniq on circles, or it will trigger a TLE error.\\n\\n\\n# Code\\n```\\ndef count_lattice_points(circles)\\n  lattice_points = Set.new\\n  circles.uniq.each do |x,y,rad|\\n    row_range = x-rad .. x+rad+1\\n    col_range = y-rad .. y+rad+1\\n\\n    row_range.each do |row|\\n      col_range.each do |col|\\n        coords = [row, col]\\n\\n        if (x-row)**2 + (y-col)**2 <= rad**2\\n          lattice_points << coords\\n        end\\n      end\\n    end\\n  end\\n  lattice_points.size\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef count_lattice_points(circles)\\n  lattice_points = Set.new\\n  circles.uniq.each do |x,y,rad|\\n    row_range = x-rad .. x+rad+1\\n    col_range = y-rad .. y+rad+1\\n\\n    row_range.each do |row|\\n      col_range.each do |col|\\n        coords = [row, col]\\n\\n        if (x-row)**2 + (y-col)**2 <= rad**2\\n          lattice_points << coords\\n        end\\n      end\\n    end\\n  end\\n  lattice_points.size\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4086140,
                "title": "just-a-crude-solution-without-optimizations",
                "content": "Just going through all the integer points in the square that describes the circle each circle in circles. And check through the Pythagorean theorem whether this point is inscribed in the circle. Then I add it to the HashSet, which will not add it if such a point has already been added. And return the number of elements.\\n\\n# Code\\n```\\nusing System.Drawing;\\n\\npublic class Solution\\n{\\n    private const int X = 0;\\n    private const int Y = 1;\\n    private const int RADIUS = 2;\\n\\n    public int CountLatticePoints(int[][] circles)\\n    {\\n        var points = new HashSet<Point>();\\n\\n        foreach (var circle in circles)\\n            for (int dx = -circle[RADIUS]; dx <= circle[RADIUS]; dx++)\\n                for (int dy = -circle[RADIUS]; dy <= circle[RADIUS]; dy++)\\n                    if ((dx * dx) + (dy * dy) <= circle[RADIUS] * circle[RADIUS])\\n                        points.Add(new Point(dx + circle[X], dy + circle[Y]));\\n        \\n        return points.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Drawing;\\n\\npublic class Solution\\n{\\n    private const int X = 0;\\n    private const int Y = 1;\\n    private const int RADIUS = 2;\\n\\n    public int CountLatticePoints(int[][] circles)\\n    {\\n        var points = new HashSet<Point>();\\n\\n        foreach (var circle in circles)\\n            for (int dx = -circle[RADIUS]; dx <= circle[RADIUS]; dx++)\\n                for (int dy = -circle[RADIUS]; dy <= circle[RADIUS]; dy++)\\n                    if ((dx * dx) + (dy * dy) <= circle[RADIUS] * circle[RADIUS])\\n                        points.Add(new Point(dx + circle[X], dy + circle[Y]));\\n        \\n        return points.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939044,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int countLatticePoints(int[][] circles) {\\n    int ans = 0;\\n\\n    for (int x = 0; x < 201; ++x)\\n      for (int y = 0; y < 201; ++y)\\n        for (int[] c : circles)\\n          if ((c[0] - x) * (c[0] - x) + (c[1] - y) * (c[1] - y) <= c[2] * c[2]) {\\n            ++ans;\\n            break;\\n          }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int countLatticePoints(int[][] circles) {\\n    int ans = 0;\\n\\n    for (int x = 0; x < 201; ++x)\\n      for (int y = 0; y < 201; ++y)\\n        for (int[] c : circles)\\n          if ((c[0] - x) * (c[0] - x) + (c[1] - y) * (c[1] - y) <= c[2] * c[2]) {\\n            ++ans;\\n            break;\\n          }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939043,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int countLatticePoints(int[][] circles) {\\n    int ans = 0;\\n\\n    for (int x = 0; x < 201; ++x)\\n      for (int y = 0; y < 201; ++y)\\n        for (int[] c : circles)\\n          if ((c[0] - x) * (c[0] - x) + (c[1] - y) * (c[1] - y) <= c[2] * c[2]) {\\n            ++ans;\\n            break;\\n          }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int countLatticePoints(int[][] circles) {\\n    int ans = 0;\\n\\n    for (int x = 0; x < 201; ++x)\\n      for (int y = 0; y < 201; ++y)\\n        for (int[] c : circles)\\n          if ((c[0] - x) * (c[0] - x) + (c[1] - y) * (c[1] - y) <= c[2] * c[2]) {\\n            ++ans;\\n            break;\\n          }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923953,
                "title": "easy-with-set-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> st;\\n\\n        for (const vector<int>& circle : circles) {\\n            int xi = circle[0];\\n            int yi = circle[1];\\n            int r = circle[2];\\n\\n            for (int x = xi - r; x <= xi + r; ++x) {\\n                for (int y = yi - r; y <= yi + r; ++y) {\\n                    if ((x - xi) * (x - xi) + (y - yi) * (y - yi) <= r * r) {\\n                        st.insert({x, y});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> st;\\n\\n        for (const vector<int>& circle : circles) {\\n            int xi = circle[0];\\n            int yi = circle[1];\\n            int r = circle[2];\\n\\n            for (int x = xi - r; x <= xi + r; ++x) {\\n                for (int y = yi - r; y <= yi + r; ++y) {\\n                    if ((x - xi) * (x - xi) + (y - yi) * (y - yi) <= r * r) {\\n                        st.insert({x, y});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911113,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateDistance(int x2,int y2,int x1,int y1){\\n        return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        for(int i = 0;i < circles.size();i++){\\n            float rad = (float)circles[i][2];\\n            int rx = circles[i][0];\\n            int ry = circles[i][1];\\n            for(int x = rx-rad;x <= rx + rad;x++){\\n                for(int y = ry - rad;y <= ry + rad;y++){\\n                    if(rad*rad >= calculateDistance(rx,ry,x,y)){\\n                        s.insert({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateDistance(int x2,int y2,int x1,int y1){\\n        return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        for(int i = 0;i < circles.size();i++){\\n            float rad = (float)circles[i][2];\\n            int rx = circles[i][0];\\n            int ry = circles[i][1];\\n            for(int x = rx-rad;x <= rx + rad;x++){\\n                for(int y = ry - rad;y <= ry + rad;y++){\\n                    if(rad*rad >= calculateDistance(rx,ry,x,y)){\\n                        s.insert({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911111,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int calculateDistance(int x2,int y2,int x1,int y1){\\n        return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        for(int i = 0;i < circles.size();i++){\\n            float rad = (float)circles[i][2];\\n            int rx = circles[i][0];\\n            int ry = circles[i][1];\\n            for(int x = rx-rad;x <= rx + rad;x++){\\n                for(int y = ry - rad;y <= ry + rad;y++){\\n                    if(rad*rad >= calculateDistance(rx,ry,x,y)){\\n                        s.insert({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateDistance(int x2,int y2,int x1,int y1){\\n        return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        for(int i = 0;i < circles.size();i++){\\n            float rad = (float)circles[i][2];\\n            int rx = circles[i][0];\\n            int ry = circles[i][1];\\n            for(int x = rx-rad;x <= rx + rad;x++){\\n                for(int y = ry - rad;y <= ry + rad;y++){\\n                    if(rad*rad >= calculateDistance(rx,ry,x,y)){\\n                        s.insert({x,y});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767780,
                "title": "numpy-is-all-you-needed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nJust use numpy. np.mgrid\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n * 500 * 500)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        import numpy as np\\n        xx, yy = np.mgrid[-200:300,-200:300]\\n        arr = np.full(shape=(500,500),fill_value=False,dtype=bool)\\n        for x,y,r in circles:\\n            arr |= (xx - x) ** 2 + (yy - y) ** 2 <= r ** 2\\n        return arr.sum()\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        import numpy as np\\n        xx, yy = np.mgrid[-200:300,-200:300]\\n        arr = np.full(shape=(500,500),fill_value=False,dtype=bool)\\n        for x,y,r in circles:\\n            arr |= (xx - x) ** 2 + (yy - y) ** 2 <= r ** 2\\n        return arr.sum()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664909,
                "title": "c-simple-grid-iteration-with-lots-of-inline-comments",
                "content": "Please upvote if helpful; thank you!\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountLatticePoints(int[][] circles) \\n    {\\n        int ret = 0; \\n\\n        // store candidate points in a manner that allows fast search afterwards,\\n        // to avoid counting the same point twice\\n        // KEY = the X coordinate and VALUE = all Y coordinates of the points\\n        // having the same X coordinate\\n        var points = new Dictionary<int, HashSet<int>>();\\n        \\n        var n = circles.Length;\\n\\n        // iterate all circles\\n        for(int c = 0; c < n; c++)\\n        {\\n            // extract the center (cx, cy) and radius (r) values\\n            var cx = circles[c][0];\\n            var cy = circles[c][1];\\n            var r = circles[c][2];\\n            var rr = r * r;\\n\\n            // iterate the 2D grid with a 1 unit step (ensures lattice points)\\n            // limited to the circumscribed square of the circle  \\n            var startX = cx - r;\\n            var endX = cx + r;\\n            var startY = cy - r;\\n            var endY = cy + r;\\n\\n            for(int x = startX; x <= endX; x++)\\n                for(int y = startY; y <= endY; y++)\\n                    // check whether the current (x, y) point is inside the circle\\n                    // meaning that the distance from the circle\\'s center to that point\\n                    // is less or equal to that circle\\'s radius\\n                    if (Math.Pow(cx -x, 2) + Math.Pow(cy - y, 2) <= rr)\\n                    {            \\n                        // if the current (x, y) point is a valid candidate,\\n                        // check whether it wasn\\'t already stored/counted\\n                        // if not, store it and increment the result    \\n                        if (!points.ContainsKey(x))\\n                        {\\n                            // add a brand new (x, y) point\\n                            points[x] = new HashSet<int> { y };\\n                            ret++;\\n                        }\\n                        else\\n                            if (!points[x].Contains(y))\\n                            {\\n                                // add a new Y coordinate to the list of points \\n                                // having the same X coordinate   \\n                                points[x].Add(y);\\n                                ret++;\\n                            }\\n                    }\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountLatticePoints(int[][] circles) \\n    {\\n        int ret = 0; \\n\\n        // store candidate points in a manner that allows fast search afterwards,\\n        // to avoid counting the same point twice\\n        // KEY = the X coordinate and VALUE = all Y coordinates of the points\\n        // having the same X coordinate\\n        var points = new Dictionary<int, HashSet<int>>();\\n        \\n        var n = circles.Length;\\n\\n        // iterate all circles\\n        for(int c = 0; c < n; c++)\\n        {\\n            // extract the center (cx, cy) and radius (r) values\\n            var cx = circles[c][0];\\n            var cy = circles[c][1];\\n            var r = circles[c][2];\\n            var rr = r * r;\\n\\n            // iterate the 2D grid with a 1 unit step (ensures lattice points)\\n            // limited to the circumscribed square of the circle  \\n            var startX = cx - r;\\n            var endX = cx + r;\\n            var startY = cy - r;\\n            var endY = cy + r;\\n\\n            for(int x = startX; x <= endX; x++)\\n                for(int y = startY; y <= endY; y++)\\n                    // check whether the current (x, y) point is inside the circle\\n                    // meaning that the distance from the circle\\'s center to that point\\n                    // is less or equal to that circle\\'s radius\\n                    if (Math.Pow(cx -x, 2) + Math.Pow(cy - y, 2) <= rr)\\n                    {            \\n                        // if the current (x, y) point is a valid candidate,\\n                        // check whether it wasn\\'t already stored/counted\\n                        // if not, store it and increment the result    \\n                        if (!points.ContainsKey(x))\\n                        {\\n                            // add a brand new (x, y) point\\n                            points[x] = new HashSet<int> { y };\\n                            ret++;\\n                        }\\n                        else\\n                            if (!points[x].Contains(y))\\n                            {\\n                                // add a new Y coordinate to the list of points \\n                                // having the same X coordinate   \\n                                points[x].Add(y);\\n                                ret++;\\n                            }\\n                    }\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597693,
                "title": "rust-circle-and-boundingbox-structs-with-iterators",
                "content": "# Intuition\\nIt\\'s faster to consider each lattice point, and see if it fits in any circle, than it is to consider each circle, generate points inside it, and then try to dedup.\\n\\nOtherwise, we\\'re just drawing a bounding box that covers the maximum range of points that circles could encompass, and checking each point against each circle until we find one it fits in.\\n\\n# Approach\\nSince we\\'re just comparing against r squared every time, we can save on multiplication costs by storing r_sq along with the Circle object.\\n\\nCreating a BoundingBox type gives us a more ergonomic way to find that largest bounding box using reduce() and iterate over all interior lattice points.\\n\\n# Complexity\\n- Time complexity: O(m * n), for the m x n bounding box containing all the circles. We have to check each point against at least one circle.\\n\\n- Space complexity: O(circles.len()). Technically this could be done in O(1) space if we didn\\'t \\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let circles = circles\\n        .into_iter()\\n        .map(|v| Circle::new(v[0], v[1], v[2]))\\n        .collect::<Vec<Circle>>();\\n\\n        let bounding_box = circles\\n        .iter()\\n        .map(|circle| circle.bounding_box())\\n        .reduce(|a, b| a.merge(b))\\n        .unwrap_or_default();\\n\\n        bounding_box\\n        .into_lattice_iter()\\n        .filter(|&(i, j)| {\\n            circles.iter().any(|circle| circle.contains(i, j))\\n        })\\n        .count() as i32\\n    }\\n}\\n\\nstruct Circle {\\n    pub x: i32,\\n    pub y: i32,\\n    pub r: i32,\\n    pub r_sq: i64,\\n}\\n\\nimpl Circle {\\n    fn new(x: i32, y: i32, r: i32) -> Self {\\n        let r_sq = i64::from(r) * i64::from(r);\\n        Self { x, y, r, r_sq}\\n    }\\n\\n    fn bounding_box(&self) -> BoundingBox {\\n        BoundingBox {\\n            min_x: self.x - self.r,\\n            max_x: self.x + self.r,\\n            min_y: self.y - self.r,\\n            max_y: self.y + self.r,\\n        }\\n    }\\n\\n    fn contains(&self, i: i32, j: i32) -> bool {\\n        let x_distance: i64 = (i - self.x).into();\\n        let y_distance: i64 = (j - self.y).into();\\n        x_distance * x_distance + y_distance * y_distance <= self.r_sq\\n    }\\n}\\n\\n#[derive(Default, Clone, Copy)]\\nstruct BoundingBox {\\n    min_x: i32,\\n    max_x: i32,\\n    min_y: i32,\\n    max_y: i32,\\n}\\n\\nimpl BoundingBox {\\n    pub fn merge(self, other: Self) -> Self {\\n        Self {\\n            min_x: self.min_x.min(other.min_x),\\n            max_x: self.max_x.max(other.max_x),\\n            min_y: self.min_y.min(other.min_y),\\n            max_y: self.max_y.max(other.max_y),\\n        }\\n    }\\n\\n    pub fn into_lattice_iter(self) -> impl Iterator<Item = (i32, i32)> {\\n        (self.min_x..=self.max_x)\\n        .flat_map(move |i| (self.min_y..=self.max_y).map(move |j| (i, j)))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let circles = circles\\n        .into_iter()\\n        .map(|v| Circle::new(v[0], v[1], v[2]))\\n        .collect::<Vec<Circle>>();\\n\\n        let bounding_box = circles\\n        .iter()\\n        .map(|circle| circle.bounding_box())\\n        .reduce(|a, b| a.merge(b))\\n        .unwrap_or_default();\\n\\n        bounding_box\\n        .into_lattice_iter()\\n        .filter(|&(i, j)| {\\n            circles.iter().any(|circle| circle.contains(i, j))\\n        })\\n        .count() as i32\\n    }\\n}\\n\\nstruct Circle {\\n    pub x: i32,\\n    pub y: i32,\\n    pub r: i32,\\n    pub r_sq: i64,\\n}\\n\\nimpl Circle {\\n    fn new(x: i32, y: i32, r: i32) -> Self {\\n        let r_sq = i64::from(r) * i64::from(r);\\n        Self { x, y, r, r_sq}\\n    }\\n\\n    fn bounding_box(&self) -> BoundingBox {\\n        BoundingBox {\\n            min_x: self.x - self.r,\\n            max_x: self.x + self.r,\\n            min_y: self.y - self.r,\\n            max_y: self.y + self.r,\\n        }\\n    }\\n\\n    fn contains(&self, i: i32, j: i32) -> bool {\\n        let x_distance: i64 = (i - self.x).into();\\n        let y_distance: i64 = (j - self.y).into();\\n        x_distance * x_distance + y_distance * y_distance <= self.r_sq\\n    }\\n}\\n\\n#[derive(Default, Clone, Copy)]\\nstruct BoundingBox {\\n    min_x: i32,\\n    max_x: i32,\\n    min_y: i32,\\n    max_y: i32,\\n}\\n\\nimpl BoundingBox {\\n    pub fn merge(self, other: Self) -> Self {\\n        Self {\\n            min_x: self.min_x.min(other.min_x),\\n            max_x: self.max_x.max(other.max_x),\\n            min_y: self.min_y.min(other.min_y),\\n            max_y: self.max_y.max(other.max_y),\\n        }\\n    }\\n\\n    pub fn into_lattice_iter(self) -> impl Iterator<Item = (i32, i32)> {\\n        (self.min_x..=self.max_x)\\n        .flat_map(move |i| (self.min_y..=self.max_y).map(move |j| (i, j)))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591932,
                "title": "java-geometry",
                "content": "class Solution {\\n\\n    public class Pair{\\n        int x;\\n        int y;\\n        public Pair(int xi,int yi){\\n            x=xi;\\n            y=yi;\\n        }\\n    }\\n    \\n    public boolean checkDistance(Pair point,Pair origin,int r){\\n        double dist = Math.sqrt(Math.pow(point.x-origin.x,2) + Math.pow(point.y-origin.y,2));\\n        return dist <= (double)r;\\n    }\\n    \\n    public int countLatticePoints(int[][] circles) {\\n        Set<String> lpoints=new HashSet<String>();\\n        int n=circles.length;\\n        for(int k=0;k<n;k++){\\n            Pair origin = new Pair(circles[k][0],circles[k][1]);\\n            int r=circles[k][2];\\n            Pair lbound = new Pair(origin.x-r,origin.y-r);\\n            Pair ubound = new Pair(origin.x+r,origin.y+r);\\n            for(int i=lbound.x;i<=ubound.x;i++){\\n                for(int j=lbound.y;j<=ubound.y;j++){\\n                    if(checkDistance(new Pair(i,j),origin,r)){\\n                        lpoints.add(i+\" \"+j);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return lpoints.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public class Pair{\\n        int x;\\n        int y;\\n        public Pair(int xi,int yi){\\n            x=xi;\\n            y=yi;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3519848,
                "title": "recursive-solution-c-very-hard-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nDont Know\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   unordered_set<int> uniquePoints;\\n   bool isPointInsideTheCircle(int xCircle,int xPoint,int yCircle ,int yPoint,int circleRadius) {\\n        int xDiff = xCircle - xPoint;\\n        int yDiff = yCircle - yPoint;\\n        int distanceSqr = xDiff * xDiff + yDiff * yDiff;\\n        return distanceSqr <= circleRadius * circleRadius;\\n   }\\n   void helper(const vector<int> &circleCordinates,int tempXPoint,int tempYPoint,int downLimit,int upLimit) {\\n       //base condition out of bounds up and down\\n       if ( (tempYPoint >= downLimit && tempYPoint<= upLimit) == false) {\\n           return ;\\n       }\\n       if (isPointInsideTheCircle(circleCordinates[0],tempXPoint,circleCordinates[1],tempYPoint,circleCordinates[2]) == false) {\\n           return ;\\n       }\\n       int centerXPoint = circleCordinates[0];\\n       int tempLeftPoint = tempXPoint-1;\\n       int tempRightPoint = tempXPoint;\\n       int centerYPoint = circleCordinates[1];\\n       int radius = circleCordinates[2];\\n       //for left\\n       while(isPointInsideTheCircle(centerXPoint,tempLeftPoint,centerYPoint,tempYPoint,radius)) {\\n           int key = tempLeftPoint * 1000000 + tempYPoint;\\n           uniquePoints.insert(key);\\n           tempLeftPoint --;\\n       }\\n       //for right\\n       while(isPointInsideTheCircle(centerXPoint,tempRightPoint,centerYPoint,tempYPoint,radius)) {\\n            int key = tempRightPoint * 1000000 + tempYPoint;\\n           uniquePoints.insert(key);\\n           tempRightPoint ++;\\n       }\\n       //for up\\n       helper(circleCordinates,tempXPoint,tempYPoint+1, tempYPoint+1,upLimit);\\n       //for down\\n       helper(circleCordinates,tempXPoint,tempYPoint-1,downLimit,upLimit-1);\\n   }\\n\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<int> dp;\\n        for(const auto& circle:circles) {\\n            int tempXPoint = circle[0];\\n            int tempYPoint = circle[1];\\n            int key = tempXPoint * 10000 + 1000 * tempYPoint + 100* circle[2];\\n             if (dp.find(key) == dp.end()) {\\n                 helper(circle,tempXPoint,tempYPoint,tempYPoint-circle[2],tempYPoint+circle[2]);\\n                 dp.insert(key);\\n            }\\n             //helper(circle,tempXPoint,tempYPoint,tempYPoint-circle[2],tempYPoint+circle[2]);\\n           \\n        }\\n         return uniquePoints.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   unordered_set<int> uniquePoints;\\n   bool isPointInsideTheCircle(int xCircle,int xPoint,int yCircle ,int yPoint,int circleRadius) {\\n        int xDiff = xCircle - xPoint;\\n        int yDiff = yCircle - yPoint;\\n        int distanceSqr = xDiff * xDiff + yDiff * yDiff;\\n        return distanceSqr <= circleRadius * circleRadius;\\n   }\\n   void helper(const vector<int> &circleCordinates,int tempXPoint,int tempYPoint,int downLimit,int upLimit) {\\n       //base condition out of bounds up and down\\n       if ( (tempYPoint >= downLimit && tempYPoint<= upLimit) == false) {\\n           return ;\\n       }\\n       if (isPointInsideTheCircle(circleCordinates[0],tempXPoint,circleCordinates[1],tempYPoint,circleCordinates[2]) == false) {\\n           return ;\\n       }\\n       int centerXPoint = circleCordinates[0];\\n       int tempLeftPoint = tempXPoint-1;\\n       int tempRightPoint = tempXPoint;\\n       int centerYPoint = circleCordinates[1];\\n       int radius = circleCordinates[2];\\n       //for left\\n       while(isPointInsideTheCircle(centerXPoint,tempLeftPoint,centerYPoint,tempYPoint,radius)) {\\n           int key = tempLeftPoint * 1000000 + tempYPoint;\\n           uniquePoints.insert(key);\\n           tempLeftPoint --;\\n       }\\n       //for right\\n       while(isPointInsideTheCircle(centerXPoint,tempRightPoint,centerYPoint,tempYPoint,radius)) {\\n            int key = tempRightPoint * 1000000 + tempYPoint;\\n           uniquePoints.insert(key);\\n           tempRightPoint ++;\\n       }\\n       //for up\\n       helper(circleCordinates,tempXPoint,tempYPoint+1, tempYPoint+1,upLimit);\\n       //for down\\n       helper(circleCordinates,tempXPoint,tempYPoint-1,downLimit,upLimit-1);\\n   }\\n\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<int> dp;\\n        for(const auto& circle:circles) {\\n            int tempXPoint = circle[0];\\n            int tempYPoint = circle[1];\\n            int key = tempXPoint * 10000 + 1000 * tempYPoint + 100* circle[2];\\n             if (dp.find(key) == dp.end()) {\\n                 helper(circle,tempXPoint,tempYPoint,tempYPoint-circle[2],tempYPoint+circle[2]);\\n                 dp.insert(key);\\n            }\\n             //helper(circle,tempXPoint,tempYPoint,tempYPoint-circle[2],tempYPoint+circle[2]);\\n           \\n        }\\n         return uniquePoints.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515114,
                "title": "javascript-solution-pythagorean-theorem",
                "content": "I totally forgot Pythagorean theorem and got very confused after studied others solution and thought: why every one know how to see if the point is in the circle???\\nTurns out, I return all of them to my school teacher\\n\\nFor every one like me don\\'t know or forgot this,\\n![image](https://assets.leetcode.com/users/images/e45744bd-f030-42b7-814e-7ace20904582_1683874111.6473796.png)\\n(ref to wiki)\\n\\nSo that we will know if a^2 + b^2 <= r^2, the point is in the circle.\\n\\n```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n    let res = 0\\n    \\n    for(let i = 0; i <= 200; i++) {\\n        for(let j = 0; j <= 200; j++) {\\n            for(let [x,y,r] of circles) {\\n                if(Math.pow(Math.abs(x-i), 2) + Math.pow(Math.abs(y-j), 2) <= r * r) {\\n                    res++\\n                    break // no need to check for other circle\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n    let res = 0\\n    \\n    for(let i = 0; i <= 200; i++) {\\n        for(let j = 0; j <= 200; j++) {\\n            for(let [x,y,r] of circles) {\\n                if(Math.pow(Math.abs(x-i), 2) + Math.pow(Math.abs(y-j), 2) <= r * r) {\\n                    res++\\n                    break // no need to check for other circle\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490694,
                "title": "basic-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif the distance between a point and the centre is less than or equal to the radius then the point is in the circle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\neach circle would be boxed in a square of length 2*r.\\nNumber of points in the square = (2*r+1)^2.\\nCalculate the distance between each point and the centre if its less than the length of the radius then the point is inside the circle.\\nWe push the points in a set to as to eliminate repetitions. \\nIn the end we return the size of the set.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& nums) {\\n        int dis=0;\\n        set<pair<int,int>> v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i][0]-nums[i][2],y=nums[i][1]-nums[i][2];\\n            int x1=nums[i][0]+nums[i][2],y1=nums[i][1]+nums[i][2];\\n            for(int k=x;k<=x1;k++)\\n            {\\n                for(int j=y;j<=y1;j++)\\n                {\\n                    if( (j-nums[i][1])*(j-nums[i][1]) + (k-nums[i][0])*(k-nums[i][0]) <= nums[i][2] * nums[i][2] ) \\n                    {\\n                        pair<int,int> m=make_pair(k,j);\\n                        v.insert(m);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& nums) {\\n        int dis=0;\\n        set<pair<int,int>> v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i][0]-nums[i][2],y=nums[i][1]-nums[i][2];\\n            int x1=nums[i][0]+nums[i][2],y1=nums[i][1]+nums[i][2];\\n            for(int k=x;k<=x1;k++)\\n            {\\n                for(int j=y;j<=y1;j++)\\n                {\\n                    if( (j-nums[i][1])*(j-nums[i][1]) + (k-nums[i][0])*(k-nums[i][0]) <= nums[i][2] * nums[i][2] ) \\n                    {\\n                        pair<int,int> m=make_pair(k,j);\\n                        v.insert(m);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321917,
                "title": "83-ms",
                "content": "Proof: https://leetcode.com/submissions/detail/919140993/\\n```ruby\\n@m = {}\\n\\ndef count_lattice_points a\\n    g = Hash.new { _1[_2] = [] }\\n    for x, y, r in a\\n        t = (x << 8) | x\\n        g[y - r] << t\\n        g[y + r] << t\\n        g[y].push (x - r << 8) | x + r\\n        v = @m[r] ||= begin\\n            r2 = r * r\\n            (1...r).map do\\n                Integer.sqrt(r2 - _1 * _1)\\n            end\\n        end\\n        yt = yb = y\\n        v.each do | d |\\n            t = (x - d << 8) | x + d\\n            g[yt -= 1] << t\\n            g[yb += 1] << t\\n        end\\n    end\\n    g.each_value.sum do | a |\\n        a.sort!\\n        s = 0\\n        until a.empty?\\n            b, e = (k = a.shift) >> 8, k & 255\\n            while k = a.first\\n                break if (k >> 8) > e\\n                a.shift\\n                e = k if (k &= 255) > e\\n            end\\n            s += e - b + 1\\n        end\\n        s\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n@m = {}\\n\\ndef count_lattice_points a\\n    g = Hash.new { _1[_2] = [] }\\n    for x, y, r in a\\n        t = (x << 8) | x\\n        g[y - r] << t\\n        g[y + r] << t\\n        g[y].push (x - r << 8) | x + r\\n        v = @m[r] ||= begin\\n            r2 = r * r\\n            (1...r).map do\\n                Integer.sqrt(r2 - _1 * _1)\\n            end\\n        end\\n        yt = yb = y\\n        v.each do | d |\\n            t = (x - d << 8) | x + d\\n            g[yt -= 1] << t\\n            g[yb += 1] << t\\n        end\\n    end\\n    g.each_value.sum do | a |\\n        a.sort!\\n        s = 0\\n        until a.empty?\\n            b, e = (k = a.shift) >> 8, k & 255\\n            while k = a.first\\n                break if (k >> 8) > e\\n                a.shift\\n                e = k if (k &= 255) > e\\n            end\\n            s += e - b + 1\\n        end\\n        s\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3300469,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nenumerate all of the point in the square whose left lower coner is at (xc-r, yc-r) and right upper corner is at (xc+r, yc+r)\\nand check the distance between the point and center is not greater than radius\\n\\n\\'\\'\\'\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        ans = set()\\n        for xc, yc, r in circles:\\n            for y in range(yc-r, yc+r+1):\\n                for x in range(xc-r, xc+r+1):\\n                    if (x, y) not in ans and self.distanceSquare(x, y, xc, yc) <= r * r:\\n                        ans.add((x,y))\\n        return len(ans)\\n\\n    def distanceSquare(self, x1, y1, x2, y2):\\n        return (x1-x2)**2 + (y1-y2)**2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\nenumerate all of the point in the square whose left lower coner is at (xc-r, yc-r) and right upper corner is at (xc+r, yc+r)\\nand check the distance between the point and center is not greater than radius\\n\\n\\'\\'\\'\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        ans = set()\\n        for xc, yc, r in circles:\\n            for y in range(yc-r, yc+r+1):\\n                for x in range(xc-r, xc+r+1):\\n                    if (x, y) not in ans and self.distanceSquare(x, y, xc, yc) <= r * r:\\n                        ans.add((x,y))\\n        return len(ans)\\n\\n    def distanceSquare(self, x1, y1, x2, y2):\\n        return (x1-x2)**2 + (y1-y2)**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242674,
                "title": "simple-neat-explanation-clean-c-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo count the number of lattice points present inside the circles, we can iterate through each circle, consider all points within the radius of the circle, and add them to a set. In the end, the size of the set will give us the count of unique lattice points that are present inside at least one circle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a set of pairs to store all unique lattice points present inside the circles.\\n1. For each circle in the given array of circles:\\n    1. Iterate through all points within the radius of the circle.\\n    1. If the distance between the current point and the center of the circle is less than or equal to the radius of the circle, add the point to the set.\\n1. The size of the set will give us the count of unique lattice points present inside the circles.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, For each circle, we iterate through all points within its radius. Therefore, the time complexity is O(nr^2), where n is the number of circles and r is the maximum radius among all circles. Since r <= 5000, the time complexity is effectively O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nr^2)$$, We use a set to store all unique lattice points present inside the circles. The worst-case size of the set is when all lattice points are present inside the circles. In that case, the size of the set is O(nr^2). Therefore, the space complexity is O(nr^2).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> set1;\\n        for(const auto &circle: circles) {\\n            int x = circle[0], y = circle[1], r = circle[2];\\n            for(int i = -r; i <= r; i++) {\\n                for(int j = -r; j <= r; j++) {\\n                    if(i*i + j*j <= r*r) {\\n                        set1.insert({i + x, j + y});\\n                    }\\n                }\\n            }\\n        }\\n        int res = set1.size();\\n        return res;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        for(int[] circle: circles) {\\n            int x = circle[0], y = circle[1], r = circle[2];\\n            for(int i = -r; i <= r; i++) {\\n                for(int j = -r; j <= r; j++) {\\n                    if(i*i + j*j <= r*r) {\\n                        set.add(new Pair<>(i + x, j + y));\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> set1;\\n        for(const auto &circle: circles) {\\n            int x = circle[0], y = circle[1], r = circle[2];\\n            for(int i = -r; i <= r; i++) {\\n                for(int j = -r; j <= r; j++) {\\n                    if(i*i + j*j <= r*r) {\\n                        set1.insert({i + x, j + y});\\n                    }\\n                }\\n            }\\n        }\\n        int res = set1.size();\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Pair<Integer, Integer>> set = new HashSet<>();\\n        for(int[] circle: circles) {\\n            int x = circle[0], y = circle[1], r = circle[2];\\n            for(int i = -r; i <= r; i++) {\\n                for(int j = -r; j <= r; j++) {\\n                    if(i*i + j*j <= r*r) {\\n                        set.add(new Pair<>(i + x, j + y));\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200008,
                "title": "c",
                "content": "```\\nbool check(int** circles, int circlesSize, int x,  int y){\\n    \\n    for(int i = 0; i < circlesSize; i++){\\n        int R = circles[i][2] * circles[i][2] ;\\n        int a = circles[i][0] ;\\n        int b = circles[i][1] ;\\n        if( ((x-a)*(x-a) + (y-b)*(y-b)) <= R )\\n            return true ;\\n    }    \\n    return false ;\\n}\\nint countLatticePoints(int** circles, int circlesSize, int* circlesColSize){\\n    int ans = 0; \\n    for(int i = 0; i < 201; i++){\\n        for(int j = 0; j < 201; j++)\\n            ans += check(circles, circlesSize, i, j) ;\\n    }\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool check(int** circles, int circlesSize, int x,  int y){\\n    \\n    for(int i = 0; i < circlesSize; i++){\\n        int R = circles[i][2] * circles[i][2] ;\\n        int a = circles[i][0] ;\\n        int b = circles[i][1] ;\\n        if( ((x-a)*(x-a) + (y-b)*(y-b)) <= R )\\n            return true ;\\n    }    \\n    return false ;\\n}\\nint countLatticePoints(int** circles, int circlesSize, int* circlesColSize){\\n    int ans = 0; \\n    for(int i = 0; i < 201; i++){\\n        for(int j = 0; j < 201; j++)\\n            ans += check(circles, circlesSize, i, j) ;\\n    }\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3191959,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n=circles.size();\\n        set<pair<int,int>> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=circles[i][0],y=circles[i][1],r=circles[i][2];\\n            \\n            for(int a=x-r;a<=x+r;a++)\\n            {\\n                for(int b=y-r;b<=y+r;b++)\\n                {\\n                    if((a-x)*(a-x)+(b-y)*(b-y)<=r*r)\\n                    {\\n                        s.insert({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n=circles.size();\\n        set<pair<int,int>> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=circles[i][0],y=circles[i][1],r=circles[i][2];\\n            \\n            for(int a=x-r;a<=x+r;a++)\\n            {\\n                for(int b=y-r;b<=y+r;b++)\\n                {\\n                    if((a-x)*(a-x)+(b-y)*(b-y)<=r*r)\\n                    {\\n                        s.insert({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160661,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) \\n    {\\n        Set<List<Integer>> set=new HashSet<>();\\n        \\n        for(int[] row:circles)\\n        {\\n            int x=row[0];\\n            int y=row[1];\\n            int r=row[2];\\n            \\n            for(int i=x-r;i<=x+r;i++)\\n            {\\n                for(int j=y-r;j<=y+r;j++)\\n                {\\n                    double dist=Math.sqrt(Math.pow(i-x,2)+Math.pow(j-y,2));\\n                    if(dist<=r)\\n                    {\\n                        List<Integer> list=new ArrayList<>();\\n                        list.add(i);\\n                        list.add(j);\\n                        set.add(list);\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n    \\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) \\n    {\\n        Set<List<Integer>> set=new HashSet<>();\\n        \\n        for(int[] row:circles)\\n        {\\n            int x=row[0];\\n            int y=row[1];\\n            int r=row[2];\\n            \\n            for(int i=x-r;i<=x+r;i++)\\n            {\\n                for(int j=y-r;j<=y+r;j++)\\n                {\\n                    double dist=Math.sqrt(Math.pow(i-x,2)+Math.pow(j-y,2));\\n                    if(dist<=r)\\n                    {\\n                        List<Integer> list=new ArrayList<>();\\n                        list.add(i);\\n                        list.add(j);\\n                        set.add(list);\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147922,
                "title": "c-solution-with-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider the square bounding the circle at 4 points, like a tangent. We know that, no points outside the square will ever belong to the circles. So, consider all points inside the circle and check if they lie in the circles or outside the circle, for each of the circles in the given vector.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck for the point:\\nLet point = (x1,y1)\\nCentre = (x0,y0)\\nRadius = r\\n\\nIf (x1-x0)^2 + (y1-y0)^2 < r^2, then point lies inside, else outside.\\nStore all the inside points in a set. In the end, return the size of the set.\\n\\n# Complexity\\nFor each circle, with:\\ncentre = (x,y)\\nradius = r\\nR is the maximum radius of all\\n- Time complexity: O(NRR)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(Number of lattice points), which is upper bounded by NRR\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        int n = circles.size();\\n        for(int i=0;i<n;i++){\\n            int cx = circles[i][0], cy = circles[i][1], r = circles[i][2];\\n            int x0 = cx-r;\\n            int x1 = cx+r;\\n            int y0 = cy-r;\\n            int y1 = cy+r;\\n\\n            for(int a = x0; a<= x1; a++){\\n                for(int b = y0;b<=y1;b++){\\n                    if( (a-circles[i][0])*(a-circles[i][0]) + (b-circles[i][1])*(b-circles[i][1]) <= circles[i][2]*circles[i][2])\\n                    s.insert({a,b});\\n                }\\n            }\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        int n = circles.size();\\n        for(int i=0;i<n;i++){\\n            int cx = circles[i][0], cy = circles[i][1], r = circles[i][2];\\n            int x0 = cx-r;\\n            int x1 = cx+r;\\n            int y0 = cy-r;\\n            int y1 = cy+r;\\n\\n            for(int a = x0; a<= x1; a++){\\n                for(int b = y0;b<=y1;b++){\\n                    if( (a-circles[i][0])*(a-circles[i][0]) + (b-circles[i][1])*(b-circles[i][1]) <= circles[i][2]*circles[i][2])\\n                    s.insert({a,b});\\n                }\\n            }\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145996,
                "title": "c-trade-space-for-runtime",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan[][] is used to record the points\\' status, that is,\\ncan[i][j] = true if (i,j) is in one of circles.\\n\\nUnder the conditions of problem,\\nWe only need to check 0( r<= min(i, j) ) <= i,j <= 100+min(100,100).\\nBesides, we don\\'t need to check (i,j) again if (i,j) is already in previous circle.\\n\\n# Complexity\\n- Time complexity:\\nn = circles.size()\\nO(n * 200 * 200) = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### This is my Hundredth problem that is Accepted, Yeah. :100:\\n\\n# Code\\n```\\nbool inCircle(int x,int y,int cx,int cy,int r){\\n    if((x-cx)*(x-cx) + (y-cy)*(y-cy) <= r*r) return true;\\n    return false;\\n}\\nclass Solution {\\npublic:\\n   \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int len = circles.size();\\n        bool can[205][205]={false};\\n        \\n        int ans=0;\\n        for(int w=0;w<len;w++){\\n            int cx = circles[w][0];\\n            int cy = circles[w][1];\\n            int r = circles[w][2];\\n            \\n            for(int i=0;i<=200;i++){\\n                for(int j=0;j<=200;j++){\\n                    if(!can[i][j] && inCircle(i,j,cx,cy,r)){\\n                        can[i][j] = true;\\n                        ans ++;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool inCircle(int x,int y,int cx,int cy,int r){\\n    if((x-cx)*(x-cx) + (y-cy)*(y-cy) <= r*r) return true;\\n    return false;\\n}\\nclass Solution {\\npublic:\\n   \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int len = circles.size();\\n        bool can[205][205]={false};\\n        \\n        int ans=0;\\n        for(int w=0;w<len;w++){\\n            int cx = circles[w][0];\\n            int cy = circles[w][1];\\n            int r = circles[w][2];\\n            \\n            for(int i=0;i<=200;i++){\\n                for(int j=0;j<=200;j++){\\n                    if(!can[i][j] && inCircle(i,j,cx,cy,r)){\\n                        can[i][j] = true;\\n                        ans ++;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139817,
                "title": "java-solution-easy-understanding",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<List<Integer>> points = new HashSet<>();\\n        for (int[] circle : circles) {\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            for (int i = x - r; i <= x + r; i++) {\\n                for (int j = y - r; j <= y + r; j++) {\\n                    double distanceFromCenter = Math.sqrt(Math.pow(i - x, 2) + Math.pow(j - y, 2));\\n                    if (distanceFromCenter <= r) {\\n                        List<Integer> point = new ArrayList<>();\\n                        point.add(i);\\n                        point.add(j);\\n                        points.add(point);\\n                    }\\n                }\\n            }\\n        }\\n        return points.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<List<Integer>> points = new HashSet<>();\\n        for (int[] circle : circles) {\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            for (int i = x - r; i <= x + r; i++) {\\n                for (int j = y - r; j <= y + r; j++) {\\n                    double distanceFromCenter = Math.sqrt(Math.pow(i - x, 2) + Math.pow(j - y, 2));\\n                    if (distanceFromCenter <= r) {\\n                        List<Integer> point = new ArrayList<>();\\n                        point.add(i);\\n                        point.add(j);\\n                        points.add(point);\\n                    }\\n                }\\n            }\\n        }\\n        return points.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117321,
                "title": "scala-oneliner",
                "content": "# Code\\n```\\nobject Solution {\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    circles.map{case Array(a,b,r) => (a,b,r)}.to(Set).asInstanceOf[Set[(Int,Int,Int)]]\\n    .flatMap{case (a:Int,b:Int,r:Int) =>\\n      ((a-r) to (a+r)).flatMap{x=>\\n        ((b-r) to (b+r)).filter{y=>((x-a)*(x-a)+(y-b)*(y-b)<=r*r)}.map(x -> _)\\n      }\\n    }.size\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Scala",
                    "Geometry"
                ],
                "code": "```\\nobject Solution {\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    circles.map{case Array(a,b,r) => (a,b,r)}.to(Set).asInstanceOf[Set[(Int,Int,Int)]]\\n    .flatMap{case (a:Int,b:Int,r:Int) =>\\n      ((a-r) to (a+r)).flatMap{x=>\\n        ((b-r) to (b+r)).filter{y=>((x-a)*(x-a)+(y-b)*(y-b)<=r*r)}.map(x -> _)\\n      }\\n    }.size\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3086750,
                "title": "c-using-set",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> Set;\\n        int xi,yi,ri;\\n        for(auto circle : circles){\\n            xi = circle[0];\\n            yi = circle[1];\\n            ri = circle[2];\\n            for(int x = xi-ri; x <= xi+ri; x++){\\n                for(int y = yi-ri; y <= yi+ri; y++){\\n                    if((y-yi)*(y-yi) + (x-xi)*(x-xi) <= ri*ri){\\n                        Set.insert(make_pair(x,y));\\n                    }\\n                }\\n            }\\n        }\\n        return Set.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> Set;\\n        int xi,yi,ri;\\n        for(auto circle : circles){\\n            xi = circle[0];\\n            yi = circle[1];\\n            ri = circle[2];\\n            for(int x = xi-ri; x <= xi+ri; x++){\\n                for(int y = yi-ri; y <= yi+ri; y++){\\n                    if((y-yi)*(y-yi) + (x-xi)*(x-xi) <= ri*ri){\\n                        Set.insert(make_pair(x,y));\\n                    }\\n                }\\n            }\\n        }\\n        return Set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058906,
                "title": "easy-maths-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& arr) \\n    {\\n        set<pair<int,int>>st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int x1 = arr[i][0];\\n            int y1 = arr[i][1];\\n            int r =  arr[i][2];\\n\\n            for(int j=0;j<=200;j++)\\n            {\\n                int x2 = j;\\n                for(int k=0;k<=200;k++)\\n                {\\n                    int y2 = k;\\n                    \\n                    double dis = sqrt(pow((x2-x1),2) + pow((y2-y1),2));\\n                       \\n                    if(dis <= r)\\n                    {\\n                        st.insert(make_pair(x2,y2));\\n                    }\\n\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& arr) \\n    {\\n        set<pair<int,int>>st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int x1 = arr[i][0];\\n            int y1 = arr[i][1];\\n            int r =  arr[i][2];\\n\\n            for(int j=0;j<=200;j++)\\n            {\\n                int x2 = j;\\n                for(int k=0;k<=200;k++)\\n                {\\n                    int y2 = k;\\n                    \\n                    double dis = sqrt(pow((x2-x1),2) + pow((y2-y1),2));\\n                       \\n                    if(dis <= r)\\n                    {\\n                        st.insert(make_pair(x2,y2));\\n                    }\\n\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052923,
                "title": "c-solution-beats-92-runtime",
                "content": "# Intuition\\nUse the distance formula to check if the point is within a cirlce.\\n\\n# Approach\\nI will create a rectangle that bounds every circle to create a search space, then test every point in that search space. To deal with overlapping, I will break the for loop once a point has been found to be inside at least one circle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int square(int a){\\n        return a*a;\\n    }\\n    double dist(int x, int y, int a, int b){\\n        double distance = sqrt((square(x - a)) + (square(y - b)));\\n        return distance;\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int comp = 0;\\n        int lowerX = circles[0][0] - circles[0][2];\\n        int lowerY = circles[0][1] - circles[0][2];\\n        int upperX = circles[0][0] + circles[0][2];\\n        int upperY = circles[0][1] + circles[0][2];\\n        //Construct the bounds of the bounding rectangle\\n\\n        //Lower X Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][0] - circles[i][2] < lowerX){\\n                lowerX = circles[i][0] - circles[i][2];\\n            }\\n        }\\n        //Lower Y Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][1] - circles[i][2] < lowerY){\\n                lowerY = circles[i][1] - circles[i][2];\\n            }\\n        }\\n        //Upper X Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][0] + circles[i][2] > upperX){\\n                upperX = circles[i][0] + circles[i][2];\\n            }\\n        }\\n        //Upper Y Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][1] + circles[i][2] > upperY){\\n                upperY = circles[i][1] + circles[i][2];\\n            }\\n        }\\n        for (int x = lowerX; x <= upperX; x++){\\n            for (int y = lowerY; y <= upperY; y++){\\n                for (int i = 0; i < circles.size(); i++){\\n                    if (dist(x, y, circles[i][0], circles[i][1]) <= circles[i][2]){\\n                        comp++;\\n                        break;\\n                    }\\n             }\\n            }\\n        }\\n        return comp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int square(int a){\\n        return a*a;\\n    }\\n    double dist(int x, int y, int a, int b){\\n        double distance = sqrt((square(x - a)) + (square(y - b)));\\n        return distance;\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int comp = 0;\\n        int lowerX = circles[0][0] - circles[0][2];\\n        int lowerY = circles[0][1] - circles[0][2];\\n        int upperX = circles[0][0] + circles[0][2];\\n        int upperY = circles[0][1] + circles[0][2];\\n        //Construct the bounds of the bounding rectangle\\n\\n        //Lower X Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][0] - circles[i][2] < lowerX){\\n                lowerX = circles[i][0] - circles[i][2];\\n            }\\n        }\\n        //Lower Y Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][1] - circles[i][2] < lowerY){\\n                lowerY = circles[i][1] - circles[i][2];\\n            }\\n        }\\n        //Upper X Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][0] + circles[i][2] > upperX){\\n                upperX = circles[i][0] + circles[i][2];\\n            }\\n        }\\n        //Upper Y Bound\\n        for (int i = 0; i < circles.size(); i++){\\n            if (circles[i][1] + circles[i][2] > upperY){\\n                upperY = circles[i][1] + circles[i][2];\\n            }\\n        }\\n        for (int x = lowerX; x <= upperX; x++){\\n            for (int y = lowerY; y <= upperY; y++){\\n                for (int i = 0; i < circles.size(); i++){\\n                    if (dist(x, y, circles[i][0], circles[i][1]) <= circles[i][2]){\\n                        comp++;\\n                        break;\\n                    }\\n             }\\n            }\\n        }\\n        return comp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977008,
                "title": "faster-than-fastest-65ms-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOverlapping points?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMerge intervals\\n\\n# Code\\n```\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n    ivals = [[] for x in range(201)]\\n    for cx,cy,cr in circles:\\n            for k in range(-cr,cr+1):\\n                d = math.floor(math.sqrt(cr*cr - k*k)) # lil bit of geometry\\n                ivals[cx+k].append((cy-d,cy+d)) # add the y interval \\n    res = 0\\n    for x in ivals:\\n        x.sort() # common merge subroutine\\n        last = -1 \\n        for ival in x:\\n            if(ival[1]<=last): continue # will not contribute to ans\\n            res +=(ival[1]-max(ival[0],last+1) + 1)\\n            last = max(ival[1],last)\\n    return res        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n    ivals = [[] for x in range(201)]\\n    for cx,cy,cr in circles:\\n            for k in range(-cr,cr+1):\\n                d = math.floor(math.sqrt(cr*cr - k*k)) # lil bit of geometry\\n                ivals[cx+k].append((cy-d,cy+d)) # add the y interval \\n    res = 0\\n    for x in ivals:\\n        x.sort() # common merge subroutine\\n        last = -1 \\n        for ival in x:\\n            if(ival[1]<=last): continue # will not contribute to ans\\n            res +=(ival[1]-max(ival[0],last+1) + 1)\\n            last = max(ival[1],last)\\n    return res        \\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2955287,
                "title": "c-beats-100-easy-to-parallelize-o-crlogr-for-max-radius-r-and-c-circles",
                "content": "```\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    inline pair<int, int> get_interval(int x, int y, int rad, int row) {\\n        assert(abs(y - row) <= rad); // We do not support doing rows in which no circle elements are present\\n\\n        // Can be improved by knowing which row you are in specifically, which should narrow down\\n        // your compute to O(1) here instead of O(log(r))\\n        int x_lo = min(x - rad - 1, -1); // You can prove this point is NEVER in the circle\\n        int x_hi = x;                    // You can prove this point is ALWAYS in the circle\\n        int rad2 = rad * rad;\\n        while (x_lo + 1 < x_hi) {\\n            assert(0 <= x_hi && x_hi <= 100);\\n\\n            // This is an x_hi-inclusive BS\\n            int x_mid = x_hi - (x_hi - x_lo) / 2;\\n            assert(0 <= x_mid && x_mid <= 100);\\n\\n            // Distance displacements\\n            int dx = x_mid - x;\\n            int dy = row - y;\\n            if (dx * dx + dy * dy > rad2) x_lo = x_mid; // x_mid Definately NOT in the circle\\n            else x_hi = x_mid;                          // x_mid Definately in the circle\\n        }\\n        assert(0 <= x_hi && x_hi <= 100);\\n\\n        int x_start = x_hi;\\n        int x_end = x + (x - x_hi);\\n        // DEBUG\\n        // cout << \"interval in row \" << row << \" for circle \" << x << \" \" << y << \" \" << rad << \" is \" << x_start << \" \" << x_end << \"\\\\n\"; \\n        return pair<int, int>(x_start, x_end);\\n    }\\n    inline void insert_interval(unordered_map<int, vector<pair<int, int>>>& intervals_rows, int row, pair<int, int> interval) {\\n        // You could use BS here but I got a little lazy and I\\'m also not sure it matters asymptotically unless\\n        // you have some sort of faster way to insert/move around inside the array (i.e. a linkedlist type structure)\\n        assert(intervals_rows[row].size() >= 1);\\n        vector<pair<int, int>>& old_intervals = intervals_rows[row];\\n        vector<pair<int, int>>  new_intervals;\\n        int i = 0;\\n        while (i < old_intervals.size() && old_intervals[i].first < interval.first) { new_intervals.push_back(old_intervals[i]); i++; }\\n\\n        assert(i == new_intervals.size());\\n        if (i > 0 && interval.first <= new_intervals[new_intervals.size() - 1].second) {\\n            int prev_second = new_intervals[new_intervals.size() - 1].second;\\n            new_intervals[new_intervals.size() - 1].second = max(prev_second, interval.second);\\n        } else new_intervals.push_back(interval);\\n\\n        while (i < old_intervals.size() && old_intervals[i].first <= new_intervals[new_intervals.size() - 1].second) {\\n            int prev_second = new_intervals[new_intervals.size() - 1].second;\\n            new_intervals[new_intervals.size() - 1].second = max(prev_second, old_intervals[i].second);\\n            i++;\\n        }\\n        while (i < old_intervals.size()) { new_intervals.push_back(old_intervals[i]); i++; }\\n\\n        intervals_rows[row] = new_intervals;\\n    }\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_map<int, vector<pair<int, int>>> intervals;\\n        // O(crlog(r)), possible with some high school math to turn into O(cr) if\\n        // there are c circles and each has max radius r\\n        for (vector<int>& circle: circles) {\\n            int x = circle[0]; int y = circle[1]; int rad = circle[2];\\n            for (int row = y - rad; row <= y + rad; row++) {\\n                pair<int, int> interval = get_interval(x, y, rad, row);\\n                if (intervals.find(row) == intervals.end()) {\\n                    intervals[row] = vector<pair<int, int>>(1, interval);\\n                } else {\\n                    // DEBUG\\n                    // cout << \"circle \" << x << \" \" << y << \" \" << rad << \" and row \" << row << \"\\\\n\";\\n                    insert_interval(intervals, row, interval);\\n                }\\n            }\\n        }\\n\\n        // Parallalizeable and good for cache\\n        // Inclusive intervals of all the points inside a circle\\n        int count = 0;\\n        for (auto& _ir : intervals) {\\n            vector<pair<int, int>>& interval_row = _ir.second;\\n            for (pair<int, int>& interval : interval_row) {\\n                assert(interval.first <= interval.second);\\n\\n                int x1 = interval.first; int x2 = interval.second;\\n                count += x2 - x1 + 1; // It\\'s inclusive on both sides\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    inline pair<int, int> get_interval(int x, int y, int rad, int row) {\\n        assert(abs(y - row) <= rad); // We do not support doing rows in which no circle elements are present\\n\\n        // Can be improved by knowing which row you are in specifically, which should narrow down\\n        // your compute to O(1) here instead of O(log(r))\\n        int x_lo = min(x - rad - 1, -1); // You can prove this point is NEVER in the circle\\n        int x_hi = x;                    // You can prove this point is ALWAYS in the circle\\n        int rad2 = rad * rad;\\n        while (x_lo + 1 < x_hi) {\\n            assert(0 <= x_hi && x_hi <= 100);\\n\\n            // This is an x_hi-inclusive BS\\n            int x_mid = x_hi - (x_hi - x_lo) / 2;\\n            assert(0 <= x_mid && x_mid <= 100);\\n\\n            // Distance displacements\\n            int dx = x_mid - x;\\n            int dy = row - y;\\n            if (dx * dx + dy * dy > rad2) x_lo = x_mid; // x_mid Definately NOT in the circle\\n            else x_hi = x_mid;                          // x_mid Definately in the circle\\n        }\\n        assert(0 <= x_hi && x_hi <= 100);\\n\\n        int x_start = x_hi;\\n        int x_end = x + (x - x_hi);\\n        // DEBUG\\n        // cout << \"interval in row \" << row << \" for circle \" << x << \" \" << y << \" \" << rad << \" is \" << x_start << \" \" << x_end << \"\\\\n\"; \\n        return pair<int, int>(x_start, x_end);\\n    }\\n    inline void insert_interval(unordered_map<int, vector<pair<int, int>>>& intervals_rows, int row, pair<int, int> interval) {\\n        // You could use BS here but I got a little lazy and I\\'m also not sure it matters asymptotically unless\\n        // you have some sort of faster way to insert/move around inside the array (i.e. a linkedlist type structure)\\n        assert(intervals_rows[row].size() >= 1);\\n        vector<pair<int, int>>& old_intervals = intervals_rows[row];\\n        vector<pair<int, int>>  new_intervals;\\n        int i = 0;\\n        while (i < old_intervals.size() && old_intervals[i].first < interval.first) { new_intervals.push_back(old_intervals[i]); i++; }\\n\\n        assert(i == new_intervals.size());\\n        if (i > 0 && interval.first <= new_intervals[new_intervals.size() - 1].second) {\\n            int prev_second = new_intervals[new_intervals.size() - 1].second;\\n            new_intervals[new_intervals.size() - 1].second = max(prev_second, interval.second);\\n        } else new_intervals.push_back(interval);\\n\\n        while (i < old_intervals.size() && old_intervals[i].first <= new_intervals[new_intervals.size() - 1].second) {\\n            int prev_second = new_intervals[new_intervals.size() - 1].second;\\n            new_intervals[new_intervals.size() - 1].second = max(prev_second, old_intervals[i].second);\\n            i++;\\n        }\\n        while (i < old_intervals.size()) { new_intervals.push_back(old_intervals[i]); i++; }\\n\\n        intervals_rows[row] = new_intervals;\\n    }\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_map<int, vector<pair<int, int>>> intervals;\\n        // O(crlog(r)), possible with some high school math to turn into O(cr) if\\n        // there are c circles and each has max radius r\\n        for (vector<int>& circle: circles) {\\n            int x = circle[0]; int y = circle[1]; int rad = circle[2];\\n            for (int row = y - rad; row <= y + rad; row++) {\\n                pair<int, int> interval = get_interval(x, y, rad, row);\\n                if (intervals.find(row) == intervals.end()) {\\n                    intervals[row] = vector<pair<int, int>>(1, interval);\\n                } else {\\n                    // DEBUG\\n                    // cout << \"circle \" << x << \" \" << y << \" \" << rad << \" and row \" << row << \"\\\\n\";\\n                    insert_interval(intervals, row, interval);\\n                }\\n            }\\n        }\\n\\n        // Parallalizeable and good for cache\\n        // Inclusive intervals of all the points inside a circle\\n        int count = 0;\\n        for (auto& _ir : intervals) {\\n            vector<pair<int, int>>& interval_row = _ir.second;\\n            for (pair<int, int>& interval : interval_row) {\\n                assert(interval.first <= interval.second);\\n\\n                int x1 = interval.first; int x2 = interval.second;\\n                count += x2 - x1 + 1; // It\\'s inclusive on both sides\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2906935,
                "title": "c-simple-some-geometry",
                "content": "```\\nclass Solution {\\n    bool inCircle(const vector<int> &circ, int x, int y) {\\n        int dx = (x - circ[0]) * (x - circ[0]); \\n        int dy = (y - circ[1]) * (y - circ[1]);\\n        return dx + dy <= circ[2] * circ[2];\\n    }\\n    unordered_set<int> counted;\\n    inline int index(int x, int y) {\\n        return (x << 8) | y;\\n    }\\n    vector<pair<int,int>> getMinMax(const vector<int>& circ) {\\n        pair<int,int> p1{circ[0] - circ[2], circ[1] - circ[2]};\\n        pair<int,int> p2{circ[0] + circ[2], circ[1] + circ[2]};\\n        return {p1, p2};\\n    }\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans = 0;\\n        for(const auto &c : circles) {\\n            auto limits = getMinMax(c);\\n            for(int x = limits[0].first; x <= limits[1].first; ++x) {\\n                for(int y = limits[0].second; y <= limits[1].second; ++y) {\\n                    if(inCircle(c, x, y)) {\\n                        if(counted.count(index(x, y)))\\n                            continue;\\n                        counted.insert(index(x, y));\\n                        ++ans;\\n                    }\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool inCircle(const vector<int> &circ, int x, int y) {\\n        int dx = (x - circ[0]) * (x - circ[0]); \\n        int dy = (y - circ[1]) * (y - circ[1]);\\n        return dx + dy <= circ[2] * circ[2];\\n    }\\n    unordered_set<int> counted;\\n    inline int index(int x, int y) {\\n        return (x << 8) | y;\\n    }\\n    vector<pair<int,int>> getMinMax(const vector<int>& circ) {\\n        pair<int,int> p1{circ[0] - circ[2], circ[1] - circ[2]};\\n        pair<int,int> p2{circ[0] + circ[2], circ[1] + circ[2]};\\n        return {p1, p2};\\n    }\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans = 0;\\n        for(const auto &c : circles) {\\n            auto limits = getMinMax(c);\\n            for(int x = limits[0].first; x <= limits[1].first; ++x) {\\n                for(int y = limits[0].second; y <= limits[1].second; ++y) {\\n                    if(inCircle(c, x, y)) {\\n                        if(counted.count(index(x, y)))\\n                            continue;\\n                        counted.insert(index(x, y));\\n                        ++ans;\\n                    }\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886441,
                "title": "simple-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n       \\n        int n=circles.size();\\n\\n        int i=0;\\n        int cnt=0;\\n        \\n       map<pair<int,int>,bool> mp;\\n        for(i=0; i<n; i++)\\n        {\\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n\\n            int j,k;\\n\\n            for(j=x-r; j<=x+r; j++)\\n            {\\n                for(k=y-r; k<=y+r; k++)\\n                {\\n                   if(mp.find({j,k})==mp.end())\\n                   {\\n\\n                   \\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=r*r)\\n                        {\\n                              mp[{j,k}]=true;\\n                              cnt++;\\n                        }\\n                   }\\n                }\\n            }\\n        }\\n\\n\\n\\n         return cnt;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) \\n    {\\n       \\n        int n=circles.size();\\n\\n        int i=0;\\n        int cnt=0;\\n        \\n       map<pair<int,int>,bool> mp;\\n        for(i=0; i<n; i++)\\n        {\\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n\\n            int j,k;\\n\\n            for(j=x-r; j<=x+r; j++)\\n            {\\n                for(k=y-r; k<=y+r; k++)\\n                {\\n                   if(mp.find({j,k})==mp.end())\\n                   {\\n\\n                   \\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=r*r)\\n                        {\\n                              mp[{j,k}]=true;\\n                              cnt++;\\n                        }\\n                   }\\n                }\\n            }\\n        }\\n\\n\\n\\n         return cnt;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782418,
                "title": "c-solution",
                "content": "Here is my C++ solution. I don\\'t use any hash map, etc. The logic is built on geometry and I introduce a bool matrix to keep track of points I have already counted inside a circle inorder to avoid repetead countings.\\n\\nThe idea is simple - For each circle, using the center and radius, you get a 2d grid that one needs to iterate over. Use the classic distance from center to determine if inside the circle. \\n\\nNow comes the interesting part, you maintain a gird of points that capture all the circles. When a point is marked visited for any circle, you mark it in this boolean array.\\n\\nFollowing is the code - \\n\\nNote - A bit long but good to break down your code into helper functions for better readability! \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> circles;\\n    vector<vector<bool>> counted;\\n    int x_max, x_min, y_max, y_min;\\n        \\n    bool isInside(int x, int y, int x_c, int y_c, int r){\\n        r = r*r;\\n        int dist = (x-x_c)*(x-x_c) + (y-y_c)*(y-y_c);\\n        if(r >= dist)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isPointConsidered(int x, int y){\\n        int i = x - x_min;\\n        int j = y - y_min;\\n        return counted[i][j];\\n    }\\n    \\n    void markCounted(int x, int y){\\n        int i = x - x_min;\\n        int j = y - y_min;\\n        counted[i][j] = true;\\n        return;\\n    }\\n    \\n    void getPointsInsideCircle(vector<int>& c, vector<pair<int,int>>& points){\\n        int x_min = INT_MAX;\\n        int x_max = INT_MIN;\\n        int y_max = INT_MIN;\\n        int y_min = INT_MAX;\\n\\n        x_max = max(x_max, c[0] + c[2]);\\n        x_min = min(x_min, c[0] - c[2]);\\n        y_max = max(y_max, c[1] + c[2]);\\n        y_min = min(y_min, c[1] - c[2]);\\n\\n        for(int x = x_min ; x <= x_max ; x++){\\n            for(int y = y_min; y <= y_max ; y++){\\n                if(isPointConsidered(x,y))\\n                    continue;\\n                if(isInside(x, y, c[0], c[1], c[2])){\\n                    points.push_back({x,y});\\n                    markCounted(x,y);\\n                }\\n            }\\n        }\\n\\n        return;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& CIRCLES) {\\n        circles = CIRCLES;\\n        vector<pair<int,int>> points;\\n        \\n        x_min = INT_MAX;\\n        x_max = INT_MIN;\\n        y_max = INT_MIN;\\n        y_min = INT_MAX;\\n        \\n        for(auto c : circles){\\n            x_max = max(x_max, c[0] + c[2]);\\n            x_min = min(x_min, c[0] - c[2]);\\n            y_max = max(y_max, c[1] + c[2]);\\n            y_min = min(y_min, c[1] - c[2]);\\n        }\\n        \\n        counted = vector<vector<bool>> (x_max-x_min+1, vector<bool> (y_max-y_min+1, false));\\n        \\n        for(vector<int> circle : circles){\\n            getPointsInsideCircle(circle, points);\\n        }\\n        \\n        return points.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> circles;\\n    vector<vector<bool>> counted;\\n    int x_max, x_min, y_max, y_min;\\n        \\n    bool isInside(int x, int y, int x_c, int y_c, int r){\\n        r = r*r;\\n        int dist = (x-x_c)*(x-x_c) + (y-y_c)*(y-y_c);\\n        if(r >= dist)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isPointConsidered(int x, int y){\\n        int i = x - x_min;\\n        int j = y - y_min;\\n        return counted[i][j];\\n    }\\n    \\n    void markCounted(int x, int y){\\n        int i = x - x_min;\\n        int j = y - y_min;\\n        counted[i][j] = true;\\n        return;\\n    }\\n    \\n    void getPointsInsideCircle(vector<int>& c, vector<pair<int,int>>& points){\\n        int x_min = INT_MAX;\\n        int x_max = INT_MIN;\\n        int y_max = INT_MIN;\\n        int y_min = INT_MAX;\\n\\n        x_max = max(x_max, c[0] + c[2]);\\n        x_min = min(x_min, c[0] - c[2]);\\n        y_max = max(y_max, c[1] + c[2]);\\n        y_min = min(y_min, c[1] - c[2]);\\n\\n        for(int x = x_min ; x <= x_max ; x++){\\n            for(int y = y_min; y <= y_max ; y++){\\n                if(isPointConsidered(x,y))\\n                    continue;\\n                if(isInside(x, y, c[0], c[1], c[2])){\\n                    points.push_back({x,y});\\n                    markCounted(x,y);\\n                }\\n            }\\n        }\\n\\n        return;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& CIRCLES) {\\n        circles = CIRCLES;\\n        vector<pair<int,int>> points;\\n        \\n        x_min = INT_MAX;\\n        x_max = INT_MIN;\\n        y_max = INT_MIN;\\n        y_min = INT_MAX;\\n        \\n        for(auto c : circles){\\n            x_max = max(x_max, c[0] + c[2]);\\n            x_min = min(x_min, c[0] - c[2]);\\n            y_max = max(y_max, c[1] + c[2]);\\n            y_min = min(y_min, c[1] - c[2]);\\n        }\\n        \\n        counted = vector<vector<bool>> (x_max-x_min+1, vector<bool> (y_max-y_min+1, false));\\n        \\n        for(vector<int> circle : circles){\\n            getPointsInsideCircle(circle, points);\\n        }\\n        \\n        return points.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771921,
                "title": "python-save-time-by-removing-duplication",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        st = set()\\n        for x, y, r in list(map(list, set(map(tuple, circles)))):\\n            lst_x = range(x - r, x + r + 1)\\n            lst_y = range(y - r, y + r + 1)\\n            st |= set([(nx, ny) for nx in lst_x for ny in lst_y if\\n                       (nx - x) ** 2 + (ny - y) ** 2 <= r ** 2])\\n        return len(st)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        st = set()\\n        for x, y, r in list(map(list, set(map(tuple, circles)))):\\n            lst_x = range(x - r, x + r + 1)\\n            lst_y = range(y - r, y + r + 1)\\n            st |= set([(nx, ny) for nx in lst_x for ny in lst_y if\\n                       (nx - x) ** 2 + (ny - y) ** 2 <= r ** 2])\\n        return len(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726984,
                "title": "easy-python-code",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        cords = set()\\n        for circle in circles:\\n            x, y, r = circle[0], circle[1], circle[2]\\n            for valX in range(x-r, x+r+1):\\n                for valY in range(y-r, y+r+1):\\n                    if ((valX,valY) not in cords) and (pow(valX-x,2) + pow(valY-y, 2) <= pow(r, 2)):\\n                        cords.add((valX,valY))\\n        return len(cords)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        cords = set()\\n        for circle in circles:\\n            x, y, r = circle[0], circle[1], circle[2]\\n            for valX in range(x-r, x+r+1):\\n                for valY in range(y-r, y+r+1):\\n                    if ((valX,valY) not in cords) and (pow(valX-x,2) + pow(valY-y, 2) <= pow(r, 2)):\\n                        cords.add((valX,valY))\\n        return len(cords)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666555,
                "title": "interview-followup-optimize-for-the-case-when-there-are-many-large-circles",
                "content": "Most people are using the cubic method of explicitly enumerating all points in each circle. That\\'s \"cubic\" in the sense of O(number of circles * area of circle) (area is approximately quadratic in radius). This is a fine approach when the number of circles times their area is small compared to the size of the grid.\\n\\nWhen the grid is mostly occupied, another approach comes into play.\\n\\nInstead of lattice points, imagine vertical lattice \"segments\" connecting highest and lowest lattice point with the same X coordinate in a given circle. Record the length of each segment. After doing all circle, scan each column of the array and accumulate the segment lengths, taking care to not double-count overlapping segments.\\n\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        grid = [[0]*202 for i in range(202)]\\n        for x,y,r in circles:\\n            for j in range(-r,r+1):\\n                k = int(sqrt(r*r-j*j))\\n                grid[x+j][y-k] = max(grid[x+j][y-k], 2*k+1)\\n        ans = 0\\n        for i in range(202):\\n            n = 0\\n            for j in range(202):\\n                n = max(n, grid[i][j])\\n                ans += (n>0)\\n                n = max(0,n-1)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        grid = [[0]*202 for i in range(202)]\\n        for x,y,r in circles:\\n            for j in range(-r,r+1):\\n                k = int(sqrt(r*r-j*j))\\n                grid[x+j][y-k] = max(grid[x+j][y-k], 2*k+1)\\n        ans = 0\\n        for i in range(202):\\n            n = 0\\n            for j in range(202):\\n                n = max(n, grid[i][j])\\n                ans += (n>0)\\n                n = max(0,n-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643604,
                "title": "loop-on-the-circles-points",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n      const points = [];\\n      const usedCircles = [];\\n      circles.forEach(c => {\\n          const [xc,yc,rc] = c;\\n          if(usedCircles.includes(`(${xc},${yc},${rc})`)) return;\\n          usedCircles.push(`(${xc},${yc},${rc})`)\\n          for(let x=xc-rc;x<=xc+rc;x++){\\n             for(let y = yc-rc;y<=yc+rc;y++){\\n              const cdata = Math.pow((x-xc),2)+Math.pow((y-yc),2);\\n              const rp = Math.pow(rc,2);\\n              if(cdata <= rp) points.push(`(${x},${y})`)\\n            } \\n          }\\n      })\\n      return [...new Set(points)].length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} circles\\n * @return {number}\\n */\\nvar countLatticePoints = function(circles) {\\n      const points = [];\\n      const usedCircles = [];\\n      circles.forEach(c => {\\n          const [xc,yc,rc] = c;\\n          if(usedCircles.includes(`(${xc},${yc},${rc})`)) return;\\n          usedCircles.push(`(${xc},${yc},${rc})`)\\n          for(let x=xc-rc;x<=xc+rc;x++){\\n             for(let y = yc-rc;y<=yc+rc;y++){\\n              const cdata = Math.pow((x-xc),2)+Math.pow((y-yc),2);\\n              const rp = Math.pow(rc,2);\\n              if(cdata <= rp) points.push(`(${x},${y})`)\\n            } \\n          }\\n      })\\n      return [...new Set(points)].length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2632221,
                "title": "c-easy-to-understand-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        for(auto circle : circles)\\n        {\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            int count = 0;\\n            for(int i = x-r;i<=r+x;i++)\\n            {\\n                for(int j = y-r;j<=r+y;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        s.insert({i,j});\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        for(auto circle : circles)\\n        {\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n            int count = 0;\\n            for(int i = x-r;i<=r+x;i++)\\n            {\\n                for(int j = y-r;j<=r+y;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        s.insert({i,j});\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572032,
                "title": "python-geometry",
                "content": "```\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n      \\n        out = set()\\n        for i in range(len(circles)):\\n            i_center = circles[i][0]\\n            j_center = circles[i][1]\\n            radius = circles[i][2]\\n            for ii in range(i_center-radius, i_center+radius+1):\\n                for jj in range(j_center-radius, j_center+radius+1):\\n                    if (ii,jj) not in out:\\n                        if sqrt((ii-i_center)**2 + (jj-j_center)**2) <= radius:\\n                            out.add((ii, jj))\\n                        \\n\\n        return len(out)\\n",
                "solutionTags": [],
                "code": "```\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n      \\n        out = set()\\n        for i in range(len(circles)):\\n            i_center = circles[i][0]\\n            j_center = circles[i][1]\\n            radius = circles[i][2]\\n            for ii in range(i_center-radius, i_center+radius+1):\\n                for jj in range(j_center-radius, j_center+radius+1):\\n                    if (ii,jj) not in out:\\n                        if sqrt((ii-i_center)**2 + (jj-j_center)**2) <= radius:\\n                            out.add((ii, jj))\\n                        \\n\\n        return len(out)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2536396,
                "title": "c-93-ms",
                "content": "```\\nint countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        vector<vector<bool>> pp(201, vector<bool>(201, false));\\n        int ans = 0;\\n        \\n        for(auto &circle : circles)\\n        {\\n\\t\\t\\t// circle centers\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n\\n\\t\\t\\t// iterating through all integer points\\n            for(int i = x - r; i<= x+r; i++)\\n            {\\n\\t\\t\\t\\t// finding the range for y cordinates\\n                int l = r*r - (x - i)*(x - i);\\n                l = sqrt(l);\\n\\n                for(int j = y - l; j<= y+l; j++)\\n                {\\n                    if(!pp[i][j]) ans++;\\n                    pp[i][j] = true;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        vector<vector<bool>> pp(201, vector<bool>(201, false));\\n        int ans = 0;\\n        \\n        for(auto &circle : circles)\\n        {\\n\\t\\t\\t// circle centers\\n            int x = circle[0];\\n            int y = circle[1];\\n            int r = circle[2];\\n\\n\\t\\t\\t// iterating through all integer points\\n            for(int i = x - r; i<= x+r; i++)\\n            {\\n\\t\\t\\t\\t// finding the range for y cordinates\\n                int l = r*r - (x - i)*(x - i);\\n                l = sqrt(l);\\n\\n                for(int j = y - l; j<= y+l; j++)\\n                {\\n                    if(!pp[i][j]) ans++;\\n                    pp[i][j] = true;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2509383,
                "title": "faster-than-98-solution-non-brute-force",
                "content": "Actually you only need to record the change of value in the graph for each circle\\n\\n```\\n public int countLatticePoints(int[][] circles) {\\n        int graphSize=200;\\n        int[][]graph=new int[graphSize][graphSize];\\n        // add to difference\\n        for (int i [] :circles){\\n            // scan from top to down\\n            // y value\\n            for (int j=i[1]-i[2],delta;j<=i[1]+i[2];j++){\\n                // x value\\n                delta=(int) Math.sqrt(Math.pow(i[2], 2)-Math.pow(j-i[1], 2))+1;\\n                graph[j][i[0]-delta+1]+=1;\\n                graph[j][i[0]+delta]-=1;\\n            }\\n        }\\n        int latticeCount=0;\\n        //printArray(graph);\\n        // count value\\n        for(int i =0;i<graphSize;i++){\\n            for (int j=0,value=0;j<graphSize;j++){\\n                value+=graph[i][j];\\n                if(value>0){\\n                    latticeCount++;\\n                }\\n            }\\n        }\\n        return latticeCount;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int countLatticePoints(int[][] circles) {\\n        int graphSize=200;\\n        int[][]graph=new int[graphSize][graphSize];\\n        // add to difference\\n        for (int i [] :circles){\\n            // scan from top to down\\n            // y value\\n            for (int j=i[1]-i[2],delta;j<=i[1]+i[2];j++){\\n                // x value\\n                delta=(int) Math.sqrt(Math.pow(i[2], 2)-Math.pow(j-i[1], 2))+1;\\n                graph[j][i[0]-delta+1]+=1;\\n                graph[j][i[0]+delta]-=1;\\n            }\\n        }\\n        int latticeCount=0;\\n        //printArray(graph);\\n        // count value\\n        for(int i =0;i<graphSize;i++){\\n            for (int j=0,value=0;j<graphSize;j++){\\n                value+=graph[i][j];\\n                if(value>0){\\n                    latticeCount++;\\n                }\\n            }\\n        }\\n        return latticeCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2467854,
                "title": "c-solution-count-lattice-points-inside-a-circle",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n    int a,b,r;\\n        \\n    int x0, x1;\\n    int y0, y1;\\n    int value;\\n    vector<pair<int,int>> v;\\n    int r2;\\n    int matrix[305][305] = {0};\\n    int count = 0;\\n        \\n        \\n    for (int i = 0; i < circles.size(); i++)\\n    {\\n        a = circles[i][0];\\n        b = circles[i][1];\\n        r = circles[i][2];\\n          \\n        x0 = a - r;\\n        x1 = a + r;\\n        y0 = b - r;\\n        y1 = b + r;\\n        \\n        for (int j = x0; j <= x1; j++)   \\n            for (int k = y0; k <= y1; k++)\\n            {\\n                value = (j - a)*(j - a) + (k - b)*(k - b);\\n                r2 = r*r;\\n                if (value <= r*r)\\n                    matrix[j][k] = 1;\\n            }\\n        \\n    }\\n      \\n    for (int i = 0; i < 305; i++)\\n        for (int j = 0; j < 305; j++)\\n            if (matrix[i][j] == 1)\\n                count++;\\n\\n        \\n     return(count); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n    int a,b,r;\\n        \\n    int x0, x1;\\n    int y0, y1;\\n    int value;\\n    vector<pair<int,int>> v;\\n    int r2;\\n    int matrix[305][305] = {0};\\n    int count = 0;\\n        \\n        \\n    for (int i = 0; i < circles.size(); i++)\\n    {\\n        a = circles[i][0];\\n        b = circles[i][1];\\n        r = circles[i][2];\\n          \\n        x0 = a - r;\\n        x1 = a + r;\\n        y0 = b - r;\\n        y1 = b + r;\\n        \\n        for (int j = x0; j <= x1; j++)   \\n            for (int k = y0; k <= y1; k++)\\n            {\\n                value = (j - a)*(j - a) + (k - b)*(k - b);\\n                r2 = r*r;\\n                if (value <= r*r)\\n                    matrix[j][k] = 1;\\n            }\\n        \\n    }\\n      \\n    for (int i = 0; i < 305; i++)\\n        for (int j = 0; j < 305; j++)\\n            if (matrix[i][j] == 1)\\n                count++;\\n\\n        \\n     return(count); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441165,
                "title": "python3-using-set-and-dictionary",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        #remove the duplicated circles:\\n        circles = list(set(tuple(i) for i in circles))\\n        \\n        points={}\\n        for circle in circles:\\n            xc, yc, r = circle[0], circle[1], circle[2]\\n            for x in range(xc-r, xc+r+1):\\n                for y in range(yc-r, yc+r+1):\\n                    if((xc-x)**2+(yc-y)**2)<=r**2:\\n                        if (x,y) not in points.keys():\\n                            points[(x,y)]=1\\n        return len(points)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        #remove the duplicated circles:\\n        circles = list(set(tuple(i) for i in circles))\\n        \\n        points={}\\n        for circle in circles:\\n            xc, yc, r = circle[0], circle[1], circle[2]\\n            for x in range(xc-r, xc+r+1):\\n                for y in range(yc-r, yc+r+1):\\n                    if((xc-x)**2+(yc-y)**2)<=r**2:\\n                        if (x,y) not in points.keys():\\n                            points[(x,y)]=1\\n        return len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435347,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n = circles.size();\\n        set<pair<int,int> > st;\\n        for(int i=0;i<n;i++){\\n            int xi = circles[i][0];\\n            int yi = circles[i][1];\\n            int ri = circles[i][2];\\n            \\n            for(int x = (- ri) ; x <= ( ri) ; x++){\\n                for(int y = ( -ri) ; y <= (ri) ; y++){\\n                    if( (x) * (x) + (y) * (y) <= ri*ri){\\n                        st.insert({xi+x,yi+y});\\n                    }\\n                }\\n            }\\n\\n        }\\n        int size = st.size();\\n        return size;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n = circles.size();\\n        set<pair<int,int> > st;\\n        for(int i=0;i<n;i++){\\n            int xi = circles[i][0];\\n            int yi = circles[i][1];\\n            int ri = circles[i][2];\\n            \\n            for(int x = (- ri) ; x <= ( ri) ; x++){\\n                for(int y = ( -ri) ; y <= (ri) ; y++){\\n                    if( (x) * (x) + (y) * (y) <= ri*ri){\\n                        st.insert({xi+x,yi+y});\\n                    }\\n                }\\n            }\\n\\n        }\\n        int size = st.size();\\n        return size;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377921,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        int n=circles.size();\\n        for(int k=0;k<n;k++){\\n            int x=circles[k][0];\\n            int y=circles[k][1];\\n            int r=circles[k][2];\\n            \\n            for(int i=x-r;i<=x+r;i++){\\n                for(int j=y-r;j<=y+r;j++){\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r){\\n                        s.insert({i,j});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>>s;\\n        int n=circles.size();\\n        for(int k=0;k<n;k++){\\n            int x=circles[k][0];\\n            int y=circles[k][1];\\n            int r=circles[k][2];\\n            \\n            for(int i=x-r;i<=x+r;i++){\\n                for(int j=y-r;j<=y+r;j++){\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r){\\n                        s.insert({i,j});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342739,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn count_lattice_points(c: Vec<Vec<i32>>) -> i32 {\\n        let mut m=[0;40401];\\n        for v in c.into_iter() {\\n            let (x,y,r) = (v[0],v[1],v[2]);\\n            for i in x-r..x+r+1 {\\n                let d=((r*r-(x-i)*(x-i)) as f64).sqrt() as i32; \\n                for j in i*201+y-d..i*201+y+d+1 {m[j as usize]=1;}\\n            }    \\n        }\\n        m.iter().sum::<i32>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_lattice_points(c: Vec<Vec<i32>>) -> i32 {\\n        let mut m=[0;40401];\\n        for v in c.into_iter() {\\n            let (x,y,r) = (v[0],v[1],v[2]);\\n            for i in x-r..x+r+1 {\\n                let d=((r*r-(x-i)*(x-i)) as f64).sqrt() as i32; \\n                for j in i*201+y-d..i*201+y+d+1 {m[j as usize]=1;}\\n            }    \\n        }\\n        m.iter().sum::<i32>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2283104,
                "title": "brute-force-question-but-optimized-greatly-using-binary-search",
                "content": "```\\n    int count(int rad,int i){\\n        int l=0,r=rad,res=0;\\n        rad*=rad;\\n        \\n        while(l<=r){\\n            int m=(l+r)/2;\\n            int v=i*i+m*m;\\n            \\n            if(v>rad)\\n                r=m-1;\\n            else{\\n                res=m;\\n                l=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        vector<vector<bool>> dp(201,vector<bool>(201,false));\\n        \\n        for(auto v:circles){\\n            int a=v[0],b=v[1],r=v[2];\\n            \\n            dp[a][b]=true;\\n            //traversing all line segments first\\n            for(int i=1;i<=r;i++){\\n                dp[a][b+i]=dp[a][b-i]=true;\\n                dp[a-i][b]=dp[a+i][b]=true;\\n            }\\n            \\n            for(int j=1;j<r;j++){\\n                int cnt=count(r,j);\\n                for(int i=1;i<=cnt;i++){\\n                    dp[a+i][b+j]=dp[a+i][b-j]=true;\\n                    dp[a-i][b+j]=dp[a-i][b-j]=true;\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<201;i++){\\n            for(int j=0;j<201;j++)\\n                if(dp[i][j])\\n                    res++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int count(int rad,int i){\\n        int l=0,r=rad,res=0;\\n        rad*=rad;\\n        \\n        while(l<=r){\\n            int m=(l+r)/2;\\n            int v=i*i+m*m;\\n            \\n            if(v>rad)\\n                r=m-1;\\n            else{\\n                res=m;\\n                l=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        vector<vector<bool>> dp(201,vector<bool>(201,false));\\n        \\n        for(auto v:circles){\\n            int a=v[0],b=v[1],r=v[2];\\n            \\n            dp[a][b]=true;\\n            //traversing all line segments first\\n            for(int i=1;i<=r;i++){\\n                dp[a][b+i]=dp[a][b-i]=true;\\n                dp[a-i][b]=dp[a+i][b]=true;\\n            }\\n            \\n            for(int j=1;j<r;j++){\\n                int cnt=count(r,j);\\n                for(int i=1;i<=cnt;i++){\\n                    dp[a+i][b+j]=dp[a+i][b-j]=true;\\n                    dp[a-i][b+j]=dp[a-i][b-j]=true;\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<201;i++){\\n            for(int j=0;j<201;j++)\\n                if(dp[i][j])\\n                    res++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282355,
                "title": "easy-c-optimum-solution-beats-85-in-o-1-space",
                "content": "First we need to find what can be possible values of x and y basically range then just simpily check that it is in the range or not by circle equation\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans=0;\\n        int min_x=200;\\n        int max_x=0;\\n        int min_y=200;\\n        int max_y=0;\\n        for(int k=0;k<circles.size();k++){\\n            min_x=min(min_x,circles[k][0]-circles[k][2]);\\n            max_x=max(max_x,circles[k][0]+circles[k][2]);\\n            min_y=min(min_y,circles[k][1]-circles[k][2]);\\n            max_y=max(max_y,circles[k][1]+circles[k][2]);\\n        }\\n        for(int i=min_x;i<=max_x;i++){\\n            for(int j=min_y;j<=max_y;j++){\\n                bool flag=false;\\n                for(int k=0;k<circles.size();k++){\\n                    int l1=(circles[k][0]-i)*(circles[k][0]-i) +(circles[k][1]-j)*(circles[k][1]-j);\\n                    if(l1<=((circles[k][2])*(circles[k][2]))){\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int ans=0;\\n        int min_x=200;\\n        int max_x=0;\\n        int min_y=200;\\n        int max_y=0;\\n        for(int k=0;k<circles.size();k++){\\n            min_x=min(min_x,circles[k][0]-circles[k][2]);\\n            max_x=max(max_x,circles[k][0]+circles[k][2]);\\n            min_y=min(min_y,circles[k][1]-circles[k][2]);\\n            max_y=max(max_y,circles[k][1]+circles[k][2]);\\n        }\\n        for(int i=min_x;i<=max_x;i++){\\n            for(int j=min_y;j<=max_y;j++){\\n                bool flag=false;\\n                for(int k=0;k<circles.size();k++){\\n                    int l1=(circles[k][0]-i)*(circles[k][0]-i) +(circles[k][1]-j)*(circles[k][1]-j);\\n                    if(l1<=((circles[k][2])*(circles[k][2]))){\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(flag){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271592,
                "title": "intuitive-geo",
                "content": "```\\nclass Solution {\\n    \\n    set<pair<int, int>> points_;\\n    \\n    bool in_circle(int x, int y, int cx, int cy, int r) {\\n        return pow(x - cx, 2) + pow(y - cy, 2) <= pow(r, 2);\\n    }\\n    \\n    void add_points(const vector<int>& c) {\\n        auto x = c[0];\\n        auto y = c[1];\\n        auto r = c[2];\\n        \\n        for (int i = x - r; i <= x + r; ++i) {\\n            for (int j = y - r; j <= y + r; ++j) {\\n                if (in_circle(i, j, x, y, r))\\n                    points_.insert({i, j});\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        for (auto c : circles) {\\n            add_points(c);\\n        }\\n        \\n        return points_.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    set<pair<int, int>> points_;\\n    \\n    bool in_circle(int x, int y, int cx, int cy, int r) {\\n        return pow(x - cx, 2) + pow(y - cy, 2) <= pow(r, 2);\\n    }\\n    \\n    void add_points(const vector<int>& c) {\\n        auto x = c[0];\\n        auto y = c[1];\\n        auto r = c[2];\\n        \\n        for (int i = x - r; i <= x + r; ++i) {\\n            for (int j = y - r; j <= y + r; ++j) {\\n                if (in_circle(i, j, x, y, r))\\n                    points_.insert({i, j});\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        for (auto c : circles) {\\n            add_points(c);\\n        }\\n        \\n        return points_.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266951,
                "title": "python3",
                "content": "target_sum={}\\n        for i in numbers:\\n            target_sum[i]=target-i\\n        for i in range(len(numbers)):\\n            try:\\n                j=numbers.index(target_sum[numbers[i]],i+1)\\n                return [i+1,j+1]\\n            except:\\n                pass",
                "solutionTags": [],
                "code": "target_sum={}\\n        for i in numbers:\\n            target_sum[i]=target-i\\n        for i in range(len(numbers)):\\n            try:\\n                j=numbers.index(target_sum[numbers[i]],i+1)\\n                return [i+1,j+1]\\n            except:\\n                pass",
                "codeTag": "Unknown"
            },
            {
                "id": 2250196,
                "title": "simple-math",
                "content": "* Max (x,y) =100, hence max diameter of any circle is 200, and hence max grid size will 200*200.\\n* choose any point in the grid and check wether it lies in any circle or not. if found in any circle just break there, no need to find the same point in another circle.\\n* code for the same is given below\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n=circles.size();\\n        int ans=0;\\n        for(int i=0;i<=200;i++){\\n            for(int j=0;j<=200;j++){\\n                for(int k=0;k<n;k++){\\n                    int a=circles[k][0],b=circles[k][1],r=circles[k][2];\\n                    if((i-a)*(i-a)+(j-b)*(j-b)<=r*r){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int n=circles.size();\\n        int ans=0;\\n        for(int i=0;i<=200;i++){\\n            for(int j=0;j<=200;j++){\\n                for(int k=0;k<n;k++){\\n                    int a=circles[k][0],b=circles[k][1],r=circles[k][2];\\n                    if((i-a)*(i-a)+(j-b)*(j-b)<=r*r){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246173,
                "title": "python-o-m-n",
                "content": "```python\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n        res= 0 \\n        for i in range(0, 201):\\n            a = [0] * 203\\n            for x,y,r in circles:\\n                k = r ** 2 - (i-x) ** 2\\n                if k >= 0:\\n                    r = int(k ** .5) + y \\n                    l = max(0, math.ceil(-int(k ** .5) + y))\\n                    a[l] += 1\\n                    a[r+1] -=1 \\n            for i in range(0, 201):\\n                a[i] += a[i-1]\\n                res += a[i] > 0 \\n        return res \\n\\t\\t```",
                "solutionTags": [],
                "code": "```python\\ndef countLatticePoints(self, circles: List[List[int]]) -> int:\\n        res= 0 \\n        for i in range(0, 201):\\n            a = [0] * 203\\n            for x,y,r in circles:\\n                k = r ** 2 - (i-x) ** 2\\n                if k >= 0:\\n                    r = int(k ** .5) + y \\n                    l = max(0, math.ceil(-int(k ** .5) + y))\\n                    a[l] += 1\\n                    a[r+1] -=1 \\n            for i in range(0, 201):\\n                a[i] += a[i-1]\\n                res += a[i] > 0 \\n        return res \\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2236378,
                "title": "python-speedy-but-greedy-solution",
                "content": "import itertools\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        result=set()\\n        circles1=set()\\n        for i in circles:\\n            circles1.add((i[0],i[1],i[2]))\\n        for circle in circles1:\\n            for i in range(circle[0]-circle[2],circle[0]+circle[2]+1):\\n                for j in range(circle[1]-circle[2],circle[1]+circle[2]+1):\\n                    if ((circle[0]-i)**2+(circle[1]-j)**2) <=circle[2]**2: result.add((i,j))\\n        print(result)\\n        return len(result)",
                "solutionTags": [],
                "code": "import itertools\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        result=set()\\n        circles1=set()\\n        for i in circles:\\n            circles1.add((i[0],i[1],i[2]))\\n        for circle in circles1:\\n            for i in range(circle[0]-circle[2],circle[0]+circle[2]+1):\\n                for j in range(circle[1]-circle[2],circle[1]+circle[2]+1):\\n                    if ((circle[0]-i)**2+(circle[1]-j)**2) <=circle[2]**2: result.add((i,j))\\n        print(result)\\n        return len(result)",
                "codeTag": "Java"
            },
            {
                "id": 2178731,
                "title": "easy-brute-force-with-small-changes",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> m;\\n    int countLatticePoints(vector<vector<int>>& c) {\\n        for(int k=0;k<c.size();k++){\\n        int x=c[k][0];\\n        int y=c[k][1];\\n        int r=c[k][2];\\n        for(int i=0;i<=r;i++){\\n            for(int j=0;j<=r;j++){\\n                if(i*i+j*j>r*r) break;\\n\\t\\t\\t\\t#check for one quarter of circle and we can store mirror image of that point in four quarters of that circle\\n                m[{x-i,y-j}]++;\\n                m[{x-i,y+j}]++;\\n                m[{x+i,y-j}]++;\\n                m[{x+i,y+j}]++;\\n            }\\n        }\\n    }\\n    int ans=0;\\n        for(auto i:m) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> m;\\n    int countLatticePoints(vector<vector<int>>& c) {\\n        for(int k=0;k<c.size();k++){\\n        int x=c[k][0];\\n        int y=c[k][1];\\n        int r=c[k][2];\\n        for(int i=0;i<=r;i++){\\n            for(int j=0;j<=r;j++){\\n                if(i*i+j*j>r*r) break;\\n\\t\\t\\t\\t#check for one quarter of circle and we can store mirror image of that point in four quarters of that circle\\n                m[{x-i,y-j}]++;\\n                m[{x-i,y+j}]++;\\n                m[{x+i,y-j}]++;\\n                m[{x+i,y+j}]++;\\n            }\\n        }\\n    }\\n    int ans=0;\\n        for(auto i:m) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124590,
                "title": "javascript-solution-brute-force-euclidean-distance",
                "content": "```\\nvar countLatticePoints = function(circles) {\\n    const set = new Set();\\n    \\n    for (const [x, y, radius] of circles) {\\n        const startX = x - radius;\\n        const startY = y - radius;\\n        \\n        const endX = x + radius;\\n        const endY = y + radius;\\n        \\n        for (let currX = startX; currX <= endX; ++currX) {\\n            for (let currY = startY; currY <= endY; ++currY) {\\n                const dist = getEuclideanDist(currX, currY, x, y);\\n                \\n                if (dist <= radius) set.add(`${currX}#${currY}`);\\n            }\\n        }\\n    }\\n    \\n    return set.size;\\n    \\n    \\n    function getEuclideanDist(x1, y1, x2, y2) {\\n        return Math.sqrt((x1 - x2)**2 + (y1 - y2)**2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countLatticePoints = function(circles) {\\n    const set = new Set();\\n    \\n    for (const [x, y, radius] of circles) {\\n        const startX = x - radius;\\n        const startY = y - radius;\\n        \\n        const endX = x + radius;\\n        const endY = y + radius;\\n        \\n        for (let currX = startX; currX <= endX; ++currX) {\\n            for (let currY = startY; currY <= endY; ++currY) {\\n                const dist = getEuclideanDist(currX, currY, x, y);\\n                \\n                if (dist <= radius) set.add(`${currX}#${currY}`);\\n            }\\n        }\\n    }\\n    \\n    return set.size;\\n    \\n    \\n    function getEuclideanDist(x1, y1, x2, y2) {\\n        return Math.sqrt((x1 - x2)**2 + (y1 - y2)**2);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103370,
                "title": "doubt",
                "content": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& c) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                for(int k=0;k<c.size();k++)\\n                {\\n                    int dis1=(i-c[k][0])*(i-c[k][0])+(j-c[k][1])*(j-c[k][1]);\\n                    if(dis1<=c[k][2]*c[k][2])\\n                    {\\n                        ++cnt;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& c) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<=200;i++)\\n        {\\n            for(int j=0;j<=200;j++)\\n            {\\n                for(int k=0;k<c.size();k++)\\n                {\\n                    int dis1=(i-c[k][0])*(i-c[k][0])+(j-c[k][1])*(j-c[k][1]);\\n                    if(dis1<=c[k][2]*c[k][2])\\n                    {\\n                        ++cnt;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2056064,
                "title": "python-set",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        for c in set([tuple(c) for c in circles]):\\n            for x in range(c[0]-c[2],c[0]+c[2]+1):\\n                for y in range(c[1]-c[2],c[1]+c[2]+1):\\n                     if (x-c[0])**2+(y-c[1])**2<=c[2]**2:\\n                            s.add((x,y))\\n        return len(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        for c in set([tuple(c) for c in circles]):\\n            for x in range(c[0]-c[2],c[0]+c[2]+1):\\n                for y in range(c[1]-c[2],c[1]+c[2]+1):\\n                     if (x-c[0])**2+(y-c[1])**2<=c[2]**2:\\n                            s.add((x,y))\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036917,
                "title": "easy-solution-based-on-circle-equations",
                "content": "```\\nclass Solution {\\n    static int pow (int a){\\n        return a*a;\\n    }\\n    public int countLatticePoints(int[][] circles) {\\n        int count=0;\\n        for(int i=0;i<=200;i++){\\n            for(int j=0;j<=200;j++){\\n                boolean b=false;\\n                for(int k=0;k<circles.length;k++){\\n                    if(pow(i-circles[k][0])+pow(j-circles[k][1])-pow(circles[k][2])<=0){\\n                        b=true;\\n                        break;\\n                    }\\n                }\\n                if(b)count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    static int pow (int a){\\n        return a*a;\\n    }\\n    public int countLatticePoints(int[][] circles) {\\n        int count=0;\\n        for(int i=0;i<=200;i++){\\n            for(int j=0;j<=200;j++){\\n                boolean b=false;\\n                for(int k=0;k<circles.length;k++){\\n                    if(pow(i-circles[k][0])+pow(j-circles[k][1])-pow(circles[k][2])<=0){\\n                        b=true;\\n                        break;\\n                    }\\n                }\\n                if(b)count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026539,
                "title": "c-beat-87",
                "content": "By the way, this problem is really meaningless...\\n```\\n#include <algorithm>  \\n#include <iostream>  \\n#include <cstring>\\n#include <string>  \\n#include <vector>  \\n#include <stack>  \\n#include <set>  \\n#include <list>  \\n#include <deque>  \\n#include <map>  \\n#include <queue> \\n#include <unordered_map>  \\n#include <unordered_set> \\n#define inf 0x3f3f3f3f\\n#define ff first\\n#define ss second\\n#define ll long long\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n\\tint A[201][201];\\n\\tinline bool in_circle(int& x, int& y, int& x_o, int& y_o, int& r_sq) {\\n\\t\\treturn (x - x_o) * (x - x_o) + (y - y_o) * (y - y_o) <= r_sq;\\n\\t}\\n    int countLatticePoints(vector<vector<int> >& circles) {\\n        memset(A, 0, sizeof(A));\\n\\t\\tfor (int i = 0; i < circles.size(); i++) {\\n\\t\\t\\tint r_sq = circles[i][2] * circles[i][2];\\n\\t\\t\\tfor (int x = circles[i][0] - circles[i][2]; x <= circles[i][0] + circles[i][2]; x++) {\\n\\t\\t\\t\\tfor (int y = circles[i][1] - circles[i][2]; y <= circles[i][1] + circles[i][2]; y++) {\\n\\t\\t\\t\\t\\tif (in_circle(x, y, circles[i][0], circles[i][1], r_sq)) {\\n\\t\\t\\t\\t\\t\\tA[x][y] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < 201; i++) {\\n\\t\\t\\tfor (int j = 0; j < 201; j++) {\\n\\t\\t\\t\\tres += A[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <algorithm>  \\n#include <iostream>  \\n#include <cstring>\\n#include <string>  \\n#include <vector>  \\n#include <stack>  \\n#include <set>  \\n#include <list>  \\n#include <deque>  \\n#include <map>  \\n#include <queue> \\n#include <unordered_map>  \\n#include <unordered_set> \\n#define inf 0x3f3f3f3f\\n#define ff first\\n#define ss second\\n#define ll long long\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n\\tint A[201][201];\\n\\tinline bool in_circle(int& x, int& y, int& x_o, int& y_o, int& r_sq) {\\n\\t\\treturn (x - x_o) * (x - x_o) + (y - y_o) * (y - y_o) <= r_sq;\\n\\t}\\n    int countLatticePoints(vector<vector<int> >& circles) {\\n        memset(A, 0, sizeof(A));\\n\\t\\tfor (int i = 0; i < circles.size(); i++) {\\n\\t\\t\\tint r_sq = circles[i][2] * circles[i][2];\\n\\t\\t\\tfor (int x = circles[i][0] - circles[i][2]; x <= circles[i][0] + circles[i][2]; x++) {\\n\\t\\t\\t\\tfor (int y = circles[i][1] - circles[i][2]; y <= circles[i][1] + circles[i][2]; y++) {\\n\\t\\t\\t\\t\\tif (in_circle(x, y, circles[i][0], circles[i][1], r_sq)) {\\n\\t\\t\\t\\t\\t\\tA[x][y] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < 201; i++) {\\n\\t\\t\\tfor (int j = 0; j < 201; j++) {\\n\\t\\t\\t\\tres += A[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2017611,
                "title": "python-use-set-clear-beat-86",
                "content": "class Solution:\\n\\n    def countLatticePoints(self, circles) -> int:\\n        points=set()\\n        for circle in circles:\\n            for x in range(circle[2]+1):\\n                for y in range(circle[2],-1,-1):\\n                    if x ** 2 + y ** 2 <= circle[2] ** 2:\\n                        # for i in range(x+1):\\n                        for j in range(y+1):\\n                            points.add((circle[0]+x, circle[1]+j))\\n                            points.add((circle[0]-x, circle[1]+j))\\n                            points.add((circle[0]+x, circle[1]-j))\\n                            points.add((circle[0]-x, circle[1]-j))\\n                        break\\n        return(len(points))",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def countLatticePoints(self, circles) -> int:\\n        points=set()\\n        for circle in circles:\\n            for x in range(circle[2]+1):\\n                for y in range(circle[2],-1,-1):\\n                    if x ** 2 + y ** 2 <= circle[2] ** 2:\\n                        # for i in range(x+1):\\n                        for j in range(y+1):\\n                            points.add((circle[0]+x, circle[1]+j))\\n                            points.add((circle[0]-x, circle[1]+j))\\n                            points.add((circle[0]+x, circle[1]-j))\\n                            points.add((circle[0]-x, circle[1]-j))\\n                        break\\n        return(len(points))",
                "codeTag": "Java"
            },
            {
                "id": 2011108,
                "title": "easy-to-understand",
                "content": "Hope this will be useful to you. Explanation is in the code. Have a great rest of the day/night ahead.\\n    \\n\\tdef countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        pt={} #to keep track of the points; we can also use set \\n        check=[] # a list to work with all unique circle datas\\n        ret = 0 # returns the count \\n        for circle in circles: # we go through every points\\n            if circle not in check: # checking that if we have never faced the data before\\n                check.append(circle) # adding the data as we checked the point now\\n                x,y,r = circle[0],circle[1],circle[2] \\n                for i in range(x-r,x+r+1):\\n                    for j in range(y-r,y+r+1):\\n                        if ((x-i)**2+(y-j)**2)<=r*r: # using circle formula to check a point is inside of a given circle\\n\\t\\t\\t\\t\\t\\t# formula: A point (h,k) is on or inside of a circle if (x-h)^2+(y-k)^2 <= r^2\\n                            key  = \\'(\\' + str(i) + \\'+\\' + str(j) + \\')\\' # we add the point in our hashtable as key \\'(i+j)\\' and increment the countvalue i.e. ret\\n                            if key not in pt:\\n                                pt[key] = 1\\n                                ret += 1\\n                            else: pt[key] += 1\\n                \\n        #print(pt)\\n        return ret",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "Hope this will be useful to you. Explanation is in the code. Have a great rest of the day/night ahead.\\n    \\n\\tdef countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        pt={} #to keep track of the points; we can also use set \\n        check=[] # a list to work with all unique circle datas\\n        ret = 0 # returns the count \\n        for circle in circles: # we go through every points\\n            if circle not in check: # checking that if we have never faced the data before\\n                check.append(circle) # adding the data as we checked the point now\\n                x,y,r = circle[0],circle[1],circle[2] \\n                for i in range(x-r,x+r+1):\\n                    for j in range(y-r,y+r+1):\\n                        if ((x-i)**2+(y-j)**2)<=r*r: # using circle formula to check a point is inside of a given circle\\n\\t\\t\\t\\t\\t\\t# formula: A point (h,k) is on or inside of a circle if (x-h)^2+(y-k)^2 <= r^2\\n                            key  = \\'(\\' + str(i) + \\'+\\' + str(j) + \\')\\' # we add the point in our hashtable as key \\'(i+j)\\' and increment the countvalue i.e. ret\\n                            if key not in pt:\\n                                pt[key] = 1\\n                                ret += 1\\n                            else: pt[key] += 1\\n                \\n        #print(pt)\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 2005965,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    \\n    boolean isInside(int circle[] ,int x ,int y){\\n        return (x - circle[0])*(x - circle[0]) + (y-circle[1])*(y-circle[1]) -circle[2]*circle[2]<=0; \\n    }\\n    \\n    public int countLatticePoints(int[][] circles) {\\n        int ans = 0;\\n        HashSet<String> set = new HashSet<>() ; \\n        for(int i=0;i<circles.length;i++){\\n            int x = circles [i][0];\\n            int y = circles [i][1];\\n            int r = circles [i][2];\\n            \\n            for(int j = x-r;j<=x+r;j++){\\n                for(int k = y-r;k<=y+r;k++){\\n                    if(isInside(circles[i],j,k))\\n                    {\\n                        if(!set.contains(j+\" \"+k)){\\n                            ans++;\\n                            set.add(j+\" \"+k);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    boolean isInside(int circle[] ,int x ,int y){\\n        return (x - circle[0])*(x - circle[0]) + (y-circle[1])*(y-circle[1]) -circle[2]*circle[2]<=0; \\n    }\\n    \\n    public int countLatticePoints(int[][] circles) {\\n        int ans = 0;\\n        HashSet<String> set = new HashSet<>() ; \\n        for(int i=0;i<circles.length;i++){\\n            int x = circles [i][0];\\n            int y = circles [i][1];\\n            int r = circles [i][2];\\n            \\n            for(int j = x-r;j<=x+r;j++){\\n                for(int k = y-r;k<=y+r;k++){\\n                    if(isInside(circles[i],j,k))\\n                    {\\n                        if(!set.contains(j+\" \"+k)){\\n                            ans++;\\n                            set.add(j+\" \"+k);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005646,
                "title": "python-straightforward-beats-95-runtime",
                "content": "Hmm, I guess a little bit overthinking did bring the speed up. So I was worried that I have lots of circles that centre at the same point, then I decided to remove them first. Hence, we have this algorithm that is fairly fast.\\n\\nSo first, we group keep only one circle if multiple is centred at the same point. We keep the largest one of course. Then we just go through each circle, and go through each possible point, and add them to a set.\\n\\n```python\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        found = set()\\n        distance = lambda x, y, cx, cy: (x - cx)**2 + (y - cy)**2\\n        centre_to_radius = {}\\n        for x, y, radius in circles:\\n            centre_to_radius[x, y] = max(centre_to_radius.get((x, y), -1), radius)\\n        for (centre_x, centre_y), radius in centre_to_radius.items():\\n            for x in range(centre_x - radius, centre_x + radius + 1):\\n                for y in range(centre_y - radius, centre_y + radius + 1):\\n                    if (x, y) not in found\\\\\\n                    and distance(x, y, centre_x, centre_y) <= radius * radius:\\n                        found.add((x, y))\\n        return len(found)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        found = set()\\n        distance = lambda x, y, cx, cy: (x - cx)**2 + (y - cy)**2\\n        centre_to_radius = {}\\n        for x, y, radius in circles:\\n            centre_to_radius[x, y] = max(centre_to_radius.get((x, y), -1), radius)\\n        for (centre_x, centre_y), radius in centre_to_radius.items():\\n            for x in range(centre_x - radius, centre_x + radius + 1):\\n                for y in range(centre_y - radius, centre_y + radius + 1):\\n                    if (x, y) not in found\\\\\\n                    and distance(x, y, centre_x, centre_y) <= radius * radius:\\n                        found.add((x, y))\\n        return len(found)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001645,
                "title": "c-solution-100-faster-simple-with-explaining",
                "content": "Three main points:\\n1. For circle [x, y, r], narrow down the possible circled points X: [x-r, x+r] AND Y:[y-r, y+r];\\n2. Judge a point [x+i, x+j] is circled by circle [x, y, r], simply check if (r^2 >= i^2 + j^2);\\n3. Use points[][] to avoid duplicated account.\\n\\n```\\nint countLatticePoints (int** circles, int circlesSize, int* circlesColSize) {\\n    int  i, j, k, x, y, r, count = 0;\\n    char points[201][201] = {{0}};\\n    \\n    for (k = 0; k < circlesSize; k++) {\\n        x = circles[k][0];\\n        y = circles[k][1];\\n        r = circles[k][2];\\n        \\n        for (i = -r; i <= r; i++) {\\n            for (j = -r; j <= r; j++) {\\n                if (points[x+i][y+j] == 0 && r*r >= i*i + j*j) {\\n                    points[x+i][y+j] = 1;\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countLatticePoints (int** circles, int circlesSize, int* circlesColSize) {\\n    int  i, j, k, x, y, r, count = 0;\\n    char points[201][201] = {{0}};\\n    \\n    for (k = 0; k < circlesSize; k++) {\\n        x = circles[k][0];\\n        y = circles[k][1];\\n        r = circles[k][2];\\n        \\n        for (i = -r; i <= r; i++) {\\n            for (j = -r; j <= r; j++) {\\n                if (points[x+i][y+j] == 0 && r*r >= i*i + j*j) {\\n                    points[x+i][y+j] = 1;\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997004,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& c) {\\n        \\n        set<pair<int,int>> st;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            int x=c[i][0];\\n            int y=c[i][1];\\n            int r=c[i][2];\\n            for(int i=x-r;i<=x+r;i++)\\n            {\\n                for(int j=y-r;j<=y+r;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        st.insert({i,j});\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& c) {\\n        \\n        set<pair<int,int>> st;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            int x=c[i][0];\\n            int y=c[i][1];\\n            int r=c[i][2];\\n            for(int i=x-r;i<=x+r;i++)\\n            {\\n                for(int j=y-r;j<=y+r;j++)\\n                {\\n                    if((i-x)*(i-x)+(j-y)*(j-y)<=r*r)\\n                        st.insert({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 1993604,
                "title": "javascript-sort-and-interval-merging-time-o-radius-circles-y-circles-log-circles",
                "content": "```\\nRuntime: 82 ms, faster than 100.00% of JavaScript online submissions for Count Lattice Points Inside a Circle.\\nMemory Usage: 48.8 MB, less than 75.90% of JavaScript online submissions for Count Lattice Points Inside a Circle.\\n\\nvar countLatticePoints = function(circles) {\\n    const coordinateRange = Array.from({ length: 201 }, () => []);\\n\\n    const isInsideCircle = (j, x, i, y, r) => (j - x) ** 2 + (i - y) ** 2 <= r * r;\\n\\n\\t/*   Time O(radius * circles)   */\\n    for (const [x, y, r] of circles) {\\n        for (let i = y + r, j = x; i >= y; i--) {\\n            for (; isInsideCircle(j, x, i, y, r); j++);\\n\\n            coordinateRange[i].push([2 * x - (j - 1), j - 1]);\\n            coordinateRange[2 * y - i].push([2 * x - (j - 1), j - 1]);\\n        }\\n    }\\n\\n\\t/*   Time O(Y * circles * log(circles))  */\\n    coordinateRange.forEach((ranges) =>\\n        ranges.sort(([start2, end2], [start1, end1]) =>\\n            start2 === start1 ? end2 - end1 : start2 - start1\\n        )\\n    );\\n\\n\\tlet ans = 0;\\n\\n    for (const ranges of coordinateRange) {\\n        let start = 0, end = -1;\\n\\n        for (const range of ranges) {\\n            if (range[0] > end) {\\n                ans += end - start + 1;\\n                start = range[0];\\n            }\\n            end = Math.max(end, range[1]);\\n        }\\n        ans += end - start + 1;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nRuntime: 82 ms, faster than 100.00% of JavaScript online submissions for Count Lattice Points Inside a Circle.\\nMemory Usage: 48.8 MB, less than 75.90% of JavaScript online submissions for Count Lattice Points Inside a Circle.\\n\\nvar countLatticePoints = function(circles) {\\n    const coordinateRange = Array.from({ length: 201 }, () => []);\\n\\n    const isInsideCircle = (j, x, i, y, r) => (j - x) ** 2 + (i - y) ** 2 <= r * r;\\n\\n\\t/*   Time O(radius * circles)   */\\n    for (const [x, y, r] of circles) {\\n        for (let i = y + r, j = x; i >= y; i--) {\\n            for (; isInsideCircle(j, x, i, y, r); j++);\\n\\n            coordinateRange[i].push([2 * x - (j - 1), j - 1]);\\n            coordinateRange[2 * y - i].push([2 * x - (j - 1), j - 1]);\\n        }\\n    }\\n\\n\\t/*   Time O(Y * circles * log(circles))  */\\n    coordinateRange.forEach((ranges) =>\\n        ranges.sort(([start2, end2], [start1, end1]) =>\\n            start2 === start1 ? end2 - end1 : start2 - start1\\n        )\\n    );\\n\\n\\tlet ans = 0;\\n\\n    for (const ranges of coordinateRange) {\\n        let start = 0, end = -1;\\n\\n        for (const range of ranges) {\\n            if (range[0] > end) {\\n                ans += end - start + 1;\\n                start = range[0];\\n            }\\n            end = Math.max(end, range[1]);\\n        }\\n        ans += end - start + 1;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1993257,
                "title": "can-someone-tell-me-what-is-wrong-with-my-answer-javascript",
                "content": "```\\nvar countLatticePoints = function (circles) {\\n  const visited = new Set();\\n  const checkIsInside = (a, b, r, x, y) => {\\n    if ((a - x) ** 2 + (b - y) ** 2 > r ** 2) return false;\\n    return true;\\n  };\\n\\n  circles.forEach((circle) => {\\n    const [a, b, r] = circle;\\n    for (let x = a - r; x <= a + r; x++) {\\n      for (let y = b - r; y <= b + r; y++) {\\n        const coordinate = `${x}${y}`;\\n        if (checkIsInside(a, b, r, x, y)) visited.add(coordinate);\\n      }\\n    }\\n  });\\n  return visited.size;\\n};\\n```\\n\\nin the case of this\\n```\\nconst circles = [\\n  [10, 7, 3],\\n  [5, 9, 5],\\n  [10, 4, 2],\\n  [3, 8, 2],\\n  [2, 3, 1],\\n  [2, 10, 1],\\n  [10, 9, 8],\\n  [6, 6, 3],\\n  [8, 6, 3],\\n  [9, 8, 7],\\n  [9, 4, 3],\\n  [7, 4, 1],\\n  [4, 6, 2],\\n  [4, 3, 2],\\n  [8, 3, 3],\\n];\\n```\\nI always get 231 instead of 232.\\n\\nPlease someone help me what is wrong with my answer .... :(",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countLatticePoints = function (circles) {\\n  const visited = new Set();\\n  const checkIsInside = (a, b, r, x, y) => {\\n    if ((a - x) ** 2 + (b - y) ** 2 > r ** 2) return false;\\n    return true;\\n  };\\n\\n  circles.forEach((circle) => {\\n    const [a, b, r] = circle;\\n    for (let x = a - r; x <= a + r; x++) {\\n      for (let y = b - r; y <= b + r; y++) {\\n        const coordinate = `${x}${y}`;\\n        if (checkIsInside(a, b, r, x, y)) visited.add(coordinate);\\n      }\\n    }\\n  });\\n  return visited.size;\\n};\\n```\n```\\nconst circles = [\\n  [10, 7, 3],\\n  [5, 9, 5],\\n  [10, 4, 2],\\n  [3, 8, 2],\\n  [2, 3, 1],\\n  [2, 10, 1],\\n  [10, 9, 8],\\n  [6, 6, 3],\\n  [8, 6, 3],\\n  [9, 8, 7],\\n  [9, 4, 3],\\n  [7, 4, 1],\\n  [4, 6, 2],\\n  [4, 3, 2],\\n  [8, 3, 3],\\n];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1987546,
                "title": "rust-easy-to-understand-check-all-point-within-circle",
                "content": "\\n```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut set = HashSet::new();\\n        \\n        for circle in circles{\\n            let x = circle[0];\\n            let y = circle[1];\\n            let r = circle[2];\\n            \\n            for px in (x - r)..=(x + r){\\n                for py in (y - r)..=(y+ r){\\n                    \\n\\t\\t\\t\\t\\t// difference from the center of the circle\\n                    let delta_x = x - px;\\n                    let delta_y = y - py;\\n                    \\n\\t\\t\\t\\t\\t// using pythagoras theorem ( x^2 + y^2 = z^2 )\\n\\t\\t\\t\\t\\t// to get the point\\'s (px, py) magnitude from the center of the circle\\n\\t\\t\\t\\t\\t\\n                    let magnitude = ((delta_x.pow(2) + delta_y.pow(2)) as f64).sqrt();\\n                    \\n                    if(magnitude <= r as f64){\\n                        set.insert((i, j));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        set.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_lattice_points(circles: Vec<Vec<i32>>) -> i32 {\\n        let mut set = HashSet::new();\\n        \\n        for circle in circles{\\n            let x = circle[0];\\n            let y = circle[1];\\n            let r = circle[2];\\n            \\n            for px in (x - r)..=(x + r){\\n                for py in (y - r)..=(y+ r){\\n                    \\n\\t\\t\\t\\t\\t// difference from the center of the circle\\n                    let delta_x = x - px;\\n                    let delta_y = y - py;\\n                    \\n\\t\\t\\t\\t\\t// using pythagoras theorem ( x^2 + y^2 = z^2 )\\n\\t\\t\\t\\t\\t// to get the point\\'s (px, py) magnitude from the center of the circle\\n\\t\\t\\t\\t\\t\\n                    let magnitude = ((delta_x.pow(2) + delta_y.pow(2)) as f64).sqrt();\\n                    \\n                    if(magnitude <= r as f64){\\n                        set.insert((i, j));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        set.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986495,
                "title": "python-math-simmetry",
                "content": "Runtime: 1067 ms, faster than 94.65% of Python3 online submissions for Count Lattice Points Inside a Circle.\\nMemory Usage: 17.7 MB, less than 78.30% of Python3 online submissions for Count Lattice Points Inside a Circle.\\n```\\nclass Solution:\\n  def countLatticePoints(self, circles: List[List[int]]) -> int:\\n    table = set()\\n    \\n    for c in circles :\\n      xl = c[0] - c[2]\\n      xr = c[0] + c[2]\\n      yu = c[1]\\n      yd = c[1]\\n      step = 1\\n      r2 = c[2]*c[2]\\n      \\n      for x in range (xl, xr +1) : table.add((x<<8) + yu)\\n      while step <= c[2] :\\n        yu += 1\\n        yd -= 1\\n        x = int(math.sqrt(r2 - step*step))\\n        for X in range(c[0] - x, c[0] + x + 1) :\\n          table.add((X<<8) + yu)\\n          table.add((X<<8) + yd)\\n        step += 1\\n    \\n    return len(table)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def countLatticePoints(self, circles: List[List[int]]) -> int:\\n    table = set()\\n    \\n    for c in circles :\\n      xl = c[0] - c[2]\\n      xr = c[0] + c[2]\\n      yu = c[1]\\n      yd = c[1]\\n      step = 1\\n      r2 = c[2]*c[2]\\n      \\n      for x in range (xl, xr +1) : table.add((x<<8) + yu)\\n      while step <= c[2] :\\n        yu += 1\\n        yd -= 1\\n        x = int(math.sqrt(r2 - step*step))\\n        for X in range(c[0] - x, c[0] + x + 1) :\\n          table.add((X<<8) + yu)\\n          table.add((X<<8) + yd)\\n        step += 1\\n    \\n    return len(table)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986036,
                "title": "python-solution-easy-but-no-so-efficient",
                "content": "def all_points(x,y,r):\\n\\n            lst = []\\n            for a in range(4*r):\\n                col = y-r+a\\n                for b in range(4*r):\\n                    row = x-r+b\\n                    p1,p2 = (x-row)**2,(y-col)**2\\n                    distance = math.sqrt(p1+p2)\\n                    if distance <= r:\\n                        lst.append((row,col))\\n\\n            return lst\\n\\n        \\n        circle = set()\\n        for x,y,r in circles:\\n            circle.add((x,y,r))\\n        result = set()\\n        for x,y,r in circle:\\n            ans = all_points(x,y,r)\\n            for coOrds in ans:\\n                result.add(coOrds)\\n\\n\\n        return (len(result))",
                "solutionTags": [
                    "Python"
                ],
                "code": "def all_points(x,y,r):\\n\\n            lst = []\\n            for a in range(4*r):\\n                col = y-r+a\\n                for b in range(4*r):\\n                    row = x-r+b\\n                    p1,p2 = (x-row)**2,(y-col)**2\\n                    distance = math.sqrt(p1+p2)\\n                    if distance <= r:\\n                        lst.append((row,col))\\n\\n            return lst\\n\\n        \\n        circle = set()\\n        for x,y,r in circles:\\n            circle.add((x,y,r))\\n        result = set()\\n        for x,y,r in circle:\\n            ans = all_points(x,y,r)\\n            for coOrds in ans:\\n                result.add(coOrds)\\n\\n\\n        return (len(result))",
                "codeTag": "Python3"
            },
            {
                "id": 1984232,
                "title": "brute-force-javascript-solutions",
                "content": "```\\nvar countLatticePoints = function(circles) {\\n    let res = 0;\\n    \\n\\t// constraints:\\n\\t//     1 <= xi, yi <= 100\\n\\t//     1 <= ri <= min(xi, yi)\\n    for (let i = 0; i <= 200; i++) {\\n        for (let j = 0; j <= 200; j++) {\\n            for (let [x, y, r] of circles) {\\n                if ((i - x) ** 2 + (j - y) ** 2 <= r ** 2) {\\n                    res++;\\n                    break;\\n                }                    \\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nvar countLatticePoints = function(circles) {\\n    let points = new Set();\\n    for (let [x, y, r] of circles) {\\n        for (let i = -r; i <= r; i++) {\\n            for (let j = -r; j <= r; j++) {\\n                if (i * i + j * j <= r * r) {\\n\\t\\t\\t\\t    // avoid points.add([i + x, j + y]), [3, 3] !== [3, 3]\\n\\t\\t\\t\\t\\t// objects are compared using the reference, not the value\\n\\t\\t\\t\\t\\t// MDN: The Set object lets you store unique values of any type, \\n\\t\\t\\t\\t\\t//      whether primitive values or object references.\\n                    points.add(`(${i + x}, ${j + y})`); \\n                }\\n            }\\n        }\\n    }\\n    \\n    return points.size;\\n};\\n\\n// combine the two ideas above\\nvar countLatticePoints = function(circles) {\\n    let points = Array.from(new Uint8Array(201), () => new Uint8Array(201));\\n    let res = 0;\\n    for (let [x, y, r] of circles) {\\n        for (let i = -r; i <= r; i++) {\\n            for (let j = -r; j <= r; j++) {\\n                if (i * i + j * j <= r * r) {\\n                    if (++points[i + x][j + y] === 1) res++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countLatticePoints = function(circles) {\\n    let res = 0;\\n    \\n\\t// constraints:\\n\\t//     1 <= xi, yi <= 100\\n\\t//     1 <= ri <= min(xi, yi)\\n    for (let i = 0; i <= 200; i++) {\\n        for (let j = 0; j <= 200; j++) {\\n            for (let [x, y, r] of circles) {\\n                if ((i - x) ** 2 + (j - y) ** 2 <= r ** 2) {\\n                    res++;\\n                    break;\\n                }                    \\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nvar countLatticePoints = function(circles) {\\n    let points = new Set();\\n    for (let [x, y, r] of circles) {\\n        for (let i = -r; i <= r; i++) {\\n            for (let j = -r; j <= r; j++) {\\n                if (i * i + j * j <= r * r) {\\n\\t\\t\\t\\t    // avoid points.add([i + x, j + y]), [3, 3] !== [3, 3]\\n\\t\\t\\t\\t\\t// objects are compared using the reference, not the value\\n\\t\\t\\t\\t\\t// MDN: The Set object lets you store unique values of any type, \\n\\t\\t\\t\\t\\t//      whether primitive values or object references.\\n                    points.add(`(${i + x}, ${j + y})`); \\n                }\\n            }\\n        }\\n    }\\n    \\n    return points.size;\\n};\\n\\n// combine the two ideas above\\nvar countLatticePoints = function(circles) {\\n    let points = Array.from(new Uint8Array(201), () => new Uint8Array(201));\\n    let res = 0;\\n    for (let [x, y, r] of circles) {\\n        for (let i = -r; i <= r; i++) {\\n            for (let j = -r; j <= r; j++) {\\n                if (i * i + j * j <= r * r) {\\n                    if (++points[i + x][j + y] === 1) res++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1983360,
                "title": "python-bruteforce-approach-with-set",
                "content": "For each circle, process all the unprocessed candidate points.\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        visited = set()\\n        res = 0\\n        for cx, cy, r in circles:\\n            for x in range(cx-r,cx+r+1):\\n                for y in range(cy-r,cy+r+1):\\n                    if (x,y) not in visited and (x-cx)**2 + (y-cy)**2 <= r**2:\\n                        visited.add((x,y))\\n                        res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "For each circle, process all the unprocessed candidate points.\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        visited = set()\\n        res = 0\\n        for cx, cy, r in circles:\\n            for x in range(cx-r,cx+r+1):\\n                for y in range(cy-r,cy+r+1):\\n                    if (x,y) not in visited and (x-cx)**2 + (y-cy)**2 <= r**2:\\n                        visited.add((x,y))\\n                        res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1983128,
                "title": "simple-c-solution",
                "content": "The given task is to brute force all the points from the bottom left corner to the top right corner and check if its inside. \\n\\n```Time complexity -> O(N^2)```\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int countLatticePoints(vector<vector<int>> &v)\\n    {\\n        // lattice points - points with integer coordinates inside the circle\\n        int res = 0, n = v.size();\\n        set<pair<int, int>> s; // storing all unique lattice points\\n        for (int i = 0; i < n; i++)\\n        {\\n            int x = v[i][0], y = v[i][1], r = v[i][2];\\n            int startx = x - r, starty = y - r, endx = x + r, endy = y + r;\\n            for (int i = startx; i <= endx; i++)\\n            {\\n                for (int j = starty; j <= endy; j++)\\n                {\\n                    if ((i - x) * (i - x) + (j - y) * (j - y) <= r * r)\\n                    {\\n                        // if the point is inside the circle\\n                        s.insert({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```Time complexity -> O(N^2)```\n```\\nclass Solution\\n{\\npublic:\\n    int countLatticePoints(vector<vector<int>> &v)\\n    {\\n        // lattice points - points with integer coordinates inside the circle\\n        int res = 0, n = v.size();\\n        set<pair<int, int>> s; // storing all unique lattice points\\n        for (int i = 0; i < n; i++)\\n        {\\n            int x = v[i][0], y = v[i][1], r = v[i][2];\\n            int startx = x - r, starty = y - r, endx = x + r, endy = y + r;\\n            for (int i = startx; i <= endx; i++)\\n            {\\n                for (int j = starty; j <= endy; j++)\\n                {\\n                    if ((i - x) * (i - x) + (j - y) * (j - y) <= r * r)\\n                    {\\n                        // if the point is inside the circle\\n                        s.insert({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982726,
                "title": "c-consider-all-points",
                "content": "```\\nclass Solution {\\npublic:\\n    bool liesInside(int cx , int cy , int r , int x , int y){\\n        int d = (cx-x)*(cx-x) + (cy-y)*(cy-y) ;\\n        if(d <= r*r) return true ;\\n        return false ;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int latticePoints = 0 ;\\n        //maximum point covered can be 200 , assumed x = 100 , y = 100 then radius = 100 ;\\n        for(int x = 0 ; x <= 200 ; ++x ){\\n            for(int y = 0 ; y <= 200 ; ++y){\\n                \\n                for(auto &circle : circles){\\n                    int cx = circle[0] , cy = circle[1] , r = circle[2] ;\\n                    if(liesInside(cx,cy,r,x,y)){\\n                        ++latticePoints ;\\n                        break ;\\n                    }\\n                }\\n            }\\n        }\\n        return latticePoints ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool liesInside(int cx , int cy , int r , int x , int y){\\n        int d = (cx-x)*(cx-x) + (cy-y)*(cy-y) ;\\n        if(d <= r*r) return true ;\\n        return false ;\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int latticePoints = 0 ;\\n        //maximum point covered can be 200 , assumed x = 100 , y = 100 then radius = 100 ;\\n        for(int x = 0 ; x <= 200 ; ++x ){\\n            for(int y = 0 ; y <= 200 ; ++y){\\n                \\n                for(auto &circle : circles){\\n                    int cx = circle[0] , cy = circle[1] , r = circle[2] ;\\n                    if(liesInside(cx,cy,r,x,y)){\\n                        ++latticePoints ;\\n                        break ;\\n                    }\\n                }\\n            }\\n        }\\n        return latticePoints ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982183,
                "title": "python-sets",
                "content": "# Solution\\n\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        def each_one(circle):\\n            x,y,r = circle\\n            ans = set()\\n            for i in range(0,r+1):\\n                for j in range(0,r+1):\\n                    if (i)**2 + (j)**2 <= r**2:\\n                        ans.add((i+x,j+y))\\n                        ans.add((-i+x,j+y))\\n                        ans.add((i+x,-j+y))\\n                        ans.add((-i+x,-j+y))\\n                    else:\\n                        break\\n            return ans\\n        ans = set()\\n        for each in circles:\\n            ans = ans | each_one(each)\\n        return len(ans)\\n```\\n# Explanation\\n## helper function:\\nfirst of all, notice that we can do all our calculations on quarter of the circle and then derive the rest of our points based on that since a circle is symmetric about the origin.\\niterate over all points from the origin to the origin+radius on both the x and y axis.\\nif those points have distance less than or equal to `r` from origin, include them in your answer\\nfor every point (i,j) that you include, also include (-i,j), (i,-j), and (-i,-j)\\nreturn answer as a set\\n## outer function\\ncreate an empty set.\\niterate over all circles\\nfor each circle, join the result of the helper function (which returns a set of each point inside the current circle) to ans.\\nreturn ans\\n\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        def each_one(circle):\\n            x,y,r = circle\\n            ans = set()\\n            for i in range(0,r+1):\\n                for j in range(0,r+1):\\n                    if (i)**2 + (j)**2 <= r**2:\\n                        ans.add((i+x,j+y))\\n                        ans.add((-i+x,j+y))\\n                        ans.add((i+x,-j+y))\\n                        ans.add((-i+x,-j+y))\\n                    else:\\n                        break\\n            return ans\\n        ans = set()\\n        for each in circles:\\n            ans = ans | each_one(each)\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981904,
                "title": "reduce-number-of-loops-by-applying-symmetry",
                "content": "```python\\ndef iterZeroBasedPoints(r):\\n    \\n    yield (0, 0)\\n\\n    for x, y in itertools.product(range(0, r+1), range(0, r+1)):\\n\\n        if (x, y) == (0, 0):\\n            continue\\n\\n        if x**2 + y**2 <= r**2: # Iterate over points with 90 degree rotations\\n            yield (x, y)\\n            yield (y, -x)\\n            yield (-x, -y)\\n            yield (-y, x)\\n\\n\\n@functools.lru_cache()\\ndef getPoints(x0, y0, r) -> set:\\n    return set((x + x0, y + y0) for x, y in iterZeroBasedPoints(r))\\n\\n\\nclass Solution:\\n    \\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = reduce(lambda a, b: a.union(b), [getPoints(x, y, r) for x, y, r in circles])\\n        return len(points)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```python\\ndef iterZeroBasedPoints(r):\\n    \\n    yield (0, 0)\\n\\n    for x, y in itertools.product(range(0, r+1), range(0, r+1)):\\n\\n        if (x, y) == (0, 0):\\n            continue\\n\\n        if x**2 + y**2 <= r**2: # Iterate over points with 90 degree rotations\\n            yield (x, y)\\n            yield (y, -x)\\n            yield (-x, -y)\\n            yield (-y, x)\\n\\n\\n@functools.lru_cache()\\ndef getPoints(x0, y0, r) -> set:\\n    return set((x + x0, y + y0) for x, y in iterZeroBasedPoints(r))\\n\\n\\nclass Solution:\\n    \\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = reduce(lambda a, b: a.union(b), [getPoints(x, y, r) for x, y, r in circles])\\n        return len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981867,
                "title": "simple-and-easy-to-understand-neat-and-clean-code-in-c",
                "content": "```\\nint countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        int n = circles.size();\\n        set<pair<int,int>> s; //for storing only unique points\\n        \\n        for(int z=0;z<n;z++){\\n            \\n            int x = circles[z][0];\\n            int y = circles[z][1];\\n            int r = circles[z][2];\\n            \\n            int left = x-r;  //the leftmost point\\n            int down = y-r;  //the rightmost point\\n            \\n//move from leftmost to rightmost points and\\n//move from bottom to top points\\n            \\n            for(int i=left;i<=x+r;i++){\\n                for(int j=down;j<=y+r;j++){\\n                    if((x-i)*(x-i)+(y-j)*(y-j)<=r*r){\\n                        s.insert({i,j});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return s.size();\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\nint countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        int n = circles.size();\\n        set<pair<int,int>> s; //for storing only unique points\\n        \\n        for(int z=0;z<n;z++){\\n            \\n            int x = circles[z][0];\\n            int y = circles[z][1];\\n            int r = circles[z][2];\\n            \\n            int left = x-r;  //the leftmost point\\n            int down = y-r;  //the rightmost point\\n            \\n//move from leftmost to rightmost points and\\n//move from bottom to top points\\n            \\n            for(int i=left;i<=x+r;i++){\\n                for(int j=down;j<=y+r;j++){\\n                    if((x-i)*(x-i)+(y-j)*(y-j)<=r*r){\\n                        s.insert({i,j});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return s.size();\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1981648,
                "title": "c-unordered-set-100-faster",
                "content": "I found that many people use set<pair<int, int>> for simplicity, but it is not reasonable to order these coordinates. Although unordered_set<pair<int, int>> is not supported by default, we can assign a proper hash function to it as we know that the range of 0 <= x, y <= 100. Then by brute force checking them, we have the following solution.\\n\\n(Note that if you try a bad hash function such as pair<int, int> p => p.first ^ p.second, this would lead to tons of hash value confliction and then TLE.)\\n```\\nclass hashFunction {\\npublic:\\n    size_t operator()(const pair<int , int> &x)const {\\n        return x.first * 1000 + x.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<pair<int, int>, hashFunction> uset;\\n        for (auto& circle : circles) {\\n            int sx = circle[0], sy = circle[1], r = circle[2];\\n            for (int x = -r;x <= r;x++) {\\n                for (int y = -r;y <= r;y++) {\\n                    if (x * x + y * y <= r * r) {\\n                        uset.insert({x + sx, y + sy});\\n                    }\\n                }\\n            }\\n        }\\n        return uset.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass hashFunction {\\npublic:\\n    size_t operator()(const pair<int , int> &x)const {\\n        return x.first * 1000 + x.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<pair<int, int>, hashFunction> uset;\\n        for (auto& circle : circles) {\\n            int sx = circle[0], sy = circle[1], r = circle[2];\\n            for (int x = -r;x <= r;x++) {\\n                for (int y = -r;y <= r;y++) {\\n                    if (x * x + y * y <= r * r) {\\n                        uset.insert({x + sx, y + sy});\\n                    }\\n                }\\n            }\\n        }\\n        return uset.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981240,
                "title": "three-loops-100-speed",
                "content": "![image](https://assets.leetcode.com/users/images/05a01cf5-d665-47d0-aa9c-e34126567f8a_1650889549.71587.png)\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = set()\\n        for cx, cy, r in circles:\\n            r2 = r * r\\n            for x in range(-r, r + 1):\\n                y_05 = int(pow(r2 - x * x, 0.5))\\n                for y in range(-y_05, y_05 + 1):\\n                    points.add((cx + x, cy + y))\\n        return len(points)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        points = set()\\n        for cx, cy, r in circles:\\n            r2 = r * r\\n            for x in range(-r, r + 1):\\n                y_05 = int(pow(r2 - x * x, 0.5))\\n                for y in range(-y_05, y_05 + 1):\\n                    points.add((cx + x, cy + y))\\n        return len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980932,
                "title": "what-is-wrong-with-my-recursive-solution-getting-wa",
                "content": "I got wrong answer using the following code. Can someone help to understand what is wrong with this one?\\n\\n```\\nclass Solution {\\npublic:\\n    set<pair<int, int>> points;\\n    vector<vector<int>> circ;\\n    set<pair<int, int>> vis;\\n    \\n    \\n    int minY = 200, maxX = -200, maxY = -200, minX = 200;\\n    \\n    bool isInside(int circle_x, int circle_y,\\n                   int rad, int x, int y)\\n    {\\n        \\n        if ((x - circle_x) * (x - circle_x) +\\n            (y - circle_y) * (y - circle_y) <= rad * rad)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    bool isInside(int x, int y)\\n    {\\n        \\n        for (auto v : circ) {\\n            if (isInside(v[0], v[1], v[2], x, y)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    void generate(pair<int, int> currentPos, int radius) {\\n        //cout << \"in generate\\\\n\";\\n        auto x = currentPos.first;\\n        auto y = currentPos.second;\\n       \\n        \\n        if (vis.count({x, y}) != 0) return;\\n        \\n        vis.insert({x, y});\\n        \\n        if (x > maxX || x < minX || y > maxY || y < minY) {\\n            return; // out of area\\n        }\\n        if (points.count({x, y}) == 0 && isInside(x, y)) {\\n            points.insert({x, y});\\n        }\\n        //up\\n        generate({x, y + radius}, radius);\\n        //down\\n        generate({x, y - radius}, radius);\\n        //left \\n        generate({x - radius, y}, radius);\\n        //right\\n        generate({x + radius, y}, radius);\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        circ = circles;\\n        \\n        vis = set<pair<int, int>>();\\n        \\n        minY = INT_MAX, maxX = INT_MIN, maxY = INT_MIN, minX = INT_MAX;\\n        for (auto v : circles) {\\n            minY = min(minY, v[1] - v[2]);\\n            maxY = max(maxY, v[1] + v[2]);\\n            minX = min(minX, v[0] - v[2]);\\n            maxX = max(maxX, v[0] + v[2]);\\n        }\\n        \\n        //cout << minX <<\" \" << maxX << \" \" << minY << \" \" << maxY << endl;\\n        \\n        \\n        for (auto v : circles) {\\n            generate({v[0], v[1]}, v[2]);\\n        }\\n        \\n        return points.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<pair<int, int>> points;\\n    vector<vector<int>> circ;\\n    set<pair<int, int>> vis;\\n    \\n    \\n    int minY = 200, maxX = -200, maxY = -200, minX = 200;\\n    \\n    bool isInside(int circle_x, int circle_y,\\n                   int rad, int x, int y)\\n    {\\n        \\n        if ((x - circle_x) * (x - circle_x) +\\n            (y - circle_y) * (y - circle_y) <= rad * rad)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    bool isInside(int x, int y)\\n    {\\n        \\n        for (auto v : circ) {\\n            if (isInside(v[0], v[1], v[2], x, y)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    void generate(pair<int, int> currentPos, int radius) {\\n        //cout << \"in generate\\\\n\";\\n        auto x = currentPos.first;\\n        auto y = currentPos.second;\\n       \\n        \\n        if (vis.count({x, y}) != 0) return;\\n        \\n        vis.insert({x, y});\\n        \\n        if (x > maxX || x < minX || y > maxY || y < minY) {\\n            return; // out of area\\n        }\\n        if (points.count({x, y}) == 0 && isInside(x, y)) {\\n            points.insert({x, y});\\n        }\\n        //up\\n        generate({x, y + radius}, radius);\\n        //down\\n        generate({x, y - radius}, radius);\\n        //left \\n        generate({x - radius, y}, radius);\\n        //right\\n        generate({x + radius, y}, radius);\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        circ = circles;\\n        \\n        vis = set<pair<int, int>>();\\n        \\n        minY = INT_MAX, maxX = INT_MIN, maxY = INT_MIN, minX = INT_MAX;\\n        for (auto v : circles) {\\n            minY = min(minY, v[1] - v[2]);\\n            maxY = max(maxY, v[1] + v[2]);\\n            minX = min(minX, v[0] - v[2]);\\n            maxX = max(maxX, v[0] + v[2]);\\n        }\\n        \\n        //cout << minX <<\" \" << maxX << \" \" << minY << \" \" << maxY << endl;\\n        \\n        \\n        for (auto v : circles) {\\n            generate({v[0], v[1]}, v[2]);\\n        }\\n        \\n        return points.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1980879,
                "title": "python-set-solution-2613ms",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        #Will be used to ignore duplicate circles\\n        used = set();\\n        \\n        #Put all the lattice points in a set\\n        latticePoints = set();\\n        \\n        for triplet in circles:\\n            circle_id = str( triplet );\\n            \\n            #To ignore duplicates\\n            if circle_id in used:\\n                continue;\\n            \\n            #Feed through helper\\n            self.addLP( latticePoints, triplet );\\n            used.add( circle_id );\\n            \\n        #Return the length of the set\\n        return len( latticePoints );\\n        \\n    def addLP( self, latticePoints, triplet ):\\n        \\n        #Unpack values\\n        r = triplet[ 2 ];\\n        d = r * 2;\\n        x =  triplet[ 0 ] - r;\\n        y =  triplet[ 1 ] - r;\\n\\n        #Used_lengths keeps track of good lengths\\n        valid_lengths = set();\\n        invalid_lengths = set();\\n        \\n        for i in range( d + 1 ):\\n            for j in range( d + 1 ):\\n                \\n                #Find the vertical and horizontal length\\n                #Relative to the center of the circle\\n                #To the current coorindate ( a,b )\\n                a = x + i;\\n                length_a = abs( triplet[ 0 ] - a);\\n                b = y + j;\\n                length_b = abs( triplet[ 1 ] - b);\\n                \\n                \\n                length_id = str( [ length_a, length_b ] );\\n                \\n                #If this length combo has been evaluated:\\n                if length_id in valid_lengths:\\n                    latticePoints.add( str( [ x + i, y + j ]) );\\n                elif length_id in invalid_lengths:\\n                    continue;\\n                    \\n                #Otherwise, check it and add to relevant set\\n                else:\\n                    is_inside = self.inside( length_a, length_b, r );\\n                    if is_inside:\\n                        latticePoints.add( str( [ x + i, y + j ]) );\\n                        valid_lengths.add( length_id );\\n                    else:\\n                        invalid_lengths.add( length_id );\\n        \\n    #a^2 + b^2 = c^2  ==>\\n    #c = sqrt( a^2 + b^2 )\\n    #Check to make sure c is less than or equal to r\\n    def inside( self, length_a , length_b, r ):\\n        a_square = math.pow( length_a, 2 );\\n        b_square = math.pow( length_b, 2 );\\n        c = math.sqrt( a_square + b_square );\\n        return c <= r;\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        \\n        #Will be used to ignore duplicate circles\\n        used = set();\\n        \\n        #Put all the lattice points in a set\\n        latticePoints = set();\\n        \\n        for triplet in circles:\\n            circle_id = str( triplet );\\n            \\n            #To ignore duplicates\\n            if circle_id in used:\\n                continue;\\n            \\n            #Feed through helper\\n            self.addLP( latticePoints, triplet );\\n            used.add( circle_id );\\n            \\n        #Return the length of the set\\n        return len( latticePoints );\\n        \\n    def addLP( self, latticePoints, triplet ):\\n        \\n        #Unpack values\\n        r = triplet[ 2 ];\\n        d = r * 2;\\n        x =  triplet[ 0 ] - r;\\n        y =  triplet[ 1 ] - r;\\n\\n        #Used_lengths keeps track of good lengths\\n        valid_lengths = set();\\n        invalid_lengths = set();\\n        \\n        for i in range( d + 1 ):\\n            for j in range( d + 1 ):\\n                \\n                #Find the vertical and horizontal length\\n                #Relative to the center of the circle\\n                #To the current coorindate ( a,b )\\n                a = x + i;\\n                length_a = abs( triplet[ 0 ] - a);\\n                b = y + j;\\n                length_b = abs( triplet[ 1 ] - b);\\n                \\n                \\n                length_id = str( [ length_a, length_b ] );\\n                \\n                #If this length combo has been evaluated:\\n                if length_id in valid_lengths:\\n                    latticePoints.add( str( [ x + i, y + j ]) );\\n                elif length_id in invalid_lengths:\\n                    continue;\\n                    \\n                #Otherwise, check it and add to relevant set\\n                else:\\n                    is_inside = self.inside( length_a, length_b, r );\\n                    if is_inside:\\n                        latticePoints.add( str( [ x + i, y + j ]) );\\n                        valid_lengths.add( length_id );\\n                    else:\\n                        invalid_lengths.add( length_id );\\n        \\n    #a^2 + b^2 = c^2  ==>\\n    #c = sqrt( a^2 + b^2 )\\n    #Check to make sure c is less than or equal to r\\n    def inside( self, length_a , length_b, r ):\\n        a_square = math.pow( length_a, 2 );\\n        b_square = math.pow( length_b, 2 );\\n        c = math.sqrt( a_square + b_square );\\n        return c <= r;\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980498,
                "title": "precalculation-with-no-sqrt-needed-in-runtime",
                "content": "For any point `(p, q)` in a square of `(x\\xB1r, y\\xB1r) `, we would want to check if it is a lattice point. \\nLet `long_pole` and `short_pole` to represent the max and min value of `abs(p - x)` and `abs(q - y)`.\\nWhen `long_pole >= r/2`, we would want to know the max value of  `short_pole` so that for any `shot_pole` equal or below that value, `(p, q)` is lattice point.\\n\\nSince `r <= 200`, this information can be precalculated.\\n\\nWe track the found lattice points with a hash set.\\n\\nThe precalculated results are too large and it cannot fit into this thread. Using `<PRECALCULATED_RESULTS>` to represent it.\\n\\nPrecalculation\\n```\\nradius_inclusion_map = {x: {} for x in range(1, 201)}\\nfor radius in radius_inclusion_map.keys():\\n    for long_pole in range(radius, (radius+1)//2-1, -1):\\n        for short_pole in range(long_pole, -1, -1):\\n            if short_pole ** 2 + long_pole ** 2 <= radius ** 2:\\n                radius_inclusion_map[radius][long_pole] = short_pole\\n                break\\n\\nprint(radius_inclusion_map)\\n```\\n\\nSolution:\\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        radius_inclusion_map = {<PRECALCULATED_RESULTS>}\\n        included = set()\\n        for circle in circles:\\n            for x in range(circle[0] - circle[2], circle[0] + circle[2] + 1):\\n                for y in range(circle[1] - circle[2], circle[1] + circle[2] + 1):\\n                    if (x, y) in included:\\n                        continue\\n                    diff_1, diff_2 = abs(x - circle[0]), abs(y - circle[1])\\n                    long_pole, short_pole = (diff_1, diff_2) if diff_1 >= diff_2 else (diff_2, diff_1)\\n                    if long_pole <= circle[2]//2 or short_pole <= radius_inclusion_map[circle[2]][long_pole]:\\n                        included.add((x, y))\\n        return len(included)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nradius_inclusion_map = {x: {} for x in range(1, 201)}\\nfor radius in radius_inclusion_map.keys():\\n    for long_pole in range(radius, (radius+1)//2-1, -1):\\n        for short_pole in range(long_pole, -1, -1):\\n            if short_pole ** 2 + long_pole ** 2 <= radius ** 2:\\n                radius_inclusion_map[radius][long_pole] = short_pole\\n                break\\n\\nprint(radius_inclusion_map)\\n```\n```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        radius_inclusion_map = {<PRECALCULATED_RESULTS>}\\n        included = set()\\n        for circle in circles:\\n            for x in range(circle[0] - circle[2], circle[0] + circle[2] + 1):\\n                for y in range(circle[1] - circle[2], circle[1] + circle[2] + 1):\\n                    if (x, y) in included:\\n                        continue\\n                    diff_1, diff_2 = abs(x - circle[0]), abs(y - circle[1])\\n                    long_pole, short_pole = (diff_1, diff_2) if diff_1 >= diff_2 else (diff_2, diff_1)\\n                    if long_pole <= circle[2]//2 or short_pole <= radius_inclusion_map[circle[2]][long_pole]:\\n                        included.add((x, y))\\n        return len(included)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980296,
                "title": "simple-c-solutions-using-math",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isInside(int x , int y , int x1 , int y1  , int r){\\n        int temp = (x-x1)*(x-x1) + (y-y1)*(y-y1);\\n        if(temp<=r*r){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> st;\\n        for(int i=0 ; i<circles.size() ; i++){\\n            vector<int> temp = circles[i];\\n            int x = temp[0];\\n            int y = temp[1];\\n            int r = temp[2];\\n            \\n            for(int k=-r; k<=r ; k++){\\n               for(int l=-r ; l<=r ; l++){\\n                   if(isInside(x,y , x+k , y+l , r)){\\n                       st.insert({x+k , y+l});\\n                   }\\n               }\\n            }\\n            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInside(int x , int y , int x1 , int y1  , int r){\\n        int temp = (x-x1)*(x-x1) + (y-y1)*(y-y1);\\n        if(temp<=r*r){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> st;\\n        for(int i=0 ; i<circles.size() ; i++){\\n            vector<int> temp = circles[i];\\n            int x = temp[0];\\n            int y = temp[1];\\n            int r = temp[2];\\n            \\n            for(int k=-r; k<=r ; k++){\\n               for(int l=-r ; l<=r ; l++){\\n                   if(isInside(x,y , x+k , y+l , r)){\\n                       st.insert({x+k , y+l});\\n                   }\\n               }\\n            }\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980160,
                "title": "python-accepted-faster-than-100",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        circles = set(map(lambda x: tuple(x), circles))\\n        for i in circles:\\n            for x in range(i[0]-i[2],i[0]+i[2]+1):\\n                for y in range(i[1]-i[2],i[1]+i[2]+1):\\n                    if((x-i[0])**2+(y-i[1])**2)<=i[2]**2:\\n                        s.add((x,y))\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        circles = set(map(lambda x: tuple(x), circles))\\n        for i in circles:\\n            for x in range(i[0]-i[2],i[0]+i[2]+1):\\n                for y in range(i[1]-i[2],i[1]+i[2]+1):\\n                    if((x-i[0])**2+(y-i[1])**2)<=i[2]**2:\\n                        s.add((x,y))\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980153,
                "title": "c-optimized-100-faster",
                "content": "A better approach for culling is to identify enclosing circles and eliminating them altogether.\\nAlso, it is possible to construct an example where my approach for culling the inner rectangle points is incorrect (LC does not have such test cases). A better approach is to use a seperate unordered_set for each circle and combine them into one large set for the final count. \\n\\n```\\n    typedef std::pair<int, int> XYPair;\\npublic:\\n    // arg1: c denotes the non-xy plane coordinates of a point on the circumference of\\n    //       the circle whose origin is at \\'(0,0)\\'.\\n    // arg2: o denotes the (x,y) coordinates of the center of the circle.\\n    // arg3: output set of points inside the circle.\\n    void fillPointsUsingCircumferencePoint(XYPair c, XYPair o, unordered_set<uint64_t>& points) \\n    {\\n        int xy[2];\\n        uint64_t *xyPoint = (uint64_t*)xy;\\n        bool skip;\\n        \\n        for (int y = c.second; y > 0; y--) {\\n            for (int x = c.first; x > 0; x--) {\\n                skip = 1;\\n                \\n                xy[0] = x + o.first; xy[1] = y + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = (-x) + o.first; xy[1] = y + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = x + o.first; xy[1] = (-y) + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = (-x) + o.first; xy[1] = (-y) + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                // all points inside the rectangle defined by the 4 corners are already inserted.\\n                if (skip)\\n                    break;\\n            }\\n        }\\n    }\\n    \\n    // arg1: a denotes an x/y plane point on the circumference of the circle\\n    //       whose origin is at \\'(0,0)\\'.\\n    // arg2: o denotes the x, y coordinates of the center of the circle.\\n    // arg3: output set of points inside the circle.\\n    void fillPointsOnAxis(XYPair a, XYPair o, unordered_set<uint64_t>& points)\\n    {\\n        int xy[2];\\n        uint64_t *xyPoint = (uint64_t*)xy;\\n        bool skip;\\n        \\n        xy[0] = o.first; xy[1] = o.second;\\n        points.insert(*xyPoint);\\n        for (int x = a.first, y = a.second; x > 0; x--, y--) {    \\n            skip = 1;\\n            \\n            xy[0] = x + o.first; xy[1] = o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = (-x) + o.first; xy[1] = o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = o.first; xy[1] = y + o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = o.first; xy[1] = (-y) + o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            if (skip)\\n                break;\\n        }\\n    }\\n    \\n    void generateCircumferencePointsAndFill(XYPair o, int radius, unordered_set<uint64_t>& points)\\n    {\\n        for (int x = o.first + radius - 1; x > o.first; --x) {\\n            for (int y = o.second + radius -1; y > o.second; --y) {\\n                if (ceil(sqrt((x-o.first)*(x-o.first) + (y-o.second)*(y-o.second))) <= radius) {\\n                    fillPointsUsingCircumferencePoint(make_pair(x-o.first, y-o.second), o, points);\\n                    break;\\n                }\\n            }\\n        }\\n        fillPointsOnAxis(make_pair(radius, radius), o, points);\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<uint64_t> lp;\\n        \\n        for (auto circle: circles) {\\n            auto origin = make_pair(circle[0], circle[1]);\\n            auto radius = circle[2];\\n            generateCircumferencePointsAndFill(origin, radius, lp);\\n        }\\n        return lp.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    typedef std::pair<int, int> XYPair;\\npublic:\\n    // arg1: c denotes the non-xy plane coordinates of a point on the circumference of\\n    //       the circle whose origin is at \\'(0,0)\\'.\\n    // arg2: o denotes the (x,y) coordinates of the center of the circle.\\n    // arg3: output set of points inside the circle.\\n    void fillPointsUsingCircumferencePoint(XYPair c, XYPair o, unordered_set<uint64_t>& points) \\n    {\\n        int xy[2];\\n        uint64_t *xyPoint = (uint64_t*)xy;\\n        bool skip;\\n        \\n        for (int y = c.second; y > 0; y--) {\\n            for (int x = c.first; x > 0; x--) {\\n                skip = 1;\\n                \\n                xy[0] = x + o.first; xy[1] = y + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = (-x) + o.first; xy[1] = y + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = x + o.first; xy[1] = (-y) + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                xy[0] = (-x) + o.first; xy[1] = (-y) + o.second;\\n                skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n                \\n                // all points inside the rectangle defined by the 4 corners are already inserted.\\n                if (skip)\\n                    break;\\n            }\\n        }\\n    }\\n    \\n    // arg1: a denotes an x/y plane point on the circumference of the circle\\n    //       whose origin is at \\'(0,0)\\'.\\n    // arg2: o denotes the x, y coordinates of the center of the circle.\\n    // arg3: output set of points inside the circle.\\n    void fillPointsOnAxis(XYPair a, XYPair o, unordered_set<uint64_t>& points)\\n    {\\n        int xy[2];\\n        uint64_t *xyPoint = (uint64_t*)xy;\\n        bool skip;\\n        \\n        xy[0] = o.first; xy[1] = o.second;\\n        points.insert(*xyPoint);\\n        for (int x = a.first, y = a.second; x > 0; x--, y--) {    \\n            skip = 1;\\n            \\n            xy[0] = x + o.first; xy[1] = o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = (-x) + o.first; xy[1] = o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = o.first; xy[1] = y + o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            xy[0] = o.first; xy[1] = (-y) + o.second;\\n            skip &= ((points.find(*xyPoint) == points.end()) ? points.insert(*xyPoint), 0 : 1);\\n            \\n            if (skip)\\n                break;\\n        }\\n    }\\n    \\n    void generateCircumferencePointsAndFill(XYPair o, int radius, unordered_set<uint64_t>& points)\\n    {\\n        for (int x = o.first + radius - 1; x > o.first; --x) {\\n            for (int y = o.second + radius -1; y > o.second; --y) {\\n                if (ceil(sqrt((x-o.first)*(x-o.first) + (y-o.second)*(y-o.second))) <= radius) {\\n                    fillPointsUsingCircumferencePoint(make_pair(x-o.first, y-o.second), o, points);\\n                    break;\\n                }\\n            }\\n        }\\n        fillPointsOnAxis(make_pair(radius, radius), o, points);\\n    }\\n    \\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_set<uint64_t> lp;\\n        \\n        for (auto circle: circles) {\\n            auto origin = make_pair(circle[0], circle[1]);\\n            auto radius = circle[2];\\n            generateCircumferencePointsAndFill(origin, radius, lp);\\n        }\\n        return lp.size();\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1979983,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> st;\\n        \\n        for (auto& c : circles) {\\n            const int& x = c[0];\\n            const int& y = c[1];\\n            const int& r = c[2];\\n            \\n            for (int i = x - r; i <= x + r; ++i) {\\n                for (int j = y - r; j <= y + r; ++j) {\\n                    if ((i - x) * (i - x) + (j - y) * (j - y) <= r * r) {\\n                        st.insert({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int, int>> st;\\n        \\n        for (auto& c : circles) {\\n            const int& x = c[0];\\n            const int& y = c[1];\\n            const int& r = c[2];\\n            \\n            for (int i = x - r; i <= x + r; ++i) {\\n                for (int j = y - r; j <= y + r; ++j) {\\n                    if ((i - x) * (i - x) + (j - y) * (j - y) <= r * r) {\\n                        st.insert({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979808,
                "title": "scala",
                "content": "```\\nimport math.{pow, sqrt}\\n\\nobject Solution {\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    circles\\n      .iterator\\n      .flatMap {\\n        case Array(x, y, r) => (x - r to x + r)\\n          .iterator\\n          .flatMap { i =>\\n            val z = sqrt(pow(r, 2.0) - pow(i - x, 2.0)).toInt\\n            (y - z to y + z).iterator.map(i -> _)\\n          }\\n      }\\n      .distinct\\n      .size\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport math.{pow, sqrt}\\n\\nobject Solution {\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    circles\\n      .iterator\\n      .flatMap {\\n        case Array(x, y, r) => (x - r to x + r)\\n          .iterator\\n          .flatMap { i =>\\n            val z = sqrt(pow(r, 2.0) - pow(i - x, 2.0)).toInt\\n            (y - z to y + z).iterator.map(i -> _)\\n          }\\n      }\\n      .distinct\\n      .size\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1979653,
                "title": "java-brute-force",
                "content": "```\\nstatic int X= 0, Y= 1, R= 2;\\n\\n// brute force\\npublic int countLatticePoints(int[][] circles) {\\n\\t// 1. sort circles from largest to smallest (heuristic)\\n\\tArrays.sort(circles, (c1, c2)->Integer.compare(c2[R],c1[R]));\\n\\n    // 2. find the smallest rectangle containing all circles\\n\\tint minX= Integer.MAX_VALUE, maxX= Integer.MIN_VALUE;\\n\\tint minY= Integer.MAX_VALUE, maxY= Integer.MIN_VALUE;\\n\\tfor(int[] c:circles){\\n\\t\\tminX= Math.min(minX, c[X]-c[R]);\\n\\t\\tmaxX= Math.max(maxX, c[X]+c[R]);\\n\\t\\tminY= Math.min(minY, c[Y]-c[R]);\\n\\t\\tmaxY= Math.max(maxY, c[Y]+c[R]);\\n\\t}\\n\\t// 3. for all lattice points in the rectangle check if at least one circle contains them\\n\\tint count= 0;\\n\\tfor(int x=minX; x<=maxX; x++){\\n\\t\\tfor(int y=minY; y<=maxY; y++){\\n\\t\\t\\tfor(int[] c:circles){\\n\\t\\t\\t\\tint rsq= c[R]*c[R];\\n\\t\\t\\t\\tint dx= Math.abs(c[X]-x), dy= Math.abs(c[Y]-y);\\n\\t\\t\\t\\tif(dx*dx+dy*dy<=rsq){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}           \\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}",
                "solutionTags": [],
                "code": "```\\nstatic int X= 0, Y= 1, R= 2;\\n\\n// brute force\\npublic int countLatticePoints(int[][] circles) {\\n\\t// 1. sort circles from largest to smallest (heuristic)\\n\\tArrays.sort(circles, (c1, c2)->Integer.compare(c2[R],c1[R]));\\n\\n    // 2. find the smallest rectangle containing all circles\\n\\tint minX= Integer.MAX_VALUE, maxX= Integer.MIN_VALUE;\\n\\tint minY= Integer.MAX_VALUE, maxY= Integer.MIN_VALUE;\\n\\tfor(int[] c:circles){\\n\\t\\tminX= Math.min(minX, c[X]-c[R]);\\n\\t\\tmaxX= Math.max(maxX, c[X]+c[R]);\\n\\t\\tminY= Math.min(minY, c[Y]-c[R]);\\n\\t\\tmaxY= Math.max(maxY, c[Y]+c[R]);\\n\\t}\\n\\t// 3. for all lattice points in the rectangle check if at least one circle contains them\\n\\tint count= 0;\\n\\tfor(int x=minX; x<=maxX; x++){\\n\\t\\tfor(int y=minY; y<=maxY; y++){\\n\\t\\t\\tfor(int[] c:circles){\\n\\t\\t\\t\\tint rsq= c[R]*c[R];\\n\\t\\t\\t\\tint dx= Math.abs(c[X]-x), dy= Math.abs(c[Y]-y);\\n\\t\\t\\t\\tif(dx*dx+dy*dy<=rsq){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}           \\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1979578,
                "title": "easy-brute-force-solution-c",
                "content": "Check for all points and store them in set.\\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        for(int i=0;i<circles.size();i++){\\n            \\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n            int x1=x-r;\\n            int x2=x+r;\\n            int y1=y-r;\\n            int y2=y+r;\\n            \\n            for(int j=x1;j<=x2;j++){\\n                for(int k=y1;k<=y2;k++){\\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=(r*r))\\n                    s.insert({j,k});\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        set<pair<int,int>> s;\\n        for(int i=0;i<circles.size();i++){\\n            \\n            int x=circles[i][0];\\n            int y=circles[i][1];\\n            int r=circles[i][2];\\n            int x1=x-r;\\n            int x2=x+r;\\n            int y1=y-r;\\n            int y2=y+r;\\n            \\n            for(int j=x1;j<=x2;j++){\\n                for(int k=y1;k<=y2;k++){\\n                    if(((j-x)*(j-x)+(k-y)*(k-y))<=(r*r))\\n                    s.insert({j,k});\\n                }\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979318,
                "title": "c-optimized-brute-force-100-faster-and-100-less-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int minX{INT_MAX}, minY{INT_MAX}, maxX{}, maxY{}, ct{};\\n\\t\\t\\n\\t\\t// Find bounding box containing all circles\\n        for(const auto& circle : circles)\\n        {\\n            minX = std::min(minX, circle[0] - circle[2]);\\n            minY = std::min(minY, circle[1] - circle[2]);\\n            maxX = std::max(maxX, circle[0] + circle[2]);\\n            maxY = std::max(maxY, circle[1] + circle[2]);\\n        }\\n        \\n\\t\\t// Sweep through the bounding box containing all circles\\n        for(int x = minX; x <= maxX; x++)\\n        {\\n            for(int y = minY; y <= maxY; y++)\\n            {\\n                for(const auto& circle : circles)\\n                {\\n                    int distX{circle[0] - x}, distY{circle[1] - y};\\n                    if(circle[2] * circle[2] < distX * distX + distY * distY)\\n                        continue;\\n                    ct++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        int minX{INT_MAX}, minY{INT_MAX}, maxX{}, maxY{}, ct{};\\n\\t\\t\\n\\t\\t// Find bounding box containing all circles\\n        for(const auto& circle : circles)\\n        {\\n            minX = std::min(minX, circle[0] - circle[2]);\\n            minY = std::min(minY, circle[1] - circle[2]);\\n            maxX = std::max(maxX, circle[0] + circle[2]);\\n            maxY = std::max(maxY, circle[1] + circle[2]);\\n        }\\n        \\n\\t\\t// Sweep through the bounding box containing all circles\\n        for(int x = minX; x <= maxX; x++)\\n        {\\n            for(int y = minY; y <= maxY; y++)\\n            {\\n                for(const auto& circle : circles)\\n                {\\n                    int distX{circle[0] - x}, distY{circle[1] - y};\\n                    if(circle[2] * circle[2] < distX * distX + distY * distY)\\n                        continue;\\n                    ct++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979252,
                "title": "python-fast-solution-using-sets-1400ms",
                "content": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        lattices = set()\\n        circles = set([tuple(c) for c in circles]) # remove duplicate circles\\n        for circle in circles:\\n            x,y,r = circle\\n            for X in range(x-r,x+r+1): # lattice x-coord range is [x-r,x+r]; check question image in ques description.\\n                for Y in range(y-r, y+r+1): # lattice y-coord range is [y-r,y+r]\\n                    if (X-x)**2 + (Y-y)**2 - r*r<=0: # check circle equation if points lies inside(<) or on(=) the circle.\\n                        lattices.add((X,Y))\\n        return len(lattices)\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        lattices = set()\\n        circles = set([tuple(c) for c in circles]) # remove duplicate circles\\n        for circle in circles:\\n            x,y,r = circle\\n            for X in range(x-r,x+r+1): # lattice x-coord range is [x-r,x+r]; check question image in ques description.\\n                for Y in range(y-r, y+r+1): # lattice y-coord range is [y-r,y+r]\\n                    if (X-x)**2 + (Y-y)**2 - r*r<=0: # check circle equation if points lies inside(<) or on(=) the circle.\\n                        lattices.add((X,Y))\\n        return len(lattices)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979127,
                "title": "java-generate-points-within-circumference",
                "content": "```\\nimport java.awt.*;\\nclass Solution {\\n    //Author: Anand\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Point> ans = new HashSet<>();\\n\\n        for (int[] c : circles) {\\n            int x = c[0];\\n            int y = c[1];\\n            int r = c[2];\\n            for (int i = x - r; i <= x + r; i++) {\\n                for (int j = y - r; j <= y + r; j++) {\\n                    // calculate distance and check if its within curcumference of circle\\n                    if ((x - i) * (x - i) + (y - j) * (y - j) <= r * r) {\\n                        ans.add(new Point(i, j));\\n                    }\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.awt.*;\\nclass Solution {\\n    //Author: Anand\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Point> ans = new HashSet<>();\\n\\n        for (int[] c : circles) {\\n            int x = c[0];\\n            int y = c[1];\\n            int r = c[2];\\n            for (int i = x - r; i <= x + r; i++) {\\n                for (int j = y - r; j <= y + r; j++) {\\n                    // calculate distance and check if its within curcumference of circle\\n                    if ((x - i) * (x - i) + (y - j) * (y - j) <= r * r) {\\n                        ans.add(new Point(i, j));\\n                    }\\n                }\\n            }\\n        }\\n        return ans.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979084,
                "title": "c-easy-code-to-undeustand",
                "content": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        set<pair<int,int>>st;\\n        for(auto it:circles)\\n        {\\n            int x=it[0];\\n            int y=it[1];\\n            int r=it[2];\\n            \\n            for(int i=x-r;i<=x+r;i++)\\n                for(int j=y-r;j<=y+r;j++)\\n                    if((i-x)*(i-x) + (j-y)*(j-y) <= r*r)\\n                        st.insert({i,j});\\n        }\\n        return st.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        \\n        set<pair<int,int>>st;\\n        for(auto it:circles)\\n        {\\n            int x=it[0];\\n            int y=it[1];\\n            int r=it[2];\\n            \\n            for(int i=x-r;i<=x+r;i++)\\n                for(int j=y-r;j<=y+r;j++)\\n                    if((i-x)*(i-x) + (j-y)*(j-y) <= r*r)\\n                        st.insert({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 1979081,
                "title": "java-using-set-pair-or-string-with-comments",
                "content": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Pair<Integer, Integer>> res = new HashSet<>(); //We need a set to avoid the duplicate\\n        for (int i = 0; i < circles.length; i++){\\n            int cx = circles[i][0]; //x of the center of the circle\\n            int cy = circles[i][1]; //y of the center of the circle\\n            int r = circles[i][2]; // radius of the circle\\n            int xl = cx - r, xh = cx + r; //low and high boundaries for x\\n            int yl = cy - r, yh = cy + r; //low and high boundaries for y\\n            \\n            for (int j = xl; j <= xh; j++){\\n                for (int k = yl; k <= yh; k++){\\n                    int xd = Math.abs(cx - j); //x distance from the center\\n                    int yd = Math.abs(cy - k); //y distance from the center\\n                    \\n                    //if it is on or inside of the circle, add to the set\\n                    if (xd * xd + yd * yd <= r * r){\\n                        \\n                        //if we use, new int[j,k], it won\\'t work because it creates a new object, so we use pair. Alternatively we can use String like \\'j_k\\' so that the set doesn\\'t add any duplicate\\n                        Pair<Integer, Integer> pair = new Pair<>(j,k);\\n                        res.add(pair);\\n                    }\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int countLatticePoints(int[][] circles) {\\n        Set<Pair<Integer, Integer>> res = new HashSet<>(); //We need a set to avoid the duplicate\\n        for (int i = 0; i < circles.length; i++){\\n            int cx = circles[i][0]; //x of the center of the circle\\n            int cy = circles[i][1]; //y of the center of the circle\\n            int r = circles[i][2]; // radius of the circle\\n            int xl = cx - r, xh = cx + r; //low and high boundaries for x\\n            int yl = cy - r, yh = cy + r; //low and high boundaries for y\\n            \\n            for (int j = xl; j <= xh; j++){\\n                for (int k = yl; k <= yh; k++){\\n                    int xd = Math.abs(cx - j); //x distance from the center\\n                    int yd = Math.abs(cy - k); //y distance from the center\\n                    \\n                    //if it is on or inside of the circle, add to the set\\n                    if (xd * xd + yd * yd <= r * r){\\n                        \\n                        //if we use, new int[j,k], it won\\'t work because it creates a new object, so we use pair. Alternatively we can use String like \\'j_k\\' so that the set doesn\\'t add any duplicate\\n                        Pair<Integer, Integer> pair = new Pair<>(j,k);\\n                        res.add(pair);\\n                    }\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978987,
                "title": "c-code-using-hashmap-faster-than-100",
                "content": "This code utilizes the restrictions that the center coordinates and the radius of each circle are less than 100. \\n```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_map<int,bool> mp;\\n        for (int i=0;i<circles.size();i++)\\n        {\\n            int a=circles[i][0],b=circles[i][1],r=circles[i][2];\\n            for (int k=-r;k<=r;k++)\\n                for (int j=-r;j<=r;j++)\\n                    if ( j*j+k*k<=r*r && mp.find(1000*(k+a)+j+b)==mp.end())\\n                        mp.insert({1000*(k+a)+j+b,true});\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLatticePoints(vector<vector<int>>& circles) {\\n        unordered_map<int,bool> mp;\\n        for (int i=0;i<circles.size();i++)\\n        {\\n            int a=circles[i][0],b=circles[i][1],r=circles[i][2];\\n            for (int k=-r;k<=r;k++)\\n                for (int j=-r;j<=r;j++)\\n                    if ( j*j+k*k<=r*r && mp.find(1000*(k+a)+j+b)==mp.end())\\n                        mp.insert({1000*(k+a)+j+b,true});\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978914,
                "title": "distance-formula-python",
                "content": "Equation for Circle:\\nx^2 + y^2 = r^2 #When Circle is from origin as center\\n if (x1,y1) is the center\\n (x-x1)^2 + (y-y1)^2 = r^2\\n \\n x can be in range [x1-r,x1+r]\\n y can be in range [y1-r,y1+r]\\n \\n There is no possibility of all numbers on or inside circle.\\n So check for points which have distance from center less than radius of the circle.\\n \\n Here is the code snippet,\\n Please let me know further optimizations that can be done. Would love to hear.\\n\\n```class Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        for i in circles:\\n            for x in range(i[0]-i[2],i[0]+i[2]+1):\\n                for y in range(i[1]-i[2],i[1]+i[2]+1):\\n                    if((x-i[0])**2+(y-i[1])**2)<=i[2]**2:\\n                        s.add((x,y))\\n                    else:\\n                        pass\\n        return len(s)```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def countLatticePoints(self, circles: List[List[int]]) -> int:\\n        s=set()\\n        for i in circles:\\n            for x in range(i[0]-i[2],i[0]+i[2]+1):\\n                for y in range(i[1]-i[2],i[1]+i[2]+1):\\n                    if((x-i[0])**2+(y-i[1])**2)<=i[2]**2:\\n                        s.add((x,y))\\n                    else:\\n                        pass\\n        return len(s)```",
                "codeTag": "Java"
            },
            {
                "id": 1978908,
                "title": "scala-solution",
                "content": "```\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    import scala.collection.mutable\\n    def getBounds(x: Int, y: Int, r: Int): Seq[(Int, Int)] = {\\n      for {\\n        i <- (x - r to x + r)\\n        j <- (y - r to y + r) if ((i - x) * (i - x)) + ((j - y) * (j - y)) <= r * r\\n      } yield (i, j)\\n    }\\n\\n    circles.foldLeft(mutable.HashSet.empty[(Int, Int)]){\\n      case (hash, Array(x, y, r)) => hash.addAll(getBounds(x, y, r))\\n    }.size\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def countLatticePoints(circles: Array[Array[Int]]): Int = {\\n    import scala.collection.mutable\\n    def getBounds(x: Int, y: Int, r: Int): Seq[(Int, Int)] = {\\n      for {\\n        i <- (x - r to x + r)\\n        j <- (y - r to y + r) if ((i - x) * (i - x)) + ((j - y) * (j - y)) <= r * r\\n      } yield (i, j)\\n    }\\n\\n    circles.foldLeft(mutable.HashSet.empty[(Int, Int)]){\\n      case (hash, Array(x, y, r)) => hash.addAll(getBounds(x, y, r))\\n    }.size\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1978790,
                "title": "c-only-find-points-for-one-quadrant-of-circle-easy-to-understand",
                "content": "```\\nvoid addCoords(set<pair<int,int>> &s, int x, int y, int x1, int y1){\\n\\ts.insert({x+x1,y+y1});\\n\\ts.insert({x-x1,y-y1});\\n\\ts.insert({x-x1,y+y1});\\n\\ts.insert({x+x1,y-y1});\\n}\\n\\nint countLatticePoints(vector<vector<int>>& circles) {\\n\\tset<pair<int,int>> s;\\n\\n\\tint n = circles.size();\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tint x = circles[i][0], y = circles[i][1], r = circles[i][2];\\n\\n\\t\\tfor(int x1=0;x1<=r;x1++){\\n\\t\\t\\tfor(int y1=0;y1<=r;y1++){\\n\\t\\t\\t\\tif(((x1*x1)+(y1*y1))<=(r*r))\\n\\t\\t\\t\\t\\taddCoords(s,x,y,x1,y1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn s.size();\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nvoid addCoords(set<pair<int,int>> &s, int x, int y, int x1, int y1){\\n\\ts.insert({x+x1,y+y1});\\n\\ts.insert({x-x1,y-y1});\\n\\ts.insert({x-x1,y+y1});\\n\\ts.insert({x+x1,y-y1});\\n}\\n\\nint countLatticePoints(vector<vector<int>>& circles) {\\n\\tset<pair<int,int>> s;\\n\\n\\tint n = circles.size();\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tint x = circles[i][0], y = circles[i][1], r = circles[i][2];\\n\\n\\t\\tfor(int x1=0;x1<=r;x1++){\\n\\t\\t\\tfor(int y1=0;y1<=r;y1++){\\n\\t\\t\\t\\tif(((x1*x1)+(y1*y1))<=(r*r))\\n\\t\\t\\t\\t\\taddCoords(s,x,y,x1,y1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978730,
                "title": "python-simulation-beat-100",
                "content": "\\tfrom math import sqrt\\n\\n\\tclass Solution:\\n\\t\\tdef countLatticePoints(self, circles: List[List[int]]) -> int:\\n\\n\\t\\t\\tpt_set=set()\\n\\t\\t\\tfor circle in circles:\\n\\t\\t\\t\\tx = circle[0]\\n\\t\\t\\t\\ty = circle[1]\\n\\t\\t\\t\\tr = circle[2]\\n\\n\\t\\t\\t\\tmin_x =   x - r\\n\\t\\t\\t\\tmax_x =   x + r\\n\\n\\t\\t\\t\\tfor _x in range(min_x,max_x+1):\\n\\t\\t\\t\\t\\t_y = int(sqrt(r**2-(x-_x)**2))\\n\\t\\t\\t\\t\\tfor y_ in range(_y+1):\\n\\t\\t\\t\\t\\t\\tpt_set.add((_x,y+y_))\\n\\t\\t\\t\\t\\t\\tpt_set.add((_x,y-y_))\\n\\n\\n\\n\\t\\t\\treturn len(list(pt_set))\\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tfrom math import sqrt\\n\\n\\tclass Solution:\\n\\t\\tdef countLatticePoints(self, circles: List[List[int]]) -> int:\\n\\n\\t\\t\\tpt_set=set()\\n\\t\\t\\tfor circle in circles:\\n\\t\\t\\t\\tx = circle[0]\\n\\t\\t\\t\\ty = circle[1]\\n\\t\\t\\t\\tr = circle[2]\\n\\n\\t\\t\\t\\tmin_x =   x - r\\n\\t\\t\\t\\tmax_x =   x + r\\n\\n\\t\\t\\t\\tfor _x in range(min_x,max_x+1):\\n\\t\\t\\t\\t\\t_y = int(sqrt(r**2-(x-_x)**2))\\n\\t\\t\\t\\t\\tfor y_ in range(_y+1):\\n\\t\\t\\t\\t\\t\\tpt_set.add((_x,y+y_))\\n\\t\\t\\t\\t\\t\\tpt_set.add((_x,y-y_))\\n\\n\\n\\n\\t\\t\\treturn len(list(pt_set))\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1978671,
                "title": "use-a-dictionary-in-python-faster-than-100",
                "content": "There\\'s so much time difference between using a list to check if the point is repeated to using a dictionary. Spent nearly 4 hours and just changed points=[] to points={} and boom it got accepted.\\nLesson- Always use a dictionary whenever searching is involved.\\n\\n```\\n\\nimport math\\nclass Solution:\\n    def countLatticePoints(self, circles) :\\n\\n        point = {}\\n\\n        for c in circles:\\n\\n            xc = c[0]\\n            yc = c[1]\\n            r = c[2]\\n            xmin = xc - r\\n            xmax = xc + r\\n            ymin = yc - r\\n            ymax = yc + r\\n\\n            for x in range(xmin, xmax + 1):\\n                for y in range(ymin, ymax + 1):\\n\\n                    t = (x, y)\\n                    if t in point:\\n                        continue\\n                    if ((x==xmax or x==xmin)and(y==ymax or y==ymin)):\\n                            continue\\n                    else:\\n                            dist = math.sqrt((x - xc) ** 2 + (y - yc) ** 2)\\n                            if dist <= r:\\n                                point[t]=1\\n\\n\\n        return len((point))\\n\\n\\ns=Solution()\\nprint(s.countLatticePoints([[2,2,2],[3,4,1]]))\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6b2fba46-2e40-4ea8-bf4e-8bd5c82c10bf_1650809287.3620253.png)\\n",
                "solutionTags": [],
                "code": "```\\n\\nimport math\\nclass Solution:\\n    def countLatticePoints(self, circles) :\\n\\n        point = {}\\n\\n        for c in circles:\\n\\n            xc = c[0]\\n            yc = c[1]\\n            r = c[2]\\n            xmin = xc - r\\n            xmax = xc + r\\n            ymin = yc - r\\n            ymax = yc + r\\n\\n            for x in range(xmin, xmax + 1):\\n                for y in range(ymin, ymax + 1):\\n\\n                    t = (x, y)\\n                    if t in point:\\n                        continue\\n                    if ((x==xmax or x==xmin)and(y==ymax or y==ymin)):\\n                            continue\\n                    else:\\n                            dist = math.sqrt((x - xc) ** 2 + (y - yc) ** 2)\\n                            if dist <= r:\\n                                point[t]=1\\n\\n\\n        return len((point))\\n\\n\\ns=Solution()\\nprint(s.countLatticePoints([[2,2,2],[3,4,1]]))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1820000,
                "content": [
                    {
                        "username": "Charles1791",
                        "content": "In this question, hash set runs slower than a tree set, interesting! Too much hash collision? \\n\\nFor c++ coder: use set<pair<int,int>> instead of unordered_set<pair<int,int>>, or you\\'d get TLE for the last test case"
                    },
                    {
                        "username": "Shohan07",
                        "content": "Circle Equations  https://www.mathopenref.com/coordgeneralcircle.html"
                    }
                ]
            },
            {
                "id": 1576704,
                "content": [
                    {
                        "username": "Charles1791",
                        "content": "In this question, hash set runs slower than a tree set, interesting! Too much hash collision? \\n\\nFor c++ coder: use set<pair<int,int>> instead of unordered_set<pair<int,int>>, or you\\'d get TLE for the last test case"
                    },
                    {
                        "username": "Shohan07",
                        "content": "Circle Equations  https://www.mathopenref.com/coordgeneralcircle.html"
                    }
                ]
            }
        ]
    }
]