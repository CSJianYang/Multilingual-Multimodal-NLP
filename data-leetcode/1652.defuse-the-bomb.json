[
    {
        "title": "Defuse the Bomb",
        "question_content": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code&nbsp;of length of n&nbsp;and a key k.\nTo decrypt the code, you must replace every number. All the numbers are replaced simultaneously.\n\n\tIf k > 0, replace the ith number with the sum of the next k numbers.\n\tIf k < 0, replace the ith number with the sum of the previous k numbers.\n\tIf k == 0, replace the ith number with 0.\n\nAs code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].\nGiven the circular array code and an integer key k, return the decrypted code to defuse the bomb!\n&nbsp;\nExample 1:\n\nInput: code = [5,7,1,4], k = 3\nOutput: [12,10,16,13]\nExplanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.\n\nExample 2:\n\nInput: code = [1,2,3,4], k = 0\nOutput: [0,0,0,0]\nExplanation: When k is zero, the numbers are replaced by 0. \n\nExample 3:\n\nInput: code = [2,4,9,3], k = -2\nOutput: [12,5,6,13]\nExplanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.\n\n&nbsp;\nConstraints:\n\n\tn == code.length\n\t1 <= n&nbsp;<= 100\n\t1 <= code[i] <= 100\n\t-(n - 1) <= k <= n - 1",
        "solutions": [
            {
                "id": 935398,
                "title": "java-o-n-100-time-and-space-short-concise-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948726,
                "title": "c-sliding-window-linear-time-and-constant-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935444,
                "title": "clean-python-3-prefix-sum-o-n",
                "content": "Use the prefix sum trick to get range sum in O(1)\\nTime: `O(N)`\\nSpace: `O(N)`\\nThanks @WangQiuc\\'s suggestion.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\\n\\nOne pass\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936749,
                "title": "pyhton3-beats-100-double-the-code-array",
                "content": "Double the ```code``` array so that it\\'s easy to iterate.\\n```class Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k==0: return [0 for i in code]\\n        temp = code\\n        code = code*2\\n        for i in range(len(temp)):\\n            if k>0:\\n                temp[i] = sum(code[i+1:i+k+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        return temp",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```code```",
                "codeTag": "Unknown"
            },
            {
                "id": 935478,
                "title": "python-3-clean-sliding-window",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```\\n\\n- for negative k: reverse params and result\\n- calculate sum of k element, then iteratively add new element and remove oldest one.\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935457,
                "title": "my-short-easy-to-understand-solution",
                "content": "To deal with this kind of problem, we need to play with the index wisely and carefully, just like defusing a bomb (lol). There are 3 points we need to notice:\\n\\n0. We need to return the result directly if k == 0 based on the problem statement. (I will handle this case specifically, to make it more readable and slightly faster :) )\\n1. We need to do ***%*** to make sure the index is always in-bound when k > 0;\\n2. We need to do ***+code.length*** to make sure it is alway > 0, and ***%*** to make sure the index is always in-bound when k < 0.\\n\\nHere is my code: \\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```\\n\\nPlease upvote if you find this is helpful! :)",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942580,
                "title": "c-easy-solution-brute-force",
                "content": "if you don\\'t know how this code works,you could comment below.\\nI will try my best to answer your question! :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218554,
                "title": "very-easy-solution-explained-with-sample-implementation-break-the-cycle-prefix-suffix-sum",
                "content": "*------Please **upvote** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\n**Prerequisites -** *Prefix Sum* and *Suffix Sum* of an Array.\\n\\nFirst, we **simplify** the problem by **breaking the cycle.** \\n\\n*****How?*****  Just append the array to itself and the cycle will be broken into a linear array.\\n\\nTake the sample input array **code** as: **[5, 7, 1, 4]**\\nAppending it to itself, we get our new array **arr** as: **[5, 7, 1, 4, 5, 7, 1, 4]**.  We will now use this array for calculation.\\n\\n1. If **k = 0**: Just change all array elements of **code** to **0** and return **code**.\\n\\n2. If **k > 0**:  We calculate the **prefix** sum array **pre** of **arr** and our result for every index **i** would be **pre [i + k] - pre [i]**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**pre:** `[5, 12, 13, 17, 22, 29, 30, 34]`\\n\\n**k = 2**\\n\\nNow, for every index **i**: **code [i]** will become **pre [i + 2] - pre [i]**.\\n\\n**i = 0**: `code [0]` = `pre [0 + 2] - pre [0]` = `pre [2] - pre [0]` = **8**\\n**i = 1**: `code [1]` = `pre [1 + 2] - pre [1]` = `pre [3] - pre [1]` = **5**\\n**i = 2**: `code [2]` = `pre [2 + 2] - pre [2]` = `pre [4] - pre [2]` = **9**\\n**i = 3**: `code [3]` = `pre [3 + 2] - pre [3]` = `pre [5] - pre [3]` = **12**\\n\\nReturn **code** as **`[8, 5, 9, 12]`**\\n\\n3. If **k < 0**:  We calculate the **suffix** sum array **suf** of **arr** and our result for every index **i** would be **suf [i + n - k] - suf [i + n]** where **`n = length (code)`**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**suf:** `[34, 29, 22, 21, 17, 12, 5, 4]`\\n\\n**k = -2**\\n\\nHere, we will proceed in the reverse order (right - to - left) because the suffix sum is calculated from the right - to - left direction.\\n\\nNow, for every index **i**: **code [i]** will become **suf [i + 4 - 2] - suf [i + 4]**.\\n\\n**i = 3**: `code [3]` = `suf [3 + 4 - 2] - suf [3 + 4]` = `suf [5] - suf [7]` = **8**\\n**i = 2**: `code [2]` = `suf [2 + 4 - 2] - suf [2 + 4]` = `suf [4] - suf [6]` = **12**\\n**i = 1**: `code [1]` = `suf [1 + 4 - 2] - suf [1 + 4]` = `suf [3] - suf [5]` = **9**\\n**i = 0**: `code [0]` = `suf [0 + 4 - 2] - suf [0 + 4]` = `suf [2] - suf [4]` = **5**\\n\\nReturn **code** as **`[5, 9, 12, 8]`**\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```\\n\\nPlease **upvote!** if you like the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947553,
                "title": "java-o-n-using-prefix-sum-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285276,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153936,
                "title": "simple-and-easy",
                "content": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008102,
                "title": "go-o-n-0ms-2-3mb-sliding-window-with-wrapping-indexes",
                "content": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942554,
                "title": "java-o-n-clear-explanation-beats-100",
                "content": "The idea is that for each index i, we will need to be able to query the sum of the next or prev k numbers - an easy way to achieve this is to cache the prefix sums.\\n\\nHowever, there is the added complexity of circular array so we can simply create a prefix sum array that is twice the normal length. Essentially caching the prefix sums of the array repeated.\\n\\ni.e. For something like A = [1,2,3,4], we can concatentate it with itself to create B = [1,2,3,4,1,2,3,4] so that it is easier to work with when applying circular things. \\n\\nWhen working with A, if k = 3 and i = 1, then normally we would have an add indexes 2, 3 and 4. However, index 4 would in fact be index 0 since we are working with a circular array. With our concatenated array B, we would be able to directly access index 4.\\n\\nTaking this concept 1 step further, we can then prefix sum cache this concatenated version which gives us a prefix sum cache that can find circular ranges. So if k < 0, we can find the range sum of [i-k, i-1] and if k > 0, we can find the range sum of [i+1, i+k].\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352139,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 971143,
                "title": "javascript-simple",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367476,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482725,
                "title": "defuse-the-bomb",
                "content": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1903674,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384496,
                "title": "c-solution-simple-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152661,
                "title": "python-3-o-n-sliding-window-with-array-rotation",
                "content": "# Intuition\\nOn close inspection we find that K<0 case solution is just a rotated form of K>0 solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReturn 0 array for k==0 case and for other case find the next k sum array by sliding window technique and in case the k value is negative then rotate the ans list by k-1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933571,
                "title": "java-sliding-window-explained",
                "content": "**Idea:** Use a sliding window to maintain sum\\n>**T/S:** O(n)/O(1), where n = size(code), (ignoring space for output)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819345,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599513,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }\\n            j--;\\n        }else{\\n            while(++k<=0){\\n                sum+=code[j--]; \\n            }\\n            j++;\\n            int temp=j;\\n            j=i;\\n            i=temp;\\n        }\\n        \\n        for(int p=0;p<code.length;p++){\\n            res[p]=sum;\\n          //  System.out.println(i+\" \"+j);\\n            j=(j+1)%code.length;\\n            sum=sum+(code[j]-code[i]);\\n            i=(i+1)%code.length;\\n        }\\n        return res;\\n    }\\n}\\nPlease upvote if you like the solution \\uD83D\\uDE4F",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2304860,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "**Here You Go =>**\\n\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256306,
                "title": "c-straightforward-modulo",
                "content": "![image](https://assets.leetcode.com/users/images/7d3784bc-ac6c-4d88-82be-bd82375afbbc_1657312778.1436577.png)\\n\\n**T->O(n * k) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfor(int j=i-1;count<abs(k);j--){\\n\\t\\t\\t\\t\\t\\tif(j==-1)j=n-1;\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2179759,
                "title": "c-100-fast-0ms-easy-to-understand",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1674760,
                "title": "java-1ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172514,
                "title": "python-beats-99-using-modulus",
                "content": "```\\n```\\nr=[]\\n        n=len(code)\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(n):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(n):\\n                e=i+k\\n                if e>0:\\n                    x=sum(code[e:i])\\n                else:\\n                    x=sum(code[:i])+sum(code[n+e:])\\n                r.append(x)\\n            return r\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114282,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010869,
                "title": "java-sum",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }\\n        }else if(k<0){\\n            k=-k;\\n            for(int i=0; i<len; i++){\\n                if(i-k>=0)\\n                    res[i] = sum[i]-sum[i-k];\\n                else\\n                    res[i] += sum[i]+sum[len]-sum[len-k+i];\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 941890,
                "title": "simple-5-line-python-faster-than-100-with-comments",
                "content": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 938895,
                "title": "javascript-sliding-window",
                "content": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936310,
                "title": "c-presum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935724,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935407,
                "title": "c-easy-solution-100-faster-100-less-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935382,
                "title": "py3-duplicate-the-array-to-simplify-things",
                "content": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "solutionTags": [],
                "code": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3912887,
                "title": "simple-list-slicing-and-loop-process-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674815,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636938,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436766,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106935,
                "title": "easy-js-solution-in-10-lines",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957477,
                "title": "runtime-55-ms-beats-100-memory-41-9-mb-beats-97-92",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/1fc69f57-672f-4bff-92c0-aa12825dcdb4_1672132892.8528547.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551093,
                "title": "java-brute-force-easy-to-understand",
                "content": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }\\n           return code;\\n       }\\n        else if(k>0){\\n            \\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i+1;\\n                if(i==code.length-1){\\n                    u=0;\\n                }\\n                for(int j=u;j<code.length;j++){\\n                    \\n                    sum+=code[j];\\n                    count++;\\n                    if(j==code.length-1){\\n                        j=-1;                       \\n                    }\\n                    if(count==k){\\n                        break;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i-1;\\n                if(i==0){\\n                    u=code.length-1;\\n                }\\n                for(int j=u;j>=0;j--){\\n                    sum+=code[j];\\n                    count++;\\n                    if(count==Math.abs(k)){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        j=code.length;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n        \\n       \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2431302,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323353,
                "title": "c-solution-with-12ms-runtime",
                "content": "Stats for this solution:\\nRuntime: 12 ms, faster than 5.85% of C++ online submissions for Defuse the Bomb.\\nMemory Usage: 8.2 MB, less than 73.28% of C++ online submissions for Defuse the Bomb.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306730,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2051862,
                "title": "c-logic-two-loops-o-n2",
                "content": "Hi there , this is the simple logic that came into my mind at first, with O(n2) complexity\\nwould update a new thread if there comes another logic with better one.\\n\\nCODE- \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThanks for coming this far!  we can do thiss ! happy coding",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033540,
                "title": "straight-forward-prefix-sum-solution",
                "content": "using a map to keep track of all prefix sum from 0 -> 2 * n - 1, since its a circular array.\\ntime: o(n), space: o(n)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992107,
                "title": "c-solution-t-o-nk-s-1",
                "content": "### C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985487,
                "title": "short-and-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967947,
                "title": "simple-javascript-solution-faster-than-70",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862972,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830648,
                "title": "python-solution-using-extra-memory",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818728,
                "title": "python-single-pass-no-reverse-no-if-s",
                "content": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1715964,
                "title": "easy-3-liner-python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640047,
                "title": "c-o-n-time-space-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623992,
                "title": "c-easy-to-understand-brute-force",
                "content": "**Brute force approach\\ntime complexity O(nxk)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603868,
                "title": "rust-fast-100",
                "content": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514918,
                "title": "c-0ms-o-n-k-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450462,
                "title": "easy-solution",
                "content": "just go with the flow \\ntwo things \\nto travel in counter clockwise direction:  **(n+j-1)%n**\\nto travel in clockwise direction:  **(n+i)%n**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333655,
                "title": "python-solution",
                "content": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "codeTag": "Java"
            },
            {
                "id": 1235556,
                "title": "python-two-lines-brute-force",
                "content": "Find the correct range based on the value of k, then sum the next/previous k values for each index using list comprehension.\\n\\n```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "solutionTags": [],
                "code": "```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1218451,
                "title": "100-python-array-concatenation-prefix-sum",
                "content": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218059,
                "title": "javascript-solution",
                "content": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207790,
                "title": "python-94",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175703,
                "title": "100-efficient-solution-c",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=k;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n\\n                ans.push_back(s);\\n                k++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n        }\\n        else if(k < 0){\\n            t=abs(k);\\n            reverse(code.begin(),code.end());\\n            cout<<code.size();\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(t==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=t;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n                ans.push_back(s);\\n                t++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n            reverse(ans.begin(),ans.end());\\n        }\\n        else if(k==0){\\n             for(int i=1;i<=code.size()/2;i++){\\n                 ans.push_back(0);\\n             }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1173463,
                "title": "rust-simple-solution",
                "content": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172511,
                "title": "using-modulus",
                "content": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114740,
                "title": "c-stupidly-concise",
                "content": "Sliding window. \\n\\n`i` is left, `j` is right, `n` is the sum of the current window. Keep moving `j` to the right, adding in whatever value we hit to our sum. \\n\\nIf the total window size hits the limit, pull up the left hand side of the window and drop the value at that index from our sum. Then set this sum into the correct index - just before the start of the window if `k` is positive, and just after the end of the window if `k` is negative.\\n```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094993,
                "title": "python-solution-array-prefix-sum",
                "content": "Array Prefix sum approach.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080903,
                "title": "c-concise-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069062,
                "title": "java-100",
                "content": "1. Calculation and its sequence are same for both directions.\\n2. If k is negative, rotate the result and return\\n```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054478,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051935,
                "title": "0ms-simple-c-solution",
                "content": "\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036396,
                "title": "simple-c-with-circle-arr-comment-100-faster-85-better-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029160,
                "title": "simple-c-solution-100-faster",
                "content": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "solutionTags": [],
                "code": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1029000,
                "title": "c-optimized-code-faster-than-90",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }\\n        int check;\\n        if(k>0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n               int sum=0;\\n               check=k;\\n               j=i+1;\\n               while(check--)\\n               {\\n                    j=j%n;\\n                   sum+=code[j];\\n                   j++;\\n                   \\n                   \\n               }\\n                v[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(i=n-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                check=-k;\\n                j=i-1;\\n                if(j==-1)\\n                {\\n                    j=n-1;\\n                }\\n                while(check--)\\n                {\\n                    if(j==-1)\\n                    {\\n                        j=n-1;\\n                    }\\n                    sum+=code[j];\\n                    j--;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n       \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1003515,
                "title": "python3-easy-solution-with-list-index-manipulation",
                "content": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "codeTag": "Python3"
            },
            {
                "id": 992601,
                "title": "java-brute-force-solution-beats-47-08",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984880,
                "title": "rust-o-n",
                "content": "Working through those type conversions, a prev sol helped. :) \\n\\n\\n```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967756,
                "title": "simple-python-solution",
                "content": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "solutionTags": [],
                "code": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "codeTag": "Unknown"
            },
            {
                "id": 963902,
                "title": "go-solution-0ms-2-5mb",
                "content": "The idea is to form a temp slice that mimic the feature of circular array. It\\'ll be easy to locate the target elements, but with cost of higher memory usage.\\neg: \\nInput: code = [5,7,1,4] , k = -2\\ntemp would become  [5,7,1,4,**5,7,1,4**,5,7,1,4]\\n\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959724,
                "title": "c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950114,
                "title": "java-solution-brute-force",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943955,
                "title": "python-3-without-modulo-94-time",
                "content": "Quite a lengthy code but it does the job.\\n\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938270,
                "title": "more-understandable",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937967,
                "title": "c-o-n-time-o-1-additional-space",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936993,
                "title": "java-10-liner-o-n",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936660,
                "title": "java-0ms-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936226,
                "title": "defuse-the-bomb",
                "content": "c++  solution \\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935446,
                "title": "javascript-o-n-k-time-complexity",
                "content": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935431,
                "title": "easy-to-understand-o-nk-soln",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935393,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935391,
                "title": "java-simple-o-nk-and-sliding-window-o-n-time-solutions",
                "content": "`O(NK)` time solutions:\\nJust do what is asked in the question\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\n`O(N)` time solution\\nCompute sum for the first element. Continue computing sum for others maintaining sliding window\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935388,
                "title": "java-0-ms-faster-than-100-00-39-4-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935385,
                "title": "brute-force-java",
                "content": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935371,
                "title": "kt-js-py3-cpp-one-step-at-a-time",
                "content": "**Synopsis:**\\n\\nGenerate the answer `ans` one step at a time by accumulating the total sum of the `K` values adjacent to-the-right of each `i`<sup>th</sup> element of the input array `A`.  To simplify the code when `K` is negative, simply reverse `A` and return the reversed answer using positive `K`.\\n\\n---\\n\\n**Bi-Weekly Contest 39 Screenshare:**\\n\\n![image](https://assets.leetcode.com/users/images/2c2f0b1a-650d-43dc-bb60-fbd2340d74c1_1605370887.2933993.png)\\n\\nhttps://www.youtube.com/watch?v=tOBm0jYytpc\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090277,
                "title": "loop-solution-time-complexity-o-n-k",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe inner loop iterates from 1 to the absolute value of k (inclusive). The purpose of this loop is to perform a certain number of shifts on the code list elements.\\n\\nInside this nested loop, there\\'s a conditional statement that checks whether k is greater than 0. If it is, it calculates the new value of newNum by adding the code element at the index (i+j)%n to newNum. If k is less than 0, it calculates newNum by adding the code element at the index (i-j)%n to newNum.\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088740,
                "title": "easy-to-understand-java-solution-takes-only-1ms-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078307,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072718,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4064331,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060974,
                "title": "2ms-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055984,
                "title": "simpler-as-much-for-beginner-beatz-100",
                "content": "## Complexity\\n####  Time complexity: O(n^2) \\n#### Space complexity: O(n) \\n\\n## Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038589,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034311,
                "title": "beats-100-with-0ms-optimal-solution-with-explanation-tc-o-n-sc-o-n",
                "content": "# Intuition\\nk is basically a window of elements and we see this window moving across as we move ahead to populate our indices in the new array.\\n\\n# Approach\\nWe break down the problem into 3 parts. k==0 is straight forward. Our window slides for K>0 and K<0. the movement of the window is same, its just the starting and ending indices we have to identify for the different tow different cases of k. Once we do that we just create a for loop where we slide our window.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) and I believe it can\\'t be lower than that as we are supposed to return an array and we should always create a new one rather than modifying our input unless asked to.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033458,
                "title": "one-line-solution-using-a-cyclic-iterator",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\\n> More readable\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020155,
                "title": "beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968965,
                "title": "c-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964778,
                "title": "sliding-window-reverse",
                "content": "# Intuition\\nWe can use sliding window for k > 0, for k < 0 we can reverse input and calculated outout.\\n\\n# Approach\\nFor k > 0, we can start by calculating first value with index 0, and sum from 1 to k.\\nNext we need to update n numbers, on each step we remove i + 1, element from the sum and add, k + i + 1 element to it. Use % of n to ensure data is read from ring buffer.\\nFor case when k < 0 we need to reverse input and output.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948273,
                "title": "cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942997,
                "title": "java-straightforward-t-s-o-m-runtime-78-80-1-ms-memory-93-29-41-1-mb",
                "content": "# Intuition & Approach\\nThis `decrypt` method that takes an integer array `code` and an integer `k` as input, and it returns an integer array `decrypt` as output. The purpose of this method is to \"decrypt\" the input array `code` using the given value of `k`. \\n\\n**Let\\'s break down the code step by step:**\\n\\n```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n````\\nHere, the method starts by defining a few variables:\\n\\n- `M` represents the length of the input array `code`.\\n\\n- An integer array `decrypt` is created with the same length as `code` to store the decrypted values.\\n\\n- The `if` condition checks if `k` is equal to `0`. If `k` is indeed `0`, then the decrypt array is returned as is (in accordance with the instructions), and the method terminates.\\n\\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\\nIf `k` is not `0`, the method proceeds to this loop. This loop iterates through each index `i` of the `code` array. Here\\'s what happens in each iteration:\\n\\n- A variable `sgn` is set to either `-1` or `1` based on whether `k` is *negative* or *positive*. This is used to control the direction of decryption.\\n\\n- A variable `e` is set to the absolute value of `k`. This determines how many *steps of decryption will be performed*.\\n\\n- An integer variable `v` is initialized to `0`. This variable will accumulate the decrypted value for the current index `i`.\\n\\n- A variable `adj` is set to `M + i` if `k` is negative, or simply `i` if `k` is positive. This `adj` value is used to adjust the index when accessing elements from the `code` array.\\n\\n- An inner loop runs `e` times. In each iteration of the inner loop, it adds the value at the adjusted index `(adj + sgn * j) % M` to the variable `v`.\\n\\n- After the inner loop completes, the decrypted value for the current index `i` is stored in the `decrypt` array.\\n\\nFinally, the decrypted array `decrypt` is returned after the loop has processed all indices of the `code` array.\\n\\nIn summary, `decrypt` method decrypts the input code array by performing a series of circular shifts based on the value of `k`, and the result is stored in the `decrypt` array.\\n\\n\\n# Complexity\\n- Time complexity: $$T(M * e) = O(M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n```\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914589,
                "title": "c-beginner-friendly-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885410,
                "title": "runtime-54ms-memory-43-10-mb-easy-for-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874629,
                "title": "simple-c-solution",
                "content": "# Intuition\\nGenerate the array just the way it is described in the problem description.\\n\\n# Approach\\nCreate an array of the same size, as all operations are done simultaneously, which means we should not edit the original array.\\n\\nFor every index in the array, we sum all the values that we need. \\n\\nsteps: the amount of steps we make. We have to make a total of abs(k) steps.\\nindex: The index of the value we add to sum. We have code to wrap it around if it goes beyond the array bounds.\\nsum: Sum of the values.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868122,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861654,
                "title": "by-07chorno-c-o-ms-beats-1oo-the-best-answer-click-now-to-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838391,
                "title": "1652-defuse-the-bomb",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817286,
                "title": "my-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814537,
                "title": "using-fixed-size-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810699,
                "title": "easy-sliding-window-solution-beats-100",
                "content": "\\n# Approach\\nI think this is minor variation of fixed sliding window. \\n1. Here window is fixed however windowstart and windowEnd isn\\'t starting with 0.\\n2. Main idea is how to initialise windowStart i.e. l and windoEnd i.e r. If  k> 0 then l=1 and r=1. Else for negative k -> l,r= code.length + k i.e. if k=-2 and n=4 then l,r = 2\\n3. Like most of sliding window solutions, we will iterate for Math.abs(k) to calculate sum of window. And doing that, we will increment r. We make sure that r is reinitiaze to 0 when it reaches end of array.\\n4. Once we have the window sum, then it is easy sliding window with maintaining boundry condition for both l and r;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809538,
                "title": "defuse-the-bomb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797556,
                "title": "c-sliding-window-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nto work on the circular array .We just need to think of modulo everytime we want to acess the next\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781729,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3763431,
                "title": "easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732757,
                "title": "solution-1652-defuse-the-bomb",
                "content": "# Intuition\\nThe code aims to decrypt an array of integers using a given key. It iterates through each element in the input array and calls the helperSum function to calculate the decrypted value. The helperSum function calculates the sum of elements based on the given key and the starting index.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732315,
                "title": "easy-ts-solution",
                "content": "# Code\\n```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726835,
                "title": "basic-and-explained-c-solution-easy-to-understand-array-basics-beginner-friendly",
                "content": "# Intuition\\nSure! Let me explain the code in first person and discuss its complexity.\\n\\nIn this code, I see a class named `Solution` with a member function `decrypt`. This function takes a reference to a vector of integers `code` and an integer `k` as input. It aims to decrypt the given code using a specific algorithm.\\n\\n\\n# Approach\\nNow, let\\'s go through the code step by step:\\n\\n1. The code starts with an `if` condition that checks if `k` is equal to 0. If this condition is true, it means there is no encryption to decrypt, so the function creates a new vector `ans` with the same size as `code` and fills it with 0s. This is done to return a vector of zeros as the decryption result.\\n\\n2. If `k` is not equal to 0, the code proceeds to the main decryption logic. It initializes an empty vector `ans` to store the decryption results.\\n\\n3. The code then enters a `for` loop that iterates over the elements of the `code` vector. Inside this loop:\\n   - It initializes `sum` and `count` variables to 0, which will be used to calculate the sum of elements and keep track of the number of elements considered.\\n   - It checks if `k` is greater than 0. If `k` is positive, it means we need to decrypt the code in the forward direction.\\n     - If the current index `i` is the last index of `code`, a nested `for` loop is used to iterate from the first element to the `k`th element of `code`. It calculates the sum of these elements and increments the `count` variable.\\n     - If the current index `i` is not the last index, another nested `for` loop is used to iterate from the next index to `k` elements ahead, wrapping around to the beginning if necessary. Again, it calculates the sum of these elements and increments the `count` variable.\\n   - If `k` is less than or equal to 0, it means we need to decrypt the code in the backward direction. The logic is similar to the forward direction, but it iterates in reverse order and wraps around from the last index to the beginning if necessary.\\n   - Finally, the calculated `sum` is added to the `ans` vector.\\n\\n4. After the loop finishes, the function returns the `ans` vector containing the decrypted code.\\n\\n- # Complexity\\n- Time complexity : The code uses two nested loops, each iterating over the elements of the `code` vector. Therefore, the time complexity is O(n^2), where n is the size of the vector.\\n- - Space complexity : The space complexity is O(n) as it uses additional space to store the decrypted code in the `ans` vector, which has the same size as `code`.\\n\\n![star-wars-bb8.gif](https://assets.leetcode.com/users/images/34d33a9f-faca-4c62-9e31-54d0b6ef0d2b_1688640507.0608313.gif)\\n\\n![upvote-raccoon.gif](https://assets.leetcode.com/users/images/e6ce0476-7e4e-47de-b6ba-05c64c207f7e_1688640515.7785654.gif)\\n\\n#Please do Upvote if you find the solution good\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701654,
                "title": "basic-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692467,
                "title": "day-30",
                "content": "# Complexity\\n- Time complexity:\\n-       O(n * abs(k)), \\n        where n is the length of the code list. This is because for\\n        each element in code, we perform a loop of length abs(k)\\n        to calculate the sum.\\n- Space complexity:\\n-       O(n) \\n        because we create a new list result of size n\\n        to store the decrypted code.\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689987,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681291,
                "title": "sliding-window-solution-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3680405,
                "title": "harshi-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673326,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665514,
                "title": "naive-method-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653280,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645630,
                "title": "go-solution-bomb-decode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641800,
                "title": "java-easy-beginner-friendly-solution-80-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629016,
                "title": "defuse-the-bomb-js-intuitive-solution",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616240,
                "title": "c-100-faster-circular-sliding-window-with-explanation",
                "content": "# Intuition\\nThe problem clearly deals with an array and sub-array with a window size of k.\\n# Approach\\n3 cases:\\n 1. k==0 return res(output array) as it is with all 0s\\n 2. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. \\nElement to be updated given by i-1\\n 3. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. Element to be updated given by (j+1)%array.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1) - excluding the output array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578348,
                "title": "100-time-beat-memory-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576292,
                "title": "lets-defuse-it-yeahhhhhhhhhhhhhh",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to replace each element in the given code array with the sum of the k elements that come after it (if k > 0) or before it (if k < 0), considering the array wraps around. The intuition is to iterate through the code array and calculate the replacement value based on the specified rules.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution iterates through the code array, calling the ReplaceNum function for each element. In ReplaceNum, the replacement value is calculated by iterating k times in the specified direction (forward or backward), summing up the values encountered. The index is adjusted using the modulo operator for wrapping around the array.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3574874,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570432,
                "title": "java-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562620,
                "title": "beginner-friendly-solution-to-the-problem-2ms-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559879,
                "title": "python-beat-93",
                "content": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559649,
                "title": "solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556345,
                "title": "defuse-the-bomb-java-easy",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556131,
                "title": "simple-and-easy-approch",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552363,
                "title": "java-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1743482,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 2043876,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1913659,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1734530,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            }
        ]
    }
]