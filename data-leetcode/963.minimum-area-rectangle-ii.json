[
    {
        "title": "Minimum Area Rectangle II",
        "question_content": "You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\nReturn the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the X and Y axes. If there is not any such rectangle, return 0.\nAnswers within 10-5 of the actual answer will be accepted.\n&nbsp;\nExample 1:\n\nInput: points = [[1,2],[2,1],[1,0],[0,1]]\nOutput: 2.00000\nExplanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.\n\nExample 2:\n\nInput: points = [[0,1],[2,1],[1,1],[1,0],[2,0]]\nOutput: 1.00000\nExplanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.\n\nExample 3:\n\nInput: points = [[0,3],[1,2],[3,1],[1,3],[2,1]]\nOutput: 0\nExplanation: There is no possible rectangle to form from these points.\n\n&nbsp;\nConstraints:\n\n\t1 <= points.length <= 50\n\tpoints[i].length == 2\n\t0 <= xi, yi <= 4 * 104\n\tAll the given points are unique.",
        "solutions": [
            {
                "id": 208361,
                "title": "java-o-n-2-using-map",
                "content": "1. Two diagonals of a rectangle bisect each other, and are of equal length.\\n2. The map\\'s key is String including diagonal length and coordinate of the diagonal center; map\\'s value is the index of two points forming the diagonal.\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int len = points.length;\\n        double res = Double.MAX_VALUE;\\n        if (len < 4) return 0.0;\\n        Map<String, List<int[]>> map = new HashMap<>(); // int[] is the index of two points forming the diagonal\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                long dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                double centerX = (double)(points[j][0] + points[i][0])/2; // centerX and centerY is the coordinate of the diagonal center\\n                double centerY = (double)(points[j][1] + points[i][1])/2;\\n                String key = \"\" + dis + \"+\" + centerX + \"+\" + centerY; // key includes the length of the diagonal and the coordinate of the diagonal center\\n                if (map.get(key) == null) map.put(key, new ArrayList<int[]>());\\n                map.get(key).add(new int[]{i,j});\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            if (map.get(key).size() > 1) {  \\n                List<int[]> list = map.get(key);\\n                for (int i = 0; i < list.size(); i++) { // there could be multiple rectangles inside\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        int p1 = list.get(i)[0]; // p1, p2 and p3 are the three vertices of a rectangle\\n                        int p2 = list.get(j)[0];\\n                        int p3 = list.get(j)[1];\\n                        // len1 and len2 are the length of the sides of a rectangle\\n                        double len1 = Math.sqrt((points[p1][0] - points[p2][0]) * (points[p1][0] - points[p2][0]) +  (points[p1][1] - points[p2][1]) * (points[p1][1] - points[p2][1])); \\n                        double len2 = Math.sqrt((points[p1][0] - points[p3][0]) * (points[p1][0] - points[p3][0]) +  (points[p1][1] - points[p3][1]) * (points[p1][1] - points[p3][1]));\\n                        double area = len1 * len2; \\n                        res = Math.min(res, area);\\n                    }\\n                }\\n            }\\n        }\\n        return res == Double.MAX_VALUE ?  0.0 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int len = points.length;\\n        double res = Double.MAX_VALUE;\\n        if (len < 4) return 0.0;\\n        Map<String, List<int[]>> map = new HashMap<>(); // int[] is the index of two points forming the diagonal\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                long dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                double centerX = (double)(points[j][0] + points[i][0])/2; // centerX and centerY is the coordinate of the diagonal center\\n                double centerY = (double)(points[j][1] + points[i][1])/2;\\n                String key = \"\" + dis + \"+\" + centerX + \"+\" + centerY; // key includes the length of the diagonal and the coordinate of the diagonal center\\n                if (map.get(key) == null) map.put(key, new ArrayList<int[]>());\\n                map.get(key).add(new int[]{i,j});\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            if (map.get(key).size() > 1) {  \\n                List<int[]> list = map.get(key);\\n                for (int i = 0; i < list.size(); i++) { // there could be multiple rectangles inside\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        int p1 = list.get(i)[0]; // p1, p2 and p3 are the three vertices of a rectangle\\n                        int p2 = list.get(j)[0];\\n                        int p3 = list.get(j)[1];\\n                        // len1 and len2 are the length of the sides of a rectangle\\n                        double len1 = Math.sqrt((points[p1][0] - points[p2][0]) * (points[p1][0] - points[p2][0]) +  (points[p1][1] - points[p2][1]) * (points[p1][1] - points[p2][1])); \\n                        double len2 = Math.sqrt((points[p1][0] - points[p3][0]) * (points[p1][0] - points[p3][0]) +  (points[p1][1] - points[p3][1]) * (points[p1][1] - points[p3][1]));\\n                        double area = len1 * len2; \\n                        res = Math.min(res, area);\\n                    }\\n                }\\n            }\\n        }\\n        return res == Double.MAX_VALUE ?  0.0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210786,
                "title": "c-with-picture-find-diagonals-o-n-n",
                "content": "Diagonals of a rectangle are intersecting in the middle point. For any pair of points (our first potential diagonal) ```{xi, yi} - {xj, yj}```, we find and track the middle point ```{x0, y0}```. Any other pair of points with the same middle point is the second potential diagonal.\\n\\nI am using the hash map for O(1) lookups, and I compressing ```{x0, y0}``` coordinates into a single integer for the simplicity.\\n![image](https://assets.leetcode.com/users/votrubac/image_1546066215.png)\\nAfter we processed all pair of points this way, we analyze potential diagonals for each middle point. We form two sides of the potential rectangle as ```{x11, y11} - {x21, y21}``` and ```{x11, y11} - {x22, y22}```, and check if they are orthogonal (perpendicular). If so, we calculate the area and track the smallest one.\\n```\\nsize_t d2(int x1, int y1, int x2, int y2) { \\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, vector<vector<int>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      m[center].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it = begin(m); it != end(m); ++it)\\n    for (auto i = 0; i < it->second.size(); ++i)\\n      for (auto j = i + 1; j < it->second.size(); ++j) {\\n        auto &p1 = it->second[i], &p2 = it->second[j];\\n        if ((p1[0] - p2[0]) * (p1[0] - p2[2]) + (p1[1] - p2[1]) * (p1[1] - p2[3]) == 0) {\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n      }\\n  return sqrt(res);\\n}\\n```\\nAs an alternative, we can track both the center and length of the diagonals in the hash map (only diagonals with the same length can form a rectangle). That way we can potentially reduce the number of diagonals to compare. We also do not need to do the orthogonality check anymore.\\n\\nThanks [@kaiwensun](https://leetcode.com/kaiwensun/) for this interesting idea.\\n```\\nsize_t d2(int x1, int y1, int x2, int y2) {\\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, unordered_map<size_t, vector<vector<int>>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      auto len = d2(ps[i][0], ps[i][1], ps[j][0], ps[j][1]);\\n      m[center][len].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it_c = begin(m); it_c != end(m); ++it_c)\\n    for (auto it_l = begin(it_c->second); it_l != end(it_c->second); ++it_l)\\n      for (auto i = 0; i < it_l->second.size(); ++i)\\n        for (auto j = i + 1; j < it_l->second.size(); ++j) {\\n          auto &p1 = it_l->second[i], &p2 = it_l->second[j];\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n  return sqrt(res);\\n}\\n```",
                "solutionTags": [],
                "code": "```{xi, yi} - {xj, yj}```\n```{x0, y0}```\n```{x0, y0}```\n```{x11, y11} - {x21, y21}```\n```{x11, y11} - {x22, y22}```\n```\\nsize_t d2(int x1, int y1, int x2, int y2) { \\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, vector<vector<int>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      m[center].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it = begin(m); it != end(m); ++it)\\n    for (auto i = 0; i < it->second.size(); ++i)\\n      for (auto j = i + 1; j < it->second.size(); ++j) {\\n        auto &p1 = it->second[i], &p2 = it->second[j];\\n        if ((p1[0] - p2[0]) * (p1[0] - p2[2]) + (p1[1] - p2[1]) * (p1[1] - p2[3]) == 0) {\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n      }\\n  return sqrt(res);\\n}\\n```\n```\\nsize_t d2(int x1, int y1, int x2, int y2) {\\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, unordered_map<size_t, vector<vector<int>>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      auto len = d2(ps[i][0], ps[i][1], ps[j][0], ps[j][1]);\\n      m[center][len].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it_c = begin(m); it_c != end(m); ++it_c)\\n    for (auto it_l = begin(it_c->second); it_l != end(it_c->second); ++it_l)\\n      for (auto i = 0; i < it_l->second.size(); ++i)\\n        for (auto j = i + 1; j < it_l->second.size(); ++j) {\\n          auto &p1 = it_l->second[i], &p2 = it_l->second[j];\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n  return sqrt(res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208470,
                "title": "java-o-n-3-bruteforce",
                "content": "1. Iterate 3 points.\\n2. Find the last point.\\n3. Calculate the area.\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Set<String> set = new HashSet<>();\\n        for (int[] p : points) {\\n            set.add(p[0] + \" \" + p[1]);\\n        }\\n        double result = Double.MAX_VALUE;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                if (p1[0] == p2[0] && p1[1] == p2[1]) {\\n                    continue;\\n                }\\n                for (int[] p3 : points) {\\n                    if (dist(p1, p3) + dist(p2, p3) != dist(p1, p2)) {\\n                        continue;\\n                    }\\n                    int x = p1[0] + p2[0] - p3[0];\\n                    int y = p1[1] + p2[1] - p3[1];\\n                    if (!set.contains(x + \" \" + y)) {\\n                        continue;\\n                    }\\n                    double area = Math.sqrt(dist(p1, p3)) * Math.sqrt(dist(p2, p3));\\n                    if (Double.compare(area, 0) == 0) {\\n                        continue;\\n                    }\\n                    result = Math.min(result, area);\\n                }\\n            }\\n        }\\n        return Double.compare(Double.MAX_VALUE, result) == 0 ? 0 : result;\\n    }\\n    private int dist(int[] p1, int[] p2) {\\n        return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Set<String> set = new HashSet<>();\\n        for (int[] p : points) {\\n            set.add(p[0] + \" \" + p[1]);\\n        }\\n        double result = Double.MAX_VALUE;\\n        for (int[] p1 : points) {\\n            for (int[] p2 : points) {\\n                if (p1[0] == p2[0] && p1[1] == p2[1]) {\\n                    continue;\\n                }\\n                for (int[] p3 : points) {\\n                    if (dist(p1, p3) + dist(p2, p3) != dist(p1, p2)) {\\n                        continue;\\n                    }\\n                    int x = p1[0] + p2[0] - p3[0];\\n                    int y = p1[1] + p2[1] - p3[1];\\n                    if (!set.contains(x + \" \" + y)) {\\n                        continue;\\n                    }\\n                    double area = Math.sqrt(dist(p1, p3)) * Math.sqrt(dist(p2, p3));\\n                    if (Double.compare(area, 0) == 0) {\\n                        continue;\\n                    }\\n                    result = Math.min(result, area);\\n                }\\n            }\\n        }\\n        return Double.compare(Double.MAX_VALUE, result) == 0 ? 0 : result;\\n    }\\n    private int dist(int[] p1, int[] p2) {\\n        return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208377,
                "title": "python-easy-to-understand-dot-product-o-n-3-ac",
                "content": "* Dot product of two sides in a rectangle should be zero  because a . b = |a| |b| cos(90)\\n* If we can extend p3 by the same margin delta(p2 - p1), we can have the fourth point p4.\\n\\t* x4 = x3 + (x2 - x1)\\n\\t* y4 = y3 + (y2 - y1)\\n* If p4 in points, calculate area.\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        mn, st, n = float(\\'inf\\'), {(x, y) for x, y in points}, len(points) \\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, n):\\n                x2, y2 = points[j]\\n                for k in range(j + 1, n):\\n                    x3, y3 = points[k]\\n                    if not (x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1) and (x3 + (x2 - x1), y3 + (y2 - y1)) in st:\\n                        mn = min(mn, ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 * ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5)\\n        return mn if mn < float(\"inf\") else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        mn, st, n = float(\\'inf\\'), {(x, y) for x, y in points}, len(points) \\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, n):\\n                x2, y2 = points[j]\\n                for k in range(j + 1, n):\\n                    x3, y3 = points[k]\\n                    if not (x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1) and (x3 + (x2 - x1), y3 + (y2 - y1)) in st:\\n                        mn = min(mn, ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 * ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5)\\n        return mn if mn < float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980956,
                "title": "python3-center-point-o-n-2",
                "content": "**Algo**\\nUse a 2-layer nested loops to scan through pair of points `(x0, y0)` and `(x1, y1)`. The key features extracted from this pair are center and length `(cx, cy, d2)`. Those points with the same center and length form rectangles. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        ans = inf\\n        seen = {}\\n        for i, (x0, y0) in enumerate(points):\\n            for x1, y1 in points[i+1:]:\\n                cx = (x0 + x1)/2\\n                cy = (y0 + y1)/2\\n                d2 = (x0 - x1)**2 + (y0 - y1)**2\\n                for xx, yy in seen.get((cx, cy, d2), []): \\n                    area = sqrt(((x0-xx)**2 + (y0-yy)**2) * ((x1-xx)**2 + (y1-yy)**2))\\n                    ans = min(ans, area)\\n                seen.setdefault((cx, cy, d2), []).append((x0, y0))\\n        return ans if ans < inf else 0\\n```\\n\\n**Analysis**\\nTime complexity `O(N^2)`\\nSpace complexity `O(N^2)`\\n\\nThe worse case of this approach is `O(N^3)`. Imagine that all points are distributed on a circle. In this case, one could find `N/2` pairs whose center is at the center of the circle. In extreme cases like this, one would have `O(N^3)` performance. But on average, `O(N^2)` can be expected.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        ans = inf\\n        seen = {}\\n        for i, (x0, y0) in enumerate(points):\\n            for x1, y1 in points[i+1:]:\\n                cx = (x0 + x1)/2\\n                cy = (y0 + y1)/2\\n                d2 = (x0 - x1)**2 + (y0 - y1)**2\\n                for xx, yy in seen.get((cx, cy, d2), []): \\n                    area = sqrt(((x0-xx)**2 + (y0-yy)**2) * ((x1-xx)**2 + (y1-yy)**2))\\n                    ans = min(ans, area)\\n                seen.setdefault((cx, cy, d2), []).append((x0, y0))\\n        return ans if ans < inf else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477751,
                "title": "clean-python-solution-with-explanation",
                "content": "The key insight is that four points `point1, point2, point3, point4` can form a rectangle if and only if\\n* the distance between `point1` and `point2` equals the distance between `point3` and `point4`\\n* the midpoint of `point1` and `point2` equals the midpoint of `point3` and `point4`.\\n\\nIn the following implementation, I use a dictionary to store all pairs of points that have the same `distance` and `midpoint`. \\n\\n```python\\n\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        diagonal_and_midpoints = defaultdict(list)\\n        for point1, point2 in self._generate_distinct_pairs(points):\\n            diagonal = self._get_distance(point1, point2)\\n            midpoint = self._get_midpoint(point1, point2)\\n            diagonal_and_midpoints[(diagonal, midpoint)].append((point1, point2))\\n        return min(\\n            (self._get_area(pair1, pair2)\\n             for pairs in diagonal_and_midpoints.values()\\n             for pair1, pair2 in self._generate_distinct_pairs(pairs)),\\n            default=0)\\n\\n    def _generate_distinct_pairs(self, items):\\n        for i in range(len(items)):\\n            for j in range(i+1, len(items)):\\n                yield items[i], items[j]\\n    \\n    def _get_midpoint(self, point1, point2):\\n        (x1, y1), (x2, y2) = point1, point2\\n        return (x1 + x2) / 2, (y1 + y2) / 2\\n\\n    def _get_area(self, pair1, pair2) -> float:\\n        (point1, _), (point3, point4) = pair1, pair2\\n        return self._get_distance(point1, point3) * self._get_distance(point1, point4)\\n    \\n    def _get_distance(self, point1, point2) -> float:\\n        x1, y1 = point1\\n        x2, y2 = point2\\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\n\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        diagonal_and_midpoints = defaultdict(list)\\n        for point1, point2 in self._generate_distinct_pairs(points):\\n            diagonal = self._get_distance(point1, point2)\\n            midpoint = self._get_midpoint(point1, point2)\\n            diagonal_and_midpoints[(diagonal, midpoint)].append((point1, point2))\\n        return min(\\n            (self._get_area(pair1, pair2)\\n             for pairs in diagonal_and_midpoints.values()\\n             for pair1, pair2 in self._generate_distinct_pairs(pairs)),\\n            default=0)\\n\\n    def _generate_distinct_pairs(self, items):\\n        for i in range(len(items)):\\n            for j in range(i+1, len(items)):\\n                yield items[i], items[j]\\n    \\n    def _get_midpoint(self, point1, point2):\\n        (x1, y1), (x2, y2) = point1, point2\\n        return (x1 + x2) / 2, (y1 + y2) / 2\\n\\n    def _get_area(self, pair1, pair2) -> float:\\n        (point1, _), (point3, point4) = pair1, pair2\\n        return self._get_distance(point1, point3) * self._get_distance(point1, point4)\\n    \\n    def _get_distance(self, point1, point2) -> float:\\n        x1, y1 = point1\\n        x2, y2 = point2\\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209117,
                "title": "short-java-solution",
                "content": "```\\n    public double minAreaFreeRect(int[][] p) {\\n        Map<String, List<int[]>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < p.length; i++) {\\n            for(int j = i + 1; j < p.length; j++) {\\n                double x = (p[i][0] + p[j][0]) / 2.0;\\n                double y = (p[i][1] + p[j][1]) / 2.0;\\n                String key = x + \",\"+ y + \",\" + getDist(p, i, j);\\n                map.putIfAbsent(key, new ArrayList<>());\\n                map.get(key).add(new int[]{i, j});\\n            }\\n        }\\n        \\n        \\n        double res = Double.MAX_VALUE;\\n        for(List<int[]> l : map.values()) {\\n            for(int i = 0; i < l.size(); i++) {\\n                for(int j = i + 1; j < l.size(); j++) {\\n                    res = Math.min(res, getArea(p, l.get(i), l.get(j)));\\n                }\\n            }\\n        }\\n        \\n        return res == Double.MAX_VALUE ? 0 : res;\\n    }\\n    \\n    int getDist(int[][] p, int i, int j) {\\n        return (p[i][0]-p[j][0])*(p[i][0]-p[j][0]) + (p[i][1]-p[j][1])*(p[i][1]-p[j][1]);\\n    }\\n    \\n    double getArea(int[][] p, int[] a, int[] b) {\\n        int dis1 = getDist(p, a[0], b[0]);\\n        int dis2 = getDist(p, a[0], b[1]);\\n        return Math.sqrt(dis1) * Math.sqrt(dis2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double minAreaFreeRect(int[][] p) {\\n        Map<String, List<int[]>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < p.length; i++) {\\n            for(int j = i + 1; j < p.length; j++) {\\n                double x = (p[i][0] + p[j][0]) / 2.0;\\n                double y = (p[i][1] + p[j][1]) / 2.0;\\n                String key = x + \",\"+ y + \",\" + getDist(p, i, j);\\n                map.putIfAbsent(key, new ArrayList<>());\\n                map.get(key).add(new int[]{i, j});\\n            }\\n        }\\n        \\n        \\n        double res = Double.MAX_VALUE;\\n        for(List<int[]> l : map.values()) {\\n            for(int i = 0; i < l.size(); i++) {\\n                for(int j = i + 1; j < l.size(); j++) {\\n                    res = Math.min(res, getArea(p, l.get(i), l.get(j)));\\n                }\\n            }\\n        }\\n        \\n        return res == Double.MAX_VALUE ? 0 : res;\\n    }\\n    \\n    int getDist(int[][] p, int i, int j) {\\n        return (p[i][0]-p[j][0])*(p[i][0]-p[j][0]) + (p[i][1]-p[j][1])*(p[i][1]-p[j][1]);\\n    }\\n    \\n    double getArea(int[][] p, int[] a, int[] b) {\\n        int dis1 = getDist(p, a[0], b[0]);\\n        int dis2 = getDist(p, a[0], b[1]);\\n        return Math.sqrt(dis1) * Math.sqrt(dis2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208351,
                "title": "python-complex",
                "content": "It will be O(N^3) in worst cases.  O(N^2) in average.\\n\\n**Python:**\\n```\\n    def minAreaFreeRect(self, points):\\n        points = [complex(*z) for z in sorted(points)]\\n        seen = collections.defaultdict(list)\\n        for P, Q in itertools.combinations(points, 2):\\n            seen[Q - P].append((P + Q) / 2)\\n\\n        ans = float(\"inf\")\\n        for A, candidates in seen.iteritems():\\n            for P, Q in itertools.combinations(candidates, 2):\\n                if A.real * (P - Q).real == -A.imag * (P - Q).imag:\\n                    ans = min(ans, abs(A) * abs(P - Q))\\n        return ans if ans < float(\"inf\") else 0\\n```",
                "solutionTags": [],
                "code": "```\\n    def minAreaFreeRect(self, points):\\n        points = [complex(*z) for z in sorted(points)]\\n        seen = collections.defaultdict(list)\\n        for P, Q in itertools.combinations(points, 2):\\n            seen[Q - P].append((P + Q) / 2)\\n\\n        ans = float(\"inf\")\\n        for A, candidates in seen.iteritems():\\n            for P, Q in itertools.combinations(candidates, 2):\\n                if A.real * (P - Q).real == -A.imag * (P - Q).imag:\\n                    ans = min(ans, abs(A) * abs(P - Q))\\n        return ans if ans < float(\"inf\") else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 208384,
                "title": "c-o-n-3-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string getKey(int a, int b) {\\n        return to_string(a) + \"_\" + to_string(b);\\n    }\\n    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_set<string> us;\\n        for (auto &p: points) {\\n            us.insert(getKey(p[0], p[1]));\\n        }\\n        double ans = 0;\\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = 0; j < points.size(); ++j) {\\n                for (int k = j + 1; k < points.size(); ++k) {\\n                    if (i == j || i == k) continue;\\n                    int x1 = points[i][0], y1 = points[i][1];\\n                    int x2 = points[j][0], y2 = points[j][1];\\n                    int x3 = points[k][0], y3 = points[k][1];\\n                    if ((x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1) != 0) continue;\\n                    int x4 = x2 + x3 - x1, y4 = y2 + y3 - y1;\\n                    if (us.count(getKey(x4, y4))) {\\n                        double w = pow(pow(x2 - x1, 2) + pow(y2 - y1, 2), 0.5);\\n                        double l = pow(pow(x3 - x1, 2) + pow(y3 - y1, 2), 0.5);\\n                        double area = w * l;\\n                        if (ans == 0 || area != 0 && area < ans) {\\n                            ans = area;   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getKey(int a, int b) {\\n        return to_string(a) + \"_\" + to_string(b);\\n    }\\n    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_set<string> us;\\n        for (auto &p: points) {\\n            us.insert(getKey(p[0], p[1]));\\n        }\\n        double ans = 0;\\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = 0; j < points.size(); ++j) {\\n                for (int k = j + 1; k < points.size(); ++k) {\\n                    if (i == j || i == k) continue;\\n                    int x1 = points[i][0], y1 = points[i][1];\\n                    int x2 = points[j][0], y2 = points[j][1];\\n                    int x3 = points[k][0], y3 = points[k][1];\\n                    if ((x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1) != 0) continue;\\n                    int x4 = x2 + x3 - x1, y4 = y2 + y3 - y1;\\n                    if (us.count(getKey(x4, y4))) {\\n                        double w = pow(pow(x2 - x1, 2) + pow(y2 - y1, 2), 0.5);\\n                        double l = pow(pow(x3 - x1, 2) + pow(y3 - y1, 2), 0.5);\\n                        double area = w * l;\\n                        if (ans == 0 || area != 0 && area < ans) {\\n                            ans = area;   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869640,
                "title": "python3-easy-to-understand-solution-with-basic-coordinate-geometry",
                "content": "For any rectangle, the length of its diagonals and the mid point of its diagonals must be equal.\\n\\n1.Form a line between any two points and assume that it forms a diagonal of some rectangle.\\n2.Group similar pairs of points into a dictionary with the key as (diagonal_len, midpoint)\\n3.Iterate through each group\\n4.Any pair of points within a group would form a rectangle so calculate its area and check if it is the minimum\\n```\\nfrom collections import defaultdict\\nfrom math import sqrt\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def mid_point(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            mid_x = (x1 + x2) / 2.0\\n            mid_y = (y1 + y2) / 2.0\\n            return (mid_x, mid_y)\\n\\n        def get_distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\\n\\n        def get_area(p1, p2, p4):\\n            width = get_distance(p1, p2)\\n            height = get_distance(p1, p4)\\n            return width * height\\n\\n        diag_centres_and_len = defaultdict(list)\\n        # Assume that two points form the diagonal of a rectangle\\n        # Group the points based on diagonal length and diagonal midpoint\\n        for i in range(len(points)):\\n            p1 = points[i]\\n            for k in range(i+1, len(points)):\\n                p2 = points[k]\\n                diagonal_len = get_distance(p1, p2)\\n                diagonal_mid = mid_point(p1, p2)\\n                diag_centres_and_len[(diagonal_len, diagonal_mid)].append((p1, p2))\\n\\n        min_area = float(\"inf\")\\n        # Each pair of items in a group form 4 points of the rectangle\\n        # Interate through each pair to get the area\\n        for group in diag_centres_and_len.values():\\n            for i in range(len(group)):\\n                p1, p3 = group[i]\\n                for k in range(i+1, len(group)):\\n                    p2, p4 = group[k]\\n                    area = get_area(p1, p2, p4)\\n                    min_area = min(min_area, area)\\n\\n        return min_area if min_area != float(\"inf\") else 0\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nfrom math import sqrt\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def mid_point(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            mid_x = (x1 + x2) / 2.0\\n            mid_y = (y1 + y2) / 2.0\\n            return (mid_x, mid_y)\\n\\n        def get_distance(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\\n\\n        def get_area(p1, p2, p4):\\n            width = get_distance(p1, p2)\\n            height = get_distance(p1, p4)\\n            return width * height\\n\\n        diag_centres_and_len = defaultdict(list)\\n        # Assume that two points form the diagonal of a rectangle\\n        # Group the points based on diagonal length and diagonal midpoint\\n        for i in range(len(points)):\\n            p1 = points[i]\\n            for k in range(i+1, len(points)):\\n                p2 = points[k]\\n                diagonal_len = get_distance(p1, p2)\\n                diagonal_mid = mid_point(p1, p2)\\n                diag_centres_and_len[(diagonal_len, diagonal_mid)].append((p1, p2))\\n\\n        min_area = float(\"inf\")\\n        # Each pair of items in a group form 4 points of the rectangle\\n        # Interate through each pair to get the area\\n        for group in diag_centres_and_len.values():\\n            for i in range(len(group)):\\n                p1, p3 = group[i]\\n                for k in range(i+1, len(group)):\\n                    p2, p4 = group[k]\\n                    area = get_area(p1, p2, p4)\\n                    min_area = min(min_area, area)\\n\\n        return min_area if min_area != float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611645,
                "title": "java-check-diagonal",
                "content": "for points forms rectangular iff:\\n1, diags cross at centers;\\n2, diag lengths are the same;\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] ps) {\\n        Map<String, List<int[][]>> map = new HashMap<>();\\n        int m = ps.length;\\n        String DEL = \",\";\\n        for (int i = 0; i < m; i++) {\\n            for (int j = i + 1; j < m; j++) {\\n                double len = getDist(new int[][]{ps[i], ps[j]});\\n                double xm = (ps[i][0] + ps[j][0]) / 2.0;\\n                double ym = (ps[i][1] + ps[j][1]) / 2.0;\\n                map.computeIfAbsent(xm + DEL + ym + DEL + len, k -> new ArrayList<>());\\n                map.get(xm + DEL + ym + DEL + len).add(new int[][]{ps[i], ps[j]});\\n            }\\n        }\\n        double res = Double.MAX_VALUE;\\n        for (String key : map.keySet()) {\\n            List<int[][]> l = map.get(key);\\n            if (l.size() < 2) continue;\\n            for (int i = 0; i < l.size(); i++) {\\n                for (int j = i + 1; j < l.size(); j++) {\\n                    int[] i1 = l.get(i)[0];\\n                    int[] j1 = l.get(j)[0];\\n                    int[] j2 = l.get(j)[1];\\n                    double area = getDist(new int[][]{i1, j1}) * getDist(new int[][]{i1, j2});\\n                    res = Math.min(res, area);\\n                }\\n            }\\n        }\\n        return res < Double.MAX_VALUE ? res : 0;  // corner case;\\n    }\\n    \\n    private double getDist(int[][] ps) {\\n        int i = 0, j = 1;\\n        return Math.sqrt((ps[i][0] - ps[j][0]) * (ps[i][0] - ps[j][0]) + \\n                         (ps[i][1] - ps[j][1]) * (ps[i][1] - ps[j][1]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] ps) {\\n        Map<String, List<int[][]>> map = new HashMap<>();\\n        int m = ps.length;\\n        String DEL = \",\";\\n        for (int i = 0; i < m; i++) {\\n            for (int j = i + 1; j < m; j++) {\\n                double len = getDist(new int[][]{ps[i], ps[j]});\\n                double xm = (ps[i][0] + ps[j][0]) / 2.0;\\n                double ym = (ps[i][1] + ps[j][1]) / 2.0;\\n                map.computeIfAbsent(xm + DEL + ym + DEL + len, k -> new ArrayList<>());\\n                map.get(xm + DEL + ym + DEL + len).add(new int[][]{ps[i], ps[j]});\\n            }\\n        }\\n        double res = Double.MAX_VALUE;\\n        for (String key : map.keySet()) {\\n            List<int[][]> l = map.get(key);\\n            if (l.size() < 2) continue;\\n            for (int i = 0; i < l.size(); i++) {\\n                for (int j = i + 1; j < l.size(); j++) {\\n                    int[] i1 = l.get(i)[0];\\n                    int[] j1 = l.get(j)[0];\\n                    int[] j2 = l.get(j)[1];\\n                    double area = getDist(new int[][]{i1, j1}) * getDist(new int[][]{i1, j2});\\n                    res = Math.min(res, area);\\n                }\\n            }\\n        }\\n        return res < Double.MAX_VALUE ? res : 0;  // corner case;\\n    }\\n    \\n    private double getDist(int[][] ps) {\\n        int i = 0, j = 1;\\n        return Math.sqrt((ps[i][0] - ps[j][0]) * (ps[i][0] - ps[j][0]) + \\n                         (ps[i][1] - ps[j][1]) * (ps[i][1] - ps[j][1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480125,
                "title": "clean-code-with-full-detail-explanation",
                "content": "```\\nThis complete problem requires the 5 basic concept of geometry.\\n\\nConcept -1 : Slope of line formed by points ( x1,y1 ) and (x2,y2) is (y2-y1) / (x2-x1)\\n\\nConcept-2 Three points form a right angle if the product of their slope is -1. Let assume 2 points are (x1,y1) , (x2,y2) and (x3,y3) \\n\\t      (y2-y1)/(x2-x1)   * (y3-y1)*(x3-x1) = -1\\n\\n\\t      Simplifying this equation\\n\\t\\t(y2-y1)* (y3-y1) \\u2013 (x2-x1) (x3-x1) = 0\\n\\n\\nConcept-3 Distance between 2 point is sqrt[ (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)]\\n\\nConcept -4 Middle of two point is (x2+x1)/2\\n\\nConcept -5 : Expressing the 4 the co-ordinate of the rectangle through other 3 co-ordinates\\nLet say we have 4 co-ordinates anticlockwise ->  a(x1,y1), b(x2,y2), c(x3,y3), d(x4,y4) \\nWe know diagonals of rectangle are equal and bisect each other. Thus\\n(x1+x3)/ 2 = (x2+x4)/2\\nSimplify the equation\\nX4 = x1-x2 +x3\\nX4 = y1-y2 +y3\\n\\nNow we have all the ingredients of our algorithm, Here is the step of our algorithm \\n\\n1.\\tFor all triplets of points check if they form a Right -Angle by using the concept -2\\n2.\\tIf they form a right angle calculate the 4th point through concept-5.\\n3.\\tCheck if the 4th point exists in our list , if yes then calculate the area of rectangle (Area = length * breadth). Length and breadth of rectangle is calculated by using the concept 3. \\n4.\\tTrack if the area calculated is minimum of the area calculated so far.\\n\\nComplexity := O(N ^ 3) where n is number of points\\n\\nIn conclusion I won\\u2019t say it is a good question of algo. It is more of testing your geometry skill.\\n\\nHere is the code \\n\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        \\n        for(int[] point : points){\\n            int x=point[0];\\n            int y=point[1];\\n            if(!map.containsKey(x)){\\n                map.put(x, new HashSet<>());\\n            }\\n            map.get(x).add(y);\\n        }\\n        \\n        double min=Double.MAX_VALUE;\\n        int n=points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int dx1=points[j][0] - points[i][0];\\n                int dy1=points[j][1] - points[i][1];\\n                \\n                for(int k=j+1;k<n;k++){\\n                    int dx2=points[k][0]-points[i][0];\\n                    int dy2=points[k][1]-points[i][1];\\n                    \\n                    if(dx1 * dx2 + dy1 * dy2 != 0){\\n                        continue;\\n                    }\\n                    \\n                    int x=dx1 + points[k][0];\\n                    int y=dy1+points[k][1];\\n                    \\n                    if(map.get(x) != null && map.get(x).contains(y)){\\n                        double area=Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);\\n                    if(area < min){\\n                        min=area;\\n                    }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\nDisclaimer \\u2013 Code is not mine, thanks to https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/1116315/Java-Solution-100-Faster for writing clean code on the above concept. I just added the explanation part.\\n```",
                "solutionTags": [],
                "code": "```\\nThis complete problem requires the 5 basic concept of geometry.\\n\\nConcept -1 : Slope of line formed by points ( x1,y1 ) and (x2,y2) is (y2-y1) / (x2-x1)\\n\\nConcept-2 Three points form a right angle if the product of their slope is -1. Let assume 2 points are (x1,y1) , (x2,y2) and (x3,y3) \\n\\t      (y2-y1)/(x2-x1)   * (y3-y1)*(x3-x1) = -1\\n\\n\\t      Simplifying this equation\\n\\t\\t(y2-y1)* (y3-y1) \\u2013 (x2-x1) (x3-x1) = 0\\n\\n\\nConcept-3 Distance between 2 point is sqrt[ (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)]\\n\\nConcept -4 Middle of two point is (x2+x1)/2\\n\\nConcept -5 : Expressing the 4 the co-ordinate of the rectangle through other 3 co-ordinates\\nLet say we have 4 co-ordinates anticlockwise ->  a(x1,y1), b(x2,y2), c(x3,y3), d(x4,y4) \\nWe know diagonals of rectangle are equal and bisect each other. Thus\\n(x1+x3)/ 2 = (x2+x4)/2\\nSimplify the equation\\nX4 = x1-x2 +x3\\nX4 = y1-y2 +y3\\n\\nNow we have all the ingredients of our algorithm, Here is the step of our algorithm \\n\\n1.\\tFor all triplets of points check if they form a Right -Angle by using the concept -2\\n2.\\tIf they form a right angle calculate the 4th point through concept-5.\\n3.\\tCheck if the 4th point exists in our list , if yes then calculate the area of rectangle (Area = length * breadth). Length and breadth of rectangle is calculated by using the concept 3. \\n4.\\tTrack if the area calculated is minimum of the area calculated so far.\\n\\nComplexity := O(N ^ 3) where n is number of points\\n\\nIn conclusion I won\\u2019t say it is a good question of algo. It is more of testing your geometry skill.\\n\\nHere is the code \\n\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        \\n        for(int[] point : points){\\n            int x=point[0];\\n            int y=point[1];\\n            if(!map.containsKey(x)){\\n                map.put(x, new HashSet<>());\\n            }\\n            map.get(x).add(y);\\n        }\\n        \\n        double min=Double.MAX_VALUE;\\n        int n=points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int dx1=points[j][0] - points[i][0];\\n                int dy1=points[j][1] - points[i][1];\\n                \\n                for(int k=j+1;k<n;k++){\\n                    int dx2=points[k][0]-points[i][0];\\n                    int dy2=points[k][1]-points[i][1];\\n                    \\n                    if(dx1 * dx2 + dy1 * dy2 != 0){\\n                        continue;\\n                    }\\n                    \\n                    int x=dx1 + points[k][0];\\n                    int y=dy1+points[k][1];\\n                    \\n                    if(map.get(x) != null && map.get(x).contains(y)){\\n                        double area=Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);\\n                    if(area < min){\\n                        min=area;\\n                    }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\nDisclaimer \\u2013 Code is not mine, thanks to https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/1116315/Java-Solution-100-Faster for writing clean code on the above concept. I just added the explanation part.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402566,
                "title": "c-solution-using-hashmap-with-distance-of-2-points-as-key-and-2-points-as-value",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    double minAreaFreeRect(vector<vector<int>>& points) \\n    {\\n        double result=2147483647;\\n        map<int,vector<vector<int>>> total;\\n        for(int i=0;i<(int)points.size()-1;i++)\\n        {\\n            for(int j=i+1;j<(int)points.size();j++)\\n            {\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                int d=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);//key is the distance between 2 points (square)\\n                vector<int> temp;//value is 2 points (x1,y1,x2,y2)\\n                if(x1>x2)\\n                {\\n                    temp.push_back(x1);\\n                    temp.push_back(y1);\\n                    temp.push_back(x2);\\n                    temp.push_back(y2);\\n                }\\n                else\\n                {\\n                    temp.push_back(x2);\\n                    temp.push_back(y2);\\n                    temp.push_back(x1);\\n                    temp.push_back(y1);\\n                }\\n                total[d].push_back(temp);\\n            }\\n        }\\n        for(map<int,vector<vector<int>>>::iterator it=total.begin();it!=total.end();it++)\\n        {\\n            for(int i=0;i<(int)it->second.size()-1;i++)//p1~p2, and p3~p4 have same length\\n            {\\n                for(int j=i+1;j<(int)it->second.size();j++)\\n                {\\n                    int x1=it->second[i][0];\\n                    int x2=it->second[i][2];\\n                    int x3=it->second[j][0];\\n                    int x4=it->second[j][2];\\n\\n                    int y1=it->second[i][1];\\n                    int y2=it->second[i][3];\\n                    int y3=it->second[j][1];\\n                    int y4=it->second[j][3];\\n                    \\n                    if((x3-x1)*(x3-x1)+(y3-y1)*(y3-y1)==(x4-x2)*(x4-x2)+(y4-y2)*(y4-y2))//check if p1~p3 and p2~p4 have same length\\n                    {\\n                        int f1=x2-x1;\\n                        int f2=y2-y1;\\n                        int f3=x3-x1;\\n                        int f4=y3-y1;\\n                        if(((f1==0&&f3==0)||(f2==0&&f4==0)||((double)(x2-x1)/(double)(y2-y1))==((double(x4-x3)/(double)(y4-y3))))&&(f1*f3+f2*f4==0))// check if p1~p2 and p3~p4 have same slope. check if p1~p2 and p1~p3 are orthogonal\\n                        {\\n                            result=min(result,sqrt(f1*f1+f2*f2)*sqrt(f3*f3+f4*f4));//the area of the rectangle\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(result==2147483647)\\n        {\\n            return 0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    double minAreaFreeRect(vector<vector<int>>& points) \\n    {\\n        double result=2147483647;\\n        map<int,vector<vector<int>>> total;\\n        for(int i=0;i<(int)points.size()-1;i++)\\n        {\\n            for(int j=i+1;j<(int)points.size();j++)\\n            {\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                int d=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);//key is the distance between 2 points (square)\\n                vector<int> temp;//value is 2 points (x1,y1,x2,y2)\\n                if(x1>x2)\\n                {\\n                    temp.push_back(x1);\\n                    temp.push_back(y1);\\n                    temp.push_back(x2);\\n                    temp.push_back(y2);\\n                }\\n                else\\n                {\\n                    temp.push_back(x2);\\n                    temp.push_back(y2);\\n                    temp.push_back(x1);\\n                    temp.push_back(y1);\\n                }\\n                total[d].push_back(temp);\\n            }\\n        }\\n        for(map<int,vector<vector<int>>>::iterator it=total.begin();it!=total.end();it++)\\n        {\\n            for(int i=0;i<(int)it->second.size()-1;i++)//p1~p2, and p3~p4 have same length\\n            {\\n                for(int j=i+1;j<(int)it->second.size();j++)\\n                {\\n                    int x1=it->second[i][0];\\n                    int x2=it->second[i][2];\\n                    int x3=it->second[j][0];\\n                    int x4=it->second[j][2];\\n\\n                    int y1=it->second[i][1];\\n                    int y2=it->second[i][3];\\n                    int y3=it->second[j][1];\\n                    int y4=it->second[j][3];\\n                    \\n                    if((x3-x1)*(x3-x1)+(y3-y1)*(y3-y1)==(x4-x2)*(x4-x2)+(y4-y2)*(y4-y2))//check if p1~p3 and p2~p4 have same length\\n                    {\\n                        int f1=x2-x1;\\n                        int f2=y2-y1;\\n                        int f3=x3-x1;\\n                        int f4=y3-y1;\\n                        if(((f1==0&&f3==0)||(f2==0&&f4==0)||((double)(x2-x1)/(double)(y2-y1))==((double(x4-x3)/(double)(y4-y3))))&&(f1*f3+f2*f4==0))// check if p1~p2 and p3~p4 have same slope. check if p1~p2 and p1~p3 are orthogonal\\n                        {\\n                            result=min(result,sqrt(f1*f1+f2*f2)*sqrt(f3*f3+f4*f4));//the area of the rectangle\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(result==2147483647)\\n        {\\n            return 0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100981,
                "title": "javascript-o-n-2-map-with-comments",
                "content": "**Key Observations:**\\n1. Calculate distance between all given points assuming they could be diagonals of the rectangle\\n2. If two set of diagonals have same key then they are a rectangle. Save diagonal distance and midpoint of each combo as key in a map\\n3. Use the map and calculate area for key\\'s which has more than 1 set of co-ordinates.\\n\\n\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    let len = points.length;\\n    \\n    if (len < 4) return 0;\\n    \\n    // Helper function to calculate distance\\n    // between two points, optionally return \\n    // without sqrt if want to use as key\\n    const getDistance = (a, b, isKey = false) => {\\n        let [xa, ya] = a;\\n        let [xb, yb] = b;\\n        \\n        const distance = (xa - xb) * (xa - xb) + (ya - yb) * (ya - yb);\\n        return isKey ? distance : Math.sqrt(distance);\\n    }\\n    \\n    let map = new Map();\\n    \\n    // let\\'s loop over all points and find all possible\\n    // diagonals and calc - dis with midpoints and \\n    // save as key with co-ordinates as values\\n    for (let i = 0; i < len; i += 1) {\\n        for (let j = i + 1; j < len; j += 1) {\\n            let disKey = getDistance(points[i], points[j], true);\\n            let [xa, ya] = points[i];\\n            let [xb, yb] = points[j];\\n            \\n            let x = (xa + xb) / 2;\\n            let y = (ya + yb) / 2;\\n            \\n            let key = `${disKey}-${x}-${y}`;\\n            \\n            let list = [];\\n            \\n            if (!map.has(key)) {\\n                map.set(key, list)\\n            } else list = map.get(key);\\n            \\n            list.push([i, j]);\\n            \\n            map.set(key, list);\\n        }\\n    }\\n    \\n    // console.log(map);\\n    let res = Number.MAX_VALUE;\\n    \\n    // loop over map of keys above and\\n    // only iterate through the list where at least \\n    // 2 set of co-ordinates have been found above\\n    map.forEach((list, key) => {\\n        if (list.length > 1) {\\n            for (let i = 0; i < list.length; i += 1) {\\n                for (let j = i + 1; j < list.length; j += 1) {\\n                    let p1 = list[i][0];\\n                    let p2 = list[j][0];\\n                    let p3 = list[j][1];\\n                    \\n                    let l = getDistance(points[p1], points[p2]);\\n                    let b = getDistance(points[p1], points[p3]);\\n                    res = Math.min(res, l * b);\\n                }\\n            }\\n        }\\n    })\\n    \\n    return res === Number.MAX_VALUE ? 0 : res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    let len = points.length;\\n    \\n    if (len < 4) return 0;\\n    \\n    // Helper function to calculate distance\\n    // between two points, optionally return \\n    // without sqrt if want to use as key\\n    const getDistance = (a, b, isKey = false) => {\\n        let [xa, ya] = a;\\n        let [xb, yb] = b;\\n        \\n        const distance = (xa - xb) * (xa - xb) + (ya - yb) * (ya - yb);\\n        return isKey ? distance : Math.sqrt(distance);\\n    }\\n    \\n    let map = new Map();\\n    \\n    // let\\'s loop over all points and find all possible\\n    // diagonals and calc - dis with midpoints and \\n    // save as key with co-ordinates as values\\n    for (let i = 0; i < len; i += 1) {\\n        for (let j = i + 1; j < len; j += 1) {\\n            let disKey = getDistance(points[i], points[j], true);\\n            let [xa, ya] = points[i];\\n            let [xb, yb] = points[j];\\n            \\n            let x = (xa + xb) / 2;\\n            let y = (ya + yb) / 2;\\n            \\n            let key = `${disKey}-${x}-${y}`;\\n            \\n            let list = [];\\n            \\n            if (!map.has(key)) {\\n                map.set(key, list)\\n            } else list = map.get(key);\\n            \\n            list.push([i, j]);\\n            \\n            map.set(key, list);\\n        }\\n    }\\n    \\n    // console.log(map);\\n    let res = Number.MAX_VALUE;\\n    \\n    // loop over map of keys above and\\n    // only iterate through the list where at least \\n    // 2 set of co-ordinates have been found above\\n    map.forEach((list, key) => {\\n        if (list.length > 1) {\\n            for (let i = 0; i < list.length; i += 1) {\\n                for (let j = i + 1; j < list.length; j += 1) {\\n                    let p1 = list[i][0];\\n                    let p2 = list[j][0];\\n                    let p3 = list[j][1];\\n                    \\n                    let l = getDistance(points[p1], points[p2]);\\n                    let b = getDistance(points[p1], points[p3]);\\n                    res = Math.min(res, l * b);\\n                }\\n            }\\n        }\\n    })\\n    \\n    return res === Number.MAX_VALUE ? 0 : res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765389,
                "title": "python-76-quick-search-for-diamond-determine-rectangle-by-diagonal-distances",
                "content": "```python\\ndef dist_pow2(x1, y1, x2, y2): return (x2 - x1)**2 + (y2 - y1)**2\\ndef dist(x1, y1, x2, y2): return dist_pow2(x1, y1, x2, y2)**0.5\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        L, m = len(points), float(\\'inf\\')\\n\\n        quick_search = {(x, y) for x, y in points}\\n\\n        for i in range(L):\\n            for j in range(i + 1, L):\\n                for k in range(j + 1, L):\\n                    x1, y1 = points[i] # calculate point4 to form a diamond by previous three\\n                    x2, y2 = points[j] # we only check case when x4 is latter occured than x3\\n                    x3, y3 = points[k] # becourse the case when x4 is earlier occured than x3 will be covered already\\n                    x4, y4 = (x3 + (x2 - x1), y3 + (y2 - y1))\\n\\n                    if (x4, y4) in quick_search:  # look for existence of dimond shape\\n                        # if two diagonals\\' length are equal, we got a rectangel\\n                        if dist_pow2(x1, y1, x4, y4) == dist_pow2(x2, y2, x3, y3):\\n                            # calculate area by multipling any two adjacent edge\\'s length\\n                            area = dist(x1, y1, x2, y2) * dist(x1, y1, x3, y3)\\n                            m = min(m, area)  # keep track of min_area\\n\\n        return m if m != float(\\'inf\\') else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Geometry"
                ],
                "code": "```python\\ndef dist_pow2(x1, y1, x2, y2): return (x2 - x1)**2 + (y2 - y1)**2\\ndef dist(x1, y1, x2, y2): return dist_pow2(x1, y1, x2, y2)**0.5\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        L, m = len(points), float(\\'inf\\')\\n\\n        quick_search = {(x, y) for x, y in points}\\n\\n        for i in range(L):\\n            for j in range(i + 1, L):\\n                for k in range(j + 1, L):\\n                    x1, y1 = points[i] # calculate point4 to form a diamond by previous three\\n                    x2, y2 = points[j] # we only check case when x4 is latter occured than x3\\n                    x3, y3 = points[k] # becourse the case when x4 is earlier occured than x3 will be covered already\\n                    x4, y4 = (x3 + (x2 - x1), y3 + (y2 - y1))\\n\\n                    if (x4, y4) in quick_search:  # look for existence of dimond shape\\n                        # if two diagonals\\' length are equal, we got a rectangel\\n                        if dist_pow2(x1, y1, x4, y4) == dist_pow2(x2, y2, x3, y3):\\n                            # calculate area by multipling any two adjacent edge\\'s length\\n                            area = dist(x1, y1, x2, y2) * dist(x1, y1, x3, y3)\\n                            m = min(m, area)  # keep track of min_area\\n\\n        return m if m != float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192431,
                "title": "python-beats-100-diagonals-in-hashmap",
                "content": "Can we identify a rectangle by looking at its diagonals? If 2 diagonals form a rectangle, they must be bisecting each other and be of equal length. We can use this property to store midpoint and length in a dictionary and then whenever we observe another line (diagonal), it would form a rectangle with all such other diagonals. The code will make things more clear.  \\n\\n```\\nclass Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        \\n        def area(p1,p2,p3):\\n            l1 = (p1[0]-p3[0])**2 + (p1[1]-p3[1])**2\\n            l2 = (p2[0]-p3[0])**2 + (p2[1]-p3[1])**2\\n            return (l1**0.5) * (l2**0.5)\\n        \\n        n = len(points)\\n        D = {}\\n        min_area = float(\"inf\")\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                x1,y1 = points[i]\\n                x2,y2 = points[j]\\n                middle = ((x1+x2)/2.0, (y1+y2)/2.0)\\n                l = (x2-x1)**2 + (y2-y1)**2\\n                if (middle, l) in D:\\n                    for p in D[(middle,l)]:\\n                        min_area = min(area(points[i], points[j], p), min_area)\\n                    D[(middle, l)].append(points[i])\\n                else:\\n                    D[(middle, l)] = [points[i]]\\n        if min_area == float(\"inf\"):\\n            return 0\\n        return min_area\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        \\n        def area(p1,p2,p3):\\n            l1 = (p1[0]-p3[0])**2 + (p1[1]-p3[1])**2\\n            l2 = (p2[0]-p3[0])**2 + (p2[1]-p3[1])**2\\n            return (l1**0.5) * (l2**0.5)\\n        \\n        n = len(points)\\n        D = {}\\n        min_area = float(\"inf\")\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                x1,y1 = points[i]\\n                x2,y2 = points[j]\\n                middle = ((x1+x2)/2.0, (y1+y2)/2.0)\\n                l = (x2-x1)**2 + (y2-y1)**2\\n                if (middle, l) in D:\\n                    for p in D[(middle,l)]:\\n                        min_area = min(area(points[i], points[j], p), min_area)\\n                    D[(middle, l)].append(points[i])\\n                else:\\n                    D[(middle, l)] = [points[i]]\\n        if min_area == float(\"inf\"):\\n            return 0\\n        return min_area\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 208753,
                "title": "c-8ms-using-map-with-explanation",
                "content": "The basic idea is to use a map, where the key is ```(dx,dy)``` formed by each two points ```(x1,y1)``` and ```(x2,y2)``` where ```dx=x2-x1```, ```dy=y2-y1```, and the value of the key is a list of point ```(x1,y1)``` where a line segment ```(dx,dy)``` can be formed from these points in the entire point set. \\n\\nFor example, if ```Map[{1,0}] = {{0,0}, {0,1}, {1,1}}```, this means that a vector ```(1,0)``` can be formed starting from point ```(0,0)```, ```(0,1)```, and ```(1,1)```. To reduce duplication, the map only takes ```(dx,dy)``` such that ```dx>=0``` and ```dy>=0```. This is because for any rectangular, there must be at least one edge satisfying this condition.\\n\\nThen simply iterate every key of the map, and find if any two starting points under this key can form a rectangular. Specifically, if both ```(x1,y1)``` and ```(x2,y2)``` belong to key ```(dx,dy)```, then the necessary and sufficient condition that they can form a triangle is ```(x2-x1,y2-y1)``` is perpendicular to ```(dx,dy)```, i.e., ```dx*(x2-x1) + dy*(y2-y1)=0```. The area of the rectangular is the outer product of ```(dx,dy)``` and ```(x2-x1, y2-y1)```, or ```|dx*(y2-y1)-dy*(x2-x1)|```.\\n\\nThe time complexity is ```O(n^2) + O(km^2)```, where ```n``` is total number of points, ```k``` is number of possible keys, and ```m``` is average number of points under each key. The first ```O(n^2)``` is due to the process establishing the map. The second ```O(km^2)``` is due to iteration over all the keys.\\n\\nI am having some difficulties computing the second time complixity contribution ```O(km^2)```. Instead, I am considering two cases. In one extreme case that all points are completely randome and no rectangule can be formed, ```n(n-1)/2``` line segments can be formed by the ```n``` points, with half of them having negative slope, hence ```k=n(n-1)/4```; but in this case ```m=1```; hence the second term is ```O(km^2)=O(n^2)```. In another extreme case, all points form a ladder shape, such as ```(0,0),(1,0),(1,0),(1,1),(2,0),(2,1),(3,0),(3,1),...```. In this case, ```k=2n``` for ```(dx,dy)=(1,0),(1,1),(1,2),(1,3),...,(1,n/2), (0,1), (0,2),(0,3),...,(0,n/2)```; the number of points under key ```(1,0)``` is ```n/2```, and ```n/2-1``` under key ```(1,1)```, ```1``` under key ```(1,n/2)```, and ```2``` for ```(0,1)```, ```(0,2)```,```(0,3)```, ... The total operation is ```(n/2)^2+(n/2-1)^2+...+1^2 + (n/2)*2^2 ~ n^3```. Hence the total time complexity in this case is ```O(n^3)```. I guess I can also compute another extreme case: all points forms a 2D grid. But my feeling is that ```O(km^2)``` is between ```O(n^2)``` and ```O(n^3)```.\\n\\nHere is the code\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double find_min_Rec(vector<pair<int,int>> & xy0, int dx, int dy){\\n        int n = xy0.size();\\n        if(n<2) return -1;\\n        double tmp_area, min_area = -1;\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++){\\n                int dx1 = xy0[i].first  - xy0[j].first;\\n                int dy1 = xy0[i].second - xy0[j].second;\\n                if(dx1==0 && dy1==0) continue;\\n                if(dx*dx1+dy*dy1==0){\\n                    tmp_area = abs((double)dx*(double)dy1 - (double)dy*(double)dx1);\\n                    if(min_area<0) min_area = tmp_area;\\n                    else min_area = min(min_area, tmp_area);\\n                }\\n            }\\n        return min_area;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        map<pair<int,int>, vector<pair<int,int>>> lines; //(dx,dy)->(x0,y0)\\n        int n = points.size();\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0]>points[j][0]){\\n                    int dx = points[i][0]-points[j][0];\\n                    int dy = points[i][1]-points[j][1];\\n                    int x0 = points[j][0], y0 = points[j][1];\\n                    if(dy>=0) lines[{dx,dy}].push_back({x0,y0});\\n                } else {\\n                    int dx = points[j][0]-points[i][0];\\n                    int dy = points[j][1]-points[i][1];\\n                    int x0 = points[i][0], y0 = points[i][1];\\n                    if(dy>=0) lines[{dx,dy}].push_back({x0,y0}); \\n                }\\n            }\\n        double minArea = -1;\\n        \\n        for(auto it = lines.begin();it!=lines.end();it++){\\n            double tmp_min_area = find_min_Rec(it->second, it->first.first, it->first.second);\\n            if(tmp_min_area<0) continue;\\n            if(minArea<0) minArea = tmp_min_area;\\n            else minArea = min(tmp_min_area,minArea);\\n        }\\n        \\n        return minArea<0?0:minArea;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```(dx,dy)```\n```(x1,y1)```\n```(x2,y2)```\n```dx=x2-x1```\n```dy=y2-y1```\n```(x1,y1)```\n```(dx,dy)```\n```Map[{1,0}] = {{0,0}, {0,1}, {1,1}}```\n```(1,0)```\n```(0,0)```\n```(0,1)```\n```(1,1)```\n```(dx,dy)```\n```dx>=0```\n```dy>=0```\n```(x1,y1)```\n```(x2,y2)```\n```(dx,dy)```\n```(x2-x1,y2-y1)```\n```(dx,dy)```\n```dx*(x2-x1) + dy*(y2-y1)=0```\n```(dx,dy)```\n```(x2-x1, y2-y1)```\n```|dx*(y2-y1)-dy*(x2-x1)|```\n```O(n^2) + O(km^2)```\n```n```\n```k```\n```m```\n```O(n^2)```\n```O(km^2)```\n```O(km^2)```\n```n(n-1)/2```\n```n```\n```k=n(n-1)/4```\n```m=1```\n```O(km^2)=O(n^2)```\n```(0,0),(1,0),(1,0),(1,1),(2,0),(2,1),(3,0),(3,1),...```\n```k=2n```\n```(dx,dy)=(1,0),(1,1),(1,2),(1,3),...,(1,n/2), (0,1), (0,2),(0,3),...,(0,n/2)```\n```(1,0)```\n```n/2```\n```n/2-1```\n```(1,1)```\n```1```\n```(1,n/2)```\n```2```\n```(0,1)```\n```(0,2)```\n```(0,3)```\n```(n/2)^2+(n/2-1)^2+...+1^2 + (n/2)*2^2 ~ n^3```\n```O(n^3)```\n```O(km^2)```\n```O(n^2)```\n```O(n^3)```\n```\\nclass Solution {\\npublic:\\n    double find_min_Rec(vector<pair<int,int>> & xy0, int dx, int dy){\\n        int n = xy0.size();\\n        if(n<2) return -1;\\n        double tmp_area, min_area = -1;\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++){\\n                int dx1 = xy0[i].first  - xy0[j].first;\\n                int dy1 = xy0[i].second - xy0[j].second;\\n                if(dx1==0 && dy1==0) continue;\\n                if(dx*dx1+dy*dy1==0){\\n                    tmp_area = abs((double)dx*(double)dy1 - (double)dy*(double)dx1);\\n                    if(min_area<0) min_area = tmp_area;\\n                    else min_area = min(min_area, tmp_area);\\n                }\\n            }\\n        return min_area;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        map<pair<int,int>, vector<pair<int,int>>> lines; //(dx,dy)->(x0,y0)\\n        int n = points.size();\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0]>points[j][0]){\\n                    int dx = points[i][0]-points[j][0];\\n                    int dy = points[i][1]-points[j][1];\\n                    int x0 = points[j][0], y0 = points[j][1];\\n                    if(dy>=0) lines[{dx,dy}].push_back({x0,y0});\\n                } else {\\n                    int dx = points[j][0]-points[i][0];\\n                    int dy = points[j][1]-points[i][1];\\n                    int x0 = points[i][0], y0 = points[i][1];\\n                    if(dy>=0) lines[{dx,dy}].push_back({x0,y0}); \\n                }\\n            }\\n        double minArea = -1;\\n        \\n        for(auto it = lines.begin();it!=lines.end();it++){\\n            double tmp_min_area = find_min_Rec(it->second, it->first.first, it->first.second);\\n            if(tmp_min_area<0) continue;\\n            if(minArea<0) minArea = tmp_min_area;\\n            else minArea = min(tmp_min_area,minArea);\\n        }\\n        \\n        return minArea<0?0:minArea;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292911,
                "title": "c-a-little-complicated-but-easy-to-understand-solution",
                "content": "This is a O(N^2LogN) solution.\\n\\nEnumerate the diagonal of the rectangle, find all diagonal with the same mid-point and length, those are two diagonal that can make a rectangle. Then calculate the size from there.  \\n\\nUse a map to group by mid point of diagonal, and another multimap to group by the length.\\n\\n```\\nclass Solution {\\npublic:    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        long ans = LONG_MAX;\\n        // map<mid_point, map<length, vector>>\\n        map<vector<long>, multimap<long, vector<int>>> db;\\n        for (auto i = points.begin(); i != points.end(); i++) {\\n            for (auto j = i+1; j != points.end(); j++) {\\n                if (i == j) continue;\\n                \\n                long x1 = j->at(0) - i->at(0);\\n                long y1 = j->at(1) - i->at(1);\\n                \\n                long length = x1 * x1 + y1 * y1;\\n\\n                vector<long> mid = {i->at(0) + j->at(0), i->at(1) + j->at(1)};\\n                \\n                if (db.find(mid) == db.end()) {\\n                    db.insert(std::make_pair(mid, multimap<long, vector<int>>()));\\n                }\\n                \\n                auto &m = (db.find(mid))->second;\\n                if (m.find(length) != m.end()) {\\n                    auto p = m.equal_range(length);\\n                    for (auto k = p.first; k != p.second; k++) {\\n                        ans = std::min(ans, std::abs(x1 * k->second.at(1) - y1 * k->second.at(0)));\\n                    }\\n                }\\n                m.insert(std::make_pair(length, vector<int>{int(x1), int(y1)}));\\n            }\\n        }\\n        return ans == LONG_MAX ? 0 : ans / 2;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        long ans = LONG_MAX;\\n        // map<mid_point, map<length, vector>>\\n        map<vector<long>, multimap<long, vector<int>>> db;\\n        for (auto i = points.begin(); i != points.end(); i++) {\\n            for (auto j = i+1; j != points.end(); j++) {\\n                if (i == j) continue;\\n                \\n                long x1 = j->at(0) - i->at(0);\\n                long y1 = j->at(1) - i->at(1);\\n                \\n                long length = x1 * x1 + y1 * y1;\\n\\n                vector<long> mid = {i->at(0) + j->at(0), i->at(1) + j->at(1)};\\n                \\n                if (db.find(mid) == db.end()) {\\n                    db.insert(std::make_pair(mid, multimap<long, vector<int>>()));\\n                }\\n                \\n                auto &m = (db.find(mid))->second;\\n                if (m.find(length) != m.end()) {\\n                    auto p = m.equal_range(length);\\n                    for (auto k = p.first; k != p.second; k++) {\\n                        ans = std::min(ans, std::abs(x1 * k->second.at(1) - y1 * k->second.at(0)));\\n                    }\\n                }\\n                m.insert(std::make_pair(length, vector<int>{int(x1), int(y1)}));\\n            }\\n        }\\n        return ans == LONG_MAX ? 0 : ans / 2;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079184,
                "title": "super-easy-to-understand-c-o-n-3logn-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dot_product(vector<int> &a, vector<int> &b, vector<int> &c){\\n        return (b[0] - a[0]) * (c[0] - b[0]) + (b[1] - a[1]) * (c[1] - b[1]);\\n    }\\n    vector<int> get_fourth_point(vector<int> &a, vector<int> &b, vector<int> &c){\\n        int x = a[0] + (c[0] - b[0]);\\n        int y = a[1] + (c[1] - b[1]);\\n        return {x, y};\\n    }\\n    double get_area(vector<int> &a, vector<int> &b, vector<int> &c, vector<int> &d){\\n        double x1 = b[0] - a[0];\\n        double y1 = b[1] - a[1];\\n        double x2 = c[0] - b[0];\\n        double y2 = c[1] - b[1];\\n        \\n        return sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2);\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        map<vector<int>, bool> point_exists;\\n        double res = INT_MAX;\\n        bool rectangle_exists = false;\\n        int n = points.size();\\n        sort(points.begin(), points.end());\\n        for(auto i : points) point_exists[i] = 1;\\n        for(int i = 0;i < n;i++){\\n            for(int j = i + 1;j < n;j++){\\n                for(int k = j + 1;k < n;k++){\\n                    vector<int> a = points[i];\\n                    vector<int> b = points[j];\\n                    vector<int> c = points[k];\\n                    if(dot_product(a, b, c)) continue; // check if vectors AB and BC are perpendicular\\n                    vector<int> d = get_fourth_point(a, b, c); // check if there exists point D such that ABCD is rectangle\\n                    if(point_exists[d]){\\n                        res = min(res, get_area(a, b, c, d));\\n                        rectangle_exists = true;\\n                    }\\n                }\\n            }\\n        }\\n        return rectangle_exists * res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool dot_product(vector<int> &a, vector<int> &b, vector<int> &c){\\n        return (b[0] - a[0]) * (c[0] - b[0]) + (b[1] - a[1]) * (c[1] - b[1]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1004532,
                "title": "python-concise-explained-solution-dhruv-vavliya",
                "content": "```\\n# written by : Dhruv Vavliya\\n\\n\\'\\'\\'\\nthe distance between point1 and point2 equals the distance between point3 and point4\\nthe midpoint of point1 and point2 equals the midpoint of point3 and point4.\\n\\'\\'\\'\\n\\npoints =[[2,4],[4,2],[1,0],[3,4],[4,4],[2,2],[1,1],[3,0],[1,4],[0,3],[0,1],[2,1],[4,0]]\\n\\n\\ndef rect_area(points):\\n    from collections import defaultdict\\n    import math\\n    dp = defaultdict(list)\\n\\n    for i in range(len(points) - 1):\\n        for j in range(i + 1, len(points)):\\n            l = (points[j][1] - points[i][1]) ** 2 + (points[j][0] - points[i][0]) ** 2  # distance\\n            x = (points[i][0] + points[j][0]) / 2                                        # midpoint (x,y)\\n            y = (points[i][1] + points[j][1]) / 2\\n            dp[(l, x, y)].append((i, j))\\n\\n    print(dp)\\n\\n    ans = float(\\'inf\\')\\n    for line in dp.values():\\n        for i in range(len(line) - 1):\\n            p0, p2 = points[line[i][0]] ,points[line[i][1]]     \\n            for j in range(i + 1, len(line)):\\n                p1, p3 = points[line[j][0]], points[line[j][1]]\\n                d1 = math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)    # two adjacent sides\\n                d2 = math.sqrt((p0[0] - p3[0]) ** 2 + (p0[1] - p3[1]) ** 2)\\n                ans = min(ans, d1 * d2)\\n\\n    if ans != float(\\'inf\\'):\\n        return ans\\n    else:\\n        return 0\\n\\n\\nprint(rect_area(points))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# written by : Dhruv Vavliya\\n\\n\\'\\'\\'\\nthe distance between point1 and point2 equals the distance between point3 and point4\\nthe midpoint of point1 and point2 equals the midpoint of point3 and point4.\\n\\'\\'\\'\\n\\npoints =[[2,4],[4,2],[1,0],[3,4],[4,4],[2,2],[1,1],[3,0],[1,4],[0,3],[0,1],[2,1],[4,0]]\\n\\n\\ndef rect_area(points):\\n    from collections import defaultdict\\n    import math\\n    dp = defaultdict(list)\\n\\n    for i in range(len(points) - 1):\\n        for j in range(i + 1, len(points)):\\n            l = (points[j][1] - points[i][1]) ** 2 + (points[j][0] - points[i][0]) ** 2  # distance\\n            x = (points[i][0] + points[j][0]) / 2                                        # midpoint (x,y)\\n            y = (points[i][1] + points[j][1]) / 2\\n            dp[(l, x, y)].append((i, j))\\n\\n    print(dp)\\n\\n    ans = float(\\'inf\\')\\n    for line in dp.values():\\n        for i in range(len(line) - 1):\\n            p0, p2 = points[line[i][0]] ,points[line[i][1]]     \\n            for j in range(i + 1, len(line)):\\n                p1, p3 = points[line[j][0]], points[line[j][1]]\\n                d1 = math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)    # two adjacent sides\\n                d2 = math.sqrt((p0[0] - p3[0]) ** 2 + (p0[1] - p3[1]) ** 2)\\n                ans = min(ans, d1 * d2)\\n\\n    if ans != float(\\'inf\\'):\\n        return ans\\n    else:\\n        return 0\\n\\n\\nprint(rect_area(points))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 880414,
                "title": "java-100-cpu-100-memory-o-n-3-area-function",
                "content": "**Steps to solve this**\\n1.   Fix the *first* point in the given list and see if it can be used to form a rectangle // loop (1)\\n2.   Fix the *second* point on the right of \"First\" point and check if it can be used for form a rectangle loop (2)\\n3.   Fix the *third* point to the right of \"Second\" and see if they form a Rectangle\\n\\t3.b Exception to this rule are if points form a straight line will make rectangle with Zero area\\n4.  Calculate the area that these points form\\n             |\\n\\t\\t\\t |\\n\\t\\t\\t |____________________\\n\\t\\t\\t \\n\\t\\t\\t In the above (x1,y1) (x2,y2) (x3,y3) = We can find the length and width that makes area\\n5. Calculate the area formed by three points \\n  5.a Using the Length and Width\\n  5.b Using the points - Core maths function implemented in code calculateArea(int[][] points, int i, int j, int k)\\n\\n\\tNote: What we have?\\n\\t  a. Three points\\n\\t  b. Area three points forming\\n\\t  c. Minimum area rectangle seen till now\\n  \\n6. Last check to perform?\\n  Does the \"Fourth\" point exists in the List of points?\\n  \\n7. Yes? Update the Tracked Minimum\\n6. \\n\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        double area;\\n        \\n        for(int[] point: points){\\n            if(!map.containsKey(point[0])){\\n                map.put(point[0], new HashSet<>());\\n            }            \\n            map.get(point[0]).add(point[1]);\\n        }//end of for\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        int n = points.length;\\n        \\n        for(int i=0; i<n -2; i++){\\n            for(int j=i+1; j<n - 1; j++){\\n                int dx1 = points[j][0] - points[i][0];\\n                int dy1 = points[j][1] - points[i][1];\\n                //get the 3rd point\\n                for(int k = j+1; k<n; k++){\\n                    int dx2 = points[k][0] - points[i][0];\\n                    int dy2 = points[k][1] - points[i][1];\\n                    \\n                    if(dx1*dx2 + dy1*dy2 != 0){\\n                        continue;\\n                    }\\n                    //find the 4th point\\n                    int x = dx1 + points[k][0];\\n                    int y = dy1 + points[k][1];\\n                    \\n                    area = calculateArea(points, i, j, k);\\n                    if(area >= minArea){\\n                        continue;\\n                    }\\n                    //4th point exists\\n                    if(map.get(x) != null && map.get(x).contains(y)){\\n                        minArea = area;\\n                    }\\n                }\\n            }\\n        }\\n        return minArea == Double.MAX_VALUE ? 0.0 : minArea;\\n    }\\n    \\n    private double calculateArea(int[][] points, int i, int j, int k) {\\n        int[] first = points[i];\\n        int[] second = points[j];\\n        int[] third = points[k];\\n        return Math.abs((first[0] * (second[1] - third[1])) +\\n                (second[0] * (third[1] - first[1])) + \\n            (third[0] * (first[1] - second[1])));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        double area;\\n        \\n        for(int[] point: points){\\n            if(!map.containsKey(point[0])){\\n                map.put(point[0], new HashSet<>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 536801,
                "title": "python",
                "content": "Same idea as the solution, without using `complex`\\n\\n**Python**\\n```py\\nclass Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = set(map(tuple, points))\\n        \\n        def vector_len(a):\\n            return math.sqrt(a[0]**2 + a[1]**2)\\n        \\n        ans = float(\"inf\")\\n        for p1, p2, p3 in itertools.permutations(points, 3):\\n            p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1]\\n            if p4 in points:\\n                v21 = (p2[0] - p1[0], p2[1] - p1[1])\\n                v31 = (p3[0] - p1[0], p3[1] - p1[1])\\n                if abs(v21[0] * v31[0] + v21[1] * v31[1]) == 0:\\n                    area = vector_len(v21) * vector_len(v31)\\n                    if area < ans:\\n                        ans = area\\n        \\n        return ans if ans < float(\"inf\") else 0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = set(map(tuple, points))\\n        \\n        def vector_len(a):\\n            return math.sqrt(a[0]**2 + a[1]**2)\\n        \\n        ans = float(\"inf\")\\n        for p1, p2, p3 in itertools.permutations(points, 3):\\n            p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1]\\n            if p4 in points:\\n                v21 = (p2[0] - p1[0], p2[1] - p1[1])\\n                v31 = (p3[0] - p1[0], p3[1] - p1[1])\\n                if abs(v21[0] * v31[0] + v21[1] * v31[1]) == 0:\\n                    area = vector_len(v21) * vector_len(v31)\\n                    if area < ans:\\n                        ans = area\\n        \\n        return ans if ans < float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282378,
                "title": "python-o-n-2-logn-avoid-divide-operation",
                "content": "We can avoid division operation and use pure vector operation to solve this problem\\n\\nSome pre-knowledge\\n\\n1. Cross Product --->  c_prod(v1, v2) = x1*y2 - x2*y1\\n2. Area formula in Coordinates ---->area(v1, v2) = abs(c_prod)  (v1, v2 is the vector of 2 vertical edge of the rectangle)\\n3. Middle point formula ----> mid(p1, p2) = ((x1+x2)/2, (y1+y2)/2)\\n4. Distance formula ----> dist(p1, p2) = SQRT ( (x1-x2)\\\\**2 + (y1-y2)\\\\**2 )\\n\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        from collections import defaultdict\\n        \\n        dic = defaultdict(list)\\n        \\n        for i in range(len(points)-1):\\n            for j in range(i+1, len(points)):\\n                pi = points[i]\\n                pj = points[j]\\n                \\n                mx, my = (pi[0] + pj[0], pi[1] + pj[1])\\n                \\n                dia_sq = (pi[0] - pj[0]) ** 2 + (pi[1] - pj[1]) ** 2\\n                \\n                dic[mx, my, dia_sq].append(pi)\\n        \\n        ans = float(\\'inf\\')\\n                        \\n        for (mx, my, _), lst in dic.items():\\n            for i in range(len(lst)-1):\\n                for j in range(i+1, len(lst)):\\n                    pi = lst[i]\\n                    pj = lst[j]\\n                    \\n                    neg_pj = [mx - pj[0], my - pj[1]]\\n                    \\n                    x1, y1 = pj[0] - pi[0], pj[1] - pi[1]\\n                    x2, y2 = neg_pj[0] - pi[0], neg_pj[1] - pi[1]\\n                                        \\n                    area = abs(x1 * y2 - x2 * y1)\\n                    \\n                    ans = min(area, ans)\\n                    \\n        return float(ans) if ans != float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        from collections import defaultdict\\n        \\n        dic = defaultdict(list)\\n        \\n        for i in range(len(points)-1):\\n            for j in range(i+1, len(points)):\\n                pi = points[i]\\n                pj = points[j]\\n                \\n                mx, my = (pi[0] + pj[0], pi[1] + pj[1])\\n                \\n                dia_sq = (pi[0] - pj[0]) ** 2 + (pi[1] - pj[1]) ** 2\\n                \\n                dic[mx, my, dia_sq].append(pi)\\n        \\n        ans = float(\\'inf\\')\\n                        \\n        for (mx, my, _), lst in dic.items():\\n            for i in range(len(lst)-1):\\n                for j in range(i+1, len(lst)):\\n                    pi = lst[i]\\n                    pj = lst[j]\\n                    \\n                    neg_pj = [mx - pj[0], my - pj[1]]\\n                    \\n                    x1, y1 = pj[0] - pi[0], pj[1] - pi[1]\\n                    x2, y2 = neg_pj[0] - pi[0], neg_pj[1] - pi[1]\\n                                        \\n                    area = abs(x1 * y2 - x2 * y1)\\n                    \\n                    ans = min(area, ans)\\n                    \\n        return float(ans) if ans != float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227068,
                "title": "js-beats-100-with-172-ms-while-existing-fastest-solution-takes-1016ms",
                "content": "The idea is to check if first 3 points constructs a right triangle, if yes, we will then try to find the fouth point easily with the info which point is the right angle point.\\n```\\nfunction distance2([x1, y1], [x2, y2]) {\\n    return (x2 - x1) ** 2 + (y2 - y1) ** 2;\\n}\\n\\nfunction rightTriangle(p1, p2, p3) {\\n    const s12 = distance2(p1, p2);\\n    const s23 = distance2(p2, p3);\\n    const s13 = distance2(p1, p3);\\n    if (s12 + s23 === s13) return [p2, p1, p3];\\n    if (s23 + s13 === s12) return [p3, p1, p2];\\n    if (s13 + s12 === s23) return [p1, p2, p3];\\n    return null;\\n}\\n\\nfunction fourthPoint([[xr, yr], [x1, y1], [x2, y2]]) {\\n    return [x1 + x2 - xr, y1 + y2 - yr];\\n}\\n\\nfunction area([pr, p1, p2]) {\\n    return distance2(pr, p1) * distance2(pr, p2);\\n}\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    const set = new Set(points.map(p => p.join(\\',\\')));\\n    let min = Infinity;\\n    const N = points.length;\\n    for (let i = 0; i < N; i++) {\\n        const pi = points[i];\\n        for (let j = i + 1; j < N; j++) {\\n            const pj = points[j];\\n            for (let k = j + 1; k < N; k++) {\\n                const pk = points[k];\\n                const rt = rightTriangle(pi, pj, pk);\\n                if (rt) {\\n                    const fourth = fourthPoint(rt);\\n                    if (set.has(fourth.join(\\',\\'))) {\\n                        min = Math.min(min, area(rt));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return min === Infinity ? 0 : Math.sqrt(min);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction distance2([x1, y1], [x2, y2]) {\\n    return (x2 - x1) ** 2 + (y2 - y1) ** 2;\\n}\\n\\nfunction rightTriangle(p1, p2, p3) {\\n    const s12 = distance2(p1, p2);\\n    const s23 = distance2(p2, p3);\\n    const s13 = distance2(p1, p3);\\n    if (s12 + s23 === s13) return [p2, p1, p3];\\n    if (s23 + s13 === s12) return [p3, p1, p2];\\n    if (s13 + s12 === s23) return [p1, p2, p3];\\n    return null;\\n}\\n\\nfunction fourthPoint([[xr, yr], [x1, y1], [x2, y2]]) {\\n    return [x1 + x2 - xr, y1 + y2 - yr];\\n}\\n\\nfunction area([pr, p1, p2]) {\\n    return distance2(pr, p1) * distance2(pr, p2);\\n}\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    const set = new Set(points.map(p => p.join(\\',\\')));\\n    let min = Infinity;\\n    const N = points.length;\\n    for (let i = 0; i < N; i++) {\\n        const pi = points[i];\\n        for (let j = i + 1; j < N; j++) {\\n            const pj = points[j];\\n            for (let k = j + 1; k < N; k++) {\\n                const pk = points[k];\\n                const rt = rightTriangle(pi, pj, pk);\\n                if (rt) {\\n                    const fourth = fourthPoint(rt);\\n                    if (set.has(fourth.join(\\',\\'))) {\\n                        min = Math.min(min, area(rt));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return min === Infinity ? 0 : Math.sqrt(min);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208329,
                "title": "java-o-n-3-solution",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer,Set<Integer>> map = new HashMap<>();\\n        for (int[] p : points){\\n            map.putIfAbsent(p[0], new HashSet<>());\\n            map.get(p[0]).add(p[1]);\\n        }\\n        double min = Double.MAX_VALUE;\\n        int n = points.length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = i + 1; j < n; j++){\\n                for (int k = j + 1; k < n; k++){\\n                    int[] p1 = points[i], p2 = points[j], p3 = points[k];\\n                    if (ver(p1, p2, p3)){\\n                        int[] temp = p4(p1, p2, p3);\\n                        if (map.containsKey(temp[0]) && map.get(temp[0]).contains(temp[1])){\\n                            min = Math.min(min, area(p1, p2, p3));\\n                        }\\n                    }\\n                    if (ver(p2, p1, p3)){\\n                        int[] temp1 = p4(p2, p1, p3);\\n                        if (map.containsKey(temp1[0]) && map.get(temp1[0]).contains(temp1[1])){\\n                            min = Math.min(min, area(p2, p1, p3));\\n                        }\\n                    }\\n                    if (ver(p3, p2, p1)){\\n                        int[] temp2 = p4(p3, p2, p1);\\n                        if (map.containsKey(temp2[0]) && map.get(temp2[0]).contains(temp2[1])){\\n                            min = Math.min(min, area(p3, p2, p1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n    public int[] p4(int[] p1, int[] p2, int[] p3){ // find point p4 \\n        return new int[]{p3[0] - p1[0] + p2[0], p3[1] - p1[1] + p2[1]};\\n    }\\n    public boolean ver(int[] p1, int[] p2, int[] p3){//detemine vector p1p2 and vector p1p3 are vertical or not\\n        int x1 = p2[0] - p1[0], y1 = p2[1] - p1[1];\\n        int x2 = p3[0] - p1[0], y2 = p3[1] - p1[1];\\n        return x1 * x2 + y1 * y2 == 0;\\n    }\\n    public double area(int[] p1, int[] p2, int[] p3){\\n        int x1 = p2[0] - p1[0], y1 = p2[1] - p1[1];\\n        int x2 = p3[0] - p1[0], y2 = p3[1] - p1[1];\\n        return Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer,Set<Integer>> map = new HashMap<>();\\n        for (int[] p : points){\\n            map.putIfAbsent(p[0], new HashSet<>());\\n            map.get(p[0]).add(p[1]);\\n        }\\n        double min = Double.MAX_VALUE;\\n        int n = points.length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = i + 1; j < n; j++){\\n                for (int k = j + 1; k < n; k++){\\n                    int[] p1 = points[i], p2 = points[j], p3 = points[k];\\n                    if (ver(p1, p2, p3)){\\n                        int[] temp = p4(p1, p2, p3);\\n                        if (map.containsKey(temp[0]) && map.get(temp[0]).contains(temp[1])){\\n                            min = Math.min(min, area(p1, p2, p3));\\n                        }\\n                    }\\n                    if (ver(p2, p1, p3)){\\n                        int[] temp1 = p4(p2, p1, p3);\\n                        if (map.containsKey(temp1[0]) && map.get(temp1[0]).contains(temp1[1])){\\n                            min = Math.min(min, area(p2, p1, p3));\\n                        }\\n                    }\\n                    if (ver(p3, p2, p1)){\\n                        int[] temp2 = p4(p3, p2, p1);\\n                        if (map.containsKey(temp2[0]) && map.get(temp2[0]).contains(temp2[1])){\\n                            min = Math.min(min, area(p3, p2, p1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n    public int[] p4(int[] p1, int[] p2, int[] p3){ // find point p4 \\n        return new int[]{p3[0] - p1[0] + p2[0], p3[1] - p1[1] + p2[1]};\\n    }\\n    public boolean ver(int[] p1, int[] p2, int[] p3){//detemine vector p1p2 and vector p1p3 are vertical or not\\n        int x1 = p2[0] - p1[0], y1 = p2[1] - p1[1];\\n        int x2 = p3[0] - p1[0], y2 = p3[1] - p1[1];\\n        return x1 * x2 + y1 * y2 == 0;\\n    }\\n    public double area(int[] p1, int[] p2, int[] p3){\\n        int x1 = p2[0] - p1[0], y1 = p2[1] - p1[1];\\n        int x2 = p3[0] - p1[0], y2 = p3[1] - p1[1];\\n        return Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530807,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double _Area, minArea = 0.0;\\n        if (points.size() < 4){\\n            return 0;\\n        }\\n        int x0, y0;\\n        int x1, y1;\\n        int x2, y2;\\n        int x3, y3;\\n        int Lx1, Ly1;\\n        int Lx2, Ly2;\\n        for(int i = 0; i < points.size() - 3; i ++){\\n\\n            x0 = points[i][0];\\n            y0 = points[i][1];\\n\\n            for (int j = i + 1; j < points.size(); j ++){\\n                x1 = points[j][0];\\n                y1 = points[j][1];\\n                for (int k = j + 1; k < points.size(); k ++){\\n                    x2 = points[k][0];\\n                    y2 = points[k][1];\\n\\n                    Lx1 = x1 - x0;\\n                    Ly1 = y1 - y0;\\n                    \\n                    Lx2 = x2 - x0;\\n                    Ly2 = y2 - y0;\\n\\n                    int dotProd = Lx1 * Lx2 + Ly1 * Ly2;\\n                    if (dotProd != 0){\\n                        continue;\\n                    }\\n                    bool skip = true;\\n                    for (int n = 0; n < points.size(); n ++){\\n                        x3 = points[n][0];\\n                        y3 = points[n][1];\\n                        if ((x3 == x0 + Lx1 + Lx2) && (y3 == y0 + Ly1 + Ly2)){\\n                            skip = false;\\n                            break;\\n                        }\\n                    }\\n                    if(skip == true){\\n                        continue;\\n                    }\\n                    _Area = (double)abs(Lx1 * Ly2 - Ly1 * Lx2);\\n\\n                    if (minArea == 0.0){\\n                        minArea = _Area; \\n                    }else{\\n                        minArea = minArea < _Area ? minArea : _Area;\\n                    }\\n                }\\n            }\\n        }\\n        return minArea;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        x, y = 0, 1\\n        vec = lambda p, q: [q[x]-p[x], q[y]-p[y]]\\n        area = lambda p,q: p[x]*q[y] - p[y]*q[x]\\n        dist = lambda p,q: (p[x]-q[x])**2 + (p[y]-q[y])**2\\n        mid_to_diagonals = defaultdict(list)\\n        for p,q in combinations(points, 2):\\n            key = p[x] + q[x], p[y] + q[y]\\n            mid_to_diagonals[key].append((p,q))\\n        res = float(\\'inf\\')\\n        for group in mid_to_diagonals.values():\\n            for (a,b), (c,d) in combinations(group, 2):\\n                if dist(a,b) == dist(c,d):\\n                    res = min(res, abs(area(vec(a,b), vec(a,d))))\\n        return res if res != float(\\'inf\\') else 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        HashSet<Point> pointsSet = new HashSet<>();\\n        for (int i = 0; i < points.length; i++) {\\n            pointsSet.add(new Point(points[i][0], points[i][1]));\\n        }\\n        double minSq = 2.0 * (double)Long.MAX_VALUE;\\n        boolean hasRects = false;\\n        for (int i2 = 0; i2 < points.length; i2++) {\\n            for (int i1 = i2 + 1; i1 < points.length; i1++) {\\n                long d12 = d2(points[i1], points[i2]);\\n                for (int i3 = i1 + 1; i3 < points.length; i3++) {\\n                    long d23 = d2(points[i2], points[i3]);\\n                    if (d12 + d23 != d2(points[i1], points[i3])) {\\n                        continue;\\n                    }\\n                    if (pointsSet.contains(new Point(points[i1][0] + points[i3][0] - points[i2][0], points[i1][1] + points[i3][1] - points[i2][1]))) {\\n                        hasRects = true;\\n                        minSq = Math.min(minSq, d12 * d23);\\n                    }\\n                }\\n            }\\n        }\\n        return hasRects ? Math.sqrt(minSq) : 0.0;\\n    }\\n    private long d2(int[] p1, int[] p2) {\\n        return ((long)p2[0] - (long)p1[0]) * ((long)p2[0] - (long)p1[0]) + ((long)p2[1] - (long)p1[1]) * ((long)p2[1] - (long)p1[1]);\\n    }\\n    private static class Point{\\n        int x;\\n        int y;\\n\\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            return x + y * 13;\\n        }\\n        @Override\\n        public boolean equals(Object other) {\\n            Point otherPoint = (Point)other;\\n\\n            return otherPoint.x == x && otherPoint.y == y;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double _Area, minArea = 0.0;\\n        if (points.size() < 4){\\n            return 0;\\n        }\\n        int x0, y0;\\n        int x1, y1;\\n        int x2, y2;\\n        int x3, y3;\\n        int Lx1, Ly1;\\n        int Lx2, Ly2;\\n        for(int i = 0; i < points.size() - 3; i ++){\\n\\n            x0 = points[i][0];\\n            y0 = points[i][1];\\n\\n            for (int j = i + 1; j < points.size(); j ++){\\n                x1 = points[j][0];\\n                y1 = points[j][1];\\n                for (int k = j + 1; k < points.size(); k ++){\\n                    x2 = points[k][0];\\n                    y2 = points[k][1];\\n\\n                    Lx1 = x1 - x0;\\n                    Ly1 = y1 - y0;\\n                    \\n                    Lx2 = x2 - x0;\\n                    Ly2 = y2 - y0;\\n\\n                    int dotProd = Lx1 * Lx2 + Ly1 * Ly2;\\n                    if (dotProd != 0){\\n                        continue;\\n                    }\\n                    bool skip = true;\\n                    for (int n = 0; n < points.size(); n ++){\\n                        x3 = points[n][0];\\n                        y3 = points[n][1];\\n                        if ((x3 == x0 + Lx1 + Lx2) && (y3 == y0 + Ly1 + Ly2)){\\n                            skip = false;\\n                            break;\\n                        }\\n                    }\\n                    if(skip == true){\\n                        continue;\\n                    }\\n                    _Area = (double)abs(Lx1 * Ly2 - Ly1 * Lx2);\\n\\n                    if (minArea == 0.0){\\n                        minArea = _Area; \\n                    }else{\\n                        minArea = minArea < _Area ? minArea : _Area;\\n                    }\\n                }\\n            }\\n        }\\n        return minArea;\\n    }\\n};\\n```\n```Python3 []\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        x, y = 0, 1\\n        vec = lambda p, q: [q[x]-p[x], q[y]-p[y]]\\n        area = lambda p,q: p[x]*q[y] - p[y]*q[x]\\n        dist = lambda p,q: (p[x]-q[x])**2 + (p[y]-q[y])**2\\n        mid_to_diagonals = defaultdict(list)\\n        for p,q in combinations(points, 2):\\n            key = p[x] + q[x], p[y] + q[y]\\n            mid_to_diagonals[key].append((p,q))\\n        res = float(\\'inf\\')\\n        for group in mid_to_diagonals.values():\\n            for (a,b), (c,d) in combinations(group, 2):\\n                if dist(a,b) == dist(c,d):\\n                    res = min(res, abs(area(vec(a,b), vec(a,d))))\\n        return res if res != float(\\'inf\\') else 0\\n```\n```Java []\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        HashSet<Point> pointsSet = new HashSet<>();\\n        for (int i = 0; i < points.length; i++) {\\n            pointsSet.add(new Point(points[i][0], points[i][1]));\\n        }\\n        double minSq = 2.0 * (double)Long.MAX_VALUE;\\n        boolean hasRects = false;\\n        for (int i2 = 0; i2 < points.length; i2++) {\\n            for (int i1 = i2 + 1; i1 < points.length; i1++) {\\n                long d12 = d2(points[i1], points[i2]);\\n                for (int i3 = i1 + 1; i3 < points.length; i3++) {\\n                    long d23 = d2(points[i2], points[i3]);\\n                    if (d12 + d23 != d2(points[i1], points[i3])) {\\n                        continue;\\n                    }\\n                    if (pointsSet.contains(new Point(points[i1][0] + points[i3][0] - points[i2][0], points[i1][1] + points[i3][1] - points[i2][1]))) {\\n                        hasRects = true;\\n                        minSq = Math.min(minSq, d12 * d23);\\n                    }\\n                }\\n            }\\n        }\\n        return hasRects ? Math.sqrt(minSq) : 0.0;\\n    }\\n    private long d2(int[] p1, int[] p2) {\\n        return ((long)p2[0] - (long)p1[0]) * ((long)p2[0] - (long)p1[0]) + ((long)p2[1] - (long)p1[1]) * ((long)p2[1] - (long)p1[1]);\\n    }\\n    private static class Point{\\n        int x;\\n        int y;\\n\\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            return x + y * 13;\\n        }\\n        @Override\\n        public boolean equals(Object other) {\\n            Point otherPoint = (Point)other;\\n\\n            return otherPoint.x == x && otherPoint.y == y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714123,
                "title": "python-center-points",
                "content": "```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        x, y = 0, 1\\n        vec = lambda p, q: [q[x]-p[x], q[y]-p[y]]\\n        area = lambda p,q: p[x]*q[y] - p[y]*q[x]\\n        dist = lambda p,q: (p[x]-q[x])**2 + (p[y]-q[y])**2\\n        mid_to_diagonals = defaultdict(list)\\n        for p,q in combinations(points, 2):\\n            key = p[x] + q[x], p[y] + q[y]\\n            mid_to_diagonals[key].append((p,q))\\n        res = float(\\'inf\\')\\n        for group in mid_to_diagonals.values():\\n            for (a,b), (c,d) in combinations(group, 2):\\n                if dist(a,b) == dist(c,d):\\n                    res = min(res, abs(area(vec(a,b), vec(a,d))))\\n        return res if res != float(\\'inf\\') else 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        x, y = 0, 1\\n        vec = lambda p, q: [q[x]-p[x], q[y]-p[y]]\\n        area = lambda p,q: p[x]*q[y] - p[y]*q[x]\\n        dist = lambda p,q: (p[x]-q[x])**2 + (p[y]-q[y])**2\\n        mid_to_diagonals = defaultdict(list)\\n        for p,q in combinations(points, 2):\\n            key = p[x] + q[x], p[y] + q[y]\\n            mid_to_diagonals[key].append((p,q))\\n        res = float(\\'inf\\')\\n        for group in mid_to_diagonals.values():\\n            for (a,b), (c,d) in combinations(group, 2):\\n                if dist(a,b) == dist(c,d):\\n                    res = min(res, abs(area(vec(a,b), vec(a,d))))\\n        return res if res != float(\\'inf\\') else 0",
                "codeTag": "Java"
            },
            {
                "id": 2340767,
                "title": "runtime-96-ms-faster-than-97-40-of-python3-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/4714725b-1c75-4f18-b154-de9846fe0776_1658920855.742452.png)\\nRuntime: 96 ms, faster than 97.40% of Python3 online submissions for Minimum Area Rectangle II.\\nMemory Usage: 14.2 MB, less than 55.19% of Python3 online submissions for Minimum Area Rectangle II.\\n\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        N = len(points)\\n        \\n        seen = set()\\n        for point in points:\\n            seen.add(tuple(point))\\n\\n        # length^2\\n        def length2(a, b):\\n            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\\n        \\n        best = 1e30\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                \\n                lij = length2(points[i], points[j])\\n                for k in range(N):\\n                    if i == k or j == k:\\n                        continue\\n                    \\n                    # given i->j line, add to k to find l\\n                    dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1]\\n                    \\n                    pl = (points[k][0] + dx, points[k][1] + dy)\\n                    if pl not in seen:\\n                        continue\\n                    \\n                    lik = length2(points[i], points[k])\\n                    ljk = length2(points[j], points[k])\\n\\n                    lil = length2(points[i], pl)\\n                    ljl = length2(points[j], pl)\\n                    lkl = length2(points[k], pl)\\n                    \\n                    if lij == lkl and lik == ljl and lil == ljk:\\n                        best = min(best, sqrt(lij * lik * lil) / sqrt(max(lij, lik, lil)))\\n                    \\n        if best >= 1e29:\\n            return 0\\n        return best\\n```\\n\\nif you found any doubt .. do mention me in comment section :)\\n\\nhappy to help",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        N = len(points)\\n        \\n        seen = set()\\n        for point in points:\\n            seen.add(tuple(point))\\n\\n        # length^2\\n        def length2(a, b):\\n            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\\n        \\n        best = 1e30\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                \\n                lij = length2(points[i], points[j])\\n                for k in range(N):\\n                    if i == k or j == k:\\n                        continue\\n                    \\n                    # given i->j line, add to k to find l\\n                    dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1]\\n                    \\n                    pl = (points[k][0] + dx, points[k][1] + dy)\\n                    if pl not in seen:\\n                        continue\\n                    \\n                    lik = length2(points[i], points[k])\\n                    ljk = length2(points[j], points[k])\\n\\n                    lil = length2(points[i], pl)\\n                    ljl = length2(points[j], pl)\\n                    lkl = length2(points[k], pl)\\n                    \\n                    if lij == lkl and lik == ljl and lil == ljk:\\n                        best = min(best, sqrt(lij * lik * lil) / sqrt(max(lij, lik, lil)))\\n                    \\n        if best >= 1e29:\\n            return 0\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426272,
                "title": "c-solution",
                "content": "```\\nclass Point{\\npublic:\\n    double x, y;\\n    \\n    Point(double x, double y){\\n        this->x = x;\\n        this->y = y;\\n    }\\n    \\n    double dist(Point *point){\\n        double value_one = point->x - this->x;\\n        double value_two = point->y - this->y;\\n        \\n        return sqrt(pow(value_one, 2) + pow(value_two, 2));\\n    }\\n    \\n    Point *center(Point *point){\\n        double x_center = (point->x + this->x) / 2;\\n        double y_center = (point->y + this->y) / 2;\\n        \\n        Point *centerPoint = new Point(x_center, y_center);\\n        return centerPoint;\\n    }\\n};\\n\\n\\ntypedef unordered_map<string, vector<pair<Point*, Point*>>> diagDT;\\nclass Solution {\\nprivate:\\n    string key(string distance, string centerXY){\\n        return distance + \" -> \" + centerXY;\\n    }\\n    \\n    void fillDiagonalValues(vector<vector<int>> &points, diagDT &diagonals){\\n        for(int i = 0; i < points.size(); i++){\\n            Point *point_one = new Point(points.at(i).at(0), points.at(i).at(1));\\n            \\n            for(int j = i + 1; j < points.size(); j++){\\n                Point *point_two = new Point(points.at(j).at(0), points.at(j).at(1));\\n                           \\n                Point *center   = point_one->center(point_two);\\n                string distance = to_string(point_one->dist(point_two));\\n                string centerXY = to_string(center->x) + \", \" + to_string(center->y);\\n                \\n                diagonals[key(distance, centerXY)].push_back({point_one, point_two});\\n            }\\n        }\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        diagDT diagonals;\\n        fillDiagonalValues(points, diagonals);\\n        \\n        double minArea = INT_MAX;\\n        for(auto iter = diagonals.begin(); iter != diagonals.end(); iter++){\\n           \\n            vector<pair<Point*, Point*>> diagonalPoints = iter->second;\\n            for(int i = 0; i < diagonalPoints.size(); i++){\\n                Point *point_one = diagonalPoints.at(i).first;\\n                Point *point_two = diagonalPoints.at(i).second;\\n                \\n                for(int j = i + 1; j < diagonalPoints.size(); j++){\\n                    Point *point_three = diagonalPoints.at(j).first;\\n                    \\n                    double length = point_one->dist(point_three);\\n                    double width  = point_two->dist(point_three);\\n                    minArea = min(minArea, (length * width));\\n                }\\n            }\\n        }\\n        \\n        return minArea != double(INT_MAX) ? minArea : 0;\\n    }\\n};\\n```\\n\\n**Solution Inspired By :** https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/1214523/Abstracted-and-Elegant-C%2B%2B-Diagonal-Solution and https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/208361/JAVA-O(n2)-using-Map",
                "solutionTags": [],
                "code": "```\\nclass Point{\\npublic:\\n    double x, y;\\n    \\n    Point(double x, double y){\\n        this->x = x;\\n        this->y = y;\\n    }\\n    \\n    double dist(Point *point){\\n        double value_one = point->x - this->x;\\n        double value_two = point->y - this->y;\\n        \\n        return sqrt(pow(value_one, 2) + pow(value_two, 2));\\n    }\\n    \\n    Point *center(Point *point){\\n        double x_center = (point->x + this->x) / 2;\\n        double y_center = (point->y + this->y) / 2;\\n        \\n        Point *centerPoint = new Point(x_center, y_center);\\n        return centerPoint;\\n    }\\n};\\n\\n\\ntypedef unordered_map<string, vector<pair<Point*, Point*>>> diagDT;\\nclass Solution {\\nprivate:\\n    string key(string distance, string centerXY){\\n        return distance + \" -> \" + centerXY;\\n    }\\n    \\n    void fillDiagonalValues(vector<vector<int>> &points, diagDT &diagonals){\\n        for(int i = 0; i < points.size(); i++){\\n            Point *point_one = new Point(points.at(i).at(0), points.at(i).at(1));\\n            \\n            for(int j = i + 1; j < points.size(); j++){\\n                Point *point_two = new Point(points.at(j).at(0), points.at(j).at(1));\\n                           \\n                Point *center   = point_one->center(point_two);\\n                string distance = to_string(point_one->dist(point_two));\\n                string centerXY = to_string(center->x) + \", \" + to_string(center->y);\\n                \\n                diagonals[key(distance, centerXY)].push_back({point_one, point_two});\\n            }\\n        }\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        diagDT diagonals;\\n        fillDiagonalValues(points, diagonals);\\n        \\n        double minArea = INT_MAX;\\n        for(auto iter = diagonals.begin(); iter != diagonals.end(); iter++){\\n           \\n            vector<pair<Point*, Point*>> diagonalPoints = iter->second;\\n            for(int i = 0; i < diagonalPoints.size(); i++){\\n                Point *point_one = diagonalPoints.at(i).first;\\n                Point *point_two = diagonalPoints.at(i).second;\\n                \\n                for(int j = i + 1; j < diagonalPoints.size(); j++){\\n                    Point *point_three = diagonalPoints.at(j).first;\\n                    \\n                    double length = point_one->dist(point_three);\\n                    double width  = point_two->dist(point_three);\\n                    minArea = min(minArea, (length * width));\\n                }\\n            }\\n        }\\n        \\n        return minArea != double(INT_MAX) ? minArea : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424599,
                "title": "easy-understanding-java-o-n-3-solution-with-comment",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Pair<Double, Double>, Map<Double, List<int[][]>>> map = new HashMap<>();\\n        \\n        double res = Double.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            int[] p1 = points[i];\\n            for (int j = i+1; j < points.length; j++) {\\n                int[] p2 = points[j];\\n                // get mid point\\n                Pair<Double, Double> pm = new Pair((p1[0]+p2[0])/2d, (p1[1]+p2[1])/2d);\\n                if (!map.containsKey(pm))\\n                    map.put(pm, new HashMap<>());\\n                // get diagonal length\\n                double dist2 = dist2(p1, p2);\\n                if (!map.get(pm).containsKey(dist2))\\n                    map.get(pm).put(dist2, new ArrayList<>());\\n                \\n                // calculate area for each pair of p3/p4 and check min\\n\\t\\t\\t\\t// Worst case is each pair has same mid point with same length\\n\\t\\t\\t\\t// At worst case, below operation costs O(N)\\n                for (int[][] ps : map.get(pm).get(dist2)) {\\n                    double d1 = dist2(p1, ps[0]);\\n                    double d2 = dist2(p1, ps[1]);\\n                    res = Math.min(res, Math.sqrt(d1 * d2));\\n                }\\n                map.get(pm).get(dist2).add(new int[][]{p1, p2});\\n            }\\n        }\\n        \\n        return res == Double.MAX_VALUE ? 0 : res;\\n    }\\n    \\n    private double dist2(int[] p1, int[] p2) {\\n        return (p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Pair<Double, Double>, Map<Double, List<int[][]>>> map = new HashMap<>();\\n        \\n        double res = Double.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            int[] p1 = points[i];\\n            for (int j = i+1; j < points.length; j++) {\\n                int[] p2 = points[j];\\n                // get mid point\\n                Pair<Double, Double> pm = new Pair((p1[0]+p2[0])/2d, (p1[1]+p2[1])/2d);\\n                if (!map.containsKey(pm))\\n                    map.put(pm, new HashMap<>());\\n                // get diagonal length\\n                double dist2 = dist2(p1, p2);\\n                if (!map.get(pm).containsKey(dist2))\\n                    map.get(pm).put(dist2, new ArrayList<>());\\n                \\n                // calculate area for each pair of p3/p4 and check min\\n\\t\\t\\t\\t// Worst case is each pair has same mid point with same length\\n\\t\\t\\t\\t// At worst case, below operation costs O(N)\\n                for (int[][] ps : map.get(pm).get(dist2)) {\\n                    double d1 = dist2(p1, ps[0]);\\n                    double d2 = dist2(p1, ps[1]);\\n                    res = Math.min(res, Math.sqrt(d1 * d2));\\n                }\\n                map.get(pm).get(dist2).add(new int[][]{p1, p2});\\n            }\\n        }\\n        \\n        return res == Double.MAX_VALUE ? 0 : res;\\n    }\\n    \\n    private double dist2(int[] p1, int[] p2) {\\n        return (p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985812,
                "title": "clean-python-iterative-centers",
                "content": "**Clean Python | Iterative Centers**\\n\\n```\\nclass Solution:\\n    Inf = float(\\'inf\\')\\n    def minAreaFreeRect(self, A):\\n        #\\n        L    = len(A)\\n        res  = self.Inf\\n        sqrt = math.sqrt\\n        #\\n        dist = lambda x1,y1,x2,y2: sqrt( (x2-x1)**2 + (y2-y1)**2 )\\n        D    = defaultdict(list)\\n        #\\n        for i1 in range(L):\\n            for i2 in range(i1+1,L):\\n                x1,y1 = A[i1]\\n                x2,y2 = A[i2]\\n                C     = (x2+x1)/2. , (y2+y1)/2.\\n                r2    = (x2-x1)**2 + (y2-y1)**2\\n                #\\n                if (C,r2) in D:\\n                    for x3,y3 in D[C,r2]:\\n                        res = min(res, dist(x1,y1,x3,y3)*dist(x2,y2,x3,y3) )\\n                #\\n                D[C,r2].append( (x1,y1) )\\n        #\\n        return 0 if res==self.Inf else res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    Inf = float(\\'inf\\')\\n    def minAreaFreeRect(self, A):\\n        #\\n        L    = len(A)\\n        res  = self.Inf\\n        sqrt = math.sqrt\\n        #\\n        dist = lambda x1,y1,x2,y2: sqrt( (x2-x1)**2 + (y2-y1)**2 )\\n        D    = defaultdict(list)\\n        #\\n        for i1 in range(L):\\n            for i2 in range(i1+1,L):\\n                x1,y1 = A[i1]\\n                x2,y2 = A[i2]\\n                C     = (x2+x1)/2. , (y2+y1)/2.\\n                r2    = (x2-x1)**2 + (y2-y1)**2\\n                #\\n                if (C,r2) in D:\\n                    for x3,y3 in D[C,r2]:\\n                        res = min(res, dist(x1,y1,x3,y3)*dist(x2,y2,x3,y3) )\\n                #\\n                D[C,r2].append( (x1,y1) )\\n        #\\n        return 0 if res==self.Inf else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926092,
                "title": "java-o-n-2-easy-to-understand",
                "content": "1. Calculate distance between all possible pairs of points and group together pairs which has same distance.\\n2. Compare all lines (pair of points) with same distance and check if it forms a rectangle. To check if it\\'s a rectangle- distance of other sides of rect and diagonals should be same (trapezium will have unequal diagonals). Consider distances x(smaller side)<y(larger side)<z(diagonal) -area would be x*y.\\n3. Return min area.\\n\\n\\n\\n\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length==0) return 0;\\n        int N = points.length;        \\n        double[][] dist = new double[N][N];\\n        HashMap<Double, ArrayList<Pair>> map = new HashMap<>();        \\n        \\n        for(int i=0; i<N; i++){\\n            for(int j=i+1; j<N; j++){\\n                int x = Math.abs(points[i][0]-points[j][0]);\\n                int y = Math.abs(points[i][1]-points[j][1]);\\n                dist[i][j] = Math.sqrt(x*x+y*y );\\n                ArrayList<Pair> list = map.getOrDefault(dist[i][j], new ArrayList<>());\\n                map.putIfAbsent(dist[i][j],list);\\n                list.add(new Pair(i,j));                \\n            }\\n        }\\n        \\n        double minarea = Double.MAX_VALUE;\\n        for( Map.Entry<Double,ArrayList<Pair>> entry:map.entrySet()){\\n            List<Pair> list = entry.getValue();\\n            for( int i=0; i<list.size(); i++){\\n                for( int j=i+1; j<list.size(); j++){\\n                    Pair p1 = list.get(i);\\n                    Pair p2 = list.get(j);\\n                    if(dist[p1.pt1][p2.pt1] == dist[p1.pt2][p2.pt2] && dist[p1.pt1][p2.pt2] == dist[p1.pt2][p2.pt1]){\\n                        ArrayList<Double> temp = new ArrayList<>();\\n                        temp.add(entry.getKey());\\n                        temp.add(dist[p1.pt1][p2.pt1]);\\n                        temp.add(dist[p1.pt1][p2.pt2]);\\n                        Collections.sort(temp);\\n                        double curr = temp.get(0)*temp.get(1);\\n                        if(curr<minarea){\\n                            minarea = curr;\\n                        }\\n                    }\\n\\n                }        \\n            }\\n        }\\n        \\n        if(minarea==Double.MAX_VALUE)\\n            minarea = 0;\\n        \\n        return minarea;\\n        \\n    }\\n    \\n    class Pair{\\n        int pt1;\\n        int pt2;\\n        \\n        Pair(int p1, int p2){\\n            this.pt1 = p1;\\n            this.pt2 = p2;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length==0) return 0;\\n        int N = points.length;        \\n        double[][] dist = new double[N][N];\\n        HashMap<Double, ArrayList<Pair>> map = new HashMap<>();        \\n        \\n        for(int i=0; i<N; i++){\\n            for(int j=i+1; j<N; j++){\\n                int x = Math.abs(points[i][0]-points[j][0]);\\n                int y = Math.abs(points[i][1]-points[j][1]);\\n                dist[i][j] = Math.sqrt(x*x+y*y );\\n                ArrayList<Pair> list = map.getOrDefault(dist[i][j], new ArrayList<>());\\n                map.putIfAbsent(dist[i][j],list);\\n                list.add(new Pair(i,j));                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 907240,
                "title": "diagonals-n-2-find-detailed-math",
                "content": "I used properties of diagonals -- if they have equal length and intersect in the middle we can form rectangular.\\nI expressed computaions using standard math operations like inner product, difference between two vectors, and cross product.\\n\\n```C++\\n    array<int, 2> dif(vector<int> const& a, vector<int> const& b) {\\n         return {b[0] - a[0], b[1] - a[1]};   \\n    }\\n    \\n    array<int, 2> dif(array<int, 2> const& a, array<int, 2> const& b) {\\n         return {b[0] - a[0], b[1] - a[1]};   \\n    }\\n    \\n    int crossNorm(array<int, 2> const& a, array<int, 2> const& b) {\\n         return abs(a[0]*b[1] - b[0]*a[1]);   \\n    }\\n    \\n    int inner(array<int, 2> const& a, array<int, 2> const& b)\\n    {\\n        return a[0]*b[0] + a[1]*b[1];\\n    }\\n    \\n    // consider diagonals\\n    // for that iterate over all pairs\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        const int n = points.size();\\n        int minArea = 1e9;\\n        \\n        unordered_map<int, vector< pair<int, int> > > seen;\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                const auto& a = points[i];\\n                const auto& b = points[j];\\n                array<int, 2> ab = dif(a, b);\\n                int dist2_ab = inner(ab, ab);\\n                auto it = seen.find(dist2_ab);\\n                if (it != seen.end())\\n                    for (auto&[k,w] : it->second) {\\n                        const auto& c = points[k];\\n                        const auto& d = points[w];\\n                        array<int, 2> cd = dif(c,d);\\n                        // need to check that they intersect in center of diagonals\\n                        // 0.5ab + a == 0.5cd + c \\n                        // iff ab + 2*a == cd + 2c\\n                        if (ab[0] + 2*a[0] == cd[0] + 2*c[0] &&\\n                            ab[1] + 2*a[1] == cd[1] + 2*c[1]) {\\n                            array<int, 2> ac = dif(a,c);\\n                            array<int, 2> bc = dif(b,c);\\n                        \\n                            minArea = min(minArea, crossNorm(ac, bc));\\n                        }\\n                            \\n                    }\\n                seen[dist2_ab].emplace_back(i, j);\\n            }\\n        }\\n        return minArea == 1e9 ? 0 : minArea;\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Geometry"
                ],
                "code": "```C++\\n    array<int, 2> dif(vector<int> const& a, vector<int> const& b) {\\n         return {b[0] - a[0], b[1] - a[1]};   \\n    }\\n    \\n    array<int, 2> dif(array<int, 2> const& a, array<int, 2> const& b) {\\n         return {b[0] - a[0], b[1] - a[1]};   \\n    }\\n    \\n    int crossNorm(array<int, 2> const& a, array<int, 2> const& b) {\\n         return abs(a[0]*b[1] - b[0]*a[1]);   \\n    }\\n    \\n    int inner(array<int, 2> const& a, array<int, 2> const& b)\\n    {\\n        return a[0]*b[0] + a[1]*b[1];\\n    }\\n    \\n    // consider diagonals\\n    // for that iterate over all pairs\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        const int n = points.size();\\n        int minArea = 1e9;\\n        \\n        unordered_map<int, vector< pair<int, int> > > seen;\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                const auto& a = points[i];\\n                const auto& b = points[j];\\n                array<int, 2> ab = dif(a, b);\\n                int dist2_ab = inner(ab, ab);\\n                auto it = seen.find(dist2_ab);\\n                if (it != seen.end())\\n                    for (auto&[k,w] : it->second) {\\n                        const auto& c = points[k];\\n                        const auto& d = points[w];\\n                        array<int, 2> cd = dif(c,d);\\n                        // need to check that they intersect in center of diagonals\\n                        // 0.5ab + a == 0.5cd + c \\n                        // iff ab + 2*a == cd + 2c\\n                        if (ab[0] + 2*a[0] == cd[0] + 2*c[0] &&\\n                            ab[1] + 2*a[1] == cd[1] + 2*c[1]) {\\n                            array<int, 2> ac = dif(a,c);\\n                            array<int, 2> bc = dif(b,c);\\n                        \\n                            minArea = min(minArea, crossNorm(ac, bc));\\n                        }\\n                            \\n                    }\\n                seen[dist2_ab].emplace_back(i, j);\\n            }\\n        }\\n        return minArea == 1e9 ? 0 : minArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711984,
                "title": "swift-clean-code-80ms-beats-100",
                "content": "```swift\\nclass Solution {\\n  private typealias Point = (x: Int, y: Int)\\n  private typealias Segment = (p1: Point, p2: Point)\\n  \\n  func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n    let points = points.map { Point($0[0], $0[1]) }\\n    \\n    var map = [String: [Segment]]()\\n    for i in 0..<points.count - 1 {\\n      for j in i + 1..<points.count {\\n        let p1 = points[i]\\n        let p2 = points[j]\\n        let center = self.center(p1, p2)\\n        let distance = self.distance(p1, p2)\\n        let key = \"\\\\(distance)-\\\\(self.key(center))\"\\n        map[key, default: []].append(Segment(p1, p2))\\n      }\\n    }\\n    \\n    var result = Int.max\\n    for segments in map.values where segments.count > 1 {\\n      for i in 0..<segments.count - 1 {\\n        for j in i + 1..<segments.count {\\n          let segment1 = segments[i]\\n          let segment2 = segments[j]\\n          let size = distance(segment1.p1, segment2.p1) * distance(segment1.p2, segment2.p1)\\n          result = min(result, size)\\n        }\\n      }\\n    }\\n    return result == Int.max ? 0 : sqrt(Double(result))\\n  }\\n\\n  private func distance(_ p1: Point, _ p2: Point) -> Int {\\n    let dx = (p1.x - p2.x)\\n    let dy = (p1.y - p2.y)\\n    return dx * dx + dy * dy\\n  }\\n  \\n  private func center(_ p1: Point, _ p2: Point) -> Point {\\n    return (p1.x + p2.x, p1.y + p2.y)\\n  }\\n  \\n  private func key(_ point: Point) -> Int {\\n    return point.x * 40001 + point.y\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n  private typealias Point = (x: Int, y: Int)\\n  private typealias Segment = (p1: Point, p2: Point)\\n  \\n  func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n    let points = points.map { Point($0[0], $0[1]) }\\n    \\n    var map = [String: [Segment]]()\\n    for i in 0..<points.count - 1 {\\n      for j in i + 1..<points.count {\\n        let p1 = points[i]\\n        let p2 = points[j]\\n        let center = self.center(p1, p2)\\n        let distance = self.distance(p1, p2)\\n        let key = \"\\\\(distance)-\\\\(self.key(center))\"\\n        map[key, default: []].append(Segment(p1, p2))\\n      }\\n    }\\n    \\n    var result = Int.max\\n    for segments in map.values where segments.count > 1 {\\n      for i in 0..<segments.count - 1 {\\n        for j in i + 1..<segments.count {\\n          let segment1 = segments[i]\\n          let segment2 = segments[j]\\n          let size = distance(segment1.p1, segment2.p1) * distance(segment1.p2, segment2.p1)\\n          result = min(result, size)\\n        }\\n      }\\n    }\\n    return result == Int.max ? 0 : sqrt(Double(result))\\n  }\\n\\n  private func distance(_ p1: Point, _ p2: Point) -> Int {\\n    let dx = (p1.x - p2.x)\\n    let dy = (p1.y - p2.y)\\n    return dx * dx + dy * dy\\n  }\\n  \\n  private func center(_ p1: Point, _ p2: Point) -> Point {\\n    return (p1.x + p2.x, p1.y + p2.y)\\n  }\\n  \\n  private func key(_ point: Point) -> Int {\\n    return point.x * 40001 + point.y\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212270,
                "title": "12-ms-o-n-3logn-solution-better-than-98",
                "content": "1. Take every three points P, Q and R.\\n2. Now create two vectors PQ and PR\\n3. Check if dot product or PQ and PR is 0 and cross product of PQ and PR is not zero (because if < between PQ and PR is pi/2 then dot product will be zero and corss product is checking if three points are all distinct.)\\n4. If the 3 satisfies then create vector X = PQ+PR\\n5. change origin of X from (0,0) to (Px, Py)\\n6. Now check if X exists in given point set\\n7. if exists area_of_rec = absolute value of cross_product(PQ, PR)\\n8. return the lowest area as answer\\n\\n```\\n#define LL long long\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& v) {\\n        LL res = 0;\\n        bool found = false;\\n        set<pair<LL,LL>> st;\\n        for(int i=0; i<v.size(); i++){\\n            st.insert(make_pair((LL)v[i][0], (LL)v[i][1]));\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=i+1; j<v.size(); j++){\\n                for(int k=j+1; k<v.size(); k++){\\n                    LL tmp = 0;\\n                    if(dot_product(v[i], v[j], v[k])==0&&(tmp=cross_product(v[i], v[j], v[k]))!=0){\\n                        auto cur = add_vect(v[i], v[j], v[k]);\\n                        if(st.find(cur)!=st.end()){\\n                            tmp = abs(tmp);\\n                            if(found==false){\\n                                found = true;\\n                                res = tmp;\\n                            }else{\\n                                res = min(res, tmp);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(found==false)return 0;\\n        else return res;\\n    }\\n    \\n    pair<LL,LL> add_vect(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return make_pair(p1[0]-(x1+x2), p1[1]-(y1+y2));\\n    }\\n    \\n    LL dot_product(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return x1*x2+y1*y2;\\n    }\\n    \\n    LL cross_product(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return x1*y2-x2*y1;\\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#define LL long long\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& v) {\\n        LL res = 0;\\n        bool found = false;\\n        set<pair<LL,LL>> st;\\n        for(int i=0; i<v.size(); i++){\\n            st.insert(make_pair((LL)v[i][0], (LL)v[i][1]));\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=i+1; j<v.size(); j++){\\n                for(int k=j+1; k<v.size(); k++){\\n                    LL tmp = 0;\\n                    if(dot_product(v[i], v[j], v[k])==0&&(tmp=cross_product(v[i], v[j], v[k]))!=0){\\n                        auto cur = add_vect(v[i], v[j], v[k]);\\n                        if(st.find(cur)!=st.end()){\\n                            tmp = abs(tmp);\\n                            if(found==false){\\n                                found = true;\\n                                res = tmp;\\n                            }else{\\n                                res = min(res, tmp);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(found==false)return 0;\\n        else return res;\\n    }\\n    \\n    pair<LL,LL> add_vect(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return make_pair(p1[0]-(x1+x2), p1[1]-(y1+y2));\\n    }\\n    \\n    LL dot_product(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return x1*x2+y1*y2;\\n    }\\n    \\n    LL cross_product(vector<int> &p1, vector<int> &p2, vector<int> &p3){\\n        LL x1 = p1[0]-(LL)p2[0];\\n        LL y1 = p1[1]-(LL)p2[1];\\n        LL x2 = p1[0]-(LL)p3[0];\\n        LL y2 = p1[1]-(LL)p3[1];\\n        return x1*y2-x2*y1;\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208443,
                "title": "math-vector-24ms-c",
                "content": "```\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string,vector<vector<int>>> dic;\\n        long size = LONG_MAX;\\n        for(int i = 0; i < points.size() - 1; ++i)\\n        {\\n            long x1 = points[i][0], y1 = points[i][1];\\n            for (int j = i + 1; j < points.size(); ++j)\\n            {\\n                long x2 = points[j][0], y2 = points[j][1];\\n                long x = x1 - x2;\\n                long y = y1 - y2;\\n                if (x < 0) x = -x, y = -y;\\n                string p = to_string(x) + \\',\\' + to_string(y);\\n                if (dic.count(p) == 1)\\n                {\\n                    for (auto v : dic[p])\\n                    {\\n                        if (((v[0] - x1) * x + (v[1] - y1) * y == 0) && ((v[2] - x2) * x + (v[3] - y2) * y == 0)) \\n                            size = min(size, (x*x + y*y) * ((v[0] - x1) * (v[0] - x1) +  (v[1] - y1) *  (v[1] - y1)));\\n                        else if (((v[0] - x2) * x + (v[1] - y2) * y == 0) && ((v[2] - x1) * x + (v[3] - y1) * y == 0))\\n                            size = min(size, (x*x + y*y) * ((v[0] - x2) * (v[0] - x2) + (v[1] - y2) *  (v[1] - y2)));\\n                    }\\n                }\\n                dic[p].push_back({x1, y1, x2, y2});\\n            }\\n        }\\n        if (size == LONG_MAX) return 0;\\n        return sqrt(size);\\n        \\n    }\\n```\\nkey idea: go through any two points(x1, y1), (x2, y2), if we get vector ***A*** = (x1 - x2, y1 - y2), when we meet two equal vectors, say ***B***=(x\\'1 - x\\'2, y\\'1 - y\\'2) which ***A*** = ***B*** , we check whether ***C***=(x1 - x\\'1, y1- y\\'1) and ***D***=(x2 - x\\'2, y2 - y\\'2)  \\u22A5 ***A*** which means ***C*** * ***A***  = 0 && ***D*** * ***A***  = 0\\n\\n***X*** = (a, b) ***Y*** = (c, d) ***X*** * ***Y*** = a * c + b * d\\ntime O(n^2) worst O(n^3)\\nspace O(n)",
                "solutionTags": [],
                "code": "```\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string,vector<vector<int>>> dic;\\n        long size = LONG_MAX;\\n        for(int i = 0; i < points.size() - 1; ++i)\\n        {\\n            long x1 = points[i][0], y1 = points[i][1];\\n            for (int j = i + 1; j < points.size(); ++j)\\n            {\\n                long x2 = points[j][0], y2 = points[j][1];\\n                long x = x1 - x2;\\n                long y = y1 - y2;\\n                if (x < 0) x = -x, y = -y;\\n                string p = to_string(x) + \\',\\' + to_string(y);\\n                if (dic.count(p) == 1)\\n                {\\n                    for (auto v : dic[p])\\n                    {\\n                        if (((v[0] - x1) * x + (v[1] - y1) * y == 0) && ((v[2] - x2) * x + (v[3] - y2) * y == 0)) \\n                            size = min(size, (x*x + y*y) * ((v[0] - x1) * (v[0] - x1) +  (v[1] - y1) *  (v[1] - y1)));\\n                        else if (((v[0] - x2) * x + (v[1] - y2) * y == 0) && ((v[2] - x1) * x + (v[3] - y1) * y == 0))\\n                            size = min(size, (x*x + y*y) * ((v[0] - x2) * (v[0] - x2) + (v[1] - y2) *  (v[1] - y2)));\\n                    }\\n                }\\n                dic[p].push_back({x1, y1, x2, y2});\\n            }\\n        }\\n        if (size == LONG_MAX) return 0;\\n        return sqrt(size);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991622,
                "title": "easy-brute-c",
                "content": "# Intuition\\nSince number of points are just 50, so even O(n^4) will work.\\nSo we will first precompute the distance between all the pair of points. \\n\\nNow after calculating the distance we just need take all possible combination of 4 points. \\nSo let points be p1,p2,p3,p4\\n\\nNow we need to check if these points can form a rectangle or not. Below conditions will help us in knowing this. \\n\\n1. Distance between any of the points should not be zero\\n2. There will be 3 possibilities in which they can form a rectangle. \\n    a. p1 -> p3 are opposite (diagonal)\\n    b. p1 -> p2 are opposite (diagonal)\\n    c. p1 -> p4 are opposite (diagonal)\\n    And for these conditions we will try to check if rectangle\\'s properties are applied or not. \\n- Opposite side length should be same\\n- ab^2(side1) + ac^2(side2) = ad^2 (diagonal) \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^4)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDist(vector <int> &p1,vector <int> &p2){\\n        return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n    }\\n\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans = DBL_MAX;\\n        int n = points.size();\\n        vector <vector <long long>> dis(n,vector <long long> (n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dis[i][j] = getDist(points[i],points[j]);\\n            }\\n        }\\n        for(long i=0;i<n-3;i++){\\n            for(long j=i+1;j<n-2;j++){\\n                for(long k=j+1;k<n-1;k++){\\n                    for(long l=k+1;l<n;l++){\\n                        long long ij = dis[i][j];\\n                        long long ik = dis[i][k];\\n                        long long il = dis[i][l];\\n                        long long jk = dis[j][k];\\n                        long long jl = dis[j][l];\\n                        long long kl = dis[k][l];\\n                        if(ij && ik && il && jk && jl && kl){\\n                            if(ij+ik == il && jl==ik && kl==ij && kl+jl==jk){\\n                                double area = (double)sqrt(ij)*(double)sqrt(ik);\\n                                ans = min(ans,area);\\n                            }else if(ik+il == ij && il==jk && ik==jl && jl+jk==kl){\\n                                double area = (double)sqrt(ik)*(double)sqrt(il);\\n                                ans = min(ans,area);\\n                            }else if(ij+il == ik && il==jk && kl==ij && jk+kl==jl){\\n                                double area = (double)sqrt(ij)*(double)sqrt(il);\\n                                ans = min(ans,area);\\n                            }\\n                        }                  \\n                    }\\n                }\\n            }\\n        }\\n        return ans==DBL_MAX?0:ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDist(vector <int> &p1,vector <int> &p2){\\n        return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n    }\\n\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans = DBL_MAX;\\n        int n = points.size();\\n        vector <vector <long long>> dis(n,vector <long long> (n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                dis[i][j] = getDist(points[i],points[j]);\\n            }\\n        }\\n        for(long i=0;i<n-3;i++){\\n            for(long j=i+1;j<n-2;j++){\\n                for(long k=j+1;k<n-1;k++){\\n                    for(long l=k+1;l<n;l++){\\n                        long long ij = dis[i][j];\\n                        long long ik = dis[i][k];\\n                        long long il = dis[i][l];\\n                        long long jk = dis[j][k];\\n                        long long jl = dis[j][l];\\n                        long long kl = dis[k][l];\\n                        if(ij && ik && il && jk && jl && kl){\\n                            if(ij+ik == il && jl==ik && kl==ij && kl+jl==jk){\\n                                double area = (double)sqrt(ij)*(double)sqrt(ik);\\n                                ans = min(ans,area);\\n                            }else if(ik+il == ij && il==jk && ik==jl && jl+jk==kl){\\n                                double area = (double)sqrt(ik)*(double)sqrt(il);\\n                                ans = min(ans,area);\\n                            }else if(ij+il == ik && il==jk && kl==ij && jk+kl==jl){\\n                                double area = (double)sqrt(ij)*(double)sqrt(il);\\n                                ans = min(ans,area);\\n                            }\\n                        }                  \\n                    }\\n                }\\n            }\\n        }\\n        return ans==DBL_MAX?0:ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930175,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  double minAreaFreeRect(vector<vector<int>>& points) {\\n    long long ans = LLONG_MAX;\\n    // For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}\\n    unordered_map<int, vector<tuple<int, int, int, int>>> centerToPoints;\\n\\n    for (const vector<int>& A : points)\\n      for (const vector<int>& B : points) {\\n        const int center = hash(A, B);\\n        centerToPoints[center].emplace_back(A[0], A[1], B[0], B[1]);\\n      }\\n\\n    // For all pair points \"that share the same center\"\\n    for (const auto& [_, points] : centerToPoints)\\n      for (const auto& [ax, ay, bx, by] : points)\\n        for (const auto& [cx, cy, dx, dy] : points)\\n          // AC is perpendicular to AD\\n          // AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0\\n          if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {\\n            const long long squaredArea =\\n                dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);\\n            if (squaredArea > 0)\\n              ans = min(ans, squaredArea);\\n          }\\n\\n    return ans == LLONG_MAX ? 0 : sqrt(ans);\\n  }\\n\\n private:\\n  int hash(const vector<int>& p, const vector<int>& q) {\\n    return ((long long)(p[0] + q[0]) << 16) + (p[1] + q[1]);\\n  }\\n\\n  long long dist(int px, int py, int qx, int qy) {\\n    return (px - qx) * (px - qx) + (py - qy) * (py - qy);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  double minAreaFreeRect(vector<vector<int>>& points) {\\n    long long ans = LLONG_MAX;\\n    // For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}\\n    unordered_map<int, vector<tuple<int, int, int, int>>> centerToPoints;\\n\\n    for (const vector<int>& A : points)\\n      for (const vector<int>& B : points) {\\n        const int center = hash(A, B);\\n        centerToPoints[center].emplace_back(A[0], A[1], B[0], B[1]);\\n      }\\n\\n    // For all pair points \"that share the same center\"\\n    for (const auto& [_, points] : centerToPoints)\\n      for (const auto& [ax, ay, bx, by] : points)\\n        for (const auto& [cx, cy, dx, dy] : points)\\n          // AC is perpendicular to AD\\n          // AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0\\n          if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {\\n            const long long squaredArea =\\n                dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);\\n            if (squaredArea > 0)\\n              ans = min(ans, squaredArea);\\n          }\\n\\n    return ans == LLONG_MAX ? 0 : sqrt(ans);\\n  }\\n\\n private:\\n  int hash(const vector<int>& p, const vector<int>& q) {\\n    return ((long long)(p[0] + q[0]) << 16) + (p[1] + q[1]);\\n  }\\n\\n  long long dist(int px, int py, int qx, int qy) {\\n    return (px - qx) * (px - qx) + (py - qy) * (py - qy);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814580,
                "title": "linear-algebra-review-problem-commented-and-explained-graduate-level",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a linear algebra problem. As such, I decided to finally implement some parts of my much needed personal linear algebra library of lambda functions, which I showcase here. These come up in a variety of problems as linear algebra is a powerful field for both AI and graphics. As such, feel free to use / improve for your own uses. I know my determinant 3D function that utilizes my determinant 2D is not the most efficient way of doing things, but it is a great learning method and a key to how I teach how to override the useful * operator for things like enum assignment for graphical nomenclatures. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom the intuition, let\\'s break down the key lambda functions in detail. \\nFirst, the make vector function takes two points and their size in agreement. This can only be used with two points of equal size, don\\'t try it otherwise. \\n\\nWhat occurs is a generated list of p2[i] - p1[i] for i in range size. \\nSaid more generally is that\\n- For each axis (basis) of point 2, get the axis based value\\n- Subtract from this the axis (basis) of point 1 for the same axis based value \\n- This generates a euclidean delta (described later) for this given axis and records the change. This is akin to saying from point 1 go to point 2 \\n\\nGet determinant 2d is rather involved with needing 2 vectors, an ith power, an index 0 and index 1 as well as a coefficient \\nThis is because, when calculating the 2D determinant of an n dimensional matrix, you will utilize a specific cross bar locaton of the matrix to split it into 2D determinants. Take the example below \\n\\n> a b c    \\n> d e f     ->  given matrix to left, consider the top bar and leftmost column \\n> g h i\\n\\n> a  b  c\\n> d [e f] -> this isolates e f h i as shown in brackets  \\n> g [h i] \\n\\n> a is at row index 0 and col index 0 -> this means our ith power of -1 is 0\\n> this makes the value of -1 to the power of 0 to be 1 \\n> a is also our coefficient \\n> in that case, our value of the 2D determinant here is ((-1)^0) * a * (e * i - f * h)\\n> we then would move across the top row, moving the left column with it \\n\\n> this would give us for the next term ((-1)^1) * b * (d * i - f * g)\\n> try to get the third one. At the end of this explanation section I\\'ll write the answer so you can check \\n\\nTo help with the above, I did add a helper function that will get the n dimensional determinants ith power. It\\'s rather simple, so I\\'ll leave it unexplained. \\n\\nTo get the euclidean delta, simply take the difference between a final and initial value \\n\\nTo get a euclidean distance, this is simply the sum of square euclidean deltas for any two points of a given size (means, for each basis, get the euclidean delta, multiply this by the same euclidean delta, and add them all up)\\n\\nNotice, we are using the sum of squared differences here, not the square root of the sum of squared differences, which is the true euclidean distance, but may involve complex positive and negative numbers! \\n\\nA diagonal key is a key set to be unique for any such pairing (hopefully, no gaurantees, but it works here). It is simply a hashing function at the end of the day, and can be improved as needed. \\n\\nFinally, we make a map of our diagonals as a collection of lists for a given diagonal key (thus avoiding the possibility of matching diagonal keys!) \\n\\nSo then, first we need to make the combinations of points in points into a diagonal key and then append to the list a given point structure. Combinations is necessarily a filtered permutation of sorted order, check the itertools documentation for more (math is fun also has a great breakdown) \\n\\nOnce we have done that, we need to then consider each list of values we have mapped. \\n\\n- For each such list \\n    - generate combinations of points (a, b) and (c, d) from this list \\n        - these are points needed for vectors of a to b and c to d \\n        - These vectors then are useful if the euclidean distance of a to b is equal to the euclidean distance from c to d (we could have used the square root distance, but we would have had to account for negative values coming out of it, which we avoid by sticking with sum of square differences instead of the more rigorous and slightly problem fraught square root of sum of squared distances) \\n            - if the vectors are useful, update result to the minimum of itself and the absolute area of the 2D determinant, using vectors from a to b of size 2 and a to d of size 2, with 2 as the size of the vectors, 2 as an even power to raise -1 to the power of, 0 as the first index, 1 as the second index, and 1 as the coefficient\\n\\nAt the end, return result if result is not our default valuation of float of infinity, otherwise return 0 \\n\\nThe promised answer to the determinant part above is found below \\n(-1 ^ (2)) * c * (d * h - g * e)\\n\\n# Complexity\\n- Time complexity : O( D^2 * C(P, D) * C(V, D) )\\n    - generating the needed combinations for the map is necessarily of time complexity O(r * n choose r) as we need to yield at least r times. \\n    - Generally this would be D * P choose D where D is the dimensionality of the points and P the number of points \\n    - We thus have at worst C(P, D) value key lists \\n    - For which we have to do D * C(V, D) combinations \\n        - each of which needs 2 * D euclidean distance operations \\n            - and which then might cost a final 6 multiplications and one addition \\n    - So D * C(P, D) + C(P, D) * D * C(V, D) * 2D * (6 multi, one add)\\n    - D^2 * C(V, D) * C(P, D) * (6 multi, one add) + D * C(P, D) \\n    - Square D term dominates out \\n    - D^2 * C(P, D) * C(V, D), not accounting additional multiplications or pre-set up\\n    - CURSE OF DIMENSIONALITY!!!   \\n\\n- Space complexity : O( C(P, D))\\n    - We store at most P Choose D lists \\n    - All others are generated / yielded as needed, so will be discounted  \\n\\n# Code\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float :\\n        # linear algebra functions \\n        make_vector = lambda p1, p2, size : list(p2[i] - p1[i] for i in range(size))\\n        get_determinant_2D = lambda v1, v2, ith_power, index_0, index_1, coefficient : (-1)**(ith_power) * coefficient * (v1[index_0]*v2[index_1] - v2[index_0]*v1[index_1])\\n        euclidean_delta = lambda val_f, val_i : val_f - val_i \\n        euclidean_distance = lambda p1, p2, size : sum(list(euclidean_delta(p2[i], p1[i]) * euclidean_delta(p2[i], p1[i]) for i in range(size)))\\n        # hash key function, could be improved but is geometrically necessary \\n        diagonal_key = lambda p1, p2, size : tuple(p1[i] + p2[i] for i in range(size))\\n        # map of hashes \\n        map_of_diagonals = collections.defaultdict(list)\\n        # generate combinations. 2 is here for the size of the vectorial dimension space, in this case 2D \\n        for p1, p2 in itertools.combinations(points, 2) : \\n            key = diagonal_key(p1, p2, 2)\\n            map_of_diagonals[key].append((p1, p2))\\n        # get float valuation \\n        result = float(\\'inf\\')\\n        # loop over C(P, D) value lists \\n        for value_list in map_of_diagonals.values() : \\n            # of size V, taking D * C(V, D) items \\n            for (a, b), (c, d) in itertools.combinations(value_list, 2) : \\n                # doing D operations 2 times to get euclidean distance \\n                if euclidean_distance(a, b, 2) == euclidean_distance(c, d, 2) : \\n                    # doing at most 6 multiplications and one addition to get determinant 2D in abs form \\n                    result = min(result, abs(get_determinant_2D(make_vector(a, b, 2), make_vector(a, d, 2), 2, 0, 1, 1)))\\n        return result if result != float(\\'inf\\') else 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float :\\n        # linear algebra functions \\n        make_vector = lambda p1, p2, size : list(p2[i] - p1[i] for i in range(size))\\n        get_determinant_2D = lambda v1, v2, ith_power, index_0, index_1, coefficient : (-1)**(ith_power) * coefficient * (v1[index_0]*v2[index_1] - v2[index_0]*v1[index_1])\\n        euclidean_delta = lambda val_f, val_i : val_f - val_i \\n        euclidean_distance = lambda p1, p2, size : sum(list(euclidean_delta(p2[i], p1[i]) * euclidean_delta(p2[i], p1[i]) for i in range(size)))\\n        # hash key function, could be improved but is geometrically necessary \\n        diagonal_key = lambda p1, p2, size : tuple(p1[i] + p2[i] for i in range(size))\\n        # map of hashes \\n        map_of_diagonals = collections.defaultdict(list)\\n        # generate combinations. 2 is here for the size of the vectorial dimension space, in this case 2D \\n        for p1, p2 in itertools.combinations(points, 2) : \\n            key = diagonal_key(p1, p2, 2)\\n            map_of_diagonals[key].append((p1, p2))\\n        # get float valuation \\n        result = float(\\'inf\\')\\n        # loop over C(P, D) value lists \\n        for value_list in map_of_diagonals.values() : \\n            # of size V, taking D * C(V, D) items \\n            for (a, b), (c, d) in itertools.combinations(value_list, 2) : \\n                # doing D operations 2 times to get euclidean distance \\n                if euclidean_distance(a, b, 2) == euclidean_distance(c, d, 2) : \\n                    # doing at most 6 multiplications and one addition to get determinant 2D in abs form \\n                    result = min(result, abs(get_determinant_2D(make_vector(a, b, 2), make_vector(a, d, 2), 2, 0, 1, 1)))\\n        return result if result != float(\\'inf\\') else 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747105,
                "title": "o-n-3-worst-case-python-solution-by-finding-parallel-vectors-and-right-angle-corners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef normalize(points) -> []:\\n    vector = (points[1][0] - points[0][0], points[1][1] - points[0][1])\\n    l = length(points)\\n    return (float(vector[0]) / l, float(vector[1]) / l)\\n\\n\\ndef length(points) -> float:\\n    vector = (points[1][0] - points[0][0], points[1][1] - points[0][1])\\n    return sqrt(float(vector[0] * vector[0] + vector[1] * vector[1]))\\n\\nclass Solution:\\n\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        n = len(points)\\n        vectors = {}\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a = points[i]\\n                b = points[j]\\n                if a[0] > b[0]:\\n                    a, b = b, a\\n                vec = (b[0] - a[0], b[1] - a[1])\\n                if not vec in vectors:\\n                    vectors[vec] = []\\n                vectors[vec].append((a, b))\\n        min_area = float(\"inf\")\\n        for vector in vectors.keys():\\n            sides = vectors[vector]\\n            for i in range(len(sides)):\\n                side1 = sides[i]\\n                for j in range(i + 1, len(sides)):\\n                    perp = (side1[0], sides[j][0])\\n                    if length(side1) > 0 and length(perp) > 0:\\n                        # we have two parallel vectors of same lengths\\n                        # check if we have a right angle corner\\n                        side1_norm = normalize(side1)\\n                        perp_norm = normalize(perp)\\n                        dot = side1_norm[0] * perp_norm[0] + side1_norm[1] * perp_norm[1]\\n                        if abs(dot) < 0.001:\\n                            area = length(side1) * length(perp)\\n                            min_area = min(min_area, area)\\n        if min_area == float(\"inf\"):\\n            return 0\\n        return min_area\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef normalize(points) -> []:\\n    vector = (points[1][0] - points[0][0], points[1][1] - points[0][1])\\n    l = length(points)\\n    return (float(vector[0]) / l, float(vector[1]) / l)\\n\\n\\ndef length(points) -> float:\\n    vector = (points[1][0] - points[0][0], points[1][1] - points[0][1])\\n    return sqrt(float(vector[0] * vector[0] + vector[1] * vector[1]))\\n\\nclass Solution:\\n\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        n = len(points)\\n        vectors = {}\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a = points[i]\\n                b = points[j]\\n                if a[0] > b[0]:\\n                    a, b = b, a\\n                vec = (b[0] - a[0], b[1] - a[1])\\n                if not vec in vectors:\\n                    vectors[vec] = []\\n                vectors[vec].append((a, b))\\n        min_area = float(\"inf\")\\n        for vector in vectors.keys():\\n            sides = vectors[vector]\\n            for i in range(len(sides)):\\n                side1 = sides[i]\\n                for j in range(i + 1, len(sides)):\\n                    perp = (side1[0], sides[j][0])\\n                    if length(side1) > 0 and length(perp) > 0:\\n                        # we have two parallel vectors of same lengths\\n                        # check if we have a right angle corner\\n                        side1_norm = normalize(side1)\\n                        perp_norm = normalize(perp)\\n                        dot = side1_norm[0] * perp_norm[0] + side1_norm[1] * perp_norm[1]\\n                        if abs(dot) < 0.001:\\n                            area = length(side1) * length(perp)\\n                            min_area = min(min_area, area)\\n        if min_area == float(\"inf\"):\\n            return 0\\n        return min_area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484544,
                "title": "time-o-n-2-log-n-space-o-n-30-40-ms",
                "content": "# Intuition\\nThe two diagonals of a rectangle must have the same middle point and the same length. Amongst all such diagonals, the minimum area is achieved by the rectangle with the smallest absolute angle.\\n\\n# Approach\\nBucket the two-point segments by middle point and length. Within each bucket, sort them by the absolute value of the angle to an arbitrary fixed line (e.g. the first diagonal in the bucket). Then find the minimum angle difference between consecutive diagonals within the bucket.\\n\\nThe rectangle area is half the absolute value of the cross product of the diagonals.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2 log n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nint vector_product(std::pair<int, int> p, std::pair<int, int> q)\\n{\\n    return p.first * q.second - p.second * q.first;\\n}\\n\\nstruct key_hash : public std::unary_function<std::tuple<int, int, int>, std::size_t>\\n{\\n    std::size_t operator()(const std::tuple<int, int, int> k) const\\n    {\\n        // Bits: 17, 17, 32\\n        return (std::get<0>(k) << (32 - 17)) ^ std::get<1>(k) ^ std::get<2>(k);\\n    }\\n};\\n\\nstruct key_equal : public std::binary_function<std::tuple<int, int, int>, std::tuple<int, int, int>, bool>\\n{\\n    bool operator()(const std::tuple<int, int, int> v0, const std::tuple<int, int, int> v1) const\\n    {\\n        return v0 == v1;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    double minAreaFreeRect(const std::vector<std::vector<int>> &points)\\n    {\\n        const int n = points.size();\\n        std::unordered_map<std::tuple<int, int, int>, std::vector<std::pair<int, int>>,\\n                           key_hash, key_equal>\\n            endpoint_indices_by_double_midpoint_and_length;\\n        endpoint_indices_by_double_midpoint_and_length.reserve(\\n            (n - 1) * n / 2);\\n        for (auto p_it = points.begin(); p_it != points.end(); ++p_it)\\n        {\\n            const auto &p = *p_it;\\n            for (auto q_it = std::next(p_it); q_it != points.end(); ++q_it)\\n            {\\n                const auto &q = *q_it;\\n                int delta_x = p[0] - q[0];\\n                int delta_y = p[1] - q[1];\\n                endpoint_indices_by_double_midpoint_and_length[{p[0] + q[0], p[1] + q[1], delta_x * delta_x + delta_y * delta_y}].push_back(\\n                    {delta_x, delta_y});\\n            }\\n        }\\n        int min_twice_area = 0;\\n        for (auto &[_, v] : endpoint_indices_by_double_midpoint_and_length)\\n        {\\n            auto p_it = v.begin();\\n            std::sort(std::next(p_it), v.end(), [p_it](const auto &lhs, const auto &rhs)\\n                      { return abs(vector_product(*p_it, lhs)) < abs(vector_product(*p_it, rhs)); });\\n            for (auto q_it = std::next(p_it); q_it != v.end(); ++q_it)\\n            {\\n                int twice_area = abs(vector_product(*p_it, *q_it));\\n                if (min_twice_area == 0 || min_twice_area > twice_area)\\n                {\\n                    min_twice_area = twice_area;\\n                }\\n                p_it = q_it;\\n            }\\n        }\\n        return min_twice_area / 2.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint vector_product(std::pair<int, int> p, std::pair<int, int> q)\\n{\\n    return p.first * q.second - p.second * q.first;\\n}\\n\\nstruct key_hash : public std::unary_function<std::tuple<int, int, int>, std::size_t>\\n{\\n    std::size_t operator()(const std::tuple<int, int, int> k) const\\n    {\\n        // Bits: 17, 17, 32\\n        return (std::get<0>(k) << (32 - 17)) ^ std::get<1>(k) ^ std::get<2>(k);\\n    }\\n};\\n\\nstruct key_equal : public std::binary_function<std::tuple<int, int, int>, std::tuple<int, int, int>, bool>\\n{\\n    bool operator()(const std::tuple<int, int, int> v0, const std::tuple<int, int, int> v1) const\\n    {\\n        return v0 == v1;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    double minAreaFreeRect(const std::vector<std::vector<int>> &points)\\n    {\\n        const int n = points.size();\\n        std::unordered_map<std::tuple<int, int, int>, std::vector<std::pair<int, int>>,\\n                           key_hash, key_equal>\\n            endpoint_indices_by_double_midpoint_and_length;\\n        endpoint_indices_by_double_midpoint_and_length.reserve(\\n            (n - 1) * n / 2);\\n        for (auto p_it = points.begin(); p_it != points.end(); ++p_it)\\n        {\\n            const auto &p = *p_it;\\n            for (auto q_it = std::next(p_it); q_it != points.end(); ++q_it)\\n            {\\n                const auto &q = *q_it;\\n                int delta_x = p[0] - q[0];\\n                int delta_y = p[1] - q[1];\\n                endpoint_indices_by_double_midpoint_and_length[{p[0] + q[0], p[1] + q[1], delta_x * delta_x + delta_y * delta_y}].push_back(\\n                    {delta_x, delta_y});\\n            }\\n        }\\n        int min_twice_area = 0;\\n        for (auto &[_, v] : endpoint_indices_by_double_midpoint_and_length)\\n        {\\n            auto p_it = v.begin();\\n            std::sort(std::next(p_it), v.end(), [p_it](const auto &lhs, const auto &rhs)\\n                      { return abs(vector_product(*p_it, lhs)) < abs(vector_product(*p_it, rhs)); });\\n            for (auto q_it = std::next(p_it); q_it != v.end(); ++q_it)\\n            {\\n                int twice_area = abs(vector_product(*p_it, *q_it));\\n                if (min_twice_area == 0 || min_twice_area > twice_area)\\n                {\\n                    min_twice_area = twice_area;\\n                }\\n                p_it = q_it;\\n            }\\n        }\\n        return min_twice_area / 2.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360769,
                "title": "c",
                "content": "```\\nclass Solution {\\n    long long getDist(vector<int> a, vector<int> b){\\n        long long x = a[0] - b[0] ;\\n        long long y = a[1] - b[1] ;\\n        return x*x + y*y ;\\n    }\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string, vector<pair<int, int>>>Map ; //len+center,  pair of points \\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            for(int j = i+1; j < points.size(); j++)\\n            {\\n                long long dist =  getDist(points[i], points[j]) ;\\n                double centerX = ( points[i][0] + points[j][0] ) / 2.0 ;\\n                double centerY = ( points[i][1] + points[j][1] ) / 2.0 ;\\n                Map[to_string(dist) + \"_\" + to_string(centerX) + \"_\" + to_string(centerY)].push_back({i, j}) ;\\n            }            \\n        }\\n        double ret = INT_MAX ;\\n        for(auto&m : Map){\\n            auto& vec = m.second ;\\n            if(vec.size() < 2)\\n                continue ;\\n            for(int i = 0; i < vec.size(); i++){\\n                for(int j = i+1; j < vec.size(); j++){\\n                    int p1 = vec[i].first ;\\n                    int p2 = vec[i].second ;\\n                    int p3 = vec[j].first ;\\n                    double len1 = sqrt(getDist(points[p1], points[p3])) ;\\n                    double len2 = sqrt(getDist(points[p2], points[p3])) ;\\n                    ret = min(ret, len1 * len2) ;\\n                }\\n            }\\n        }\\n        \\n        return (ret == INT_MAX) ? 0 :  ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long getDist(vector<int> a, vector<int> b){\\n        long long x = a[0] - b[0] ;\\n        long long y = a[1] - b[1] ;\\n        return x*x + y*y ;\\n    }\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string, vector<pair<int, int>>>Map ; //len+center,  pair of points \\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            for(int j = i+1; j < points.size(); j++)\\n            {\\n                long long dist =  getDist(points[i], points[j]) ;\\n                double centerX = ( points[i][0] + points[j][0] ) / 2.0 ;\\n                double centerY = ( points[i][1] + points[j][1] ) / 2.0 ;\\n                Map[to_string(dist) + \"_\" + to_string(centerX) + \"_\" + to_string(centerY)].push_back({i, j}) ;\\n            }            \\n        }\\n        double ret = INT_MAX ;\\n        for(auto&m : Map){\\n            auto& vec = m.second ;\\n            if(vec.size() < 2)\\n                continue ;\\n            for(int i = 0; i < vec.size(); i++){\\n                for(int j = i+1; j < vec.size(); j++){\\n                    int p1 = vec[i].first ;\\n                    int p2 = vec[i].second ;\\n                    int p3 = vec[j].first ;\\n                    double len1 = sqrt(getDist(points[p1], points[p3])) ;\\n                    double len2 = sqrt(getDist(points[p2], points[p3])) ;\\n                    ret = min(ret, len1 * len2) ;\\n                }\\n            }\\n        }\\n        \\n        return (ret == INT_MAX) ? 0 :  ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300670,
                "title": "easy-to-understand-c-solution",
                "content": "\\n\\n# Approach\\nThe approach used in the code is to iterate through all possible combinations of three points, check if they form a right triangle, and then check if there exists a fourth point that can form a rectangle with the three original points. If such a rectangle exists, then its area is calculated and compared to the current minimum area. At the end of the iteration, the minimum area is returned.\\n\\nHere is a breakdown of the main steps in the code:\\n\\n1. First, an unordered_map is created to store all the points. The keys of the map are the x-coordinates and the values are sets of y-coordinates. This is done to easily access points with a particular x-coordinate while checking for rectangles.\\n2. Next, three nested loops are used to generate all possible combinations of three points from the given set of points.\\n3. For each triplet of points (i, j, k), the code checks if they form a right-angled triangle using the formula:\\n- (xj-xi)(xk-xi) + (yj-yi)(yk-yi) = 0\\n\\n- This condition is simplified to dx1dx2 + dy1dy2 == 0\\n- If this condition is satisfied, it means that the three points form a right-angled triangle.\\n\\n4. After finding a right-angled triangle, the code calculates the fourth point (m) which lies on the diagonal opposite to the right angle.\\n5. The coordinates of the fourth point are calculated using the formula:\\nfor \"xm\" --> (xj+xk)/2 = (xm+xi)/2  and for \"ym\" --> (yj+yk)/2 = (ym+yi)/2. After simplify the equation \\n\\n- xm = xj+xk - xi\\n- ym = yj+yk - yi\\n6. Finally, the code calculates the area of the rectangle formed by the four points and checks if it is the minimum area seen so far. If it is, the minimum area is updated.\\nIf no rectangle is found, the function returns 0.0.\\n\\n\\n# Complexity\\n- Time complexity:\\nOverall, the code uses a brute-force approach to check all possible combinations of points, but takes advantage of efficient data structures such as unordered maps and sets to reduce the number of operations required.\\nTC = O(n^3)\\n- Space complexity:\\nSC = O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<int, unordered_set<int>> mp;\\n        for(auto p: points){\\n            mp[p[0]].insert(p[1]); // x-->{y1,y2,..}\\n        }\\n\\n        double area=DBL_MAX; \\n        // Every time we will take three coordinate points(i, j, k) and we will check that can these three point form a right traingle. if slop1*slpo2=-1 then three points form right angle traingle\\n        // slope1 = (yj-yi)/(xj-xi) \\n        // slope2 = (yk-yi)/(xk-xi)\\n\\n        // slope1*slop2=-1, \\n        // simpyfy this==> (xj-xi)*(xk-xi) + (yj-yi)*(yk-yi) =0\\n        // ===>dx1*dx2 + dy1*dy2 ==0[if right angle traingle]\\n\\n        // then we will find fourth point, we know both digonal have same mid points then then \\n        // fourth point(m) can be found as\\n        // (xj+xk)/2 = (xm+xi)/2 ===> xm = xj+xk - xi\\n        // (yj+yk)/2 = (ym+yi)/2 ===> ym = yj+yk - yi\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=i+1; j<points.size(); j++){\\n                for(int k=j+1; k<points.size(); k++){\\n                    // finds dx1, dx2, dy1, dy2\\n                    int dx1 = points[j][0]-points[i][0];\\n                    int dx2 = points[k][0]-points[i][0];\\n                    int dy1 = points[j][1]-points[i][1];\\n                    int dy2 = points[k][1]-points[i][1];\\n                    // check these three points can form a right traingle\\n                    if(dx1*dx2 + dy1*dy2 ==0){ // right traingle\\n                        // find the fourht point \\n                        // intersection point of two digonal will have same points\\n                        // xm = xj+xk - xi, ym = yj+yk - yi\\n                        int xm = dx1 + points[k][0];\\n                        int ym = dy1 + points[k][1];\\n                        // check this point exist into the map\\n                        if(mp[xm].find(ym)!=mp[xm].end()){\\n                            double area1 = sqrt(dx1*dx1 + dy1*dy1)*sqrt(dx2*dx2 + dy2*dy2);\\n                            if(area>area1){\\n                                area = area1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(area == DBL_MAX) return 0.0;\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<int, unordered_set<int>> mp;\\n        for(auto p: points){\\n            mp[p[0]].insert(p[1]); // x-->{y1,y2,..}\\n        }\\n\\n        double area=DBL_MAX; \\n        // Every time we will take three coordinate points(i, j, k) and we will check that can these three point form a right traingle. if slop1*slpo2=-1 then three points form right angle traingle\\n        // slope1 = (yj-yi)/(xj-xi) \\n        // slope2 = (yk-yi)/(xk-xi)\\n\\n        // slope1*slop2=-1, \\n        // simpyfy this==> (xj-xi)*(xk-xi) + (yj-yi)*(yk-yi) =0\\n        // ===>dx1*dx2 + dy1*dy2 ==0[if right angle traingle]\\n\\n        // then we will find fourth point, we know both digonal have same mid points then then \\n        // fourth point(m) can be found as\\n        // (xj+xk)/2 = (xm+xi)/2 ===> xm = xj+xk - xi\\n        // (yj+yk)/2 = (ym+yi)/2 ===> ym = yj+yk - yi\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=i+1; j<points.size(); j++){\\n                for(int k=j+1; k<points.size(); k++){\\n                    // finds dx1, dx2, dy1, dy2\\n                    int dx1 = points[j][0]-points[i][0];\\n                    int dx2 = points[k][0]-points[i][0];\\n                    int dy1 = points[j][1]-points[i][1];\\n                    int dy2 = points[k][1]-points[i][1];\\n                    // check these three points can form a right traingle\\n                    if(dx1*dx2 + dy1*dy2 ==0){ // right traingle\\n                        // find the fourht point \\n                        // intersection point of two digonal will have same points\\n                        // xm = xj+xk - xi, ym = yj+yk - yi\\n                        int xm = dx1 + points[k][0];\\n                        int ym = dy1 + points[k][1];\\n                        // check this point exist into the map\\n                        if(mp[xm].find(ym)!=mp[xm].end()){\\n                            double area1 = sqrt(dx1*dx1 + dy1*dy1)*sqrt(dx2*dx2 + dy2*dy2);\\n                            if(area>area1){\\n                                area = area1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(area == DBL_MAX) return 0.0;\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279091,
                "title": "geometry-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        Set<String> pointSet = new HashSet<>();\\n        for (int[] point : points) {\\n            pointSet.add(point[0] + \",\" + point[1]);\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int[] p1 = points[i];\\n            for (int j = i + 1; j < n; j++) {\\n                int[] p2 = points[j];\\n                for (int k = j + 1; k < n; k++) {\\n                    int[] p3 = points[k];\\n                    int dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1];\\n                    int dx2 = p3[0] - p1[0], dy2 = p3[1] - p1[1];\\n                    if (dx1 * dx2 + dy1 * dy2 == 0) {\\n                        int[] p4 = new int[]{p2[0] + dx2, p2[1] + dy2};\\n                        String p4Str = p4[0] + \",\" + p4[1];\\n                        if (pointSet.contains(p4Str)) {\\n                            double area = Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);\\n                            minArea = Math.min(minArea, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Geometry",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        Set<String> pointSet = new HashSet<>();\\n        for (int[] point : points) {\\n            pointSet.add(point[0] + \",\" + point[1]);\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int[] p1 = points[i];\\n            for (int j = i + 1; j < n; j++) {\\n                int[] p2 = points[j];\\n                for (int k = j + 1; k < n; k++) {\\n                    int[] p3 = points[k];\\n                    int dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1];\\n                    int dx2 = p3[0] - p1[0], dy2 = p3[1] - p1[1];\\n                    if (dx1 * dx2 + dy1 * dy2 == 0) {\\n                        int[] p4 = new int[]{p2[0] + dx2, p2[1] + dy2};\\n                        String p4Str = p4[0] + \",\" + p4[1];\\n                        if (pointSet.contains(p4Str)) {\\n                            double area = Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);\\n                            minArea = Math.min(minArea, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202625,
                "title": "solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int len = points.length;\\n        double res = Double.MAX_VALUE;\\n        if (len < 4) return 0.0;\\n        Map<String, List<int[]>> map = new HashMap<>(); // int[] is the index of two points forming the diagonal\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                long dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                double centerX = (double)(points[j][0] + points[i][0])/2; // centerX and centerY is the coordinate of the diagonal center\\n                double centerY = (double)(points[j][1] + points[i][1])/2;\\n                String key = \"\" + dis + \"+\" + centerX + \"+\" + centerY; // key includes the length of the diagonal and the coordinate of the diagonal center\\n                if (map.get(key) == null) map.put(key, new ArrayList<int[]>());\\n                map.get(key).add(new int[]{i,j});\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            if (map.get(key).size() > 1) {  \\n                List<int[]> list = map.get(key);\\n                for (int i = 0; i < list.size(); i++) { // there could be multiple rectangles inside\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        int p1 = list.get(i)[0]; // p1, p2 and p3 are the three vertices of a rectangle\\n                        int p2 = list.get(j)[0];\\n                        int p3 = list.get(j)[1];\\n                        // len1 and len2 are the length of the sides of a rectangle\\n                        double len1 = Math.sqrt((points[p1][0] - points[p2][0]) * (points[p1][0] - points[p2][0]) +  (points[p1][1] - points[p2][1]) * (points[p1][1] - points[p2][1])); \\n                        double len2 = Math.sqrt((points[p1][0] - points[p3][0]) * (points[p1][0] - points[p3][0]) +  (points[p1][1] - points[p3][1]) * (points[p1][1] - points[p3][1]));\\n                        double area = len1 * len2; \\n                        res = Math.min(res, area);\\n                    }\\n                }\\n            }\\n        }\\n        return res == Double.MAX_VALUE ?  0.0 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int len = points.length;\\n        double res = Double.MAX_VALUE;\\n        if (len < 4) return 0.0;\\n        Map<String, List<int[]>> map = new HashMap<>(); // int[] is the index of two points forming the diagonal\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                long dis = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                double centerX = (double)(points[j][0] + points[i][0])/2; // centerX and centerY is the coordinate of the diagonal center\\n                double centerY = (double)(points[j][1] + points[i][1])/2;\\n                String key = \"\" + dis + \"+\" + centerX + \"+\" + centerY; // key includes the length of the diagonal and the coordinate of the diagonal center\\n                if (map.get(key) == null) map.put(key, new ArrayList<int[]>());\\n                map.get(key).add(new int[]{i,j});\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            if (map.get(key).size() > 1) {  \\n                List<int[]> list = map.get(key);\\n                for (int i = 0; i < list.size(); i++) { // there could be multiple rectangles inside\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        int p1 = list.get(i)[0]; // p1, p2 and p3 are the three vertices of a rectangle\\n                        int p2 = list.get(j)[0];\\n                        int p3 = list.get(j)[1];\\n                        // len1 and len2 are the length of the sides of a rectangle\\n                        double len1 = Math.sqrt((points[p1][0] - points[p2][0]) * (points[p1][0] - points[p2][0]) +  (points[p1][1] - points[p2][1]) * (points[p1][1] - points[p2][1])); \\n                        double len2 = Math.sqrt((points[p1][0] - points[p3][0]) * (points[p1][0] - points[p3][0]) +  (points[p1][1] - points[p3][1]) * (points[p1][1] - points[p3][1]));\\n                        double area = len1 * len2; \\n                        res = Math.min(res, area);\\n                    }\\n                }\\n            }\\n        }\\n        return res == Double.MAX_VALUE ?  0.0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127517,
                "title": "simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    size_t d2(int x1, int y1, int x2, int y2) {\\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, unordered_map<size_t, vector<vector<int>>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      auto len = d2(ps[i][0], ps[i][1], ps[j][0], ps[j][1]);\\n      m[center][len].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it_c = begin(m); it_c != end(m); ++it_c)\\n    for (auto it_l = begin(it_c->second); it_l != end(it_c->second); ++it_l)\\n      for (auto i = 0; i < it_l->second.size(); ++i)\\n        for (auto j = i + 1; j < it_l->second.size(); ++j) {\\n          auto &p1 = it_l->second[i], &p2 = it_l->second[j];\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n  return sqrt(res);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    size_t d2(int x1, int y1, int x2, int y2) {\\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& ps, size_t res = 0) {\\n  unordered_map<size_t, unordered_map<size_t, vector<vector<int>>>> m;\\n  for (auto i = 0; i < ps.size(); ++i)\\n    for (auto j = i + 1; j < ps.size(); ++j) {\\n      auto center = ((size_t)(ps[i][0] + ps[j][0]) << 16) + ps[i][1] + ps[j][1];\\n      auto len = d2(ps[i][0], ps[i][1], ps[j][0], ps[j][1]);\\n      m[center][len].push_back({ ps[i][0], ps[i][1], ps[j][0], ps[j][1] });\\n    }\\n  for (auto it_c = begin(m); it_c != end(m); ++it_c)\\n    for (auto it_l = begin(it_c->second); it_l != end(it_c->second); ++it_l)\\n      for (auto i = 0; i < it_l->second.size(); ++i)\\n        for (auto j = i + 1; j < it_l->second.size(); ++j) {\\n          auto &p1 = it_l->second[i], &p2 = it_l->second[j];\\n          auto area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n          if (res == 0 || res > area) res = area;\\n        }\\n  return sqrt(res);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012497,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar minAreaFreeRect = function(points) {\\n    const diagonalMap = new Map();\\n    let result = Infinity;\\n\\n    for (let a = 0; a < points.length - 1; a++) {\\n        const [x1, y1] = points[a];\\n        for (let b = a + 1; b < points.length; b++) {\\n            const [x2, y2] = points[b];\\n            const diagonal = calculateeDiagonal(x1, y1, x2, y2);\\n            const centerX = (x1 + x2) / 2;\\n            const centerY = (y1 + y2) / 2;\\n            const key = `${diagonal}_${centerX}_${centerY}`;\\n            const vectors = diagonalMap.get(key) ?? [];\\n\\n            vectors.push({ x1, x2, y1, y2 });\\n            diagonalMap.set(key, vectors);\\n        }\\n    }\\n\\n    for (const [key, vector] of diagonalMap) {\\n        if (vector.length < 2) continue;\\n        for (let a = 0; a < vector.length - 1; a++) {\\n            const vectorA = vector[a];\\n            for (let b = a + 1; b < vector.length; b++) {\\n                const vectorB = vector[b];\\n                const w = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x1, vectorB.y1));\\n                const h = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x2, vectorB.y2));\\n\\n                result = Math.min(result, w * h);\\n            }\\n        }\\n    }\\n    return result === Infinity ? 0 : result;\\n\\n    function calculateeDiagonal(x1, y1, x2, y2) {\\n        return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minAreaFreeRect = function(points) {\\n    const diagonalMap = new Map();\\n    let result = Infinity;\\n\\n    for (let a = 0; a < points.length - 1; a++) {\\n        const [x1, y1] = points[a];\\n        for (let b = a + 1; b < points.length; b++) {\\n            const [x2, y2] = points[b];\\n            const diagonal = calculateeDiagonal(x1, y1, x2, y2);\\n            const centerX = (x1 + x2) / 2;\\n            const centerY = (y1 + y2) / 2;\\n            const key = `${diagonal}_${centerX}_${centerY}`;\\n            const vectors = diagonalMap.get(key) ?? [];\\n\\n            vectors.push({ x1, x2, y1, y2 });\\n            diagonalMap.set(key, vectors);\\n        }\\n    }\\n\\n    for (const [key, vector] of diagonalMap) {\\n        if (vector.length < 2) continue;\\n        for (let a = 0; a < vector.length - 1; a++) {\\n            const vectorA = vector[a];\\n            for (let b = a + 1; b < vector.length; b++) {\\n                const vectorB = vector[b];\\n                const w = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x1, vectorB.y1));\\n                const h = Math.sqrt(calculateeDiagonal(vectorA.x1, vectorA.y1, vectorB.x2, vectorB.y2));\\n\\n                result = Math.min(result, w * h);\\n            }\\n        }\\n    }\\n    return result === Infinity ? 0 : result;\\n\\n    function calculateeDiagonal(x1, y1, x2, y2) {\\n        return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3001608,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_area_free_rect(points: Vec<Vec<i32>>) -> f64 {\\n        fn d2(x1: i64, y1: i64, x2: i64, y2: i64) -> i64 {\\n            (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\\n        }\\n        let points = points\\n            .iter()\\n            .map(|v| v.iter().map(|&x| x as i64).collect::<Vec<_>>())\\n            .collect::<Vec<_>>();\\n        let mut res = 0;\\n        let mut m = std::collections::HashMap::new();\\n        for i in 0..points.len() {\\n            for j in i + 1..points.len() {\\n                let pt_i_0 = points[i][0];\\n                let pt_i_1 = points[i][1];\\n                let pt_j_0 = points[j][0];\\n                let pt_j_1 = points[j][1];\\n                let center = (((pt_i_0 + pt_j_0) as u64) << 16) + (pt_i_1 + pt_j_1) as u64;\\n                let v = vec![pt_i_0, pt_i_1, pt_j_0, pt_j_1];\\n                m.entry(center).or_insert_with(Vec::new).push(v);\\n            }\\n        }\\n        for (_center, points) in m {\\n            for i in 0..points.len() {\\n                for j in i + 1..points.len() {\\n                    let p1 = &points[i];\\n                    let p2 = &points[j];\\n                    if (p1[0] - p2[0]) * (p1[0] - p2[2]) + (p1[1] - p2[1]) * (p1[1] - p2[3]) == 0 {\\n                        let area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n                        if res == 0 || res > area {\\n                            res = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        (res as f64).sqrt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_area_free_rect(points: Vec<Vec<i32>>) -> f64 {\\n        fn d2(x1: i64, y1: i64, x2: i64, y2: i64) -> i64 {\\n            (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\\n        }\\n        let points = points\\n            .iter()\\n            .map(|v| v.iter().map(|&x| x as i64).collect::<Vec<_>>())\\n            .collect::<Vec<_>>();\\n        let mut res = 0;\\n        let mut m = std::collections::HashMap::new();\\n        for i in 0..points.len() {\\n            for j in i + 1..points.len() {\\n                let pt_i_0 = points[i][0];\\n                let pt_i_1 = points[i][1];\\n                let pt_j_0 = points[j][0];\\n                let pt_j_1 = points[j][1];\\n                let center = (((pt_i_0 + pt_j_0) as u64) << 16) + (pt_i_1 + pt_j_1) as u64;\\n                let v = vec![pt_i_0, pt_i_1, pt_j_0, pt_j_1];\\n                m.entry(center).or_insert_with(Vec::new).push(v);\\n            }\\n        }\\n        for (_center, points) in m {\\n            for i in 0..points.len() {\\n                for j in i + 1..points.len() {\\n                    let p1 = &points[i];\\n                    let p2 = &points[j];\\n                    if (p1[0] - p2[0]) * (p1[0] - p2[2]) + (p1[1] - p2[1]) * (p1[1] - p2[3]) == 0 {\\n                        let area = d2(p1[0], p1[1], p2[0], p2[1]) * d2(p1[0], p1[1], p2[2], p2[3]);\\n                        if res == 0 || res > area {\\n                            res = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        (res as f64).sqrt()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924041,
                "title": "group-all-pairs-by-slopes-anf-lengths",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dist(self, a, b):\\n        return (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])\\n\\n    def area(self, a, b, c, d):\\n        if self.dist(a, c) != self.dist(b, d):\\n            return float(\\'inf\\')\\n        if a[0] + c[0] != b[0] + d[0] or a[1] + c[1] != b[1] + d[1]:\\n            return float(\\'inf\\')\\n        return self.dist(a, b) * self.dist(a, d)\\n    \\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        n = len(points)\\n        pairs = defaultdict(lambda: defaultdict(list))\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a, b = points[i]\\n                c, d = points[j]\\n                x, y = c - a, d - b\\n                if y < 0:\\n                    x, y = -x, -y\\n                mul = self.gcd(abs(x), abs(y))\\n                x //= mul\\n                y //= mul\\n                if x >= 0 and y >= 0:\\n                    pairs[(x, y)][self.dist((a, b), (c, d))].append((i, j))\\n        res = float(\\'inf\\')\\n        for slope in pairs:\\n            for d in pairs[slope]:\\n                m = len(pairs[slope][d])\\n                for i in range(m):\\n                    for j in range(i + 1, m):\\n                        p, q = pairs[slope][d][i]\\n                        r, s = pairs[slope][d][j]\\n                        p, q, s, r = sorted([p, q, r, s], key = lambda x: points[x])\\n                        res = min(res, self.area(points[p], points[q], points[r], points[s]))\\n        if res == float(\\'inf\\'):\\n            return 0\\n        return res ** 0.5\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dist(self, a, b):\\n        return (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])\\n\\n    def area(self, a, b, c, d):\\n        if self.dist(a, c) != self.dist(b, d):\\n            return float(\\'inf\\')\\n        if a[0] + c[0] != b[0] + d[0] or a[1] + c[1] != b[1] + d[1]:\\n            return float(\\'inf\\')\\n        return self.dist(a, b) * self.dist(a, d)\\n    \\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        n = len(points)\\n        pairs = defaultdict(lambda: defaultdict(list))\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                a, b = points[i]\\n                c, d = points[j]\\n                x, y = c - a, d - b\\n                if y < 0:\\n                    x, y = -x, -y\\n                mul = self.gcd(abs(x), abs(y))\\n                x //= mul\\n                y //= mul\\n                if x >= 0 and y >= 0:\\n                    pairs[(x, y)][self.dist((a, b), (c, d))].append((i, j))\\n        res = float(\\'inf\\')\\n        for slope in pairs:\\n            for d in pairs[slope]:\\n                m = len(pairs[slope][d])\\n                for i in range(m):\\n                    for j in range(i + 1, m):\\n                        p, q = pairs[slope][d][i]\\n                        r, s = pairs[slope][d][j]\\n                        p, q, s, r = sorted([p, q, r, s], key = lambda x: points[x])\\n                        res = min(res, self.area(points[p], points[q], points[r], points[s]))\\n        if res == float(\\'inf\\'):\\n            return 0\\n        return res ** 0.5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757454,
                "title": "python-two-solutions-with-explanation",
                "content": "**The Logic**:\\n*I Solution*\\nI created a dictionary `d` to keep all pairs of dots as values and a tuple of two elements described below as keys.\\nTwo elements of keys are segment distance (between two points) and alpha (angle with X-axis). To simplify calculations, I used squared distance instead of distance (to save on sqrt computations) and the difference between x coordinates between two points and a sign of the difference in y coordinates. Why? knowing the distance and the difference - it is enough information to calculate the angle (cos).\\nThus, in each key, I keep pairs of dots with the same length and which are parallel to each other.\\nI loop through the items of `d` and check all pairs between pairs of points (4 points). I check if I can build a rectangle from them and if yes - I calculate the area of rectangular. \\n**Time complexity is difficult to measure but it runs faster than the next solution**\\n```\\nfrom math import sqrt\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def isPerp(p1, p2, p3):\\n            v1 = (p1[0] - p2[0], p1[1] - p2[1])\\n            v2 = (p2[0] - p3[0], p2[1] - p3[1])\\n            return (v1[0] * v2[0] + v1[1] * v2[1]) == 0\\n        def sq3(p1, p2, p3):\\n            return sqrt((p3[0] - p2[0])**2 + (p3[1] - p2[1])**2) * sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)\\n        def squareR(p1, p2, p3, p4):\\n            if (isPerp(p1, p3, p4) and isPerp(p2, p4, p3)):\\n                return sq3(p1, p3, p4)\\n            if (isPerp(p2, p3, p4) and isPerp(p1, p4, p3)):\\n                return sq3(p2, p3, p4)\\n            return 0\\n            \\n        d = dict()\\n        for i in range(len(points) - 1):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, len(points)):\\n                x2, y2 = points[j]\\n                l = (x1-x2)**2 + (y1-y2)**2\\n                a = (x2 - x1) if y2 >= y1 else x1 - x2\\n                t = (l, a)\\n                if t not in d:\\n                    d[t] = []\\n                d[t].append((points[i], points[j]))\\n        ans = float(\\'inf\\')\\n        for (l, xDiff), v in d.items():\\n            xDiff = abs(xDiff)\\n            for i in range(len(v) - 1):\\n                p1, p2 = v[i]\\n                for j in range(i + 1, len(v)):\\n                    p3, p4 = v[j]\\n                    s = squareR(p1, p2, p3, p4)\\n                    if s:\\n                        ans = min(ans, s)\\n        return ans if ans < float(\\'inf\\') else 0\\n```\\n\\n*II Solution*\\nIn the second solution, we iterate through the points checking different combinations of three points (that is why we have three nested loops). If those three points are orthogonal (p1-p2  and p1-p3) we can understand the next point\\'s coordinates and check them in the set of points. If p4 is in the set, we calculate the area.\\n**Time complexity O(N^3)**\\n\\n```\\nfrom math import sqrt\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def findArea(i, j, k):\\n            x1, y1 = points[i]\\n            x2, y2 = points[j]\\n            x3, y3 = points[k]\\n            if x1 == x2 == x3:\\n                return False, 0\\n            xv, yv = x2 - x1, y2 - y1\\n            xu, yu = x3 - x1, y3 - y1\\n            if not (xv * xu + yv * yu) == 0:\\n                return False, 0\\n            p4 = (xv + x3, yv + y3)\\n            if not p4 in pSet:\\n                return False, 0\\n            a = (xv**2 + yv**2) * (xu**2 + yu**2)\\n            return a != 0, a\\n\\n        points.sort()\\n        pSet = set(map(tuple, points))\\n        ans = float(\\'inf\\')\\n        for i in range(len(points) - 3):\\n            for j in range(i + 1, len(points) - 2):\\n                for k in range(j + 1, len(points) - 1):\\n                    isFind, ar = findArea(i, j, k)\\n                    if isFind:\\n                        ans = min(ans, ar)\\n        return sqrt(ans) if ans < float(\\'inf\\') else 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import sqrt\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def isPerp(p1, p2, p3):\\n            v1 = (p1[0] - p2[0], p1[1] - p2[1])\\n            v2 = (p2[0] - p3[0], p2[1] - p3[1])\\n            return (v1[0] * v2[0] + v1[1] * v2[1]) == 0\\n        def sq3(p1, p2, p3):\\n            return sqrt((p3[0] - p2[0])**2 + (p3[1] - p2[1])**2) * sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)\\n        def squareR(p1, p2, p3, p4):\\n            if (isPerp(p1, p3, p4) and isPerp(p2, p4, p3)):\\n                return sq3(p1, p3, p4)\\n            if (isPerp(p2, p3, p4) and isPerp(p1, p4, p3)):\\n                return sq3(p2, p3, p4)\\n            return 0\\n            \\n        d = dict()\\n        for i in range(len(points) - 1):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, len(points)):\\n                x2, y2 = points[j]\\n                l = (x1-x2)**2 + (y1-y2)**2\\n                a = (x2 - x1) if y2 >= y1 else x1 - x2\\n                t = (l, a)\\n                if t not in d:\\n                    d[t] = []\\n                d[t].append((points[i], points[j]))\\n        ans = float(\\'inf\\')\\n        for (l, xDiff), v in d.items():\\n            xDiff = abs(xDiff)\\n            for i in range(len(v) - 1):\\n                p1, p2 = v[i]\\n                for j in range(i + 1, len(v)):\\n                    p3, p4 = v[j]\\n                    s = squareR(p1, p2, p3, p4)\\n                    if s:\\n                        ans = min(ans, s)\\n        return ans if ans < float(\\'inf\\') else 0\\n```\n```\\nfrom math import sqrt\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        def findArea(i, j, k):\\n            x1, y1 = points[i]\\n            x2, y2 = points[j]\\n            x3, y3 = points[k]\\n            if x1 == x2 == x3:\\n                return False, 0\\n            xv, yv = x2 - x1, y2 - y1\\n            xu, yu = x3 - x1, y3 - y1\\n            if not (xv * xu + yv * yu) == 0:\\n                return False, 0\\n            p4 = (xv + x3, yv + y3)\\n            if not p4 in pSet:\\n                return False, 0\\n            a = (xv**2 + yv**2) * (xu**2 + yu**2)\\n            return a != 0, a\\n\\n        points.sort()\\n        pSet = set(map(tuple, points))\\n        ans = float(\\'inf\\')\\n        for i in range(len(points) - 3):\\n            for j in range(i + 1, len(points) - 2):\\n                for k in range(j + 1, len(points) - 1):\\n                    isFind, ar = findArea(i, j, k)\\n                    if isFind:\\n                        ans = min(ans, ar)\\n        return sqrt(ans) if ans < float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735636,
                "title": "easy-swift-solution",
                "content": "For every combination of all three points:\\nDetermine if the inner product of those three points is zero to make a right angle.\\nCalculate the area of the rectangle created by those 3 points by outer product and determine that it is the smallest.\\nConfirm that there exists a fourth point that constitutes a rectangle.\\n```\\nstruct Po:Hashable {\\n    var x: Int\\n    var y: Int\\n    init(_ p: [Int]){\\n        x = p[0]\\n        y = p[1]\\n    }\\n}\\n\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        var ps: Set<Po> = Set(points.map { Po($0) } )\\n        let n = points.count\\n        var ret = Int.max\\n        for i in 0..<n {\\n            for j in 0..<n {\\n                if i != j {\\n                    for k in 0..<n {\\n                        if k != i && k != j  {\\n                            let ux = points[i][0] - points[k][0]\\n                            let uy = points[i][1] - points[k][1]\\n                            let vx = points[j][0] - points[k][0]\\n                            let vy = points[j][1] - points[k][1]\\n                            if ux*vx + uy*vy == 0 { //Three points make a right angle\\n                                let r = abs(ux*vy - vx*uy)\\n                                if r < ret { //Smallest area\\n                                    let np = [points[i][0]+vx, points[i][1]+vy]\\n                                    if ps.contains(Po(np)) { //The forth point exists\\n                                        ret = r\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if ret == Int.max { return 0}\\n        return Double(ret)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nstruct Po:Hashable {\\n    var x: Int\\n    var y: Int\\n    init(_ p: [Int]){\\n        x = p[0]\\n        y = p[1]\\n    }\\n}\\n\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        var ps: Set<Po> = Set(points.map { Po($0) } )\\n        let n = points.count\\n        var ret = Int.max\\n        for i in 0..<n {\\n            for j in 0..<n {\\n                if i != j {\\n                    for k in 0..<n {\\n                        if k != i && k != j  {\\n                            let ux = points[i][0] - points[k][0]\\n                            let uy = points[i][1] - points[k][1]\\n                            let vx = points[j][0] - points[k][0]\\n                            let vy = points[j][1] - points[k][1]\\n                            if ux*vx + uy*vy == 0 { //Three points make a right angle\\n                                let r = abs(ux*vy - vx*uy)\\n                                if r < ret { //Smallest area\\n                                    let np = [points[i][0]+vx, points[i][1]+vy]\\n                                    if ps.contains(Po(np)) { //The forth point exists\\n                                        ret = r\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if ret == Int.max { return 0}\\n        return Double(ret)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718568,
                "title": "c-solution-no-mistakes-faster-than-57-submissions",
                "content": "Basic geometry. \\n\\n* No need to calculate right angles explicitly using acos. The cross products between lines which forms right angles are 0 already.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> R;\\n    bool isR(vector<int>& a, vector<int>& o, vector<int>& b) {\\n        int ca = (a[0] - o[0]) * (b[0] - o[0]);\\n        int cb = (a[1] - o[1]) * (b[1] - o[1]);\\n        return ca + cb == 0 ? true : false;\\n    }\\n    double line(vector<int>& a, vector<int>& b) {\\n        int x = a[0] - b[0];\\n        int y = a[1] - b[1];\\n        return std::sqrt(x * x + y * y);\\n    }\\n    double area(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        return line(a, b) * line(b, c);\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int len = points.size();\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                for (int k = j + 1; k < len; k++) {\\n                    if (isR(points[i], points[j], points[k])) {\\n                        R.push_back({i,j,k});\\n                    }\\n                    if (isR(points[j], points[k], points[i])) {\\n                        R.push_back({i,k,j});\\n                    }\\n                    if (isR(points[k], points[i], points[j])) {\\n                        R.push_back({j,i,k});\\n                    }\\n                }\\n            }\\n        }\\n        int rlen = R.size();\\n        vector<int> a, b, c, d;\\n        double res = -1.0;\\n        for (int i = 0; i < rlen; i++) {\\n            for (int j = i + 1; j < rlen; j++) {\\n                if (R[i][0] == R[j][0] && R[i][2] == R[j][2]) {\\n                    a = points[R[i][1]];\\n                    b = points[R[i][0]];\\n                    c = points[R[i][2]];\\n                    d = points[R[j][1]];\\n                    if (isR(a, b, d) && isR(a, c, d)) {\\n                        if (res == -1.0) {\\n                            res = area(b, a, c);\\n                        }\\n                        else {\\n                            double tmp = area(b, a, c);\\n                            if (tmp < res)\\n                                res = tmp;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res == -1.0 ? 0.0 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> R;\\n    bool isR(vector<int>& a, vector<int>& o, vector<int>& b) {\\n        int ca = (a[0] - o[0]) * (b[0] - o[0]);\\n        int cb = (a[1] - o[1]) * (b[1] - o[1]);\\n        return ca + cb == 0 ? true : false;\\n    }\\n    double line(vector<int>& a, vector<int>& b) {\\n        int x = a[0] - b[0];\\n        int y = a[1] - b[1];\\n        return std::sqrt(x * x + y * y);\\n    }\\n    double area(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        return line(a, b) * line(b, c);\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int len = points.size();\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                for (int k = j + 1; k < len; k++) {\\n                    if (isR(points[i], points[j], points[k])) {\\n                        R.push_back({i,j,k});\\n                    }\\n                    if (isR(points[j], points[k], points[i])) {\\n                        R.push_back({i,k,j});\\n                    }\\n                    if (isR(points[k], points[i], points[j])) {\\n                        R.push_back({j,i,k});\\n                    }\\n                }\\n            }\\n        }\\n        int rlen = R.size();\\n        vector<int> a, b, c, d;\\n        double res = -1.0;\\n        for (int i = 0; i < rlen; i++) {\\n            for (int j = i + 1; j < rlen; j++) {\\n                if (R[i][0] == R[j][0] && R[i][2] == R[j][2]) {\\n                    a = points[R[i][1]];\\n                    b = points[R[i][0]];\\n                    c = points[R[i][2]];\\n                    d = points[R[j][1]];\\n                    if (isR(a, b, d) && isR(a, c, d)) {\\n                        if (res == -1.0) {\\n                            res = area(b, a, c);\\n                        }\\n                        else {\\n                            double tmp = area(b, a, c);\\n                            if (tmp < res)\\n                                res = tmp;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res == -1.0 ? 0.0 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686177,
                "title": "ruby-t-o-n2-s-o-n2-100-100-vector",
                "content": "Base of vector theory\\n\\n- 2 lines are possibly in the same rectangle if they are parallel and have the same length => their vectors are either the same or the reverse.\\n- 2 lines are perpendicular only if their dot product equals to 0\\n\\nWith that, we can come up with a 3-step solution:\\n- First, group all lines that forming the same vector\\n- Second, for each group, find the groups of 2 that their vectors form a dot product of 0, those 4 will form a rectangle\\n- The area of the rectangle will be product of their vector lengths, loop and update the min\\n\\n```\\n# @param {Integer[][]} points\\n# @return {Float}\\ndef min_area_free_rect(points)\\n  vectors = {}\\n\\n  points.combination(2).each do |(x1, y1), (x2, y2)|\\n    if x1 < x2 || y1 < y2\\n      x1, y1, x2, y2 = x2, y2, x1, y1\\n    end\\n    vector = [x1 - x2, y1 - y2]\\n\\n    vectors[vector] ||= []\\n    vectors[vector] << [x1, y1]\\n  end\\n\\n  min = nil\\n  \\n  vectors.each do |vector, grp|\\n    next if grp.size < 2\\n    v0x, v0y = vector\\n    l1 = Math.sqrt(v0x * v0x + v0y * v0y)\\n\\n    grp.combination(2).each do |(x01, y01), (x11, y11)|\\n      v1x = x11 - x01\\n      v1y = y11 - y01\\n\\n      if v0x * v1x + v0y * v1y == 0\\n        l2 = Math.sqrt(v1x * v1x + v1y * v1y)\\n        min = [min, l1 * l2].compact.min\\n      end\\n    end\\n  end\\n\\n  min || 0\\nend\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "Base of vector theory\\n\\n- 2 lines are possibly in the same rectangle if they are parallel and have the same length => their vectors are either the same or the reverse.\\n- 2 lines are perpendicular only if their dot product equals to 0\\n\\nWith that, we can come up with a 3-step solution:\\n- First, group all lines that forming the same vector\\n- Second, for each group, find the groups of 2 that their vectors form a dot product of 0, those 4 will form a rectangle\\n- The area of the rectangle will be product of their vector lengths, loop and update the min\\n\\n```\\n# @param {Integer[][]} points\\n# @return {Float}\\ndef min_area_free_rect(points)\\n  vectors = {}\\n\\n  points.combination(2).each do |(x1, y1), (x2, y2)|\\n    if x1 < x2 || y1 < y2\\n      x1, y1, x2, y2 = x2, y2, x1, y1\\n    end\\n    vector = [x1 - x2, y1 - y2]\\n\\n    vectors[vector] ||= []\\n    vectors[vector] << [x1, y1]\\n  end\\n\\n  min = nil\\n  \\n  vectors.each do |vector, grp|\\n    next if grp.size < 2\\n    v0x, v0y = vector\\n    l1 = Math.sqrt(v0x * v0x + v0y * v0y)\\n\\n    grp.combination(2).each do |(x01, y01), (x11, y11)|\\n      v1x = x11 - x01\\n      v1y = y11 - y01\\n\\n      if v0x * v1x + v0y * v1y == 0\\n        l2 = Math.sqrt(v1x * v1x + v1y * v1y)\\n        min = [min, l1 * l2].compact.min\\n      end\\n    end\\n  end\\n\\n  min || 0\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2587864,
                "title": "java-36-ms-80-faster",
                "content": "\\tdouble[][] distance;\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        distance = new double[n][n];\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                double d = getDistanceBtw(points[i], points[j]);\\n                distance[i][j] = d;\\n                distance[j][i] = d;\\n            }\\n        }\\n        \\n        double minArea = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    double dij = distance[i][j];\\n                    double dik = distance[i][k];\\n                    double djk = distance[j][k];\\n                    double area = Integer.MAX_VALUE;\\n                    if(isRightAngleTri(i,j,k)) {\\n                        area = findFourthPoint(i, j, k);\\n                    } else if(isRightAngleTri(i,k,j)) {\\n                        area = findFourthPoint(i, j, k);\\n                    } else if(isRightAngleTri(j,k,i)) {\\n                        area = findFourthPoint(i, j, k);\\n                    }\\n                    \\n                    minArea = Math.min(area, minArea);\\n                }\\n            }\\n        }\\n        return minArea == Integer.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    public double findFourthPoint(int x, int y, int z) {\\n        for(int i=0; i<distance.length; i++) {\\n            if(i != x && i != y && i != z){\\n                if(distance[z][i] == distance[x][y] && isRightAngleTri(x,y,i)) {\\n                    double area = Math.sqrt(distance[x][z]) * Math.sqrt(distance[y][z]);\\n                    return area;\\n                }\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n    \\n    \\n    \\n    public boolean isRightAngleTri(int x, int y, int z) {\\n        double hyp = distance[x][y];\\n        double side1 = distance[x][z];\\n        double side2 = distance[y][z];\\n        if(hyp == side1 + side2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public double getDistanceBtw(int[] p1, int[] p2) {\\n        double x = p1[0] - p2[0];\\n        double y = p1[1] - p2[1];\\n        double d = x*x + y*y;\\n        return d;\\n    }",
                "solutionTags": [],
                "code": "\\tdouble[][] distance;\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        distance = new double[n][n];\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                double d = getDistanceBtw(points[i], points[j]);\\n                distance[i][j] = d;\\n                distance[j][i] = d;\\n            }\\n        }\\n        \\n        double minArea = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            for(int j=i+1; j<n; j++) {\\n                for(int k=j+1; k<n; k++) {\\n                    double dij = distance[i][j];\\n                    double dik = distance[i][k];\\n                    double djk = distance[j][k];\\n                    double area = Integer.MAX_VALUE;\\n                    if(isRightAngleTri(i,j,k)) {\\n                        area = findFourthPoint(i, j, k);\\n                    } else if(isRightAngleTri(i,k,j)) {\\n                        area = findFourthPoint(i, j, k);\\n                    } else if(isRightAngleTri(j,k,i)) {\\n                        area = findFourthPoint(i, j, k);\\n                    }\\n                    \\n                    minArea = Math.min(area, minArea);\\n                }\\n            }\\n        }\\n        return minArea == Integer.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    public double findFourthPoint(int x, int y, int z) {\\n        for(int i=0; i<distance.length; i++) {\\n            if(i != x && i != y && i != z){\\n                if(distance[z][i] == distance[x][y] && isRightAngleTri(x,y,i)) {\\n                    double area = Math.sqrt(distance[x][z]) * Math.sqrt(distance[y][z]);\\n                    return area;\\n                }\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n    \\n    \\n    \\n    public boolean isRightAngleTri(int x, int y, int z) {\\n        double hyp = distance[x][y];\\n        double side1 = distance[x][z];\\n        double side2 = distance[y][z];\\n        if(hyp == side1 + side2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public double getDistanceBtw(int[] p1, int[] p2) {\\n        double x = p1[0] - p2[0];\\n        double y = p1[1] - p2[1];\\n        double d = x*x + y*y;\\n        return d;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2507171,
                "title": "python-pythagorean-theorem-o-n-3-easy-solution-with-comments",
                "content": "class Solution(object):\\n    def minAreaFreeRect(self, points):\\n\\n        #Basic idea:\\n        #Iterate all possible 3 points combination\\n        #If they can form a rectangle (By Pythagorean theorem), find the 4th point:\\n        #   then check whether the 4th point in points or not\\n        #        if 4th point in points:\\n        #           calculate their area\\n        #Return the min area\\n        \\n        pLen = len(points)\\n       \\n        \\n        setPts = set((points[i][0],points[i][1]) for i in range(pLen))\\n\\n        distIJMat = [[0 for j in range(pLen)] for i in range(pLen)]\\n        \\n        #Find the distance square between any two points i,j\\n        for i in range(pLen - 1):\\n            for j in range(i, pLen):\\n                distTmp = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\\n                distIJMat[j][i] = distTmp\\n                distIJMat[i][j] = distTmp\\n\\n        areas = []\\n\\n        for i in range(pLen - 2):\\n            for j in range(i + 1, pLen - 1):\\n                for k in range(j + 1, pLen):\\n                    \\n                    if(distIJMat[i][j] == distIJMat[i][k] + distIJMat[j][k]):\\n                        pt1, pt2, pt3 = k, i, j\\n                    elif(distIJMat[j][k] == distIJMat[i][k] + distIJMat[j][i]):\\n                        pt1, pt2, pt3 = i, j, k\\n                    elif(distIJMat[k][i] == distIJMat[i][j] + distIJMat[j][k]):\\n                        pt1, pt2, pt3 = j, i, k\\n                    else:\\n                        continue\\n                        \\n                    pt4 = points[pt2][0] + points[pt3][0] - points[pt1][0], points[pt2][1] + points[pt3][1] - points[pt1][1]\\n                    \\n                    if(pt4 not in setPts):\\n                        continue\\n                        \\n                    areas.append(distIJMat[pt1][pt2] *  distIJMat[pt1][pt3])\\n\\n        if(areas == []):\\n            return 0\\n        else:\\n            return sqrt(min(areas))\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def minAreaFreeRect(self, points):\\n\\n        #Basic idea:\\n        #Iterate all possible 3 points combination\\n        #If they can form a rectangle (By Pythagorean theorem), find the 4th point:\\n        #   then check whether the 4th point in points or not\\n        #        if 4th point in points:\\n        #           calculate their area\\n        #Return the min area\\n        \\n        pLen = len(points)\\n       \\n        \\n        setPts = set((points[i][0],points[i][1]) for i in range(pLen))\\n\\n        distIJMat = [[0 for j in range(pLen)] for i in range(pLen)]\\n        \\n        #Find the distance square between any two points i,j\\n        for i in range(pLen - 1):\\n            for j in range(i, pLen):\\n                distTmp = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\\n                distIJMat[j][i] = distTmp\\n                distIJMat[i][j] = distTmp\\n\\n        areas = []\\n\\n        for i in range(pLen - 2):\\n            for j in range(i + 1, pLen - 1):\\n                for k in range(j + 1, pLen):\\n                    \\n                    if(distIJMat[i][j] == distIJMat[i][k] + distIJMat[j][k]):\\n                        pt1, pt2, pt3 = k, i, j\\n                    elif(distIJMat[j][k] == distIJMat[i][k] + distIJMat[j][i]):\\n                        pt1, pt2, pt3 = i, j, k\\n                    elif(distIJMat[k][i] == distIJMat[i][j] + distIJMat[j][k]):\\n                        pt1, pt2, pt3 = j, i, k\\n                    else:\\n                        continue\\n                        \\n                    pt4 = points[pt2][0] + points[pt3][0] - points[pt1][0], points[pt2][1] + points[pt3][1] - points[pt1][1]\\n                    \\n                    if(pt4 not in setPts):\\n                        continue\\n                        \\n                    areas.append(distIJMat[pt1][pt2] *  distIJMat[pt1][pt3])\\n\\n        if(areas == []):\\n            return 0\\n        else:\\n            return sqrt(min(areas))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2442480,
                "title": "c-using-dictionary-to-store-center-distance",
                "content": "In first loop calculate power 2 distance of each pair of points and middle point of them and insert in a dictionary.\\nThe second will happen only if there is two or more frequency of a key. it will choose a triangle in those four point to calculate the area of rectangle and update minimum value.\\n```\\npublic class Solution {\\n    public double MinAreaFreeRect(int[][] points) {\\n        var len=points.Length;\\n        if(len<4) return 0.0;\\n        var res=Double.MaxValue;\\n        Dictionary<string,List<int[]>> dict = new Dictionary<string,List<int[]>>();\\n        for(int i=0;i<len-1;i++){\\n            for(int j=i+1;j<len;j++){\\n                long dis = Distance2(points[i],points[j]);\\n                double[] mid = Middle(points[i],points[j]);\\n                String key = $\"{dis}-{mid[0]},{mid[1]}\";\\n                if(!dict.ContainsKey(key)) dict.Add(key, new List<int[]>());\\n                dict[key].Add(new int[] {i,j});\\n            }\\n        }\\n        foreach (var key in dict.Keys) {\\n            List<int[]> list = dict[key];\\n            for(int i=0;i<list.Count-1;i++){\\n                for(int j=i+1;j<list.Count;j++){\\n                    int p1=list[i][0];\\n                    int p2=list[j][0];\\n                    int p3=list[j][1];\\n                    double len1=Math.Sqrt(Distance2(points[p1],points[p2]));\\n                    double len2=Math.Sqrt(Distance2(points[p1],points[p3]));\\n                    double area = len1 * len2; \\n                    res = Math.Min(res, area);\\n                }\\n            }\\n        }\\n        return res == Double.MaxValue ?  0.0 : res;\\n    }\\n    private long Distance2(int[] point1,int[] point2){\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + \\n            (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n    private double[] Middle(int[] point1,int[] point2){\\n        return new double[] {(point1[0]+point2[0])/2.0,\\n                             (point1[1]+point2[1])/2.0};\\n    }\\n}\\n```\\nO(N^2)\\nconverted from java code",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double MinAreaFreeRect(int[][] points) {\\n        var len=points.Length;\\n        if(len<4) return 0.0;\\n        var res=Double.MaxValue;\\n        Dictionary<string,List<int[]>> dict = new Dictionary<string,List<int[]>>();\\n        for(int i=0;i<len-1;i++){\\n            for(int j=i+1;j<len;j++){\\n                long dis = Distance2(points[i],points[j]);\\n                double[] mid = Middle(points[i],points[j]);\\n                String key = $\"{dis}-{mid[0]},{mid[1]}\";\\n                if(!dict.ContainsKey(key)) dict.Add(key, new List<int[]>());\\n                dict[key].Add(new int[] {i,j});\\n            }\\n        }\\n        foreach (var key in dict.Keys) {\\n            List<int[]> list = dict[key];\\n            for(int i=0;i<list.Count-1;i++){\\n                for(int j=i+1;j<list.Count;j++){\\n                    int p1=list[i][0];\\n                    int p2=list[j][0];\\n                    int p3=list[j][1];\\n                    double len1=Math.Sqrt(Distance2(points[p1],points[p2]));\\n                    double len2=Math.Sqrt(Distance2(points[p1],points[p3]));\\n                    double area = len1 * len2; \\n                    res = Math.Min(res, area);\\n                }\\n            }\\n        }\\n        return res == Double.MaxValue ?  0.0 : res;\\n    }\\n    private long Distance2(int[] point1,int[] point2){\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + \\n            (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n    private double[] Middle(int[] point1,int[] point2){\\n        return new double[] {(point1[0]+point2[0])/2.0,\\n                             (point1[1]+point2[1])/2.0};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409203,
                "title": "check-mid-point-and-length-with-annotation",
                "content": "class Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        from collections import defaultdict\\n        import math\\n        dp = {}\\n        points=map(lambda n: (float(n[0]),float(n[1])),points)\\n        for i in range(len(points) - 1):\\n            for j in range(i + 1, len(points)):\\n                l = (points[j][1] - points[i][1]) ** 2 + (points[j][0] - points[i][0]) ** 2  # distance squared\\n                x = (points[i][0] + points[j][0]) / 2                                      # midpoint (x,y)\\n                y = (points[i][1] + points[j][1]) / 2\\n                dp[(i, j)] = (l, (x,y), points[i], points[j]) \\n        #print(dp)\\n        lines=dp.keys()\\n        minnum=float(\\'inf\\')\\n        flag=False\\n        for i in range(len(lines)-1):\\n            for j in range(i + 1, len(lines)):\\n                if dp[lines[i]][1]==dp[lines[j]][1] and dp[lines[i]][0]==dp[lines[j]][0]:\\n                    #midpoints align and length same\\n                    a=math.sqrt((dp[lines[i]][2][0]-dp[lines[j]][2][0])**2+(dp[lines[i]][2][1]-dp[lines[j]][2][1])**2)\\n                    b=math.sqrt((dp[lines[i]][2][0]-dp[lines[j]][3][0])**2+(dp[lines[i]][2][1]-dp[lines[j]][3][1])**2)\\n                    print(a,b,dp[lines[i]][1],dp[lines[i]][0],lines[i],lines[j])\\n                    minnum=min(minnum,float(a*b))\\n                    flag=True\\n        if flag:\\n            return minnum\\n        else:\\n            return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        from collections import defaultdict\\n        import math\\n        dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 2391880,
                "title": "python-solution-tedious-question-should-belong-to-hard",
                "content": "To solve this problem, you need to know some basic geometry of the rectangle:\\n1. A rectangle\\'s diagonals bisect each other (therefore same length)\\n2. The length of a diagonal do not correlate with the area of the rectangle, i.e. longer diagonal does not mean larger area (d^2 = a^2 + b^2, area = a * b)\\n\\nTherefore, even after using hash table to store the coordinates of mid points and diagonal length, we still have to loop through all pairs of pairs within the same diagonal length to arrive at the correct answer.\\n```\\nclass Solution:\\n    # 1 <= points.length <= 50 -> O(n^2) algorithm should be ok\\n    # For a rectangle, diagonal\\'s mid-point should coincide between the opposite corners\\n    # In addition their length should be the same\\n    # Therefore, we can first scan points and compute the centroid coordinates and diagonal length between all pairs\\n    # Format = hash_table[(2*xmid, 2*ymid, diag_length^2)] = [{(x0, y1), (x1, y1)}, {(x2, y2), (x3, y3)}, ....]\\n    # Then scan through the keys to find look for the smallest area\\n    # We should note that the area of rectangle is a*b, diagonal length is sqrt(a^2 + b^2), the shorter diagonal do not necessarily means smaller area\\n    \\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        hash_table = {}\\n        n = len(points)\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                x0, y0 = points[i]\\n                x1, y1 = points[j]\\n                key = (x0+x1, y0+y1, (x0-x1)*(x0-x1)+(y0-y1)*(y0-y1))\\n                if key not in hash_table:\\n                    hash_table[key] = []\\n                hash_table[key].append([tuple(points[i]), tuple(points[j])])\\n        \\n        curr_min = float(\\'Inf\\')\\n        for key in hash_table.keys():\\n            if len(hash_table[key]) > 1:\\n                lp = len(hash_table[key])\\n                for i in range(lp-1):\\n                    for j in range(i+1, lp):\\n                        x0, y0 = hash_table[key][i][0]\\n                        x2, y2 = hash_table[key][i][1]\\n                        x1, y1 = hash_table[key][j][0]\\n                        curr_min = min(curr_min, math.sqrt(((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1))*((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))))\\n        if curr_min == float(\\'Inf\\'):\\n            return 0\\n        else:\\n            return curr_min\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # 1 <= points.length <= 50 -> O(n^2) algorithm should be ok\\n    # For a rectangle, diagonal\\'s mid-point should coincide between the opposite corners\\n    # In addition their length should be the same\\n    # Therefore, we can first scan points and compute the centroid coordinates and diagonal length between all pairs\\n    # Format = hash_table[(2*xmid, 2*ymid, diag_length^2)] = [{(x0, y1), (x1, y1)}, {(x2, y2), (x3, y3)}, ....]\\n    # Then scan through the keys to find look for the smallest area\\n    # We should note that the area of rectangle is a*b, diagonal length is sqrt(a^2 + b^2), the shorter diagonal do not necessarily means smaller area\\n    \\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        hash_table = {}\\n        n = len(points)\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                x0, y0 = points[i]\\n                x1, y1 = points[j]\\n                key = (x0+x1, y0+y1, (x0-x1)*(x0-x1)+(y0-y1)*(y0-y1))\\n                if key not in hash_table:\\n                    hash_table[key] = []\\n                hash_table[key].append([tuple(points[i]), tuple(points[j])])\\n        \\n        curr_min = float(\\'Inf\\')\\n        for key in hash_table.keys():\\n            if len(hash_table[key]) > 1:\\n                lp = len(hash_table[key])\\n                for i in range(lp-1):\\n                    for j in range(i+1, lp):\\n                        x0, y0 = hash_table[key][i][0]\\n                        x2, y2 = hash_table[key][i][1]\\n                        x1, y1 = hash_table[key][j][0]\\n                        curr_min = min(curr_min, math.sqrt(((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1))*((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))))\\n        if curr_min == float(\\'Inf\\'):\\n            return 0\\n        else:\\n            return curr_min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209517,
                "title": "c-brute-force-and-hash-set-time-o-n-3",
                "content": "```\\n#if 0\\n \\n(x1, y1) x----------------x (x4, y4)\\n         |                |\\n         |                |\\n(x3, y3) x----------------x (x2, y2)\\n\\n#endif\\n\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        if (points.size() < 4) {\\n            return 0.0;\\n        }\\n\\n        unordered_set<unsigned long> pointSet;\\n        for (int i = 0; i < points.size(); ++i) {\\n            pointSet.insert(encode(points[i][0], points[i][1]));\\n        }\\n\\n        double answer = DBL_MAX;\\n        bool foundRec = false;\\n        for (vector<int>& p1 : points) {\\n            int x1 = p1[0], y1 = p1[1];\\n\\n            for (vector<int>& p2 : points) {\\n                int x2 = p2[0], y2 = p2[1];\\n                if (x1 == x2 && y1 == y2) {\\n                    // p1 and p2 are the same.\\n                    continue;\\n                }\\n\\n                for (vector<int>& p3 : points) {\\n                    int x3 = p3[0], y3 = p3[1];\\n                    unsigned long x4 = x1 + x2 - x3, y4 = y1 + y2 - y3;\\n                    if (pointSet.count(encode(x4, y4)) == 0) {\\n                        // The fourth point doesn\\u2019t exist.\\n                        continue;\\n                    }\\n\\n                    unsigned long side1 = distance(x1, y1, x3, y3);\\n                    unsigned long side2 = distance(x2, y2, x3, y3);\\n                    if (side1 == 0 || side2 == 0) {\\n                        continue;\\n                    }\\n                    unsigned long diagonal = distance(x1, y1, x2, y2);\\n                    if (side1 + side2 != diagonal) {\\n                        // side1 and side2 are not perpendicular.\\n                        continue;\\n                    }\\n                    foundRec = true;\\n                    answer = min(answer, sqrt(side1) * sqrt(side2));\\n                } // end of for-loop\\n            } // end of for-loop\\n        } // end of for-loop\\n\\n        if (!foundRec) {\\n            return 0.0;\\n        }\\n        return answer;\\n    }\\n\\nprivate:\\n    unsigned long encode(unsigned long x, unsigned long y) {\\n        return 50000 * x + y;\\n    }\\n\\n    unsigned long distance(unsigned long x1, unsigned long y1, unsigned long x2, unsigned long y2) {\\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#if 0\\n \\n(x1, y1) x----------------x (x4, y4)\\n         |                |\\n         |                |\\n(x3, y3) x----------------x (x2, y2)\\n\\n#endif\\n\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        if (points.size() < 4) {\\n            return 0.0;\\n        }\\n\\n        unordered_set<unsigned long> pointSet;\\n        for (int i = 0; i < points.size(); ++i) {\\n            pointSet.insert(encode(points[i][0], points[i][1]));\\n        }\\n\\n        double answer = DBL_MAX;\\n        bool foundRec = false;\\n        for (vector<int>& p1 : points) {\\n            int x1 = p1[0], y1 = p1[1];\\n\\n            for (vector<int>& p2 : points) {\\n                int x2 = p2[0], y2 = p2[1];\\n                if (x1 == x2 && y1 == y2) {\\n                    // p1 and p2 are the same.\\n                    continue;\\n                }\\n\\n                for (vector<int>& p3 : points) {\\n                    int x3 = p3[0], y3 = p3[1];\\n                    unsigned long x4 = x1 + x2 - x3, y4 = y1 + y2 - y3;\\n                    if (pointSet.count(encode(x4, y4)) == 0) {\\n                        // The fourth point doesn\\u2019t exist.\\n                        continue;\\n                    }\\n\\n                    unsigned long side1 = distance(x1, y1, x3, y3);\\n                    unsigned long side2 = distance(x2, y2, x3, y3);\\n                    if (side1 == 0 || side2 == 0) {\\n                        continue;\\n                    }\\n                    unsigned long diagonal = distance(x1, y1, x2, y2);\\n                    if (side1 + side2 != diagonal) {\\n                        // side1 and side2 are not perpendicular.\\n                        continue;\\n                    }\\n                    foundRec = true;\\n                    answer = min(answer, sqrt(side1) * sqrt(side2));\\n                } // end of for-loop\\n            } // end of for-loop\\n        } // end of for-loop\\n\\n        if (!foundRec) {\\n            return 0.0;\\n        }\\n        return answer;\\n    }\\n\\nprivate:\\n    unsigned long encode(unsigned long x, unsigned long y) {\\n        return 50000 * x + y;\\n    }\\n\\n    unsigned long distance(unsigned long x1, unsigned long y1, unsigned long x2, unsigned long y2) {\\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134680,
                "title": "c-slope-of-opposite-sides-are-equal",
                "content": "```\\nint sortcol(vector<int>& v1,vector<int>& v2){\\n    if(v1[0]==v2[0]) return v1[1]<v2[1];\\n    else return v1[0]<v2[0];\\n}\\nclass Solution {\\npublic:\\n    double dis(vector<vector<int>>& nums, int i,int j){\\n        return (nums[i][0]-nums[j][0])*(nums[i][0]-nums[j][0]) + (nums[i][1]-nums[j][1])*(nums[i][1]-nums[j][1]);\\n    }\\n    double find(vector<vector<int>>& nums){\\n        sort(nums.begin(),nums.end(),sortcol);\\n        if(dis(nums,0,1)==dis(nums,2,3) && dis(nums,0,2)==dis(nums,1,3) && dis(nums,2,1)==dis(nums,0,3)){\\n            return sqrt(dis(nums,0,1))*sqrt(dis(nums,0,2));\\n        }\\n        else return INT_MAX;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& nums) {\\n        map<string,vector<vector<int>>> mp; // {slope, vector of all points pair}\\n        for(int i = 0; i<nums.size()-1;++i){\\n            for(int j = i+1; j<nums.size();++j){  \\n                int x = nums[i][0]-nums[j][0], y = nums[i][1]-nums[j][1];\\n                int g = __gcd(y,x);\\n                string s = to_string(y/g)+\"*\"+to_string(x/g);  // slope\\n                mp[s].push_back({i,j});\\n            }\\n        }\\n        double re = INT_MAX;\\n        for(auto&[s,arr]:mp){\\n            for(int a = 0; a<arr.size()-1;++a){  \\n                for(int b = 0; b<arr.size();++b){\\n\\t\\t\\t\\t// for a given slope, try all possible combinations of points\\n                    int i = arr[a][0], j=arr[a][1], k = arr[b][0], l = arr[b][1];\\n                    if(i==k||i==l||j==k||j==l) continue;\\n                    vector<vector<int>> temp = {nums[i],nums[j],nums[k],nums[l]};\\n                    re = min(re,find(temp));\\n                }\\n            }\\n        }\\n        if(re==INT_MAX) re = 0;\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint sortcol(vector<int>& v1,vector<int>& v2){\\n    if(v1[0]==v2[0]) return v1[1]<v2[1];\\n    else return v1[0]<v2[0];\\n}\\nclass Solution {\\npublic:\\n    double dis(vector<vector<int>>& nums, int i,int j){\\n        return (nums[i][0]-nums[j][0])*(nums[i][0]-nums[j][0]) + (nums[i][1]-nums[j][1])*(nums[i][1]-nums[j][1]);\\n    }\\n    double find(vector<vector<int>>& nums){\\n        sort(nums.begin(),nums.end(),sortcol);\\n        if(dis(nums,0,1)==dis(nums,2,3) && dis(nums,0,2)==dis(nums,1,3) && dis(nums,2,1)==dis(nums,0,3)){\\n            return sqrt(dis(nums,0,1))*sqrt(dis(nums,0,2));\\n        }\\n        else return INT_MAX;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& nums) {\\n        map<string,vector<vector<int>>> mp; // {slope, vector of all points pair}\\n        for(int i = 0; i<nums.size()-1;++i){\\n            for(int j = i+1; j<nums.size();++j){  \\n                int x = nums[i][0]-nums[j][0], y = nums[i][1]-nums[j][1];\\n                int g = __gcd(y,x);\\n                string s = to_string(y/g)+\"*\"+to_string(x/g);  // slope\\n                mp[s].push_back({i,j});\\n            }\\n        }\\n        double re = INT_MAX;\\n        for(auto&[s,arr]:mp){\\n            for(int a = 0; a<arr.size()-1;++a){  \\n                for(int b = 0; b<arr.size();++b){\\n\\t\\t\\t\\t// for a given slope, try all possible combinations of points\\n                    int i = arr[a][0], j=arr[a][1], k = arr[b][0], l = arr[b][1];\\n                    if(i==k||i==l||j==k||j==l) continue;\\n                    vector<vector<int>> temp = {nums[i],nums[j],nums[k],nums[l]};\\n                    re = min(re,find(temp));\\n                }\\n            }\\n        }\\n        if(re==INT_MAX) re = 0;\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108231,
                "title": "bruteforce-three-point-program-has-bug-that-test-case-cannot-detected",
                "content": "The following bruteForce three point shouldn\\'t test on all three point combination on right angle\\nwhen looping check i j k is right angle is not passed\\nbut j i k can pass submition\\nactually both of them cannot test all case\\n\\nexample code pass\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length < 4)\\n        {\\n            return 0;\\n        }\\n        HashSet<Pair<Integer,Integer>> exiPoint = new HashSet<>();\\n        \\n        for(int[] point : points)\\n        {\\n            exiPoint.add(new Pair(point[0],point[1]));\\n        }\\n        Double minArea = Double.MAX_VALUE;\\n        for(int i = 0 ; i < points.length - 2 ; i++)\\n        {\\n            for(int j = i+1 ; j < points.length - 1 ; j++)\\n            {\\n                for(int k =j+1; k < points.length; k++)\\n                {\\n                    if(distance(points[i],points[j]) + distance(points[i], points[k]) == distance(points[j], points[k]))\\n                    {\\n                        //angle j i k is right-angle\\n                        int p4x = points[j][0] + points[k][0] - points[i][0];\\n                        int p4y = points[j][1] + points[k][1] - points[i][1];\\n                        if(exiPoint.contains(new Pair(p4x,p4y)))\\n                        {\\n                            Double area = Math.sqrt(distance(points[i],points[j])) * Math.sqrt(distance(points[i], points[k]));\\n                            \\n                            System.out.println(\"area : \" + area + \" i j k\" + i + \" \" + j + \" \" + k);\\n                            minArea = Math.min(area, minArea);  \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    public double distance(int[] p1, int[] p2)\\n    {\\n        return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1]);\\n    }\\n}\\n\\nexample code not pass\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length < 4)\\n        {\\n            return 0;\\n        }\\n        HashSet<Pair<Integer,Integer>> exiPoint = new HashSet<>();\\n        \\n        for(int[] point : points)\\n        {\\n            exiPoint.add(new Pair(point[0],point[1]));\\n        }\\n        Double minArea = Double.MAX_VALUE;\\n        for(int i = 0 ; i < points.length - 2 ; i++)\\n        {\\n            for(int j = i+1 ; j < points.length - 1 ; j++)\\n            {\\n                for(int k =j+1; k < points.length; k++)\\n                {\\n                    if(distance(points[i],points[j]) + distance(points[j], points[k]) == distance(points[i], points[k]))\\n                    {\\n                        //angle i j k is right-angle\\n                        int p4x = points[i][0] + points[k][0] - points[j][0];\\n                        int p4y = points[i][1] + points[k][1] - points[j][1];\\n                        if(exiPoint.contains(new Pair(p4x,p4y)))\\n                        {\\n                            Double area = Math.sqrt(distance(points[i],points[j])) * Math.sqrt(distance(points[i], points[k]));\\n                            \\n                            System.out.println(\"area : \" + area + \" i j k\" + i + \" \" + j + \" \" + k);\\n                            minArea = Math.min(area, minArea);  \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    public double distance(int[] p1, int[] p2)\\n    {\\n        return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1]);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if(points.length < 4)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2083507,
                "title": "c-solution-based-on-geometry-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<int, unordered_set<int>> x_to_ys;\\n        for (int i = 0; i < points.size(); i++){\\n            int x = points[i][0], y = points[i][1];\\n            if (x_to_ys.count(x) == 0){x_to_ys.insert({x, {y}});}\\n            else{x_to_ys[x].insert(y);}\\n        }\\n        long min_area = INT_MAX;\\n        bool at_least_one = false;\\n        int n = points.size();\\n        for (int i = 0; i < n; i++){\\n            for (int j = i + 1; j < n; j++){\\n                long dx_ij = (points[i][0] - points[j][0]), dy_ij = (points[i][1] - points[j][1]);\\n                long sq_ij = dx_ij * dx_ij + dy_ij * dy_ij;\\n                for (int k = 0; k < n; k++){\\n                    if (k != i && k != j){\\n                        // whether i, j, k can form a RT?\\n                        long dx_ik = (points[i][0] - points[k][0]), dy_ik = (points[i][1] - points[k][1]);\\n                        long sq_ik = dx_ik * dx_ik + dy_ik * dy_ik;\\n                        long dx_jk = (points[j][0] - points[k][0]), dy_jk = (points[j][1] - points[k][1]);\\n                        long sq_jk = dx_jk * dx_jk + dy_jk * dy_jk;\\n                        if (sq_ik + sq_jk == sq_ij){\\n                            // if the sym point of k for {i, j} is exist?\\n                            int kx = points[k][0], ky = points[k][1];\\n                            int cx_ij = (points[i][0] + points[j][0]);\\n                            int cy_ij = (points[i][1] + points[j][1]);\\n                            int ax = cx_ij - kx, ay = cy_ij - ky;\\n                            if (x_to_ys.count(ax) == 1 && x_to_ys[ax].count(ay) == 1){\\n                                at_least_one = true;\\n                                min_area = min(min_area, (long)sqrt(sq_ik * sq_jk));\\n                            }\\n                        }   \\n                    }                    \\n                }\\n            }\\n        }\\n        if (!at_least_one){return 0;}\\n        return (double)min_area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<int, unordered_set<int>> x_to_ys;\\n        for (int i = 0; i < points.size(); i++){\\n            int x = points[i][0], y = points[i][1];\\n            if (x_to_ys.count(x) == 0){x_to_ys.insert({x, {y}});}\\n            else{x_to_ys[x].insert(y);}\\n        }\\n        long min_area = INT_MAX;\\n        bool at_least_one = false;\\n        int n = points.size();\\n        for (int i = 0; i < n; i++){\\n            for (int j = i + 1; j < n; j++){\\n                long dx_ij = (points[i][0] - points[j][0]), dy_ij = (points[i][1] - points[j][1]);\\n                long sq_ij = dx_ij * dx_ij + dy_ij * dy_ij;\\n                for (int k = 0; k < n; k++){\\n                    if (k != i && k != j){\\n                        // whether i, j, k can form a RT?\\n                        long dx_ik = (points[i][0] - points[k][0]), dy_ik = (points[i][1] - points[k][1]);\\n                        long sq_ik = dx_ik * dx_ik + dy_ik * dy_ik;\\n                        long dx_jk = (points[j][0] - points[k][0]), dy_jk = (points[j][1] - points[k][1]);\\n                        long sq_jk = dx_jk * dx_jk + dy_jk * dy_jk;\\n                        if (sq_ik + sq_jk == sq_ij){\\n                            // if the sym point of k for {i, j} is exist?\\n                            int kx = points[k][0], ky = points[k][1];\\n                            int cx_ij = (points[i][0] + points[j][0]);\\n                            int cy_ij = (points[i][1] + points[j][1]);\\n                            int ax = cx_ij - kx, ay = cy_ij - ky;\\n                            if (x_to_ys.count(ax) == 1 && x_to_ys[ax].count(ay) == 1){\\n                                at_least_one = true;\\n                                min_area = min(min_area, (long)sqrt(sq_ik * sq_jk));\\n                            }\\n                        }   \\n                    }                    \\n                }\\n            }\\n        }\\n        if (!at_least_one){return 0;}\\n        return (double)min_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861290,
                "title": "java-hashset-and-pythagoras-theorem-based-solution",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        \\n        int numPoints = points.length;\\n        \\n        if (numPoints < 4)\\n            return 0;\\n        \\n        Set<Pair<Double, Double>> uniquePoints = new HashSet<Pair<Double, Double>>();\\n        \\n        for (int i = 0; i < numPoints; i++)\\n            uniquePoints.add(new Pair((double)points[i][0], (double)points[i][1]));\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        for (int i = 0; i < numPoints-2; i++) {\\n            \\n            int[] vertex1 = points[i];\\n            \\n            for (int j = i+1; j < numPoints-1; j++) {\\n                \\n                int[] vertex2 = points[j];\\n                \\n                for (int k = j+1; k < numPoints; k++) {\\n                    \\n                    int[] vertex3 = points[k];\\n                    \\n                    double dx12 = vertex1[0] - vertex2[0];\\n                    double dy12 = vertex1[1] - vertex2[1];\\n                    \\n                    double dx13 = vertex1[0] - vertex3[0];\\n                    double dy13 = vertex1[1] - vertex3[1];\\n                    \\n                    double dx23 = vertex2[0] - vertex3[0];\\n                    double dy23 = vertex2[1] - vertex3[1];\\n                    \\n                    if ((dx12 * dx12 + dy12 * dy12) + (dx13 * dx13 + dy13 * dy13) == (dx23 * dx23 + dy23 * dy23)) {\\n                        \\n                        double corX = (vertex2[0] + vertex3[0]) - vertex1[0];\\n                        double corY = (vertex2[1] + vertex3[1]) - vertex1[1];\\n                        \\n                        double[] pointToCheck = new double[2];\\n                        pointToCheck[0] = corX;\\n                        pointToCheck[1] = corY;\\n                        if (uniquePoints.contains(new Pair(corX, corY)))\\n                            minArea = Math.min(minArea, Math.sqrt(dx12 * dx12 + dy12 * dy12) * Math.sqrt(dx13 * dx13 + dy13 * dy13));\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE? 0 : minArea;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        \\n        int numPoints = points.length;\\n        \\n        if (numPoints < 4)\\n            return 0;\\n        \\n        Set<Pair<Double, Double>> uniquePoints = new HashSet<Pair<Double, Double>>();\\n        \\n        for (int i = 0; i < numPoints; i++)\\n            uniquePoints.add(new Pair((double)points[i][0], (double)points[i][1]));\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        for (int i = 0; i < numPoints-2; i++) {\\n            \\n            int[] vertex1 = points[i];\\n            \\n            for (int j = i+1; j < numPoints-1; j++) {\\n                \\n                int[] vertex2 = points[j];\\n                \\n                for (int k = j+1; k < numPoints; k++) {\\n                    \\n                    int[] vertex3 = points[k];\\n                    \\n                    double dx12 = vertex1[0] - vertex2[0];\\n                    double dy12 = vertex1[1] - vertex2[1];\\n                    \\n                    double dx13 = vertex1[0] - vertex3[0];\\n                    double dy13 = vertex1[1] - vertex3[1];\\n                    \\n                    double dx23 = vertex2[0] - vertex3[0];\\n                    double dy23 = vertex2[1] - vertex3[1];\\n                    \\n                    if ((dx12 * dx12 + dy12 * dy12) + (dx13 * dx13 + dy13 * dy13) == (dx23 * dx23 + dy23 * dy23)) {\\n                        \\n                        double corX = (vertex2[0] + vertex3[0]) - vertex1[0];\\n                        double corY = (vertex2[1] + vertex3[1]) - vertex1[1];\\n                        \\n                        double[] pointToCheck = new double[2];\\n                        pointToCheck[0] = corX;\\n                        pointToCheck[1] = corY;\\n                        if (uniquePoints.contains(new Pair(corX, corY)))\\n                            minArea = Math.min(minArea, Math.sqrt(dx12 * dx12 + dy12 * dy12) * Math.sqrt(dx13 * dx13 + dy13 * dy13));\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE? 0 : minArea;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744455,
                "title": "c-32ms-88-sorting-hash",
                "content": "Runtime: 32 ms, faster than 88.30% of C++ online submissions for Minimum Area Rectangle II.\\nMemory Usage: 9.2 MB, less than 89.89% of C++ online submissions for Minimum Area Rectangle II.\\n```\\n#define x1 points[i][0]\\n#define y1 points[i][1]\\n#define x2 points[j][0]\\n#define y2 points[j][1]\\n#define x3 points[k][0]\\n#define y3 points[k][1]\\n\\nclass Solution {\\npublic:\\n  double minAreaFreeRect(vector<vector<int>>& points) {\\n    int ans = INT_MAX;\\n    sort(points.begin(),points.end());\\n    set<pair<int,int>>st;\\n    for(auto &p: points) st.insert({p[0], p[1]});\\n    \\n    for(int i = 0; i != points.size() && ans != 1; i++)\\n      for(int j = i+1; j != points.size() && ans != 1; j++)\\n        for(int k = j+1; k != points.size() && ans != 1; k++)\\n          if( (x1-x2)*(x2-x3)+(y1-y2)*(y2-y3) == 0 && st.count({x1+x3-x2, y1+y3-y2}))\\n          ans = min(ans, abs( (y1-y2)*(x3-x2) - (x1-x2)*(y3-y2)));\\n         \\n    return ans == INT_MAX ? 0.0 : double(ans);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define x1 points[i][0]\\n#define y1 points[i][1]\\n#define x2 points[j][0]\\n#define y2 points[j][1]\\n#define x3 points[k][0]\\n#define y3 points[k][1]\\n\\nclass Solution {\\npublic:\\n  double minAreaFreeRect(vector<vector<int>>& points) {\\n    int ans = INT_MAX;\\n    sort(points.begin(),points.end());\\n    set<pair<int,int>>st;\\n    for(auto &p: points) st.insert({p[0], p[1]});\\n    \\n    for(int i = 0; i != points.size() && ans != 1; i++)\\n      for(int j = i+1; j != points.size() && ans != 1; j++)\\n        for(int k = j+1; k != points.size() && ans != 1; k++)\\n          if( (x1-x2)*(x2-x3)+(y1-y2)*(y2-y3) == 0 && st.count({x1+x3-x2, y1+y3-y2}))\\n          ans = min(ans, abs( (y1-y2)*(x3-x2) - (x1-x2)*(y3-y2)));\\n         \\n    return ans == INT_MAX ? 0.0 : double(ans);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717703,
                "title": "c-solution",
                "content": "The solution was inspired by discussions in https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/210786/C%2B%2B-with-picture-find-diagonals-O(n-*-n)\\n```\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        // the basic idea is to find all middle point of any pair of points\\n        // and we will also need to get the distance of every pair of points\\n        // for any pair of line segments, if they can intersect and the intersect point is the middle point for both line segments, and the length of these two line segments are the same, then this pair of line segments are the diagonals of a rectangle\\n        // if two points are (x1, y1) and (x2, y2), for storing the accurate middle point position\\n        // we just do (x1 + x2, y1 + y2) without dividing them by two\\n        // similarly, for computing distance, we won\\'t do sqrt operation\\n        // since we want to use middle point as the key for a map, if we store the middle point as pair, we can\\'t use unordered_map, so we can convert the middle point pair as a unsigned long value.\\n        int size = points.size();\\n        // middlePoints\\'s key is an encoded middle point pair value, value is an unordered_map, with the square of distance as the key and a vector of two end points as value.\\n        unordered_map<unsigned long, unordered_map<int, vector<vector<int>>>> middlePoints;\\n        for (int i = 0; i < size; i++) {\\n            for (int j = i + 1; j < size; j++) {\\n                int middleX_2 = points[i][0] + points[j][0];\\n                int middleY_2 = points[i][1] + points[j][1];\\n                unsigned long encodedKey = (unsigned long)middleX_2 << 32;\\n                encodedKey += middleY_2;\\n                int dSquare = distanceSquare(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                middlePoints[encodedKey][dSquare].push_back({points[i][0], points[i][1], points[j][0], points[j][1]});\\n            }\\n        }\\n        double result = DBL_MAX;\\n        for (auto& middleData : middlePoints) {\\n            for (auto& disData : middleData.second) {\\n                // compute the area of every square, but we can compute the square feet in the end\\n                // so we store the square of the area in the result first\\n                for (int i = 0; i < disData.second.size(); i++) {\\n                    for (int j = i + 1; j < disData.second.size(); j++) {\\n                        double w = distanceSquare(disData.second[i][0], disData.second[i][1], disData.second[j][0], disData.second[j][1]);\\n                        double h = distanceSquare(disData.second[i][0], disData.second[i][1], disData.second[j][2], disData.second[j][3]);\\n                        double area = w * h;\\n                        result = min(result, area);\\n                    }\\n                }\\n            }\\n        }\\n        return result == DBL_MAX ? 0 : sqrt(result);\\n    }\\n    \\n    int distanceSquare(int& x0, int& y0, int& x1, int& y1) {\\n        int dx = x1 - x0;\\n        int dy = y1 - y0;\\n        return dx * dx + dy * dy;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        // the basic idea is to find all middle point of any pair of points\\n        // and we will also need to get the distance of every pair of points\\n        // for any pair of line segments, if they can intersect and the intersect point is the middle point for both line segments, and the length of these two line segments are the same, then this pair of line segments are the diagonals of a rectangle\\n        // if two points are (x1, y1) and (x2, y2), for storing the accurate middle point position\\n        // we just do (x1 + x2, y1 + y2) without dividing them by two\\n        // similarly, for computing distance, we won\\'t do sqrt operation\\n        // since we want to use middle point as the key for a map, if we store the middle point as pair, we can\\'t use unordered_map, so we can convert the middle point pair as a unsigned long value.\\n        int size = points.size();\\n        // middlePoints\\'s key is an encoded middle point pair value, value is an unordered_map, with the square of distance as the key and a vector of two end points as value.\\n        unordered_map<unsigned long, unordered_map<int, vector<vector<int>>>> middlePoints;\\n        for (int i = 0; i < size; i++) {\\n            for (int j = i + 1; j < size; j++) {\\n                int middleX_2 = points[i][0] + points[j][0];\\n                int middleY_2 = points[i][1] + points[j][1];\\n                unsigned long encodedKey = (unsigned long)middleX_2 << 32;\\n                encodedKey += middleY_2;\\n                int dSquare = distanceSquare(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                middlePoints[encodedKey][dSquare].push_back({points[i][0], points[i][1], points[j][0], points[j][1]});\\n            }\\n        }\\n        double result = DBL_MAX;\\n        for (auto& middleData : middlePoints) {\\n            for (auto& disData : middleData.second) {\\n                // compute the area of every square, but we can compute the square feet in the end\\n                // so we store the square of the area in the result first\\n                for (int i = 0; i < disData.second.size(); i++) {\\n                    for (int j = i + 1; j < disData.second.size(); j++) {\\n                        double w = distanceSquare(disData.second[i][0], disData.second[i][1], disData.second[j][0], disData.second[j][1]);\\n                        double h = distanceSquare(disData.second[i][0], disData.second[i][1], disData.second[j][2], disData.second[j][3]);\\n                        double area = w * h;\\n                        result = min(result, area);\\n                    }\\n                }\\n            }\\n        }\\n        return result == DBL_MAX ? 0 : sqrt(result);\\n    }\\n    \\n    int distanceSquare(int& x0, int& y0, int& x1, int& y1) {\\n        int dx = x1 - x0;\\n        int dy = y1 - y0;\\n        return dx * dx + dy * dy;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668962,
                "title": "java-n-2-40ms",
                "content": "```\\n    public double minAreaFreeRect(int[][] points) {\\n        \\n        Map<Double, List<Line>> distanceToLines = new HashMap<>();\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i + 1; j < points.length; j++) {\\n                Line line = new Line(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                \\n                List<Line> lines = distanceToLines.getOrDefault(line.distance, new ArrayList<Line>());\\n                lines.add(line);\\n                distanceToLines.put(line.distance, lines);\\n            }\\n        }\\n        \\n        double result = -1.0;\\n        for(Double distance : distanceToLines.keySet()){\\n            List<Line> lines = distanceToLines.get(distance);\\n            if(lines.size() < 2) {\\n                continue;\\n            }\\n            \\n            for(int i = 0; i < lines.size(); i++) {\\n                for(int j = i + 1; j < lines.size(); j++) {\\n                    double area = getArea(lines.get(i), lines.get(j));\\n                    if(area > 0) {\\n                        result = result < 0.0 ? area : Math.min(result, area);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        result = result < 0.0 ? 0.0 : result;\\n        DecimalFormat format = new DecimalFormat(\"#.#####\");\\n        return Double.valueOf(format.format(result));\\n    }\\n    \\n    private double getArea(Line line1, Line line2){\\n        if(line1.hasSamePoint(line2)) {\\n            return -1.0;\\n        }\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(line1);\\n        lines.add(line2);\\n        lines.add(new Line(line1.x1, line1.y1, line2.x1, line2.y1));\\n        lines.add(new Line(line1.x2, line1.y2, line2.x2, line2.y2));\\n        lines.add(new Line(line1.x1, line1.y1, line2.x2, line2.y2));\\n        lines.add(new Line(line1.x2, line1.y2, line2.x1, line2.y1));\\n        Collections.sort(lines, (l1, l2) -> l1.distance.compareTo(l2.distance));\\n        \\n        if(!lines.get(0).distance.equals(lines.get(1).distance) \\n           || !lines.get(2).distance.equals(lines.get(3).distance) \\n           || !lines.get(4).distance.equals(lines.get(5).distance)) {\\n            return -1.0;\\n        }\\n        \\n        if(!lines.get(4).sameMidPoint(lines.get(5))) {\\n            return -1.0;\\n        }\\n        \\n        return lines.get(0).distance * lines.get(2).distance;\\n    }\\n    \\n    private static class Line {\\n        int x1;\\n        int y1;\\n        int x2;\\n        int y2;\\n        Double distance;\\n        \\n        public Line(int x1, int y1, int x2, int y2){\\n            this.x1 = x1;\\n            this.y1 = y1;\\n            this.x2 = x2;\\n            this.y2 = y2;\\n            this.distance = Math.pow((Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2)), 0.5);\\n        }\\n        \\n        public boolean hasSamePoint(Line line){\\n            return (x1 == line.x1 && y1 == line.y1)\\n                || (x1 == line.x2 && y1 == line.y2)\\n                || (x2 == line.x1 && y2 == line.y1)\\n                || (x2 == line.x2 && y2 == line.y2);\\n        }\\n        \\n        public boolean sameMidPoint(Line line) {\\n            double[] midPoint1 = getMidPoint();\\n            double[] midPoint2 = line.getMidPoint();\\n            return midPoint1[0] == midPoint2[0] && midPoint1[1] == midPoint2[1];\\n        }\\n        \\n        private double[] getMidPoint() {\\n            return new double[] {(x1 + x2) / 2.0, (y1 + y2) / 2.0};\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public double minAreaFreeRect(int[][] points) {\\n        \\n        Map<Double, List<Line>> distanceToLines = new HashMap<>();\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i + 1; j < points.length; j++) {\\n                Line line = new Line(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                \\n                List<Line> lines = distanceToLines.getOrDefault(line.distance, new ArrayList<Line>());\\n                lines.add(line);\\n                distanceToLines.put(line.distance, lines);\\n            }\\n        }\\n        \\n        double result = -1.0;\\n        for(Double distance : distanceToLines.keySet()){\\n            List<Line> lines = distanceToLines.get(distance);\\n            if(lines.size() < 2) {\\n                continue;\\n            }\\n            \\n            for(int i = 0; i < lines.size(); i++) {\\n                for(int j = i + 1; j < lines.size(); j++) {\\n                    double area = getArea(lines.get(i), lines.get(j));\\n                    if(area > 0) {\\n                        result = result < 0.0 ? area : Math.min(result, area);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        result = result < 0.0 ? 0.0 : result;\\n        DecimalFormat format = new DecimalFormat(\"#.#####\");\\n        return Double.valueOf(format.format(result));\\n    }\\n    \\n    private double getArea(Line line1, Line line2){\\n        if(line1.hasSamePoint(line2)) {\\n            return -1.0;\\n        }\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(line1);\\n        lines.add(line2);\\n        lines.add(new Line(line1.x1, line1.y1, line2.x1, line2.y1));\\n        lines.add(new Line(line1.x2, line1.y2, line2.x2, line2.y2));\\n        lines.add(new Line(line1.x1, line1.y1, line2.x2, line2.y2));\\n        lines.add(new Line(line1.x2, line1.y2, line2.x1, line2.y1));\\n        Collections.sort(lines, (l1, l2) -> l1.distance.compareTo(l2.distance));\\n        \\n        if(!lines.get(0).distance.equals(lines.get(1).distance) \\n           || !lines.get(2).distance.equals(lines.get(3).distance) \\n           || !lines.get(4).distance.equals(lines.get(5).distance)) {\\n            return -1.0;\\n        }\\n        \\n        if(!lines.get(4).sameMidPoint(lines.get(5))) {\\n            return -1.0;\\n        }\\n        \\n        return lines.get(0).distance * lines.get(2).distance;\\n    }\\n    \\n    private static class Line {\\n        int x1;\\n        int y1;\\n        int x2;\\n        int y2;\\n        Double distance;\\n        \\n        public Line(int x1, int y1, int x2, int y2){\\n            this.x1 = x1;\\n            this.y1 = y1;\\n            this.x2 = x2;\\n            this.y2 = y2;\\n            this.distance = Math.pow((Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2)), 0.5);\\n        }\\n        \\n        public boolean hasSamePoint(Line line){\\n            return (x1 == line.x1 && y1 == line.y1)\\n                || (x1 == line.x2 && y1 == line.y2)\\n                || (x2 == line.x1 && y2 == line.y1)\\n                || (x2 == line.x2 && y2 == line.y2);\\n        }\\n        \\n        public boolean sameMidPoint(Line line) {\\n            double[] midPoint1 = getMidPoint();\\n            double[] midPoint2 = line.getMidPoint();\\n            return midPoint1[0] == midPoint2[0] && midPoint1[1] == midPoint2[1];\\n        }\\n        \\n        private double[] getMidPoint() {\\n            return new double[] {(x1 + x2) / 2.0, (y1 + y2) / 2.0};\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635583,
                "title": "o-n-3-hashmap-ac",
                "content": "```\\nclass Solution {\\npublic:\\n    int distance(long long int x1,long long int y1,long long int x2,long long int y2)\\n    {\\n        return ((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) \\n    {\\n        map<pair<long long int,long long int>,bool>mp;\\n        double mini =0.0;\\n        \\n        // taking all points into map \\n        for(long long int i=0;i<points.size();i++)\\n        {\\n            long long int x = points[i][0];\\n            long long int y = points[i][1];\\n            mp[make_pair(x,y)]=true;\\n        }\\n        \\n        // now i will fix 3 points p1,p2,p3 and try to find the p4\\n\\n        int v = points.size();\\n        // int e = points[0].size();\\n        for(int i=0;i<v;i++)\\n        {\\n            for(int j=0;j<v;j++)\\n            {\\n                for(int k=0;k<v;k++)\\n                {\\n                    long long int x1 = points[i][0];\\n                    long long int y1 = points[i][1];\\n                    \\n                    long long int x2 = points[j][0];\\n                    long long int y2 = points[j][1];\\n                    \\n                    long long int x3 = points[k][0];\\n                    long long int y3 = points[k][1];\\n                    \\n                    pair<long long int,long long int>p1=make_pair(x1,y1); // p1\\n                    pair<long long int,long long int>p2=make_pair(x2,y2); // p2\\n                    pair<long long int,long long int>p3=make_pair(x3,y3); // p3\\n                    \\n                    // slope of p1&p2 p2&p3\\n                    \\n                    // if product is -1 then p2 perpendicular to p1 and p2\\n                    if((y3-y2)*(y2-y1)+(x3-x2)*(x2-x1) == 0)\\n                    {\\n                        // mid point of p1 and p3   \\n                        // long long int mx1 = (x1+x3)/2;\\n                        // long long int my1 = (y1+y3)/2;\\n                        // using mid point of p2 and p4 we know \\n                        // both midpoints lie at same point so we equated them to get point 4\\n                        // we found p4 \\n                        // now we check whether p1 and p2 and p3 form a rectangle part\\n                        // using slope of (p1 , p2 ) & (p2,p3) and product is -1\\n                        long long int x4,y4;\\n                        x4 = x1+x3-x2;\\n                        y4 = y1+y3-y2;\\n                        pair<int,int>p4=make_pair(x4,y4);\\n                        if(mp.find(p4)!=mp.end())\\n                        {\\n                            double d1 = sqrtl(distance(x1,y1,x2,y2));\\n                            double d2 = sqrtl(distance(x2,y2,x3,y3));\\n                            \\n                            double area = (d1*d2);\\n                            \\n                            if(mini == 0 || area<mini)\\n                            {\\n                                if(area!=0)\\n                                {\\n                                    mini = area;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n       \\n        return (mini);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distance(long long int x1,long long int y1,long long int x2,long long int y2)\\n    {\\n        return ((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) \\n    {\\n        map<pair<long long int,long long int>,bool>mp;\\n        double mini =0.0;\\n        \\n        // taking all points into map \\n        for(long long int i=0;i<points.size();i++)\\n        {\\n            long long int x = points[i][0];\\n            long long int y = points[i][1];\\n            mp[make_pair(x,y)]=true;\\n        }\\n        \\n        // now i will fix 3 points p1,p2,p3 and try to find the p4\\n\\n        int v = points.size();\\n        // int e = points[0].size();\\n        for(int i=0;i<v;i++)\\n        {\\n            for(int j=0;j<v;j++)\\n            {\\n                for(int k=0;k<v;k++)\\n                {\\n                    long long int x1 = points[i][0];\\n                    long long int y1 = points[i][1];\\n                    \\n                    long long int x2 = points[j][0];\\n                    long long int y2 = points[j][1];\\n                    \\n                    long long int x3 = points[k][0];\\n                    long long int y3 = points[k][1];\\n                    \\n                    pair<long long int,long long int>p1=make_pair(x1,y1); // p1\\n                    pair<long long int,long long int>p2=make_pair(x2,y2); // p2\\n                    pair<long long int,long long int>p3=make_pair(x3,y3); // p3\\n                    \\n                    // slope of p1&p2 p2&p3\\n                    \\n                    // if product is -1 then p2 perpendicular to p1 and p2\\n                    if((y3-y2)*(y2-y1)+(x3-x2)*(x2-x1) == 0)\\n                    {\\n                        // mid point of p1 and p3   \\n                        // long long int mx1 = (x1+x3)/2;\\n                        // long long int my1 = (y1+y3)/2;\\n                        // using mid point of p2 and p4 we know \\n                        // both midpoints lie at same point so we equated them to get point 4\\n                        // we found p4 \\n                        // now we check whether p1 and p2 and p3 form a rectangle part\\n                        // using slope of (p1 , p2 ) & (p2,p3) and product is -1\\n                        long long int x4,y4;\\n                        x4 = x1+x3-x2;\\n                        y4 = y1+y3-y2;\\n                        pair<int,int>p4=make_pair(x4,y4);\\n                        if(mp.find(p4)!=mp.end())\\n                        {\\n                            double d1 = sqrtl(distance(x1,y1,x2,y2));\\n                            double d2 = sqrtl(distance(x2,y2,x3,y3));\\n                            \\n                            double area = (d1*d2);\\n                            \\n                            if(mini == 0 || area<mini)\\n                            {\\n                                if(area!=0)\\n                                {\\n                                    mini = area;\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n       \\n        return (mini);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570836,
                "title": "java-get-rectangles-based-on-center-point-diagonal-length-75-faster-22ms",
                "content": "```\\n\\nclass Solution {\\n    private int[][] points;\\n    \\n    public double minAreaFreeRect(int[][] points) {\\n        this.points = points;\\n        \\n        Map<Pair<Double, Double>, Map<Long, List<Pair<Integer, Integer>>>> centerDiagLenLines = new HashMap();\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i + 1; j < points.length; j++) {\\n                int[] point1 = points[i];\\n                int[] point2 = points[j];\\n                \\n                Pair<Double, Double> center = getCenter(point1, point2);\\n                long len = getLen(point1, point2);\\n                \\n                centerDiagLenLines.computeIfAbsent(center, k -> new HashMap<Long, List<Pair<Integer, Integer>>>()).computeIfAbsent(len, k -> new ArrayList<Pair<Integer, Integer>>()).add(new Pair(i,j));\\n            }\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        for(Pair<Double, Double> c: centerDiagLenLines.keySet()) {\\n             Map<Long, List<Pair<Integer, Integer>>> mp = centerDiagLenLines.get(c);\\n            Set<Long> keySet = mp.keySet();\\n            for(Long l: keySet) {\\n                List<Pair<Integer, Integer>> lines = mp.get(l);\\n                if(lines.size() < 2) continue;\\n                \\n                for(int i = 0; i < lines.size(); i++) {\\n                    for(int j = i + 1; j < lines.size(); j++) {\\n                        minArea = Math.min(minArea, getArea(lines.get(i), lines.get(j)));\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE? 0: minArea;\\n    }\\n    \\n    private Pair<Double, Double> getCenter(int[] point1, int[] point2) {\\n        return new Pair((point1[0] + point2[0])/2.0, (point1[1] + point2[1])/2.0);\\n    }\\n    \\n    private long getLen(int[] point1, int[] point2) {\\n        int xDiff = point1[0] - point2[0];\\n        int yDiff = point1[1] - point2[1];\\n        return xDiff*xDiff + yDiff*yDiff;\\n    }\\n    \\n    private double getArea(Pair<Integer, Integer> line1, Pair<Integer, Integer> line2) {\\n        int[] line1Pt1 = points[line1.getKey()];\\n        int[] line1Pt2 = points[line1.getValue()];\\n\\n        int[] line2Pt1 = points[line2.getKey()];\\n        int[] line2Pt2 = points[line2.getValue()];\\n        \\n        double widthPow = Math.pow(line2Pt1[0] - line1Pt1[0], 2) + Math.pow(line2Pt1[1] - line1Pt1[1], 2);\\n        double lenPow = Math.pow(line2Pt1[0] - line1Pt2[0], 2) + Math.pow(line2Pt1[1] - line1Pt2[1], 2);\\n        \\n        return Math.sqrt(widthPow)*Math.sqrt(lenPow);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    private int[][] points;\\n    \\n    public double minAreaFreeRect(int[][] points) {\\n        this.points = points;\\n        \\n        Map<Pair<Double, Double>, Map<Long, List<Pair<Integer, Integer>>>> centerDiagLenLines = new HashMap();\\n        \\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i + 1; j < points.length; j++) {\\n                int[] point1 = points[i];\\n                int[] point2 = points[j];\\n                \\n                Pair<Double, Double> center = getCenter(point1, point2);\\n                long len = getLen(point1, point2);\\n                \\n                centerDiagLenLines.computeIfAbsent(center, k -> new HashMap<Long, List<Pair<Integer, Integer>>>()).computeIfAbsent(len, k -> new ArrayList<Pair<Integer, Integer>>()).add(new Pair(i,j));\\n            }\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        for(Pair<Double, Double> c: centerDiagLenLines.keySet()) {\\n             Map<Long, List<Pair<Integer, Integer>>> mp = centerDiagLenLines.get(c);\\n            Set<Long> keySet = mp.keySet();\\n            for(Long l: keySet) {\\n                List<Pair<Integer, Integer>> lines = mp.get(l);\\n                if(lines.size() < 2) continue;\\n                \\n                for(int i = 0; i < lines.size(); i++) {\\n                    for(int j = i + 1; j < lines.size(); j++) {\\n                        minArea = Math.min(minArea, getArea(lines.get(i), lines.get(j)));\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return minArea == Double.MAX_VALUE? 0: minArea;\\n    }\\n    \\n    private Pair<Double, Double> getCenter(int[] point1, int[] point2) {\\n        return new Pair((point1[0] + point2[0])/2.0, (point1[1] + point2[1])/2.0);\\n    }\\n    \\n    private long getLen(int[] point1, int[] point2) {\\n        int xDiff = point1[0] - point2[0];\\n        int yDiff = point1[1] - point2[1];\\n        return xDiff*xDiff + yDiff*yDiff;\\n    }\\n    \\n    private double getArea(Pair<Integer, Integer> line1, Pair<Integer, Integer> line2) {\\n        int[] line1Pt1 = points[line1.getKey()];\\n        int[] line1Pt2 = points[line1.getValue()];\\n\\n        int[] line2Pt1 = points[line2.getKey()];\\n        int[] line2Pt2 = points[line2.getValue()];\\n        \\n        double widthPow = Math.pow(line2Pt1[0] - line1Pt1[0], 2) + Math.pow(line2Pt1[1] - line1Pt1[1], 2);\\n        double lenPow = Math.pow(line2Pt1[0] - line1Pt2[0], 2) + Math.pow(line2Pt1[1] - line1Pt2[1], 2);\\n        \\n        return Math.sqrt(widthPow)*Math.sqrt(lenPow);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532210,
                "title": "python-group-all-lines-that-can-make-rectangles-with-each-other-into-a-sorted-list",
                "content": "```python\\nfrom math import sqrt\\nfrom collections import defaultdict as dd\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        \\n        # get length between points p1, p2\\n        length = lambda p1, p2: sqrt((p1[1]-p2[1])**2 + (p1[0]-p2[0])**2)\\n        \\n        # arrange tuple(p1, p2) so that p1 is always closest of two points to origin\\n        arrange = lambda p1, p2: (p1,p2) if length((0,0), p1) < length((0,0), p2) else (p2,p1)\\n        \\n        # get area encompassed by two parallel vectors v1 = tuple(p1, p2), v2 = tuple(p3, p4)\\n        area = lambda v1, v2: length(v1[0], v1[1]) * length(v1[0], v2[0])\\n        \\n        # get slope of points p1, p2\\n        slope = lambda p1, p2: float(\\'inf\\') if p1[0] == p2[0] else (p2[1]-p1[1])/(p2[0]-p1[0])\\n\\n        # get two orthogonal y-intercepts of points p1, p2\\n        orthogonals = lambda p1, p2: (p1[0], p2[0]) if p1[1] == p2[1] else ((p1[1] + p1[0]/slope(p1, p2)), (p2[1] + p2[0] / slope(p1, p2))) \\n        \\n        line_groups = dd(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                p1, p2 = arrange(points[i], points[j])\\n                \\n                # only potential vectors that can make a rectangle with p1->p2 \\n                # all have the same slope and same two orthogonal points\\n                line_groups[(orthogonals(p1,p2), slope(p1, p2))].append((p1,p2))\\n        \\n        min_area = float(\\'inf\\')\\n        for key in line_groups:\\n            \\n            # all vectors in vectors potentially make rectangle with each other\\n            vectors = sorted(line_groups[key])\\n            for i in range(len(vectors)-1):\\n                \\n                # smallest rectangle from vector[i] is always with vector[i+1] or vector[i-1]\\n                v1, v2 = vectors[i], vectors[i+1]\\n                \\n                # update min_area\\n                min_area = min(min_area, area(v1, v2))\\n                \\n        # if min_area was never updated, you never found a rectangle\\n        if min_area == float(\\'inf\\'): return 0\\n        return min_area\\n```\\n\\t\\t\\nFor some reason it works even if you don\\'t sort `vectors`, not sure if it\\'s because they\\'re missing test cases",
                "solutionTags": [],
                "code": "```python\\nfrom math import sqrt\\nfrom collections import defaultdict as dd\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        \\n        # get length between points p1, p2\\n        length = lambda p1, p2: sqrt((p1[1]-p2[1])**2 + (p1[0]-p2[0])**2)\\n        \\n        # arrange tuple(p1, p2) so that p1 is always closest of two points to origin\\n        arrange = lambda p1, p2: (p1,p2) if length((0,0), p1) < length((0,0), p2) else (p2,p1)\\n        \\n        # get area encompassed by two parallel vectors v1 = tuple(p1, p2), v2 = tuple(p3, p4)\\n        area = lambda v1, v2: length(v1[0], v1[1]) * length(v1[0], v2[0])\\n        \\n        # get slope of points p1, p2\\n        slope = lambda p1, p2: float(\\'inf\\') if p1[0] == p2[0] else (p2[1]-p1[1])/(p2[0]-p1[0])\\n\\n        # get two orthogonal y-intercepts of points p1, p2\\n        orthogonals = lambda p1, p2: (p1[0], p2[0]) if p1[1] == p2[1] else ((p1[1] + p1[0]/slope(p1, p2)), (p2[1] + p2[0] / slope(p1, p2))) \\n        \\n        line_groups = dd(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                p1, p2 = arrange(points[i], points[j])\\n                \\n                # only potential vectors that can make a rectangle with p1->p2 \\n                # all have the same slope and same two orthogonal points\\n                line_groups[(orthogonals(p1,p2), slope(p1, p2))].append((p1,p2))\\n        \\n        min_area = float(\\'inf\\')\\n        for key in line_groups:\\n            \\n            # all vectors in vectors potentially make rectangle with each other\\n            vectors = sorted(line_groups[key])\\n            for i in range(len(vectors)-1):\\n                \\n                # smallest rectangle from vector[i] is always with vector[i+1] or vector[i-1]\\n                v1, v2 = vectors[i], vectors[i+1]\\n                \\n                # update min_area\\n                min_area = min(min_area, area(v1, v2))\\n                \\n        # if min_area was never updated, you never found a rectangle\\n        if min_area == float(\\'inf\\'): return 0\\n        return min_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509700,
                "title": "typescript-solution-using-map",
                "content": "```\\ntype Line = {\\n    p1:number[],\\n    p2:number[],\\n    center:number[],\\n    len2:number,\\n    k:number,\\n};\\n\\nfunction minAreaFreeRect(points: number[][]): number {\\n    const lines:Line[] = [];\\n    const map:{[key:string]:Line[]} = {};\\n    \\n    for(let i:number = 0;i<points.length-1;i++){\\n        for(let j:number = i+1; j<points.length;j++){\\n            const [x1,y1] = points[i];\\n            const [x2,y2] = points[j];\\n            const k:number = (y2-y1)/(x2-x1);\\n            const center:number[] = [(x2+x1)/2,(y2+y1)/2];\\n            const len2:number = (y2-y1)**2 + (x2 - x1)**2;\\n            lines.push({\\n                p1:points[i],\\n                p2:points[j],\\n                center,\\n                len2,\\n                k,\\n            });\\n        }\\n    };\\n    \\n    let minArea:number = Infinity;\\n\\n    for(let i:number = 0;i<lines.length;i++){\\n        const line1:Line = lines[i];\\n        const key:string = \"\" + line1.center + line1.len2;\\n        if(map.hasOwnProperty(key)){\\n           for(const line2 of map[key]){\\n                const {p1,p2} = line1;\\n                const {p1:p1Two} = line2;\\n                const dist1:number = Math.sqrt((p1[0]-p1Two[0])**2 + (p1[1] - p1Two[1])**2);\\n                const dist2:number = Math.sqrt((p2[0]-p1Two[0])**2 + (p2[1] - p1Two[1])**2);\\n\\n                const area:number = dist1 * dist2;\\n                minArea = Math.min(minArea,area);\\n           };\\n           map[key].push(line1);\\n        }else{\\n           map[key] = [line1]; \\n        }\\n    };\\n    \\n    return minArea === Infinity ? 0 : minArea\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Line = {\\n    p1:number[],\\n    p2:number[],\\n    center:number[],\\n    len2:number,\\n    k:number,\\n};\\n\\nfunction minAreaFreeRect(points: number[][]): number {\\n    const lines:Line[] = [];\\n    const map:{[key:string]:Line[]} = {};\\n    \\n    for(let i:number = 0;i<points.length-1;i++){\\n        for(let j:number = i+1; j<points.length;j++){\\n            const [x1,y1] = points[i];\\n            const [x2,y2] = points[j];\\n            const k:number = (y2-y1)/(x2-x1);\\n            const center:number[] = [(x2+x1)/2,(y2+y1)/2];\\n            const len2:number = (y2-y1)**2 + (x2 - x1)**2;\\n            lines.push({\\n                p1:points[i],\\n                p2:points[j],\\n                center,\\n                len2,\\n                k,\\n            });\\n        }\\n    };\\n    \\n    let minArea:number = Infinity;\\n\\n    for(let i:number = 0;i<lines.length;i++){\\n        const line1:Line = lines[i];\\n        const key:string = \"\" + line1.center + line1.len2;\\n        if(map.hasOwnProperty(key)){\\n           for(const line2 of map[key]){\\n                const {p1,p2} = line1;\\n                const {p1:p1Two} = line2;\\n                const dist1:number = Math.sqrt((p1[0]-p1Two[0])**2 + (p1[1] - p1Two[1])**2);\\n                const dist2:number = Math.sqrt((p2[0]-p1Two[0])**2 + (p2[1] - p1Two[1])**2);\\n\\n                const area:number = dist1 * dist2;\\n                minArea = Math.min(minArea,area);\\n           };\\n           map[key].push(line1);\\n        }else{\\n           map[key] = [line1]; \\n        }\\n    };\\n    \\n    return minArea === Infinity ? 0 : minArea\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1462117,
                "title": "java-solution-with-simple-math",
                "content": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n \\n        /**\\n        Approach:\\n            \\n           \\n            \\n            \\n            Get a mapping for points by diagonal width and by center\\n            Idea : In a rectangle diagonals length is same and both the diagonals have same center\\n            \\n            \\n            Iterate through all  pair of points ( all combination of points N^2)\\n                => Get the length of line \\n                => Get the center of line\\n            \\n            we need to maintain two Map such that \\n            => center to Line Map \\n\\t\\t\\t=> Diagonal Width to Line Map\\n            \\n            Now iterate through each diagonal and cross check the same agains the center\\n            \\n\\t\\t\\tTime : O(N^3)\\n\\t\\t\\tSpaceL O(N^2)\\n            \\n        **/\\n        List<Point> allPoints = new ArrayList<>();\\n        \\n        for(int []aPoint : points) {\\n            allPoints.add(new Point(aPoint[0], aPoint[1]));\\n        }\\n        \\n        \\n        Map<String, List<Line>> clMap = new HashMap<>();\\n        \\n        // diagonal witdth to point \\n        Map<Long, List<Line>> dlMap = new HashMap<>();\\n        \\n        \\n        \\n        \\n        for(int i =0; i < points.length; i++) {\\n            Point aPoint = allPoints.get(i);\\n            for(int j =i + 1; j < points.length; j++ ) {\\n                Point bPoint = allPoints.get(j);\\n                \\n                String center = getCenterPointKey(aPoint, bPoint);\\n                \\n                if(!clMap.containsKey(center)) {\\n                    clMap.put(center, new ArrayList<>());\\n                }\\n                \\n                Line aLine = new Line(aPoint, bPoint);\\n                clMap.get(center).add(aLine);\\n                long diagLen = aLine.len;\\n                \\n                if(!dlMap.containsKey(diagLen)) {\\n                    dlMap.put(diagLen, new ArrayList<>());\\n                }\\n                \\n                dlMap.get(diagLen).add(aLine);\\n            }// end of inner forloop\\n        }// end of outer for loop\\n        \\n        // System.out.println(\"clMap:\" + clMap);\\n        // System.out.println(\"dlMap:\" + dlMap);\\n        \\n        double minArea = Double.MAX_VALUE;\\n        \\n        // now we have mapping of diagonals and centers\\n        //size of map will be N^2\\n        \\n        for(long diagLen : dlMap.keySet()) {\\n            \\n            List<Line> list = dlMap.get(diagLen);\\n            if(list.size() <= 1) {\\n                continue;\\n            }\\n            for(int i =0; i < list.size(); i++) {\\n            \\n                Line aLine = list.get(i);\\n                String center = getCenterPointKey(aLine.a, aLine.b);\\n                List<Line> cLines = clMap.get(center);\\n                if(cLines.size() > 1) {\\n                    // we have more than one lines with same center\\n                    for(Line cLine : cLines) {\\n                        if(cLine.len == diagLen && cLine != aLine) {\\n                            double area = getAreaOfRect(cLine, aLine);\\n                            if(area < minArea) {\\n                                minArea = area;\\n                            }\\n                        }\\n                    }  \\n                }\\n            }\\n            \\n        }// end of outer for loop\\n        return minArea ==Double.MAX_VALUE ? 0 : minArea;\\n    }\\n            \\n    double getAreaOfRect(Line aLine, Line bLine) {\\n        // first check if it is a rectangle\\n        // say aLine is [A,B] and bLine is [C,D]\\n        \\n        Line ad = new Line(aLine.a, bLine.b);\\n        \\n        Line bc = new Line(aLine.b, bLine.a);\\n        if(ad.len != bc.len) {\\n            // opposite sides are not same \\n            // it can not be a rectangle\\n            return Double.MAX_VALUE;\\n        }\\n        \\n        // it is a rectangle because \\n        // 1. diagonals are same\\n        // 2. center is same ( point of intersection of diagonal aLine and bLine)\\n        // 3. and two sides are equal ( ad and bc)\\n        \\n        \\n        Line bd = new Line(aLine.b, bLine.b);\\n        \\n        return  Math.sqrt( bd.len * ad.len);\\n        \\n    }\\n    \\n    String getCenterPointKey(Point aPoint, Point bPoint) {\\n        double cX = (aPoint.x + bPoint.x)/2.0;\\n        double cY = (aPoint.y + bPoint.y)/2.0;\\n                \\n        String center = cX + \"_\" + cY;\\n                return center;\\n    }\\n    \\n    // create a pojo class for easy calculation\\n    \\n    class Line {\\n        Point a;\\n        Point b;\\n        long len;\\n        Line(Point a, Point b) {\\n            this.a = a;\\n            this.b = b;\\n            len = Math.abs(a.x -b.x) * Math.abs(a.x -b.x) + Math.abs(a.y - b.y) * Math.abs(a.y - b.y);\\n            \\n        }\\n\\n        public String toString() {\\n            return \"{\" + a + \",\"+ b +\"}\";\\n        }\\n\\n        \\n    }\\n    \\n    class Point {\\n        long x;\\n        long y;\\n        String key;\\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n            key = x + \".\" + y;\\n        }\\n        \\n        String getKey() {\\n            return key;\\n        }\\n        \\n        public String toString() {\\n            return \"(\" + x + \",\"+ y +\")\";\\n        }\\n        \\n    }\\n    \\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n \\n        /**\\n        Approach:\\n            \\n           \\n            \\n            \\n            Get a mapping for points by diagonal width and by center\\n            Idea : In a rectangle diagonals length is same and both the diagonals have same center\\n            \\n            \\n            Iterate through all  pair of points ( all combination of points N^2)\\n                => Get the length of line \\n                => Get the center of line\\n            \\n            we need to maintain two Map such that \\n            => center to Line Map \\n\\t\\t\\t=> Diagonal Width to Line Map\\n            \\n            Now iterate through each diagonal and cross check the same agains the center\\n            \\n\\t\\t\\tTime : O(N^3)\\n\\t\\t\\tSpaceL O(N^2)\\n            \\n        **/\\n        List<Point> allPoints = new ArrayList<>();\\n        \\n        for(int []aPoint : points) {\\n            allPoints.add(new Point(aPoint[0], aPoint[1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1458812,
                "title": "very-easy-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int dot_prod(vector<int>v1,vector<int> v2)\\n    {\\n        return (v1[0]*v2[0]+v1[1]*v2[1])==0;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans=INT_MAX;\\n        int n=points.size();\\n        set< pair<int,int> >s;\\n        for(int i=0;i<n;i++)\\n            s.insert({points[i][0],points[i][1]});\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                { \\n                    vector<int>v1(2),v2(2);\\n                    \\n                    v1[0]=points[i][0]-points[j][0];\\n                    v1[1]=points[i][1]-points[j][1];\\n                    v2[0]=points[i][0]-points[k][0];\\n                    v2[1]=points[i][1]-points[k][1];\\n                    \\n                   if(dot_prod(v1,v2))//checks two adjacent sides are prependicular or not\\n                    {    \\n                       // mid point co-ordinates from points[j] and points[k] as diagonal \\n                        double midx=(double)(points[k][0]+points[j][0])/2;\\n                        double midy=(double)(points[k][1]+points[j][1])/2;\\n                        \\n                        //fourth co-ordinates\\n                        double fx=2*midx-points[i][0];\\n                        double fy=2*midy-points[i][1];\\n                       \\n                        if(s.find({fx,fy})!=s.end())\\n                        {\\n                            double len=v1[0]*v1[0]+v1[1]*v1[1];\\n                            double wid=v2[0]*v2[0]+v2[1]*v2[1];\\n                            \\n                            double area=sqrt(len)*sqrt(wid);\\n                            ans=min(area,ans);\\n                        }\\n                     }\\n                }\\n            }\\n        }\\n       return ans==INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dot_prod(vector<int>v1,vector<int> v2)\\n    {\\n        return (v1[0]*v2[0]+v1[1]*v2[1])==0;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans=INT_MAX;\\n        int n=points.size();\\n        set< pair<int,int> >s;\\n        for(int i=0;i<n;i++)\\n            s.insert({points[i][0],points[i][1]});\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                { \\n                    vector<int>v1(2),v2(2);\\n                    \\n                    v1[0]=points[i][0]-points[j][0];\\n                    v1[1]=points[i][1]-points[j][1];\\n                    v2[0]=points[i][0]-points[k][0];\\n                    v2[1]=points[i][1]-points[k][1];\\n                    \\n                   if(dot_prod(v1,v2))//checks two adjacent sides are prependicular or not\\n                    {    \\n                       // mid point co-ordinates from points[j] and points[k] as diagonal \\n                        double midx=(double)(points[k][0]+points[j][0])/2;\\n                        double midy=(double)(points[k][1]+points[j][1])/2;\\n                        \\n                        //fourth co-ordinates\\n                        double fx=2*midx-points[i][0];\\n                        double fy=2*midy-points[i][1];\\n                       \\n                        if(s.find({fx,fy})!=s.end())\\n                        {\\n                            double len=v1[0]*v1[0]+v1[1]*v1[1];\\n                            double wid=v2[0]*v2[0]+v2[1]*v2[1];\\n                            \\n                            double area=sqrt(len)*sqrt(wid);\\n                            ans=min(area,ans);\\n                        }\\n                     }\\n                }\\n            }\\n        }\\n       return ans==INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392052,
                "title": "16-ms-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int n=points.size(), i, j, k;\\n        double ret=0, e=1e-5;\\n        unordered_map<int, unordered_map<int, bool>> s;\\n        for(auto &p:points) s[p[0]][p[1]]=true;\\n        for(i=0; i<n; i++) {\\n            for(j=i+1; j<n; j++) {\\n                auto &p1=points[i], &p2=points[j];\\n                double x=(p1[0]+p2[0])/2.0, y=(p1[1]+p2[1])/2.0;\\n                double d=pow((p1[0]-x), 2)+pow((p1[1]-y), 2);\\n                for(k=j+1; k<n; k++) {\\n                    auto &p3=points[k];\\n                    double t=pow((p3[0]-x), 2)+pow((p3[1]-y), 2);\\n                    if (fabs(t-d)>e) continue;\\n                    double x1=2*x-p3[0], y1=2*y-p3[1];\\n                    int xi1=int(x1), yi1=int(y1);\\n                    if (fabs(xi1-x1)>e || fabs(yi1-y1)>e || s[xi1][yi1]==false) continue;\\n                    double a=sqrt(pow((p1[0]-p3[0]), 2)+pow((p1[1]-p3[1]), 2))*sqrt(pow((p2[0]-p3[0]), 2)+pow((p2[1]-p3[1]), 2));\\n                    if (ret==0 || a<ret) ret=a;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int n=points.size(), i, j, k;\\n        double ret=0, e=1e-5;\\n        unordered_map<int, unordered_map<int, bool>> s;\\n        for(auto &p:points) s[p[0]][p[1]]=true;\\n        for(i=0; i<n; i++) {\\n            for(j=i+1; j<n; j++) {\\n                auto &p1=points[i], &p2=points[j];\\n                double x=(p1[0]+p2[0])/2.0, y=(p1[1]+p2[1])/2.0;\\n                double d=pow((p1[0]-x), 2)+pow((p1[1]-y), 2);\\n                for(k=j+1; k<n; k++) {\\n                    auto &p3=points[k];\\n                    double t=pow((p3[0]-x), 2)+pow((p3[1]-y), 2);\\n                    if (fabs(t-d)>e) continue;\\n                    double x1=2*x-p3[0], y1=2*y-p3[1];\\n                    int xi1=int(x1), yi1=int(y1);\\n                    if (fabs(xi1-x1)>e || fabs(yi1-y1)>e || s[xi1][yi1]==false) continue;\\n                    double a=sqrt(pow((p1[0]-p3[0]), 2)+pow((p1[1]-p3[1]), 2))*sqrt(pow((p2[0]-p3[0]), 2)+pow((p2[1]-p3[1]), 2));\\n                    if (ret==0 || a<ret) ret=a;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347551,
                "title": "java-o-n-3-time-beats-90",
                "content": "1: First record all the positions of points in map, index_x as key and set of index_y as value;\\n2: then set line p1p2 ( p1:[x_1, y_1], p2:[x_2, y_2] ) as diagonal of rectangle;\\n3: then try to find another point( p3:[x_3, y_3] ), so that (x_3 - x_1) * (x_3 - x_2) + (y_3 - y_1) * (y_3 - y_2) = 0, meaning that line p1p3 is vertical to line p2p3;\\n4: if such point p3 was found, then we check if a point p4( [x_4, y_4] ) exist in map, so that x_4 = x_1 + (x_2 - x_3) && y_4 = y_1 + (y_2 - y_3), meaning that line p1p4 is parallel to line p2p3 AND these two lines have equal length;\\n5: if such point p4 was found, calculate the area and update the min area\\n6: return the min area\\n\\nTime: O(N^3)\\n// 3 for loops with one time search from map\\nSpace: O(N)\\n// map to store the coodinates\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        double min = Double.MAX_VALUE;\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int[] point : points) {\\n            if (!map.containsKey(point[0])) {\\n                map.put(point[0], new HashSet<>());\\n            }\\n            map.get(point[0]).add(point[1]);\\n        }\\n        for (int i = 0; i < points.length - 1; i ++) {\\n            for (int j = i + 1; j < points.length; j ++) {\\n                int[] diagno_1 = points[i];\\n                int[] diagno_2 = points[j];\\n                for (int k = 0; k < points.length; k ++) {\\n                    if (k != i && k != j) {\\n                        int[] candid = points[k];\\n                        if (((candid[0] - diagno_1[0]) * (candid[0] - diagno_2[0])) + ((candid[1] - diagno_1[1]) * (candid[1] - diagno_2[1])) == 0) {\\n                            int desired_x = diagno_1[0] + (diagno_2[0] - candid[0]);\\n                            int desired_y = diagno_1[1] + (diagno_2[1] - candid[1]);\\n                            if (map.containsKey(desired_x) && map.get(desired_x).contains(desired_y)) {\\n                                double side_1 = Math.sqrt((int)Math.pow(candid[0] - diagno_1[0], 2) + (int)Math.pow(candid[1] - diagno_1[1], 2));\\n                                double side_2 = Math.sqrt((int)Math.pow(candid[0] - diagno_2[0], 2) + (int)Math.pow(candid[1] - diagno_2[1], 2));\\n                                double area = side_1 * side_2;\\n                                min = Math.min(area, min);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        double min = Double.MAX_VALUE;\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int[] point : points) {\\n            if (!map.containsKey(point[0])) {\\n                map.put(point[0], new HashSet<>());\\n            }\\n            map.get(point[0]).add(point[1]);\\n        }\\n        for (int i = 0; i < points.length - 1; i ++) {\\n            for (int j = i + 1; j < points.length; j ++) {\\n                int[] diagno_1 = points[i];\\n                int[] diagno_2 = points[j];\\n                for (int k = 0; k < points.length; k ++) {\\n                    if (k != i && k != j) {\\n                        int[] candid = points[k];\\n                        if (((candid[0] - diagno_1[0]) * (candid[0] - diagno_2[0])) + ((candid[1] - diagno_1[1]) * (candid[1] - diagno_2[1])) == 0) {\\n                            int desired_x = diagno_1[0] + (diagno_2[0] - candid[0]);\\n                            int desired_y = diagno_1[1] + (diagno_2[1] - candid[1]);\\n                            if (map.containsKey(desired_x) && map.get(desired_x).contains(desired_y)) {\\n                                double side_1 = Math.sqrt((int)Math.pow(candid[0] - diagno_1[0], 2) + (int)Math.pow(candid[1] - diagno_1[1], 2));\\n                                double side_2 = Math.sqrt((int)Math.pow(candid[0] - diagno_2[0], 2) + (int)Math.pow(candid[1] - diagno_2[1], 2));\\n                                double area = side_1 * side_2;\\n                                min = Math.min(area, min);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323394,
                "title": "c-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tdouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\t\\t\\tset<vector<int>>num;\\n\\t\\t\\tfor(const auto &s:points)num.insert(s);\\n\\n\\t\\t\\tdouble res=DBL_MAX;\\n\\n\\t\\t\\tfor(int i=0;i<=points.size()-3;++i){\\n\\t\\t\\t\\tfor(int j=i+1;j<=points.size()-2;++j){\\n\\t\\t\\t\\t\\tfor(int k=j+1;k<points.size();++k){\\n\\t\\t\\t\\t\\t\\tdouble slop_y1=points[j][1]-points[i][1];\\n\\t\\t\\t\\t\\t\\tdouble slop_x1=points[j][0]-points[i][0];\\n\\t\\t\\t\\t\\t\\tdouble slop_y2=points[k][1]-points[i][1];\\n\\t\\t\\t\\t\\t\\tdouble slop_x2=points[k][0]-points[i][0];\\n\\t\\t\\t\\t\\t\\tif(slop_y1*slop_y2+slop_x1*slop_x2!=0)continue;\\n\\n\\t\\t\\t\\t\\t\\tint lasty=slop_y1+points[k][1];\\n\\t\\t\\t\\t\\t\\tint lastx=slop_x1+points[k][0];\\n\\n\\t\\t\\t\\t\\t\\tif(num.count({lastx,lasty})){                        \\n\\t\\t\\t\\t\\t\\t\\tres=min(res,sqrt(pow(slop_y1,2)+pow(slop_x1,2))*sqrt(pow(slop_y2,2)+pow(slop_x2,2)));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res==DBL_MAX?0:res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tdouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\t\\t\\tset<vector<int>>num;\\n\\t\\t\\tfor(const auto &s:points)num.insert(s);\\n\\n\\t\\t\\tdouble res=DBL_MAX;\\n\\n\\t\\t\\tfor(int i=0;i<=points.size()-3;++i){\\n\\t\\t\\t\\tfor(int j=i+1;j<=points.size()-2;++j){\\n\\t\\t\\t\\t\\tfor(int k=j+1;k<points.size();++k){\\n\\t\\t\\t\\t\\t\\tdouble slop_y1=points[j][1]-points[i][1];\\n\\t\\t\\t\\t\\t\\tdouble slop_x1=points[j][0]-points[i][0];\\n\\t\\t\\t\\t\\t\\tdouble slop_y2=points[k][1]-points[i][1];\\n\\t\\t\\t\\t\\t\\tdouble slop_x2=points[k][0]-points[i][0];\\n\\t\\t\\t\\t\\t\\tif(slop_y1*slop_y2+slop_x1*slop_x2!=0)continue;\\n\\n\\t\\t\\t\\t\\t\\tint lasty=slop_y1+points[k][1];\\n\\t\\t\\t\\t\\t\\tint lastx=slop_x1+points[k][0];\\n\\n\\t\\t\\t\\t\\t\\tif(num.count({lastx,lasty}",
                "codeTag": "Java"
            },
            {
                "id": 1214523,
                "title": "abstracted-and-elegant-c-diagonal-solution",
                "content": "Refactored code from @bianhit\\n\\n```\\nclass Point{\\n    public:\\n    double x;\\n    double y;\\n    Point(double x,double y):x(x),y(y){}\\n    double dist(Point* p1){\\n        return sqrt((p1->x-this->x)*(p1->x-this->x)+(p1->y-this->y)*(p1->y-this->y));\\n    }\\n    Point* center(Point* p1){\\n        double xc = (p1->x+this->x)/2.0;\\n        double yc = (p1->y+this->y)/2.0;\\n        return new Point(xc,yc);\\n    }\\n};\\nvoid fillDiagInfo(vector<vector<int>>& points,unordered_map<string,vector<pair<Point*,Point*>>> &diag){\\n    for(int i=0;i<points.size();i++){\\n        for(int j=i+1;j<points.size();j++){\\n            Point* p1 = new Point(points[i][0],points[i][1]);\\n            Point* p2 = new Point(points[j][0],points[j][1]);\\n            string dis = to_string(p1->dist(p2));\\n            Point *cent = p1->center(p2);\\n            string cen = to_string(cent->x)+\",\"+to_string(cent->y);\\n            diag[dis+\"#\"+cen].push_back(make_pair(p1,p2));\\n        }\\n    }\\n}\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string,vector<pair<Point*,Point*>>> diag;\\n        fillDiagInfo(points,diag);\\n        double minArea = INT_MAX;\\n        for(auto it=diag.begin();it!=diag.end();it++){\\n            if(it->second.size()<2) continue;\\n            auto p = it->second;\\n            for(int i=0;i<p.size();i++){\\n                for(int j=i+1;j<p.size();j++){\\n                    Point *p1 = p[i].first;\\n                    Point *p2 = p[j].first;\\n                    Point *p3 = p[i].second;\\n                    minArea = min(minArea,(p1->dist(p2))*(p2->dist(p3)));\\n                }\\n            }\\n        }\\n        return minArea==double(INT_MAX)?0:minArea;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Point{\\n    public:\\n    double x;\\n    double y;\\n    Point(double x,double y):x(x),y(y){}\\n    double dist(Point* p1){\\n        return sqrt((p1->x-this->x)*(p1->x-this->x)+(p1->y-this->y)*(p1->y-this->y));\\n    }\\n    Point* center(Point* p1){\\n        double xc = (p1->x+this->x)/2.0;\\n        double yc = (p1->y+this->y)/2.0;\\n        return new Point(xc,yc);\\n    }\\n};\\nvoid fillDiagInfo(vector<vector<int>>& points,unordered_map<string,vector<pair<Point*,Point*>>> &diag){\\n    for(int i=0;i<points.size();i++){\\n        for(int j=i+1;j<points.size();j++){\\n            Point* p1 = new Point(points[i][0],points[i][1]);\\n            Point* p2 = new Point(points[j][0],points[j][1]);\\n            string dis = to_string(p1->dist(p2));\\n            Point *cent = p1->center(p2);\\n            string cen = to_string(cent->x)+\",\"+to_string(cent->y);\\n            diag[dis+\"#\"+cen].push_back(make_pair(p1,p2));\\n        }\\n    }\\n}\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        unordered_map<string,vector<pair<Point*,Point*>>> diag;\\n        fillDiagInfo(points,diag);\\n        double minArea = INT_MAX;\\n        for(auto it=diag.begin();it!=diag.end();it++){\\n            if(it->second.size()<2) continue;\\n            auto p = it->second;\\n            for(int i=0;i<p.size();i++){\\n                for(int j=i+1;j<p.size();j++){\\n                    Point *p1 = p[i].first;\\n                    Point *p2 = p[j].first;\\n                    Point *p3 = p[i].second;\\n                    minArea = min(minArea,(p1->dist(p2))*(p2->dist(p3)));\\n                }\\n            }\\n        }\\n        return minArea==double(INT_MAX)?0:minArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154769,
                "title": "js-o-n-3",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    function isRect(pivot, a, b) {\\n        const [pivotX, pivotY] = pivot\\n        const [aX, aY] = a\\n        const [bX, bY] = b\\n        \\n        const deltaXA = aX - pivotX\\n        const deltaYA = aY - pivotY\\n        const deltaXB = bX - pivotX\\n        const deltaYB = bY - pivotY\\n        \\n        return deltaXA * deltaXB + deltaYA * deltaYB === 0\\n    }\\n    \\n    function toKey(point) {\\n        return point.join(\\'|\\')\\n    }\\n    \\n    \\n    const pointKeySet = points.reduce((set, point) => {\\n        const key = toKey(point)\\n        set.add(key)\\n        return set\\n    }, new Set())\\n    \\n    \\n    let result = Infinity\\n    for (let i = 0, len = points.length;\\n    i < len; i++) {\\n        const pivot = points[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const pointA = points[j]\\n            for (let k = 1 + j; k < len; k++) {\\n                const pointB = points[k]\\n                if (!isRect(pivot, pointA, pointB))\\n                    continue\\n                    \\n                const doubleX = pointA[0] + pointB[0]\\n                const doubleY = pointA[1] + pointB[1]\\n                const seekMeX = doubleX - pivot[0]\\n                const seekMeY = doubleY - pivot[1]\\n                const seekMe = [seekMeX, seekMeY]\\n                const seekMeKey = toKey(seekMe)\\n                \\n                if (pointKeySet.has(seekMeKey)) {\\n                    const [pivotX, pivotY] = pivot\\n                    const [aX, aY] = pointA\\n                    const [bX, bY] = pointB\\n                    \\n                    const deltaXA = aX - pivotX\\n                    const deltaYA = aY - pivotY\\n                    const deltaXB = bX - pivotX\\n                    const deltaYB = bY - pivotY\\n                    const width = Math.hypot(deltaXA, deltaYA)\\n                    const height = Math.hypot(deltaXB, deltaYB)\\n                    \\n                    let outcome = width * height\\n                    result = Math.min(result, outcome)\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    if (result === Infinity)\\n        result = 0\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    function isRect(pivot, a, b) {\\n        const [pivotX, pivotY] = pivot\\n        const [aX, aY] = a\\n        const [bX, bY] = b\\n        \\n        const deltaXA = aX - pivotX\\n        const deltaYA = aY - pivotY\\n        const deltaXB = bX - pivotX\\n        const deltaYB = bY - pivotY\\n        \\n        return deltaXA * deltaXB + deltaYA * deltaYB === 0\\n    }\\n    \\n    function toKey(point) {\\n        return point.join(\\'|\\')\\n    }\\n    \\n    \\n    const pointKeySet = points.reduce((set, point) => {\\n        const key = toKey(point)\\n        set.add(key)\\n        return set\\n    }, new Set())\\n    \\n    \\n    let result = Infinity\\n    for (let i = 0, len = points.length;\\n    i < len; i++) {\\n        const pivot = points[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const pointA = points[j]\\n            for (let k = 1 + j; k < len; k++) {\\n                const pointB = points[k]\\n                if (!isRect(pivot, pointA, pointB))\\n                    continue\\n                    \\n                const doubleX = pointA[0] + pointB[0]\\n                const doubleY = pointA[1] + pointB[1]\\n                const seekMeX = doubleX - pivot[0]\\n                const seekMeY = doubleY - pivot[1]\\n                const seekMe = [seekMeX, seekMeY]\\n                const seekMeKey = toKey(seekMe)\\n                \\n                if (pointKeySet.has(seekMeKey)) {\\n                    const [pivotX, pivotY] = pivot\\n                    const [aX, aY] = pointA\\n                    const [bX, bY] = pointB\\n                    \\n                    const deltaXA = aX - pivotX\\n                    const deltaYA = aY - pivotY\\n                    const deltaXB = bX - pivotX\\n                    const deltaYB = bY - pivotY\\n                    const width = Math.hypot(deltaXA, deltaYA)\\n                    const height = Math.hypot(deltaXB, deltaYB)\\n                    \\n                    let outcome = width * height\\n                    result = Math.min(result, outcome)\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    if (result === Infinity)\\n        result = 0\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1108747,
                "title": "java-solution-83-faster",
                "content": "```\\npublic static class Segment {\\n        int[] a;\\n        int[] b;\\n        int dx;\\n        int dy;\\n        double inclination;\\n        Double length;\\n\\n        public Segment(int[] a, int[] b) {\\n            // sort by x-value\\n            if (a[0] <= b[0]) {\\n                this.a = a;\\n                this.b = b;\\n            } else {\\n                this.a = b;\\n                this.b = a;\\n            }\\n            dx = a[0] - b[0];\\n            dy = a[1] - b[1];\\n            inclination = calculateInclination();\\n        }\\n\\n        public double getLength() {\\n            if (this.length == null)\\n                this.length = Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\\n            return this.length;\\n        }\\n\\n        public double getSizeOfRectangle(Segment another) {\\n            Segment s1 = new Segment(this.a, another.a);\\n            Segment s2 = new Segment(this.b, another.b);\\n\\n            if (isInSameLine(another)) return 0;\\n            if (isOrthogonalWith(s1) && isOrthogonalWith(s2)) {\\n                return this.getLength() * s1.getLength();\\n            }\\n            return 0;\\n\\n        }\\n\\n        // check if two segments are in same line\\n        private boolean isInSameLine(Segment another) {\\n            int dx2 = another.a[0] - a[0];\\n            int dy2 = another.a[1] - a[1];\\n\\n            return dy * dx2 == dy2 * dx;\\n        }\\n\\n        // check if two segments are orthogonal\\n        private boolean isOrthogonalWith(Segment another) {\\n            if ((dx == 0 && another.dy == 0 || dy == 0 && another.dy == 0)) return true;\\n\\n            return dx * another.dx == -dy * another.dy;\\n        }\\n\\n        private double calculateInclination() {\\n            // use Double.MAX_VALUE as infinite value\\n            if (a[0] - b[0] == 0) return Double.MAX_VALUE;\\n\\n            double inclination = ((double) a[1] - b[1]) / ((double) a[0] - b[0]);\\n            // convert -0.0 to +0.0\\n            if (inclination == -0) return 0;\\n\\n            return inclination;\\n        }\\n    }\\n\\n    public static double minAreaFreeRect(int[][] points) {\\n        double min = Double.MAX_VALUE;\\n        int n = points.length;\\n\\n        // K: inclination , V: segment\\n        Map<Double, List<Segment>> map = new HashMap<>();\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                Segment segment = new Segment(points[i], points[j]);\\n                double inclination = segment.inclination;\\n                List<Segment> list = map.get(inclination);\\n                if (list == null) {\\n                    list = new ArrayList<>();\\n\\n                }\\n                list.add(segment);\\n                map.put(inclination, list);\\n            }\\n        }\\n        for (double inclination : map.keySet()) {\\n            List<Segment> list = map.get(inclination);\\n            for (int i = 0; i < list.size() - 1; i++) {\\n                for (int j = i + 1; j < list.size(); j++) {\\n                    double size = list.get(i).getSizeOfRectangle(list.get(j));\\n                    if (size != 0)\\n                        min = Math.min(min, size);\\n                }\\n            }\\n        }\\n        if (min == Double.MAX_VALUE) return 0;\\n        return min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static class Segment {\\n        int[] a;\\n        int[] b;\\n        int dx;\\n        int dy;\\n        double inclination;\\n        Double length;\\n\\n        public Segment(int[] a, int[] b) {\\n            // sort by x-value\\n            if (a[0] <= b[0]) {\\n                this.a = a;\\n                this.b = b;\\n            } else {\\n                this.a = b;\\n                this.b = a;\\n            }\\n            dx = a[0] - b[0];\\n            dy = a[1] - b[1];\\n            inclination = calculateInclination();\\n        }\\n\\n        public double getLength() {\\n            if (this.length == null)\\n                this.length = Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\\n            return this.length;\\n        }\\n\\n        public double getSizeOfRectangle(Segment another) {\\n            Segment s1 = new Segment(this.a, another.a);\\n            Segment s2 = new Segment(this.b, another.b);\\n\\n            if (isInSameLine(another)) return 0;\\n            if (isOrthogonalWith(s1) && isOrthogonalWith(s2)) {\\n                return this.getLength() * s1.getLength();\\n            }\\n            return 0;\\n\\n        }\\n\\n        // check if two segments are in same line\\n        private boolean isInSameLine(Segment another) {\\n            int dx2 = another.a[0] - a[0];\\n            int dy2 = another.a[1] - a[1];\\n\\n            return dy * dx2 == dy2 * dx;\\n        }\\n\\n        // check if two segments are orthogonal\\n        private boolean isOrthogonalWith(Segment another) {\\n            if ((dx == 0 && another.dy == 0 || dy == 0 && another.dy == 0)) return true;\\n\\n            return dx * another.dx == -dy * another.dy;\\n        }\\n\\n        private double calculateInclination() {\\n            // use Double.MAX_VALUE as infinite value\\n            if (a[0] - b[0] == 0) return Double.MAX_VALUE;\\n\\n            double inclination = ((double) a[1] - b[1]) / ((double) a[0] - b[0]);\\n            // convert -0.0 to +0.0\\n            if (inclination == -0) return 0;\\n\\n            return inclination;\\n        }\\n    }\\n\\n    public static double minAreaFreeRect(int[][] points) {\\n        double min = Double.MAX_VALUE;\\n        int n = points.length;\\n\\n        // K: inclination , V: segment\\n        Map<Double, List<Segment>> map = new HashMap<>();\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                Segment segment = new Segment(points[i], points[j]);\\n                double inclination = segment.inclination;\\n                List<Segment> list = map.get(inclination);\\n                if (list == null) {\\n                    list = new ArrayList<>();\\n\\n                }\\n                list.add(segment);\\n                map.put(inclination, list);\\n            }\\n        }\\n        for (double inclination : map.keySet()) {\\n            List<Segment> list = map.get(inclination);\\n            for (int i = 0; i < list.size() - 1; i++) {\\n                for (int j = i + 1; j < list.size(); j++) {\\n                    double size = list.get(i).getSizeOfRectangle(list.get(j));\\n                    if (size != 0)\\n                        min = Math.min(min, size);\\n                }\\n            }\\n        }\\n        if (min == Double.MAX_VALUE) return 0;\\n        return min;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079513,
                "title": "python-fast-and-easy-solution-better-than-90-online-submissions",
                "content": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        if len(points)<4:\\n            return 0\\n        \\n        def dis(x,y):\\n            return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\\n        \\n        diagonal={}\\n        area=float(\"inf\")\\n        for i in range(len(points)):\\n            for j in range(i):\\n                p1=points[i]\\n                p2=points[j]\\n                \\n                cx=(p1[0]+p2[0])/2\\n                cy=(p1[1]+p2[1])/2\\n                le=(p2[0]-p1[0])**2+(p2[1]-p1[1])**2\\n                \\n                if diagonal.get((cx,cy,le))==None:\\n                    diagonal[(cx,cy,le)]=[(p1,p2)]\\n                else:\\n                    diagonal[(cx,cy,le)].append((p1,p2))\\n        for i in diagonal:\\n            if len(diagonal[i])>1:\\n                \\n                for j in range(len(diagonal[i])):\\n                    for k in range(j):\\n                        \\n                        p1=diagonal[i][j][0]\\n                        p2=diagonal[i][j][1]\\n                        p3=diagonal[i][k][0]\\n                        p4=diagonal[i][k][1]\\n                        \\n                        area=min(area,dis(p1,p3)*dis(p2,p3))\\n        return area if area!=float(\"inf\") else 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        if len(points)<4:\\n            return 0\\n        \\n        def dis(x,y):\\n            return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\\n        \\n        diagonal={}\\n        area=float(\"inf\")\\n        for i in range(len(points)):\\n            for j in range(i):\\n                p1=points[i]\\n                p2=points[j]\\n                \\n                cx=(p1[0]+p2[0])/2\\n                cy=(p1[1]+p2[1])/2\\n                le=(p2[0]-p1[0])**2+(p2[1]-p1[1])**2\\n                \\n                if diagonal.get((cx,cy,le))==None:\\n                    diagonal[(cx,cy,le)]=[(p1,p2)]\\n                else:\\n                    diagonal[(cx,cy,le)].append((p1,p2))\\n        for i in diagonal:\\n            if len(diagonal[i])>1:\\n                \\n                for j in range(len(diagonal[i])):\\n                    for k in range(j):\\n                        \\n                        p1=diagonal[i][j][0]\\n                        p2=diagonal[i][j][1]\\n                        p3=diagonal[i][k][0]\\n                        p4=diagonal[i][k][1]\\n                        \\n                        area=min(area,dis(p1,p3)*dis(p2,p3))\\n        return area if area!=float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072798,
                "title": "golang-brute-force-solution",
                "content": "```go\\nfunc minAreaFreeRect(points [][]int) float64 {\\n\\thash := map[[2]int]struct{}{}\\n\\tfor _, p := range points {\\n\\t\\thash[[...]int{p[0], p[1]}] = struct{}{}\\n\\t}\\n\\tminRect := 0.0\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tfor j := i+1; j < len(points); j++ {\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n                if k == i || k == j {\\n                    continue\\n                }\\n\\t\\t\\t\\tif area, exist := getArea(points[i], points[j], points[k], hash); exist {\\n\\t\\t\\t\\t\\tif minRect == 0.0 || minRect > area {\\n\\t\\t\\t\\t\\t\\tminRect = area\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn minRect\\n}\\n\\nfunc getArea(x, y, z []int, hash map[[2]int]struct{}) (float64, bool) {\\n\\ta := (x[1] - y[1]) * (y[1] - z[1])\\n\\tb := (x[0] - y[0]) * (y[0] - z[0])\\n    // a == -b means LineXY is perpendicular to lineYZ\\n\\tif a != -b {\\n\\t\\treturn 0.0, false\\n\\t}\\n    // calculate the other point q\\n\\tqx := x[0] + z[0] - y[0]\\n\\tqy := x[1] + z[1] - y[1]\\n    // q must exist in hash\\n\\tif _, exist := hash[[...]int{qx, qy}]; !exist {\\n\\t\\treturn 0.0, false\\n\\t}\\n\\tarea := math.Hypot(float64(x[1]-y[1]), float64(x[0]-y[0])) * math.Hypot(float64(y[1]-z[1]), float64(y[0]-z[0]))\\n\\treturn area, true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minAreaFreeRect(points [][]int) float64 {\\n\\thash := map[[2]int]struct{}{}\\n\\tfor _, p := range points {\\n\\t\\thash[[...]int{p[0], p[1]}] = struct{}{}\\n\\t}\\n\\tminRect := 0.0\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tfor j := i+1; j < len(points); j++ {\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n                if k == i || k == j {\\n                    continue\\n                }\\n\\t\\t\\t\\tif area, exist := getArea(points[i], points[j], points[k], hash); exist {\\n\\t\\t\\t\\t\\tif minRect == 0.0 || minRect > area {\\n\\t\\t\\t\\t\\t\\tminRect = area\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn minRect\\n}\\n\\nfunc getArea(x, y, z []int, hash map[[2]int]struct{}) (float64, bool) {\\n\\ta := (x[1] - y[1]) * (y[1] - z[1])\\n\\tb := (x[0] - y[0]) * (y[0] - z[0])\\n    // a == -b means LineXY is perpendicular to lineYZ\\n\\tif a != -b {\\n\\t\\treturn 0.0, false\\n\\t}\\n    // calculate the other point q\\n\\tqx := x[0] + z[0] - y[0]\\n\\tqy := x[1] + z[1] - y[1]\\n    // q must exist in hash\\n\\tif _, exist := hash[[...]int{qx, qy}]; !exist {\\n\\t\\treturn 0.0, false\\n\\t}\\n\\tarea := math.Hypot(float64(x[1]-y[1]), float64(x[0]-y[0])) * math.Hypot(float64(y[1]-z[1]), float64(y[0]-z[0]))\\n\\treturn area, true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005746,
                "title": "c-o-n-3-beating-98-95-runtime-with-detailed-explanation",
                "content": "This is a hard problem. \\n\\nFor any two points   i and  j,  we can draw a line between them and use the line as c of a triangle.  For any third point l1: we record a triangle and the edges have the following relation  a^2+ b^2=c^2. \\n\\nNow the goal is to find the fourth point l2,  it can also form another triangle satisfiying the same relation\\n\\na^2+ b^2=c^2\\n\\n\\nSo we have 4 points with 3 triangles sharing the same edge c, as follows: \\n\\n```\\n   i         l2\\n       b\\n   -------\\na | \\\\      |\\n  |   \\\\  c |  a\\n  |     \\\\  |\\n  l1- ---- j\\n      b\\n```\\n\\nc= dist(i,j)     // we need power 2 one both side, so we calculate dist_square (i,j)\\na = dist(i, l)\\nb= dist(l, j)\\n\\n```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int sz=points.size();\\n\\n        //must short points first by first dimension x. \\n\\t\\t // We find boundary points first, then find middle points in the triangles. \\n        sort (points.begin(), points.end());\\n\\n        // long instead of int to avoid overflow after multiplication\\n        vector<vector<long>> dist_square(sz, vector<long>(sz,0));\\n\\n        // dist_square[i][j] for any two points indexed i and j\\n        for (int i=0; i<sz;i++)\\n            for (int j=i+1; j<sz; j++)\\n            {\\n                long dx= points[i][0]-points[j][0], dy= points[i][1]-points[j][1];\\n                dist_square[i][j]= dx*dx + dy*dy;\\n                dist_square[j][i]=  dist_square[i][j];\\n            }\\n\\n        long min_area_square= numeric_limits<long>::max();\\n\\n        // now find all i,j, then l1, then l2\\n        for (int i=0; i<sz; i++)\\n            for (int j=sz-1; j>i+2; j--) // i0, i1,i2, j, at least four points between [i,j]\\n            {\\n                long c_square= dist_square[i][j];                \\n                if (c_square==0) continue; // skip 0 len c edge\\n\\n                // a^2+ b^2=c^2:   pair of a2 and b2 satisfying the equation\\n                unordered_map <long, vector<pair<long,long>>> c2pairs;\\n\\n                for (int l=i+1; l<j; l++)\\n                {\\n                    long a_square= dist_square[i][l];\\n                    long b_square= dist_square[j][l];\\n\\n                    //optimize: even if we found a square, the area would be too large\\n                    if (a_square*b_square >= min_area_square) continue;\\n                  \\n                    if (a_square+b_square==c_square) // a new l is found\\n                    {\\n                        if (c2pairs.count(c_square)) // prevous l ??\\n                        {\\n                            for (auto p: c2pairs[c_square])\\n                            {\\n                                // matching same a b pairs:\\n                                // it is possible same c_square, but differnt a, b pair\\n                                if ( (p.first==a_square && p.second==b_square) ||\\n                                     (p.first==b_square && p.second==a_square) )\\n                                { \\n                                    min_area_square= min (min_area_square,  a_square*b_square);\\n                                    break; // one square of same a,b,c length is enough\\n                                }\\n                            }\\n                        }\\n                        // store current triangle anyway\\n                        c2pairs[c_square].push_back({a_square, b_square});\\n                    }\\n\\n                }\\n            }\\n\\n        if (min_area_square==numeric_limits<long>::max() )\\n            return 0.0;\\n        return sqrt ((double)min_area_square);\\n\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   i         l2\\n       b\\n   -------\\na | \\\\      |\\n  |   \\\\  c |  a\\n  |     \\\\  |\\n  l1- ---- j\\n      b\\n```\n```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int sz=points.size();\\n\\n        //must short points first by first dimension x. \\n\\t\\t // We find boundary points first, then find middle points in the triangles. \\n        sort (points.begin(), points.end());\\n\\n        // long instead of int to avoid overflow after multiplication\\n        vector<vector<long>> dist_square(sz, vector<long>(sz,0));\\n\\n        // dist_square[i][j] for any two points indexed i and j\\n        for (int i=0; i<sz;i++)\\n            for (int j=i+1; j<sz; j++)\\n            {\\n                long dx= points[i][0]-points[j][0], dy= points[i][1]-points[j][1];\\n                dist_square[i][j]= dx*dx + dy*dy;\\n                dist_square[j][i]=  dist_square[i][j];\\n            }\\n\\n        long min_area_square= numeric_limits<long>::max();\\n\\n        // now find all i,j, then l1, then l2\\n        for (int i=0; i<sz; i++)\\n            for (int j=sz-1; j>i+2; j--) // i0, i1,i2, j, at least four points between [i,j]\\n            {\\n                long c_square= dist_square[i][j];                \\n                if (c_square==0) continue; // skip 0 len c edge\\n\\n                // a^2+ b^2=c^2:   pair of a2 and b2 satisfying the equation\\n                unordered_map <long, vector<pair<long,long>>> c2pairs;\\n\\n                for (int l=i+1; l<j; l++)\\n                {\\n                    long a_square= dist_square[i][l];\\n                    long b_square= dist_square[j][l];\\n\\n                    //optimize: even if we found a square, the area would be too large\\n                    if (a_square*b_square >= min_area_square) continue;\\n                  \\n                    if (a_square+b_square==c_square) // a new l is found\\n                    {\\n                        if (c2pairs.count(c_square)) // prevous l ??\\n                        {\\n                            for (auto p: c2pairs[c_square])\\n                            {\\n                                // matching same a b pairs:\\n                                // it is possible same c_square, but differnt a, b pair\\n                                if ( (p.first==a_square && p.second==b_square) ||\\n                                     (p.first==b_square && p.second==a_square) )\\n                                { \\n                                    min_area_square= min (min_area_square,  a_square*b_square);\\n                                    break; // one square of same a,b,c length is enough\\n                                }\\n                            }\\n                        }\\n                        // store current triangle anyway\\n                        c2pairs[c_square].push_back({a_square, b_square});\\n                    }\\n\\n                }\\n            }\\n\\n        if (min_area_square==numeric_limits<long>::max() )\\n            return 0.0;\\n        return sqrt ((double)min_area_square);\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003541,
                "title": "c-using-hashmap-with-distance-plus-center-as-key-under-readable-oo-design",
                "content": "```\\nstruct Point {\\n    Point(int x, int y) : x{x}, y{y} {}\\n    Point(const vector<int> &p) : Point(p[0], p[1]) {}\\n    \\n    int dis() {\\n        return x*x+y*y;\\n    }\\n    \\n    uint hash() {\\n        return (uint)x<<16|y;\\n    }\\n    \\n    const int x, y;\\n};\\n\\nstruct Line {\\n    Line(const Point &p1, const Point &p2) : p1{p1}, p2{p2} {}\\n    Line(const vector<int> &p1, const vector<int> &p2) : Line(Point(p1), Point(p2)) {}\\n    \\n    uint64_t hash() {\\n        Point cent(p1.x+p2.x, p1.y+p2.y);\\n        Point vec(p2.x-p1.x, p2.y-p1.y);\\n        return (uint64_t)cent.hash()<<32|vec.dis();\\n    }\\n    \\n    const Point p1, p2;\\n};\\n\\n\\nclass Solution {\\n    int area(const Point& p1, const Point& p2, const Point& p3) {\\n        return abs(p1.x*(p2.y-p3.y)+p2.x*(p3.y-p1.y)+p3.x*(p1.y-p2.y));\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& ps) {\\n        unordered_map<uint64_t, vector<Line>> table;\\n        int ret = INT_MAX;\\n        for(int i=0;i<ps.size();i++)\\n            for(int j=i+1;j<ps.size();j++) {\\n                auto l = Line(ps[i], ps[j]);\\n                table[l.hash()].emplace_back(l);\\n            }\\n        for(auto it:table) {\\n            auto &lines = it.second;\\n            for(int i=0;i<lines.size();i++)\\n                for(int j=i+1;j<lines.size();j++)\\n                    if(auto a = area(lines[i].p1, lines[i].p2, lines[j].p1))\\n                        ret = min(ret, a);\\n        }\\n        return ret == INT_MAX ? 0 : ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Point {\\n    Point(int x, int y) : x{x}, y{y} {}\\n    Point(const vector<int> &p) : Point(p[0], p[1]) {}\\n    \\n    int dis() {\\n        return x*x+y*y;\\n    }\\n    \\n    uint hash() {\\n        return (uint)x<<16|y;\\n    }\\n    \\n    const int x, y;\\n};\\n\\nstruct Line {\\n    Line(const Point &p1, const Point &p2) : p1{p1}, p2{p2} {}\\n    Line(const vector<int> &p1, const vector<int> &p2) : Line(Point(p1), Point(p2)) {}\\n    \\n    uint64_t hash() {\\n        Point cent(p1.x+p2.x, p1.y+p2.y);\\n        Point vec(p2.x-p1.x, p2.y-p1.y);\\n        return (uint64_t)cent.hash()<<32|vec.dis();\\n    }\\n    \\n    const Point p1, p2;\\n};\\n\\n\\nclass Solution {\\n    int area(const Point& p1, const Point& p2, const Point& p3) {\\n        return abs(p1.x*(p2.y-p3.y)+p2.x*(p3.y-p1.y)+p3.x*(p1.y-p2.y));\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& ps) {\\n        unordered_map<uint64_t, vector<Line>> table;\\n        int ret = INT_MAX;\\n        for(int i=0;i<ps.size();i++)\\n            for(int j=i+1;j<ps.size();j++) {\\n                auto l = Line(ps[i], ps[j]);\\n                table[l.hash()].emplace_back(l);\\n            }\\n        for(auto it:table) {\\n            auto &lines = it.second;\\n            for(int i=0;i<lines.size();i++)\\n                for(int j=i+1;j<lines.size();j++)\\n                    if(auto a = area(lines[i].p1, lines[i].p2, lines[j].p1))\\n                        ret = min(ret, a);\\n        }\\n        return ret == INT_MAX ? 0 : ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980904,
                "title": "checking-cyles",
                "content": "I think that this question can also be solved by checking if any cycle is formed between coordinates and storing the area in a set\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 979868,
                "title": "c-simple-solution-hashset",
                "content": "```\\nclass Solution {\\npublic:\\n    struct SimpleHash {\\n    size_t operator()(const std::pair<int, int>& p) const {\\n        return p.first ^ p.second;\\n    }\\n};\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        //check form parallelogram and then check if the angle is 90 degree\\n        unordered_set<pair<int, int>, SimpleHash> allPoints;\\n        for (auto x: points) {\\n            allPoints.insert(make_pair(x[0], x[1]));\\n        }\\n        double ans = DBL_MAX;\\n        for (int i = 0; i < points.size(); i++) {\\n            pair<int, int> p1 = make_pair(points[i][0], points[i][1]);\\n            for (int j = 0; j < points.size(); j++) {\\n                if (i == j) continue;\\n                pair<int, int> p2 = make_pair(points[j][0], points[j][1]);\\n                for (int k = 0; k < points.size(); k++) {\\n                    if (k == i || k == j) continue;\\n                    pair<int, int> p3 = make_pair(points[k][0], points[k][1]);\\n                    pair<int, int> p4 = make_pair((p2.first+p3.first-p1.first), (p2.second+p3.second-p1.second));\\n                    //if can form parallelogram\\n                    if (allPoints.count(p4)) {\\n                        //dot product of (p2 - p1) and (p3 - p1)\\n                        int dot = (p2.first - p1.first) * (p3.first - p1.first) + (p2.second - p1.second) * (p3.second - p1.second);\\n                        if (dot == 0) {\\n                            double a = pow(p2.first - p1.first, 2) + pow(p2.second - p1.second, 2);\\n                            double b = pow(p3.first - p1.first, 2) + pow(p3.second - p1.second, 2);\\n                            double area = sqrt(a * b);\\n                            ans = min(ans, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans < DBL_MAX ? ans : 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct SimpleHash {\\n    size_t operator()(const std::pair<int, int>& p) const {\\n        return p.first ^ p.second;\\n    }\\n};\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        //check form parallelogram and then check if the angle is 90 degree\\n        unordered_set<pair<int, int>, SimpleHash> allPoints;\\n        for (auto x: points) {\\n            allPoints.insert(make_pair(x[0], x[1]));\\n        }\\n        double ans = DBL_MAX;\\n        for (int i = 0; i < points.size(); i++) {\\n            pair<int, int> p1 = make_pair(points[i][0], points[i][1]);\\n            for (int j = 0; j < points.size(); j++) {\\n                if (i == j) continue;\\n                pair<int, int> p2 = make_pair(points[j][0], points[j][1]);\\n                for (int k = 0; k < points.size(); k++) {\\n                    if (k == i || k == j) continue;\\n                    pair<int, int> p3 = make_pair(points[k][0], points[k][1]);\\n                    pair<int, int> p4 = make_pair((p2.first+p3.first-p1.first), (p2.second+p3.second-p1.second));\\n                    //if can form parallelogram\\n                    if (allPoints.count(p4)) {\\n                        //dot product of (p2 - p1) and (p3 - p1)\\n                        int dot = (p2.first - p1.first) * (p3.first - p1.first) + (p2.second - p1.second) * (p3.second - p1.second);\\n                        if (dot == 0) {\\n                            double a = pow(p2.first - p1.first, 2) + pow(p2.second - p1.second, 2);\\n                            double b = pow(p3.first - p1.first, 2) + pow(p3.second - p1.second, 2);\\n                            double area = sqrt(a * b);\\n                            ans = min(ans, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans < DBL_MAX ? ans : 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960164,
                "title": "python3-intersecting-diagonals-math",
                "content": "```\\nfrom typing import List, Tuple\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        # key: for rect, diagonals from corners will:\\n        # 1) intersect at common midpoint\\n        # 2) and be of equal length\\n\\n        # going through and comparing two points:\\n        # calculate distance between points (hello math)\\n        # calculate midpoint between points (hello math)\\n        # store in dict {(mid, dist) : [(pairs)]}\\n\\n        # then go through dict keys with len > 1\\n        # compare points against each other,\\n        # calc distance between pair1 point1 and pair2 both points\\n        # product of these distances == area\\n        # track for min area\\n        # O(N^2) time and O(N) space\\n\\n        def get_dist(p1, p2) -> float:\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            return (abs(x1-x2)**2 + abs(y1-y2)**2)**0.5\\n\\n        def get_mid(p1, p2) -> Tuple[float, float]:\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            return ((x1+x2)/2, (y1+y2)/2)\\n\\n        d = defaultdict(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                mid = get_mid(points[i], points[j])\\n                dist = get_dist(points[i], points[j])\\n                d[(mid, dist)].append( (points[i], points[j]) )\\n\\n        res = float(\"inf\")\\n        for k in d:\\n            if len(d[k]) > 1:\\n                for i in range(len(d[k])):\\n                    for j in range(i+1, len(d[k])):\\n                        p1, p2 = d[k][i]\\n                        p3, p4 = d[k][j]\\n\\n                        side1 = get_dist(p1,p3)\\n                        side2 = get_dist(p1,p4)\\n                        res = min(res, side1 * side2)\\n\\n        return res if res < float(\"inf\") else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List, Tuple\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        # key: for rect, diagonals from corners will:\\n        # 1) intersect at common midpoint\\n        # 2) and be of equal length\\n\\n        # going through and comparing two points:\\n        # calculate distance between points (hello math)\\n        # calculate midpoint between points (hello math)\\n        # store in dict {(mid, dist) : [(pairs)]}\\n\\n        # then go through dict keys with len > 1\\n        # compare points against each other,\\n        # calc distance between pair1 point1 and pair2 both points\\n        # product of these distances == area\\n        # track for min area\\n        # O(N^2) time and O(N) space\\n\\n        def get_dist(p1, p2) -> float:\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            return (abs(x1-x2)**2 + abs(y1-y2)**2)**0.5\\n\\n        def get_mid(p1, p2) -> Tuple[float, float]:\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            return ((x1+x2)/2, (y1+y2)/2)\\n\\n        d = defaultdict(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                mid = get_mid(points[i], points[j])\\n                dist = get_dist(points[i], points[j])\\n                d[(mid, dist)].append( (points[i], points[j]) )\\n\\n        res = float(\"inf\")\\n        for k in d:\\n            if len(d[k]) > 1:\\n                for i in range(len(d[k])):\\n                    for j in range(i+1, len(d[k])):\\n                        p1, p2 = d[k][i]\\n                        p3, p4 = d[k][j]\\n\\n                        side1 = get_dist(p1,p3)\\n                        side2 = get_dist(p1,p4)\\n                        res = min(res, side1 * side2)\\n\\n        return res if res < float(\"inf\") else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958965,
                "title": "python-o-n-2-solution-98-17",
                "content": "- Find each pair of nodes, calculate `(x1+x2), (y1+y2)` as key and add this `point pair` to dictionary `groups`.\\n- Eventually in each entry in this dictionary, we have a list of `point pairs`, and any pair of `point pairs` can form a parallelogram.\\n- Then we check if the parallelogram is rectangle by checking if orthogonal.\\n- I thinks this is `O(n^2)` because:\\n\\t- First looping over the points is definitely `O(n^2)`\\n\\t- Then for the looping over `groups` part, worst case would be every `point pair` falls into the same group (i.e. any pair of point pairs can form a parallelogram), in which case the list length would be `n/2`. So looping over pairs of `point pairs` is still `O(n^2)`\\n\\t\\t- The reason it\\'s `n/2` is because if all points are inside the same `group`, any point can only appear in one `point pair` (since the group key `(x1+x2), (y1+y2)` is fixed)\\n\\t\\t- **UPDATE**: ok... now I think about it the worst case should be every 2 `point pairs` fall into different groups.. Could somebody help me explain what\\'s the correct way to calculate the overall complexity\\n\\n\\n---\\n\\n   ```\\n   class Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n\\t\\n        if not points:\\n            return 0\\n     \\n        groups = dict()\\n        minarea = float(\\'inf\\')\\n        area = lambda x1,y1,x2,y2,x3,y3: (((x1-x3)**2 + (y1-y3)**2) * ((x2-x3)**2 + (y2-y3)**2)) ** (1/2)\\n        orthogonal = lambda x1,y1,x2,y2,x3,y3: (x1-x3) * (x2-x3) + (y1-y3) * (y2-y3) == 0\\n     \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                (x1, y1), (x2, y2) = points[i], points[j]\\n                xsum, ysum = x1 + x2, y1 + y2\\n                if (xsum, ysum) not in groups:\\n                    groups[(xsum, ysum)] = []\\n                groups[(xsum, ysum)].append((x1, y1, x2, y2))\\n     \\n        for group in groups.values():\\n            for i in range(len(group)):\\n                for j in range(i+1, len(group)):\\n                    (x1, y1, x2, y2), (x3, y3, _, _) = group[i], group[j]\\n                    if orthogonal(x1,y1,x2,y2,x3,y3):\\n                        minarea = min(minarea, area(x1,y1,x2,y2,x3,y3))\\n\\n        return minarea if minarea != float(\\'inf\\') else 0",
                "solutionTags": [],
                "code": "- Find each pair of nodes, calculate `(x1+x2), (y1+y2)` as key and add this `point pair` to dictionary `groups`.\\n- Eventually in each entry in this dictionary, we have a list of `point pairs`, and any pair of `point pairs` can form a parallelogram.\\n- Then we check if the parallelogram is rectangle by checking if orthogonal.\\n- I thinks this is `O(n^2)` because:\\n\\t- First looping over the points is definitely `O(n^2)`\\n\\t- Then for the looping over `groups` part, worst case would be every `point pair` falls into the same group (i.e. any pair of point pairs can form a parallelogram), in which case the list length would be `n/2`. So looping over pairs of `point pairs` is still `O(n^2)`\\n\\t\\t- The reason it\\'s `n/2` is because if all points are inside the same `group`, any point can only appear in one `point pair` (since the group key `(x1+x2), (y1+y2)` is fixed)\\n\\t\\t- **UPDATE**: ok... now I think about it the worst case should be every 2 `point pairs` fall into different groups.. Could somebody help me explain what\\'s the correct way to calculate the overall complexity\\n\\n\\n---\\n\\n   ```\\n   class Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n\\t\\n        if not points:\\n            return 0\\n     \\n        groups = dict()\\n        minarea = float(\\'inf\\')\\n        area = lambda x1,y1,x2,y2,x3,y3: (((x1-x3)**2 + (y1-y3)**2) * ((x2-x3)**2 + (y2-y3)**2)) ** (1/2)\\n        orthogonal = lambda x1,y1,x2,y2,x3,y3: (x1-x3) * (x2-x3) + (y1-y3) * (y2-y3) == 0\\n     \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                (x1, y1), (x2, y2) = points[i], points[j]\\n                xsum, ysum = x1 + x2, y1 + y2\\n                if (xsum, ysum) not in groups:\\n                    groups[(xsum, ysum)] = []\\n                groups[(xsum, ysum)].append((x1, y1, x2, y2))\\n     \\n        for group in groups.values():\\n            for i in range(len(group)):\\n                for j in range(i+1, len(group)):\\n                    (x1, y1, x2, y2), (x3, y3, _, _) = group[i], group[j]\\n                    if orthogonal(x1,y1,x2,y2,x3,y3):\\n                        minarea = min(minarea, area(x1,y1,x2,y2,x3,y3))\\n\\n        return minarea if minarea != float(\\'inf\\') else 0",
                "codeTag": "Java"
            },
            {
                "id": 948439,
                "title": "swift-o-n-3-solution-using-math-vectors",
                "content": "<img src=\"https://assets.leetcode.com/users/images/b93e8a04-87c2-4fe9-bce6-1e09e54fd8f4_1606296386.2932158.png\" height=200 />\\n\\n```swift\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        guard points.count >= 4 else { return 0 }\\n        let vectors = points.map { Vector([0, 0], $0) }\\n        var set = Set(vectors), res = 0 as Double\\n        for OA in vectors { for OB in vectors where OA != OB { for OC in vectors where OC != OA && OC != OB {\\n            let AB = OB - OA // vector AB = A->B\\n            let AC = OC - OA // vector AC = A->C\\n            if AB * AC != 0 { continue } // AB \\u22A5 AC\\n            let OD = OB + AC // OD = OB + vector AC, so that ABCD forms a rect\\n            if !set.contains(OD) { continue }\\n            let s = AB.length * AC.length  // |AB|*|AC|\\n            res = (res == 0) ? s : min(res, s)\\n        }}}\\n        return res\\n    }\\n\\n    private struct Vector: Hashable {\\n        let x: Int, y: Int\\n        init(_ from: [Int], _ to: [Int]) {\\n            x = to[0] - from[0]\\n            y = to[1] - from[1]\\n        }\\n        static func +(lhs: Vector, rhs: Vector) -> Vector {\\n            return Vector([0, 0], [lhs.x + rhs.x, lhs.y + rhs.y])\\n        }\\n        static func -(lhs: Vector, rhs: Vector) -> Vector {\\n            return Vector([0, 0], [lhs.x - rhs.x, lhs.y - rhs.y])\\n        }\\n        static func *(lhs: Vector, rhs: Vector) -> Int {\\n            return lhs.x * rhs.x + lhs.y * rhs.y\\n        }\\n        var length: Double {\\n            return sqrt(Double(x * x + y * y))\\n        }\\n    }\\n}\\n```\\n\\nOr if you don\\'t want to define a struct:\\n```swift\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        guard points.count >= 4 else { return 0 }\\n        var set = Set(points), res = 0 as Double\\n        for p1 in points { for p2 in points where p1 != p2 { for p3 in points where p3 != p1 && p3 != p2 {\\n            let v1 = [p2[0] - p1[0], p2[1] - p1[1]] // v1 = p1->p2\\n            let v2 = [p3[0] - p1[0], p3[1] - p1[1]] // v2 = p1->p3\\n            if v1[0] * v2[0] + v1[1] * v2[1] != 0 { continue } // v1 & v2: perpendicular\\n            let p4 = [p2[0] + v2[0], p2[1] + v2[1]] // p2 + v2\\n            if !set.contains(p4) { continue }\\n            let s = sqrt(\\n                Double(v1[0] * v1[0] + v1[1] * v1[1]) \\n                * Double(v2[0] * v2[0] + v2[1] * v2[1])\\n            )  // |v1|*|v2|\\n            if res == 0 {\\n                res = s\\n            } else {\\n                res = min(res, s)\\n            }\\n        }}}\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        guard points.count >= 4 else { return 0 }\\n        let vectors = points.map { Vector([0, 0], $0) }\\n        var set = Set(vectors), res = 0 as Double\\n        for OA in vectors { for OB in vectors where OA != OB { for OC in vectors where OC != OA && OC != OB {\\n            let AB = OB - OA // vector AB = A->B\\n            let AC = OC - OA // vector AC = A->C\\n            if AB * AC != 0 { continue } // AB \\u22A5 AC\\n            let OD = OB + AC // OD = OB + vector AC, so that ABCD forms a rect\\n            if !set.contains(OD) { continue }\\n            let s = AB.length * AC.length  // |AB|*|AC|\\n            res = (res == 0) ? s : min(res, s)\\n        }}}\\n        return res\\n    }\\n\\n    private struct Vector: Hashable {\\n        let x: Int, y: Int\\n        init(_ from: [Int], _ to: [Int]) {\\n            x = to[0] - from[0]\\n            y = to[1] - from[1]\\n        }\\n        static func +(lhs: Vector, rhs: Vector) -> Vector {\\n            return Vector([0, 0], [lhs.x + rhs.x, lhs.y + rhs.y])\\n        }\\n        static func -(lhs: Vector, rhs: Vector) -> Vector {\\n            return Vector([0, 0], [lhs.x - rhs.x, lhs.y - rhs.y])\\n        }\\n        static func *(lhs: Vector, rhs: Vector) -> Int {\\n            return lhs.x * rhs.x + lhs.y * rhs.y\\n        }\\n        var length: Double {\\n            return sqrt(Double(x * x + y * y))\\n        }\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        guard points.count >= 4 else { return 0 }\\n        var set = Set(points), res = 0 as Double\\n        for p1 in points { for p2 in points where p1 != p2 { for p3 in points where p3 != p1 && p3 != p2 {\\n            let v1 = [p2[0] - p1[0], p2[1] - p1[1]] // v1 = p1->p2\\n            let v2 = [p3[0] - p1[0], p3[1] - p1[1]] // v2 = p1->p3\\n            if v1[0] * v2[0] + v1[1] * v2[1] != 0 { continue } // v1 & v2: perpendicular\\n            let p4 = [p2[0] + v2[0], p2[1] + v2[1]] // p2 + v2\\n            if !set.contains(p4) { continue }\\n            let s = sqrt(\\n                Double(v1[0] * v1[0] + v1[1] * v1[1]) \\n                * Double(v2[0] * v2[0] + v2[1] * v2[1])\\n            )  // |v1|*|v2|\\n            if res == 0 {\\n                res = s\\n            } else {\\n                res = min(res, s)\\n            }\\n        }}}\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903402,
                "title": "simple-solution-to-find-diagonal",
                "content": "```python\\nfrom collections import defaultdict\\nfrom math import sqrt\\n\\ndef distance(p1, p2):\\n    return sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        mem = defaultdict(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                p1, p2 = points[i], points[j]\\n                d = distance(p1, p2)\\n                mid = (p2[0] + p1[0]) / 2, (p2[1] + p1[1]) / 2\\n                mem[mid, d].append((p1, p2))\\n        min_area = float(\\'inf\\')\\n        for pairs in mem.values():\\n            for i in range(len(pairs)):\\n                for j in range(i+1, len(pairs)):\\n                    (p1, p2), (p3, p4) = pairs[i], pairs[j]\\n                    new_area = distance(p1, p3) * distance(p1, p4)\\n                    min_area = min(min_area, new_area)\\n        return min_area if min_area < float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\nfrom math import sqrt\\n\\ndef distance(p1, p2):\\n    return sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        mem = defaultdict(list)\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                p1, p2 = points[i], points[j]\\n                d = distance(p1, p2)\\n                mid = (p2[0] + p1[0]) / 2, (p2[1] + p1[1]) / 2\\n                mem[mid, d].append((p1, p2))\\n        min_area = float(\\'inf\\')\\n        for pairs in mem.values():\\n            for i in range(len(pairs)):\\n                for j in range(i+1, len(pairs)):\\n                    (p1, p2), (p3, p4) = pairs[i], pairs[j]\\n                    new_area = distance(p1, p3) * distance(p1, p4)\\n                    min_area = min(min_area, new_area)\\n        return min_area if min_area < float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869489,
                "title": "c-simple-intuitive-code-with-explanation",
                "content": "```\\n// Bizzare interview question\\n// Main Idea: All points in a rectagle are equidistant from the diagonal interesection\\n// Find the center between each pair of points and use that as the key (diagonal interection as key i.e. dist + p2x-p1x/2, p2y-p1y/2)\\n// Any 2 points from all points which are indexed by same key can form a rectangle.\\n// Itereate thru all pair of points in each group of points indexed by the key\\n// and get the min aray\\npublic class Solution {\\n    public double MinAreaFreeRect(int[][] points) {\\n        var row = points.Length;\\n        var col = row > 0 ? points[0].Length : 0;\\n        \\n        if(row == 0 || col == 0)\\n            return 0;\\n        \\n        var pointsGroup = new Dictionary<string, List<(int[] Point1, int[] Point2)>>();\\n        for(var i = 0; i < row; i++)\\n        {\\n            for(var j = i + 1; j < row; j++)\\n            {\\n                var p1 = points[i];\\n                var p2 = points[j];\\n                \\n                var dist = (p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]);\\n                var centerX = (p2[0] + p1[0]) / 2.0;\\n                var centerY = (p2[1] + p1[1]) / 2.0;\\n                \\n                var key = dist + \":\" + centerX + \"-\" + centerY;\\n                if(!pointsGroup.ContainsKey(key))\\n                {\\n                    pointsGroup.Add(key, new List<(int[], int[])>(){(p2, p1)});\\n                }\\n                else\\n                {\\n                    pointsGroup[key].Add((p2, p1));\\n                }\\n            }\\n        }\\n        \\n        var minResult = double.MaxValue;\\n        // A group contains all pairs of points with the same distance and middle point, any two of these pairs form a rectangle with each other.\\n        // We iterate through all rectangles that can be formed with the given points, we compute the area of each rectangle and maintain the min area.\\n        \\n        foreach(var allPoints in pointsGroup.Values)\\n        {\\n            for(var i = 0; i < allPoints.Count; i++)\\n            {\\n                for(var j = i + 1; j < allPoints.Count; j++)\\n                {\\n                    var p1 = allPoints[i].Point1;\\n                    var p2 = allPoints[i].Point2;\\n                    var p3 = allPoints[j].Point1;\\n                    \\n                    double firstSidelen = Math.Sqrt((p1[0] - p3[0]) * (p1[0] - p3[0]) + (p1[1] - p3[1]) * (p1[1] - p3[1]));\\n                    double secondSideLen = Math.Sqrt((p2[0] - p3[0]) * (p2[0] - p3[0]) + (p2[1] - p3[1]) * (p2[1] - p3[1]));\\n                    double area = firstSidelen * secondSideLen;\\n                    minResult = Math.Min(minResult, area);\\n                }\\n            }\\n        }\\n     \\n        return minResult == double.MaxValue ? 0 : minResult;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Bizzare interview question\\n// Main Idea: All points in a rectagle are equidistant from the diagonal interesection\\n// Find the center between each pair of points and use that as the key (diagonal interection as key i.e. dist + p2x-p1x/2, p2y-p1y/2)\\n// Any 2 points from all points which are indexed by same key can form a rectangle.\\n// Itereate thru all pair of points in each group of points indexed by the key\\n// and get the min aray\\npublic class Solution {\\n    public double MinAreaFreeRect(int[][] points) {\\n        var row = points.Length;\\n        var col = row > 0 ? points[0].Length : 0;\\n        \\n        if(row == 0 || col == 0)\\n            return 0;\\n        \\n        var pointsGroup = new Dictionary<string, List<(int[] Point1, int[] Point2)>>();\\n        for(var i = 0; i < row; i++)\\n        {\\n            for(var j = i + 1; j < row; j++)\\n            {\\n                var p1 = points[i];\\n                var p2 = points[j];\\n                \\n                var dist = (p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]);\\n                var centerX = (p2[0] + p1[0]) / 2.0;\\n                var centerY = (p2[1] + p1[1]) / 2.0;\\n                \\n                var key = dist + \":\" + centerX + \"-\" + centerY;\\n                if(!pointsGroup.ContainsKey(key))\\n                {\\n                    pointsGroup.Add(key, new List<(int[], int[])>(){(p2, p1)});\\n                }\\n                else\\n                {\\n                    pointsGroup[key].Add((p2, p1));\\n                }\\n            }\\n        }\\n        \\n        var minResult = double.MaxValue;\\n        // A group contains all pairs of points with the same distance and middle point, any two of these pairs form a rectangle with each other.\\n        // We iterate through all rectangles that can be formed with the given points, we compute the area of each rectangle and maintain the min area.\\n        \\n        foreach(var allPoints in pointsGroup.Values)\\n        {\\n            for(var i = 0; i < allPoints.Count; i++)\\n            {\\n                for(var j = i + 1; j < allPoints.Count; j++)\\n                {\\n                    var p1 = allPoints[i].Point1;\\n                    var p2 = allPoints[i].Point2;\\n                    var p3 = allPoints[j].Point1;\\n                    \\n                    double firstSidelen = Math.Sqrt((p1[0] - p3[0]) * (p1[0] - p3[0]) + (p1[1] - p3[1]) * (p1[1] - p3[1]));\\n                    double secondSideLen = Math.Sqrt((p2[0] - p3[0]) * (p2[0] - p3[0]) + (p2[1] - p3[1]) * (p2[1] - p3[1]));\\n                    double area = firstSidelen * secondSideLen;\\n                    minResult = Math.Min(minResult, area);\\n                }\\n            }\\n        }\\n     \\n        return minResult == double.MaxValue ? 0 : minResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829244,
                "title": "straightforward-c-o-n-3",
                "content": "Iterating over the triples this way, with `i < j < k` and trying to set the vertex at `i`, `j`, and `k`, rather than trying all triples `(i, j, k)` where `i`, `j`, and `k` are distinct (like in [@wangzi6147\\'s solution](https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/208470/Java-O(N3)-bruteforce)), seems to make the solution somewhat faster (160ms to 94ms).\\n\\nOf course not faster than the O(N^2) solution, but it is fairly straightforward and easy to understand.\\n\\nBeats 70% time, 90% memory.\\n\\n```cpp\\nint dotProd(int p1, int p2, int p3, vector<vector<int>> &points) {\\n\\t// calculate dot product: x1 * x2 + y1 * y2, make sure it\\'s equal to zero\\n\\treturn (points[p2][0] - points[p1][0]) * (points[p3][0] - points[p1][0])\\n\\t\\t+ (points[p2][1] - points[p1][1]) * (points[p3][1] - points[p1][1]);\\n}\\n\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tint i, j, k, len = points.size(), p1, p2, p3, x1, x2, y1, y2;\\n\\tdouble area, minArea = -1;\\n\\n\\t// save all (x, y) pairs (encoded into a single integer) in a hashset for quick searches\\n\\tunordered_set<int> ps(0);\\n\\tfor (i = 0; i < len; ++i)\\n\\t\\tps.insert(points[i][0] * 40000 + points[i][1]);\\n\\n\\t// cubic search for rectangles; loop over every triple (i, j, k), where i > j > k\\n\\tfor (i = 2; i < len; ++i) {\\n\\t\\tfor (j = 1; j < i; ++j) {\\n\\t\\t\\tfor (k = 0; k < j; ++k) {\\n\\t\\t\\t\\t// check if JIK or IJK or IKJ is a right angle by calculating the dot\\n\\t\\t\\t\\t// product of two vectors and checking if it\\'s zero; if one is a right angle,\\n\\t\\t\\t\\t// set the vertex point to be p1; otherwise no valid right angle, continue\\n\\t\\t\\t\\tif (dotProd(p1 = i, p2 = j, p3 = k, points)\\n\\t\\t\\t\\t   && dotProd(p1 = j, p2 = i, p3 = k, points)\\n\\t\\t\\t\\t   && dotProd(p1 = k, p2 = i, p3 = j, points))\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tx1 = points[p2][0] - points[p1][0];\\n\\t\\t\\t\\tx2 = points[p3][0] - points[p1][0];\\n\\t\\t\\t\\ty1 = points[p2][1] - points[p1][1];\\n\\t\\t\\t\\ty2 = points[p3][1] - points[p1][1];\\n\\n\\t\\t\\t\\t// area is sqrt((x1^2 + y1^2) * (x2^2 + y2^2))\\n\\t\\t\\t\\tarea = sqrt(((unsigned long) x1*x1 + y1*y1) * (x2*x2 + y2*y2));\\n\\t\\t\\t\\tif (minArea != -1 && area >= minArea)\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t// try to complete this rectangle: fourth point at (p1.x + x1 + x2, p1.y + y1 + y2)\\n\\t\\t\\t\\t// hashset makes searching for the fourth point roughly O(1)\\n\\t\\t\\t\\tif (ps.count((points[p1][0] + x1 + x2) * 40000 + (points[p1][1] + y1 + y2)))\\n\\t\\t\\t\\t\\tminArea = area;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn minArea == -1 ? 0 : minArea;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dotProd(int p1, int p2, int p3, vector<vector<int>> &points) {\\n\\t// calculate dot product: x1 * x2 + y1 * y2, make sure it\\'s equal to zero\\n\\treturn (points[p2][0] - points[p1][0]) * (points[p3][0] - points[p1][0])\\n\\t\\t+ (points[p2][1] - points[p1][1]) * (points[p3][1] - points[p1][1]);\\n}\\n\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tint i, j, k, len = points.size(), p1, p2, p3, x1, x2, y1, y2;\\n\\tdouble area, minArea = -1;\\n\\n\\t// save all (x, y) pairs (encoded into a single integer) in a hashset for quick searches\\n\\tunordered_set<int> ps(0);\\n\\tfor (i = 0; i < len; ++i)\\n\\t\\tps.insert(points[i][0] * 40000 + points[i][1]);\\n\\n\\t// cubic search for rectangles; loop over every triple (i, j, k), where i > j > k\\n\\tfor (i = 2; i < len; ++i) {\\n\\t\\tfor (j = 1; j < i; ++j) {\\n\\t\\t\\tfor (k = 0; k < j; ++k) {\\n\\t\\t\\t\\t// check if JIK or IJK or IKJ is a right angle by calculating the dot\\n\\t\\t\\t\\t// product of two vectors and checking if it\\'s zero; if one is a right angle,\\n\\t\\t\\t\\t// set the vertex point to be p1; otherwise no valid right angle, continue\\n\\t\\t\\t\\tif (dotProd(p1 = i, p2 = j, p3 = k, points)\\n\\t\\t\\t\\t   && dotProd(p1 = j, p2 = i, p3 = k, points)\\n\\t\\t\\t\\t   && dotProd(p1 = k, p2 = i, p3 = j, points))\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tx1 = points[p2][0] - points[p1][0];\\n\\t\\t\\t\\tx2 = points[p3][0] - points[p1][0];\\n\\t\\t\\t\\ty1 = points[p2][1] - points[p1][1];\\n\\t\\t\\t\\ty2 = points[p3][1] - points[p1][1];\\n\\n\\t\\t\\t\\t// area is sqrt((x1^2 + y1^2) * (x2^2 + y2^2))\\n\\t\\t\\t\\tarea = sqrt(((unsigned long) x1*x1 + y1*y1) * (x2*x2 + y2*y2));\\n\\t\\t\\t\\tif (minArea != -1 && area >= minArea)\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t// try to complete this rectangle: fourth point at (p1.x + x1 + x2, p1.y + y1 + y2)\\n\\t\\t\\t\\t// hashset makes searching for the fourth point roughly O(1)\\n\\t\\t\\t\\tif (ps.count((points[p1][0] + x1 + x2) * 40000 + (points[p1][1] + y1 + y2)))\\n\\t\\t\\t\\t\\tminArea = area;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn minArea == -1 ? 0 : minArea;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823346,
                "title": "go-group-by-center-and-length",
                "content": "```go\\nfunc minAreaFreeRect(points [][]int) float64 {\\n    // group pointer pairs by key [3]int{center_x*2, center_y*2, dis2}\\n    var centers = make(map[[3]int][][2]int)\\n    \\n    for i, p1:= range points {\\n        for j := i+1; j < len(points); j++ {\\n            var p2 = points[j]\\n            \\n            var cp = [3]int{p1[0]+p2[0], p1[1]+p2[1], dis2(p1, p2)}\\n            \\n            var v = centers[cp]\\n            v = append(v, [2]int{i, j})\\n            centers[cp] = v\\n        }\\n    }\\n    \\n    var ret = 0\\n    \\n    for _, l := range centers {\\n        for i := 0; i < len(l); i++ {\\n            for j := i+1; j < len(l); j++ {\\n                var p0, p2, p3 = points[l[i][0]], points[l[j][0]], points[l[j][1]]\\n                var area2 = dis2(p0, p2) * dis2(p0, p3)\\n                if ret == 0 || ret > area2 {\\n                    ret = area2\\n                }\\n            }\\n        }\\n    }\\n    \\n    return math.Sqrt(float64(ret))\\n}\\n\\nfunc dis2(p0, p1 []int) int {\\n    var dx = p0[0] - p1[0]\\n    var dy = p0[1] - p1[1]\\n    return dx*dx + dy*dy\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc minAreaFreeRect(points [][]int) float64 {\\n    // group pointer pairs by key [3]int{center_x*2, center_y*2, dis2}\\n    var centers = make(map[[3]int][][2]int)\\n    \\n    for i, p1:= range points {\\n        for j := i+1; j < len(points); j++ {\\n            var p2 = points[j]\\n            \\n            var cp = [3]int{p1[0]+p2[0], p1[1]+p2[1], dis2(p1, p2)}\\n            \\n            var v = centers[cp]\\n            v = append(v, [2]int{i, j})\\n            centers[cp] = v\\n        }\\n    }\\n    \\n    var ret = 0\\n    \\n    for _, l := range centers {\\n        for i := 0; i < len(l); i++ {\\n            for j := i+1; j < len(l); j++ {\\n                var p0, p2, p3 = points[l[i][0]], points[l[j][0]], points[l[j][1]]\\n                var area2 = dis2(p0, p2) * dis2(p0, p3)\\n                if ret == 0 || ret > area2 {\\n                    ret = area2\\n                }\\n            }\\n        }\\n    }\\n    \\n    return math.Sqrt(float64(ret))\\n}\\n\\nfunc dis2(p0, p1 []int) int {\\n    var dx = p0[0] - p1[0]\\n    var dy = p0[1] - p1[1]\\n    return dx*dx + dy*dy\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788054,
                "title": "java-o-n-2-average-time-complexity",
                "content": "Two diagonals of rectangle have equal length and their intersection point is the middle of both diagonals.\\nso we  need to check all the point pairs one time.\\n\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        double s = Integer.MAX_VALUE;\\n        for(int i = 0; i<n; i++){\\n            for(int j = i+1; j<n; j++){\\n                double x = ((double)points[i][0]+points[j][0])/2;\\n                double y = ((double)points[i][1]+points[j][1])/2;\\n                double l = Math.pow(points[i][0]-points[j][0],2) + Math.pow(points[i][1]-points[j][1],2);\\n                String key = l + \" \" + x + \" \" + y;\\n                if(map.containsKey(key)){\\n                    for(Integer z : map.get(key)){\\n                        s = Math.min(s, calcSquare(i,j,z, points));\\n                    }\\n                }\\n                map.computeIfAbsent(key, nil->new ArrayList<>()).add(i);\\n            }\\n        }\\n        return s == Integer.MAX_VALUE ? 0 : s;\\n    }\\n    \\n    private double calcSquare(int x, int y, int z, int[][] points){\\n        double l = Math.pow(Math.pow(points[x][0]-points[z][0],2)+Math.pow(points[x][1] - points[z][1],2),0.5);\\n        double w = Math.pow(Math.pow(points[y][0]-points[z][0],2)+Math.pow(points[y][1] - points[z][1],2),0.5);\\n        return l*w;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        int n = points.length;\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        double s = Integer.MAX_VALUE;\\n        for(int i = 0; i<n; i++){\\n            for(int j = i+1; j<n; j++){\\n                double x = ((double)points[i][0]+points[j][0])/2;\\n                double y = ((double)points[i][1]+points[j][1])/2;\\n                double l = Math.pow(points[i][0]-points[j][0],2) + Math.pow(points[i][1]-points[j][1],2);\\n                String key = l + \" \" + x + \" \" + y;\\n                if(map.containsKey(key)){\\n                    for(Integer z : map.get(key)){\\n                        s = Math.min(s, calcSquare(i,j,z, points));\\n                    }\\n                }\\n                map.computeIfAbsent(key, nil->new ArrayList<>()).add(i);\\n            }\\n        }\\n        return s == Integer.MAX_VALUE ? 0 : s;\\n    }\\n    \\n    private double calcSquare(int x, int y, int z, int[][] points){\\n        double l = Math.pow(Math.pow(points[x][0]-points[z][0],2)+Math.pow(points[x][1] - points[z][1],2),0.5);\\n        double w = Math.pow(Math.pow(points[y][0]-points[z][0],2)+Math.pow(points[y][1] - points[z][1],2),0.5);\\n        return l*w;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786415,
                "title": "possible-wrong-test-case",
                "content": "For test case: [[21096,38753],[2304,26303],[3969,29792],[33983,32544],[15376,38207],[15512,38241],[1232,20799],[37696,13697],[30465,4400],[20799,38768],[8100,34535],[38785,20000],[1241,20988],[38207,24624],[1300,21785],[38768,20799],[38241,24488],[18215,38700],[1793,24624],[28127,3064],[36575,28840],[33983,7456],[4340,30375],[37340,12775],[26201,2268],[27225,37340],[3816,29537],[1759,24488],[11873,36936],[37017,12044],[28840,36575],[12044,37017],[4972,31271],[38753,21096],[35028,31271],[7456,33983],[38700,21785],[36936,11873],[36031,29792],[35028,8729],[20000,38785],[1247,21096],[30375,35660],[20799,1232],[36184,29537],[1575,23660],[20000,1215],[18904,38753],[34535,31900],[29792,36031]]\\n\\nThe expected output is 209460264.00000, but we can get a smaller rectangle by using these 4 points from the input [[28127,3064], [4972,31271], [35028,8729], [11873,36936]]. The min area should be 30018430.00000.\\n\\nIf you just give [[28127,3064], [4972,31271], [35028,8729], [11873,36936]] as input to formal solution, it will return 30018430.00000.\\n\\nAm I missing something?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 768415,
                "title": "c-geometry",
                "content": "```c++\\nclass Solution {\\n    string getKey(int &x,int &y)\\n    {\\n        return to_string(x)+\"_\"+to_string(y);\\n    }\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans=0;\\n        unordered_map<string,int> f;\\n        for(auto it:points)\\n            f[getKey(it[0],it[1])]=1;\\n        int n=points.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    int x1=points[i][0],y1=points[i][1];\\n                    int x2=points[j][0],y2=points[j][1];\\n                    int x3=points[k][0],y3=points[k][1];\\n                    if(((x2-x1)*(x3-x1)+(y2-y1)*(y3-y1))!=0)continue;\\n                    int x4=x3+x2-x1,y4=y3+y2-y1;\\n                    if(f.count(getKey(x4,y4))==0)continue;\\n                    double l=pow(pow(x2-x1,2)+pow(y2-y1,2),0.5);\\n                    double w=pow(pow(x3-x1,2)+pow(y3-y1,2),0.5);\\n                    double area=l*w;\\n                    if(ans==0)ans=area;\\n                    else if(area<ans)ans=area;\\n                }\\n            }\\n        }\\n        return ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\n    string getKey(int &x,int &y)\\n    {\\n        return to_string(x)+\"_\"+to_string(y);\\n    }\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        double ans=0;\\n        unordered_map<string,int> f;\\n        for(auto it:points)\\n            f[getKey(it[0],it[1])]=1;\\n        int n=points.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    int x1=points[i][0],y1=points[i][1];\\n                    int x2=points[j][0],y2=points[j][1];\\n                    int x3=points[k][0],y3=points[k][1];\\n                    if(((x2-x1)*(x3-x1)+(y2-y1)*(y3-y1))!=0)continue;\\n                    int x4=x3+x2-x1,y4=y3+y2-y1;\\n                    if(f.count(getKey(x4,y4))==0)continue;\\n                    double l=pow(pow(x2-x1,2)+pow(y2-y1,2),0.5);\\n                    double w=pow(pow(x3-x1,2)+pow(y3-y1,2),0.5);\\n                    double area=l*w;\\n                    if(ans==0)ans=area;\\n                    else if(area<ans)ans=area;\\n                }\\n            }\\n        }\\n        return ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760954,
                "title": "python-using-vectors-sketches-and-explanation-included",
                "content": "```\\n\\t\\t\\t\\t\\t\\t   p4\\n\\t\\t\\t\\t\\t\\t   /\\\\\\n\\t  p1   p3          p1 /  \\\\ p3\\n\\t   \\\\  /               \\\\  /\\n    v12 \\\\/ v23             \\\\/\\n\\t\\tp2                 p2\\n```\\n\\nApproach to finding a rectangle:\\n\\n1. Pick a point ```p2```\\n2. For all possible points ```p1``` and ```p3``` check if the vector between ```(p1,p2)``` and the vector between ```(p2,p3)``` are perpendicular (orthogonal).  If they are not perpendicular, then this cannot be the corner of a rectangle.  \\n3. If the two vectors ```v12``` and ```v23``` are orthogonal, check if area of the rectangle they make is smaller than the smallest rectangle found so far (```smallest_rectangle```)\\n4. If it is, then check if ```p4``` exists in ```points_set```, converted to a set for O(1) lookup times.\\n\\n```python\\ndef minAreaFreeRect(self, points: List[List[int]]) -> float:\\n\\n\\tdef is_orthogonal(v12, v23) -> bool:\\n\\t\\t\\'\\'\\'\\n\\t\\treturns True if vectors v12 and v23 are orthogonal\\n\\t\\tvector v12 connects points p1 and p2\\n\\t\\tvector v23 connects points p2 and p3\\n\\n\\t\\t p1      p3\\n\\t\\t   \\\\    /\\n\\t\\tv12 \\\\  / v23\\n\\t\\t\\t \\\\/ \\n\\t\\t\\t p2\\n\\t\\t\\'\\'\\'\\n\\t\\treturn not v12[0]*v23[0]+v12[1]*v23[1]\\n\\n\\tdef fourth_point(p2, v12, v23) -> tuple:\\n\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t\\t\\t\\t   p4\\n\\t\\t\\t\\t\\t\\t\\t   /\\\\\\n\\t\\t  p1   p3          p1 /  \\\\ p3\\n\\t\\t   \\\\  /               \\\\  /\\n\\t\\t\\t\\\\/                 \\\\/\\n\\t\\t\\tp2                 p2\\n\\n\\t\\tp2 is the shared point between two orthogonal vectors\\n\\n\\t\\treturns p4 (x,y) that completes the rectangle\\n\\t\\t\\'\\'\\'\\n\\t\\treturn (p2[0]+v12[0]+v23[0], p2[1]+v12[1]+v23[1])\\n\\n\\tdef area(v12, v23) -> int:\\n\\t\\t\\'\\'\\'\\n\\t\\tgiven vectors v12 and v23 returns the area of the rectangle\\n\\t\\t\\'\\'\\'\\n\\t\\tlength_12 = (v12[0]**2 + v12[1]**2)**0.5\\n\\t\\tlength_23 = (v23[0]**2 + v23[1]**2)**0.5\\n\\t\\treturn length_12*length_23\\n\\n\\tdef vector(p1, p2):\\n\\t\\t\\'\\'\\'\\n\\t\\treturns the vector that points from p2 to p1\\n\\t\\t\\'\\'\\'\\n\\t\\treturn (p2[0]-p1[0], p2[1]-p1[1])\\n\\n\\tpoint_set = set(tuple(p) for p in points)\\n\\tsmallest_rectangle = float(\\'inf\\')\\n\\n\\tfor i in range(len(points)):\\n\\t\\tp1 = points[i]\\n\\n\\t\\tfor j in range(i+1, len(points)):\\n\\n\\t\\t\\tp2 = points[j]\\n\\t\\t\\tv12 = vector(p2,p1)\\n\\n\\t\\t\\tfor k in range(j+1, len(points)):\\n\\n\\t\\t\\t\\tp3 = points[k]\\n\\t\\t\\t\\tv23 = vector(p2,p3)\\n\\n\\t\\t\\t\\tif is_orthogonal(v12,v23):\\n\\n\\t\\t\\t\\t\\tA = area(v12,v23)\\n\\t\\t\\t\\t\\tif (A < smallest_rectangle) and (fourth_point(p2,v12,v23) in point_set):\\n\\t\\t\\t\\t\\t\\tsmallest_rectangle = A\\n\\n\\treturn 0 if smallest_rectangle == float(\\'inf\\') else smallest \\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t\\t   p4\\n\\t\\t\\t\\t\\t\\t   /\\\\\\n\\t  p1   p3          p1 /  \\\\ p3\\n\\t   \\\\  /               \\\\  /\\n    v12 \\\\/ v23             \\\\/\\n\\t\\tp2                 p2\\n```\n```p2```\n```p1```\n```p3```\n```(p1,p2)```\n```(p2,p3)```\n```v12```\n```v23```\n```smallest_rectangle```\n```p4```\n```points_set```\n```python\\ndef minAreaFreeRect(self, points: List[List[int]]) -> float:\\n\\n\\tdef is_orthogonal(v12, v23) -> bool:\\n\\t\\t\\'\\'\\'\\n\\t\\treturns True if vectors v12 and v23 are orthogonal\\n\\t\\tvector v12 connects points p1 and p2\\n\\t\\tvector v23 connects points p2 and p3\\n\\n\\t\\t p1      p3\\n\\t\\t   \\\\    /\\n\\t\\tv12 \\\\  / v23\\n\\t\\t\\t \\\\/ \\n\\t\\t\\t p2\\n\\t\\t\\'\\'\\'\\n\\t\\treturn not v12[0]*v23[0]+v12[1]*v23[1]\\n\\n\\tdef fourth_point(p2, v12, v23) -> tuple:\\n\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t\\t\\t\\t   p4\\n\\t\\t\\t\\t\\t\\t\\t   /\\\\\\n\\t\\t  p1   p3          p1 /  \\\\ p3\\n\\t\\t   \\\\  /               \\\\  /\\n\\t\\t\\t\\\\/                 \\\\/\\n\\t\\t\\tp2                 p2\\n\\n\\t\\tp2 is the shared point between two orthogonal vectors\\n\\n\\t\\treturns p4 (x,y) that completes the rectangle\\n\\t\\t\\'\\'\\'\\n\\t\\treturn (p2[0]+v12[0]+v23[0], p2[1]+v12[1]+v23[1])\\n\\n\\tdef area(v12, v23) -> int:\\n\\t\\t\\'\\'\\'\\n\\t\\tgiven vectors v12 and v23 returns the area of the rectangle\\n\\t\\t\\'\\'\\'\\n\\t\\tlength_12 = (v12[0]**2 + v12[1]**2)**0.5\\n\\t\\tlength_23 = (v23[0]**2 + v23[1]**2)**0.5\\n\\t\\treturn length_12*length_23\\n\\n\\tdef vector(p1, p2):\\n\\t\\t\\'\\'\\'\\n\\t\\treturns the vector that points from p2 to p1\\n\\t\\t\\'\\'\\'\\n\\t\\treturn (p2[0]-p1[0], p2[1]-p1[1])\\n\\n\\tpoint_set = set(tuple(p) for p in points)\\n\\tsmallest_rectangle = float(\\'inf\\')\\n\\n\\tfor i in range(len(points)):\\n\\t\\tp1 = points[i]\\n\\n\\t\\tfor j in range(i+1, len(points)):\\n\\n\\t\\t\\tp2 = points[j]\\n\\t\\t\\tv12 = vector(p2,p1)\\n\\n\\t\\t\\tfor k in range(j+1, len(points)):\\n\\n\\t\\t\\t\\tp3 = points[k]\\n\\t\\t\\t\\tv23 = vector(p2,p3)\\n\\n\\t\\t\\t\\tif is_orthogonal(v12,v23):\\n\\n\\t\\t\\t\\t\\tA = area(v12,v23)\\n\\t\\t\\t\\t\\tif (A < smallest_rectangle) and (fourth_point(p2,v12,v23) in point_set):\\n\\t\\t\\t\\t\\t\\tsmallest_rectangle = A\\n\\n\\treturn 0 if smallest_rectangle == float(\\'inf\\') else smallest \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 739670,
                "title": "o-n-n-16ms",
                "content": "This solutsion is based on the following observations:\\n1. Parallelogram\\'s diagonals bissect each other. [Wikipedia - Parallelogram](https://en.wikipedia.org/wiki/Parallelogram#Characterizations)\\n2. A rectangle is a parallelogram with diagonals of equal length. [Wikipedia - Rectangle](https://en.wikipedia.org/wiki/Rectangle#Characterizations)\\n\\nTherefore:\\n1. partition segemts by their diagonal\\'s centers.\\n2. two segments of the same length comprise a rectangle.\\n\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        List<Point> ps = distinct(points);\\n        \\n        Map<Point, List<Segment>> centers = new HashMap<>();\\n        for (int i = 0; i < ps.size(); i++) {\\n            Point start = ps.get(i);\\n            for (int j = i + 1; j < ps.size(); j++) {\\n                Point end = ps.get(j);\\n                Segment s = new Segment(start, end);\\n                centers.computeIfAbsent(s.diagonal(), k -> new ArrayList<>()).add(s);\\n            }\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        for (Point center : centers.keySet()) {\\n            List<Segment> segments = centers.get(center);\\n            for (int i = 0; i < segments.size(); i++) {\\n                Segment a = segments.get(i);\\n                for (int j = i + 1; j < segments.size(); j++) {\\n                    Segment b = segments.get(j);\\n                    if (a.length() == b.length()) {\\n                        minArea = Math.min(minArea, area(a, b));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (minArea == Double.MAX_VALUE) {\\n            return 0;\\n        }\\n        \\n        return Math.sqrt(minArea);\\n    }\\n    \\n    private List<Point> distinct(int[][] points) {\\n        Set<Point> ps = new HashSet<>();\\n        for (int[] p : points) {\\n            ps.add(new Point(p[0], p[1]));\\n        }\\n        return new ArrayList<>(ps);\\n    }\\n    \\n    private double area(Segment a, Segment b) {\\n        return new Segment(a.start, b.start).length() * new Segment(b.start, a.end).length();\\n    }\\n}\\n\\nclass Segment {\\n    final Point start;\\n    final Point end;\\n    \\n    Segment(Point s, Point e) {\\n        start = s;\\n        end = e;\\n    }\\n    \\n    Point diagonal() {\\n        return new Point((start.x + end.x) / 2, (start.y + end.y) / 2);\\n    }\\n    \\n    double length() {\\n        double dx = start.x - end.x;\\n        double dy = start.y - end.y;\\n        return dx * dx + dy * dy;\\n    }\\n\\n}\\n\\nclass Point {\\n    final double x;\\n    final double y;\\n    \\n    Point(double x, double y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(x, y);\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        if (!(o instanceof Point)) {\\n            return false;\\n        }\\n        \\n        Point other = (Point) o;\\n        return x == other.x && y == other.y;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        List<Point> ps = distinct(points);\\n        \\n        Map<Point, List<Segment>> centers = new HashMap<>();\\n        for (int i = 0; i < ps.size(); i++) {\\n            Point start = ps.get(i);\\n            for (int j = i + 1; j < ps.size(); j++) {\\n                Point end = ps.get(j);\\n                Segment s = new Segment(start, end);\\n                centers.computeIfAbsent(s.diagonal(), k -> new ArrayList<>()).add(s);\\n            }\\n        }\\n        \\n        double minArea = Double.MAX_VALUE;\\n        for (Point center : centers.keySet()) {\\n            List<Segment> segments = centers.get(center);\\n            for (int i = 0; i < segments.size(); i++) {\\n                Segment a = segments.get(i);\\n                for (int j = i + 1; j < segments.size(); j++) {\\n                    Segment b = segments.get(j);\\n                    if (a.length() == b.length()) {\\n                        minArea = Math.min(minArea, area(a, b));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (minArea == Double.MAX_VALUE) {\\n            return 0;\\n        }\\n        \\n        return Math.sqrt(minArea);\\n    }\\n    \\n    private List<Point> distinct(int[][] points) {\\n        Set<Point> ps = new HashSet<>();\\n        for (int[] p : points) {\\n            ps.add(new Point(p[0], p[1]));\\n        }\\n        return new ArrayList<>(ps);\\n    }\\n    \\n    private double area(Segment a, Segment b) {\\n        return new Segment(a.start, b.start).length() * new Segment(b.start, a.end).length();\\n    }\\n}\\n\\nclass Segment {\\n    final Point start;\\n    final Point end;\\n    \\n    Segment(Point s, Point e) {\\n        start = s;\\n        end = e;\\n    }\\n    \\n    Point diagonal() {\\n        return new Point((start.x + end.x) / 2, (start.y + end.y) / 2);\\n    }\\n    \\n    double length() {\\n        double dx = start.x - end.x;\\n        double dy = start.y - end.y;\\n        return dx * dx + dy * dy;\\n    }\\n\\n}\\n\\nclass Point {\\n    final double x;\\n    final double y;\\n    \\n    Point(double x, double y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(x, y);\\n    }\\n    \\n    @Override\\n    public boolean equals(Object o) {\\n        if (!(o instanceof Point)) {\\n            return false;\\n        }\\n        \\n        Point other = (Point) o;\\n        return x == other.x && y == other.y;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646633,
                "title": "c-mapping-lensq-center-corner-points-with-comments",
                "content": "```cpp\\nprivate:\\n    // square of segment(p1, p2) length \\n    long lenSq(vector<int>& p1, vector<int>& p2) {\\n      return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n    }\\n  \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& pts) \\n    {\\n      // PtGroups: (len^2, 2*xc, 2*yc)-> {{x1,y1},...} \\n      // where segment (x1,y)-(x2,y2) has length len and center (xc,yc)\\n      unordered_map<string, vector<vector<int>>> PtGroups; // group by center and length \\n      \\n      for (int j = 1; j < pts.size(); j++) \\n        for (int i = 0; i < j; i++) \\n        {\\n          int xc2 = pts[i][0]+pts[j][0];\\n          int yc2 = pts[i][1]+pts[j][1];\\n          long distSq = lenSq(pts[i], pts[j]);\\n          string key = to_string(distSq) + \" \" + to_string(xc2) + \" \" + to_string(yc2);\\n          PtGroups[key].push_back(pts[i]); // just need one end point\\n        }\\n      \\n      long minAreaSq = LONG_MAX;\\n      for (auto& p : PtGroups) {\\n        stringstream key(p.first);\\n        string tmp; key >> tmp;\\n        long distSq = stol(tmp);\\n        \\n        for (int j = 1; j < p.second.size(); j++)\\n          for (int i = 0; i < j; i++)\\n          {\\n            auto p1 = p.second[i];\\n            auto p2 = p.second[j];\\n            minAreaSq = min(minAreaSq, lenSq(p1,p2)*(distSq - lenSq(p1,p2))); // using Pythagoras\\'s Theorem\\n          }\\n      }\\n      \\n      return minAreaSq == LONG_MAX? 0 : sqrt(minAreaSq);\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\nprivate:\\n    // square of segment(p1, p2) length \\n    long lenSq(vector<int>& p1, vector<int>& p2) {\\n      return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\\n    }\\n  \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& pts) \\n    {\\n      // PtGroups: (len^2, 2*xc, 2*yc)-> {{x1,y1},...} \\n      // where segment (x1,y)-(x2,y2) has length len and center (xc,yc)\\n      unordered_map<string, vector<vector<int>>> PtGroups; // group by center and length \\n      \\n      for (int j = 1; j < pts.size(); j++) \\n        for (int i = 0; i < j; i++) \\n        {\\n          int xc2 = pts[i][0]+pts[j][0];\\n          int yc2 = pts[i][1]+pts[j][1];\\n          long distSq = lenSq(pts[i], pts[j]);\\n          string key = to_string(distSq) + \" \" + to_string(xc2) + \" \" + to_string(yc2);\\n          PtGroups[key].push_back(pts[i]); // just need one end point\\n        }\\n      \\n      long minAreaSq = LONG_MAX;\\n      for (auto& p : PtGroups) {\\n        stringstream key(p.first);\\n        string tmp; key >> tmp;\\n        long distSq = stol(tmp);\\n        \\n        for (int j = 1; j < p.second.size(); j++)\\n          for (int i = 0; i < j; i++)\\n          {\\n            auto p1 = p.second[i];\\n            auto p2 = p.second[j];\\n            minAreaSq = min(minAreaSq, lenSq(p1,p2)*(distSq - lenSq(p1,p2))); // using Pythagoras\\'s Theorem\\n          }\\n      }\\n      \\n      return minAreaSq == LONG_MAX? 0 : sqrt(minAreaSq);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 645675,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        auto pack = [](const vector<int> &p) {\\n            return (uint64_t(p[0])<<32) | p[1];\\n        };\\n\\n        unordered_set<int64_t> s;\\n        for (const auto &p : points) {\\n            s.insert(pack(p));\\n        }\\n\\n        double best = -1;\\n        for (int a_index=0; a_index<points.size(); ++a_index) {\\n            const auto &a = points[a_index];\\n            for (int b_index=a_index+1; b_index<points.size(); ++b_index) {\\n                const auto &b = points[b_index];\\n                for (int c_index=b_index+1; c_index<points.size(); ++c_index) {\\n                    const auto &c = points[c_index];\\n                    const int ab_x = b[0]-a[0];\\n                    const int ab_y = b[1]-a[1];\\n\\n                    const int ac_x = c[0]-a[0];\\n                    const int ac_y = c[1]-a[1];\\n\\n                    if (ab_x*ac_x+ab_y*ac_y != 0) continue;\\n\\n                    const int d_x  = a[0] + ab_x + ac_x;\\n                    const int d_y  = a[1] + ab_y + ac_y;\\n\\n                    if (s.find(pack({d_x, d_y})) == s.end()) {\\n                        continue;\\n                    }\\n\\n                    const double area = sqrt((double(ab_x)*ab_x+ab_y*ab_y)*(ac_x*ac_x+ac_y*ac_y));\\n                    if (area>0.000000001) {\\n                        if (best<0 || area<best) {\\n                            best = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return best < 0 ? 0 : best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        auto pack = [](const vector<int> &p) {\\n            return (uint64_t(p[0])<<32) | p[1];\\n        };\\n\\n        unordered_set<int64_t> s;\\n        for (const auto &p : points) {\\n            s.insert(pack(p));\\n        }\\n\\n        double best = -1;\\n        for (int a_index=0; a_index<points.size(); ++a_index) {\\n            const auto &a = points[a_index];\\n            for (int b_index=a_index+1; b_index<points.size(); ++b_index) {\\n                const auto &b = points[b_index];\\n                for (int c_index=b_index+1; c_index<points.size(); ++c_index) {\\n                    const auto &c = points[c_index];\\n                    const int ab_x = b[0]-a[0];\\n                    const int ab_y = b[1]-a[1];\\n\\n                    const int ac_x = c[0]-a[0];\\n                    const int ac_y = c[1]-a[1];\\n\\n                    if (ab_x*ac_x+ab_y*ac_y != 0) continue;\\n\\n                    const int d_x  = a[0] + ab_x + ac_x;\\n                    const int d_y  = a[1] + ab_y + ac_y;\\n\\n                    if (s.find(pack({d_x, d_y})) == s.end()) {\\n                        continue;\\n                    }\\n\\n                    const double area = sqrt((double(ab_x)*ab_x+ab_y*ab_y)*(ac_x*ac_x+ac_y*ac_y));\\n                    if (area>0.000000001) {\\n                        if (best<0 || area<best) {\\n                            best = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return best < 0 ? 0 : best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640740,
                "title": "python3-10-lines",
                "content": "1. key: mid, diagonal length\\n2. min\\n3. if float(\"inf\") return 0\\n```\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        ans, dic = float(\"inf\"), {}\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                key = ((points[i][0] + points[j][0])/2, (points[i][1] + points[j][1])/2, ((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)**0.5)\\n                if key in dic:\\n                    for val in dic[key]:\\n                        ans = min(ans, ((points[i][0]-val[0][0])**2 + (points[i][1]-val[0][1])**2)**0.5 * ((points[i][0]-val[1][0])**2 + (points[i][1]-val[1][1])**2)**0.5)\\n                dic[key] = dic.get(key, []) + [(points[i], points[j])]\\n        return ans if ans != float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        ans, dic = float(\"inf\"), {}\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                key = ((points[i][0] + points[j][0])/2, (points[i][1] + points[j][1])/2, ((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)**0.5)\\n                if key in dic:\\n                    for val in dic[key]:\\n                        ans = min(ans, ((points[i][0]-val[0][0])**2 + (points[i][1]-val[0][1])**2)**0.5 * ((points[i][0]-val[1][0])**2 + (points[i][1]-val[1][1])**2)**0.5)\\n                dic[key] = dic.get(key, []) + [(points[i], points[j])]\\n        return ans if ans != float(\\'inf\\') else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 625617,
                "title": "python-prefix-solution",
                "content": "**Explanation**\\n\\nLoop through all the points and for each point build a distance D => dict{distance:edges} to to store all the distance:edges information\\n\\nIf the distance of two edges are same that means we can try to build a rectangle from the diagonal pair, the rest of the thing is to check if all the pair-edges in the rectangle has the same length, if valid that means this is a valid rectangle.\\n\\n```\\nimport math\\n    def minAreaFreeRect(self, P: List[List[int]]) -> float:\\n        if len(P) < 4:return 0\\n        \\n        def dis(A, B):\\n            return (A[0]-B[0])**2 + (A[1]-B[1])**2\\n        \\n        D = defaultdict(lambda:[])\\n        ans = math.inf\\n        for i in range(len(P)-1):\\n            for j in range(i+1, len(P)):\\n                D[dis(P[i], P[j])].append(((P[i][0], P[i][1]), (P[j][0],P[j][1])))\\n        \\n        for d in D:\\n            for i in range(len(D[d])-1):\\n                for j in range(i+1, len(D[d])):\\n                    if dis(D[d][i][0], D[d][j][0]) == dis(D[d][i][1], D[d][j][1]):\\n                        if dis(D[d][i][0], D[d][j][1]) == dis(D[d][i][1], D[d][j][0]):\\n                            ans = min(ans, dis(D[d][i][0], D[d][j][0])*dis(D[d][i][0], D[d][j][1]))\\n\\n        return math.sqrt(ans) if ans!=inf else float(0)\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\n    def minAreaFreeRect(self, P: List[List[int]]) -> float:\\n        if len(P) < 4:return 0\\n        \\n        def dis(A, B):\\n            return (A[0]-B[0])**2 + (A[1]-B[1])**2\\n        \\n        D = defaultdict(lambda:[])\\n        ans = math.inf\\n        for i in range(len(P)-1):\\n            for j in range(i+1, len(P)):\\n                D[dis(P[i], P[j])].append(((P[i][0], P[i][1]), (P[j][0],P[j][1])))\\n        \\n        for d in D:\\n            for i in range(len(D[d])-1):\\n                for j in range(i+1, len(D[d])):\\n                    if dis(D[d][i][0], D[d][j][0]) == dis(D[d][i][1], D[d][j][1]):\\n                        if dis(D[d][i][0], D[d][j][1]) == dis(D[d][i][1], D[d][j][0]):\\n                            ans = min(ans, dis(D[d][i][0], D[d][j][0])*dis(D[d][i][0], D[d][j][1]))\\n\\n        return math.sqrt(ans) if ans!=inf else float(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 598104,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        using point = vector<int>;\\n        if(points.size() < 4)\\n            return 0;\\n        // radius ----> {ith, jth}\\n        unordered_map<int, vector<pair<int, int>>> hashmap;\\n        for(int i = 0; i < points.size(); ++i)\\n        {\\n            for(int j = i + 1; j < points.size(); ++j)\\n            {\\n                const point& p1 = points[i];\\n                const point& p2 = points[j];\\n                int radius = pow((p2[0] - p1[0]), 2) + pow((p2[1] - p1[1]), 2);\\n                // std::cout << radius << std::endl;\\n                hashmap[radius].push_back({i, j});\\n            }\\n        }\\n        double ans = 2e9;\\n        for(const auto& hashItem : hashmap)\\n        {\\n            for(int i = 0; i < hashItem.second.size(); ++i)\\n            {\\n                const point& p1 = points[hashItem.second[i].first];\\n                const point& p2 = points[hashItem.second[i].second];\\n                for(int j = i + 1; j < hashItem.second.size(); ++j)\\n                {\\n                    const point& p3 = points[hashItem.second[j].first];\\n                    const point& p4 = points[hashItem.second[j].second];\\n                 \\n                    int dx1 = p3[0] - p1[0];\\n                    int dx2 = p4[0] - p1[0];\\n                    int dy1 = p3[1] - p1[1];\\n                    int dy2 = p4[1] - p1[1];\\n                    if(dx1 * dx2 + dy1 * dy2 != 0)\\n                        continue;\\n                    dx1 = p3[0] - p2[0];\\n                    dx2 = p4[0] - p2[0];\\n                    dy1 = p3[1] - p2[1];\\n                    dy2 = p4[1] - p2[1];\\n                    if(dx1 * dx2 + dy1 * dy2 != 0)\\n                        continue;\\n                    double area = sqrt(dx1 * dx1 + dy1 * dy1) * sqrt(dx2 * dx2 + dy2 * dy2);\\n                    ans = area == 0 ? ans : min(ans, area);\\n                }\\n                \\n                \\n            }\\n        }\\n        return ans == 2e9 ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        using point = vector<int>;\\n        if(points.size() < 4)\\n            return 0;\\n        // radius ----> {ith, jth}\\n        unordered_map<int, vector<pair<int, int>>> hashmap;\\n        for(int i = 0; i < points.size(); ++i)\\n        {\\n            for(int j = i + 1; j < points.size(); ++j)\\n            {\\n                const point& p1 = points[i];\\n                const point& p2 = points[j];\\n                int radius = pow((p2[0] - p1[0]), 2) + pow((p2[1] - p1[1]), 2);\\n                // std::cout << radius << std::endl;\\n                hashmap[radius].push_back({i, j});\\n            }\\n        }\\n        double ans = 2e9;\\n        for(const auto& hashItem : hashmap)\\n        {\\n            for(int i = 0; i < hashItem.second.size(); ++i)\\n            {\\n                const point& p1 = points[hashItem.second[i].first];\\n                const point& p2 = points[hashItem.second[i].second];\\n                for(int j = i + 1; j < hashItem.second.size(); ++j)\\n                {\\n                    const point& p3 = points[hashItem.second[j].first];\\n                    const point& p4 = points[hashItem.second[j].second];\\n                 \\n                    int dx1 = p3[0] - p1[0];\\n                    int dx2 = p4[0] - p1[0];\\n                    int dy1 = p3[1] - p1[1];\\n                    int dy2 = p4[1] - p1[1];\\n                    if(dx1 * dx2 + dy1 * dy2 != 0)\\n                        continue;\\n                    dx1 = p3[0] - p2[0];\\n                    dx2 = p4[0] - p2[0];\\n                    dy1 = p3[1] - p2[1];\\n                    dy2 = p4[1] - p2[1];\\n                    if(dx1 * dx2 + dy1 * dy2 != 0)\\n                        continue;\\n                    double area = sqrt(dx1 * dx1 + dy1 * dy1) * sqrt(dx2 * dx2 + dy2 * dy2);\\n                    ans = area == 0 ? ans : min(ans, area);\\n                }\\n                \\n                \\n            }\\n        }\\n        return ans == 2e9 ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 559772,
                "title": "c-28ms-o-n-3-vector-math",
                "content": "```\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tauto pack = [](const vector<int> &p) {return (uint64_t(p[0])<<32) | p[1];};\\n\\n\\tunordered_set<int64_t> s;\\n\\tfor (const auto &p : points) {\\n\\t\\ts.insert(pack(p));\\n\\t}\\n\\n\\tdouble best = -1;\\n\\t// take every 3 points and see if there is a corner\\n\\tfor (int a_index=0; a_index<points.size(); ++a_index) {\\n\\t\\tconst auto &a = points[a_index];\\n\\t\\tfor (int b_index=a_index+1; b_index<points.size(); ++b_index) {\\n\\t\\t\\tconst auto &b = points[b_index];\\n\\t\\t\\tfor (int c_index=b_index+1; c_index<points.size(); ++c_index) {\\n\\t\\t\\t\\tconst auto &c = points[c_index];\\n\\t\\t\\t\\t// build vectors ab and ac\\n\\t\\t\\t\\tconst int ab_x = b[0]-a[0];\\n\\t\\t\\t\\tconst int ab_y = b[1]-a[1];\\n\\n\\t\\t\\t\\tconst int ac_x = c[0]-a[0];\\n\\t\\t\\t\\tconst int ac_y = c[1]-a[1];\\n\\n\\t\\t\\t\\t// vectors ab and ac are orthogonal if the scalar product is zero\\n\\t\\t\\t\\tif (ab_x*ac_x+ab_y*ac_y != 0) {\\n\\t\\t\\t\\t\\t// not orthogonal: ab and ac cannot form sides of a rectangle\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// point d is sum of vectors ab and ac\\n\\t\\t\\t\\tconst int d_x  = a[0] + ab_x + ac_x;\\n\\t\\t\\t\\tconst int d_y  = a[1] + ab_y + ac_y;\\n\\n\\t\\t\\t\\t// does d exist?\\n\\t\\t\\t\\tif (s.find(pack({d_x, d_y})) == s.end()) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// area is length of vector ab * length of vector ac\\n\\t\\t\\t\\tconst double area = sqrt((double(ab_x)*ab_x+ab_y*ab_y)*(ac_x*ac_x+ac_y*ac_y));\\n\\t\\t\\t\\tif (area>0.000000001) { // ignore empty rects\\n\\t\\t\\t\\t\\tif (best<0 || area<best) {\\n\\t\\t\\t\\t\\t\\tbest = area;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn best < 0 ? 0 : best;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tauto pack = [](const vector<int> &p) {return (uint64_t(p[0])<<32) | p[1];};\\n\\n\\tunordered_set<int64_t> s;\\n\\tfor (const auto &p : points) {\\n\\t\\ts.insert(pack(p));\\n\\t}\\n\\n\\tdouble best = -1;\\n\\t// take every 3 points and see if there is a corner\\n\\tfor (int a_index=0; a_index<points.size(); ++a_index) {\\n\\t\\tconst auto &a = points[a_index];\\n\\t\\tfor (int b_index=a_index+1; b_index<points.size(); ++b_index) {\\n\\t\\t\\tconst auto &b = points[b_index];\\n\\t\\t\\tfor (int c_index=b_index+1; c_index<points.size(); ++c_index) {\\n\\t\\t\\t\\tconst auto &c = points[c_index];\\n\\t\\t\\t\\t// build vectors ab and ac\\n\\t\\t\\t\\tconst int ab_x = b[0]-a[0];\\n\\t\\t\\t\\tconst int ab_y = b[1]-a[1];\\n\\n\\t\\t\\t\\tconst int ac_x = c[0]-a[0];\\n\\t\\t\\t\\tconst int ac_y = c[1]-a[1];\\n\\n\\t\\t\\t\\t// vectors ab and ac are orthogonal if the scalar product is zero\\n\\t\\t\\t\\tif (ab_x*ac_x+ab_y*ac_y != 0) {\\n\\t\\t\\t\\t\\t// not orthogonal: ab and ac cannot form sides of a rectangle\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// point d is sum of vectors ab and ac\\n\\t\\t\\t\\tconst int d_x  = a[0] + ab_x + ac_x;\\n\\t\\t\\t\\tconst int d_y  = a[1] + ab_y + ac_y;\\n\\n\\t\\t\\t\\t// does d exist?\\n\\t\\t\\t\\tif (s.find(pack({d_x, d_y})) == s.end()) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// area is length of vector ab * length of vector ac\\n\\t\\t\\t\\tconst double area = sqrt((double(ab_x)*ab_x+ab_y*ab_y)*(ac_x*ac_x+ac_y*ac_y));\\n\\t\\t\\t\\tif (area>0.000000001) { // ignore empty rects\\n\\t\\t\\t\\t\\tif (best<0 || area<best) {\\n\\t\\t\\t\\t\\t\\tbest = area;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn best < 0 ? 0 : best;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558516,
                "title": "c-beats-70",
                "content": "Run time = 36-52 ms / beats ~70 %\\n\\nThe idea is to record all the pairs of points which have the same middle point, and then check among all the pairs sharing the same middle point, if any two pairs give inner product of zero.\\n\\n```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int n = points.size();\\n        unordered_map<long int, vector<pair<int, int>>> m;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                long int tmp = (points[i][0] + points[j][0]) * 80001.0 + (points[i][1] + points[j][1]);\\n                m[tmp].push_back(pair(i, j));\\n            }\\n        }\\n        double ret = 2e9;\\n        for (auto it = m.begin(); it != m.end(); it++)\\n        {\\n            if (it->second.size() == 1) continue;\\n            for (int i = 0; i < it->second.size()-1; i++)\\n            {\\n                for (int j = i + 1; j < it->second.size(); j++)\\n                {\\n                    int dx1 = points[it->second[i].first][0] - points[it->second[j].first][0];\\n                    int dy1 = points[it->second[i].first][1] - points[it->second[j].first][1];\\n                    int dx2 = points[it->second[i].first][0] - points[it->second[j].second][0];\\n                    int dy2 = points[it->second[i].first][1] - points[it->second[j].second][1];\\n                    if (dx1 * dx2 + dy1 * dy2 != 0) continue;\\n                    ret = min(ret, sqrt(dx1 * dx1 + dy1 * dy1) * sqrt(dx2 * dx2 + dy2 * dy2));\\n                }\\n            }\\n        }\\n        return ret == 2e9 ? 0 : ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        int n = points.size();\\n        unordered_map<long int, vector<pair<int, int>>> m;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                long int tmp = (points[i][0] + points[j][0]) * 80001.0 + (points[i][1] + points[j][1]);\\n                m[tmp].push_back(pair(i, j));\\n            }\\n        }\\n        double ret = 2e9;\\n        for (auto it = m.begin(); it != m.end(); it++)\\n        {\\n            if (it->second.size() == 1) continue;\\n            for (int i = 0; i < it->second.size()-1; i++)\\n            {\\n                for (int j = i + 1; j < it->second.size(); j++)\\n                {\\n                    int dx1 = points[it->second[i].first][0] - points[it->second[j].first][0];\\n                    int dy1 = points[it->second[i].first][1] - points[it->second[j].first][1];\\n                    int dx2 = points[it->second[i].first][0] - points[it->second[j].second][0];\\n                    int dy2 = points[it->second[i].first][1] - points[it->second[j].second][1];\\n                    if (dx1 * dx2 + dy1 * dy2 != 0) continue;\\n                    ret = min(ret, sqrt(dx1 * dx1 + dy1 * dy1) * sqrt(dx2 * dx2 + dy2 * dy2));\\n                }\\n            }\\n        }\\n        return ret == 2e9 ? 0 : ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556215,
                "title": "963-minimum-area-rectangle-ii-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Diagonal as Key**\\n| O(T): O(n^3) | O(S): O(n) | Rt: 76ms | \\n```python\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        rst, l = float(\\'inf\\'), len(points)\\n        if l < 4: return 0\\n        dt = {}\\n        for i in range(l-1):\\n            x1, y1 = points[i]\\n            for j in range(i+1, l):\\n                x2, y2 = points[j]\\n                x, y = (x1 + x2) / 2, (y1 + y2) / 2\\n                distance = (x2-x1) * (x2-x1) + (y2-y1) * (y2-y1)\\n                key = (x, y, distance)\\n                if key not in dt: dt[key] = []\\n                dt[key].append((i, j))\\n                \\n        for k in dt:\\n            if len(dt[k]) > 1:\\n                arr, le = dt[k], len(dt[k])\\n                for i in range(le-1):\\n                    a, b = arr[i]\\n                    x1, y1, x2, y2 = *points[a], *points[b]\\n                    for j in range(i+1, le):\\n                        x3, y3 = points[arr[j][0]]\\n                        m, n = ((x3-x1)**2 + (y3-y1)**2)**0.5, ((x3-x2)**2 + (y3-y2)**2)**0.5\\n                        rst = min(rst, m*n)\\n        return 0 if rst == float(\\'inf\\') else rst\\n```\\nReferrence: https://leetcode.com/problems/minimum-area-rectangle-ii/discuss/208361/JAVA-O(n2)-using-Map\\n\\n",
                "solutionTags": [],
                "code": "```python\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        rst, l = float(\\'inf\\'), len(points)\\n        if l < 4: return 0\\n        dt = {}\\n        for i in range(l-1):\\n            x1, y1 = points[i]\\n            for j in range(i+1, l):\\n                x2, y2 = points[j]\\n                x, y = (x1 + x2) / 2, (y1 + y2) / 2\\n                distance = (x2-x1) * (x2-x1) + (y2-y1) * (y2-y1)\\n                key = (x, y, distance)\\n                if key not in dt: dt[key] = []\\n                dt[key].append((i, j))\\n                \\n        for k in dt:\\n            if len(dt[k]) > 1:\\n                arr, le = dt[k], len(dt[k])\\n                for i in range(le-1):\\n                    a, b = arr[i]\\n                    x1, y1, x2, y2 = *points[a], *points[b]\\n                    for j in range(i+1, le):\\n                        x3, y3 = points[arr[j][0]]\\n                        m, n = ((x3-x1)**2 + (y3-y1)**2)**0.5, ((x3-x2)**2 + (y3-y2)**2)**0.5\\n                        rst = min(rst, m*n)\\n        return 0 if rst == float(\\'inf\\') else rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 526517,
                "title": "golang-o-n-3",
                "content": "```\\nfunc minAreaFreeRect(points [][]int) float64 {\\n\\tpositionsMap := make(map[string]bool)\\n\\tfor _, point := range points {\\n\\t\\tx, y := point[0], point[1]\\n\\t\\tpositionsMap[fmt.Sprintf(\"%s:%s\", x, y)] = true\\n\\t}\\n\\tres := math.MaxFloat64\\n\\tfound := false\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tx1, y1 := points[i][0], points[i][1]\\n\\t\\tfor j := 0; j < len(points); j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tx2, y2 := points[j][0], points[j][1]\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx3, y3 := points[k][0], points[k][1]\\n\\t\\t\\t\\tif (y2-y1)*(y3-y2)+(x2-x1)*(x3-x2) != 0 {\\n\\t\\t\\t\\t\\t// check if it\\'s 90 degrees at point j\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx4, y4 := x1+x3-x2, y1+y3-y2\\n\\t\\t\\t\\tif !positionsMap[fmt.Sprintf(\"%s:%s\", x4, y4)] {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tl, w := math.Sqrt(float64((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))), math.Sqrt(float64((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3)))\\n\\t\\t\\t\\tres = min(res, l*w)\\n\\t\\t\\t\\tfound = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif found {\\n\\t\\treturn res\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc min(x, y float64) float64 {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\n\\treturn y\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minAreaFreeRect(points [][]int) float64 {\\n\\tpositionsMap := make(map[string]bool)\\n\\tfor _, point := range points {\\n\\t\\tx, y := point[0], point[1]\\n\\t\\tpositionsMap[fmt.Sprintf(\"%s:%s\", x, y)] = true\\n\\t}\\n\\tres := math.MaxFloat64\\n\\tfound := false\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tx1, y1 := points[i][0], points[i][1]\\n\\t\\tfor j := 0; j < len(points); j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tx2, y2 := points[j][0], points[j][1]\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx3, y3 := points[k][0], points[k][1]\\n\\t\\t\\t\\tif (y2-y1)*(y3-y2)+(x2-x1)*(x3-x2) != 0 {\\n\\t\\t\\t\\t\\t// check if it\\'s 90 degrees at point j\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx4, y4 := x1+x3-x2, y1+y3-y2\\n\\t\\t\\t\\tif !positionsMap[fmt.Sprintf(\"%s:%s\", x4, y4)] {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tl, w := math.Sqrt(float64((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))), math.Sqrt(float64((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3)))\\n\\t\\t\\t\\tres = min(res, l*w)\\n\\t\\t\\t\\tfound = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif found {\\n\\t\\treturn res\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc min(x, y float64) float64 {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\n\\treturn y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506690,
                "title": "javascript-iterate-triangles-to-n-3",
                "content": "```\\nconst isPerpendicular = ([x1, y1], [x2, y2], [x3, y3]) => {       // X.Y = |X| * |Y| * cos(angle)  --> cos(90) = 0\\n    const dot = ( (x2-x1) * (x3-x1) ) + ( (y2-y1) * (y3-y1) );\\n    return dot == 0;\\n}\\n\\nconst calculateArea = ([x1, y1], [x2, y2], [x3, y3]) => {\\n    const a = Math.sqrt( Math.pow((x2-x1), 2) + Math.pow((y2-y1), 2) );\\n    const b = Math.sqrt( Math.pow((x3-x1), 2) + Math.pow((y3-y1), 2) );\\n    return a * b;\\n}\\n\\nconst minAreaFreeRect = points => {\\n\\tif(points.length < 4){  return 0 ;}\\n    const pointsMap = new Map()\\n    for(let [x,y] of points){ \\n        pointsMap.set(40000*x + y, true) ; \\n    }\\n    let min = Infinity;\\n    \\n    for(let [x1, y1] of points){\\n        for(let [x2, y2] of points){\\n            if(x2 != x1 || y2 != y1){                                 // point 2 & 1 are different\\n                for(let [x3, y3] of points){\\n                    const cond31 = x3 != x1 || y3 != y1;              // point 3 & 1 are different\\n                    const cond32 = x3 != x2 || y3 != y2;              // point 3 & 2 are different\\n                    if(cond31 && cond32){\\n                        const x4 = x3 + x2 - x1 ;\\n                        const y4 = y3 + y2 - y1 ;\\n                        const p4 = 40000 *x4 + y4 ;\\n                        if(pointsMap.has(p4)){                                  \\n                            if(isPerpendicular([x1, y1], [x2, y2], [x3, y3])){                     // if angle is 90 degree\\n                                const area = calculateArea([x1, y1], [x2, y2], [x3, y3])\\n                                min = Math.min(min , area)\\n                            }\\n                        } \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return min == Infinity ? 0 : min; \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst isPerpendicular = ([x1, y1], [x2, y2], [x3, y3]) => {       // X.Y = |X| * |Y| * cos(angle)  --> cos(90) = 0\\n    const dot = ( (x2-x1) * (x3-x1) ) + ( (y2-y1) * (y3-y1) );\\n    return dot == 0;\\n}\\n\\nconst calculateArea = ([x1, y1], [x2, y2], [x3, y3]) => {\\n    const a = Math.sqrt( Math.pow((x2-x1), 2) + Math.pow((y2-y1), 2) );\\n    const b = Math.sqrt( Math.pow((x3-x1), 2) + Math.pow((y3-y1), 2) );\\n    return a * b;\\n}\\n\\nconst minAreaFreeRect = points => {\\n\\tif(points.length < 4){  return 0 ;}\\n    const pointsMap = new Map()\\n    for(let [x,y] of points){ \\n        pointsMap.set(40000*x + y, true) ; \\n    }\\n    let min = Infinity;\\n    \\n    for(let [x1, y1] of points){\\n        for(let [x2, y2] of points){\\n            if(x2 != x1 || y2 != y1){                                 // point 2 & 1 are different\\n                for(let [x3, y3] of points){\\n                    const cond31 = x3 != x1 || y3 != y1;              // point 3 & 1 are different\\n                    const cond32 = x3 != x2 || y3 != y2;              // point 3 & 2 are different\\n                    if(cond31 && cond32){\\n                        const x4 = x3 + x2 - x1 ;\\n                        const y4 = y3 + y2 - y1 ;\\n                        const p4 = 40000 *x4 + y4 ;\\n                        if(pointsMap.has(p4)){                                  \\n                            if(isPerpendicular([x1, y1], [x2, y2], [x3, y3])){                     // if angle is 90 degree\\n                                const area = calculateArea([x1, y1], [x2, y2], [x3, y3])\\n                                min = Math.min(min , area)\\n                            }\\n                        } \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return min == Infinity ? 0 : min; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494733,
                "title": "javascript-iterate-triangle",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    let area = Infinity , pointsMap = {} , len = points.length;\\n    \\n    //corner case\\n    if(len < 4) return 0;\\n    \\n    //points map\\n    for(let point of points){\\n        const [x , y ] = point;\\n        pointsMap[40000*x + y] = true;\\n    }\\n    \\n    for(let pointOne of points){\\n        const [x1 , y1] = pointOne;\\n        for(let pointTwo of points){\\n            if(pointTwo != pointOne){\\n                const [x2 , y2] = pointTwo;\\n                for(let pointThree of points){\\n                    if(pointThree != pointTwo){\\n                        const [x3 , y3] = pointThree;\\n                        //prove it\\'s triangle\\n                        let triangleVal = (y2-y1)*(y3-y1) + (x2-x1)*(x3-x1)\\n                        if(triangleVal === 0){\\n                            let y4 = y2 + y3 - y1;\\n                            let x4 = x2 + x3 - x1;\\n                            if(pointsMap[40000*x4 + y4]){\\n                                let curArea = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)) * Math.sqrt((x3-x1)*(x3-x1) + (y3-y1)*(y3-y1));\\n                                if(curArea !== 0) area = Math.min(area , curArea);\\n                            }\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return area === Infinity ? 0 : area;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar minAreaFreeRect = function(points) {\\n    let area = Infinity , pointsMap = {} , len = points.length;\\n    \\n    //corner case\\n    if(len < 4) return 0;\\n    \\n    //points map\\n    for(let point of points){\\n        const [x , y ] = point;\\n        pointsMap[40000*x + y] = true;\\n    }\\n    \\n    for(let pointOne of points){\\n        const [x1 , y1] = pointOne;\\n        for(let pointTwo of points){\\n            if(pointTwo != pointOne){\\n                const [x2 , y2] = pointTwo;\\n                for(let pointThree of points){\\n                    if(pointThree != pointTwo){\\n                        const [x3 , y3] = pointThree;\\n                        //prove it\\'s triangle\\n                        let triangleVal = (y2-y1)*(y3-y1) + (x2-x1)*(x3-x1)\\n                        if(triangleVal === 0){\\n                            let y4 = y2 + y3 - y1;\\n                            let x4 = x2 + x3 - x1;\\n                            if(pointsMap[40000*x4 + y4]){\\n                                let curArea = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)) * Math.sqrt((x3-x1)*(x3-x1) + (y3-y1)*(y3-y1));\\n                                if(curArea !== 0) area = Math.min(area , curArea);\\n                            }\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return area === Infinity ? 0 : area;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466570,
                "title": "python-faster-than-90-less-use-than-100-with-some-explanation",
                "content": "```\\nimport math\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        size = len(points)\\n        dic = {}\\n        res = float(\\'inf\\')\\n        for i in range(size):\\n            point1 = points[i]\\n            for j in range(i+1,size):\\n                point2 = points[j]\\n                x = point1[0] - point2[0]\\n                y = point1[1] - point2[1]\\n                if x < 0:\\n                    x = -x\\n                    y = -y\\n                    pair = [point2, point1]\\n                else:   pair = [point1, point2]\\n                vec = (x,y)\\n                if vec not in dic:\\n                    dic[vec] = [pair]\\n                else:\\n                    dic[vec].append(pair)\\n            #end for\\n        #end for\\n        \\n        ### Above finding all pairs point that have same maginitude vector\\n        \\n        vecs = dic.keys()\\n        for vec in vecs:\\n            pairs = dic[vec]\\n            size = len(pairs)\\n            if size < 2:\\n                continue    #   if there is only one pair points is not enough to\\n                            #   construct a rectangle\\n            #   Looping the those pairs point\\n            for i in range(size):\\n                p1, p2 = pairs[i][0], pairs[i][1]\\n                for j in range(i+1,size):\\n                    p3 = pairs[j][0]\\n                    x = p1[0] - p3[0]\\n                    y = p1[1] - p3[1]\\n                    #   check there is a right angle\\n                    if (x * vec[0] + y * vec[1]) != 0:    \\n                        continue\\n                    length = math.sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2)\\n                    width = math.sqrt((p1[0]-p3[0])**2+(p1[1]-p3[1])**2)\\n                    area = length * width\\n                    res = min(res,area)\\n        return res if res!=float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def minAreaFreeRect(self, points: List[List[int]]) -> float:\\n        size = len(points)\\n        dic = {}\\n        res = float(\\'inf\\')\\n        for i in range(size):\\n            point1 = points[i]\\n            for j in range(i+1,size):\\n                point2 = points[j]\\n                x = point1[0] - point2[0]\\n                y = point1[1] - point2[1]\\n                if x < 0:\\n                    x = -x\\n                    y = -y\\n                    pair = [point2, point1]\\n                else:   pair = [point1, point2]\\n                vec = (x,y)\\n                if vec not in dic:\\n                    dic[vec] = [pair]\\n                else:\\n                    dic[vec].append(pair)\\n            #end for\\n        #end for\\n        \\n        ### Above finding all pairs point that have same maginitude vector\\n        \\n        vecs = dic.keys()\\n        for vec in vecs:\\n            pairs = dic[vec]\\n            size = len(pairs)\\n            if size < 2:\\n                continue    #   if there is only one pair points is not enough to\\n                            #   construct a rectangle\\n            #   Looping the those pairs point\\n            for i in range(size):\\n                p1, p2 = pairs[i][0], pairs[i][1]\\n                for j in range(i+1,size):\\n                    p3 = pairs[j][0]\\n                    x = p1[0] - p3[0]\\n                    y = p1[1] - p3[1]\\n                    #   check there is a right angle\\n                    if (x * vec[0] + y * vec[1]) != 0:    \\n                        continue\\n                    length = math.sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2)\\n                    width = math.sqrt((p1[0]-p3[0])**2+(p1[1]-p3[1])**2)\\n                    area = length * width\\n                    res = min(res,area)\\n        return res if res!=float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420870,
                "title": "wrong-test-case",
                "content": "I think there is a wrong test case. \\n![image](https://assets.leetcode.com/users/dakzholov/image_1572897490.png)\\nHere we see that the points (3, 1) (2, 1) (0, 1) (0,2) are in the given list. But the expected answer is 2.0\\n\\n![image](https://assets.leetcode.com/users/dakzholov/image_1572897560.png)\\nIn case I include only thouse points, the system gives 3.0 as the answer.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "I think there is a wrong test case. \\n![image](https://assets.leetcode.com/users/dakzholov/image_1572897490.png)\\nHere we see that the points (3, 1) (2, 1) (0, 1) (0,2) are in the given list. But the expected answer is 2.0\\n\\n![image](https://assets.leetcode.com/users/dakzholov/image_1572897560.png)\\nIn case I include only thouse points, the system gives 3.0 as the answer.\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 385835,
                "title": "swift-984-ms-faster-than-100-00-21-5-mb-less-than-100-00-o-n2-modular-solution",
                "content": "```\\nimport Foundation\\n\\nclass Solution {\\n    struct Diagonal {\\n        let from : (Int,Int)\\n        let to : (Int,Int)\\n        let length :Double\\n        var md : (Double,Double) {\\n            let xLength = from.0 + to.0\\n            let yLength = from.1 + to.1\\n            return (Double(xLength)/2,Double(yLength)/2)\\n            \\n        }\\n       \\n    }\\n    func minAreaFreeRect(_ points: [[Int]]) -> Double {\\n        \\n        guard points.count >= 4 else { return 0 }\\n        \\n        let MAX_AREA :Double = Double.greatestFiniteMagnitude\\n        \\n        var minArea :Double = MAX_AREA\\n        \\n        let ds = getDiagonals(points)\\n        \\n        for i in 0 ..< ds.count  {\\n            \\n            let md1 = ds[i].md\\n            \\n            for j in i+1 ..< ds.count  {\\n                \\n                let md2 = ds[j].md\\n               \\n               \\n                \\n                \\n                if md1.0 == md2.0 && md1.1 == md2.1 && ds[i].length == ds[j].length  {\\n                    \\n                   \\n                    let sideLength1 = calDistanceBetweenTwoPoints(ds[j].from,ds[i].from)\\n                    let sideLength2 = calDistanceBetweenTwoPoints(ds[j].from,ds[i].to)\\n                    \\n                    let area = sideLength1 * sideLength2\\n                    \\n                    \\n                    if area < minArea {\\n                        \\n                        minArea = area\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return minArea == MAX_AREA ? 0 : minArea\\n    }\\n    func getDiagonals(_ points :[[Int]] ) -> [Diagonal] {\\n        \\n        var ds = [Diagonal]()\\n        \\n        for i in 0 ..< points.count {\\n            \\n            let p1 = (points[i][0],points[i][1])\\n            \\n            for j in i+1 ..< points.count  {\\n                \\n                \\n                \\n                let p2 = (points[j][0],points[j][1])\\n                \\n                let d = Diagonal(from:p1,to:p2,length:calDistanceBetweenTwoPoints(p1, p2))\\n                \\n                ds.append(d)\\n                \\n            }\\n            \\n        }\\n        \\n        return ds\\n        \\n        \\n    }\\n    func calDistanceBetweenTwoPoints(_ p1:(Int,Int),_ p2:(Int,Int) ) -> Double {\\n        \\n        let dx = p2.0 - p1.0\\n        let dy = p2.1 - p1.1\\n        \\n        \\n        return Double((dy*dy)+(dx*dx)).squareRoot()\\n        \\n    }\\n   \\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    struct Diagonal {\\n        let from : (Int,Int)\\n        let to : (Int,Int)\\n        let length :Double\\n        var md : (Double,Double) {\\n            let xLength = from.0 + to.0\\n            let yLength = from.1 + to.1\\n            return (Double(xLength)/2,Double(yLength)/2)\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 363487,
                "title": "java-55-ms-faster-than-23-33-37-1-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Map<String, List<int[]>>> ps = new HashMap<>();\\n        int n = points.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                String c = (points[i][0] + points[j][0]) + \" \" + (points[i][1] + points[j][1]);\\n                int r = r2(points[i], points[j]);\\n                ps.computeIfAbsent(r, map -> new HashMap<>()).computeIfAbsent(c, list -> new ArrayList<>()).add(new int[]{points[i][0], points[i][1], points[j][0], points[j][1]});\\n            }\\n        }\\n        double ans = Double.MAX_VALUE;\\n        for (Map<String, List<int[]>> map : ps.values()) {\\n            for (List<int[]> list : map.values()) {\\n                for (int i = 0; i < list.size(); ++i) {\\n                    int[] p1 = list.get(i);\\n                    int[] P = new int[]{p1[0], p1[1]};\\n                    for (int j = i + 1; j < list.size(); ++j) {\\n                        int[] p2 = list.get(j);\\n                        double area = Math.sqrt(r2(P, new int[]{p2[0], p2[1]})) * Math.sqrt(r2(P, new int[]{p2[2], p2[3]}));\\n                        ans = Math.min(ans, area);\\n                    }\\n                }\\n            }\\n        }\\n        return Double.compare(ans, Double.MAX_VALUE) == 0 ? 0 : ans;\\n    }\\n    \\n    private int r2(int[] a, int[] b) {\\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Integer, Map<String, List<int[]>>> ps = new HashMap<>();\\n        int n = points.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                String c = (points[i][0] + points[j][0]) + \" \" + (points[i][1] + points[j][1]);\\n                int r = r2(points[i], points[j]);\\n                ps.computeIfAbsent(r, map -> new HashMap<>()).computeIfAbsent(c, list -> new ArrayList<>()).add(new int[]{points[i][0], points[i][1], points[j][0], points[j][1]});\\n            }\\n        }\\n        double ans = Double.MAX_VALUE;\\n        for (Map<String, List<int[]>> map : ps.values()) {\\n            for (List<int[]> list : map.values()) {\\n                for (int i = 0; i < list.size(); ++i) {\\n                    int[] p1 = list.get(i);\\n                    int[] P = new int[]{p1[0], p1[1]};\\n                    for (int j = i + 1; j < list.size(); ++j) {\\n                        int[] p2 = list.get(j);\\n                        double area = Math.sqrt(r2(P, new int[]{p2[0], p2[1]})) * Math.sqrt(r2(P, new int[]{p2[2], p2[3]}));\\n                        ans = Math.min(ans, area);\\n                    }\\n                }\\n            }\\n        }\\n        return Double.compare(ans, Double.MAX_VALUE) == 0 ? 0 : ans;\\n    }\\n    \\n    private int r2(int[] a, int[] b) {\\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349229,
                "title": "java-map-solution",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<String, Map<Double, List<int[]>>> map = new HashMap<>();\\n        int n = points.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                double centerX = ((double)points[i][0] + points[j][0]) / 2;\\n                double centerY = ((double)points[i][1] + points[j][1]) / 2;\\n                double dist = ((double)points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                String str = centerX + \" \" + centerY;\\n                map.putIfAbsent(str, new HashMap<>());\\n                map.get(str).putIfAbsent(dist, new ArrayList<>());\\n                map.get(str).get(dist).add(points[i]); \\n                map.get(str).get(dist).add(points[j]);\\n            }\\n        }\\n        double min = Double.MAX_VALUE;\\n        for (String c : map.keySet()) {\\n            for (double d : map.get(c).keySet()) {\\n                List<int[]> list = map.get(c).get(d);\\n                if (list.size() >= 4) {\\n                    for (int i = 0; i + 2 < list.size(); i += 2) {\\n                        for (int j = i + 2; j + 1 < list.size(); j += 2) {\\n                            double dist1 = Math.sqrt(((double)list.get(i)[0] - list.get(j)[0]) * ((double)list.get(i)[0] - list.get(j)[0]) + ((double)list.get(i)[1] - list.get(j)[1]) * ((double)list.get(i)[1] - list.get(j)[1]));\\n                            double dist2 = Math.sqrt(((double)list.get(i)[0] - list.get(j + 1)[0]) * ((double)list.get(i)[0] - list.get(j + 1)[0]) + ((double)list.get(i)[1] - list.get(j + 1)[1]) * ((double)list.get(i)[1] - list.get(j + 1)[1]));\\n                            min = Math.min(dist1 * dist2, min);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<String, Map<Double, List<int[]>>> map = new HashMap<>();\\n        int n = points.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                double centerX = ((double)points[i][0] + points[j][0]) / 2;\\n                double centerY = ((double)points[i][1] + points[j][1]) / 2;\\n                double dist = ((double)points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\\n                String str = centerX + \" \" + centerY;\\n                map.putIfAbsent(str, new HashMap<>());\\n                map.get(str).putIfAbsent(dist, new ArrayList<>());\\n                map.get(str).get(dist).add(points[i]); \\n                map.get(str).get(dist).add(points[j]);\\n            }\\n        }\\n        double min = Double.MAX_VALUE;\\n        for (String c : map.keySet()) {\\n            for (double d : map.get(c).keySet()) {\\n                List<int[]> list = map.get(c).get(d);\\n                if (list.size() >= 4) {\\n                    for (int i = 0; i + 2 < list.size(); i += 2) {\\n                        for (int j = i + 2; j + 1 < list.size(); j += 2) {\\n                            double dist1 = Math.sqrt(((double)list.get(i)[0] - list.get(j)[0]) * ((double)list.get(i)[0] - list.get(j)[0]) + ((double)list.get(i)[1] - list.get(j)[1]) * ((double)list.get(i)[1] - list.get(j)[1]));\\n                            double dist2 = Math.sqrt(((double)list.get(i)[0] - list.get(j + 1)[0]) * ((double)list.get(i)[0] - list.get(j + 1)[0]) + ((double)list.get(i)[1] - list.get(j + 1)[1]) * ((double)list.get(i)[1] - list.get(j + 1)[1]));\\n                            min = Math.min(dist1 * dist2, min);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Double.MAX_VALUE ? 0 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344351,
                "title": "fast-c-solution-faster-than-94-74-of-c-online-submissions",
                "content": "Runtime: 20 ms, faster than 94.74% of C++ online submissions for Minimum Area Rectangle II.\\nMemory Usage: 14.9 MB, less than 62.34% of C++ online submissions for Minimum Area Rectangle II.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> Point;\\n    //For points a and b, define a < b if and only if\\n    // a.first < b.first or else if a.first == b.first then if a.second < b.second.\\n    inline long ComputeSquareOfDistance(const Point a, const Point b) {\\n        long d1 = a.first - b.first;\\n        long d2 = a.second - b.second;\\n        return d1 * d1 + d2 * d2;\\n    }\\n    inline long ComputeAreaOfRectangle(Point a0, Point a1, Point b0, Point b1) {\\n        long d1 = ComputeSquareOfDistance(a0, a1);\\n        long d2 = ComputeSquareOfDistance(a0, b0);\\n        assert(d1 == ComputeSquareOfDistance(b0, b1));\\n        assert(d2 == ComputeSquareOfDistance(a1, b1));\\n        return sqrt(d1 * d2);\\n    }\\n    //Assumes that a0 <= a1 and b0 <= b1.\\n    inline bool DoesFormRectaangle(Point a0, Point a1, Point b0, Point b1) {\\n        long square_of_diagonal1_dist = ComputeSquareOfDistance(a0, b1);\\n        long square_of_diagonal2_dist = ComputeSquareOfDistance(a1, b0);\\n        return square_of_diagonal1_dist == square_of_diagonal2_dist;\\n    }\\n    inline Point GetVector(Point &p0, Point &p1) {\\n        if (p0.first > p1.first || p0.first == p1.first && p1.first < p0.first)\\n            swap(p0, p1);\\n        return {p1.first - p0.first, p1.second - p0.second};\\n    }\\n    struct PointHash {\\n        size_t operator()(const Point &p) const {\\n            return hash<int>{}(p.first) ^ (hash<int>{}(p.second));\\n        }\\n    };\\n    void FillInVectorToPointsMap(vector<Point>& points, unordered_multimap<Point, pair<Point*, Point*>, PointHash> &vec_to_points) {\\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = i + 1; j < points.size(); ++j) {\\n                Point p0 = points[i], p1 = points[j];\\n                Point vec = GetVector(p0, p1);\\n                //Map vec back to the points that created it, where we insert it\\n                // so that *ptr0 <= *ptr1.\\n                Point * ptr0 = &(points[i]), * ptr1 = &(points[j]);\\n                if (p0 != points[i])\\n                    swap(ptr0, ptr1);\\n                vec_to_points.insert({vec, make_pair(ptr0, ptr1)});\\n            }\\n        }\\n        return ;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        vector<Point> actual_points;\\n        for (const vector<int> &v : points)\\n            actual_points.push_back({v[0], v[1]});\\n        unordered_multimap<Point, pair<Point*, Point*>, PointHash> vec_to_points;\\n        FillInVectorToPointsMap(actual_points, vec_to_points);\\n        double min_area = numeric_limits<double>::max();\\n\\n        while (vec_to_points.size() > 0) {\\n            auto it_start = vec_to_points.begin();\\n            Point vec = it_start->first;\\n            auto range = vec_to_points.equal_range(vec);\\n            if (distance(range.first, range.second) == 1) { //If vec only has 1 pair of points associated with it then move on\\n                vec_to_points.erase(it_start);\\n                continue;\\n            }\\n\\t\\t\\t//We now go through every pair of elements in this range (where each element is a pair of points).\\n            for (auto it = range.first; it != range.second; ) {\\n                auto second_it = it;\\n                ++second_it;\\n                if (second_it == range.second)\\n                    break;\\n                pair<Point *, Point *> a_ptrs = it->second;\\n                Point a0 = *(a_ptrs.first), a1 = *(a_ptrs.second);\\n                for (auto it2 = second_it; it2 != range.second; ++it2) {\\n                    pair<Point *, Point *> b_ptrs = it2->second;\\n                    Point b0 = *(b_ptrs.first), b1 = *(b_ptrs.second);\\n                    if (DoesFormRectaangle(a0, a1, b0, b1)) {\\n                        double area_of_rectangle = ComputeAreaOfRectangle(a0, a1, b0, b1);\\n                        if (area_of_rectangle < min_area)\\n                            min_area = area_of_rectangle;\\n                    }\\n                }\\n                it = second_it;\\n            }\\n            \\n            //Erase the points just considered.\\n            for (auto it = range.first; it != range.second; ) {\\n                auto next_it = it;\\n                ++next_it;\\n                vec_to_points.erase(it);\\n                it = next_it;\\n            }\\n        }\\n        if (min_area == numeric_limits<double>::max())\\n            return 0;\\n        return min_area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> Point;\\n    //For points a and b, define a < b if and only if\\n    // a.first < b.first or else if a.first == b.first then if a.second < b.second.\\n    inline long ComputeSquareOfDistance(const Point a, const Point b) {\\n        long d1 = a.first - b.first;\\n        long d2 = a.second - b.second;\\n        return d1 * d1 + d2 * d2;\\n    }\\n    inline long ComputeAreaOfRectangle(Point a0, Point a1, Point b0, Point b1) {\\n        long d1 = ComputeSquareOfDistance(a0, a1);\\n        long d2 = ComputeSquareOfDistance(a0, b0);\\n        assert(d1 == ComputeSquareOfDistance(b0, b1));\\n        assert(d2 == ComputeSquareOfDistance(a1, b1));\\n        return sqrt(d1 * d2);\\n    }\\n    //Assumes that a0 <= a1 and b0 <= b1.\\n    inline bool DoesFormRectaangle(Point a0, Point a1, Point b0, Point b1) {\\n        long square_of_diagonal1_dist = ComputeSquareOfDistance(a0, b1);\\n        long square_of_diagonal2_dist = ComputeSquareOfDistance(a1, b0);\\n        return square_of_diagonal1_dist == square_of_diagonal2_dist;\\n    }\\n    inline Point GetVector(Point &p0, Point &p1) {\\n        if (p0.first > p1.first || p0.first == p1.first && p1.first < p0.first)\\n            swap(p0, p1);\\n        return {p1.first - p0.first, p1.second - p0.second};\\n    }\\n    struct PointHash {\\n        size_t operator()(const Point &p) const {\\n            return hash<int>{}(p.first) ^ (hash<int>{}(p.second));\\n        }\\n    };\\n    void FillInVectorToPointsMap(vector<Point>& points, unordered_multimap<Point, pair<Point*, Point*>, PointHash> &vec_to_points) {\\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = i + 1; j < points.size(); ++j) {\\n                Point p0 = points[i], p1 = points[j];\\n                Point vec = GetVector(p0, p1);\\n                //Map vec back to the points that created it, where we insert it\\n                // so that *ptr0 <= *ptr1.\\n                Point * ptr0 = &(points[i]), * ptr1 = &(points[j]);\\n                if (p0 != points[i])\\n                    swap(ptr0, ptr1);\\n                vec_to_points.insert({vec, make_pair(ptr0, ptr1)});\\n            }\\n        }\\n        return ;\\n    }\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        vector<Point> actual_points;\\n        for (const vector<int> &v : points)\\n            actual_points.push_back({v[0], v[1]});\\n        unordered_multimap<Point, pair<Point*, Point*>, PointHash> vec_to_points;\\n        FillInVectorToPointsMap(actual_points, vec_to_points);\\n        double min_area = numeric_limits<double>::max();\\n\\n        while (vec_to_points.size() > 0) {\\n            auto it_start = vec_to_points.begin();\\n            Point vec = it_start->first;\\n            auto range = vec_to_points.equal_range(vec);\\n            if (distance(range.first, range.second) == 1) { //If vec only has 1 pair of points associated with it then move on\\n                vec_to_points.erase(it_start);\\n                continue;\\n            }\\n\\t\\t\\t//We now go through every pair of elements in this range (where each element is a pair of points).\\n            for (auto it = range.first; it != range.second; ) {\\n                auto second_it = it;\\n                ++second_it;\\n                if (second_it == range.second)\\n                    break;\\n                pair<Point *, Point *> a_ptrs = it->second;\\n                Point a0 = *(a_ptrs.first), a1 = *(a_ptrs.second);\\n                for (auto it2 = second_it; it2 != range.second; ++it2) {\\n                    pair<Point *, Point *> b_ptrs = it2->second;\\n                    Point b0 = *(b_ptrs.first), b1 = *(b_ptrs.second);\\n                    if (DoesFormRectaangle(a0, a1, b0, b1)) {\\n                        double area_of_rectangle = ComputeAreaOfRectangle(a0, a1, b0, b1);\\n                        if (area_of_rectangle < min_area)\\n                            min_area = area_of_rectangle;\\n                    }\\n                }\\n                it = second_it;\\n            }\\n            \\n            //Erase the points just considered.\\n            for (auto it = range.first; it != range.second; ) {\\n                auto next_it = it;\\n                ++next_it;\\n                vec_to_points.erase(it);\\n                it = next_it;\\n            }\\n        }\\n        if (min_area == numeric_limits<double>::max())\\n            return 0;\\n        return min_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342888,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public double MinAreaFreeRect(int[][] points)\\n    {\\n        if (points.Length < 4) return 0.0;\\n        double result = double.MaxValue;\\n        var dict = new Dictionary<string, List<int[]>>();\\n        for (int i = 0; i < points.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < points.Length; j++)\\n            {\\n                int[] p1 = points[j], p2 = points[i];\\n                double dis = Distance(p1, p2), centerX = (double)(p1[0] + p2[0]) / 2, centerY = (double)(p1[1] + p2[1]) / 2;\\n                var key = dis + \":\" + centerX + \":\" + centerY;\\n                if (!dict.ContainsKey(key)) dict[key] = new List<int[]>();\\n                dict[key].Add(new int[] { i, j });\\n            }\\n        }\\n\\n        foreach (List<int[]> list in dict.Values)\\n        {\\n            for (int i = 0; i < list.Count - 1; i++)                                                                                              \\n            {\\n                for (int j = i + 1; j < list.Count; j++)\\n                {\\n                    int p1 = list[i][0], p2 = list[j][0], p3 = list[j][1];\\n                    result = Math.Min(result, Distance(points[p1], points[p2]) * Distance(points[p1], points[p3]));\\n                }\\n            }\\n        }\\n\\n        return result == double.MaxValue ? 0.0 : result;\\n    }\\n\\n    private double Distance(int[] p1, int[] p2)\\n    {\\n        return Math.Sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public double MinAreaFreeRect(int[][] points)\\n    {\\n        if (points.Length < 4) return 0.0;\\n        double result = double.MaxValue;\\n        var dict = new Dictionary<string, List<int[]>>();\\n        for (int i = 0; i < points.Length - 1; i++)\\n        {\\n            for (int j = i + 1; j < points.Length; j++)\\n            {\\n                int[] p1 = points[j], p2 = points[i];\\n                double dis = Distance(p1, p2), centerX = (double)(p1[0] + p2[0]) / 2, centerY = (double)(p1[1] + p2[1]) / 2;\\n                var key = dis + \":\" + centerX + \":\" + centerY;\\n                if (!dict.ContainsKey(key)) dict[key] = new List<int[]>();\\n                dict[key].Add(new int[] { i, j });\\n            }\\n        }\\n\\n        foreach (List<int[]> list in dict.Values)\\n        {\\n            for (int i = 0; i < list.Count - 1; i++)                                                                                              \\n            {\\n                for (int j = i + 1; j < list.Count; j++)\\n                {\\n                    int p1 = list[i][0], p2 = list[j][0], p3 = list[j][1];\\n                    result = Math.Min(result, Distance(points[p1], points[p2]) * Distance(points[p1], points[p3]));\\n                }\\n            }\\n        }\\n\\n        return result == double.MaxValue ? 0.0 : result;\\n    }\\n\\n    private double Distance(int[] p1, int[] p2)\\n    {\\n        return Math.Sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248447,
                "title": "java-solution-slow-and-clean",
                "content": "```\\nclass Solution {\\n    private double minArea = Double.MAX_VALUE;\\n    \\n    public double minAreaFreeRect(int[][] points) {\\n        minAreaRectHelper(points, new ArrayList<Point>(), 0);\\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    private void minAreaRectHelper(int[][] points, List<Point> pointList, int i) {\\n        if (pointList.size() == 4) {\\n            double area = area(pointList);\\n            if (area > 0) {\\n                minArea = Math.min(minArea, area);\\n            }\\n            return;\\n        }\\n        if (i == points.length) {\\n            return;\\n        }\\n        \\n        for (int j = i; j < points.length; j++) {\\n            pointList.add(new Point(points[j][0], points[j][1]));\\n            minAreaRectHelper(points, pointList, j + 1);\\n            pointList.remove(pointList.size() - 1);\\n        }\\n    }\\n    \\n    private double area(List<Point> points) {\\n        Map<Integer, Integer> mapX = new HashMap<>();\\n        Map<Integer, Integer> mapY = new HashMap<>();\\n        \\n        // There shouldn\\'t be more than 2 points on a straight line\\n        for (Point point : points) {\\n            int valX = mapX.containsKey(point.x) ? mapX.get(point.x) : 0;\\n            int valY = mapY.containsKey(point.y) ? mapY.get(point.y) : 0;\\n            if (valX == 2 || valY == 2) {\\n                return 0;\\n            }\\n            mapX.put(point.x, valX + 1);\\n            mapY.put(point.y, valY + 1);\\n        }\\n        \\n        List<Double> distances = new ArrayList<>();\\n        \\n        for (int i = 0; i < points.size() - 1; i++) {\\n            for (int j = i + 1; j < points.size(); j++) {\\n                double distance = distance(points.get(i), points.get(j));\\n                if (!distances.contains(distance)) {\\n                    distances.add(distance);\\n                }\\n            }\\n        }\\n        \\n        Collections.sort(distances);\\n        \\n        // There should not be more than 3 distinct distances (length, breadth, diagonal)\\n        if (distances.size() > 3) {\\n            return 0;\\n        }\\n        // Square\\n        if (distances.size() == 2 && ((distances.get(0) * 2) == distances.get(1))) {\\n            return distances.get(0);\\n        }\\n        // Non-square Rectangle\\n        if (distances.size() == 3 && (distances.get(0) + distances.get(1) == distances.get(2))) {\\n            return Math.sqrt(distances.get(0)) * Math.sqrt(distances.get(1));\\n        }\\n        return 0;\\n    }\\n    \\n    private double distance(Point p1, Point p2) {\\n        int diffX = Math.abs(p1.x - p2.x);\\n        int diffY = Math.abs(p1.y - p2.y);\\n        return Math.pow(diffX, 2) + Math.pow(diffY, 2);\\n    }\\n}\\n\\nclass Point {\\n    int x;\\n    int y;\\n    \\n    Point(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```\\n\\n**A Better and Faster Solution**\\nhttps://leetcode.com/problems/minimum-area-rectangle-ii/discuss/209117/Short-Java-Solution-!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private double minArea = Double.MAX_VALUE;\\n    \\n    public double minAreaFreeRect(int[][] points) {\\n        minAreaRectHelper(points, new ArrayList<Point>(), 0);\\n        return minArea == Double.MAX_VALUE ? 0 : minArea;\\n    }\\n    \\n    private void minAreaRectHelper(int[][] points, List<Point> pointList, int i) {\\n        if (pointList.size() == 4) {\\n            double area = area(pointList);\\n            if (area > 0) {\\n                minArea = Math.min(minArea, area);\\n            }\\n            return;\\n        }\\n        if (i == points.length) {\\n            return;\\n        }\\n        \\n        for (int j = i; j < points.length; j++) {\\n            pointList.add(new Point(points[j][0], points[j][1]));\\n            minAreaRectHelper(points, pointList, j + 1);\\n            pointList.remove(pointList.size() - 1);\\n        }\\n    }\\n    \\n    private double area(List<Point> points) {\\n        Map<Integer, Integer> mapX = new HashMap<>();\\n        Map<Integer, Integer> mapY = new HashMap<>();\\n        \\n        // There shouldn\\'t be more than 2 points on a straight line\\n        for (Point point : points) {\\n            int valX = mapX.containsKey(point.x) ? mapX.get(point.x) : 0;\\n            int valY = mapY.containsKey(point.y) ? mapY.get(point.y) : 0;\\n            if (valX == 2 || valY == 2) {\\n                return 0;\\n            }\\n            mapX.put(point.x, valX + 1);\\n            mapY.put(point.y, valY + 1);\\n        }\\n        \\n        List<Double> distances = new ArrayList<>();\\n        \\n        for (int i = 0; i < points.size() - 1; i++) {\\n            for (int j = i + 1; j < points.size(); j++) {\\n                double distance = distance(points.get(i), points.get(j));\\n                if (!distances.contains(distance)) {\\n                    distances.add(distance);\\n                }\\n            }\\n        }\\n        \\n        Collections.sort(distances);\\n        \\n        // There should not be more than 3 distinct distances (length, breadth, diagonal)\\n        if (distances.size() > 3) {\\n            return 0;\\n        }\\n        // Square\\n        if (distances.size() == 2 && ((distances.get(0) * 2) == distances.get(1))) {\\n            return distances.get(0);\\n        }\\n        // Non-square Rectangle\\n        if (distances.size() == 3 && (distances.get(0) + distances.get(1) == distances.get(2))) {\\n            return Math.sqrt(distances.get(0)) * Math.sqrt(distances.get(1));\\n        }\\n        return 0;\\n    }\\n    \\n    private double distance(Point p1, Point p2) {\\n        int diffX = Math.abs(p1.x - p2.x);\\n        int diffY = Math.abs(p1.y - p2.y);\\n        return Math.pow(diffX, 2) + Math.pow(diffY, 2);\\n    }\\n}\\n\\nclass Point {\\n    int x;\\n    int y;\\n    \\n    Point(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245769,
                "title": "o-n-3-method-c",
                "content": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nstruct myHash \\n{\\n    size_t operator()(pair<int, int> __val) const\\n    {\\n        return static_cast<size_t>(__val.first * 101 + __val.second);\\n    }\\n};\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        //\\u8FD9\\u9898\\u7684question \\u662F\\u7ED9\\u4F60\\u4E00\\u4E9B\\u70B9,\\u5982\\u4F55\\u627E\\u5230\\u6700\\u5C0F\\u7684\\u77E9\\u5F62\\u5462,\\u8FD9\\u4E2A\\u95EE\\u9898,\\u6709\\u70B9\\u96BE,\\u9700\\u8981\\u6211\\u4EEC\\u82B1\\u5927\\u91CF\\u7684\\u65F6\\u95F4\\u53BB\\u601D\\u8003\\u95EE\\u9898.\\n        //\\u5982\\u4F55\\u505A\\u5230\\u4E00\\u4E2A\\u6280\\u672F\\u7537\\u662F\\u4E00\\u79CD\\u5B66\\u95EE\\n        //\\u8003\\u8651\\u5230\\u4E00\\u4E2A\\u5E73\\u884C\\u56DB\\u8FB9\\u5F62\\u95EE\\u9898,\\n        //\\u6211\\u4EEC\\u6709   \\u5BF9\\u4E8E\\u5BF9\\u9876\\u70B9(p2,p3) and (p1,p4) \\u6211\\u4EEC\\u6709 p1+p4 = p2+p3  \\u53EF\\u4EE5\\u4ECE\\u5411\\u91CF\\u89D2\\u5EA6\\u6765\\u89E3\\u91CA p4 = p2+p3-p1\\n        // \\u5224\\u65AD\\u6211\\u4EEC\\u7684\\u811A\\u662F\\u5426\\u662F\\u76F4\\u89D2\\u7684\\u64CD\\u4F5C,\\u4E5F\\u975E\\u5E38\\u7684\\u65B9\\u4FBF\\u6211\\u4EEC\\u53EA\\u9700\\u5224\\u65AD,(p2-p1).(p3-p1) = 0 \\u5373\\u53EF\\n        // \\u5176\\u4ED6\\u7684\\u65B9\\u6CD5\\u662F\\u5173\\u4E8Eiterate centers\\n        //key1  --->  radicus   key2--->center  val-----> all point satisfied this question\\n        \\n        int N = points.size();\\n        \\n        unordered_set<pair<int,int>,myHash > sets;\\n        for(int i = 0;i<N;i++)\\n        {\\n            sets.insert(pair<int,int>(points[i][0],points[i][1]));\\n        }\\n        double ans = INT_MAX;\\n        //fix one point the other points is oppsite point\\n        for(int  i = 0;i<N;i++)\\n        {\\n            auto p1 = pair<int,int>(points[i][0],points[i][1]);\\n            for(int j = 0;j<N;j++)\\n            {\\n                if(j==i)\\n                    continue;\\n                auto p2 = pair<int,int>(points[j][0],points[j][1]);\\n                for(int k = j+1;k<N;k++)\\n                {\\n                    if(k ==i)\\n                    {\\n                        continue;\\n                    }\\n                    auto p3 = pair<int,int>(points[k][0],points[k][1]);\\n                    pair<int,int> p4;\\n                    p4.first = p2.first+p3.first-p1.first;\\n                    p4.second = p2.second+p3.second-p1.second;\\n                    //\\u6784\\u6210\\u5E73\\u884C\\u56DB\\u8FB9\\u5F62\\n                    if(sets.count(p4))\\n                    {\\n                        pair<int,int> l1,l2;\\n                        l1.first = p1.first-p2.first;\\n                        l2.first = p1.first-p3.first;\\n                        l1.second = p1.second-p2.second;\\n                        l2.second = p1.second-p3.second;\\n                        int degree = l1.first*l2.first+l1.second*l2.second;\\n                        if(degree == 0)\\n                        {\\n                            double area = longth(l1)*longth(l2);\\n                            ans = ans>area?area:ans;\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans == INT_MAX?0:ans;\\n    }\\n    double longth(pair<int,int> & x)\\n    {\\n        return sqrt(x.first*x.first+x.second*x.second);\\n    }\\n        \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nstruct myHash \\n{\\n    size_t operator()(pair<int, int> __val) const\\n    {\\n        return static_cast<size_t>(__val.first * 101 + __val.second);\\n    }\\n};\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        //\\u8FD9\\u9898\\u7684question \\u662F\\u7ED9\\u4F60\\u4E00\\u4E9B\\u70B9,\\u5982\\u4F55\\u627E\\u5230\\u6700\\u5C0F\\u7684\\u77E9\\u5F62\\u5462,\\u8FD9\\u4E2A\\u95EE\\u9898,\\u6709\\u70B9\\u96BE,\\u9700\\u8981\\u6211\\u4EEC\\u82B1\\u5927\\u91CF\\u7684\\u65F6\\u95F4\\u53BB\\u601D\\u8003\\u95EE\\u9898.\\n        //\\u5982\\u4F55\\u505A\\u5230\\u4E00\\u4E2A\\u6280\\u672F\\u7537\\u662F\\u4E00\\u79CD\\u5B66\\u95EE\\n        //\\u8003\\u8651\\u5230\\u4E00\\u4E2A\\u5E73\\u884C\\u56DB\\u8FB9\\u5F62\\u95EE\\u9898,\\n        //\\u6211\\u4EEC\\u6709   \\u5BF9\\u4E8E\\u5BF9\\u9876\\u70B9(p2,p3) and (p1,p4) \\u6211\\u4EEC\\u6709 p1+p4 = p2+p3  \\u53EF\\u4EE5\\u4ECE\\u5411\\u91CF\\u89D2\\u5EA6\\u6765\\u89E3\\u91CA p4 = p2+p3-p1\\n        // \\u5224\\u65AD\\u6211\\u4EEC\\u7684\\u811A\\u662F\\u5426\\u662F\\u76F4\\u89D2\\u7684\\u64CD\\u4F5C,\\u4E5F\\u975E\\u5E38\\u7684\\u65B9\\u4FBF\\u6211\\u4EEC\\u53EA\\u9700\\u5224\\u65AD,(p2-p1).(p3-p1) = 0 \\u5373\\u53EF\\n        // \\u5176\\u4ED6\\u7684\\u65B9\\u6CD5\\u662F\\u5173\\u4E8Eiterate centers\\n        //key1  --->  radicus   key2--->center  val-----> all point satisfied this question\\n        \\n        int N = points.size();\\n        \\n        unordered_set<pair<int,int>,myHash > sets;\\n        for(int i = 0;i<N;i++)\\n        {\\n            sets.insert(pair<int,int>(points[i][0],points[i][1]));\\n        }\\n        double ans = INT_MAX;\\n        //fix one point the other points is oppsite point\\n        for(int  i = 0;i<N;i++)\\n        {\\n            auto p1 = pair<int,int>(points[i][0],points[i][1]);\\n            for(int j = 0;j<N;j++)\\n            {\\n                if(j==i)\\n                    continue;\\n                auto p2 = pair<int,int>(points[j][0],points[j][1]);\\n                for(int k = j+1;k<N;k++)\\n                {\\n                    if(k ==i)\\n                    {\\n                        continue;\\n                    }\\n                    auto p3 = pair<int,int>(points[k][0],points[k][1]);\\n                    pair<int,int> p4;\\n                    p4.first = p2.first+p3.first-p1.first;\\n                    p4.second = p2.second+p3.second-p1.second;\\n                    //\\u6784\\u6210\\u5E73\\u884C\\u56DB\\u8FB9\\u5F62\\n                    if(sets.count(p4))\\n                    {\\n                        pair<int,int> l1,l2;\\n                        l1.first = p1.first-p2.first;\\n                        l2.first = p1.first-p3.first;\\n                        l1.second = p1.second-p2.second;\\n                        l2.second = p1.second-p3.second;\\n                        int degree = l1.first*l2.first+l1.second*l2.second;\\n                        if(degree == 0)\\n                        {\\n                            double area = longth(l1)*longth(l2);\\n                            ans = ans>area?area:ans;\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans == INT_MAX?0:ans;\\n    }\\n    double longth(pair<int,int> & x)\\n    {\\n        return sqrt(x.first*x.first+x.second*x.second);\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228883,
                "title": "java-map-solution",
                "content": "s1 -> use y/x as the key\\ns2 -> use what\\'s mentioned in Solution Section, the mid of two points as the key;\\nremember to use Long, as Int will overflow.\\n```\\nclass Solution {\\n\\n    // i != j\\n    private String getKey(int i, int j) {\\n        if (i == 0) {\\n            return \"NaN\";\\n        }\\n        if (j == 0) {\\n            return \"0\";\\n        }\\n        boolean flag = true;\\n        if (i < 0) {\\n            i = -i;\\n            flag = !flag;\\n        }\\n        if (j < 0) {\\n            j = -j;\\n            flag = !flag;\\n        }\\n        int gcd = gcd(i, j);\\n        i = i / gcd;\\n        j = j / gcd;\\n        StringBuilder sb = new StringBuilder();\\n        if (!flag) {\\n            sb.append(\"-\");\\n        }\\n        sb.append(i);\\n        sb.append(\",\");\\n        sb.append(j);\\n        return sb.toString();\\n\\n    }\\n\\n    private int gcd(int i, int j) {\\n        while (j != 0) {\\n            int tmp = j;\\n            j = i % j;\\n            i = tmp;\\n        }\\n        return i;\\n    }\\n\\n    public double minAreaFreeRect(int[][] points) {\\n        return s2(points);\\n    }\\n    \\n    private String getKey2(int[] point1, int[] point2) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(point1[0] + point2[0]);\\n        sb.append(\",\");\\n        sb.append(point1[1] + point2[1]);\\n        return sb.toString();\\n    }\\n    \\n    private double s2(int[][] points) {\\n        if (points.length < 4) {\\n            return 0;\\n        }\\n        Map<String, Map<Long, List<int[]>>> maps = new HashMap<>();\\n        for (int i = 0; i < points.length - 1; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                if (!equal(points[i], points[j])) {\\n                    String key = getKey2(points[i], points[j]);\\n                    long innerKey = dis(points[i], points[j]);\\n                    if (!maps.containsKey(key)) {\\n                        maps.put(key, new HashMap<>());\\n                    }\\n                    if (!maps.get(key).containsKey(innerKey)) {\\n                        maps.get(key).put(innerKey, new ArrayList<>());\\n                    }\\n                    maps.get(key).get(innerKey).add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        double max = 0;\\n        for (Map<Long, List<int[]>> map : maps.values()) {\\n            for (List<int[]> list : map.values()) {\\n                for (int i = 0; i < list.size() - 1; i++) {\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        // list.get(i)[0], list.get(i)[1]\\n                        // list.get(j)[0], list.get(j)[1]\\n\\n                        if (!equal(points[list.get(i)[0]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[0]], points[list.get(j)[1]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[1]])) {\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(j)[1]], points[list.get(j)[0]])) {\\n                                double area = Math.sqrt(dis(points[list.get(i)[0]], points[list.get(j)[1]]) * dis(points[list.get(i)[0]], points[list.get(j)[0]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n\\n\\n        }\\n        return max;\\n    }\\n\\n    private double s1(int[][] points) {\\n        if (points.length < 4) {\\n            return 0;\\n        }\\n\\n        Map<String, Map<Long, List<int[]>>> maps = new HashMap<>();\\n        for (int i = 0; i < points.length - 1; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                if (!equal(points[i], points[j])) {\\n                    String key = getKey(points[j][0] - points[i][0], points[j][1] - points[i][1]);\\n                    long innerKey = dis(points[i], points[j]);\\n                    if (!maps.containsKey(key)) {\\n                        maps.put(key, new HashMap<>());\\n                    }\\n                    if (!maps.get(key).containsKey(innerKey)) {\\n                        maps.get(key).put(innerKey, new ArrayList<>());\\n                    }\\n                    maps.get(key).get(innerKey).add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        double max = 0;\\n        for (Map<Long, List<int[]>> map : maps.values()) {\\n            for (Map.Entry<Long, List<int[]>> entry : map.entrySet()) {\\n                Long key = entry.getKey();\\n                List<int[]> list = entry.getValue();\\n                for (int i = 0; i < list.size() - 1; i++) {\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        // list.get(i)[0], list.get(i)[1]\\n                        // list.get(j)[0], list.get(j)[1]\\n\\n                        if (!equal(points[list.get(i)[0]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[0]], points[list.get(j)[1]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[1]])) {\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                    isVertical(points[list.get(i)[1]], points[list.get(i)[0]], points[list.get(j)[1]])) {\\n                                double area = Math.sqrt(key * dis(points[list.get(i)[0]], points[list.get(j)[0]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(i)[1]], points[list.get(j)[1]]) &&\\n                                    isVertical(points[list.get(i)[1]], points[list.get(i)[0]], points[list.get(j)[0]])) {\\n                                double area = Math.sqrt(key * dis(points[list.get(i)[0]], points[list.get(j)[1]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n\\n\\n        }\\n        return max;\\n    }\\n\\n    private boolean isVertical(int[] point1, int[] point2, int[] point3) {\\n        int[] vector12 = new int[] {point2[0] - point1[0], point2[1] - point1[1]};\\n        int[] vector13 = new int[] {point3[0] - point1[0], point3[1] - point1[1]};\\n        return vector12[0] * vector13[0] + vector12[1] * vector13[1] == 0;\\n    }\\n\\n    private boolean equal(int[] point1, int[] point2) {\\n        return point1[0] == point2[0] && point1[1] == point2[1];\\n    }\\n\\n    private long dis(int[] point1, int[] point2) {\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    // i != j\\n    private String getKey(int i, int j) {\\n        if (i == 0) {\\n            return \"NaN\";\\n        }\\n        if (j == 0) {\\n            return \"0\";\\n        }\\n        boolean flag = true;\\n        if (i < 0) {\\n            i = -i;\\n            flag = !flag;\\n        }\\n        if (j < 0) {\\n            j = -j;\\n            flag = !flag;\\n        }\\n        int gcd = gcd(i, j);\\n        i = i / gcd;\\n        j = j / gcd;\\n        StringBuilder sb = new StringBuilder();\\n        if (!flag) {\\n            sb.append(\"-\");\\n        }\\n        sb.append(i);\\n        sb.append(\",\");\\n        sb.append(j);\\n        return sb.toString();\\n\\n    }\\n\\n    private int gcd(int i, int j) {\\n        while (j != 0) {\\n            int tmp = j;\\n            j = i % j;\\n            i = tmp;\\n        }\\n        return i;\\n    }\\n\\n    public double minAreaFreeRect(int[][] points) {\\n        return s2(points);\\n    }\\n    \\n    private String getKey2(int[] point1, int[] point2) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(point1[0] + point2[0]);\\n        sb.append(\",\");\\n        sb.append(point1[1] + point2[1]);\\n        return sb.toString();\\n    }\\n    \\n    private double s2(int[][] points) {\\n        if (points.length < 4) {\\n            return 0;\\n        }\\n        Map<String, Map<Long, List<int[]>>> maps = new HashMap<>();\\n        for (int i = 0; i < points.length - 1; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                if (!equal(points[i], points[j])) {\\n                    String key = getKey2(points[i], points[j]);\\n                    long innerKey = dis(points[i], points[j]);\\n                    if (!maps.containsKey(key)) {\\n                        maps.put(key, new HashMap<>());\\n                    }\\n                    if (!maps.get(key).containsKey(innerKey)) {\\n                        maps.get(key).put(innerKey, new ArrayList<>());\\n                    }\\n                    maps.get(key).get(innerKey).add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        double max = 0;\\n        for (Map<Long, List<int[]>> map : maps.values()) {\\n            for (List<int[]> list : map.values()) {\\n                for (int i = 0; i < list.size() - 1; i++) {\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        // list.get(i)[0], list.get(i)[1]\\n                        // list.get(j)[0], list.get(j)[1]\\n\\n                        if (!equal(points[list.get(i)[0]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[0]], points[list.get(j)[1]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[1]])) {\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(j)[1]], points[list.get(j)[0]])) {\\n                                double area = Math.sqrt(dis(points[list.get(i)[0]], points[list.get(j)[1]]) * dis(points[list.get(i)[0]], points[list.get(j)[0]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n\\n\\n        }\\n        return max;\\n    }\\n\\n    private double s1(int[][] points) {\\n        if (points.length < 4) {\\n            return 0;\\n        }\\n\\n        Map<String, Map<Long, List<int[]>>> maps = new HashMap<>();\\n        for (int i = 0; i < points.length - 1; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                if (!equal(points[i], points[j])) {\\n                    String key = getKey(points[j][0] - points[i][0], points[j][1] - points[i][1]);\\n                    long innerKey = dis(points[i], points[j]);\\n                    if (!maps.containsKey(key)) {\\n                        maps.put(key, new HashMap<>());\\n                    }\\n                    if (!maps.get(key).containsKey(innerKey)) {\\n                        maps.get(key).put(innerKey, new ArrayList<>());\\n                    }\\n                    maps.get(key).get(innerKey).add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        double max = 0;\\n        for (Map<Long, List<int[]>> map : maps.values()) {\\n            for (Map.Entry<Long, List<int[]>> entry : map.entrySet()) {\\n                Long key = entry.getKey();\\n                List<int[]> list = entry.getValue();\\n                for (int i = 0; i < list.size() - 1; i++) {\\n                    for (int j = i + 1; j < list.size(); j++) {\\n                        // list.get(i)[0], list.get(i)[1]\\n                        // list.get(j)[0], list.get(j)[1]\\n\\n                        if (!equal(points[list.get(i)[0]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                !equal(points[list.get(i)[0]], points[list.get(j)[1]]) &&\\n                                !equal(points[list.get(i)[1]], points[list.get(j)[1]])) {\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(i)[1]], points[list.get(j)[0]]) &&\\n                                    isVertical(points[list.get(i)[1]], points[list.get(i)[0]], points[list.get(j)[1]])) {\\n                                double area = Math.sqrt(key * dis(points[list.get(i)[0]], points[list.get(j)[0]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                            if (isVertical(points[list.get(i)[0]], points[list.get(i)[1]], points[list.get(j)[1]]) &&\\n                                    isVertical(points[list.get(i)[1]], points[list.get(i)[0]], points[list.get(j)[0]])) {\\n                                double area = Math.sqrt(key * dis(points[list.get(i)[0]], points[list.get(j)[1]]));\\n                                if (max == 0 || max > area) {\\n                                    max = area;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n            }\\n\\n\\n        }\\n        return max;\\n    }\\n\\n    private boolean isVertical(int[] point1, int[] point2, int[] point3) {\\n        int[] vector12 = new int[] {point2[0] - point1[0], point2[1] - point1[1]};\\n        int[] vector13 = new int[] {point3[0] - point1[0], point3[1] - point1[1]};\\n        return vector12[0] * vector13[0] + vector12[1] * vector13[1] == 0;\\n    }\\n\\n    private boolean equal(int[] point1, int[] point2) {\\n        return point1[0] == point2[0] && point1[1] == point2[1];\\n    }\\n\\n    private long dis(int[] point1, int[] point2) {\\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227259,
                "title": "python-o-n-2",
                "content": "\\tdef minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        n = len(points)\\n        d = collections.defaultdict(list)\\n        \\n        for i in range(n - 1):\\n            pi = points[i]\\n            for j in range(i + 1, n):\\n                pj = points[j]\\n                length = ((pi[0] - pj[0]) ** 2) + ((pi[1] - pj[1]) ** 2)\\n                cx = (pi[0] + pj[0]) / 2.0\\n                cy = (pi[1] + pj[1]) / 2.0\\n                d[(length, cx, cy)].append((i, j))\\n        \\n        res = float(\"inf\")\\n        for ls in d.values():\\n            length = len(ls)\\n            for i in range(length - 1):\\n                p0, p2 = points[ls[i][0]], points[ls[i][1]]\\n                for j in range(i + 1, length):\\n                    p1, p3 = points[ls[j][0]], points[ls[j][1]]\\n                    d1 = math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\\n                    d2 = math.sqrt((p0[0] - p3[0]) ** 2 + (p0[1] - p3[1]) ** 2)\\n                    res = min(res, d1 * d2)\\n        \\n        return res if res != float(\"inf\") else 0",
                "solutionTags": [],
                "code": "\\tdef minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        n = len(points)\\n        d = collections.defaultdict(list)\\n        \\n        for i in range(n - 1):\\n            pi = points[i]\\n            for j in range(i + 1, n):\\n                pj = points[j]\\n                length = ((pi[0] - pj[0]) ** 2) + ((pi[1] - pj[1]) ** 2)\\n                cx = (pi[0] + pj[0]) / 2.0\\n                cy = (pi[1] + pj[1]) / 2.0\\n                d[(length, cx, cy)].append((i, j))\\n        \\n        res = float(\"inf\")\\n        for ls in d.values():\\n            length = len(ls)\\n            for i in range(length - 1):\\n                p0, p2 = points[ls[i][0]], points[ls[i][1]]\\n                for j in range(i + 1, length):\\n                    p1, p3 = points[ls[j][0]], points[ls[j][1]]\\n                    d1 = math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\\n                    d2 = math.sqrt((p0[0] - p3[0]) ** 2 + (p0[1] - p3[1]) ** 2)\\n                    res = min(res, d1 * d2)\\n        \\n        return res if res != float(\"inf\") else 0",
                "codeTag": "Python3"
            },
            {
                "id": 214704,
                "title": "python-two-methods-straightforward-o-n-3-and-record-center-o-n-2-log-n",
                "content": "Starightforward O(N^3)\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = set(map(tuple, points))\\n        ans = float(\\'inf\\')\\n        \\n        for p1, p2, p3 in itertools.combinations(points, 3):\\n            p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1]\\n            if p4 in points and self.checkAngle(p1, p2, p3):\\n                area = self.getArea(p1, p2, p3)\\n                if area < ans:\\n                    ans = area\\n        return ans if ans < float(\\'inf\\') else 0\\n    \\n    def checkAngle(self, p1, p2, p3):\\n        vec21 = p2[0] - p1[0], p2[1] - p1[1]\\n        vec31 = p3[0] - p1[0], p3[1] - p1[1]\\n        return vec21[0] * vec31[0] + vec21[1] * vec31[1] == 0\\n    \\n    def getArea(self, p1, p2, p3):\\n        len21 = ((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)**0.5\\n        len31 = ((p3[0] - p1[0])**2 + (p3[1] - p1[1])**2)**0.5\\n        return len21*len31\\n```\\n\\nRecord centers seen\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = [complex(*p) for p in points]\\n        seen = collections.defaultdict(list)\\n        for P, Q in itertools.combinations(points, 2):\\n            center = (P + Q) / 2\\n            radius = abs(center - P)\\n            seen[center, radius].append(P)\\n            \\n        ans = float(\\'inf\\')\\n        for (center, radius), candidates in seen.items():\\n            for P, Q in itertools.combinations(candidates, 2):\\n                ans = min(ans, abs(P - Q) * abs(P - (2*center - Q)))\\n        return ans if ans < float(\\'inf\\') else 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = set(map(tuple, points))\\n        ans = float(\\'inf\\')\\n        \\n        for p1, p2, p3 in itertools.combinations(points, 3):\\n            p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1]\\n            if p4 in points and self.checkAngle(p1, p2, p3):\\n                area = self.getArea(p1, p2, p3)\\n                if area < ans:\\n                    ans = area\\n        return ans if ans < float(\\'inf\\') else 0\\n    \\n    def checkAngle(self, p1, p2, p3):\\n        vec21 = p2[0] - p1[0], p2[1] - p1[1]\\n        vec31 = p3[0] - p1[0], p3[1] - p1[1]\\n        return vec21[0] * vec31[0] + vec21[1] * vec31[1] == 0\\n    \\n    def getArea(self, p1, p2, p3):\\n        len21 = ((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)**0.5\\n        len31 = ((p3[0] - p1[0])**2 + (p3[1] - p1[1])**2)**0.5\\n        return len21*len31\\n```\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        points = [complex(*p) for p in points]\\n        seen = collections.defaultdict(list)\\n        for P, Q in itertools.combinations(points, 2):\\n            center = (P + Q) / 2\\n            radius = abs(center - P)\\n            seen[center, radius].append(P)\\n            \\n        ans = float(\\'inf\\')\\n        for (center, radius), candidates in seen.items():\\n            for P, Q in itertools.combinations(candidates, 2):\\n                ans = min(ans, abs(P - Q) * abs(P - (2*center - Q)))\\n        return ans if ans < float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210350,
                "title": "python-faster-than-72-73",
                "content": "https://blog.csdn.net/fuxuemingzhu/article/details/85223775\\n\\t \\'\\'\\'\\n\\t  from collections import defaultdict\\n        \\n        dict=defaultdict(list)\\n        \\n        for i,(x1,y1) in enumerate(points[:-1]):\\n            for j,(x2,y2) in enumerate(points[i+1:],i+1):\\n                \\n                l=(y2-y1)**2+(x2-x1)**2\\n                x=(x1+x2)/2\\n                y=(y1+y2)/2\\n                \\n                dict[(l,x,y)].append((x1,y1,x2,y2))\\n                \\n        res=1<<30\\n        for elem in dict.values():\\n            if len(elem)<=1:\\n                continue\\n            for i,(x1,y1,x2,y2) in enumerate(elem[:-1]):\\n                for j,(x11,y11,x22,y22) in enumerate(elem[i+1:],i+1):\\n                    d=(y11-y1)**2.0+(x11-x1)**2.0\\n                    h1=(y2-y11)**2.0+(x2-x11)**2.0\\n                    h2=(y22-y11)**2.0+(x22-x11)**2.0\\n                    h=min(h1,h2)\\n                    area=(d*h)**0.5\\n                    res=min(res,area)\\n                        \\n        return(res if res<1<<30 else 0)",
                "solutionTags": [],
                "code": "https://blog.csdn.net/fuxuemingzhu/article/details/85223775\\n\\t \\'\\'\\'\\n\\t  from collections import defaultdict\\n        \\n        dict=defaultdict(list)\\n        \\n        for i,(x1,y1) in enumerate(points[:-1]):\\n            for j,(x2,y2) in enumerate(points[i+1:],i+1):\\n                \\n                l=(y2-y1)**2+(x2-x1)**2\\n                x=(x1+x2)/2\\n                y=(y1+y2)/2\\n                \\n                dict[(l,x,y)].append((x1,y1,x2,y2))\\n                \\n        res=1<<30\\n        for elem in dict.values():\\n            if len(elem)<=1:\\n                continue\\n            for i,(x1,y1,x2,y2) in enumerate(elem[:-1]):\\n                for j,(x11,y11,x22,y22) in enumerate(elem[i+1:],i+1):\\n                    d=(y11-y1)**2.0+(x11-x1)**2.0\\n                    h1=(y2-y11)**2.0+(x2-x11)**2.0\\n                    h2=(y22-y11)**2.0+(x22-x11)**2.0\\n                    h=min(h1,h2)\\n                    area=(d*h)**0.5\\n                    res=min(res,area)\\n                        \\n        return(res if res<1<<30 else 0)",
                "codeTag": "Python3"
            },
            {
                "id": 210126,
                "title": "java-o-n-2-grouping-pairs-with-diagonal",
                "content": "A diagonal contains the centroid location of two points, and the length (distance between two points) of this diagonal.\\nTwo pairs sharing the same diagonal will be able to make a rectangle.\\n\\n```\\nclass Solution {\\n\\n    public static class Diagonal {\\n\\n        double len;\\n        double x;\\n        double y;\\n        public Diagonal(int x1, int y1, int x2, int y2) {\\n            this.len = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n            this.x = (x1 + x2) / 2d;\\n            this.y = (y1 + y2) / 2d;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (!(o instanceof Diagonal)) return false;\\n\\n            Diagonal diagonal = (Diagonal) o;\\n\\n            if (Double.compare(diagonal.len, len) != 0) return false;\\n            if (Double.compare(diagonal.x, x) != 0) return false;\\n            return Double.compare(diagonal.y, y) == 0;\\n\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            int result;\\n            long temp;\\n            temp = Double.doubleToLongBits(len);\\n            result = (int) (temp ^ (temp >>> 32));\\n            temp = Double.doubleToLongBits(x);\\n            result = 31 * result + (int) (temp ^ (temp >>> 32));\\n            temp = Double.doubleToLongBits(y);\\n            result = 31 * result + (int) (temp ^ (temp >>> 32));\\n            return result;\\n        }\\n    }\\n\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Diagonal, List<int[]>> map = new HashMap<>();\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                Diagonal diagonal = new Diagonal(x1, y1, x2, y2);\\n                map.putIfAbsent(diagonal, new ArrayList<>());\\n                map.get(diagonal).add(new int[]{ x1, y1, x2, y2 });\\n            }\\n        }\\n        double min = Integer.MAX_VALUE;\\n        for (Diagonal diagonal : map.keySet()) {\\n            List<int[]> ls = map.get(diagonal);\\n            for (int i = 0; i < ls.size(); i++) {\\n                for (int j = i + 1; j < ls.size(); j++) {\\n                    int[] p1 = ls.get(i);\\n                    int[] p2 = ls.get(j);\\n                    min = Math.min(min, area(p1[0], p1[1], p1[2], p1[3], p2[0], p2[1], p2[2], p2[3]));\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? 0d : min;\\n    }\\n\\n    private double area(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\\n        double width = distance(x1, y1, x3, y3);\\n        double height = distance(x1, y1, x4, y4);\\n        return width * height;\\n    }\\n\\n    private double distance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public static class Diagonal {\\n\\n        double len;\\n        double x;\\n        double y;\\n        public Diagonal(int x1, int y1, int x2, int y2) {\\n            this.len = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n            this.x = (x1 + x2) / 2d;\\n            this.y = (y1 + y2) / 2d;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (!(o instanceof Diagonal)) return false;\\n\\n            Diagonal diagonal = (Diagonal) o;\\n\\n            if (Double.compare(diagonal.len, len) != 0) return false;\\n            if (Double.compare(diagonal.x, x) != 0) return false;\\n            return Double.compare(diagonal.y, y) == 0;\\n\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            int result;\\n            long temp;\\n            temp = Double.doubleToLongBits(len);\\n            result = (int) (temp ^ (temp >>> 32));\\n            temp = Double.doubleToLongBits(x);\\n            result = 31 * result + (int) (temp ^ (temp >>> 32));\\n            temp = Double.doubleToLongBits(y);\\n            result = 31 * result + (int) (temp ^ (temp >>> 32));\\n            return result;\\n        }\\n    }\\n\\n    public double minAreaFreeRect(int[][] points) {\\n        Map<Diagonal, List<int[]>> map = new HashMap<>();\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = i + 1; j < points.length; j++) {\\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                Diagonal diagonal = new Diagonal(x1, y1, x2, y2);\\n                map.putIfAbsent(diagonal, new ArrayList<>());\\n                map.get(diagonal).add(new int[]{ x1, y1, x2, y2 });\\n            }\\n        }\\n        double min = Integer.MAX_VALUE;\\n        for (Diagonal diagonal : map.keySet()) {\\n            List<int[]> ls = map.get(diagonal);\\n            for (int i = 0; i < ls.size(); i++) {\\n                for (int j = i + 1; j < ls.size(); j++) {\\n                    int[] p1 = ls.get(i);\\n                    int[] p2 = ls.get(j);\\n                    min = Math.min(min, area(p1[0], p1[1], p1[2], p1[3], p2[0], p2[1], p2[2], p2[3]));\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? 0d : min;\\n    }\\n\\n    private double area(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\\n        double width = distance(x1, y1, x3, y3);\\n        double height = distance(x1, y1, x4, y4);\\n        return width * height;\\n    }\\n\\n    private double distance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209700,
                "title": "c-group-lines-by-slope-length-and-test-for-perpendicularity-beats-95-71",
                "content": "The basic idea is that two lines with the same slope and length are candidates for a rectangle.\\nFor example,\\n```\\n|    |\\n|    |\\n|    |\\n```\\nand\\n```\\n\\\\       \\\\\\n \\\\       \\\\\\n  \\\\       \\\\\\n  ```\\n  However, the following two lines share a slope and length\\n  ```\\n  |\\n  |       |\\n  |       |\\n          |\\n```\\nand obviosuly they cannot form a rectangle so we have to make sure if we connect both lines that the connected lines are prependicular to the original one.\\nTo make things easier we connect the mid points of the lines.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n       \\n        //Group pair of points by the distance and the slope of the formed line segments.\\n        map<pair<double,double>, vector<pair<double,double>> > h;\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                pair<double,double> p1 = make_pair(points[i][0],points[i][1]);\\n                pair<double,double> p2 = make_pair(points[j][0],points[j][1]);\\n                double d = distance(p1,p2);\\n                //if(d == 0 ) continue;   \\n                double slope = calc_slope(p1,p2);\\n                //we store the mid point\\n                h[make_pair(d,slope) ].push_back( make_pair((p1.first+p2.first)/2.0, (p1.second+p2.second)/2.0) );\\n            }\\n        }\\n        \\n        /*We search for two lines with the same slope and length, however, we have to make sure that we can\\n        connect both ends with a line prependicaulr to both line segments.\\n        This to avoid the considering the following two lines\\n        |\\n        |\\n        |\\n              |\\n              |\\n              |\\n        */\\n        double m = std::numeric_limits<double>::max();\\n         for(auto &p :h ) { \\n             if(p.second.size() > 1 ) \\n             for(int i=0;i<p.second.size();i++) { \\n                for(int j=i+1;j<p.second.size();j++) {\\n                    double d = distance(p.second[i],p.second[j]);\\n                    double slope = calc_slope(p.second[i],p.second[j]);\\n                    \\n                    /*here we test if the two lines are perpendicular by forming a line -call it X - between the\\n                    midpoints of both lines and check if X is perpendicular to both lines by multiplying both slopes\\n                    -1 means its ok. However, a vertical line has an undefined (double max in our implementation ) slope while horizontal one has 0\\n                    so we check for that corner case\\n                    */\\n                    if( (slope == std::numeric_limits<double>::max() && p.first.second == 0 ) || \\n                       (p.first.second == std::numeric_limits<double>::max() && slope == 0 ) ||\\n                       ( abs(-1 - (slope * p.first.second ) ) < 0.01 ) ) {\\n                        m = min(m,d*p.first.first);\\n                    }\\n                    \\n                }\\n             }\\n         }\\n        return m == std::numeric_limits<double>::max()? 0 : m;\\n       \\n    }\\nprivate:\\n    double distance(pair<double,double> &p1,pair<double,double> &p2) { \\n        return sqrt( pow(p1.first-p2.first,2) + pow(p1.second-p2.second,2) );\\n    }\\n     double calc_slope(pair<double,double> &p1,pair<double,double> &p2) { \\n        double dem = p1.first - p2.first;\\n        double slope=std::numeric_limits<double>::max();\\n        if(dem !=0 ) slope = (p1.second-p2.second)/dem;  \\n         return slope;\\n     }\\n};\\n```\\nThe upper bound running time is O(n^2)\\n",
                "solutionTags": [],
                "code": "```\\n|    |\\n|    |\\n|    |\\n```\n```\\n\\\\       \\\\\\n \\\\       \\\\\\n  \\\\       \\\\\\n  ```\n```\\n  |\\n  |       |\\n  |       |\\n          |\\n```\n```\\n\\nclass Solution {\\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n       \\n        //Group pair of points by the distance and the slope of the formed line segments.\\n        map<pair<double,double>, vector<pair<double,double>> > h;\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                pair<double,double> p1 = make_pair(points[i][0],points[i][1]);\\n                pair<double,double> p2 = make_pair(points[j][0],points[j][1]);\\n                double d = distance(p1,p2);\\n                //if(d == 0 ) continue;   \\n                double slope = calc_slope(p1,p2);\\n                //we store the mid point\\n                h[make_pair(d,slope) ].push_back( make_pair((p1.first+p2.first)/2.0, (p1.second+p2.second)/2.0) );\\n            }\\n        }\\n        \\n        /*We search for two lines with the same slope and length, however, we have to make sure that we can\\n        connect both ends with a line prependicaulr to both line segments.\\n        This to avoid the considering the following two lines\\n        |\\n        |\\n        |\\n              |\\n              |\\n              |\\n        */\\n        double m = std::numeric_limits<double>::max();\\n         for(auto &p :h ) { \\n             if(p.second.size() > 1 ) \\n             for(int i=0;i<p.second.size();i++) { \\n                for(int j=i+1;j<p.second.size();j++) {\\n                    double d = distance(p.second[i],p.second[j]);\\n                    double slope = calc_slope(p.second[i],p.second[j]);\\n                    \\n                    /*here we test if the two lines are perpendicular by forming a line -call it X - between the\\n                    midpoints of both lines and check if X is perpendicular to both lines by multiplying both slopes\\n                    -1 means its ok. However, a vertical line has an undefined (double max in our implementation ) slope while horizontal one has 0\\n                    so we check for that corner case\\n                    */\\n                    if( (slope == std::numeric_limits<double>::max() && p.first.second == 0 ) || \\n                       (p.first.second == std::numeric_limits<double>::max() && slope == 0 ) ||\\n                       ( abs(-1 - (slope * p.first.second ) ) < 0.01 ) ) {\\n                        m = min(m,d*p.first.first);\\n                    }\\n                    \\n                }\\n             }\\n         }\\n        return m == std::numeric_limits<double>::max()? 0 : m;\\n       \\n    }\\nprivate:\\n    double distance(pair<double,double> &p1,pair<double,double> &p2) { \\n        return sqrt( pow(p1.first-p2.first,2) + pow(p1.second-p2.second,2) );\\n    }\\n     double calc_slope(pair<double,double> &p1,pair<double,double> &p2) { \\n        double dem = p1.first - p2.first;\\n        double slope=std::numeric_limits<double>::max();\\n        if(dem !=0 ) slope = (p1.second-p2.second)/dem;  \\n         return slope;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209065,
                "title": "python3-92ms-o-n-2-beat-100",
                "content": "Main idea is that in a rectangle, the two diagonals have same length and same midpoint. We go through each pair of points, and put the pair in the bucket of (midpoint, length). Loop through each bucket and compute the areas.\\n\\n```\\nfrom collections import defaultdict\\nimport math\\n\\ndef sq_norm(p1,p2):\\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1])**2\\n    \\ndef area(p1,p2,p3):\\n    return math.sqrt(sq_norm(p1,p3) * sq_norm(p2,p3))\\n\\nclass Solution:\\n    def minAreaFreeRect(self, p):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        \\n        ans = 1E9\\n        \\n        m = defaultdict(list)\\n        for p1 in p:\\n            for p2 in p:\\n                if p1 < p2:\\n                    mid = (p1[0]+p2[0], p1[1] + p2[1], sq_norm(p1, p2))\\n                    sf = m[mid]\\n                    for p3 in sf:\\n                        ans = min(area(p1, p2, p3), ans)\\n                    m[mid].append(p1)\\n        return ans if ans < 1E9 else 0\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nimport math\\n\\ndef sq_norm(p1,p2):\\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1])**2\\n    \\ndef area(p1,p2,p3):\\n    return math.sqrt(sq_norm(p1,p3) * sq_norm(p2,p3))\\n\\nclass Solution:\\n    def minAreaFreeRect(self, p):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        \\n        ans = 1E9\\n        \\n        m = defaultdict(list)\\n        for p1 in p:\\n            for p2 in p:\\n                if p1 < p2:\\n                    mid = (p1[0]+p2[0], p1[1] + p2[1], sq_norm(p1, p2))\\n                    sf = m[mid]\\n                    for p3 in sf:\\n                        ans = min(area(p1, p2, p3), ans)\\n                    m[mid].append(p1)\\n        return ans if ans < 1E9 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208963,
                "title": "simple-python3-solution-o-n-2-using-slope-and-inner-product-beat-100-188-ms",
                "content": "```\\ndef minAreaFreeRect(self, points):\\n        dist = lambda x1, y1, x2, y2: (x1-x2)**2 + (y1-y2)**2\\n        inner = lambda p1, p2, p3: (p2[0] - p1[0]) * (p3[0] - p2[0]) + (p2[1] - p1[1]) * (p3[1] - p2[1])             \\n        area = lambda p1, p2, p3, p4: float(\\'inf\\') if not (inner(p1, p2, p3) == 0 and inner(p2, p3, p4) == 0 and inner(p3, p4, p1) == 0) else (dist(*p1, *p2) * dist(*p2, *p3))**.5                \\n        slope = lambda x1, y1, x2, y2: int((y2-y1)/ float(x2-x1) * 10**5) if x1 != x2 else float(\\'inf\\')            \\n    \\n        ans = float(\\'inf\\')              \\n        memo = collections.defaultdict(list)        \\n        for i, p in enumerate(points):\\n            for j, q in enumerate(points[:i]):\\n                memo[slope(*p, *q)].append([p, q])                \\n        for sl, cands in memo.items():\\n            for P1, P2 in itertools.permutations(cands, 2):\\n                p1, p2 = sorted(P1)\\n                p3, p4 = sorted(P2)\\n                ans = min(ans, area(p1, p2, p4, p3))                                        \\n        return ans if ans < float(\\'inf\\') else 0",
                "solutionTags": [],
                "code": "```\\ndef minAreaFreeRect(self, points):\\n        dist = lambda x1, y1, x2, y2: (x1-x2)**2 + (y1-y2)**2\\n        inner = lambda p1, p2, p3: (p2[0] - p1[0]) * (p3[0] - p2[0]) + (p2[1] - p1[1]) * (p3[1] - p2[1])             \\n        area = lambda p1, p2, p3, p4: float(\\'inf\\') if not (inner(p1, p2, p3) == 0 and inner(p2, p3, p4) == 0 and inner(p3, p4, p1) == 0) else (dist(*p1, *p2) * dist(*p2, *p3))**.5                \\n        slope = lambda x1, y1, x2, y2: int((y2-y1)/ float(x2-x1) * 10**5) if x1 != x2 else float(\\'inf\\')            \\n    \\n        ans = float(\\'inf\\')              \\n        memo = collections.defaultdict(list)        \\n        for i, p in enumerate(points):\\n            for j, q in enumerate(points[:i]):\\n                memo[slope(*p, *q)].append([p, q])                \\n        for sl, cands in memo.items():\\n            for P1, P2 in itertools.permutations(cands, 2):\\n                p1, p2 = sorted(P1)\\n                p3, p4 = sorted(P2)\\n                ans = min(ans, area(p1, p2, p4, p3))                                        \\n        return ans if ans < float(\\'inf\\') else 0",
                "codeTag": "Python3"
            },
            {
                "id": 208912,
                "title": "192ms-python3-solution-beaten-100",
                "content": "Steps:\\n1. Calculate the slopes of all straight segments and store them in **ijMap** which takes the point index pair as the key. Also, store the slope relations in a multi-dimension map - **relations** which takes the index of the start point as the first key, the slope as the second key and a set of the end points\\' indexes as the value. Note the slope is represented as a (dy, dx) pair where both are integers and dx is always greater than 0.\\n2. Loop thru all point pair (i0, i1) where i0 < i1. Get the slope of (i0, i1) and the slope of the other ajacent side. Now we have a set - **i3Set** of point i3 which connects to i1 and has the correct slope. Then we loop all possible i2 which connects to i0 and has the correct slope. For each i2, we have a set of possible i3 - **relations\\\\[i2\\\\]\\\\[inc01\\\\]**. If this set has intersection with **i3Set**, we get a valid rectangle and we can compute its area.\\nNote I have normalized all slopes by the maximum common divisor. And the slopes are optimized when the straight segment is parrellel to the x axis or the y axis.\\n```\\nfrom collections import defaultdict\\nimport math\\n\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        N = len(points)\\n        relations = [defaultdict(set) for i in range(N)]\\n        ijMap = dict()\\n        for i, (x0, y0) in enumerate(points):\\n            for j, (x1, y1) in enumerate(points[i + 1:], i + 1):\\n                incline = self.getIncline(x0, y0, x1, y1)\\n                relations[i][incline].add(j)\\n                relations[j][incline].add(i)\\n                ijMap[(i, j)] = ijMap[(j, i)] = incline\\n        minArea = math.inf\\n        for i0 in range(N):\\n            for i1 in range(i0 + 1, N):\\n                inc01 = ijMap[(i0, i1)]\\n                inc02 = self.getRevIncline(*inc01)\\n                i3Set = relations[i1][inc02]\\n                for i2 in relations[i0][inc02]:\\n                    if not i3Set.isdisjoint(relations[i2][inc01]):\\n                        minArea = min(\\n                            minArea, self.calArea(points, i0, i1, i2))\\n        return minArea if minArea != math.inf else 0\\n\\n    def calArea(self, points, i0, i1, i2):\\n        x0, y0 = points[i0]\\n        x1, y1 = points[i1]\\n        x2, y2 = points[i2]\\n        return math.sqrt(((x1 - x0)*(x1 - x0) + (y1 - y0) * (y1 - y0)) * ((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0)))\\n\\n    def getRevIncline(self, dy, dx):\\n        if dy == math.inf:\\n            return 0, 1\\n        if dy == 0:\\n            return math.inf, 1\\n        return (-dx, dy) if dy > 0 else (dx, -dy)\\n\\n    def getIncline(self, x0, y0, x1, y1):\\n        if x0 == x1:\\n            return math.inf, 1\\n        if y0 == y1:\\n            return 0, 1\\n        dx, dy = x1 - x0, y1 - y0\\n        cf = self.getCommonFactor(dx, dy)\\n        dx, dy = dx // cf, dy // cf\\n        return (dy, dx) if dx > 0 else (-dy, -dx)\\n\\n    def getCommonFactor(self, a, b):\\n        a, b = abs(a), abs(b)\\n        a = a % b\\n        while a != 0:\\n            b = b % a\\n            a, b = b, a\\n        return b\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nimport math\\n\\n\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        N = len(points)\\n        relations = [defaultdict(set) for i in range(N)]\\n        ijMap = dict()\\n        for i, (x0, y0) in enumerate(points):\\n            for j, (x1, y1) in enumerate(points[i + 1:], i + 1):\\n                incline = self.getIncline(x0, y0, x1, y1)\\n                relations[i][incline].add(j)\\n                relations[j][incline].add(i)\\n                ijMap[(i, j)] = ijMap[(j, i)] = incline\\n        minArea = math.inf\\n        for i0 in range(N):\\n            for i1 in range(i0 + 1, N):\\n                inc01 = ijMap[(i0, i1)]\\n                inc02 = self.getRevIncline(*inc01)\\n                i3Set = relations[i1][inc02]\\n                for i2 in relations[i0][inc02]:\\n                    if not i3Set.isdisjoint(relations[i2][inc01]):\\n                        minArea = min(\\n                            minArea, self.calArea(points, i0, i1, i2))\\n        return minArea if minArea != math.inf else 0\\n\\n    def calArea(self, points, i0, i1, i2):\\n        x0, y0 = points[i0]\\n        x1, y1 = points[i1]\\n        x2, y2 = points[i2]\\n        return math.sqrt(((x1 - x0)*(x1 - x0) + (y1 - y0) * (y1 - y0)) * ((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0)))\\n\\n    def getRevIncline(self, dy, dx):\\n        if dy == math.inf:\\n            return 0, 1\\n        if dy == 0:\\n            return math.inf, 1\\n        return (-dx, dy) if dy > 0 else (dx, -dy)\\n\\n    def getIncline(self, x0, y0, x1, y1):\\n        if x0 == x1:\\n            return math.inf, 1\\n        if y0 == y1:\\n            return 0, 1\\n        dx, dy = x1 - x0, y1 - y0\\n        cf = self.getCommonFactor(dx, dy)\\n        dx, dy = dx // cf, dy // cf\\n        return (dy, dx) if dx > 0 else (-dy, -dx)\\n\\n    def getCommonFactor(self, a, b):\\n        a, b = abs(a), abs(b)\\n        a = a % b\\n        while a != 0:\\n            b = b % a\\n            a, b = b, a\\n        return b\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208911,
                "title": "java-backtracking",
                "content": "1. Using backtrack to construct all possible points set.\\n2. Check the points set and calculate the area if the points can make up a rectangle.\\n3. Store the minimal rectangle area value.\\n\\n\\n```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        double[] res = new double[1];\\n        res[0] = Double.MAX_VALUE;\\n        backtracking(points, new ArrayList<>(), 0, res);\\n        return res[0] == Double.MAX_VALUE? 0 : res[0];\\n    }\\n\\n    private void backtracking(int[][] points, List<int[]> vertex, int index, double[] min) {\\n        if (vertex.size() >= 4) {\\n            // judge Rectangle\\n            double[] area = new double[1];\\n            if (isSquare(vertex,area)) {\\n                min[0] = Math.min(min[0], area[0]);\\n            }\\n            return;\\n        } else {\\n            for(int i = index; i < points.length; i++) {\\n\\n                vertex.add(points[i]);\\n                backtracking(points, vertex, i+1, min);\\n                vertex.remove(vertex.size() - 1);\\n            }\\n        }\\n\\n    }\\n\\n    public boolean isSquare (List<int[]> vertex, double[] area){\\n        int p[][]={{vertex.get(0)[0], vertex.get(0)[1]},\\n                {vertex.get(1)[0], vertex.get(1)[1]},\\n                {vertex.get(2)[0], vertex.get(2)[1]},\\n                {vertex.get(3)[0], vertex.get(3)[1]}};\\n        double cx = (double)(p[0][0] + p[1][0] + p[2][0] + p[3][0]) / 4;\\n        double cy = (double)(p[0][1] + p[1][1] + p[2][1] + p[3][1]) / 4;\\n        double dd1,dd2,dd3,dd4;\\n        dd1 = (cx - p[0][0])*(cx - p[0][0]) + (cy - p[0][1])*(cy - p[0][1]);\\n        dd2 = (cx - p[1][0])*(cx - p[1][0]) + (cy - p[1][1])*(cy - p[1][1]); \\n        dd3 = (cx - p[2][0])*(cx - p[2][0]) + (cy - p[2][1])*(cy - p[2][1]); \\n        dd4 = (cx - p[3][0])*(cx - p[3][0]) + (cy - p[3][1])*(cy - p[3][1]); \\n        boolean res = (dd1==dd2 && dd1==dd3 && dd1==dd4);\\n        \\n        if (res) {\\n            int cnt=0;\\n            double  len[]=new double[6];\\n            for(int i=0;i<=3;i++){\\n                for(int j=i+1;j<=3;j++){\\n                    len[cnt++]=(p[i][0]-p[j][0])*(p[i][0]-p[j][0])+\\n                            (p[i][1]-p[j][1])*(p[i][1]-p[j][1]);\\n                }\\n\\n            }\\n            Arrays.sort(len);\\n            area[0] = Math.sqrt(len[0]*len[2]);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        double[] res = new double[1];\\n        res[0] = Double.MAX_VALUE;\\n        backtracking(points, new ArrayList<>(), 0, res);\\n        return res[0] == Double.MAX_VALUE? 0 : res[0];\\n    }\\n\\n    private void backtracking(int[][] points, List<int[]> vertex, int index, double[] min) {\\n        if (vertex.size() >= 4) {\\n            // judge Rectangle\\n            double[] area = new double[1];\\n            if (isSquare(vertex,area)) {\\n                min[0] = Math.min(min[0], area[0]);\\n            }\\n            return;\\n        } else {\\n            for(int i = index; i < points.length; i++) {\\n\\n                vertex.add(points[i]);\\n                backtracking(points, vertex, i+1, min);\\n                vertex.remove(vertex.size() - 1);\\n            }\\n        }\\n\\n    }\\n\\n    public boolean isSquare (List<int[]> vertex, double[] area){\\n        int p[][]={{vertex.get(0)[0], vertex.get(0)[1]},\\n                {vertex.get(1)[0], vertex.get(1)[1]},\\n                {vertex.get(2)[0], vertex.get(2)[1]},\\n                {vertex.get(3)[0], vertex.get(3)[1]}};\\n        double cx = (double)(p[0][0] + p[1][0] + p[2][0] + p[3][0]) / 4;\\n        double cy = (double)(p[0][1] + p[1][1] + p[2][1] + p[3][1]) / 4;\\n        double dd1,dd2,dd3,dd4;\\n        dd1 = (cx - p[0][0])*(cx - p[0][0]) + (cy - p[0][1])*(cy - p[0][1]);\\n        dd2 = (cx - p[1][0])*(cx - p[1][0]) + (cy - p[1][1])*(cy - p[1][1]); \\n        dd3 = (cx - p[2][0])*(cx - p[2][0]) + (cy - p[2][1])*(cy - p[2][1]); \\n        dd4 = (cx - p[3][0])*(cx - p[3][0]) + (cy - p[3][1])*(cy - p[3][1]); \\n        boolean res = (dd1==dd2 && dd1==dd3 && dd1==dd4);\\n        \\n        if (res) {\\n            int cnt=0;\\n            double  len[]=new double[6];\\n            for(int i=0;i<=3;i++){\\n                for(int j=i+1;j<=3;j++){\\n                    len[cnt++]=(p[i][0]-p[j][0])*(p[i][0]-p[j][0])+\\n                            (p[i][1]-p[j][1])*(p[i][1]-p[j][1]);\\n                }\\n\\n            }\\n            Arrays.sort(len);\\n            area[0] = Math.sqrt(len[0]*len[2]);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208908,
                "title": "an-easy-o-n-3-way-to-solve",
                "content": "\\'\\'\\'\\nclass Solution(object):\\n    \\n    def recarea(self,a,b,c):\\n        x1=a[0]\\n        y1=a[1]\\n        x2=b[0]\\n        y2=b[1]\\n        x3=c[0]\\n        y3=c[1]\\n        return abs(x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2) + 0.0\\n    \\n    def vec_mul(self,va,vb):\\n        return va[0] * vb[0] + va[1] * vb[1]\\n    \\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        minarea = 0\\n        length = len(points)\\n        if length < 4:\\n            return 0\\n        for i in range(0,length):\\n            for j in range(i+1,length):\\n                for k in range(j+1,length):\\n                    pi = points[i]\\n                    pj = points[j]\\n                    pk = points[k]\\n                    temparea = self.recarea(pi,pj,pk)\\n                    if temparea > minarea and minarea != 0:\\n                        continue\\n                    v_ij = [pj[0]-pi[0],pj[1]-pi[1]]\\n                    v_ik = [pk[0]-pi[0],pk[1]-pi[1]]\\n                    v_jk = [pk[0]-pj[0],pk[1]-pj[1]]\\n                    if self.vec_mul(v_ij,v_jk) == 0:\\n                        t = [pi[0]+v_jk[0],pi[1]+v_jk[1]]\\n                        if t in points:\\n                            minarea = temparea \\n                    elif self.vec_mul(v_ij,v_ik) == 0:\\n                        t = [pj[0]+v_ik[0],pj[1]+v_ik[1]]\\n                        if t in points:\\n                            minarea = temparea\\n                    elif self.vec_mul(v_jk,v_ik) == 0:\\n                        t = [pi[0]-v_jk[0],pi[1]-v_jk[1]]\\n                        if t in points:\\n                            minarea = temparea\\n        return minarea\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution(object):\\n    \\n    def recarea(self,a,b,c):\\n        x1=a[0]\\n        y1=a[1]\\n        x2=b[0]\\n        y2=b[1]\\n        x3=c[0]\\n        y3=c[1]\\n        return abs(x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2) + 0.0\\n    \\n    def vec_mul(self,va,vb):\\n        return va[0] * vb[0] + va[1] * vb[1]\\n    \\n    def minAreaFreeRect(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        minarea = 0\\n        length = len(points)\\n        if length < 4:\\n            return 0\\n        for i in range(0,length):\\n            for j in range(i+1,length):\\n                for k in range(j+1,length):\\n                    pi = points[i]\\n                    pj = points[j]\\n                    pk = points[k]\\n                    temparea = self.recarea(pi,pj,pk)\\n                    if temparea > minarea and minarea != 0:\\n                        continue\\n                    v_ij = [pj[0]-pi[0],pj[1]-pi[1]]\\n                    v_ik = [pk[0]-pi[0],pk[1]-pi[1]]\\n                    v_jk = [pk[0]-pj[0],pk[1]-pj[1]]\\n                    if self.vec_mul(v_ij,v_jk) == 0:\\n                        t = [pi[0]+v_jk[0],pi[1]+v_jk[1]]\\n                        if t in points:\\n                            minarea = temparea \\n                    elif self.vec_mul(v_ij,v_ik) == 0:\\n                        t = [pj[0]+v_ik[0],pj[1]+v_ik[1]]\\n                        if t in points:\\n                            minarea = temparea\\n                    elif self.vec_mul(v_jk,v_ik) == 0:\\n                        t = [pi[0]-v_jk[0],pi[1]-v_jk[1]]\\n                        if t in points:\\n                            minarea = temparea\\n        return minarea\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 208801,
                "title": "python-use-math-vector",
                "content": "```\\ndef minAreaFreeRect(self, points):\\n        vectorMap = {}\\n        for i in range(len(points)):\\n            p1 = points[i]\\n            for j in range(i + 1, len(points)):\\n                p2 = points[j]\\n                indexP1, indexP2 = i, j\\n                vector = (p2[0] - p1[0], p2[1] - p1[1])\\n                if vector[0] < 0 or (vector[0] == 0 and vector[1] < 0):\\n                    # consider vector with inverse direction\\n                    vector = (-vector[0], -vector[1])\\n                    indexP1, indexP2 = indexP2, indexP1\\n                if vector not in vectorMap:\\n                    vectorMap[vector] = [[indexP1, indexP2]]\\n                else:\\n                    vectorMap[vector].append([indexP1, indexP2])\\n        \\n        res = sys.maxint\\n        for vector, pairs in vectorMap.iteritems():\\n            if len(pairs) > 1:\\n                for i in range(len(pairs)):\\n                    p1 = points[pairs[i][0]]\\n                    for j in range(i + 1, len(pairs)):\\n                        p2 = points[pairs[j][0]]\\n                        # use start points of two vectors to get the third side\\n                        v3 = [p2[0] - p1[0], p2[1] - p1[1]]\\n                        if (vector[0] * v3[0] + vector[1] * v3[1]) == 0:\\n                            # is rectangle\\n                            area = abs(vector[0] * v3[1] - vector[1] * v3[0])\\n                            if area < res:\\n                                res = area\\n                            \\n        if res == sys.maxint:\\n            return 0\\n        else:\\n            return res\\n```\\n\\nIdea:\\n1. put all vectors (a pair of points) into map and group them by magnitude and direction.\\n2. check if any 2 vectors with the same magnitude and direction can form a rectangle and save the minimum area.",
                "solutionTags": [],
                "code": "```\\ndef minAreaFreeRect(self, points):\\n        vectorMap = {}\\n        for i in range(len(points)):\\n            p1 = points[i]\\n            for j in range(i + 1, len(points)):\\n                p2 = points[j]\\n                indexP1, indexP2 = i, j\\n                vector = (p2[0] - p1[0], p2[1] - p1[1])\\n                if vector[0] < 0 or (vector[0] == 0 and vector[1] < 0):\\n                    # consider vector with inverse direction\\n                    vector = (-vector[0], -vector[1])\\n                    indexP1, indexP2 = indexP2, indexP1\\n                if vector not in vectorMap:\\n                    vectorMap[vector] = [[indexP1, indexP2]]\\n                else:\\n                    vectorMap[vector].append([indexP1, indexP2])\\n        \\n        res = sys.maxint\\n        for vector, pairs in vectorMap.iteritems():\\n            if len(pairs) > 1:\\n                for i in range(len(pairs)):\\n                    p1 = points[pairs[i][0]]\\n                    for j in range(i + 1, len(pairs)):\\n                        p2 = points[pairs[j][0]]\\n                        # use start points of two vectors to get the third side\\n                        v3 = [p2[0] - p1[0], p2[1] - p1[1]]\\n                        if (vector[0] * v3[0] + vector[1] * v3[1]) == 0:\\n                            # is rectangle\\n                            area = abs(vector[0] * v3[1] - vector[1] * v3[0])\\n                            if area < res:\\n                                res = area\\n                            \\n        if res == sys.maxint:\\n            return 0\\n        else:\\n            return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 208596,
                "title": "c-o-n-3-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n  struct myHash\\n{\\n\\tsize_t operator()(pair<int, int> __val) const\\n\\t{\\n\\t\\treturn static_cast<size_t>(__val.first * 40001 + __val.second);\\n\\t}\\n};\\nstruct Point {\\n\\tint x;\\n\\tint y;\\n\\tPoint(int a=0, int b=0)\\n\\t{\\n\\t\\tx = a;\\n\\t\\ty = b;\\n\\t}\\n\\n};\\ndouble dis(Point a, Point b)\\n{\\n\\tdouble dis = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);\\n\\n\\treturn sqrt(dis);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tunordered_set<pair<int,int>,myHash> store;\\n\\tPoint * A = new Point[points.size()];\\n\\tfor (int i = 0; i<points.size(); i++)\\n\\t{\\n\\t\\tPoint a(points[i][0], points[i][1]);\\n\\t\\tA[i] = a;\\n\\t\\tstore.insert({ points[i][0], points[i][1] });\\n\\t}\\n\\tdouble val = INT_MAX;\\n\\t//A1+ A4==A2+A3\\n\\tfor (int i = 0; i<points.size(); i++)\\n\\t\\tfor (int j = i + 1; j<points.size(); j++)\\n\\t\\t\\tfor (int k = j + 1; k<points.size(); k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint dx = A[j].x + A[k].x - A[i].x;\\n\\t\\t\\t\\tint dy = A[j].y + A[k].y - A[i].y;\\n\\t\\t\\t\\tPoint b(dx, dy);\\n\\t\\t\\t\\tif (store.count({ dx, dy }) != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint dot = ((A[j].x - A[i].x) * (A[k].x - A[i].x) + (A[j].y - A[i].y) * (A[k].y - A[i].y));\\n\\t\\t\\t\\t\\tif (dot == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdouble distance = dis(A[i], A[j])*dis(A[i], A[k]);\\n\\n\\t\\t\\t\\t\\t\\tval = min(val, distance);\\n\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\t}\\n    if(abs(val-INT_MAX)<0.0001) return 0;\\n\\treturn val;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  struct myHash\\n{\\n\\tsize_t operator()(pair<int, int> __val) const\\n\\t{\\n\\t\\treturn static_cast<size_t>(__val.first * 40001 + __val.second);\\n\\t}\\n};\\nstruct Point {\\n\\tint x;\\n\\tint y;\\n\\tPoint(int a=0, int b=0)\\n\\t{\\n\\t\\tx = a;\\n\\t\\ty = b;\\n\\t}\\n\\n};\\ndouble dis(Point a, Point b)\\n{\\n\\tdouble dis = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);\\n\\n\\treturn sqrt(dis);\\n}\\ndouble minAreaFreeRect(vector<vector<int>>& points) {\\n\\tunordered_set<pair<int,int>,myHash> store;\\n\\tPoint * A = new Point[points.size()];\\n\\tfor (int i = 0; i<points.size(); i++)\\n\\t{\\n\\t\\tPoint a(points[i][0], points[i][1]);\\n\\t\\tA[i] = a;\\n\\t\\tstore.insert({ points[i][0], points[i][1] });\\n\\t}\\n\\tdouble val = INT_MAX;\\n\\t//A1+ A4==A2+A3\\n\\tfor (int i = 0; i<points.size(); i++)\\n\\t\\tfor (int j = i + 1; j<points.size(); j++)\\n\\t\\t\\tfor (int k = j + 1; k<points.size(); k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint dx = A[j].x + A[k].x - A[i].x;\\n\\t\\t\\t\\tint dy = A[j].y + A[k].y - A[i].y;\\n\\t\\t\\t\\tPoint b(dx, dy);\\n\\t\\t\\t\\tif (store.count({ dx, dy }) != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint dot = ((A[j].x - A[i].x) * (A[k].x - A[i].x) + (A[j].y - A[i].y) * (A[k].y - A[i].y));\\n\\t\\t\\t\\t\\tif (dot == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdouble distance = dis(A[i], A[j])*dis(A[i], A[k]);\\n\\n\\t\\t\\t\\t\\t\\tval = min(val, distance);\\n\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\t}\\n    if(abs(val-INT_MAX)<0.0001) return 0;\\n\\treturn val;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208584,
                "title": "java-easy-understanding-solution",
                "content": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if (points == null || points.length < 4) {\\n            return 0;\\n        }\\n        \\n        // check the fourth point\\n        Set<String> checker = new HashSet<String>();\\n        for (int[] point : points) {\\n            checker.add(point[0] + \"-\" + point[1]);\\n        }\\n        \\n        // check rectangle\\n        double result = Double.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                for (int k = 0; k < j; k++) {\\n                    int[] p1 = points[i], p2 = points[j], p3 = points[k];\\n\\t\\t\\t\\t\\t// get the fourth point\\n                    int x = p2[0] + p3[0] - p1[0];\\n                    int y = p2[1] + p3[1] - p1[1];\\n                    // two lines needs to be vertical\\n                    if (checker.contains(x + \"-\" + y) && checkDirectionHelper(p1, p2, p3)) {\\n                        result = Math.min(result, getAreaHelper(p1, p2, p3));\\n                    }\\n                }\\n            }\\n        }\\n        return result == Double.MAX_VALUE ? 0 : result;\\n    }\\n    \\n    private double getAreaHelper(int[] p1, int[] p2, int[] p3) {\\n        double d1 = getDistanceHelper(p1, p2);\\n        double d2 = getDistanceHelper(p2, p3);\\n        double d3 = getDistanceHelper(p1, p3);\\n        List<Double> distances = new ArrayList<Double>();\\n        distances.add(d1);\\n        distances.add(d2);\\n        distances.add(d3);\\n        Collections.sort(distances);\\n        return distances.get(0) * distances.get(1);\\n    }\\n    \\n    private double getDistanceHelper(int[] p1, int[] p2) {\\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\\n    }\\n    \\n    private boolean checkDirectionHelper(int[] p1, int[] p2, int[] p3) {\\n        int x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], x3 = p3[0], y3 = p3[1];\\n        return (y2 - y1) * (y3 - y1) + (x2 - x1) * (x3 - x1) == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double minAreaFreeRect(int[][] points) {\\n        if (points == null || points.length < 4) {\\n            return 0;\\n        }\\n        \\n        // check the fourth point\\n        Set<String> checker = new HashSet<String>();\\n        for (int[] point : points) {\\n            checker.add(point[0] + \"-\" + point[1]);\\n        }\\n        \\n        // check rectangle\\n        double result = Double.MAX_VALUE;\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                for (int k = 0; k < j; k++) {\\n                    int[] p1 = points[i], p2 = points[j], p3 = points[k];\\n\\t\\t\\t\\t\\t// get the fourth point\\n                    int x = p2[0] + p3[0] - p1[0];\\n                    int y = p2[1] + p3[1] - p1[1];\\n                    // two lines needs to be vertical\\n                    if (checker.contains(x + \"-\" + y) && checkDirectionHelper(p1, p2, p3)) {\\n                        result = Math.min(result, getAreaHelper(p1, p2, p3));\\n                    }\\n                }\\n            }\\n        }\\n        return result == Double.MAX_VALUE ? 0 : result;\\n    }\\n    \\n    private double getAreaHelper(int[] p1, int[] p2, int[] p3) {\\n        double d1 = getDistanceHelper(p1, p2);\\n        double d2 = getDistanceHelper(p2, p3);\\n        double d3 = getDistanceHelper(p1, p3);\\n        List<Double> distances = new ArrayList<Double>();\\n        distances.add(d1);\\n        distances.add(d2);\\n        distances.add(d3);\\n        Collections.sort(distances);\\n        return distances.get(0) * distances.get(1);\\n    }\\n    \\n    private double getDistanceHelper(int[] p1, int[] p2) {\\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\\n    }\\n    \\n    private boolean checkDirectionHelper(int[] p1, int[] p2, int[] p3) {\\n        int x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], x3 = p3[0], y3 = p3[1];\\n        return (y2 - y1) * (y3 - y1) + (x2 - x1) * (x3 - x1) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208552,
                "title": "python-o-n-2-beats-100-10-lines-with-explanation",
                "content": "ideas:\\n1) make center, and distance of a pair to be a key to a hash map and list to be a value\\n2) make a vector out of a pair by subtracting 2 end points and append to list corresponds to the key\\n3) do cross product to calculate area of the rectangle if 2 pairs with same center and distance found\\n```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        st_pt, mn = collections.defaultdict(list), math.inf\\n        for l1, l2 in itertools.combinations((complex(*z) for z in points), 2):\\n            v1 = l1 - l2\\n            key = (l1 + l2, v1*v1.conjugate())\\n            for v2 in st_pt[key]:\\n                mn = min(abs(v1.imag*v2.real - v2.imag*v1.real)/2, mn)\\n            st_pt[key].append(v1)\\n        return mn if mn != math.inf else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minAreaFreeRect(self, points):\\n        st_pt, mn = collections.defaultdict(list), math.inf\\n        for l1, l2 in itertools.combinations((complex(*z) for z in points), 2):\\n            v1 = l1 - l2\\n            key = (l1 + l2, v1*v1.conjugate())\\n            for v2 in st_pt[key]:\\n                mn = min(abs(v1.imag*v2.real - v2.imag*v1.real)/2, mn)\\n            st_pt[key].append(v1)\\n        return mn if mn != math.inf else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208427,
                "title": "js-o-n-4-solution",
                "content": "```\\nvar minAreaFreeRect = function(points) {\\n    let min = Infinity;\\n    for(let i=0;i<points.length;i++) {\\n        for(let j=0;j<points.length;j++) {\\n            if(i==j) continue;\\n            for(let k=0;k<points.length;k++) {\\n                if(i==k||j==k) continue;\\n                for(let l=0;l<points.length;l++) {\\n                    min = Math.min(min, isRect(points[i],points[j],points[k],points[l]));\\n                }\\n            }    \\n        }\\n    }\\n    return min==Infinity?0:min;\\n};\\n\\nvar isRect = function (p1,p2,p3,p4) {\\n    let d1 = distSq(p1, p2); // from p1 to p2 \\n    let d2 = distSq(p2, p3); // from p2 to p3 \\n    let d3 = distSq(p3, p4); // from p3 to p4 \\n    let d4 = distSq(p1, p4); // from p1 to p4 \\n\\n    let dg1 = distSq(p1, p3); // dialognal 1\\n    let dg2 = distSq(p2, p4); // dialognal 2\\n    \\n    if(d1==d3&&d2==d4&&dg1==dg2) {\\n        return Math.sqrt(d1*d2);  \\n    }\\n    \\n    return Infinity;\\n}\\n\\nvar distSq = function(p1,p2) {\\n    return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar minAreaFreeRect = function(points) {\\n    let min = Infinity;\\n    for(let i=0;i<points.length;i++) {\\n        for(let j=0;j<points.length;j++) {\\n            if(i==j) continue;\\n            for(let k=0;k<points.length;k++) {\\n                if(i==k||j==k) continue;\\n                for(let l=0;l<points.length;l++) {\\n                    min = Math.min(min, isRect(points[i],points[j],points[k],points[l]));\\n                }\\n            }    \\n        }\\n    }\\n    return min==Infinity?0:min;\\n};\\n\\nvar isRect = function (p1,p2,p3,p4) {\\n    let d1 = distSq(p1, p2); // from p1 to p2 \\n    let d2 = distSq(p2, p3); // from p2 to p3 \\n    let d3 = distSq(p3, p4); // from p3 to p4 \\n    let d4 = distSq(p1, p4); // from p1 to p4 \\n\\n    let dg1 = distSq(p1, p3); // dialognal 1\\n    let dg2 = distSq(p2, p4); // dialognal 2\\n    \\n    if(d1==d3&&d2==d4&&dg1==dg2) {\\n        return Math.sqrt(d1*d2);  \\n    }\\n    \\n    return Infinity;\\n}\\n\\nvar distSq = function(p1,p2) {\\n    return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208350,
                "title": "is-o-n-4-allowed-for-n-50",
                "content": "I am never able to pass it with O(n^4) solution but I wonder why some could pass it?",
                "solutionTags": [],
                "code": "I am never able to pass it with O(n^4) solution but I wonder why some could pass it?",
                "codeTag": "Unknown"
            },
            {
                "id": 208325,
                "title": "using-set-o-n-3log-n-c-20-ms",
                "content": "```\\nProblem can\\'t be done solved in O(n^4) (brute force ) .\\nSo we need to reduce time complexity. I used set to store the co-ordinates of rectangle.\\nand Then used set as replacement for 4th loop in solution\\n\\n```\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &p1,vector<int> &p2,vector<int>&p3){\\n\\t\\n\\t// function to find wheater given 3 points intersect at right angle\\n        \\n        int x1 = p1[0]-p2[0];\\n        int x2 = p3[0] - p2[0];\\n        \\n        int y1 = p1[1] -p2[1];\\n        int y2 = p3[1] -p2[1];\\n        \\n        \\n        if((y1==0 && x2==0) || (y2==0 && x1==0)){\\n            return true;\\n        }\\n        else if(y1==0 || x1==0 || y2==0 || x2==0)\\n            return false;\\n        \\n        else if(x1*x2==-y1*y2){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    double dist(vector<int> &p1,vector<int> &p2){\\n        return sqrt((pow(p1[0]-p2[0],2))+ pow(p1[1]-p2[1],2));\\n    }\\n    \\n    double Area(vector<int> &p1,vector<int> &p2,vector<int>&p3){\\n        return dist(p1,p2) * dist(p2,p3);\\n    }\\n    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        set<pair<int,int> > hmap;\\n        \\n        int n = points.size();\\n        \\n        if(n<3)\\n            return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            hmap.insert({points[i][0],points[i][1]});\\n        }\\n        \\n        double sol=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(isValid(points[i],points[j],points[k])){\\n                        int x = points[i][0] + points[k][0] - points[j][0];\\n                        int y = points[i][1] + points[k][1] - points[j][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[i],points[j],points[k]));\\n                        }\\n                    }\\n                   else  if(isValid(points[i],points[k],points[j])){\\n                        int x = points[i][0] + points[j][0] - points[k][0];\\n                        int y = points[i][1] + points[j][1] - points[k][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[i],points[k],points[j]));\\n                        }\\n                    }\\n                   else if(isValid(points[j],points[i],points[k])){\\n                        int x = points[j][0] + points[k][0] - points[i][0];\\n                        int y = points[j][1] + points[k][1] - points[i][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[j],points[i],points[k]));\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return sol==INT_MAX?0:sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nProblem can\\'t be done solved in O(n^4) (brute force ) .\\nSo we need to reduce time complexity. I used set to store the co-ordinates of rectangle.\\nand Then used set as replacement for 4th loop in solution\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &p1,vector<int> &p2,vector<int>&p3){\\n\\t\\n\\t// function to find wheater given 3 points intersect at right angle\\n        \\n        int x1 = p1[0]-p2[0];\\n        int x2 = p3[0] - p2[0];\\n        \\n        int y1 = p1[1] -p2[1];\\n        int y2 = p3[1] -p2[1];\\n        \\n        \\n        if((y1==0 && x2==0) || (y2==0 && x1==0)){\\n            return true;\\n        }\\n        else if(y1==0 || x1==0 || y2==0 || x2==0)\\n            return false;\\n        \\n        else if(x1*x2==-y1*y2){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    double dist(vector<int> &p1,vector<int> &p2){\\n        return sqrt((pow(p1[0]-p2[0],2))+ pow(p1[1]-p2[1],2));\\n    }\\n    \\n    double Area(vector<int> &p1,vector<int> &p2,vector<int>&p3){\\n        return dist(p1,p2) * dist(p2,p3);\\n    }\\n    \\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        set<pair<int,int> > hmap;\\n        \\n        int n = points.size();\\n        \\n        if(n<3)\\n            return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            hmap.insert({points[i][0],points[i][1]});\\n        }\\n        \\n        double sol=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(isValid(points[i],points[j],points[k])){\\n                        int x = points[i][0] + points[k][0] - points[j][0];\\n                        int y = points[i][1] + points[k][1] - points[j][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[i],points[j],points[k]));\\n                        }\\n                    }\\n                   else  if(isValid(points[i],points[k],points[j])){\\n                        int x = points[i][0] + points[j][0] - points[k][0];\\n                        int y = points[i][1] + points[j][1] - points[k][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[i],points[k],points[j]));\\n                        }\\n                    }\\n                   else if(isValid(points[j],points[i],points[k])){\\n                        int x = points[j][0] + points[k][0] - points[i][0];\\n                        int y = points[j][1] + points[k][1] - points[i][1];\\n                        if(hmap.find({x,y})!=hmap.end()){\\n                            sol = min(sol,Area(points[j],points[i],points[k]));\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return sol==INT_MAX?0:sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200357,
                "title": "c-understanding-vectors-dot-product",
                "content": "`Good Read:` https://cp-algorithms.com/geometry/basic-geometry.html\\n\\n```\\nusing ll = long long int;\\nclass point {\\n    public:\\n    double x;\\n    double y;\\n\\n    point(double x, double y) : x(x), y(y) {}\\n    \\n    point(vector<int> &p) : x(p[0]), y(p[1]) {}\\n    \\n    double distance(double x1, double y1) {\\n        return sqrt((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));\\n    }  \\n};\\n\\nclass Solution {\\n    unordered_map<double, vector<vector<point>>> pointMap;\\n    \\n\\t/**\\n\\t\\tmiddle point = (p1 + p2) / 2\\n\\t\\tbut we are creating a hash to keep in pointMap using similar equation.\\n\\t*/\\n    double getMiddlePoint(point &p1, point &p2) {\\n        return ((p1.x + p2.x) * (1e9) + (p1.y + p2.y) * (2)) / 2;\\n    }\\n    \\n    bool is90(point p1, point p2, point p3) {\\n        point v1 = {p1.x - p2.x, p1.y - p2.y}; // vector\\n        point v2 = {p3.x - p2.x, p3.y - p2.y}; // vector\\n        \\n        // compute dot product of vectors\\n        auto dot = v1.x * v2.x + v1.y * v2.y;\\n        // not equal points\\n        bool d1 = p1.x != p2.x or p1.y != p2.y;\\n        bool d2 = p1.x != p3.x or p1.y != p3.y;\\n        \\n        return d1 and d2 and dot == 0;\\n    }\\n    \\npublic:\\n    double minAreaFreeRect(vector<vector<int>>& points) {\\n        pointMap.clear();\\n        \\n        // create a map using middle point pairs\\n        for (int ptr1 = 0; ptr1 < points.size(); ptr1++) {\\n            for (int ptr2 = ptr1 + 1; ptr2 < points.size(); ptr2++) {\\n                auto point1 = point(points[ptr1]);\\n                auto point2 = point(points[ptr2]);\\n                \\n                auto point3 = getMiddlePoint(point1, point2);\\n                pointMap[point3].push_back({point1, point2});\\n            }\\n        }\\n        \\n        double area = 1e18;\\n        for (auto [middlePoint, pointList]: pointMap) {\\n            for (int ptr1 = 0; ptr1 < pointList.size(); ptr1++) {\\n                for (int ptr2 = ptr1 + 1; ptr2 < pointList.size(); ptr2++) {\\n                    auto pointlist1 = pointList[ptr1];\\n                    auto pointlist2 = pointList[ptr2];\\n                    \\n                    if (is90(pointlist1[0], pointlist2[0], pointlist1[1]) && is90(pointlist2[0], pointlist1[0], pointlist2[1])) {\\n                        double d1 = pointlist1[0].distance(pointlist2[0].x, pointlist2[0].y);\\n                        double d2 = pointlist1[1].distance(pointlist2[0].x, pointlist2[0].y);\\n                        \\n                        area = min(area, d1 * d2);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return area == (1e18) ? 0 : area;\\n    }\\n};",
                "solutionTags": [
                    "Geometry"
                ],
                "code": "class Solution {\\n    unordered_map<double, vector<vector<point>>> pointMap;\\n    \\n\\t/**\\n\\t\\tmiddle point = (p1 + p2) / 2\\n\\t\\tbut we are creating a hash to keep in pointMap using similar equation.\\n\\t*/\\n    double getMiddlePoint(point &p1, point &p2) {\\n        return ((p1.x + p2.x) * (1e9) + (p1.y + p2.y) * (2)) / 2;\\n    }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1744586,
                "content": [
                    {
                        "username": "aryabhishek",
                        "content": "So, no one is going to say anything?"
                    },
                    {
                        "username": "luanct",
                        "content": "it\\'s hard af, how is this problem supposed to be a medium problem lol"
                    }
                ]
            }
        ]
    }
]