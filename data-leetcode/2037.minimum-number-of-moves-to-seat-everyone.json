[
    {
        "title": "Minimum Number of Moves to Seat Everyone",
        "question_content": "There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.\nYou may perform the following move any number of times:\n\n\tIncrease or decrease the position of the ith student by 1 (i.e., moving the ith student from position&nbsp;x&nbsp;to x + 1 or x - 1)\n\nReturn the minimum number of moves required to move each student to a seat such that no two students are in the same seat.\nNote that there may be multiple seats or students in the same position at the beginning.\n&nbsp;\nExample 1:\n\nInput: seats = [3,1,5], students = [2,7,4]\nOutput: 4\nExplanation: The students are moved as follows:\n- The first student is moved from from position 2 to position 1 using 1 move.\n- The second student is moved from from position 7 to position 5 using 2 moves.\n- The third student is moved from from position 4 to position 3 using 1 move.\nIn total, 1 + 2 + 1 = 4 moves were used.\n\nExample 2:\n\nInput: seats = [4,1,5,9], students = [1,3,2,6]\nOutput: 7\nExplanation: The students are moved as follows:\n- The first student is not moved.\n- The second student is moved from from position 3 to position 4 using 1 move.\n- The third student is moved from from position 2 to position 5 using 3 moves.\n- The fourth student is moved from from position 6 to position 9 using 3 moves.\nIn total, 0 + 1 + 3 + 3 = 7 moves were used.\n\nExample 3:\n\nInput: seats = [2,2,6,6], students = [1,3,2,6]\nOutput: 4\nExplanation: Note that there are two seats at position 2 and two seats at position 6.\nThe students are moved as follows:\n- The first student is moved from from position 1 to position 2 using 1 move.\n- The second student is moved from from position 3 to position 6 using 3 moves.\n- The third student is not moved.\n- The fourth student is not moved.\nIn total, 1 + 3 + 0 + 0 = 4 moves were used.\n\n&nbsp;\nConstraints:\n\n\tn == seats.length == students.length\n\t1 <= n <= 100\n\t1 <= seats[i], students[j] <= 100",
        "solutions": [
            {
                "id": 1526110,
                "title": "c-simple-and-clean-solution",
                "content": "**Idea:**\\nWe sort both arrays.\\nThen, greedily, we loop through them and match each student with the closest seat.\\n\\n**Time Complexity:** O(nlogn)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        \\n        int res = 0;\\n        for (int i = 0; i < seats.size(); i++) res += abs(seats[i] - students[i]);\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        \\n        int res = 0;\\n        for (int i = 0; i < seats.size(); i++) res += abs(seats[i] - students[i]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524213,
                "title": "java-python-3-sort-both-and-sum-the-corresponding-difference",
                "content": "```java\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves = 0;\\n        for (int i = 0; i < seats.length; ++i) {\\n            moves += Math.abs(seats[i] - students[i]);\\n        }\\n        return moves;\\n    }\\n```\\n```python\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        return sum(abs(e - t) for e, t in zip(seats, students))\\n```\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(S)`, where `n = seats.length, S = space cost during sorting`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves = 0;\\n        for (int i = 0; i < seats.length; ++i) {\\n            moves += Math.abs(seats[i] - students[i]);\\n        }\\n        return moves;\\n    }\\n```\n```python\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        return sum(abs(e - t) for e, t in zip(seats, students))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1524946,
                "title": "c-linear-time-counting-sort",
                "content": "Let us exploit the last constraint `1 <= seats[i], students[j] <= 100` and trade some (constant) space in favor of O(n) time:\\n```c++\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n\\tint a[100] = {}, b[100] = {}, ans = 0;\\n\\tfor (int i : seats) ++a[i - 1];\\n\\tfor (int i : students) ++b[i - 1];\\n\\tfor (int i = 0, j = 0; i < 100;)\\n\\t\\tif (!a[i]) ++i;\\n\\t\\telse if (!b[j]) ++j;\\n\\t\\telse {\\n\\t\\t\\tint diff = min(a[i], b[j]);\\n\\t\\t\\tans += diff * abs(i - j);\\n\\t\\t\\ta[i] -= diff;\\n\\t\\t\\tb[j] -= diff;\\n\\t\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n\\tint a[100] = {}, b[100] = {}, ans = 0;\\n\\tfor (int i : seats) ++a[i - 1];\\n\\tfor (int i : students) ++b[i - 1];\\n\\tfor (int i = 0, j = 0; i < 100;)\\n\\t\\tif (!a[i]) ++i;\\n\\t\\telse if (!b[j]) ++j;\\n\\t\\telse {\\n\\t\\t\\tint diff = min(a[i], b[j]);\\n\\t\\t\\tans += diff * abs(i - j);\\n\\t\\t\\ta[i] -= diff;\\n\\t\\t\\tb[j] -= diff;\\n\\t\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1526737,
                "title": "easy-java-solution-1-ms-faster-than-100-00-of-java-online-submissions",
                "content": "class Solution {\\n\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int answer = 0;\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        for(int i =0; i<seats.length; i++)\\n            answer += Math.abs(seats[i]-students[i]);\\n        \\n        return answer;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int answer = 0;\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        for(int i =0; i<seats.length; i++)\\n            answer += Math.abs(seats[i]-students[i]);\\n        \\n        return answer;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1524152,
                "title": "a-few-solutions",
                "content": "**TL;DR**\\n\\nSort the input arrays `A` and `B` and return the accumulated absolute difference of each i<sup>th</sup> element.\\n\\n**AC:**\\n\\n3 minutes 12 seconds during [bi-weekly contest 63](https://leetcode.com/contest/biweekly-contest-63/ranking/82/)\\n\\n**Details:**\\n\\nThis sum is the optimal solution since each student position `a` in `A` is mapped onto each seat position `b` in `B`.  An informal proof by contradiction would be this thought experiment: consider the values of `A` and `B` in a two-dimensional plane, ie. a graph.  When `A` and `B` are sorted in ascending order, then their graph would represent monotonically non-decreasing values, ie. the lines which connect each point `a` in `A` start at the bottom-left of the graph and end at the top-right of the graph.  The same monotonically non-decreasing values can be observed from each point `b` in `B`.  So the graph looks something like this:\\n\\n![image](https://assets.leetcode.com/users/images/8ab30b62-b393-47b0-a424-1b708c745ea1_1634406996.2212293.png)\\n\\n\\nThen we can visiualize the optimal solution as the mimimized absolute difference in the y-axis.  So the question then is: how do we minimize the difference between each i<sup>th</sup> element, ie. every a<sub>i</sub> and b<sub>j</sub> value for some i, j in 0..N-1 inclusive?  And we can draw little dotted lines which represent their absolute difference as the cost we must pay for the student/seating mapping:\\n\\n![image](https://assets.leetcode.com/users/images/3a0fa3ae-29b3-4d36-879a-aa44e001d193_1634407160.8059773.png)\\n\\nWithout loss of generality, we can safely swap each a<sub>i</sub> and b<sub>i</sub> value to make this graph \"pretty\", ie. more easy to visualize with all `b` in `B` at or above all `a` in `A` since we accumulate their absolute difference (per the commutative property `|a - b| == |b - a|`).  The contradictory thought is then: how could this accumulated absolute difference be further minimized?  It cannot; thus we have \"proved\" this is the optimal solution, since we have \"shown\" the opposite is impossible.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var minMovesToSeat = { A: IntArray, B: IntArray -> (A.sorted() zip B.sorted()).map{ (a, b) -> Math.abs(a - b) }.sum() }\\n}\\n```\\n\\n*Java*\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        return IntStream.range(0, A.length)\\n            .mapToObj(i -> Math.abs(A[i] - B[i]))\\n            .reduce(0, (a, b) -> a + b);\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minMovesToSeat = (A, B) => {\\n    A.sort((a, b) => a - b);\\n    B.sort((a, b) => a - b);\\n    return _.sum(_.zip(A, B).map(([a, b]) => Math.abs(a - b)));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    minMovesToSeat = lambda self, A, B: sum(abs(a - b) for a, b in zip(sorted(A), sorted(B)))\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn min_moves_to_seat(mut A: VI, mut B: VI) -> i32 {\\n        A.sort();\\n        B.sort();\\n        A.into_iter().zip(B.into_iter()).map(|(a, b)| (a - b).abs()).sum::<i32>()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minMovesToSeat(VI& A, VI& B, int best = 0) {\\n        sort(A.begin(), A.end());\\n        sort(B.begin(), B.end());\\n        for (auto i{ 0 }; i < A.size(); ++i)\\n            best += abs(A[i] - B[i]);\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var minMovesToSeat = { A: IntArray, B: IntArray -> (A.sorted() zip B.sorted()).map{ (a, b) -> Math.abs(a - b) }.sum() }\\n}\\n```\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        return IntStream.range(0, A.length)\\n            .mapToObj(i -> Math.abs(A[i] - B[i]))\\n            .reduce(0, (a, b) -> a + b);\\n    }\\n}\\n```\n```\\nlet minMovesToSeat = (A, B) => {\\n    A.sort((a, b) => a - b);\\n    B.sort((a, b) => a - b);\\n    return _.sum(_.zip(A, B).map(([a, b]) => Math.abs(a - b)));\\n};\\n```\n```\\nclass Solution:\\n    minMovesToSeat = lambda self, A, B: sum(abs(a - b) for a, b in zip(sorted(A), sorted(B)))\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn min_moves_to_seat(mut A: VI, mut B: VI) -> i32 {\\n        A.sort();\\n        B.sort();\\n        A.into_iter().zip(B.into_iter()).map(|(a, b)| (a - b).abs()).sum::<i32>()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minMovesToSeat(VI& A, VI& B, int best = 0) {\\n        sort(A.begin(), A.end());\\n        sort(B.begin(), B.end());\\n        for (auto i{ 0 }; i < A.size(); ++i)\\n            best += abs(A[i] - B[i]);\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527789,
                "title": "sort",
                "content": "**C++**\\n```cpp\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n    int res = 0;\\n    sort(begin(seats), end(seats));\\n    sort(begin(students), end(students));\\n    for (int i = 0; i < seats.size(); ++i)\\n        res += abs(seats[i] - students[i]);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n    int res = 0;\\n    sort(begin(seats), end(seats));\\n    sort(begin(students), end(students));\\n    for (int i = 0; i < seats.size(); ++i)\\n        res += abs(seats[i] - students[i]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563215,
                "title": "a-simple-proof-why-greedy-works-with-diagram",
                "content": "C++ code:\\n```\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        int total = 0;\\n        for (int i = 0; i < seats.size(); ++i) {\\n            total += abs(seats[i] - students[i]);\\n        }\\n        return total;\\n    }\\n```\\n\\n## when `n = 2`\\nWe can use a simple example to examine why greedy algorithm works.\\n\\nLet\\'s say we have `seats = [a1, a2]` and `students = [b1, b2]`, with `a1 < a2`, `b1 < b2`, and `a1 < b1`. Now three cases will happen:\\n\\n### case 1: `a2 < b1`\\n```\\n[a1]|-------|[a2]\\n                   [b1]|------|[b2]\\n```\\nThen `(b1 - a1) + (b2 - a2)` is equal to `(b2 - a1) + (b2 - a1)`. In this case, greedy method is *no worse*.\\n\\n### case 2: `b1 < a2` and `a2 < b2`\\n```\\n[a1]|-------|[a2]\\n      [b1]|-------|[b2]\\n```\\nClearly `(b1 - a1) + (b2 - a2) < (b2 -a1) < (b2 - a1) + (a2 - b1)`. Greedy method wins.\\n\\n### case 3: `b1 < a2` and `b2 < a2`\\n```\\n[a1]|--------------------|[a2]\\n        [b1]|----|[b2]\\n```\\nIn this case, we can easily see `(b1 - a1) + (a2 - b2) < (a2 - a1) < (b2 - a1) + (a2 - b1)`. Greedy wins.\\n\\nIn all cases, greedy method is *at least not worse* than the alternative approach.\\n\\n## when `n > 2`\\nWe can use induction to prove the general case.",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        int total = 0;\\n        for (int i = 0; i < seats.size(); ++i) {\\n            total += abs(seats[i] - students[i]);\\n        }\\n        return total;\\n    }\\n```\n```\\n[a1]|-------|[a2]\\n                   [b1]|------|[b2]\\n```\n```\\n[a1]|-------|[a2]\\n      [b1]|-------|[b2]\\n```\n```\\n[a1]|--------------------|[a2]\\n        [b1]|----|[b2]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539518,
                "title": "o-n-counting-sort-in-python",
                "content": "trivial `O(nlogn)` solution, using `sort()` w/o hesitation:\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        return sum(abs(seat - student) for seat, student in zip(seats, students))\\n```\\n`O(m+n)` solution, using counting sort where `m` and `n` are respectively the maximum digit of `students` and `seats`:\\nnote that for better understanding, you may replace `i` and `j` with `student` and `seat`.\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats_cnt, students_cnt = [0] * (max(seats) + 1), [0] * (max(students) + 1)\\n        for seat in seats:\\n            seats_cnt[seat] += 1\\n        for student in students:\\n            students_cnt[student] += 1\\n        ans = 0\\n        i = j = 1\\n        while i < len(students_cnt):\\n            if students_cnt[i]:\\n                # find the next available seat\\n                while j < len(seats_cnt) and not seats_cnt[j]:\\n                    j += 1\\n                ans += abs(i - j)\\n                seats_cnt[j] -= 1\\n                students_cnt[i] -= 1\\n            else:\\n                i += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        return sum(abs(seat - student) for seat, student in zip(seats, students))\\n```\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats_cnt, students_cnt = [0] * (max(seats) + 1), [0] * (max(students) + 1)\\n        for seat in seats:\\n            seats_cnt[seat] += 1\\n        for student in students:\\n            students_cnt[student] += 1\\n        ans = 0\\n        i = j = 1\\n        while i < len(students_cnt):\\n            if students_cnt[i]:\\n                # find the next available seat\\n                while j < len(seats_cnt) and not seats_cnt[j]:\\n                    j += 1\\n                ans += abs(i - j)\\n                seats_cnt[j] -= 1\\n                students_cnt[i] -= 1\\n            else:\\n                i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526206,
                "title": "c-minimum-number-of-moves-to-seat-everyone",
                "content": "https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(students.begin(),students.end());\\n        sort(seats.begin(),seats.end());\\n    \\n        int sum=0;\\n       \\n        for(int i=0;i<seats.size();i++)\\n        {\\n            sum=sum+abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/7cae2c8c-0bc4-4398-a152-7f5239ae3ab9_1634475902.212435.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(students.begin(),students.end());\\n        sort(seats.begin(),seats.end());\\n    \\n        int sum=0;\\n       \\n        for(int i=0;i<seats.size();i++)\\n        {\\n            sum=sum+abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182660,
                "title": "java-solution-for-beginners-self-explanatory-clean-code",
                "content": "import java.util.*;\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int sum = 0;\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        for(int i = 0;i<seats.length;i++){\\n            if(seats[i] >= students[i]){\\n                sum = sum + (seats[i] - students[i]);\\n            }\\n            \\n            else if(seats[i] < students[i]){\\n                sum = sum + (students[i] - seats[i]);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int sum = 0;\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        for(int i = 0;i<seats.length;i++){\\n            if(seats[i] >= students[i]){\\n                sum = sum + (seats[i] - students[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1761226,
                "title": "java-easy-to-understand-shorter-solution",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int diff = 0;\\n        for(int i=0; i<seats.length; i++){\\n            diff +=  Math.abs(students[i]-seats[i]);\\n        }\\n        return diff;\\n    }\\n}\\n```\\nPlease **UPVOTE** if you find this solution helpful.\\nThanks : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int diff = 0;\\n        for(int i=0; i<seats.length; i++){\\n            diff +=  Math.abs(students[i]-seats[i]);\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527466,
                "title": "javascript-solution-132ms",
                "content": "We are given 2 arrays of the same length, `students` and `seats`, and are asked to *return the minimum number of moves required to move each student to a seat such that no two students are in the same seat*. \\n\\nThe first thing we must do is sort both arrays so that when we compare them they will return the optimal difference. Do NOT use `seats.sort()` as this will return an incorrect sort (it will sort by the first numeral in a number ex: 1, 10, 2, 3, 434, 5...) and lead to a wrong answer submission.\\n- `seats.sort((a, b) => { return a - b})`\\n- `students.sort((a, b) => { return a - b})`\\n\\nNow that the arrays are sorted we want to compare them and return the difference, we can do this by using the reduce method on either of the arrays. Inside the reduce method we set `a` as the accumulator, `b` as the current value, `i` as the iteration, and 0 as the initial value. \\n- `seats.reduce((a, b, i) => , 0)`\\n\\nAs we iterate through the method we want to accumulate the absolute value of the difference between the current iteration in the `seats` and `students` arrays.\\n- `a += Math.abs(seats[i] - students[i])`\\n\\nReturn the method as the final accumulation value will represent out answer.\\n- `return seats.reduce((a, b, i) => a += Math.abs(seats[i] - students[i]), 0)`\\n\\n**Solution 1: 154ms**\\n\\n```\\nvar minMovesToSeat = function(seats, students) {\\n    seats.sort((a, b) => { return a - b})\\n    students.sort((a, b) => { return a - b})\\n    return seats.reduce((a, b, i) => a += Math.abs(seats[i] - students[i]), 0)\\n};\\n```\\n\\n---\\n\\n**Solution 2: 132ms**\\n\\nThis solution is slightly faster and requires less code. The only difference is that we replace `seats` in the reduce method with `seats.sort((a, b) => { return a - b})` so we can streamline the sorted array into the return statement.\\n\\n```\\nvar minMovesToSeat = function(seats, students) {\\n    students.sort((a, b) => { return a - b})\\n    return seats.sort((a, b) => { return a - b}).reduce((a, b, i) => a += Math.abs(seats[i] - students[i]), 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minMovesToSeat = function(seats, students) {\\n    seats.sort((a, b) => { return a - b})\\n    students.sort((a, b) => { return a - b})\\n    return seats.reduce((a, b, i) => a += Math.abs(seats[i] - students[i]), 0)\\n};\\n```\n```\\nvar minMovesToSeat = function(seats, students) {\\n    students.sort((a, b) => { return a - b})\\n    return seats.sort((a, b) => { return a - b}).reduce((a, b, i) => a += Math.abs(seats[i] - students[i]), 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1987191,
                "title": "python-easiest-solution-with-explanation-sorting-beg-to-adv",
                "content": "```python\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        total_moves = 0 # taking a int variable to store the value\\n        sorted_seats = sorted(seats) # sorting the seat list\\n        sorted_students = sorted(students) #sorting the student list\\n        \\n        diff_1 = [] # taking empty list for storing difference of both the list\\n        for i in range(len(seats)):\\n            diff = abs(sorted_seats[i] - sorted_students[i]) # calculating diff of both the list elements, to calculate numbers of move. \\n            diff_1.append(diff) # appending the Difference to the empty list declared by us. \\n        \\n        for i in diff_1: # loop for traversing the diff of elems from both the lists.\\n            total_moves += i # adding them to calculate the moves. \\n        \\n        return total_moves\\n```\\n\\n```python\\n\\t\\t\"\"\"\\n        Short form of above solution:-\\n        \"\"\"\\n        #first sort both the lists\\n        seats.sort() \\n        students.sort()\\n        \\n        res = 0 # variable to store the result\\n        \\n        for i in range(len(seats)): \\n            res += abs(students[i] - seats[i]) # calculating diff of both the list and adding it to the variable , rather then adding it to the list, and then to traverse that list for the total moves.\\n            \\n        return res\\n```\\n\\n***Found helpful, Do upvote !!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        total_moves = 0 # taking a int variable to store the value\\n        sorted_seats = sorted(seats) # sorting the seat list\\n        sorted_students = sorted(students) #sorting the student list\\n        \\n        diff_1 = [] # taking empty list for storing difference of both the list\\n        for i in range(len(seats)):\\n            diff = abs(sorted_seats[i] - sorted_students[i]) # calculating diff of both the list elements, to calculate numbers of move. \\n            diff_1.append(diff) # appending the Difference to the empty list declared by us. \\n        \\n        for i in diff_1: # loop for traversing the diff of elems from both the lists.\\n            total_moves += i # adding them to calculate the moves. \\n        \\n        return total_moves\\n```\n```python\\n\\t\\t\"\"\"\\n        Short form of above solution:-\\n        \"\"\"\\n        #first sort both the lists\\n        seats.sort() \\n        students.sort()\\n        \\n        res = 0 # variable to store the result\\n        \\n        for i in range(len(seats)): \\n            res += abs(students[i] - seats[i]) # calculating diff of both the list and adding it to the variable , rather then adding it to the list, and then to traverse that list for the total moves.\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629508,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    private int MAX_POS_NUM = 100;\\n    \\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int[] seatsAtPos = getFrequencyArray(seats, MAX_POS_NUM);\\n        int[] studentsAtPos = getFrequencyArray(students, MAX_POS_NUM);\\n        \\n        return iterateBothArraysAndAddMoves(seatsAtPos, studentsAtPos);\\n    }\\n    \\n    private int[] getFrequencyArray(int[] nums, int maxNum) {\\n        int[] freqArray = new int[maxNum + 1];\\n        for (int i = 0; i < nums.length; ++i) {\\n            ++freqArray[nums[i]];\\n        }\\n        return freqArray;\\n    }\\n    \\n    private int iterateBothArraysAndAddMoves(int[] seatsAtPos, int[] studentsAtPos) {\\n        int totalMoves = 0;\\n        for (int i = 1, j = 1; i < seatsAtPos.length;) {\\n            if (seatsAtPos[i] == 0) {\\n                ++i;\\n            } else if (studentsAtPos[j] == 0) {\\n                ++j;\\n            } else {\\n                --seatsAtPos[i];\\n                --studentsAtPos[j];\\n                totalMoves += Math.abs(i - j);\\n            }\\n        }\\n        \\n        return totalMoves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int MAX_POS_NUM = 100;\\n    \\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int[] seatsAtPos = getFrequencyArray(seats, MAX_POS_NUM);\\n        int[] studentsAtPos = getFrequencyArray(students, MAX_POS_NUM);\\n        \\n        return iterateBothArraysAndAddMoves(seatsAtPos, studentsAtPos);\\n    }\\n    \\n    private int[] getFrequencyArray(int[] nums, int maxNum) {\\n        int[] freqArray = new int[maxNum + 1];\\n        for (int i = 0; i < nums.length; ++i) {\\n            ++freqArray[nums[i]];\\n        }\\n        return freqArray;\\n    }\\n    \\n    private int iterateBothArraysAndAddMoves(int[] seatsAtPos, int[] studentsAtPos) {\\n        int totalMoves = 0;\\n        for (int i = 1, j = 1; i < seatsAtPos.length;) {\\n            if (seatsAtPos[i] == 0) {\\n                ++i;\\n            } else if (studentsAtPos[j] == 0) {\\n                ++j;\\n            } else {\\n                --seatsAtPos[i];\\n                --studentsAtPos[j];\\n                totalMoves += Math.abs(i - j);\\n            }\\n        }\\n        \\n        return totalMoves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524261,
                "title": "simple-sorting-method-c",
                "content": "Sort both arrays as this way the difference between student & seat at ```i```th position will be minimum.\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int cnt=0,diff;\\n        for(int i=0;i<seats.size();i++){\\n            diff = max(seats[i],students[i]) - min(seats[i],students[i]);\\n            cnt+=diff;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```i```\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int cnt=0,diff;\\n        for(int i=0;i<seats.size();i++){\\n            diff = max(seats[i],students[i]) - min(seats[i],students[i]);\\n            cnt+=diff;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524161,
                "title": "python3-1-line",
                "content": "\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum(abs(x-y) for x, y in zip(sorted(seats), sorted(students)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum(abs(x-y) for x, y in zip(sorted(seats), sorted(students)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365294,
                "title": "math-bazooka-1-liner-earthmover-distance-solution",
                "content": "Today we will be nuking mosquitos by using the [Earthmover distance](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wasserstein_distance.html). \\n\\nExcluding an import, this yields a 1-liner.\\n\\nIs that overkill? Yes, absolutely.\\n\\n```\\nfrom scipy.stats import wasserstein_distance as EMD\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return round( len(seats)*EMD(seats, students) )\\n```\\n\\n# Intuition\\n\\n**TLDR:** The Earthmover distance (EMD) is a measure of statistical distance coming from the theory of optimal transport which basically tells you the minimal effort it would take to reshape one probability distribution into another. Reframing our inputs as probability distributions, we can compute their EMD and rescale to get the answer in 1-line. You can learn more about the specific implementation the code used from the [documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wasserstein_distance.html).\\n\\n**Q:** But where are the probability distributions?\\n**A:** To turn our `seats` position data into a probability distribution, we can just imagine we pick seats at random. So each seat has a uniform $$1/n$$ chance of being selected. That\\'s it, that\\'s the distribution. It\\'s called the *empirical distribution*. We can do the same thing for `students`. \\n\\nIn our case, the EMD of two 1D empirical distributions with equal number of points will tell us on ***average*** how much each point will need to move in the optimal transport plan. The scipy implemention with defaults assumes this, so that means `EMD(seats,students)` equals `answer/n`. So if we just multiply by the number of points (i.e. array length) then we should have the answer. However, because of the limited precision of floats, we\\'ll need to actually round after that multiplication. \\n\\n# Complexity\\n![image.png](https://assets.leetcode.com/users/images/d8d236fc-0e16-4251-a922-a5723a49327e_1680342490.2423034.png)\\nDidn\\'t vet the implementation so dunno. The differences of sorted values solution is surely much faster though since it avoids floats and requires no import. It would be interesting to see how that solution fares against the EMD approach if the seat/student positions were allowed to be floats.\\n\\n**Bonus Background:** Among many reasons the EMD is nice is because it is well-defined for higher dimensions (possibly infinite), curved geometry (spheres), and wacky distributions (you can compare discrete and continuous distributions and mixes of the two). It has lots of applications ranging from statistics, physics, biology, and machine learning as well (see Wasserstein GANs).\\n\\n**Minor technical notes:** I\\'ve been saying probability distribution but I really mean probability measure to be precise. \\n\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Probability and Statistics"
                ],
                "code": "```\\nfrom scipy.stats import wasserstein_distance as EMD\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return round( len(seats)*EMD(seats, students) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843436,
                "title": "python-clean-with-comments",
                "content": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats = sorted(seats)\\n        students = sorted(students)\\n        # redefine the varaibles to be sorted [min->max]\\n\\n        counter = 0\\n        # set up the counter for amount of moves\\n\\n        for x in range(len(seats)):\\n            counter += abs(seats[x]-students[x])\\n            # add the amount of moves that the person moved\\n            # use absolute in the case seats[x]<students[x]\\n            \\n        return counter\\n        # return the amount of moves\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats = sorted(seats)\\n        students = sorted(students)\\n        # redefine the varaibles to be sorted [min->max]\\n\\n        counter = 0\\n        # set up the counter for amount of moves\\n\\n        for x in range(len(seats)):\\n            counter += abs(seats[x]-students[x])\\n            # add the amount of moves that the person moved\\n            # use absolute in the case seats[x]<students[x]\\n            \\n        return counter\\n        # return the amount of moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822070,
                "title": "python-99-81-faster-5-lines-sorting",
                "content": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        c,n=0,len(seats)\\n        for i in range(n): c+=abs(seats[i]-students[i])\\n        return c\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        c,n=0,len(seats)\\n        for i in range(n): c+=abs(seats[i]-students[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711124,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int noMoves = 0;\\n        for (int i = 0; i < seats.length; ++i) {\\n            noMoves += Math.abs(seats[i] - students[i]);\\n        }\\n        return noMoves;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int noMoves = 0;\\n        for (int i = 0; i < seats.length; ++i) {\\n            noMoves += Math.abs(seats[i] - students[i]);\\n        }\\n        return noMoves;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597861,
                "title": "java-best-approach-99-98-faster",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int n = seats.length;\\n        int m = students.length;\\n        int count = 0;\\n        for( int i = 0; i < n ; i++){\\n            if(seats[i] < students[i]){\\n                count = count + students[i] - seats[i];\\n            }\\n            else{\\n                count = count + seats[i] -students[i];\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int n = seats.length;\\n        int m = students.length;\\n        int count = 0;\\n        for( int i = 0; i < n ; i++){\\n            if(seats[i] < students[i]){\\n                count = count + students[i] - seats[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1909541,
                "title": "javascript-solution-easy-style",
                "content": "```\\nvar minMovesToSeat = function(seats, students) {\\n    let sum = 0\\n    seats=seats.sort((a,b)=>a-b)    \\n    students=students.sort((a,b)=>a-b)\\n    for(let i=0;i<seats.length;i++)\\n        sum+=Math.abs(seats[i]-students[i])\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minMovesToSeat = function(seats, students) {\\n    let sum = 0\\n    seats=seats.sort((a,b)=>a-b)    \\n    students=students.sort((a,b)=>a-b)\\n    for(let i=0;i<seats.length;i++)\\n        sum+=Math.abs(seats[i]-students[i])\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1615500,
                "title": "two-c-solutions",
                "content": "**Solution 1 : Worked for all the test cases**\\n\\n**Idea:**\\nWe sort both arrays.\\nThen, greedily, we loop through them and match each student with the closest seat.\\n\\n**Time Complexity: O(nlogn)**\\n**Space Complexity: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        int sum = 0;\\n        for(int i = 0; i<seats.size(); i++)\\n            sum += (abs(seats[i] - students[i]));\\n        return sum;\\n    }\\n};\\n```\\n**Solution 2 : Worked for half of the test cases**\\n\\n**Idea:**\\nWe just get the sum of the students and seats then return the difference\\n\\nTried for some brilliancy here but failed\\uD83D\\uDE05\\uD83D\\uDE05\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n         int se = accumulate(seats.begin(), seats.end(), 0);\\n         int stu = accumulate(students.begin(), students.end(), 0);\\n        \\n         return abs(se - stu);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        int sum = 0;\\n        for(int i = 0; i<seats.size(); i++)\\n            sum += (abs(seats[i] - students[i]));\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n         int se = accumulate(seats.begin(), seats.end(), 0);\\n         int stu = accumulate(students.begin(), students.end(), 0);\\n        \\n         return abs(se - stu);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565998,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        \\n        \\n        seats = sorted(seats, reverse = False)\\n        students = sorted(students, reverse = False)\\n\\n        count = 0\\n        for x in range (len(seats)):\\n            count+= abs(seats[x]-students[x])\\n            \\n        return count\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        \\n        \\n        seats = sorted(seats, reverse = False)\\n        students = sorted(students, reverse = False)\\n\\n        count = 0\\n        for x in range (len(seats)):\\n            count+= abs(seats[x]-students[x])\\n            \\n        return count\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539348,
                "title": "c-python-scala-one-liners",
                "content": "C#:\\n```\\npublic class Solution {\\n    public int MinMovesToSeat(int[] seats, int[] students) {\\n        return seats.OrderBy(p => p).Zip(students.OrderBy(p => p), (p1, p2) => Math.Abs(p1 - p2)).Sum();\\n    }\\n}\\n```\\nPython:\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum(abs(p1 - p2) for p1, p2 in zip(sorted(seats), sorted(students)))\\n```\\nScala:\\n```\\nobject Solution {\\n    def minMovesToSeat(seats: Array[Int], students: Array[Int]): Int = {\\n        (seats.sorted zip students.sorted).map{case (p1, p2) => (p1 - p2).abs}.sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Scala"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMovesToSeat(int[] seats, int[] students) {\\n        return seats.OrderBy(p => p).Zip(students.OrderBy(p => p), (p1, p2) => Math.Abs(p1 - p2)).Sum();\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum(abs(p1 - p2) for p1, p2 in zip(sorted(seats), sorted(students)))\\n```\n```\\nobject Solution {\\n    def minMovesToSeat(seats: Array[Int], students: Array[Int]): Int = {\\n        (seats.sorted zip students.sorted).map{case (p1, p2) => (p1 - p2).abs}.sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536967,
                "title": "java-sort-and-find-difference",
                "content": "This solution has O(n log n) time complexity.\\n\\nBy sorting both input arrays, you ensure that the number of moves is the lowest because the student with the lowest position moves to the lowest seat, and the student with the highest position moves to the highest seat.\\n\\n```\\npublic int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count = 0;\\n        for (int i=0; i<seats.length; i++) {\\n            count += Math.abs(seats[i] - students[i]);\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count = 0;\\n        for (int i=0; i<seats.length; i++) {\\n            count += Math.abs(seats[i] - students[i]);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525887,
                "title": "python3-easy-solution-sorting",
                "content": "\\u0421omputing sum of the differences between elements of the sorted lists:\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        moves = 0\\n        \\n        for seat, student in zip(sorted(seats), sorted(students)):\\n            moves += abs(seat - student)\\n            \\n        return moves\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        moves = 0\\n        \\n        for seat, student in zip(sorted(seats), sorted(students)):\\n            moves += abs(seat - student)\\n            \\n        return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866306,
                "title": "beats-99-9-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n   // let count = 0;\\n   let sum =0;\\n   seats.sort((a,b)=>a-b);\\n   students.sort((a,b)=>a-b);\\n\\n    for(let i=0;i<seats.length;i++)\\n    {\\n        if(seats[i]==students[i]){\\n            continue;\\n        }\\n        else if(seats[i]>students[i]){\\n            sum += (seats[i]-students[i]);\\n        }\\n        else{\\n            sum +=(students[i]-seats[i]);\\n        }\\n    }\\n    return sum\\n};\\n```\\n# plz upvote my solution",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n   // let count = 0;\\n   let sum =0;\\n   seats.sort((a,b)=>a-b);\\n   students.sort((a,b)=>a-b);\\n\\n    for(let i=0;i<seats.length;i++)\\n    {\\n        if(seats[i]==students[i]){\\n            continue;\\n        }\\n        else if(seats[i]>students[i]){\\n            sum += (seats[i]-students[i]);\\n        }\\n        else{\\n            sum +=(students[i]-seats[i]);\\n        }\\n    }\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858028,
                "title": "solution-in-java-beginner-friendly-with-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Firstly sort both array (i.e. seats, students)\\n2. Create \\'moves\\' variable of type int.\\n3. Iterate both array using for loop.\\n4. subtract values for every index of \\'seats\\' and \\'students\\' and add subtraction to \\'moves\\' variable.\\n5. return moves;\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n\\n        int moves = 0;\\n        for(int i=0; i<students.length; i++){\\n            moves = moves + Math.abs(seats[i]-students[i]);\\n        }\\n\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n\\n        int moves = 0;\\n        for(int i=0; i<students.length; i++){\\n            moves = moves + Math.abs(seats[i]-students[i]);\\n        }\\n\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670823,
                "title": "c-easy-faster-than-97-4ms",
                "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int c =0;\\n      sort(seats.begin(),seats.end()); \\n      sort(students.begin(),students.end());  \\n        for(int i=0;i<seats.size();i++){\\n          c=c+(abs(seats[i]-students[i]));  \\n        }\\n      return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int c =0;\\n      sort(seats.begin(),seats.end()); \\n      sort(students.begin(),students.end());  \\n        for(int i=0;i<seats.size();i++){\\n          c=c+(abs(seats[i]-students[i]));  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3383943,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int cnt=0;\\n        for(int i=0;i<seats.size();i++){\\n            cnt+=sqrt((seats[i]-students[i])*(seats[i]-students[i]));\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# Please Upvote if you find it helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int cnt=0;\\n        for(int i=0;i<seats.size();i++){\\n            cnt+=sqrt((seats[i]-students[i])*(seats[i]-students[i]));\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858825,
                "title": "python-faster-than-86-11-memory-beats-97-69",
                "content": "# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        moves = 0\\n        seats.sort()\\n        students.sort()\\n        for s in range(len(students)):\\n            moves += abs(students[s]-seats[s])\\n        return moves\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/72c84c67-12ab-4943-ba77-ffa3e8c88023_1669702259.6721807.png)\\n![image.png](https://assets.leetcode.com/users/images/b195919f-0c94-480f-a862-fd4ece1799e6_1669702363.7398427.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        moves = 0\\n        seats.sort()\\n        students.sort()\\n        for s in range(len(students)):\\n            moves += abs(students[s]-seats[s])\\n        return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855055,
                "title": "python-comments-simple",
                "content": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats = sorted(seats)\\n        students = sorted(students)\\n        # redefine the varaibles to be sorted [min->max]\\n\\n        counter = 0\\n        # set up the counter for amount of moves\\n\\n        for x in range(len(seats)):\\n            counter += abs(seats[x]-students[x])\\n            # add the amount of moves that the person moved\\n            # use absolute in the case seats[x]<students[x]\\n            \\n        return counter\\n        # return the amount of moves\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats = sorted(seats)\\n        students = sorted(students)\\n        # redefine the varaibles to be sorted [min->max]\\n\\n        counter = 0\\n        # set up the counter for amount of moves\\n\\n        for x in range(len(seats)):\\n            counter += abs(seats[x]-students[x])\\n            # add the amount of moves that the person moved\\n            # use absolute in the case seats[x]<students[x]\\n            \\n        return counter\\n        # return the amount of moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751567,
                "title": "c-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& arr1, vector<int>& arr2) {\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n        int ans=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {\\n            ans=ans+abs(arr1[i]-arr2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& arr1, vector<int>& arr2) {\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n        int ans=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {\\n            ans=ans+abs(arr1[i]-arr2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677439,
                "title": "99-75-faster-very-easy-java",
                "content": "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int ans=0;\\n        Arrays.sort(seats);//sorting array\\n        Arrays.sort(students);\\n        \\n        for(int i=0;i<seats.length;i++)\\n        {\\n            int dif=Math.abs(seats[i]-students[i]);//Math.abs for avoiding negative value\\n            ans+=dif;//add answer\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int ans=0;\\n        Arrays.sort(seats);//sorting array\\n        Arrays.sort(students);\\n        \\n        for(int i=0;i<seats.length;i++)\\n        {\\n            int dif=Math.abs(seats[i]-students[i]);//Math.abs for avoiding negative value\\n            ans+=dif;//add answer\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2597854,
                "title": "java-clean-solution-by-sorting-best-approach",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minMovesToSeat(int[] seats, int[] students) {\\n\\t\\t\\tArrays.sort(seats);\\n\\t\\t\\tArrays.sort(students);\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 0; i < seats.length; ++i) {\\n\\t\\t\\t\\tcount += Math.abs(seats[i] - students[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minMovesToSeat(int[] seats, int[] students) {\\n\\t\\t\\tArrays.sort(seats);\\n\\t\\t\\tArrays.sort(students);\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 0; i < seats.length; ++i) {\\n\\t\\t\\t\\tcount += Math.abs(seats[i] - students[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2158112,
                "title": "explanation-of-question-with-code",
                "content": "The question demands for minimun postition to place n students in n seats after moving them from their current position to the closest seat present from their position \\n\\nso ,the algorithm goes like this:\\n* firstly sort both the arrays \\n* this will match the minimum position student with the closest seat present from them \\n* start a loop traversing the student array and find the difference of position from his seat to the minimum seat availabe \\n* add all the differences in a variable and return the end result\\n\\n\\n\\t\\tint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int res=0;\\n        for(int i=0;i<students.size();i++)\\n        {\\n            res=res+(abs(students[i]-seats[i]));\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "The question demands for minimun postition to place n students in n seats after moving them from their current position to the closest seat present from their position \\n\\nso ,the algorithm goes like this:\\n* firstly sort both the arrays \\n* this will match the minimum position student with the closest seat present from them \\n* start a loop traversing the student array and find the difference of position from his seat to the minimum seat availabe \\n* add all the differences in a variable and return the end result\\n\\n\\n\\t\\tint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int res=0;\\n        for(int i=0;i<students.size();i++)\\n        {\\n            res=res+(abs(students[i]-seats[i]));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1800999,
                "title": "java-please-upvoke",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int min=0;\\n        for(int i=0;i<seats.length;i++){\\n            min+=Math.abs(seats[i]-students[i]);\\n        }\\n        return min;\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int min=0;\\n        for(int i=0;i<seats.length;i++){\\n            min+=Math.abs(seats[i]-students[i]);\\n        }\\n        return min;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795795,
                "title": "c-solution-using-vector-sorting-abs-easy-solution",
                "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        \\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        \\n        int count =0;\\n        \\n        for(int i =0; i<students.size(); i++)\\n        {\\n            count += abs(seats[i] - students[i]);  // considering absolute difference because moves can\\'t be negative\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        \\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        \\n        int count =0;\\n        \\n        for(int i =0; i<students.size(); i++)\\n        {\\n            count += abs(seats[i] - students[i]);  // considering absolute difference because moves can\\'t be negative\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1649732,
                "title": "minimum-number-of-moves-to-seat-everyone-with-explanation",
                "content": "```\\n/* the intitution is very simple\\nfirst sort the array \\nthen check wheather the value of seats[i] == students[i]\\nif the value is same that means the student already have a seat so no need to move\\nif the value is not same that menas the student needs to move in order to seat \\nso count the no of move \\n*/\\n\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        // first sort two arrays\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        // checking for edge case if array has no element then just return 0\\n        if(seats.length==0){\\n            return 0;\\n        }\\n        \\n        \\n        int moves = 0;\\n        for(int i = 0;i<seats.length;i++){\\n            //check at index i\\n            //if the value of seats is not equal to  then the value of student \\n            // that means the student need to move it\\'s position to seat, then\\n            // the difference between the seat value and student value will be the no of moves\\n            \\n            \\n            // count the moves accondig to the value\\n            if(seats[i]>students[i]){\\n                moves += seats[i]-students[i];\\n            }\\n            if(seats[i]<students[i]){\\n                moves += students[i]- seats[i];\\n            }\\n            \\n        }\\n        \\n        return moves;\\n    }\\n}\\n```\\nthis is not only for mine but for everyones solution, if you find the solution helpfull then please upvote it",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* the intitution is very simple\\nfirst sort the array \\nthen check wheather the value of seats[i] == students[i]\\nif the value is same that means the student already have a seat so no need to move\\nif the value is not same that menas the student needs to move in order to seat \\nso count the no of move \\n*/\\n\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        // first sort two arrays\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        // checking for edge case if array has no element then just return 0\\n        if(seats.length==0){\\n            return 0;\\n        }\\n        \\n        \\n        int moves = 0;\\n        for(int i = 0;i<seats.length;i++){\\n            //check at index i\\n            //if the value of seats is not equal to  then the value of student \\n            // that means the student need to move it\\'s position to seat, then\\n            // the difference between the seat value and student value will be the no of moves\\n            \\n            \\n            // count the moves accondig to the value\\n            if(seats[i]>students[i]){\\n                moves += seats[i]-students[i];\\n            }\\n            if(seats[i]<students[i]){\\n                moves += students[i]- seats[i];\\n            }\\n            \\n        }\\n        \\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531776,
                "title": "swift-2037-minimum-number-of-moves-to-seat-everyone-one-liner",
                "content": "```swift\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n        zip(seats.sorted(), students.sorted()).map { abs($0 - $1) }.reduce(0, +)\\n    }\\n```\\nIt\\'s also possible to combine the final map and reduce to:\\n```swift\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n        zip(seats.sorted(), students.sorted()).reduce(0) { $0 + abs($1.0 - $1.1) }\\n    }\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n        zip(seats.sorted(), students.sorted()).map { abs($0 - $1) }.reduce(0, +)\\n    }\\n```\n```swift\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n        zip(seats.sorted(), students.sorted()).reduce(0) { $0 + abs($1.0 - $1.1) }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525809,
                "title": "if-you-put-things-in-order-then-everything-becomes-easier",
                "content": "```\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int minMovesToSeat = 0;\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        for(int i = 0;  i < seats.length; i++){\\n            minMovesToSeat += Math.abs(seats[i] - students[i]);\\n        }\\n        \\n        return minMovesToSeat;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int minMovesToSeat = 0;\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        for(int i = 0;  i < seats.length; i++){\\n            minMovesToSeat += Math.abs(seats[i] - students[i]);\\n        }\\n        \\n        return minMovesToSeat;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524427,
                "title": "c-sorting-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tsort(seats.begin(), seats.end());\\n\\t\\t\\tsort(students.begin(), students.end());\\n\\t\\t\\tfor(int i = 0; i < seats.size(); i++){\\n\\t\\t\\t\\tres += abs(seats[i] - students[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tsort(seats.begin(), seats.end());\\n\\t\\t\\tsort(students.begin(), students.end());\\n\\t\\t\\tfor(int i = 0; i < seats.size(); i++){\\n\\t\\t\\t\\tres += abs(seats[i] - students[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1524335,
                "title": "c-solution-12-ms-sorting",
                "content": "```\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n\\tsort(seats.begin(),seats.end());\\n\\tsort(students.begin(),students.end());\\n\\tlong long ans=0;\\n\\tfor(int i=0;i<seats.size();i++)\\n\\t{\\n\\t\\tans+=abs(seats[i]-students[i]);\\n\\t}\\n\\treturn ans;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n\\tsort(seats.begin(),seats.end());\\n\\tsort(students.begin(),students.end());\\n\\tlong long ans=0;\\n\\tfor(int i=0;i<seats.size();i++)\\n\\t{\\n\\t\\tans+=abs(seats[i]-students[i]);\\n\\t}\\n\\treturn ans;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524331,
                "title": "c-sorting",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Sorting\\n\\nSort both arrays. Match each seat to the corresponding student with the same index with `abs(seats[i] - students[i])` moves.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& A, vector<int>& B) {\\n        sort(begin(A), end(A));\\n        sort(begin(B), end(B));\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += abs(A[i] - B[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& A, vector<int>& B) {\\n        sort(begin(A), end(A));\\n        sort(begin(B), end(B));\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += abs(A[i] - B[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524237,
                "title": "by-sorting-both-the-vector-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        \\n        sort(seats.begin(),seats.end());\\n        \\n        sort(students.begin(),students.end());\\n        \\n        int n= seats.size();\\n        int total=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            total+=abs(seats[i]-students[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        \\n        sort(seats.begin(),seats.end());\\n        \\n        sort(students.begin(),students.end());\\n        \\n        int n= seats.size();\\n        int total=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            total+=abs(seats[i]-students[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524233,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& v, vector<int>& vv) {\\n        \\n        sort(v.begin(), v.end());\\n        sort(vv.begin(), vv.end());\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            temp = abs(v[i] - vv[i]);\\n            ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& v, vector<int>& vv) {\\n        \\n        sort(v.begin(), v.end());\\n        sort(vv.begin(), vv.end());\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            temp = abs(v[i] - vv[i]);\\n            ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524226,
                "title": "easy-o-nlogn-approach-with-comments-and-explanation-c",
                "content": "Ques 1  \\n\\nEASY  O(NLOGN) Approach with comments and explanation C++\\nWe will sort both the students and the seat array, Now the most optimal seat for student[I] will seat[I]\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        int n=seats.size();\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=abs(seats[i]-students[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        int n=seats.size();\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=abs(seats[i]-students[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524215,
                "title": "c-using-sorting",
                "content": "```\\n   int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0; i<seats.size(); i++)\\n        {\\n            ans+=abs(seats[i]-students[i]);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n   int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0; i<seats.size(); i++)\\n        {\\n            ans+=abs(seats[i]-students[i]);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1524188,
                "title": "java-sort-simple",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        \\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves=0;\\n        \\n        for(int i=0;i<seats.length;i++)\\n        moves+=Math.abs(seats[i]-students[i]);\\n            \\n        return moves;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        \\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves=0;\\n        \\n        for(int i=0;i<seats.length;i++)\\n        moves+=Math.abs(seats[i]-students[i]);\\n            \\n        return moves;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735463,
                "title": "beats-100-simple-easy-to-understand-solution-o-nlogn",
                "content": "\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n\\n        int moves = 0;\\n\\n        for(int i=0; i<seats.length; i++){\\n            moves += Math.abs(seats[i] - students[i]);\\n        }\\n\\n        return moves;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n\\n        int moves = 0;\\n\\n        for(int i=0; i<seats.length; i++){\\n            moves += Math.abs(seats[i] - students[i]);\\n        }\\n\\n        return moves;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649101,
                "title": "97-beats-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(students);\\n        Arrays.sort(seats);\\n        int sum = 0;\\n        for(int i = 0; i < seats.length; i++) {\\n            sum += Math.abs(seats[i] - students[i]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(students);\\n        Arrays.sort(seats);\\n        int sum = 0;\\n        for(int i = 0; i < seats.length; i++) {\\n            sum += Math.abs(seats[i] - students[i]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568368,
                "title": "c-o-nlog-n-easy",
                "content": "# Intuition\\nThe main objective is to calculate is to calculate the minimum distance between the seats and students\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort both the vector so that every ith student is at its ith position seat. Then calculate the distance between them.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlog n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n\\n        // The maximum distance is\\n        int total_dis = 0;\\n        for(int i=0; i<seats.size(); i++){\\n            total_dis += abs(seats[i]-students[i]);\\n        }\\n\\n        return total_dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n\\n        // The maximum distance is\\n        int total_dis = 0;\\n        for(int i=0; i<seats.size(); i++){\\n            total_dis += abs(seats[i]-students[i]);\\n        }\\n\\n        return total_dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492673,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\tpublic int minMovesToSeat(int[] seats, int[] students) {\\n\\t\\tArrays.sort(seats);\\n\\t\\tArrays.sort(students);\\n\\t\\tint moves = 0;\\n\\t\\tfor (int i = 0; i < seats.length; i++) {\\n\\t\\t\\tmoves += Math.abs(seats[i] - students[i]);\\n\\t\\t}\\n\\t\\treturn moves;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int minMovesToSeat(int[] seats, int[] students) {\\n\\t\\tArrays.sort(seats);\\n\\t\\tArrays.sort(students);\\n\\t\\tint moves = 0;\\n\\t\\tfor (int i = 0; i < seats.length; i++) {\\n\\t\\t\\tmoves += Math.abs(seats[i] - students[i]);\\n\\t\\t}\\n\\t\\treturn moves;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267474,
                "title": "simple-c-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int count = 0;\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        for(int i=0;i<seats.size();++i){\\n            \\n                count+=abs(seats[i]-students[i]);\\n                \\n\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int count = 0;\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        for(int i=0;i<seats.size();++i){\\n            \\n                count+=abs(seats[i]-students[i]);\\n                \\n\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248521,
                "title": "minimum-number-of-moves-to-seat-everyone-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int i, j, count=0;\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n\\n        for(i=0 ; i<seats.size() ; i++)\\n        {\\n            count += abs(seats[i]-students[i]);\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/f285d5cd-7bee-45a5-b066-589e9dc0ac60_1683460958.5686083.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int i, j, count=0;\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n\\n        for(i=0 ; i<seats.size() ; i++)\\n        {\\n            count += abs(seats[i]-students[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121876,
                "title": "java-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count=0;\\n        for(int i=0;i<seats.length;i++){\\n            count+=Math.abs(seats[i]-students[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count=0;\\n        for(int i=0;i<seats.length;i++){\\n            count+=Math.abs(seats[i]-students[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091535,
                "title": "c-solution-fasterthan99-30",
                "content": "Runtime: 3 ms, faster than 99.30% of C++ online submissions for Minimum Number of Moves to Seat Everyone.\\nMemory Usage: 18.1 MB, less than 90.22% of C++ online submissions for Minimum Number of Moves to Seat Everyone.\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        \\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        \\n        int count=0;\\n        for(int i=0;i<seats.size();i++){\\n            int temp = abs(seats[i]-students[i]);\\n            \\n            count += temp;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        \\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        \\n        int count=0;\\n        for(int i=0;i<seats.size();i++){\\n            int temp = abs(seats[i]-students[i]);\\n            \\n            count += temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2770954,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0;i<seats.size();i++)\\n        {\\n            ans+=( students[i]>seats[i])?(students[i]-seats[i]):(seats[i]-students[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0;i<seats.size();i++)\\n        {\\n            ans+=( students[i]>seats[i])?(students[i]-seats[i]):(seats[i]-students[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751562,
                "title": "c-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& arr1, vector<int>& arr2) \\n{\\n    sort(arr1.begin(),arr1.end());\\n    sort(arr2.begin(),arr2.end());\\n    //1 3 5   2 4 7\\n    int ans=0;\\n    for(int i=0;i<arr1.size();i++)\\n    {\\n    \\tans=ans+(abs(arr1[i]-arr2[i]));\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& arr1, vector<int>& arr2) \\n{\\n    sort(arr1.begin(),arr1.end());\\n    sort(arr2.begin(),arr2.end());\\n    //1 3 5   2 4 7\\n    int ans=0;\\n    for(int i=0;i<arr1.size();i++)\\n    {\\n    \\tans=ans+(abs(arr1[i]-arr2[i]));\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566185,
                "title": "java-recommended-solution-100",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        sort(students);\\n        sort(seats);\\n        \\n        int movesCounter = 0;\\n        for(int i = 0; i < seats.length; i++)\\n            movesCounter += Math.abs(students[i] - seats[i]);\\n        \\n        return movesCounter;\\n    }\\n    \\n    public int[] sort(int[] arr) {\\n        for(int i = 0; i < arr.length - 1; i++)\\n            for(int j = i + 1; j < arr.length; j++)\\n                if(arr[j] > arr[i]) {\\n                    int x = arr[j];\\n                    arr[j] = arr[i];\\n                    arr[i] = x;\\n                }\\n                \\n        return arr;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        sort(students);\\n        sort(seats);\\n        \\n        int movesCounter = 0;\\n        for(int i = 0; i < seats.length; i++)\\n            movesCounter += Math.abs(students[i] - seats[i]);\\n        \\n        return movesCounter;\\n    }\\n    \\n    public int[] sort(int[] arr) {\\n        for(int i = 0; i < arr.length - 1; i++)\\n            for(int j = i + 1; j < arr.length; j++)\\n                if(arr[j] > arr[i]) {\\n                    int x = arr[j];\\n                    arr[j] = arr[i];\\n                    arr[i] = x;\\n                }\\n                \\n        return arr;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562460,
                "title": "sorting-both-and-sum-the-corresponding-diff-java-sol",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int moves=0;\\n       Arrays.sort(seats);\\n        Arrays.sort(students);\\n        for(int i=0;i<seats.length;i++){\\n            if(seats[i]>students[i])   moves+=seats[i]-students[i];\\n            if(seats[i]<=students[i])   moves+=students[i]-seats[i];\\n            \\n        }\\n        return moves;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int moves=0;\\n       Arrays.sort(seats);\\n        Arrays.sort(students);\\n        for(int i=0;i<seats.length;i++){\\n            if(seats[i]>students[i])   moves+=seats[i]-students[i];\\n            if(seats[i]<=students[i])   moves+=students[i]-seats[i];\\n            \\n        }\\n        return moves;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551836,
                "title": "easy-python3-solution-one-line",
                "content": "if it is helpful please **Upvote** me\\n ``` \\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        count = 0\\n        for i in range(len(seats)):\\n            count += abs(seats[i]-students[i])\\n        return count\\n``` \\n**One line approach **\\n``` \\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum(abs(a-b) for a,b in zip(sorted(students),sorted(seats)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` \\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        count = 0\\n        for i in range(len(seats)):\\n            count += abs(seats[i]-students[i])\\n        return count\\n```\n``` \\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum(abs(a-b) for a,b in zip(sorted(students),sorted(seats)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2479303,
                "title": "java-simple-solution-using-sorting",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves=0;\\n        for(int i=0;i<seats.length;i++){\\n            moves+= Math.abs(seats[i]-students[i]);\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves=0;\\n        for(int i=0;i<seats.length;i++){\\n            moves+= Math.abs(seats[i]-students[i]);\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472701,
                "title": "java-brute-force",
                "content": "**//Dev Bhayani\\n//Date: 24/08/2022**\\n\\nclass Solution {\\n    public int minMovesToSeat(int[] a, int[] b) {\\n       int n=a.length;\\n        int count=0;\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<n;i++)\\n        {\\n            count+=Math.abs(a[i]-b[i]);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minMovesToSeat(int[] a, int[] b) {\\n       int n=a.length;\\n        int count=0;\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<n;i++)\\n        {\\n            count+=Math.abs(a[i]-b[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2457034,
                "title": "easy-simple-5-liner-c-code",
                "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n    int n=seats.size();\\n    sort(seats.begin(),seats.end());\\n    sort(students.begin(),students.end());\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        count+=abs(students[i]-seats[i]);\\n    }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n    int n=seats.size();\\n    sort(seats.begin(),seats.end());\\n    sort(students.begin(),students.end());\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        count+=abs(students[i]-seats[i]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2438391,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def minMovesToSeat(self, seats, students):\\n        \"\"\"\\n        :type seats: List[int]\\n        :type students: List[int]\\n        :rtype: int\\n        \"\"\"\\n        seats.sort()\\n        students.sort()\\n        move=0\\n        for i in range(len(seats)):\\n            move += abs(seats[i]-students[i])\\n        return move\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minMovesToSeat(self, seats, students):\\n        \"\"\"\\n        :type seats: List[int]\\n        :type students: List[int]\\n        :rtype: int\\n        \"\"\"\\n        seats.sort()\\n        students.sort()\\n        move=0\\n        for i in range(len(seats)):\\n            move += abs(seats[i]-students[i])\\n        return move\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416844,
                "title": "python-easy-solution",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        count = 0\\n        for i in range(0,len(seats)):\\n            for j in range(i,len(students)):\\n                count = count + abs(seats[i]-students[j])\\n                break\\n        return count\\n\\'\\'\\'\\nRuntime: 95 ms, faster than 58.66% of Python3 online submissions for Minimum Number of Moves to Seat Everyone.",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        count = 0\\n        for i in range(0,len(seats)):\\n            for j in range(i,len(students)):\\n                count = count + abs(seats[i]-students[j])\\n                break\\n        return count\\n\\'\\'\\'\\nRuntime: 95 ms, faster than 58.66% of Python3 online submissions for Minimum Number of Moves to Seat Everyone.",
                "codeTag": "Java"
            },
            {
                "id": 2363113,
                "title": "easy-python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n\\n\\t\\t\\tseats.sort()\\n\\t\\t\\tstudents.sort()\\n\\n\\t\\t\\tmoves =0\\n\\n\\t\\t\\tfor i in range(len(seats)):\\n\\t\\t\\t\\tmoves += abs(seats[i] - students[i])\\n\\n\\n\\t\\t\\treturn moves",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n\\n\\t\\t\\tseats.sort()\\n\\t\\t\\tstudents.sort()\\n\\n\\t\\t\\tmoves =0\\n\\n\\t\\t\\tfor i in range(len(seats)):\\n\\t\\t\\t\\tmoves += abs(seats[i] - students[i])\\n\\n\\n\\t\\t\\treturn moves",
                "codeTag": "Java"
            },
            {
                "id": 2305212,
                "title": "c-sorting-priority-queue",
                "content": "**Sorting Method :**\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        int n = seats.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans += abs(students[i] - seats[i]);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\u200E\\n**Priority Queue Method :**\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        priority_queue<int> ss;\\n        priority_queue<int> st;\\n        int n = seats.size();\\n        for(int i = 0; i < n; i++){\\n            ss.push(seats[i]);\\n            st.push(students[i]);\\n        }\\n        int ans = 0;\\n        while(ss.size() != 0){\\n            ans += abs(ss.top() - st.top());\\n            ss.pop();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\u200E\\nIf you think this post was ***helpful***, I will be happy if you give a ***upvote***. Any questions or discussions are welcome! **Thanks a lot.** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        int n = seats.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans += abs(students[i] - seats[i]);\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        priority_queue<int> ss;\\n        priority_queue<int> st;\\n        int n = seats.size();\\n        for(int i = 0; i < n; i++){\\n            ss.push(seats[i]);\\n            st.push(students[i]);\\n        }\\n        int ans = 0;\\n        while(ss.size() != 0){\\n            ans += abs(ss.top() - st.top());\\n            ss.pop();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289490,
                "title": "easy-java-solution-by-sorting",
                "content": "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count = 0;\\n        for(int i = 0;i<seats.length;i++){\\n            count+= Math.abs((seats[i]-students[i]));\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count = 0;\\n        for(int i = 0;i<seats.length;i++){\\n            count+= Math.abs((seats[i]-students[i]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2284950,
                "title": "easy-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves=0;\\n        for(int i=0;i<seats.length;i++)\\n            moves+=(Math.abs(seats[i]-students[i]));\\n        return moves;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves=0;\\n        for(int i=0;i<seats.length;i++)\\n            moves+=(Math.abs(seats[i]-students[i]));\\n        return moves;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2258558,
                "title": "easiest-java-solution-sorting",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int min = 0;\\n        for(int i = 0; i < seats.length; i++){\\n            min+=Math.abs(seats[i] - students[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int min = 0;\\n        for(int i = 0; i < seats.length; i++){\\n            min+=Math.abs(seats[i] - students[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201436,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves = 0;\\n        for(int i = 0; i< seats.length; i++){\\n            moves += Math.abs(seats[i]-students[i]);\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int moves = 0;\\n        for(int i = 0; i< seats.length; i++){\\n            moves += Math.abs(seats[i]-students[i]);\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034797,
                "title": "java-easy-to-understand-code",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int n=seats.length,sum=0;\\n        for(int i=0;i<n;i++){\\n             sum=sum+Math.abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n**Please Upvote if you understand my code and comment your best code**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int n=seats.length,sum=0;\\n        for(int i=0;i<n;i++){\\n             sum=sum+Math.abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032479,
                "title": "python-code-with-sorting-using-min-function",
                "content": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        res=0\\n        \\n        for i in range(len(seats)):\\n            res+=abs(min(seats)-min(students))\\n            seats.remove(min(seats))\\n            students.remove(min(students))\\n        return res\\n           \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        res=0\\n        \\n        for i in range(len(seats)):\\n            res+=abs(min(seats)-min(students))\\n            seats.remove(min(seats))\\n            students.remove(min(students))\\n        return res\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026975,
                "title": "python-basic-approach-explained-with-notes",
                "content": "```\\n/*\\n    if we observe carefully, we will notice that no matter what the seats and students position are,\\n    the optimal choice would always be to assingn the max index of student to max index of seat, so on\\n    and so forth...\\n    example:\\n    seats = [4, 1, 5, 9] student = [1, 3, 2, 6]\\n    seats ->      1        4   5         9\\n    students ->   1  2  3         6\\n    it make sense to assign student 6 to seat 9, student 3 to seat 5, student 2 to seat 4 and student 1 \\n    to seat 1\\n    we can compute the absolute difference in each assignment and sum them together to\\n    get the final moves\\n*/\\n```\\n\\n```\\nclass Solution:\\n\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        moves = 0\\n        seats.sort()\\n        students.sort()\\n        for seat, student in zip(seats, students):\\n            moves+=abs(seat-student)\\n        return moves\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\n/*\\n    if we observe carefully, we will notice that no matter what the seats and students position are,\\n    the optimal choice would always be to assingn the max index of student to max index of seat, so on\\n    and so forth...\\n    example:\\n    seats = [4, 1, 5, 9] student = [1, 3, 2, 6]\\n    seats ->      1        4   5         9\\n    students ->   1  2  3         6\\n    it make sense to assign student 6 to seat 9, student 3 to seat 5, student 2 to seat 4 and student 1 \\n    to seat 1\\n    we can compute the absolute difference in each assignment and sum them together to\\n    get the final moves\\n*/\\n```\n```\\nclass Solution:\\n\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        moves = 0\\n        seats.sort()\\n        students.sort()\\n        for seat, student in zip(seats, students):\\n            moves+=abs(seat-student)\\n        return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026127,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats=sorted(seats)\\n        students=sorted(students)\\n        c=0\\n        for i in range(len(seats)):\\n            for j in range(len(students)):\\n                if i==j:\\n                    if students[j]>seats[i]:\\n                        c+=students[j]-seats[i]\\n                    elif students[j]<seats[i]:\\n                        c+=seats[j]-students[i]\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats=sorted(seats)\\n        students=sorted(students)\\n        c=0\\n        for i in range(len(seats)):\\n            for j in range(len(students)):\\n                if i==j:\\n                    if students[j]>seats[i]:\\n                        c+=students[j]-seats[i]\\n                    elif students[j]<seats[i]:\\n                        c+=seats[j]-students[i]\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021902,
                "title": "simple-java-solution-with-concept",
                "content": "\\nWe can approach this question by simple method\\nWe need to implement Greedy Algo\\n\\nFirst All of We sort both arrays seats and students\\nthen we all take absolute difference of seats[i] and students[j];\\n\\n\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        \\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        int i=0;\\n        int j=0;\\n        int result = 0;\\n        \\n        while(i<seats.length && j <students.length){\\n            \\n            int diff = Math.abs(seats[i] - students[j]);\\n            \\n            result = result + diff;\\n            i++;\\n            j++;\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```\\n\\n\\n\\n# **If You found useful , Kindly upvote**",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        \\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        \\n        int i=0;\\n        int j=0;\\n        int result = 0;\\n        \\n        while(i<seats.length && j <students.length){\\n            \\n            int diff = Math.abs(seats[i] - students[j]);\\n            \\n            result = result + diff;\\n            i++;\\n            j++;\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993521,
                "title": "minimum-number-of-moves-to-seat-everyone-easy-to-understand-solution",
                "content": "public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);//eg-1[1,3,5]\\n        Arrays.sort(students); //[2,4,7]\\n        // we will initialize the number of moves by 0;\\n        int numberOfMoves= 0;\\n        \\n        // we will loop througth the seat\\n        for(int i= 0;i<seats.length;i++){\\n            numberOfMoves += Math.abs(seats[i]- students[i]);\\n            // 2-1 = 1\\n            // 4-3= 1\\n            // 7-5 = 2\\n            // 2+1+1 = 4 \\n        }\\n        return numberOfMoves;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);//eg-1[1,3,5]\\n        Arrays.sort(students); //[2,4,7]\\n        // we will initialize the number of moves by 0;\\n        int numberOfMoves= 0;\\n        \\n        // we will loop througth the seat\\n        for(int i= 0;i<seats.length;i++){\\n            numberOfMoves += Math.abs(seats[i]- students[i]);\\n            // 2-1 = 1\\n            // 4-3= 1\\n            // 7-5 = 2\\n            // 2+1+1 = 4 \\n        }\\n        return numberOfMoves;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1991141,
                "title": "c-o-n-time-no-sorting",
                "content": "```\\nint minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize)\\n\\n{\\n\\nint i,stu[101]={0},sea[101]={0},j=1,count=0;\\n    \\nfor(i=0;i<seatsSize;i++)\\n{\\n    sea[seats[i]]++;\\n}\\nfor(i=0;i<studentsSize;i++)\\n{\\n    stu[students[i]]++;\\n}\\ni=1;    \\nwhile(i<101)\\n{\\n  if(stu[i]!=0)\\n  {\\n      while(j<101&&sea[j]==0)\\n      {\\n          j++;\\n      }\\n     count+=abs(j-i);\\n     stu[i]--;\\n     sea[j]--;\\n  }\\n  else\\n  {\\n      i++;\\n  }\\n}\\n    \\n  return count;\\n}",
                "solutionTags": [],
                "code": "```\\nint minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize)\\n\\n{\\n\\nint i,stu[101]={0},sea[101]={0},j=1,count=0;\\n    \\nfor(i=0;i<seatsSize;i++)\\n{\\n    sea[seats[i]]++;\\n}\\nfor(i=0;i<studentsSize;i++)\\n{\\n    stu[students[i]]++;\\n}\\ni=1;    \\nwhile(i<101)\\n{\\n  if(stu[i]!=0)\\n  {\\n      while(j<101&&sea[j]==0)\\n      {\\n          j++;\\n      }\\n     count+=abs(j-i);\\n     stu[i]--;\\n     sea[j]--;\\n  }\\n  else\\n  {\\n      i++;\\n  }\\n}\\n    \\n  return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1916371,
                "title": "c-solution",
                "content": "\\n      \\n      int minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize)\\n      {\\n              char temp;\\n          int sum = 0;\\n          for ( int i = 0 ; i < seatsSize ; i++)\\n          {\\n              for ( int j = i+1 ; j < seatsSize ; j++ )\\n              {\\n                  if  (  seats[i] > seats[j])\\n                  {\\n                  temp = seats[i];\\n                  seats[i] = seats[j];\\n                  seats[j] = temp;\\n                  }\\n                  \\n                  if  (  students[i] > students[j])\\n                  {\\n                  temp = students[i];\\n                  students[i] = students[j];\\n                  students[j] = temp;\\n                  }\\n              }\\n              \\n              sum = sum + abs(( students[i] - seats[i] ));\\n          }\\n          \\n          \\n          return sum;\\n      }",
                "solutionTags": [],
                "code": "\\n      \\n      int minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize)\\n      {\\n              char temp;\\n          int sum = 0;\\n          for ( int i = 0 ; i < seatsSize ; i++)\\n          {\\n              for ( int j = i+1 ; j < seatsSize ; j++ )\\n              {\\n                  if  (  seats[i] > seats[j])\\n                  {\\n                  temp = seats[i];\\n                  seats[i] = seats[j];\\n                  seats[j] = temp;\\n                  }\\n                  \\n                  if  (  students[i] > students[j])\\n                  {\\n                  temp = students[i];\\n                  students[i] = students[j];\\n                  students[j] = temp;\\n                  }\\n              }\\n              \\n              sum = sum + abs(( students[i] - seats[i] ));\\n          }\\n          \\n          \\n          return sum;\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 1845341,
                "title": "pyhton-clean-and-easy-to-understand-faster-than-99",
                "content": "![image](https://assets.leetcode.com/users/images/ac1f5176-e7f1-4a46-945e-25dc319b3886_1647161178.6164188.png)\\n```\\n\\t\\tx=sorted(seats)\\n        y=sorted(students)\\n        \\n        sum=0\\n\\n        for i in range(len(x)):\\n            sum=sum+abs(y[i]-x[i])\\n        \\n        return (sum)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\t\\tx=sorted(seats)\\n        y=sorted(students)\\n        \\n        sum=0\\n\\n        for i in range(len(x)):\\n            sum=sum+abs(y[i]-x[i])\\n        \\n        return (sum)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827464,
                "title": "simple-python-solution-easy-to-understand-90-faster",
                "content": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        c = 0\\n        for i, j in zip(seats, students):\\n            c += abs(j-i)\\n        return c\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        c = 0\\n        for i, j in zip(seats, students):\\n            c += abs(j-i)\\n        return c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755893,
                "title": "c-easy-soln",
                "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& s, vector<int>& s1) {\\n        sort(s.begin(),s.end());\\n         sort(s1.begin(),s1.end());\\n        int sum=0;\\n        for(int i=0; i<s.size(); i++){\\n                sum = sum+abs(s[i]-s1[i]);\\n          \\n        }\\n    return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& s, vector<int>& s1) {\\n        sort(s.begin(),s.end());\\n         sort(s1.begin(),s1.end());\\n        int sum=0;\\n        for(int i=0; i<s.size(); i++){\\n                sum = sum+abs(s[i]-s1[i]);\\n          \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1745060,
                "title": "c-o-nlogn-time-complexity-no-extra-memory-sorting",
                "content": "Please Upvote if you found this helpful.\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) \\n    {\\n        int ans= 0;\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        for(int i=0; i<seats.size(); i++)\\n        {\\n            ans+=(abs(seats[i]-students[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) \\n    {\\n        int ans= 0;\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        for(int i=0; i<seats.size(); i++)\\n        {\\n            ans+=(abs(seats[i]-students[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731537,
                "title": "ruby-zip-solution",
                "content": "```\\ndef min_moves_to_seat(seats, students)\\n    count = 0\\n    seats.sort.zip(students.sort).each { |a, b| count += (a - b).abs }\\n    return count\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef min_moves_to_seat(seats, students)\\n    count = 0\\n    seats.sort.zip(students.sort).each { |a, b| count += (a - b).abs }\\n    return count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1709040,
                "title": "c-o-n-logn-solution-via-sorting",
                "content": "I have used the simple approach and have first sorted the two arrays in ascending order. The only thing we teh had to do was to find the absolute difference of the corresponding elements of the 2 sorted arrays to find the minimum number of movements required.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<students.size();i++)\\n        {\\n            ans+=abs(seats[i]-students[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<students.size();i++)\\n        {\\n            ans+=abs(seats[i]-students[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1685464,
                "title": "easy-c-solution",
                "content": "```\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int sum=0;\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        for(int i=0;i<seats.size();i++)\\n        {\\n            sum+=abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int sum=0;\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        for(int i=0;i<seats.size();i++)\\n        {\\n            sum+=abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681993,
                "title": "java-solution",
                "content": "**Time Complexity : O(nlogn)**\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count = 0;\\n        for(int i=0; i<seats.length; i++){\\n            count += Math.abs(seats[i] - students[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count = 0;\\n        for(int i=0; i<seats.length; i++){\\n            count += Math.abs(seats[i] - students[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662827,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        \\n      Arrays.sort(seats);\\n      Arrays.sort(students);\\n      \\n     int moves = 0 ;\\n        for (int i = 0 ; i < seats.length ; i++){\\n            moves += Math.abs(seats[i] - students[i]);\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        \\n      Arrays.sort(seats);\\n      Arrays.sort(students);\\n      \\n     int moves = 0 ;\\n        for (int i = 0 ; i < seats.length ; i++){\\n            moves += Math.abs(seats[i] - students[i]);\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635993,
                "title": "javascript-counting-sort",
                "content": "```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n    // brute force would be to try every possible combination\\n    // and record its number of moves, then choosing the \\n    // one with fewer moves\\n    \\n    // a greedy approach would try to satisfy the best seat for student i, then\\n    // the best seat available for student i+1, and so on, in only one pass.\\n    \\n    // but somehow looks like the solution can be done with dynamic programming\\n    \\n    // we will use counting sort\\n    \\n    const arr_seats = new Array(Math.max(...seats) + 1).fill(0);\\n    const arr_students = new Array(Math.max(...students) + 1).fill(0);\\n    \\n    seats.forEach(seat => {\\n        arr_seats[seat] += 1;\\n    });\\n    \\n    students.forEach(student => {\\n        arr_students[student] += 1;\\n    });\\n    \\n    let i, j = 0;\\n    let result = 0;\\n    \\n    // iter over the sorted student array and then over the seats array to find seats for each student\\n    // advance in index only if student and seat in current position are all placed (repeated seats/student)\\n    for (i = 0; i < arr_students.length;) {\\n        if (arr_students[i] > 0) {\\n            while(j < arr_seats.length) {\\n                if (arr_seats[j] > 0) {\\n                    result += Math.abs(i - j);\\n                    arr_seats[j] -= 1;\\n                    arr_students[i] -= 1;\\n                    break;\\n                }\\n                j++;\\n            }\\n        }\\n        if (arr_students[i] === 0) {\\n            i++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n    // brute force would be to try every possible combination\\n    // and record its number of moves, then choosing the \\n    // one with fewer moves\\n    \\n    // a greedy approach would try to satisfy the best seat for student i, then\\n    // the best seat available for student i+1, and so on, in only one pass.\\n    \\n    // but somehow looks like the solution can be done with dynamic programming\\n    \\n    // we will use counting sort\\n    \\n    const arr_seats = new Array(Math.max(...seats) + 1).fill(0);\\n    const arr_students = new Array(Math.max(...students) + 1).fill(0);\\n    \\n    seats.forEach(seat => {\\n        arr_seats[seat] += 1;\\n    });\\n    \\n    students.forEach(student => {\\n        arr_students[student] += 1;\\n    });\\n    \\n    let i, j = 0;\\n    let result = 0;\\n    \\n    // iter over the sorted student array and then over the seats array to find seats for each student\\n    // advance in index only if student and seat in current position are all placed (repeated seats/student)\\n    for (i = 0; i < arr_students.length;) {\\n        if (arr_students[i] > 0) {\\n            while(j < arr_seats.length) {\\n                if (arr_seats[j] > 0) {\\n                    result += Math.abs(i - j);\\n                    arr_seats[j] -= 1;\\n                    arr_students[i] -= 1;\\n                    break;\\n                }\\n                j++;\\n            }\\n        }\\n        if (arr_students[i] === 0) {\\n            i++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1612579,
                "title": "c-easy-solution-4-ms-faster-than-97-06",
                "content": "```\\nint minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize)\\n{\\n    int countSeat[101] = {0};\\n    int countStudent[101] = {0};\\n    \\n\\t//sorting seats and students using count sort algorithm\\n    for(int i=0; i<seatsSize; i++)\\n        countSeat[seats[i]]++;\\n    \\n    for(int i=0; i<studentsSize; i++)\\n        countStudent[students[i]]++;\\n    \\n    int ans=0, ptr=0;\\n    for(int i=1; i<101; i++)\\n    {\\n        ptr+= countSeat[i]-countStudent[i];\\n        ans+= ptr>-ptr ? ptr : -ptr;\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize)\\n{\\n    int countSeat[101] = {0};\\n    int countStudent[101] = {0};\\n    \\n\\t//sorting seats and students using count sort algorithm\\n    for(int i=0; i<seatsSize; i++)\\n        countSeat[seats[i]]++;\\n    \\n    for(int i=0; i<studentsSize; i++)\\n        countStudent[students[i]]++;\\n    \\n    int ans=0, ptr=0;\\n    for(int i=1; i<101; i++)\\n    {\\n        ptr+= countSeat[i]-countStudent[i];\\n        ans+= ptr>-ptr ? ptr : -ptr;\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589575,
                "title": "python-3-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats = sorted(seats)\\n        students = sorted(students)\\n        ans = 0\\n        for i in range(len(seats)):\\n            ans += abs(seats[i] - students[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats = sorted(seats)\\n        students = sorted(students)\\n        ans = 0\\n        for i in range(len(seats)):\\n            ans += abs(seats[i] - students[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585772,
                "title": "javascript-solution",
                "content": "```\\nvar minMovesToSeat = function(seats, students) {\\n    seats.sort((a, b) => a - b)\\n    students.sort((a, b) => a - b)\\n    \\n    let counter = 0\\n    \\n    for(let i = 0; i < seats.length; i++) {\\n        while(seats[i] != students[i]) {\\n            if(seats[i] < students[i]) {\\n                students[i] -= 1\\n            } else if(seats[i] > students[i]) {\\n                students[i] += 1\\n            }\\n            counter++\\n        }\\n    }\\n    return counter\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minMovesToSeat = function(seats, students) {\\n    seats.sort((a, b) => a - b)\\n    students.sort((a, b) => a - b)\\n    \\n    let counter = 0\\n    \\n    for(let i = 0; i < seats.length; i++) {\\n        while(seats[i] != students[i]) {\\n            if(seats[i] < students[i]) {\\n                students[i] -= 1\\n            } else if(seats[i] > students[i]) {\\n                students[i] += 1\\n            }\\n            counter++\\n        }\\n    }\\n    return counter\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1579422,
                "title": "minimum-number-of-moves-to-seat-everyone-java-solution-easy-one",
                "content": "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int move=0;\\n        for(int i=0;i<seats.length;i++){\\n            move+=Math.abs(seats[i]-students[i]);\\n        }\\n        return move;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int move=0;\\n        for(int i=0;i<seats.length;i++){\\n            move+=Math.abs(seats[i]-students[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1572037,
                "title": "solution-using-c-sorting",
                "content": "int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        \\n        int sum=0;\\n        sort(students.begin(),students.end());\\n        sort(seats.begin(),seats.end());\\n        for(int i=0;i<seats.size();i++)\\n        {\\n            sum+=abs(students[i]-seats[i]);\\n        }\\n        return sum;\\n        \\n    }",
                "solutionTags": [],
                "code": "int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        \\n        int sum=0;\\n        sort(students.begin(),students.end());\\n        sort(seats.begin(),seats.end());\\n        for(int i=0;i<seats.size();i++)\\n        {\\n            sum+=abs(students[i]-seats[i]);\\n        }\\n        return sum;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1571899,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int res=0;\\n        for(int i=0;i<students.size();i++){\\n            res+=abs(seats[i]-students[i]);\\n        }     \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int res=0;\\n        for(int i=0;i<students.size();i++){\\n            res+=abs(seats[i]-students[i]);\\n        }     \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561063,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int counter = 0;\\n        for (int i = 0; i < seats.length; i ++)\\n            counter += (int) Math.abs(seats[i] - students[i]);\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int counter = 0;\\n        for (int i = 0; i < seats.length; i ++)\\n            counter += (int) Math.abs(seats[i] - students[i]);\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550317,
                "title": "java-easy-to-understand-1ms-beats-100-submissions",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count = 0;\\n        for(int i=0;i<seats.length;i++){\\n            count += Math.abs( seats[i] - students[i] );\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count = 0;\\n        for(int i=0;i<seats.length;i++){\\n            count += Math.abs( seats[i] - students[i] );\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546338,
                "title": "java-solution-in-3-lines",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats); \\n\\t\\tArrays.sort(students);\\n\\t\\t\\n        return IntStream.range(0, seats.length)\\n            .map(i -> Math.abs(seats[i] - students[i])).sum();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats); \\n\\t\\tArrays.sort(students);\\n\\t\\t\\n        return IntStream.range(0, seats.length)\\n            .map(i -> Math.abs(seats[i] - students[i])).sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537061,
                "title": "c-simple-solution",
                "content": "We sort the seats array and the students array to directly correlate the nearest seat with the nearest student thereby decreasing the number of moves required to move each student.\\n\\n```\\npublic class Solution {\\n    public int MinMovesToSeat(int[] seats, int[] students) {\\n        int moves = 0;\\n        Array.Sort(seats);\\n        Array.Sort(students);\\n        for(int i=0; i<seats.Length; i++)\\n        {\\n            moves += Math.Abs(seats[i] - students[i]);\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMovesToSeat(int[] seats, int[] students) {\\n        int moves = 0;\\n        Array.Sort(seats);\\n        Array.Sort(students);\\n        for(int i=0; i<seats.Length; i++)\\n        {\\n            moves += Math.Abs(seats[i] - students[i]);\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534523,
                "title": "c-sort-plus-linq",
                "content": "```\\npublic int MinMovesToSeat(int[] seats, int[] students) {\\n        Array.Sort(seats);\\n        Array.Sort(students);\\n        return seats.Zip(students, (seat, student) => Math.Abs(seat - student)).Sum();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MinMovesToSeat(int[] seats, int[] students) {\\n        Array.Sort(seats);\\n        Array.Sort(students);\\n        return seats.Zip(students, (seat, student) => Math.Abs(seat - student)).Sum();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527455,
                "title": "rust-simple-solution",
                "content": "```\\nimpl Solution {\\n    pub fn min_moves_to_seat(mut seats: Vec<i32>, mut students: Vec<i32>) -> i32 {\\n        seats.sort_unstable();\\n        students.sort_unstable();\\n        seats\\n            .iter()\\n            .zip(students.iter())\\n            .map(|(seat, stud)| (seat - stud).abs())\\n            .sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_moves_to_seat(mut seats: Vec<i32>, mut students: Vec<i32>) -> i32 {\\n        seats.sort_unstable();\\n        students.sort_unstable();\\n        seats\\n            .iter()\\n            .zip(students.iter())\\n            .map(|(seat, stud)| (seat - stud).abs())\\n            .sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525435,
                "title": "greedy-c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0; i<seats.size();i++){\\n          ans+= abs(students[i]-seats[i]);     \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0; i<seats.size();i++){\\n          ans+= abs(students[i]-seats[i]);     \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1524642,
                "title": "c-easy-understanding-approach-with-proper-explanation-and-dry-run-using-sorting",
                "content": "**Simple Approach Step-by-Step Explanation**\\n\\n* sort both the given vectors seats and students\\n* keep a variable ans and initialize it 0 where we would store the moves.\\n* Since, both the vectors have a similar size iterate through any of them and find the difference between every elements of vector and add it to ans.\\n\\nFor eg:  seats = [3,1,5], students = [2,7,4]\\n\\t\\t\\tAfter sorting: [1,3,5] [2,4,7]\\n\\t\\t\\t\\n\\t\\t\\t1st iteration: diff= abs(1-2) = 1 add to ans=0 (0+1)\\n\\t\\t\\t2nd iteration: diff=abs(3-4)=1 add to ans=(1+1)=2\\n\\t\\t\\t3rd iteration: diff=abs(5-7)=2 add to ans=(2+2)=4\\n\\t\\t\\t\\n\\t    sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0;i<=seats.size()-1;i++){    \\n                  ans+=abs(seats[i]-students[i]);       \\n            } \\n        return ans;\\n\\t\\t\\t\\n\\t\\t\\tThus we get our answer! Hope you like it if you have any doubts post them down below\\n\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "**Simple Approach Step-by-Step Explanation**\\n\\n* sort both the given vectors seats and students\\n* keep a variable ans and initialize it 0 where we would store the moves.\\n* Since, both the vectors have a similar size iterate through any of them and find the difference between every elements of vector and add it to ans.\\n\\nFor eg:  seats = [3,1,5], students = [2,7,4]\\n\\t\\t\\tAfter sorting: [1,3,5] [2,4,7]\\n\\t\\t\\t\\n\\t\\t\\t1st iteration: diff= abs(1-2) = 1 add to ans=0 (0+1)\\n\\t\\t\\t2nd iteration: diff=abs(3-4)=1 add to ans=(1+1)=2\\n\\t\\t\\t3rd iteration: diff=abs(5-7)=2 add to ans=(2+2)=4\\n\\t\\t\\t\\n\\t    sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int ans=0;\\n        for(int i=0;i<=seats.size()-1;i++){    \\n                  ans+=abs(seats[i]-students[i]);       \\n            } \\n        return ans;\\n\\t\\t\\t\\n\\t\\t\\tThus we get our answer! Hope you like it if you have any doubts post them down below\\n\\t\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1524608,
                "title": "c-sorting-method",
                "content": "```\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n=seats.size();\\n        int sum=0;\\n       sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        for(int i=0;i<n;i++)\\n        {\\n                sum=sum+(abs(seats[i]-students[i]));\\n         }\\n        return sum;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n=seats.size();\\n        int sum=0;\\n       sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        for(int i=0;i<n;i++)\\n        {\\n                sum=sum+(abs(seats[i]-students[i]));\\n         }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1524468,
                "title": "javascript-solution",
                "content": "var minMovesToSeat = function(seats, students) {\\n\\n    seats.sort((a,b) => b - a);\\n    students.sort((a,b) => b - a);\\n    let res = 0;\\n\\t\\n\\t  for(let k = 0; k < students.length; k++){\\n\\t\\t  res += Math.abs(students[k] - seats[k]);\\n\\t  }\\n    \\n    return res;\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var minMovesToSeat = function(seats, students) {\\n\\n    seats.sort((a,b) => b - a);\\n    students.sort((a,b) => b - a);\\n    let res = 0;\\n\\t\\n\\t  for(let k = 0; k < students.length; k++){\\n\\t\\t  res += Math.abs(students[k] - seats[k]);\\n\\t  }\\n    \\n    return res;\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1524391,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count=0;\\n        if(seats.length>students.length | seats.length<students.length) return -1;\\n        for(int i=0;i<seats.length;i++){\\n            if(seats[i]!=students[i]){\\n                int diff = Math.abs(seats[i]-students[i]);\\n                count+=diff;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n        int count=0;\\n        if(seats.length>students.length | seats.length<students.length) return -1;\\n        for(int i=0;i<seats.length;i++){\\n            if(seats[i]!=students[i]){\\n                int diff = Math.abs(seats[i]-students[i]);\\n                count+=diff;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524234,
                "title": "c-using-sorting",
                "content": "**Logic:** After sorting, for some int i, if seats[i] == students[i], then 0 movement is required, while if they are not equal abs(seats[i] - students[i]) movement is required.\\n\\n\\tint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int res = 0;\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(), students.end());\\n        for(int i=0; i<seats.size(); i++){\\n            res += abs(seats[i] - students[i]);\\n        }\\n        return res;\\n    }\\n\\t\\n**T.C:** O(NlogN)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**Logic:** After sorting, for some int i, if seats[i] == students[i], then 0 movement is required, while if they are not equal abs(seats[i] - students[i]) movement is required.\\n\\n\\tint minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int res = 0;\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(), students.end());\\n        for(int i=0; i<seats.size(); i++){\\n            res += abs(seats[i] - students[i]);\\n        }\\n        return res;\\n    }\\n\\t\\n**T.C:** O(NlogN)",
                "codeTag": "Unknown"
            },
            {
                "id": 1524224,
                "title": "c-o-mlogm-nlogn-find-nearest-seat",
                "content": "```csharp\\npublic int MinMovesToSeat(int[] seats, int[] students)\\n{\\n\\tArray.Sort(seats);\\n\\tArray.Sort(students);\\n\\tint result = 0;\\n\\n\\tfor(int i = 0; i < seats.Length; i++)\\n\\t{\\n\\t\\tresult += Math.Abs(students[i] - seats[i]);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinMovesToSeat(int[] seats, int[] students)\\n{\\n\\tArray.Sort(seats);\\n\\tArray.Sort(students);\\n\\tint result = 0;\\n\\n\\tfor(int i = 0; i < seats.Length; i++)\\n\\t{\\n\\t\\tresult += Math.Abs(students[i] - seats[i]);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524217,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] st) {\\n        Arrays.sort(seats);\\n        Arrays.sort(st);\\n        \\n        int res = 0;\\n        \\n        for(int i = 0; i < st.length; i++){\\n            res += Math.abs(st[i] - seats[i]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] st) {\\n        Arrays.sort(seats);\\n        Arrays.sort(st);\\n        \\n        int res = 0;\\n        \\n        for(int i = 0; i < st.length; i++){\\n            res += Math.abs(st[i] - seats[i]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524212,
                "title": "c-5-liners-o-nlogn-solution-using-sort",
                "content": "```\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) \\n{\\n\\tint result=0,n=students.size();\\n\\tsort(seats.begin(),seats.end());\\n\\tsort(students.begin(),students.end());\\n\\tfor(int i=0;i<n;i++) result+=abs(students[i]-seats[i]);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minMovesToSeat(vector<int>& seats, vector<int>& students) \\n{\\n\\tint result=0,n=students.size();\\n\\tsort(seats.begin(),seats.end());\\n\\tsort(students.begin(),students.end());\\n\\tfor(int i=0;i<n;i++) result+=abs(students[i]-seats[i]);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524209,
                "title": "easy-solution-uses-sorting",
                "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int sum = 0;\\n        for(int i=0;i<seats.size();i++){\\n            sum += abs(seats[i] - students[i]);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int sum = 0;\\n        for(int i=0;i<seats.size();i++){\\n            sum += abs(seats[i] - students[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1524178,
                "title": "c-easy-to-understand-o-nlogn",
                "content": "Steps-\\n    1. Sort both arrays.\\n    2. Find distance of each student from closest seat.\\nTime complexity - ``` O(NlogN)```\\n```\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        int moves=0;\\n        for(int i=0; i<seats.size(); i++)\\n            moves+=abs(seats[i]-students[i]);\\n        return moves;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` O(NlogN)```\n```\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        int moves=0;\\n        for(int i=0; i<seats.size(); i++)\\n            moves+=abs(seats[i]-students[i]);\\n        return moves;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080737,
                "title": "php-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $seats\\n     * @param Integer[] $students\\n     * @return Integer\\n     */\\n        function minMovesToSeat($seats, $students) {\\n          sort($seats);\\n          sort($students);\\n          $result = 0;\\n\\n          for ($i = 0; $i < count($seats); $i++) {\\n            $result += abs($seats[$i] - $students[$i]);\\n          }\\n          return $result;\\n        }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $seats\\n     * @param Integer[] $students\\n     * @return Integer\\n     */\\n        function minMovesToSeat($seats, $students) {\\n          sort($seats);\\n          sort($students);\\n          $result = 0;\\n\\n          for ($i = 0; $i < count($seats); $i++) {\\n            $result += abs($seats[$i] - $students[$i]);\\n          }\\n          return $result;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078757,
                "title": "fast-and-optimal-solution",
                "content": "Very fast and optimal solution \\n\\n\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n       seats.sort()\\n       students.sort()\\n       c=0\\n       \\n       for pos in range(len(seats)):\\n           c=c+abs(seats[pos]-students[pos])\\n       return c\\n           \\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Very fast and optimal solution \\n\\n\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n       seats.sort()\\n       students.sort()\\n       c=0\\n       \\n       for pos in range(len(seats)):\\n           c=c+abs(seats[pos]-students[pos])\\n       return c\\n           \\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076426,
                "title": "the-easiest-fun-o-n-time-eat-seats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust use counting sort and discover how long does it take to bring students and chairs to each other.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Each student \"eats\" one seat.\\n* If the the previous students are fed, you don\\'t need to count distance.\\n* If you have some empty chairs, you could feed suddenly appeared students.\\n* Pass all 100 units and count how long does it take to feed suddenly appearing hungry students.\\n* Yes, it\\'s $$gready$$ and $$counting \\\\space sort$$.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n* You could find some other extraordinary solutions in my [profile](https://leetcode.com/almostmonday/) on the Solutions tab (I don\\'t post obvious or not interesting solutions at all.)\\n* If this was helpful, please upvote so that others can see this solution too.\\n---\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        d = [0] * 101\\n        for i in seats: d[i] += 1\\n        for i in students: d[i] -= 1\\n        res = s = 0\\n        for x in d:\\n            if s != 0: res += abs(s)\\n            s += x\\n        \\n        return res\\n```\\n\\nOr it could be:\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        d = [0] * 101\\n        for i in seats: d[i] += 1\\n        for i in students: d[i] -= 1\\n        res = s = 0\\n        for x in d:\\n            res += abs(s)\\n            s += x\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        d = [0] * 101\\n        for i in seats: d[i] += 1\\n        for i in students: d[i] -= 1\\n        res = s = 0\\n        for x in d:\\n            if s != 0: res += abs(s)\\n            s += x\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        d = [0] * 101\\n        for i in seats: d[i] += 1\\n        for i in students: d[i] -= 1\\n        res = s = 0\\n        for x in d:\\n            res += abs(s)\\n            s += x\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073683,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n = seats.size();\\n        \\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            int x = abs(seats[i] - students[i]);\\n            ans += x;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n = seats.size();\\n        \\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            int x = abs(seats[i] - students[i]);\\n            ans += x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4069638,
                "title": "python-simple-wioth-explanation-3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        #INITIALISE ANS=0\\n        ans=0\\n        #SORT THE LISTS\\n        seats.sort()\\n        students.sort()\\n        #APPEND DIFFERENCE TO ANS\\n        for i in range(len(seats)):\\n            ans+=abs(seats[i]-students[i])\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        #INITIALISE ANS=0\\n        ans=0\\n        #SORT THE LISTS\\n        seats.sort()\\n        students.sort()\\n        #APPEND DIFFERENCE TO ANS\\n        for i in range(len(seats)):\\n            ans+=abs(seats[i]-students[i])\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065535,
                "title": "solution-with-sort-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int count = 0;\\n        int min_local = INT_MAX;\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        for (int i = 0; i <= seats.size() - 1; i++) {\\n           if (students[i] > seats[i]) count += students[i] - seats[i];\\n           else count += seats[i] - students[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int count = 0;\\n        int min_local = INT_MAX;\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        for (int i = 0; i <= seats.size() - 1; i++) {\\n           if (students[i] > seats[i]) count += students[i] - seats[i];\\n           else count += seats[i] - students[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064387,
                "title": "sort-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        return sum([abs(students[i] - seats[i]) for i in range(len(seats))])\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        return sum([abs(students[i] - seats[i]) for i in range(len(seats))])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063420,
                "title": "beats-100-java-solution-using-quick-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int n = seats.length;\\n        quickSort(seats, 0, n - 1);\\n        quickSort(students, 0, n - 1);\\n\\n        int moves = 0;\\n        for(int i=0; i<n; i++){\\n            moves += Math.abs(seats[i] - students[i]);\\n        }\\n\\n        return moves;\\n    }\\n\\n    static void swap(int[] arr, int i, int j)\\n    {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n \\n    // This function takes last element as pivot,\\n    // places the pivot element at its correct position\\n    // in sorted array, and places all smaller to left\\n    // of pivot and all greater elements to right of pivot\\n    static int partition(int[] arr, int low, int high)\\n    {\\n        // Choosing the pivot\\n        int pivot = arr[high];\\n \\n        // Index of smaller element and indicates\\n        // the right position of pivot found so far\\n        int i = (low - 1);\\n \\n        for (int j = low; j <= high - 1; j++) {\\n \\n            // If current element is smaller than the pivot\\n            if (arr[j] < pivot) {\\n \\n                // Increment index of smaller element\\n                i++;\\n                swap(arr, i, j);\\n            }\\n        }\\n        swap(arr, i + 1, high);\\n        return (i + 1);\\n    }\\n \\n    // The main function that implements QuickSort\\n    // arr[] --> Array to be sorted,\\n    // low --> Starting index,\\n    // high --> Ending index\\n    static void quickSort(int[] arr, int low, int high)\\n    {\\n        if (low < high) {\\n \\n            // pi is partitioning index, arr[p]\\n            // is now at right place\\n            int pi = partition(arr, low, high);\\n \\n            // Separately sort elements before\\n            // partition and after partition\\n            quickSort(arr, low, pi - 1);\\n            quickSort(arr, pi + 1, high);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int n = seats.length;\\n        quickSort(seats, 0, n - 1);\\n        quickSort(students, 0, n - 1);\\n\\n        int moves = 0;\\n        for(int i=0; i<n; i++){\\n            moves += Math.abs(seats[i] - students[i]);\\n        }\\n\\n        return moves;\\n    }\\n\\n    static void swap(int[] arr, int i, int j)\\n    {\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n \\n    // This function takes last element as pivot,\\n    // places the pivot element at its correct position\\n    // in sorted array, and places all smaller to left\\n    // of pivot and all greater elements to right of pivot\\n    static int partition(int[] arr, int low, int high)\\n    {\\n        // Choosing the pivot\\n        int pivot = arr[high];\\n \\n        // Index of smaller element and indicates\\n        // the right position of pivot found so far\\n        int i = (low - 1);\\n \\n        for (int j = low; j <= high - 1; j++) {\\n \\n            // If current element is smaller than the pivot\\n            if (arr[j] < pivot) {\\n \\n                // Increment index of smaller element\\n                i++;\\n                swap(arr, i, j);\\n            }\\n        }\\n        swap(arr, i + 1, high);\\n        return (i + 1);\\n    }\\n \\n    // The main function that implements QuickSort\\n    // arr[] --> Array to be sorted,\\n    // low --> Starting index,\\n    // high --> Ending index\\n    static void quickSort(int[] arr, int low, int high)\\n    {\\n        if (low < high) {\\n \\n            // pi is partitioning index, arr[p]\\n            // is now at right place\\n            int pi = partition(arr, low, high);\\n \\n            // Separately sort elements before\\n            // partition and after partition\\n            quickSort(arr, low, pi - 1);\\n            quickSort(arr, pi + 1, high);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059956,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum(abs(seat-student) for seat, student in zip(sorted(seats), sorted(students)))       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum(abs(seat-student) for seat, student in zip(sorted(seats), sorted(students)))       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059507,
                "title": "easy-python-solution-python",
                "content": "# EASY PYTHON SOLUTION || PYTHON || \\u270C\\u270C\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        res = 0\\n        for i in range(0,len(seats)):\\n            res += abs(seats[i] - students[i])\\n    \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        res = 0\\n        for i in range(0,len(seats)):\\n            res += abs(seats[i] - students[i])\\n    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056625,
                "title": "swift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n        \\nvar sortedSeats = seats.sorted()\\n    var sortedStudents = students.sorted()\\n    \\n    return sortedSeats\\n        .enumerated()\\n        .map { (i, n) -> Int in\\n            \\n            abs(n - sortedStudents[i])\\n            \\n        }\\n        .reduce(0, { $0 + $1 })\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n        \\nvar sortedSeats = seats.sorted()\\n    var sortedStudents = students.sorted()\\n    \\n    return sortedSeats\\n        .enumerated()\\n        .map { (i, n) -> Int in\\n            \\n            abs(n - sortedStudents[i])\\n            \\n        }\\n        .reduce(0, { $0 + $1 })\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056303,
                "title": "c-easy-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n         //sort seats \\n         int sz=seats.size();\\n         sort(seats.begin(),seats.end());\\n         sort(students.begin(),students.end()); \\n         int sum=0;\\n         vector<int>vis(sz,false);\\n         for(int i=0;i<sz;i++)\\n            {\\n            \\n                 \\n                 //cout<<students[i]<<\" \"<<ele<<endl;\\n               sum=sum+abs(students[i]-seats[i]);\\n            }\\n            return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n         //sort seats \\n         int sz=seats.size();\\n         sort(seats.begin(),seats.end());\\n         sort(students.begin(),students.end()); \\n         int sum=0;\\n         vector<int>vis(sz,false);\\n         for(int i=0;i<sz;i++)\\n            {\\n            \\n                 \\n                 //cout<<students[i]<<\" \"<<ele<<endl;\\n               sum=sum+abs(students[i]-seats[i]);\\n            }\\n            return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4055638,
                "title": "easy-to-understand-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        ans=0\\n        for i in range(len(seats)):\\n            ans+=abs(students[i]-seats[i])\\n        return ans    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        ans=0\\n        for i in range(len(seats)):\\n            ans+=abs(students[i]-seats[i])\\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055634,
                "title": "simple-sorting-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple sorting technique!!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int sum =0;\\n        Arrays.sort(seats);//1 3 5\\n        Arrays.sort(students);//2 4 7\\n        for(int i=0; i<seats.length;i++){\\n          sum += Math.abs(students[i] - seats[i]); \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        int sum =0;\\n        Arrays.sort(seats);//1 3 5\\n        Arrays.sort(students);//2 4 7\\n        for(int i=0; i<seats.length;i++){\\n          sum += Math.abs(students[i] - seats[i]); \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052519,
                "title": "easy-python-solution",
                "content": "# Intuition\\nI first thought about using multiple loops and then solving but that was very hectic. After the first hint I was able to approach it pretty easily, the question is simple just have to think about it for a while.\\n\\n# Approach\\nfor minimum number of moves the smallest student should go to the smallest seat. Which is pretty obvious if you think about it.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minMovesToSeat(self, seats, students):\\n        \"\"\"\\n        :type seats: List[int]\\n        :type students: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        seats.sort(reverse = True)\\n        students.sort(reverse = True)\\n        for i in range(len(seats)):\\n            cnt += abs(seats[i] - students[i])\\n\\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minMovesToSeat(self, seats, students):\\n        \"\"\"\\n        :type seats: List[int]\\n        :type students: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        seats.sort(reverse = True)\\n        students.sort(reverse = True)\\n        for i in range(len(seats)):\\n            cnt += abs(seats[i] - students[i])\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048233,
                "title": "easy-solution-with-the-help-of-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(3n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n    const arr1 = seats.sort((a, b) => a - b)\\n    const arr2 = students.sort((a, b) => a - b)\\n    const arr3 = []\\n    for(let i=0; i<seats.length; i++){\\n        arr3[i] = Math.abs(arr1[i] - arr2[i])\\n    }\\n    return arr3.reduce((a, c) => a + c, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n    const arr1 = seats.sort((a, b) => a - b)\\n    const arr2 = students.sort((a, b) => a - b)\\n    const arr3 = []\\n    for(let i=0; i<seats.length; i++){\\n        arr3[i] = Math.abs(arr1[i] - arr2[i])\\n    }\\n    return arr3.reduce((a, c) => a + c, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039928,
                "title": "two-easy-c-solutions-explanation",
                "content": "# Explanation \\n  *Just sort both the given arrays and take absolute difference between each elements between the array.*\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Solution 1 (**Selection Sort**): $$O(1)$$ \\n- Solution 2 (**Quick Sort using qsort funciton**): $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n# Solution 1: With selection sort\\n```\\nint minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize){\\nint x;\\nfor(int i=0;i<seatsSize;i++)\\n{\\n    for(int j=i+1;j<seatsSize;j++)\\n    {\\n\\n        if(seats[i]>seats[j])\\n        {\\n          x=seats[i];\\n          seats[i]=seats[j];\\n          seats[j]=x;\\n        }\\n        \\n        if(students[i]>students[j])\\n        {\\n          x=students[i];\\n          students[i]=students[j];\\n         students[j]=x;\\n        }\\n    }\\n}\\nint sum=0;\\nfor(int i=0;i<seatsSize;i++)\\n{\\n  sum+=abs(seats[i]-students[i]);\\n}\\n\\nreturn sum;\\n}\\n```\\n\\n# Solution 2: With using qsort() function\\n\\n```\\nint compare(const void *a, const void *b){\\n    return(*(int*)a-*(int*)b);\\n}\\n\\nint minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize){\\n\\n    qsort(seats , seatsSize , sizeof(int) ,compare);\\n    qsort(students , studentsSize , sizeof(int) ,compare);\\n    int move = 0 ;\\n\\n    for(int i = 0 ; i < seatsSize ; i++) move += abs(seats[i] - students[i]); \\n\\n    return move;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize){\\nint x;\\nfor(int i=0;i<seatsSize;i++)\\n{\\n    for(int j=i+1;j<seatsSize;j++)\\n    {\\n\\n        if(seats[i]>seats[j])\\n        {\\n          x=seats[i];\\n          seats[i]=seats[j];\\n          seats[j]=x;\\n        }\\n        \\n        if(students[i]>students[j])\\n        {\\n          x=students[i];\\n          students[i]=students[j];\\n         students[j]=x;\\n        }\\n    }\\n}\\nint sum=0;\\nfor(int i=0;i<seatsSize;i++)\\n{\\n  sum+=abs(seats[i]-students[i]);\\n}\\n\\nreturn sum;\\n}\\n```\n```\\nint compare(const void *a, const void *b){\\n    return(*(int*)a-*(int*)b);\\n}\\n\\nint minMovesToSeat(int* seats, int seatsSize, int* students, int studentsSize){\\n\\n    qsort(seats , seatsSize , sizeof(int) ,compare);\\n    qsort(students , studentsSize , sizeof(int) ,compare);\\n    int move = 0 ;\\n\\n    for(int i = 0 ; i < seatsSize ; i++) move += abs(seats[i] - students[i]); \\n\\n    return move;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034623,
                "title": "javascript-solution-sort-math-abs",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n    seats.sort((a,b) => a-b)\\n    students.sort((a,b) => a-b)\\n    let res = 0\\n    for(let i = 0; i < students.length;i++) {\\n        res += Math.abs(students[i] - seats[i])\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n    seats.sort((a,b) => a-b)\\n    students.sort((a,b) => a-b)\\n    let res = 0\\n    for(let i = 0; i < students.length;i++) {\\n        res += Math.abs(students[i] - seats[i])\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032507,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n    var moves = 0\\n    var s = seats.sorted()\\n    var p = students.sorted()\\n    \\n    for i in 0..<seats.count {\\n        moves += abs(s[i] - p[i])\\n    }\\n    \\n    return moves\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n    var moves = 0\\n    var s = seats.sorted()\\n    var p = students.sorted()\\n    \\n    for i in 0..<seats.count {\\n        moves += abs(s[i] - p[i])\\n    }\\n    \\n    return moves\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016315,
                "title": "python-simple-solution-using-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        \\n        seats.sort()\\n        students.sort()\\n\\n        out = 0\\n        for i in range(len(seats)):\\n            out += abs(students[i]-seats[i])\\n\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        \\n        seats.sort()\\n        students.sort()\\n\\n        out = 0\\n        for i in range(len(seats)):\\n            out += abs(students[i]-seats[i])\\n\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013986,
                "title": "easy-approach-c-solution-using-sort-function-loop-88-66-beats-c-users-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int s=0;\\n        for(int i=0;i<seats.size();i++){\\n            int g=abs(seats[i]-students[i]);\\n            s+=g;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int s=0;\\n        for(int i=0;i<seats.size();i++){\\n            int g=abs(seats[i]-students[i]);\\n            s+=g;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013599,
                "title": "java-solution-without-sorting-only-with-array-straightforward",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        \\n        int[] seat = new int[102];\\n        int[] student = new int[102]; \\n\\n        for (int i = 0; i < seats.length; i++) {\\n            seat[seats[i]]++;\\n            student[students[i]]++;\\n        }\\n\\n        int shifts = 0;\\n        int seatIndex = 0, stundetIndex = 0;\\n        while(seatIndex != 101 && stundetIndex != 101) {\\n            if(seat[seatIndex] == 0) seatIndex++;\\n            if(student[stundetIndex] == 0) stundetIndex++;\\n            if (seat[seatIndex] != 0 && student[stundetIndex] != 0) {\\n                shifts += Math.abs(seatIndex - stundetIndex);\\n                seat[seatIndex]--;\\n                student[stundetIndex]--;\\n            }\\n        }    \\n        return shifts;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n        \\n        int[] seat = new int[102];\\n        int[] student = new int[102]; \\n\\n        for (int i = 0; i < seats.length; i++) {\\n            seat[seats[i]]++;\\n            student[students[i]]++;\\n        }\\n\\n        int shifts = 0;\\n        int seatIndex = 0, stundetIndex = 0;\\n        while(seatIndex != 101 && stundetIndex != 101) {\\n            if(seat[seatIndex] == 0) seatIndex++;\\n            if(student[stundetIndex] == 0) stundetIndex++;\\n            if (seat[seatIndex] != 0 && student[stundetIndex] != 0) {\\n                shifts += Math.abs(seatIndex - stundetIndex);\\n                seat[seatIndex]--;\\n                student[stundetIndex]--;\\n            }\\n        }    \\n        return shifts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013028,
                "title": "beating-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n  // Sort the arrays in ascending order to have seats and students in order.\\n  let sortedSeats = seats.sort((a, b) => a - b);\\n  let sortedStudents = students.sort((a, b) => a - b);\\n\\n  // Initialize a variable to keep track of the total number of moves.\\n  let totalMoves = 0;\\n\\n  // Iterate through the sorted arrays to calculate the moves needed for each student.\\n  for (let i = 0; i < sortedSeats.length; i++) {\\n    // Calculate the absolute difference between the seat and student positions.\\n    let move = Math.abs(sortedSeats[i] - sortedStudents[i]);\\n\\n    // Add the move to the total moves.\\n    totalMoves += move;\\n  }\\n\\n  // Return the total number of moves required to seat all students.\\n  return totalMoves;\\n};\\n\\n// Example usage:\\n// const seats = [3, 1, 5];\\n// const students = [2, 7, 4];\\n// const moves = minMovesToSeat(seats, students);\\n// console.log(\"Minimum moves:\", moves);\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n  // Sort the arrays in ascending order to have seats and students in order.\\n  let sortedSeats = seats.sort((a, b) => a - b);\\n  let sortedStudents = students.sort((a, b) => a - b);\\n\\n  // Initialize a variable to keep track of the total number of moves.\\n  let totalMoves = 0;\\n\\n  // Iterate through the sorted arrays to calculate the moves needed for each student.\\n  for (let i = 0; i < sortedSeats.length; i++) {\\n    // Calculate the absolute difference between the seat and student positions.\\n    let move = Math.abs(sortedSeats[i] - sortedStudents[i]);\\n\\n    // Add the move to the total moves.\\n    totalMoves += move;\\n  }\\n\\n  // Return the total number of moves required to seat all students.\\n  return totalMoves;\\n};\\n\\n// Example usage:\\n// const seats = [3, 1, 5];\\n// const students = [2, 7, 4];\\n// const moves = minMovesToSeat(seats, students);\\n// console.log(\"Minimum moves:\", moves);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006859,
                "title": "java-fast-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n\\n        int ans = 0;\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n\\n        for (int i = 0; i < seats.length; i++)\\n            ans += Math.abs(seats[i] - students[i]);\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToSeat(int[] seats, int[] students) {\\n\\n        int ans = 0;\\n        Arrays.sort(seats);\\n        Arrays.sort(students);\\n\\n        for (int i = 0; i < seats.length; i++)\\n            ans += Math.abs(seats[i] - students[i]);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990784,
                "title": "quick-sort-approach",
                "content": "# Intuition\\nSort the seats vector in ascending order. This way, the seats are arranged from left to right.\\n\\nSort the students vector in ascending order. This way, the students are arranged from left to right.\\n\\nIterate through both sorted vectors simultaneously, comparing the position of each student with the position of the corresponding seat.\\n\\nCalculate the absolute difference between each student\\'s position and their corresponding seat\\'s position. Sum up these differences to find the minimum number of moves required.\\n\\n# Approach\\n\\nDefine a quickSort function: Implement the quicksort algorithm to sort a vector in ascending order. This function takes the vector, the low index, and the high index as parameters.\\n\\nDefine a partition function: Implement the partitioning step of the quicksort algorithm to rearrange elements in the vector. It returns the index of the pivot element.\\n\\nIn the minMovesToSeat function:\\n\\nGet the size n of the seats vector.\\nSort both the seats and students vectors using the quickSort function.\\nInitialize a variable res to keep track of the total moves required (initially set to 0).\\n\\nIterate through both vectors simultaneously using a loop:\\n\\nCalculate the absolute difference between the position of the student (students[i]) and their corresponding seat (seats[i]).\\nAdd this absolute difference to the res variable.\\nReturn the res variable as the minimum number of moves required to seat the students.\\n\\nThe idea here is that by sorting both the seats and students vectors, you ensure that students are seated closest to their corresponding seats, and the absolute differences represent the minimum number of moves to achieve this arrangement. By summing these differences, you obtain the minimum total moves required to seat the students.\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void quickSort(vector<int>& arr, int low, int high){\\n        if(low < high){\\n            int pivot = partition(arr, low, high);\\n            quickSort(arr, low, pivot-1);\\n            quickSort(arr, pivot+1, high);\\n        }\\n    }\\n\\n    int partition(vector<int>& arr, int low, int high){\\n        int pivot = arr[high];\\n        int i = low-1;\\n\\n        for(int j=low; j<=high-1; j++){\\n            if(arr[j] < pivot){\\n                i++;\\n                swap(arr[i], arr[j]);\\n            }\\n        }\\n\\n        swap(arr[i+1], arr[high]);\\n        return i+1;\\n    }\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n\\n        int n = seats.size();\\n        int m = students.size();\\n\\n        quickSort(seats, 0, n-1);\\n        quickSort(students, 0, m-1);\\n\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            res += abs(seats[i] - students[i]);\\n        }\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void quickSort(vector<int>& arr, int low, int high){\\n        if(low < high){\\n            int pivot = partition(arr, low, high);\\n            quickSort(arr, low, pivot-1);\\n            quickSort(arr, pivot+1, high);\\n        }\\n    }\\n\\n    int partition(vector<int>& arr, int low, int high){\\n        int pivot = arr[high];\\n        int i = low-1;\\n\\n        for(int j=low; j<=high-1; j++){\\n            if(arr[j] < pivot){\\n                i++;\\n                swap(arr[i], arr[j]);\\n            }\\n        }\\n\\n        swap(arr[i+1], arr[high]);\\n        return i+1;\\n    }\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n\\n        int n = seats.size();\\n        int m = students.size();\\n\\n        quickSort(seats, 0, n-1);\\n        quickSort(students, 0, m-1);\\n\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            res += abs(seats[i] - students[i]);\\n        }\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985922,
                "title": "swift-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n        let sortedSeats = seats.sorted()\\n        var result = 0\\n\\n        for (index, student) in students.sorted().enumerated() {\\n            result += abs(student - sortedSeats[index])\\n        }\\n\\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minMovesToSeat(_ seats: [Int], _ students: [Int]) -> Int {\\n        let sortedSeats = seats.sorted()\\n        var result = 0\\n\\n        for (index, student) in students.sorted().enumerated() {\\n            result += abs(student - sortedSeats[index])\\n        }\\n\\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985242,
                "title": "brute-force-approach-cpp-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        \\n        int moves = 0;\\n        for (int i = 0; i < seats.size(); i++) {\\n            moves += abs(seats[i] - students[i]);\\n        }\\n        \\n        return moves;\\n   }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(), seats.end());\\n        sort(students.begin(), students.end());\\n        \\n        int moves = 0;\\n        for (int i = 0; i < seats.size(); i++) {\\n            moves += abs(seats[i] - students[i]);\\n        }\\n        \\n        return moves;\\n   }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983875,
                "title": "python-o-nlog-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        count=0\\n        for i,j in zip(seats,students):\\n            count+=abs(i-j)\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        count=0\\n        for i,j in zip(seats,students):\\n            count+=abs(i-j)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974861,
                "title": "c-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid swap(int *x, int *y){\\n    int temp = *x;\\n    *x = *y;\\n    *y = temp;\\n\\n}\\nvoid quicksort(int arr[], int l, int r){\\n    if(l >= r){\\n        return;\\n    }\\n\\n    int ptr1 = l;\\n    int ptr2 = l;\\n\\n    while(ptr2 != r){\\n        if(arr[ptr2] <= arr[r]){\\n            swap(&arr[ptr2], &arr[ptr1]);\\n            ptr1++;\\n        }\\n        ptr2++;\\n    }\\n    swap(&arr[ptr2], &arr[ptr1]);\\n\\n    quicksort(arr, l, ptr1 - 1);\\n    quicksort(arr, ptr1 + 1, r);\\n}\\n\\n\\nint minMovesToSeat(int* seats, int N, int* students, int studentsSize){\\n    int ans = 0;\\n    quicksort(seats,0, N - 1);\\n    quicksort(students,0, N - 1);\\n    for(int i = 0; i < N; i++){\\n        ans += fabs(seats[i] - students[i]);\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid swap(int *x, int *y){\\n    int temp = *x;\\n    *x = *y;\\n    *y = temp;\\n\\n}\\nvoid quicksort(int arr[], int l, int r){\\n    if(l >= r){\\n        return;\\n    }\\n\\n    int ptr1 = l;\\n    int ptr2 = l;\\n\\n    while(ptr2 != r){\\n        if(arr[ptr2] <= arr[r]){\\n            swap(&arr[ptr2], &arr[ptr1]);\\n            ptr1++;\\n        }\\n        ptr2++;\\n    }\\n    swap(&arr[ptr2], &arr[ptr1]);\\n\\n    quicksort(arr, l, ptr1 - 1);\\n    quicksort(arr, ptr1 + 1, r);\\n}\\n\\n\\nint minMovesToSeat(int* seats, int N, int* students, int studentsSize){\\n    int ans = 0;\\n    quicksort(seats,0, N - 1);\\n    quicksort(students,0, N - 1);\\n    for(int i = 0; i < N; i++){\\n        ans += fabs(seats[i] - students[i]);\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974392,
                "title": "python-program-count-the-moves-easy-solution",
                "content": "\\n# Approach\\nSteps:\\n1. Sort the given list of students and seats.\\n2. Use a varibale count..\\n3. apply a loop and increment the count for the difference of each position i of seats and students.\\n4. Take the positive value of difference.\\n5. Return the count\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        c = 0\\n\\n        for i in range(len(seats)):\\n            c += abs(seats[i]-students[i])   \\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        c = 0\\n\\n        for i in range(len(seats)):\\n            c += abs(seats[i]-students[i])   \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971646,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        ans = 0\\n        for i in range(len(seats)):\\n            a = seats[i] - students[i]\\n            ans += abs(a)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        seats.sort()\\n        students.sort()\\n        ans = 0\\n        for i in range(len(seats)):\\n            a = seats[i] - students[i]\\n            ans += abs(a)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970525,
                "title": "python-one-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum([abs(sorted(seats)[i] - sorted(students)[i]) for i in range(0, len(seats), 1)])\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        return sum([abs(sorted(seats)[i] - sorted(students)[i]) for i in range(0, len(seats), 1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970524,
                "title": "python-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        res = 0\\n        seats.sort(); students.sort()\\n        while seats:\\n            res += abs(seats.pop() - students.pop())\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\\n        res = 0\\n        seats.sort(); students.sort()\\n        while seats:\\n            res += abs(seats.pop() - students.pop())\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969917,
                "title": "simple-solution-100-workout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n   let total = 0\\n    seats=seats.sort((a,b)=>a-b)    \\n    students=students.sort((a,b)=>a-b)\\n    for(let i=0;i<students.length;i++)\\n        total+=Math.abs(students[i]-seats[i])\\n    return total \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} seats\\n * @param {number[]} students\\n * @return {number}\\n */\\nvar minMovesToSeat = function(seats, students) {\\n   let total = 0\\n    seats=seats.sort((a,b)=>a-b)    \\n    students=students.sort((a,b)=>a-b)\\n    for(let i=0;i<students.length;i++)\\n        total+=Math.abs(students[i]-seats[i])\\n    return total \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969910,
                "title": "simple-c-solution-with-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        int sum=0,diff;\\n        sort(students.begin(),students.end());\\n        for(int i=0;i<seats.size();i++){\\n           \\n            diff=abs(seats[i]-students[i]);\\n            sum = sum+diff;\\n          \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        sort(seats.begin(),seats.end());\\n        int sum=0,diff;\\n        sort(students.begin(),students.end());\\n        for(int i=0;i<seats.size();i++){\\n           \\n            diff=abs(seats[i]-students[i]);\\n            sum = sum+diff;\\n          \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575863,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1567683,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1782321,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1980995,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1576777,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 2068178,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1970424,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1948012,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1844618,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1787411,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1575863,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1567683,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1782321,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1980995,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1576777,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 2068178,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1970424,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1948012,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1844618,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            },
            {
                "id": 1787411,
                "content": [
                    {
                        "username": "rohit_998",
                        "content": "Please explain what the problem is asking for?"
                    },
                    {
                        "username": "niks1020",
                        "content": "imagine there is a class room with seats one behind another.\\nnow lets number the seats starting from 1,2,3,,....and so on.\\n\\nThe problem statement says that: \\nHey! I want you to fill those seats numbered (say) 3, 1, 5 \\nAnd you need to fill those by moving students from their original seats which is 2, 4, 7\\n\\nNow you need to move them in such a manner that no 2 students are on the same seat number.\\nThere is a catch explained in the last that, a seat can be a 2 seater seat or even more. Meaning the program asks you to fill the seat it can give you same seat number 2 or more times as well. \\nso in the third example you can see the seat array is [2,2,6,6] this means number 2 and number 6 seat are 2 seater seats and can accommodate 2 students each.\\nAnother catch explained is that in the beginning those students could be sitting on the same seat as well. (may be the seat on which those students are sitting is already a multi seater seat)\\n\\nThe end goal is to move students sitting in a certain seat position( positions gven in student array), to the position given in seats array.\\n"
                    },
                    {
                        "username": "stanniss5",
                        "content": "Can someone point me to an explanation as to why sorting presents the best solution? I don\\'t understand why sorting will results in the minimum answer."
                    },
                    {
                        "username": "fconstantinos",
                        "content": "Here is my attempt at a formal proof:\\n\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3310914/proof-why-sorting-works/"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "sort by using Arrays.sort(seats);"
                    },
                    {
                        "username": "Prateek73",
                        "content": "That way you can make a pair of positions that will always have minimum difference between seats and students"
                    },
                    {
                        "username": "ibodnarchuk",
                        "content": "It doesn\\'t matter which student is in which seat. You just want the minimum distance. Without sorting, you\\'d end up having to find the next minimum every single time."
                    },
                    {
                        "username": "Ankita04111970",
                        "content": "if you see carefully the main approach of the question is to make the elements of array students must be equal to the array of seats\\n according to the explanation given:\\nseats = [3,1,5], students = [2,7,4]\\n1>if we decrese students[0] = 2 by 1 move then it will equal to 1\\n2>if we decrese students[1] = 7 by 2 move then it will equal to 5\\n3>if we decrese students[2] = 4 by 1 move then it will equal to 3\\noutput = 4\\nnow you can see that students={1,5,3}\\nwhose elemets are equal to seats array\\n\\nNow if we sort both the arrays in increasing order \\nsuch that \\n1         3        5\\n|dif=1    | dif=1  |dif = 2      1+1+2=4(which is the output)\\n2         4        7\\nTHe absolute difference of elements will give the answer\\n You can find easy soltion here\\nhttps://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/3123922/easy-java-solution-with-explanation/\\n"
                    },
                    {
                        "username": "Subham_Singh-1",
                        "content": "Solved the problem using hints but still didn\\'t understand the problem\\n"
                    },
                    {
                        "username": "va_asu_",
                        "content": "with help of sorting both array we can easily get minimum number  of moves to seat everyone,but is it possible to solve this question in O(N)....."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Yes, it\\'s possible. The solution is [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "almostmonday",
                        "content": "Would you like the easiest fun **O(n) time** solution with explanations? It's [here](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/4076426/the-easiest-fun-o-n-eat-seats/)."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "In my opinion, this problem is not that easy, especially prove how the algorithm using sorting can give us correct result."
                    },
                    {
                        "username": "Frozencold",
                        "content": "I think due to the constraint that there are n seats for n students"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "One best way that I solve this question is using basic math without backtracking concept is sorting both array then create a new variable name sum=0 then , run loop tills no of seats then student =student -seats which create a new array after ware sum+student and return condition of sum>0 then print sum else -1*sum\\n\\n<b>This can pass upto 100test case out off 262</b>"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\\n        int n =seats.size();\\n        sort(seats.begin(),seats.end());\\n        sort(students.begin(),students.end());\\n        int i ,j;\\n        int sum=0;\\n        for(i=0;i<n;i++)\\n        {\\n            sum += abs(seats[i]-students[i]);\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "98ujjwal",
                        "content": "can someone explain the problem , its soo confusing.\\n"
                    }
                ]
            }
        ]
    }
]