[
    {
        "title": "Recover Binary Search Tree",
        "question_content": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\n&nbsp;\nExample 1:\n\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\nExample 2:\n\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [2, 1000].\n\t-231 <= Node.val <= 231 - 1\n\n&nbsp;\nFollow up: A solution using O(n) space is pretty straight-forward. Could you devise a constant O(1) space solution?",
        "solutions": [
            {
                "id": 32535,
                "title": "no-fancy-algorithm-just-simple-and-powerful-in-order-traversal",
                "content": "This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. \\n\\nLet's start by writing the in order traversal:\\n\\n    private void traverse (TreeNode root) {\\n       if (root == null)\\n          return;\\n       traverse(root.left);\\n       // Do some business\\n       traverse(root.right);\\n    }\\n\\nSo when we need to print the node values in order, we insert System.out.println(root.val) in the place of \"Do some business\".\\n\\nWhat is the business we are doing here?\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\". \\n\\nLet us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the \"do some business\" logic as finding the two elements. See the code below:\\n\\n    public class Solution {\\n        \\n        TreeNode firstElement = null;\\n        TreeNode secondElement = null;\\n        // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized\\n        TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);\\n        \\n        public void recoverTree(TreeNode root) {\\n            \\n            // In order traversal to find the two elements\\n            traverse(root);\\n            \\n            // Swap the values of the two nodes\\n            int temp = firstElement.val;\\n            firstElement.val = secondElement.val;\\n            secondElement.val = temp;\\n        }\\n        \\n        private void traverse(TreeNode root) {\\n            \\n            if (root == null)\\n                return;\\n                \\n            traverse(root.left);\\n            \\n            // Start of \"do some business\", \\n            // If first element has not been found, assign it to prevElement (refer to 6 in the example above)\\n            if (firstElement == null && prevElement.val >= root.val) {\\n                firstElement = prevElement;\\n            }\\n        \\n            // If first element is found, assign the second element to the root (refer to 2 in the example above)\\n            if (firstElement != null && prevElement.val >= root.val) {\\n                secondElement = root;\\n            }        \\n            prevElement = root;\\n\\n            // End of \"do some business\"\\n\\n            traverse(root.right);\\n    }\\n\\nAnd we are done, it is just that easy!",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        TreeNode firstElement = null;\\n        TreeNode secondElement = null;\\n        // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized\\n        TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);\\n        \\n        public void recoverTree(TreeNode root) {\\n            \\n            // In order traversal to find the two elements\\n            traverse(root);\\n            \\n            // Swap the values of the two nodes\\n            int temp = firstElement.val;\\n            firstElement.val = secondElement.val;\\n            secondElement.val = temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32559,
                "title": "detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer",
                "content": "To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.\\nIt take use of leaf nodes' right/left pointer to achieve O(1) space Traversal on a Binary Tree.\\nBelow is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration)\\n\\n    public void morrisTraversal(TreeNode root){\\n    \\t\\tTreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n\\nIn the above code, `System.out.println(root.val);`appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with\\n\\n        if(pre!=null && pre.val > root.val){\\n        \\tif(first==null){first = pre;second = root;}\\n        \\telse{second = root;}\\n      }\\n    pre = root;\\n\\neach time, the pre node and root are in order as `System.out.println(root.val);` outputs them in order.\\n\\nThen, come to how to specify the first wrong node and second wrong node.\\n\\nWhen they are not consecutive, the first time we meet `pre.val > root.val` ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet `pre.val > root.val` ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before.\\n\\nWhen they are consecutive, which means the case `pre.val > cur.val` will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected.\\n\\nBelow is the updated version on Morris Traversal.\\n\\n\\n    public void recoverTree(TreeNode root) {\\n            TreeNode pre = null;\\n            TreeNode first = null, second = null;\\n            // Morris Traversal\\n            TreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t    if(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t        if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t        else{second = root;}\\n    \\t\\t\\t\\t    }\\n    \\t\\t\\t\\t    pre = root;\\n    \\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tif(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t    if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t    else{second = root;}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tpre = root;\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// swap two node values;\\n    \\t\\tif(first!= null && second != null){\\n    \\t\\t    int t = first.val;\\n    \\t\\t    first.val = second.val;\\n    \\t\\t    second.val = t;\\n    \\t\\t}\\n        }",
                "solutionTags": [],
                "code": "To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.\\nIt take use of leaf nodes' right/left pointer to achieve O(1) space Traversal on a Binary Tree.\\nBelow is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration)\\n\\n    public void morrisTraversal(TreeNode root){\\n    \\t\\tTreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tSystem.out.println(root.val);\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n\\nIn the above code, `System.out.println(root.val);`appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with\\n\\n        if(pre!=null && pre.val > root.val){\\n        \\tif(first==null){first = pre;second = root;}\\n        \\telse{second = root;}\\n      }\\n    pre = root;\\n\\neach time, the pre node and root are in order as `System.out.println(root.val);` outputs them in order.\\n\\nThen, come to how to specify the first wrong node and second wrong node.\\n\\nWhen they are not consecutive, the first time we meet `pre.val > root.val` ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet `pre.val > root.val` ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before.\\n\\nWhen they are consecutive, which means the case `pre.val > cur.val` will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected.\\n\\nBelow is the updated version on Morris Traversal.\\n\\n\\n    public void recoverTree(TreeNode root) {\\n            TreeNode pre = null;\\n            TreeNode first = null, second = null;\\n            // Morris Traversal\\n            TreeNode temp = null;\\n    \\t\\twhile(root!=null){\\n    \\t\\t\\tif(root.left!=null){\\n    \\t\\t\\t\\t// connect threading for root\\n    \\t\\t\\t\\ttemp = root.left;\\n    \\t\\t\\t\\twhile(temp.right!=null && temp.right != root)\\n    \\t\\t\\t\\t\\ttemp = temp.right;\\n    \\t\\t\\t\\t// the threading already exists\\n    \\t\\t\\t\\tif(temp.right!=null){\\n    \\t\\t\\t\\t    if(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t        if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t        else{second = root;}\\n    \\t\\t\\t\\t    }\\n    \\t\\t\\t\\t    pre = root;\\n    \\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\ttemp.right = null;\\n    \\t\\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\t// construct the threading\\n    \\t\\t\\t\\t\\ttemp.right = root;\\n    \\t\\t\\t\\t\\troot = root.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tif(pre!=null && pre.val > root.val){\\n    \\t\\t\\t\\t    if(first==null){first = pre;second = root;}\\n    \\t\\t\\t\\t    else{second = root;}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tpre = root;\\n    \\t\\t\\t\\troot = root.right;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// swap two node values;\\n    \\t\\tif(first!= null && second != null){\\n    \\t\\t    int t = first.val;\\n    \\t\\t    first.val = second.val;\\n    \\t\\t    second.val = t;\\n    \\t\\t}\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 32539,
                "title": "tree-deserializer-and-visualizer-for-python",
                "content": "Wrote some tools for my own local testing. For example `deserialize('[1,2,3,null,null,4,null,null,5]')` will turn that into a tree and return the root [as explained in the FAQ](https://leetcode.com/faq/). I also wrote a visualizer. Two examples:\\n\\n`drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))`:\\n\\n![enter image description here][1]\\n\\n`drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))`:\\n\\n![enter image description here][2]\\n\\nHere's the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo.\\n\\n    class TreeNode:\\n        def __init__(self, val, left=None, right=None):\\n            self.val = val\\n            self.left = left\\n            self.right = right\\n        def __repr__(self):\\n            return 'TreeNode({})'.format(self.val)\\n        \\n    def deserialize(string):\\n        if string == '{}':\\n            return None\\n        nodes = [None if val == 'null' else TreeNode(int(val))\\n                 for val in string.strip('[]{}').split(',')]\\n        kids = nodes[::-1]\\n        root = kids.pop()\\n        for node in nodes:\\n            if node:\\n                if kids: node.left  = kids.pop()\\n                if kids: node.right = kids.pop()\\n        return root\\n    \\n    def drawtree(root):\\n        def height(root):\\n            return 1 + max(height(root.left), height(root.right)) if root else -1\\n        def jumpto(x, y):\\n            t.penup()\\n            t.goto(x, y)\\n            t.pendown()\\n        def draw(node, x, y, dx):\\n            if node:\\n                t.goto(x, y)\\n                jumpto(x, y-20)\\n                t.write(node.val, align='center', font=('Arial', 12, 'normal'))\\n                draw(node.left, x-dx, y-60, dx/2)\\n                jumpto(x, y-20)\\n                draw(node.right, x+dx, y-60, dx/2)\\n        import turtle\\n        t = turtle.Turtle()\\n        t.speed(0); turtle.delay(0)\\n        h = height(root)\\n        jumpto(0, 30*h)\\n        draw(root, 0, 30*h, 40*h)\\n        t.hideturtle()\\n        turtle.mainloop()\\n        \\n    if __name__ == '__main__':\\n        drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))\\n        drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))\\n\\n  [1]: http://pochmann.org/leetcode/images/tree1.png\\n  [2]: http://pochmann.org/leetcode/images/tree2.png",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "Wrote some tools for my own local testing. For example `deserialize('[1,2,3,null,null,4,null,null,5]')` will turn that into a tree and return the root [as explained in the FAQ](https://leetcode.com/faq/). I also wrote a visualizer. Two examples:\\n\\n`drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))`:\\n\\n![enter image description here][1]\\n\\n`drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))`:\\n\\n![enter image description here][2]\\n\\nHere's the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo.\\n\\n    class TreeNode:\\n        def __init__(self, val, left=None, right=None):\\n            self.val = val\\n            self.left = left\\n            self.right = right\\n        def __repr__(self):\\n            return 'TreeNode({})'.format(self.val)\\n        \\n    def deserialize(string):\\n        if string == '{}':\\n            return None\\n        nodes = [None if val == 'null' else TreeNode(int(val))\\n                 for val in string.strip('[]{}').split(',')]\\n        kids = nodes[::-1]\\n        root = kids.pop()\\n        for node in nodes:\\n            if node:\\n                if kids: node.left  = kids.pop()\\n                if kids: node.right = kids.pop()\\n        return root\\n    \\n    def drawtree(root):\\n        def height(root):\\n            return 1 + max(height(root.left), height(root.right)) if root else -1\\n        def jumpto(x, y):\\n            t.penup()\\n            t.goto(x, y)\\n            t.pendown()\\n        def draw(node, x, y, dx):\\n            if node:\\n                t.goto(x, y)\\n                jumpto(x, y-20)\\n                t.write(node.val, align='center', font=('Arial', 12, 'normal'))\\n                draw(node.left, x-dx, y-60, dx/2)\\n                jumpto(x, y-20)\\n                draw(node.right, x+dx, y-60, dx/2)\\n        import turtle\\n        t = turtle.Turtle()\\n        t.speed(0); turtle.delay(0)\\n        h = height(root)\\n        jumpto(0, 30*h)\\n        draw(root, 0, 30*h, 40*h)\\n        t.hideturtle()\\n        turtle.mainloop()\\n        \\n    if __name__ == '__main__':\\n        drawtree(deserialize('[1,2,3,null,null,4,null,null,5]'))\\n        drawtree(deserialize('[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]'))\\n\\n  [1]: http://pochmann.org/leetcode/images/tree1.png\\n  [2]: http://pochmann.org/leetcode/images/tree2.png",
                "codeTag": "Java"
            },
            {
                "id": 1962981,
                "title": "idea-inorder-traversal-easy-to-understand",
                "content": "I will try to explain the approach using diagrams and pseudo code : \\n\\n![image](https://assets.leetcode.com/users/images/452c1932-e252-4a64-a745-66cb4ef08b1a_1650349299.0155501.jpeg)\\n![image](https://assets.leetcode.com/users/images/66d468cc-dd11-4a36-958d-6ad68956ef96_1650349307.373912.jpeg)\\n\\nNow try to implement the actual problem.\\nHints : Firstly write the inorder traversal and try to follow the array approach of updating the prev,first and second and you will be able to solve it. \\nHere is my solution : \\n```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    void inorder(TreeNode root){\\n        if(root==null)\\n            return ;\\n        inorder(root.left);\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        if(root==null)\\n            return ; \\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n}\\n```\\n\\nHope you understood the approach :)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    void inorder(TreeNode root){\\n        if(root==null)\\n            return ;\\n        inorder(root.left);\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        if(root==null)\\n            return ; \\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32562,
                "title": "share-my-solutions-and-detailed-explanation-with-recursive-iterative-in-order-traversal-and-morris-traversal",
                "content": "In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val < curr.val. If not, then we found at least one incorrectly placed node\\n\\nSo the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back.\\n\\nNow the problem is if we found an incorrect pair where prev.val > curr.val, how do we know which node is the incorrect one?  The answer is it depends on whether we have found incorrect node before. So What is that?\\n\\nSince we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value.\\nTheir value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e.  when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don't know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node.\\n\\nTherefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.\\nIf it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, though\\nwe may have corner case that two incorrect nodes are in same pair.\\n\\nRecursive in-order traversal based on above idea:\\n\\n    public void recoverTree(TreeNode root) {\\n        //use inorder traversal to detect incorrect node\\n        \\n        inOrder(root);\\n        \\n\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    TreeNode prev = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void inOrder(TreeNode root){\\n        if(root == null) return;\\n        //search left tree\\n        inOrder(root.left);\\n        \\n        //in inorder traversal of BST, prev should always have smaller value than current value\\n        if(prev != null && prev.val >= root.val){\\n            //incorrect smaller node is always found as prev node\\n            if(first == null) first = prev;\\n          //incorrect larger node is always found as curr(root) node\\n            second = root;\\n        }\\n        \\n        \\n        //update prev node\\n        prev = root;\\n\\n        //search right tree\\n        inOrder(root.right);\\n    }\\n\\n\\niterative in-order traversal based on above idea:\\n\\n\\n    public void recoverTree(TreeNode root) {\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        while(!stack.isEmpty() ||  curr != null){\\n            if(curr != null){\\n                //visit curr's left subtree\\n                stack.push(curr);\\n                curr = curr.left;\\n            }else{\\n                //done left subtree of curr Node\\n                curr = stack.pop();\\n                \\n                //compare curr.val with prev.val if we have one\\n                if(prev != null && curr.val <= prev.val){\\n                    //incorrect smaller node is always found as prev node\\n                    if(first == null) first = prev;\\n                    //incorrect larger node is always found as curr node\\n                    second = curr;         \\n                }  \\n                \\n                //visit curr's right subtree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        //recover swapped nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\nBoth recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList\\n\\nTo reduce the space to constant space, we have to use Morris-traversal.\\n\\nMorris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during the\\ntraversal.  before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.\\nWe don't use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n)\\n\\nMorris-traversal based on above description:\\n\\n    public void recoverTree(TreeNode root) {\\n    \\t//Morris-traversal\\n    \\t\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode pred = null; //rightmost node in left tree\\n        TreeNode prev = null; \\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            //for each node, we compare it with prev node as we did in in-order-traversal\\n            if(prev != null && curr.val <= prev.val){\\n                if(first == null) first = prev;\\n                second = curr;\\n            }\\n            \\n            if(curr.left != null){\\n                //got left tree, then let's locate its rightmost node in left tree\\n                pred = curr.left;\\n                //we may have visited the left tree before, and connect the rightmost node with curr node (root node)\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n                \\n                if(pred.right == curr){\\n                    //if this left tree has been visited before, then we are done with it\\n                    //cut the connection with currNode and start visit curr's right tree\\n                    pred.right = null;\\n                    prev = curr;\\n                    curr = curr.right;\\n                }else{\\n                    //if this left tree has not been visited before, then we create a back edge from rightmost node\\n                    // to curr node, so we can return to the start point after done the left tree\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n                \\n            }else{\\n                //no left tree, then just visit its right tree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val < curr.val. If not, then we found at least one incorrectly placed node\\n\\nSo the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back.\\n\\nNow the problem is if we found an incorrect pair where prev.val > curr.val, how do we know which node is the incorrect one?  The answer is it depends on whether we have found incorrect node before. So What is that?\\n\\nSince we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value.\\nTheir value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e.  when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don't know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node.\\n\\nTherefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.\\nIf it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, though\\nwe may have corner case that two incorrect nodes are in same pair.\\n\\nRecursive in-order traversal based on above idea:\\n\\n    public void recoverTree(TreeNode root) {\\n        //use inorder traversal to detect incorrect node\\n        \\n        inOrder(root);\\n        \\n\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    TreeNode prev = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void inOrder(TreeNode root){\\n        if(root == null) return;\\n        //search left tree\\n        inOrder(root.left);\\n        \\n        //in inorder traversal of BST, prev should always have smaller value than current value\\n        if(prev != null && prev.val >= root.val){\\n            //incorrect smaller node is always found as prev node\\n            if(first == null) first = prev;\\n          //incorrect larger node is always found as curr(root) node\\n            second = root;\\n        }\\n        \\n        \\n        //update prev node\\n        prev = root;\\n\\n        //search right tree\\n        inOrder(root.right);\\n    }\\n\\n\\niterative in-order traversal based on above idea:\\n\\n\\n    public void recoverTree(TreeNode root) {\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        while(!stack.isEmpty() ||  curr != null){\\n            if(curr != null){\\n                //visit curr's left subtree\\n                stack.push(curr);\\n                curr = curr.left;\\n            }else{\\n                //done left subtree of curr Node\\n                curr = stack.pop();\\n                \\n                //compare curr.val with prev.val if we have one\\n                if(prev != null && curr.val <= prev.val){\\n                    //incorrect smaller node is always found as prev node\\n                    if(first == null) first = prev;\\n                    //incorrect larger node is always found as curr node\\n                    second = curr;         \\n                }  \\n                \\n                //visit curr's right subtree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        //recover swapped nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\nBoth recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList\\n\\nTo reduce the space to constant space, we have to use Morris-traversal.\\n\\nMorris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during the\\ntraversal.  before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.\\nWe don't use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n)\\n\\nMorris-traversal based on above description:\\n\\n    public void recoverTree(TreeNode root) {\\n    \\t//Morris-traversal\\n    \\t\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        \\n        TreeNode pred = null; //rightmost node in left tree\\n        TreeNode prev = null; \\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            //for each node, we compare it with prev node as we did in in-order-traversal\\n            if(prev != null && curr.val <= prev.val){\\n                if(first == null) first = prev;\\n                second = curr;\\n            }\\n            \\n            if(curr.left != null){\\n                //got left tree, then let's locate its rightmost node in left tree\\n                pred = curr.left;\\n                //we may have visited the left tree before, and connect the rightmost node with curr node (root node)\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n                \\n                if(pred.right == curr){\\n                    //if this left tree has been visited before, then we are done with it\\n                    //cut the connection with currNode and start visit curr's right tree\\n                    pred.right = null;\\n                    prev = curr;\\n                    curr = curr.right;\\n                }else{\\n                    //if this left tree has not been visited before, then we create a back edge from rightmost node\\n                    // to curr node, so we can return to the start point after done the left tree\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n                \\n            }else{\\n                //no left tree, then just visit its right tree\\n                prev = curr;\\n                curr = curr.right;\\n            }\\n        }\\n        \\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 187407,
                "title": "python-short-and-slick-solution-108ms-beats-100-both-stack-and-morris-versions",
                "content": "Here\\'s a full solution using stack-based (iterative) inorder traversal. Just to demonstrate how efficient this code is, I\\'ve included the code for a regular inorder traversal on the right:\\n```python\\ndef recoverTree(self, root):                                               |  def inorder(self, root):\\n    cur, prev, drops, stack = root, TreeNode(float(\\'-inf\\')), [], []        |      cur, stack = root, []\\n    while cur or stack:                                                    |      while cur or stack:\\n        while cur:                                                         |          while cur:\\n            stack.append(cur)                                              |              stack.append(cur)\\n            cur = cur.left                                                 |              cur = cur.left\\n        node = stack.pop()                                                 |          node = stack.pop()\\n        if node.val < prev.val: drops.append((prev, node))                 |          print(node.val)\\n        prev, cur = node, node.right                                       |          cur = node.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\\nFull solution using Morris inorder traversal:\\n```python\\ndef recoverTree(self, root):                                               |  def inorderMorris(self, root):\\n    cur, prev, drops = root, TreeNode(float(\\'-inf\\')), []                   |      cur = root\\n    while cur:                                                             |      while cur:\\n        if cur.left:                                                       |          if cur.left:\\n            temp = cur.left                                                |              temp = cur.left\\n            while temp.right and temp.right != cur: temp = temp.right      |              while temp.right and temp.right != cur: temp = temp.right\\n            if not temp.right:                                             |              if not temp.right:\\n                temp.right, cur = cur, cur.left                            |                  temp.right, cur = cur, cur.left\\n                continue                                                   |                  continue\\n            temp.right = None                                              |              temp.right = None\\n        if cur.val < prev.val: drops.append((prev, cur))                   |          print(cur.val)\\n        prev, cur = cur, cur.right                                         |          cur = cur.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\\n---\\n\\n### Explanation\\n\\nI don\\'t have any new ideas; just a cool way to implement an old idea.\\n\\nUse whatever inorder traversal you like (recursion/stack = O(log n) extra space, Morris = O(1) extra space). As most people have figured out pretty easily, the idea is to remember the last value you saw and compare it with the current value. If `lastValue > currentValue`, then we know that something is \"wrong\", but it\\'s not immediately clear which values have to be swapped.\\n\\nThere are 2 cases: The values that need to be swapped are either adjacent or not adjacent. If they\\'re adjacent, then there will be one \"drop\"; if they\\'re not adjacent, then there will be two \"drops\".\\n```abc\\nadjacent: ... _ < _ < A > B < _ < _ ...\\n                      ^^^^^\\n                      drop #1\\n\\nnot adjacent: ... _ < _ < A > X < _ < Y > B < _ < _ ... (X may be the same as Y, but it\\'s irrelevant)\\n                          ^^^^^       ^^^^^\\n                          drop #1     drop #2\\n```\\nIn both cases, we want to swap `A` and `B`. So the idea is to keep a `drops` array and append a tuple of `(lastNode, currentNode)` whenever we come across `lastValue > currentValue`. At the end of the traversal, the `drops` array must have either 1 or 2 tuples (otherwise, there would be more than 2 nodes that need to be swapped).\\n\\nHere\\'s the clear but not-so-clean way to swap them:\\n```python\\nif len(drops) == 1: # drops == [(A, B)]\\n    drops[0][0].val, drops[0][1].val = drops[0][1].val, drops[0][0].val\\nelse: # drops == [(A, X), (Y, B)]\\n    drops[0][0].val, drops[1][1].val = drops[1][1].val, drops[0][0].val\\n```\\nHere\\'s the clean but not-so-clear way that gets rid of the conditional branching:\\n```python\\ndrops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val\\n```",
                "solutionTags": [],
                "code": "```python\\ndef recoverTree(self, root):                                               |  def inorder(self, root):\\n    cur, prev, drops, stack = root, TreeNode(float(\\'-inf\\')), [], []        |      cur, stack = root, []\\n    while cur or stack:                                                    |      while cur or stack:\\n        while cur:                                                         |          while cur:\\n            stack.append(cur)                                              |              stack.append(cur)\\n            cur = cur.left                                                 |              cur = cur.left\\n        node = stack.pop()                                                 |          node = stack.pop()\\n        if node.val < prev.val: drops.append((prev, node))                 |          print(node.val)\\n        prev, cur = node, node.right                                       |          cur = node.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\n```python\\ndef recoverTree(self, root):                                               |  def inorderMorris(self, root):\\n    cur, prev, drops = root, TreeNode(float(\\'-inf\\')), []                   |      cur = root\\n    while cur:                                                             |      while cur:\\n        if cur.left:                                                       |          if cur.left:\\n            temp = cur.left                                                |              temp = cur.left\\n            while temp.right and temp.right != cur: temp = temp.right      |              while temp.right and temp.right != cur: temp = temp.right\\n            if not temp.right:                                             |              if not temp.right:\\n                temp.right, cur = cur, cur.left                            |                  temp.right, cur = cur, cur.left\\n                continue                                                   |                  continue\\n            temp.right = None                                              |              temp.right = None\\n        if cur.val < prev.val: drops.append((prev, cur))                   |          print(cur.val)\\n        prev, cur = cur, cur.right                                         |          cur = cur.right\\n    drops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val  |\\n```\n```abc\\nadjacent: ... _ < _ < A > B < _ < _ ...\\n                      ^^^^^\\n                      drop #1\\n\\nnot adjacent: ... _ < _ < A > X < _ < Y > B < _ < _ ... (X may be the same as Y, but it\\'s irrelevant)\\n                          ^^^^^       ^^^^^\\n                          drop #1     drop #2\\n```\n```python\\nif len(drops) == 1: # drops == [(A, B)]\\n    drops[0][0].val, drops[0][1].val = drops[0][1].val, drops[0][0].val\\nelse: # drops == [(A, X), (Y, B)]\\n    drops[0][0].val, drops[1][1].val = drops[1][1].val, drops[0][0].val\\n```\n```python\\ndrops[0][0].val, drops[-1][1].val = drops[-1][1].val, drops[0][0].val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1962281,
                "title": "c-easy-to-understand",
                "content": "If u use inorder traveral, problem will be find 2 mistakes in acending array and swap them\\nFor example array: 1 2 3 4 5 6 7\\n-> swap random two elments -> 1 2 6 4 5 3 7 (swap 3 and 6)\\n-> Question is how can know 2 elements is 3 and 6?\\n-> First: find the first number have index i satisfy arr[i - 1] > arr[i] => first mistake have index i - 1 (in the exam, first mistake is 6)\\n-> Second: continue but don\\'t change first mistake, if arr[i - 1] > arr[i] and u had found the first mistake => second mistake is i;\\nin the example second mistake in the first time is 4 change to 3\\n\\nIn the tree question, to keep compare, u need a variable is previous root.\\nBy @LemonHerbs :\\nif we encounter a tree looking like this:\\n\\n\\t   5\\n\\t  /   \\\\\\n\\t6     8\\n\\t\\t /\\n\\t\\t 4\\nfirstMistake will be assigned to 6, and in the same recursive call, secondMistake will be assigned to 5.\\nThen in the next recursive call, firstMistake will NOT be changed since it is not a null pointer, while secondMistake will be\\nupdated to 4. Then in the following recursions the 2 mistake nodes remain unchanged.\\nWhen inorder() returns to the main function recoverTree(), the 2 mistakes swap values and hence the correct BST.\\n\\n\\t   5\\n\\t  /   \\\\\\n\\t4     8\\n\\t\\t /\\n\\t\\t 6\\nCode:\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\t\\tvoid recoverTree(TreeNode* root) {\\n\\t\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\t\\tinorder(root);\\n\\t\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t\\t}\\n\\n\\t\\tvoid inorder(TreeNode* root) {\\n\\t\\t\\tif(root == nullptr) \\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tinorder(root->left);\\n\\n\\t\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\t\\tfirstMistake = pre;\\n\\t\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\t\\tsecondMistake = root;\\n\\t\\t\\tpre = root;\\n\\n\\t\\t\\tinorder(root->right);\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\t\\tvoid recoverTree(TreeNode* root) {\\n\\t\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\t\\tinorder(root);\\n\\t\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 917430,
                "title": "python-o-n-o-1-morris-traversal-explained",
                "content": "If we want to traverse our tree and do not use any additional memory, than as far as I know, Morris traversal is the only way how to do it. \\n\\nFor more details about Morris traversal, you can look at oficial solution of problem 94: Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/solution/.\\n\\nAlso, here we need to use variation of traversal, which keep the original structure of tree.\\n\\nLet us use this traversal and use `node` is current node we are in and `cands` are candidates for our swapped nodes. We will look at oddities in inorder traversal: in BST all numbers will always increase. So, if in inorder traversal some value is less than previous, we need to keep and eye on this node. There can be two main cases:\\n\\n1. We have `1, 2, 3, 4, 5` and swapped nodes are adjacent, for example `1, 2, 4, 3, 5`. In this case, we have only one oddity: `4` and `3`: and we save them to our `cands` list. And we need to change values for the first and for the last nodes in our `cands`.\\n2. We have `1, 2, 3, 4, 5` and swapped nodes are not adjacent, for example `1, 2, 5, 4, 3`. In this case we have two oddities: `5` and `4`; `4` and `3`.  In this case we again need to swap the first and the last nodes.\\n\\nSo, in both cases it is enough to run `cands[0].val, cands[-1].val = cands[-1].val, cands[0].val` to swap our nodes.\\n\\n**Complexity**: time complexity is `O(n)`: because we basically do Morris traverasal plus some additional `O(n)` operations. Space complexity is `O(1)`, becauswe we again do Morris traversal and also we have `node` and `cands`, where `cands` can have maximum size `4`.\\n\\n```\\nclass Solution:\\n    def recoverTree(self, root):\\n        cur, node, cands = root, TreeNode(-float(\"inf\")), []\\n        while cur:\\n            if cur.left:\\n                pre = cur.left\\n                while pre.right and pre.right != cur:\\n                    pre = pre.right\\n                if not pre.right:\\n                    pre.right = cur\\n                    cur = cur.left\\n                else:\\n                    pre.right = None\\n                    if cur.val < node.val:\\n                        cands += [node, cur]\\n                    node = cur\\n                    cur = cur.right\\n            else:\\n                if cur.val < node.val:\\n                    cands += [node, cur]\\n                node = cur\\n                cur = cur.right\\n            \\n        cands[0].val, cands[-1].val = cands[-1].val, cands[0].val\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root):\\n        cur, node, cands = root, TreeNode(-float(\"inf\")), []\\n        while cur:\\n            if cur.left:\\n                pre = cur.left\\n                while pre.right and pre.right != cur:\\n                    pre = pre.right\\n                if not pre.right:\\n                    pre.right = cur\\n                    cur = cur.left\\n                else:\\n                    pre.right = None\\n                    if cur.val < node.val:\\n                        cands += [node, cur]\\n                    node = cur\\n                    cur = cur.right\\n            else:\\n                if cur.val < node.val:\\n                    cands += [node, cur]\\n                node = cur\\n                cur = cur.right\\n            \\n        cands[0].val, cands[-1].val = cands[-1].val, cands[0].val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423225,
                "title": "c-clear-solution-with-explanation",
                "content": "In an inorder traversal, nodes should go from smallest to largest, if not we know there is an issue.\\nFor instance, if we have nodes 10 11 1 6 7 20 27, the inorder traversal should be\\n1 6 7 10 11 20 27. If it is anything else, you know two numbers are swapped. For instance, you could have:\\n1 7 6 10 11 20 27 (SITUATION 1), where two nodes sie by side are swapped, or 1 6  20 10 11 7 27 (SITUATION 2), where two nodes somewhere in the tree are flipped. We need to maintain a pointer to four locations:\\n\\n1. The previous node.  (prev)\\n2. The current node (root)\\n3. Our first flipped node (start)\\n4. Our second flipped node (end)\\n\\nAs we hit the first node in the inorder traversal, we mark it with prev (point prev to it). We then move onto the next node. This is when we want to start makiing the comparison. We then compare the previous node\\'s value to the current node\\'s value. So we\\'d compare 1 to 6. Since 6 is greater than 1, we continue. We compare 6 to 20. Since 20 is greater than 6, we continue. Then we get to 10, and 10 is less than 20, so we move our pointer to point to 20 as our first target. We set our second pointer (end) to the current node, since it may be the situation where the two flipped nodes are side by side (SITUATION 1). If that is NOT the case, our loop will be triggered again, and since our first pointer (start) is already occupied, our second pointer will now change to the second poorly placed node (SITUATION 2\\'s 7)\\n\\n```\\nclass Solution {\\nprivate:\\n    \\n    void markTree(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if (!root) return;\\n        markTree(root->left, prev, first, end);\\n        if (prev) {\\n            if (root->val < prev->val) {\\n                if (!first) {\\n                    first = prev;\\n                }\\n                end = root;\\n            }\\n        }\\n        prev = root;\\n        markTree(root->right, prev, first, end);\\n    }\\n    \\n    \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr, *first = nullptr, *end = nullptr;\\n        markTree(root, prev, first, end);\\n        swap(first->val, end->val);\\n        return;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\nprivate:\\n    \\n    void markTree(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if (!root) return;\\n        markTree(root->left, prev, first, end);\\n        if (prev) {\\n            if (root->val < prev->val) {\\n                if (!first) {\\n                    first = prev;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 917502,
                "title": "c-o-n-time-o-1-space-short-easy-code-with-explanation",
                "content": "The space O(1) does not consider recursion stack space.\\nThe idea is that, if we swap any 2 values in an ascending sorted array, then we may find irregularity in our array (i.e. arr[i]>arr[i+1]) at 2 places, and if we swap any 2 adjacent numbers then such irregularity occurs at ony 1 place.\\nSo the idea is to traverse the tree in inorder fashion and keeping a check on previous node and comparing the value of current node with previous node of inorder traversal. We save all such pairs of {curr, prev} nodes in an array.\\nThe size of array == 1 if 2 adjacent numbers were swapped, else the size of array == 2.\\nSo we have to accordingly swap the numbers to get back the original tree.\\n```\\nvector<pair<TreeNode*,TreeNode*>> vec;\\n    TreeNode* prev = NULL;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(prev && prev->val>root->val) vec.push_back({prev,root});\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if(vec.size()==1)\\n            swap(vec[0].first->val,vec[0].second->val);\\n        if(vec.size()==2)\\n            swap(vec[0].first->val,vec[1].second->val);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<pair<TreeNode*,TreeNode*>> vec;\\n    TreeNode* prev = NULL;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(prev && prev->val>root->val) vec.push_back({prev,root});\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if(vec.size()==1)\\n            swap(vec[0].first->val,vec[0].second->val);\\n        if(vec.size()==2)\\n            swap(vec[0].first->val,vec[1].second->val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32580,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explaination",
                "content": "Just use the \"first\" and \"second\" pointer to find the 2 nodes that violate the order. Then change the value of the first node ad the second node by their value.\\n\\n    class Solution {\\n        TreeNode* first=NULL;\\n        TreeNode* second=NULL;\\n        TreeNode* prev = new TreeNode(INT_MIN);\\n    public:\\n        void recoverTree(TreeNode* root) {\\n            help(root);\\n            swp(first->val, second->val);\\n        }\\n        \\n        void help(TreeNode* root){\\n            if(root==NULL)  return;\\n            help(root->left);\\n            if(first==NULL && prev->val >= root->val)   first=prev;\\n            if(first!=NULL && prev->val >= root->val)   second=root;\\n            prev=root;\\n            help(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        TreeNode* first=NULL;\\n        TreeNode* second=NULL;\\n        TreeNode* prev = new TreeNode(INT_MIN);\\n    public:\\n        void recoverTree(TreeNode* root) {\\n            help(root);\\n            swp(first->val, second->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32624,
                "title": "python-easy-to-understand-solutions",
                "content": "```\\n\\nclass Solution(object): \\n    def recoverTree(self, root): # O(lg(n)) space\\n        pre = first = second = None\\n        stack = []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            if not first and pre and pre.val > node.val:\\n                first = pre\\n            if first and pre and pre.val > node.val:\\n                second = node\\n            pre = node\\n            root = node.right\\n        first.val, second.val = second.val, first.val\\n      \\n    def recoverTree1(self, root): # O(n+lg(n)) space  \\n        res = []\\n        self.dfs(root, res)\\n        first, second = None, None\\n        for i in range(len(res)-1):\\n            if res[i].val > res[i+1].val and not first:\\n                first = res[i]\\n            if res[i].val > res[i+1].val and first:\\n                second = res[i+1]\\n        first.val, second.val = second.val, first.val\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            res.append(root)\\n            self.dfs(root.right, res)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n\\nclass Solution(object): \\n    def recoverTree(self, root): # O(lg(n)) space\\n        pre = first = second = None\\n        stack = []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            if not first and pre and pre.val > node.val:\\n                first = pre\\n            if first and pre and pre.val > node.val:\\n                second = node\\n            pre = node\\n            root = node.right\\n        first.val, second.val = second.val, first.val\\n      \\n    def recoverTree1(self, root): # O(n+lg(n)) space  \\n        res = []\\n        self.dfs(root, res)\\n        first, second = None, None\\n        for i in range(len(res)-1):\\n            if res[i].val > res[i+1].val and not first:\\n                first = res[i]\\n            if res[i].val > res[i+1].val and first:\\n                second = res[i+1]\\n        first.val, second.val = second.val, first.val\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            res.append(root)\\n            self.dfs(root.right, res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962833,
                "title": "beginner-level-illustration-11-line-solution",
                "content": "Pretty sure mine is the easiest one to understand. \\n\\nIf you do not want to spend much time on that, you could read the examples below the orange highlight line and get the idea.\\n\\nIf you do not think so, please comment.\\n\\nIf you have additional questions, please let me know\\n\\n**Please upvote me if you think this is helpful :) Much Appreciated!**\\n\\n![image](https://assets.leetcode.com/users/images/f6d861cd-c19a-4ee2-b377-50851abe09d8_1650345918.5829039.jpeg)\\n\\n****\\n\\nPython Solution\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\t\\n        # the idea is the in order BST is always increasing, if not, then there is something wrong\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            # track left side to start with min\\n            inorderBST(root.left)\\n\\n            # so that the first prev is the smallest node\\n            # and update each time\\n            if self.prev:\\n                \\n                # when order is wrong\\n\\t\\t\\t\\t# check the examples in the illustration\\n                if self.prev.val > root.val:\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = root\\n            \\n            # update the prev node\\n            self.prev = root\\n            \\n            # check right side\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        \\n        # swap the two wrong ones\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n        \\n        return\\n```\\n\\n****\\n\\nCompressed 11-line Python Solution\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            inorderBST(root.left)\\n\\n            if self.prev and self.prev.val > root.val:\\n                if not self.first:  self.first = self.prev\\n                self.second = root\\n            self.prev = root\\n\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\t\\n        # the idea is the in order BST is always increasing, if not, then there is something wrong\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            # track left side to start with min\\n            inorderBST(root.left)\\n\\n            # so that the first prev is the smallest node\\n            # and update each time\\n            if self.prev:\\n                \\n                # when order is wrong\\n\\t\\t\\t\\t# check the examples in the illustration\\n                if self.prev.val > root.val:\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = root\\n            \\n            # update the prev node\\n            self.prev = root\\n            \\n            # check right side\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        \\n        # swap the two wrong ones\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n        \\n        return\\n```\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n\\n        def inorderBST(root):\\n            if not root:    return\\n            \\n            inorderBST(root.left)\\n\\n            if self.prev and self.prev.val > root.val:\\n                if not self.first:  self.first = self.prev\\n                self.second = root\\n            self.prev = root\\n\\n            inorderBST(root.right)\\n        \\n        \\n        self.first = self.second = self.prev = None\\n        inorderBST(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274892,
                "title": "java-easy-inorder-traversal-soln-faster-than-100-explained",
                "content": "Here, we leverage the fact that **Inorder Traversal of a BST gives a sorted list of elements.**\\nIf there are exactly 2 swapped nodes, we can check the mistake in the inorder traversal.\\nFor eg.,\\n`root = [6,2,5,null,null,null,3]`\\nInorder traversal: `[2,6,5,3]` (Not sorted).\\n\\n- First incorrect node/element is **6** because 6 > 5 `(first == null && prev > curr)` => `prev` is the first node.\\n- Second incorrect node/element is **3**, because 5 > 3 `(first != null && prev > curr)`, `curr` is the second node.\\n- To cover the edge-case of 2 consecutive elements to be swapped, we always assign `second = curr`.\\n\\nHence, after swapping, the root becomes: `[2,3,5,6]`.\\n\\nBelow is the code:\\n\\n```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```\\n\\n\\n-------------------------------------------------------------------------------------------------------------------\\nIf you find this post helpful, please do upvote!\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671363,
                "title": "on-paper-explanantion-well-commented-easy-understand",
                "content": "![image](https://assets.leetcode.com/users/akshit0699/image_1591339571.png)\\n\\nCASE 1:\\n4, 15, 7, 10, 14, 5, 17\\nWe reach 7, prev.val(15) >root.val(7) VIOLATION! Hence, found first.\\nfirst = 15(prev) and second = 7(root)\\nWe go to 7,10,14... all obey the sorted order.\\nWe reach 5, prev.val(14) > root.val(5) VIOLATION! Hence, found second.\\nsecond = 5 (root)\\nEverything else in the array is fine.\\nSwap first and second. Done!\\n\\nCase 2:\\n4,5, 7, 10, 15, 14, 17\\nReaches upto 15 safely.\\nComes to 14, VIOLATION. Found first.\\nfirst = 15(prev) and second = 14(root)\\nEverything else works fine.\\nSwap first and second. Done!\\n\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: None Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.first, self.second, self.prevNode = None, None, None # Create three nodes.\\n        self.inOrder(root) # Calling the function\\n        self.first.val, self.second.val = self.second.val, self.first.val \\n        # Swapping the two elements needed to be swapped\\n        \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if self.prevNode: # To handle the case of first node, because we make it prev to begin with\\n            if self.prevNode.val > root.val: # Check property violation\\n                if not self.first: \\n                    self.first = self.prevNode # Found first pair\\n                self.second = root # If the second pair is found then simply assign the smaller element of the   pair as the second guy, it works for single pair easily, as it wont get             updated again in that case.\\n                \\n        self.prevNode = root\\n        \\n        self.inOrder(root.right)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: None Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.first, self.second, self.prevNode = None, None, None # Create three nodes.\\n        self.inOrder(root) # Calling the function\\n        self.first.val, self.second.val = self.second.val, self.first.val \\n        # Swapping the two elements needed to be swapped\\n        \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if self.prevNode: # To handle the case of first node, because we make it prev to begin with\\n            if self.prevNode.val > root.val: # Check property violation\\n                if not self.first: \\n                    self.first = self.prevNode # Found first pair\\n                self.second = root # If the second pair is found then simply assign the smaller element of the   pair as the second guy, it works for single pair easily, as it wont get             updated again in that case.\\n                \\n        self.prevNode = root\\n        \\n        self.inOrder(root.right)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962583,
                "title": "c-2-approach-brute-force-optimal",
                "content": "**1. Brute Force:**\\ntaking a vector, insert value into it according inorder traversal. Then sort, now again traverse the tree (in-order) & check the difference.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    void check(TreeNode* root){\\n        if(!root) return;\\n        check(root->left);\\n        if(v[i]!=root->val) swap(v[i],root->val);\\n        i++;\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```\\n`TC-> O(NlogN), SC-> O(N)+O(N) [1 for vector, 1 for recursion space]`\\n\\n**2. Optimal:**\\n```\\nclass Solution {\\n    TreeNode* first, *last, *prev;\\npublic:\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        if(prev!=NULL && (root->val<prev->val)){\\n            if(first==NULL){\\n                first=prev;\\n                last=root; \\n            }\\n            else\\n                last=root;\\n        }\\n        prev=root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first=last=prev=NULL;\\n        inorder(root);\\n        swap(first->val,last->val);\\n    }\\n};\\n```\\n`TC-> O(N), SC->O(N) [for recursion space]`\\n\\n**Upvote if you like it**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    void check(TreeNode* root){\\n        if(!root) return;\\n        check(root->left);\\n        if(v[i]!=root->val) swap(v[i],root->val);\\n        i++;\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    TreeNode* first, *last, *prev;\\npublic:\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        if(prev!=NULL && (root->val<prev->val)){\\n            if(first==NULL){\\n                first=prev;\\n                last=root; \\n            }\\n            else\\n                last=root;\\n        }\\n        prev=root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first=last=prev=NULL;\\n        inorder(root);\\n        swap(first->val,last->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552230,
                "title": "c-morris-traversal-o-1-space",
                "content": "According to question statement there will be only one swap necessary to make recover BST.\\n- From observation inorder traversal in BST gives sorted arrays\\n- Now if there is any nodes in in wrong order it makes array irregular\\n- there can be one or two wrong ordered pairs of elements in inorders traversal array.\\n\\t- If one pair wrong ordered element then keep track of two element in that pair and swap their values.\\n\\t- If two wrong pair exist then swap first element of first pair with second element of second pair\\n\\t\\n\\tExample: \\n\\tBST inorder: **2, 1,** 3 // one pair wrong ordered. here swaping 2 and 1 makes a BST valid\\n\\tBST inorder: 1, **7, 3**, 5, **6, 2,** 8, // two pair wrong ordered. swaping 7 and 2 make valid BST\\n  \\n  **Upvote if you find this helpful. Thanks :)**\\n  \\n```\\nclass Solution {\\n    TreeNode* first{nullptr}, *second{nullptr}, *prev{nullptr};\\npublic:\\n    void verifyNode(TreeNode* node){\\n\\t\\n\\t// check if previous pointer == null or node values are correct inorder traversal i.e prev is smaller than current node\\n        if(prev == nullptr || (prev->val<node->val)){ \\n            prev = node;\\n            return;\\n        }\\n        \\n        if(first == nullptr ){\\n            first = prev;\\n            second = node;\\n        }else{ \\n            second = node;\\n        }\\n    }\\n    void morrisInorder(TreeNode* root){\\n        if(!root)return;\\n        while(root){\\n            if(root->left == nullptr){\\n                verifyNode(root);\\n                root = root->right;\\n            }else{\\n                TreeNode* iter = root->left;\\n                // find predecessor\\n                while(iter->right && iter->right!=root){\\n                    iter = iter->right;\\n                }\\n                \\n                if(iter->right == nullptr)//create morris thread\\n                {\\n                    iter->right = root;\\n                    root = root->left;\\n                }else{\\n                    iter->right = nullptr;\\n                    verifyNode(root);\\n                    root = root->right;\\n                }\\n            }\\n        }\\n    }\\n    void recoverTree(TreeNode* root) {\\n        morrisInorder(root);\\n        swap(first->val, second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode* first{nullptr}, *second{nullptr}, *prev{nullptr};\\npublic:\\n    void verifyNode(TreeNode* node){\\n\\t\\n\\t// check if previous pointer == null or node values are correct inorder traversal i.e prev is smaller than current node\\n        if(prev == nullptr || (prev->val<node->val)){ \\n            prev = node;\\n            return;\\n        }\\n        \\n        if(first == nullptr ){\\n            first = prev;\\n            second = node;\\n        }else{ \\n            second = node;\\n        }\\n    }\\n    void morrisInorder(TreeNode* root){\\n        if(!root)return;\\n        while(root){\\n            if(root->left == nullptr){\\n                verifyNode(root);\\n                root = root->right;\\n            }else{\\n                TreeNode* iter = root->left;\\n                // find predecessor\\n                while(iter->right && iter->right!=root){\\n                    iter = iter->right;\\n                }\\n                \\n                if(iter->right == nullptr)//create morris thread\\n                {\\n                    iter->right = root;\\n                    root = root->left;\\n                }else{\\n                    iter->right = nullptr;\\n                    verifyNode(root);\\n                    root = root->right;\\n                }\\n            }\\n        }\\n    }\\n    void recoverTree(TreeNode* root) {\\n        morrisInorder(root);\\n        swap(first->val, second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278113,
                "title": "come-on-in-no-explanation-can-be-more-straightforward-than-graph-for-this-problem",
                "content": "\\nFor BST, if we do the in-order traversal, and add to the list, then the nodes in the list are sorted in acsending order. If we put them in a graph, then it will be like below where:\\n- **dark nodes** represent the tree nodes\\n- **red line** represents the **node values trend**\\n\\n![image](https://assets.leetcode.com/users/images/b6fce400-bbdc-4718-8a2a-3b356d58ff2f_1623906705.6791987.jpeg)\\n\\n\\nSo, if 2 nodes are swapped mistakenly, then the graph will be changed to below graph where:\\n- **yellow nodes** represent the node after swapped mistakendly\\n- **blue line** represents the **changed trend**\\n\\n![image](https://assets.leetcode.com/users/images/3e500bc5-960a-4ac9-a8ce-47714a8163c4_1623906718.23329.jpeg)\\n\\nAs we can see:\\n- The 1st mistaken node is the **peak node** around the its neighbors\\n- The 2nd mistaken node is the **negative peak node** around its neighbors\\n\\n**However!!!** it is easy to ignore that there are **2 peaks**, and **2 negative peaks**!!!\\n\\n![image](https://assets.leetcode.com/users/images/f2eff705-102c-48ac-8912-1c6fdddef120_1623907741.1990602.jpeg)\\n\\n\\n\\nThen we can correct above statement to: \\n- The **1st peak node** is the 1st mistaken node\\n- The **2nd node** or **the last node** is the 2nd mistaken node\\n\\nSo we can add condition to deal with above cases:\\n- If we find a peak node, then it is the 1st mistaken node, and we will not update 1st node in the following process\\n- If we find the any negative peak node, then we just update the 2nd mistaken node directly. Then the last negative peak node will overwrite the previous one which is what we want \\n\\n---\\n**Code**\\n```java\\nclass Solution {\\n    public void recoverTree(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        TreeNode node1 = null;\\n        TreeNode node2 = null;\\n        int n = nodes.size();\\n        for(int i = 0; i < nodes.size(); i++){\\n            if(i == 0){\\n                if(nodes.get(0).val > nodes.get(1).val) node1 = nodes.get(0);\\n            }else if(i == n - 1){\\n                if(nodes.get(i).val < nodes.get(i - 1).val) node2 = nodes.get(i);\\n            }else{\\n                if(node1 == null && nodes.get(i).val > nodes.get(i - 1).val && nodes.get(i).val > nodes.get(i + 1).val)\\n                    node1 = nodes.get(i);\\n                else if(nodes.get(i).val < nodes.get(i - 1).val && nodes.get(i).val < nodes.get(i + 1).val)\\n                    node2 = nodes.get(i);\\n            }\\n        }\\n        \\n        // swap val of node1 and node2, instead of node1 and node2 to keep the structure\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> nodes){\\n        if(root == null) return;\\n        \\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n}\\n```\\n\\n---\\n**Complexity Analysis**\\nTC: O(n)\\nSC: O(n)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public void recoverTree(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        TreeNode node1 = null;\\n        TreeNode node2 = null;\\n        int n = nodes.size();\\n        for(int i = 0; i < nodes.size(); i++){\\n            if(i == 0){\\n                if(nodes.get(0).val > nodes.get(1).val) node1 = nodes.get(0);\\n            }else if(i == n - 1){\\n                if(nodes.get(i).val < nodes.get(i - 1).val) node2 = nodes.get(i);\\n            }else{\\n                if(node1 == null && nodes.get(i).val > nodes.get(i - 1).val && nodes.get(i).val > nodes.get(i + 1).val)\\n                    node1 = nodes.get(i);\\n                else if(nodes.get(i).val < nodes.get(i - 1).val && nodes.get(i).val < nodes.get(i + 1).val)\\n                    node2 = nodes.get(i);\\n            }\\n        }\\n        \\n        // swap val of node1 and node2, instead of node1 and node2 to keep the structure\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> nodes){\\n        if(root == null) return;\\n        \\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32650,
                "title": "share-my-java-solution-using-morris-traversal",
                "content": "The Key idea is to use Morris Traversal which only uses O(1) Space. Here is my code and comments.\\nThe code just uses the variable root as the current node.\\n\\n    public class Solution {\\n      public void recoverTree(TreeNode root) {  \\n    \\n        TreeNode first = null;     // first node need to be swap\\n        TreeNode second = null;    // second node need to be swap\\n        TreeNode pre = new TreeNode(Integer.MIN_VALUE);  //previous node.\\n    \\n        while(root!=null){\\n          TreeNode node = root.left;\\n    \\n          // If left is not null, we need to find the rightmost node of left subtree,\\n          // Set its right child to current node\\n          if(node!=null){ \\n         \\n            //find the rightmost\\n            while(node.right!=null && node.right != root){\\n              node = node.right;\\n            }\\n    \\n            //There are two cases,\\n            //null: first time we access current, set node.right to current and move to left child of current and continue;\\n            //current: we accessed current before, thus we've finished traversing left subtree, set node.right back to null;\\n            if(node.right == null){\\n              node.right = root;\\n              root = root.left;\\n              continue;\\n            }else{\\n              node.right = null;\\n            }\\n          }\\n    \\n          // compare current node with previous node\\n          if(root.val < pre.val ){\\n            // first time we enconter reversed order, we set previous node to first\\n            if( first == null ){\\n              first = pre;\\n            }\\n            //In case that two nodes are successive, we set second to current every time.\\n            second = root;\\n          }\\n          pre = root;\\n          root = root.right;      \\n        }\\n    \\n        //swap the value;\\n        int temp = second.val;\\n        second.val = first.val;\\n        first.val = temp;\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public void recoverTree(TreeNode root) {  \\n    \\n        TreeNode first = null;     // first node need to be swap\\n        TreeNode second = null;    // second node need to be swap\\n        TreeNode pre = new TreeNode(Integer.MIN_VALUE);  //previous node.\\n    \\n        while(root!=null){\\n          TreeNode node = root.left;\\n    \\n          // If left is not null, we need to find the rightmost node of left subtree,\\n          // Set its right child to current node\\n          if(node!=null){ \\n         \\n            //find the rightmost\\n            while(node.right!=null && node.right != root){\\n              node = node.right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 256055,
                "title": "python-inorder-traversal",
                "content": "Since it\\'s a BST, so an inorder traversal returns a sorted array. And we can easily spot the midplaced nodes **first** and **second** as **first** is larger than the element next to it while **second** is smaller than the element ahead of it.\\n\\nSo we can run an inorder traversal. Between inorder(node.left) and inorder(node.right), we need to compare the current node with its neighbor.\\n\\nWe first identify the **first**, pointed by a helper pointer **prev**. And current **node** would be the node next to **prev** in sorted array. If prev.val >= node.val, we find the first node. Then we identify the **second**, which is now pointed by current **node** so that **prev** points to the node ahead of it. If node.val <= prev.val, we find the second node. So it\\'s like:\\n```\\nif not self.first and self.prev.val >= node.val:\\n\\tself.first = self.prev\\nif self.first and self.prev.val >= node.val:\\n\\tself.second = node\\n```\\nAnd we can combine the logic checks as:\\n```\\nif self.prev.val >= node.val:\\n\\tself.first = self.first or self.prev\\n\\tself.second = node\\n```\\nThere are at most two times of ```self.prev.val >= node.val```. That\\'s when **first** and **second** are not neighboring with each other. In such case, the **second** would be allocated to a false node in the first ```self.prev.val >= node.val``` occasion. But that doesn\\'t matter since it would be corrected in the second ```self.prev.val >= node.val```. Meanwhile, the **second** would be allocated to a correct node in the first and only time of ```self.prev.val >= node.val``` when **first** and **second** are neighbors.\\n\\nEventually, we swap the values between **first** and **second**.\\n```\\ndef recoverTree(root):\\n\\tself.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\')) \\n\\tdef inorder(node):\\n\\t\\tif node:\\n\\t\\t\\tinorder(node.left)\\n\\t\\t\\tif self.prev.val >= node.val: \\n\\t\\t\\t\\tself.first = self.first or self.prev\\n\\t\\t\\t\\tself.second = node\\n\\t\\t\\tself.prev = node\\n\\t\\t\\tinorder(node.right)\\n\\tinorder(root)\\n\\tself.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "solutionTags": [],
                "code": "```\\nif not self.first and self.prev.val >= node.val:\\n\\tself.first = self.prev\\nif self.first and self.prev.val >= node.val:\\n\\tself.second = node\\n```\n```\\nif self.prev.val >= node.val:\\n\\tself.first = self.first or self.prev\\n\\tself.second = node\\n```\n```self.prev.val >= node.val```\n```self.prev.val >= node.val```\n```self.prev.val >= node.val```\n```self.prev.val >= node.val```\n```\\ndef recoverTree(root):\\n\\tself.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\')) \\n\\tdef inorder(node):\\n\\t\\tif node:\\n\\t\\t\\tinorder(node.left)\\n\\t\\t\\tif self.prev.val >= node.val: \\n\\t\\t\\t\\tself.first = self.first or self.prev\\n\\t\\t\\t\\tself.second = node\\n\\t\\t\\tself.prev = node\\n\\t\\t\\tinorder(node.right)\\n\\tinorder(root)\\n\\tself.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1962276,
                "title": "clear-n-easy-to-understand-code",
                "content": "***INORDER TRAVERSAL APPROACH***\\n```\\nclass Solution {\\n     // Creating three global pointers\\n    TreeNode previous = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        // Finding the two swapped nodes\\n        solve(root);\\n        \\n        //Swaping the value of nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n     //New Function to find the two nodes\\n    public void solve(TreeNode root){\\n        \\n        if(root == null){\\n            return;\\n        }\\n        \\n        //Doing inorder traversal i.e, sarting from left then right\\n        solve(root.left);\\n        \\n        // If current node is smaller than previous, then previous node is invalid\\n        if(previous != null && root.val < previous.val){\\n            \\n            //Storing previous node\\n            if(first == null){\\n                first = previous;\\n            }\\n            \\n            //If both nodes are adjacent, save the current node in that case\\n            second = root;\\n            \\n        }\\n        \\n        //Making current node as previous node\\n        previous = root;\\n        \\n        //Moving to right sub-tree\\n        solve(root.right);\\n        \\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity =O(N)***\\n***Space Complexity = O(N)***\\n\\n<hr>\\n<hr>",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     // Creating three global pointers\\n    TreeNode previous = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        // Finding the two swapped nodes\\n        solve(root);\\n        \\n        //Swaping the value of nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n     //New Function to find the two nodes\\n    public void solve(TreeNode root){\\n        \\n        if(root == null){\\n            return;\\n        }\\n        \\n        //Doing inorder traversal i.e, sarting from left then right\\n        solve(root.left);\\n        \\n        // If current node is smaller than previous, then previous node is invalid\\n        if(previous != null && root.val < previous.val){\\n            \\n            //Storing previous node\\n            if(first == null){\\n                first = previous;\\n            }\\n            \\n            //If both nodes are adjacent, save the current node in that case\\n            second = root;\\n            \\n        }\\n        \\n        //Making current node as previous node\\n        previous = root;\\n        \\n        //Moving to right sub-tree\\n        solve(root.right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32532,
                "title": "my-javascript-solution",
                "content": "The idea is simple, find the two nodes that are swapped by mistake and then swap back their values. The question is how to find out those two nodes?\\n\\nAs we know, an inorder traversal of BST gives us a sorted array, if two elements in the array are swapped, we can find them out in one scan, that is whenever we see the previous value is larger than the current value, we can mark them.\\n\\nFor example, let's say we have a sorted array [0, 1] and we swap the values, so that array becomes [1, 0], when we scan through, we found that 1 > 0, we know that 1 and 0 are the nodes that are swapped by mistake.\\n\\nTake another example, in this array [0, 1, 2, 5, 4, 3], 3 and 5 are swapped by mistake, when we scan the array, we noticed that 5 > 4 and 4 > 3. How to get 3 and 5? Whenever we find a mistake, if it's the first one, mark both nodes as \"first\" and \"second\", for the second mistake, we just have to update the \"second\", see the codes below.\\n\\nBut we are not there yet, the question asks us to use constant space, so we can't store the values of the BST in an array, that will be O(n) space complexity. The solution is to use DFS and traverse the tree in inorder manner.\\n\\nSo time complexity is O(n), space complexity is O(1) (if we don't care about recursion stack, otherwise it's the height of the tree).\\n\\nBelow is the JavaScript code:\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar recoverTree = function(root) {\\n    // first and second are the two nodes that are swapped by mistake\\n    var prev, first, second;\\n    \\n    function inorder(root) {\\n        if (!root) return;\\n        \\n        inorder(root.left);\\n        \\n        if (prev && prev.val > root.val) {\\n            // Found a mistake\\n            if (!first) first = prev; // Only set the \"first\" once\\n            second = root; // Always update the \"second\"\\n        }\\n        prev = root;\\n        \\n        inorder(root.right);\\n    }\\n    \\n    inorder(root);\\n    \\n    // Swap the values of the two nodes\\n    var temp = first.val;\\n    first.val = second.val;\\n    second.val = temp;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar recoverTree = function(root) {\\n    // first and second are the two nodes that are swapped by mistake\\n    var prev, first, second;\\n    \\n    function inorder(root) {\\n        if (!root) return;\\n        \\n        inorder(root.left);\\n        \\n        if (prev && prev.val > root.val) {\\n            // Found a mistake\\n            if (!first) first = prev; // Only set the \"first\" once\\n            second = root; // Always update the \"second\"\\n        }\\n        prev = root;\\n        \\n        inorder(root.right);\\n    }\\n    \\n    inorder(root);\\n    \\n    // Swap the values of the two nodes\\n    var temp = first.val;\\n    first.val = second.val;\\n    second.val = temp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32613,
                "title": "real-o-1-space-no-recursion-no-stack-etc-o-n-time-solution-48ms-c",
                "content": "Someone complained that a recursion solution isn't really a O(1) space solution. Ok, here comes the real O(1) solution. No recursion, no stack. Pure Morris traversal. 48 ms, C++ :\\n\\n    class Solution {\\n            TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr;\\n            void verify(TreeNode * cur)\\n            {\\n                if (prev != nullptr && prev -> val > cur -> val)\\n                {\\n                    if (wrong_node0 == nullptr)\\n                    {\\n                        wrong_node0 = prev;\\n                        wrong_node1 = cur; // in case the tree has only 2 elements.\\n                    }\\n                    else\\n                        wrong_node1 = cur;\\n                }\\n                prev = cur;\\n            }\\n            void morrisInorder(TreeNode * root)\\n            {\\n                TreeNode * cur = root;\\n                while (cur)\\n                {\\n                    if (cur->left == nullptr)\\n                    {\\n                        verify(cur);       \\n                        cur = cur->right;\\n                        continue;\\n                    }\\n                    TreeNode * pred = cur->left;\\n                    while (pred -> right != nullptr && pred -> right != cur)\\n                        pred = pred -> right; //finding predecessor\\n                    if (pred -> right == nullptr)\\n                    {\\n                        pred -> right = cur;\\n                        cur = cur -> left;\\n                    }else {//pred -> right == cur;\\n                        pred -> right = nullptr;\\n                        verify(cur);\\n                        cur = cur -> right;\\n                    }\\n                }\\n            }\\n        public:\\n            void recoverTree(TreeNode* root) {\\n                morrisInorder(root);\\n                swap(wrong_node0->val, wrong_node1->val);\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n            TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr;\\n            void verify(TreeNode * cur)\\n            {\\n                if (prev != nullptr && prev -> val > cur -> val)\\n                {\\n                    if (wrong_node0 == nullptr)\\n                    {\\n                        wrong_node0 = prev;\\n                        wrong_node1 = cur; // in case the tree has only 2 elements.\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1671711,
                "title": "constant-space-easy-in-order-traversal-with-explaination",
                "content": "The space taken by the recursion call is not considered as a space complexity here.\\nThe extra space is usually used to store the inorder traversal list. which is not used in this solution.\\n\\nInOrder traversal for BST means the tree is traversed in sorted order, so if any node breaks the sorted order that wll be our node to swap.\\nthat is the first and last node which breaks the sorting is our culprit !!\\n\\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n       \\n        res = []     \\n        startnode = None\\n        prev = None\\n        lastnode = None\\n        \\n        def dfs(root):\\n            nonlocal res, startnode, prev, lastnode\\n            if not root:\\n                return \\n            # go to left  (inorder step 1)  \\n            dfs(root.left)\\n\\t\\t\\t\\n            # do processing....(inorder step 2)\\n\\t\\t\\t# get the first node where the sorted order is broken the first time and the last time\\n            if prev and prev.val > root.val:\\n                if not startnode:\\n                    startnode = prev\\n                lastnode = root\\n                \\n            prev = root\\n\\t\\t\\t\\n            # go to right (inorder step 3)    \\n            dfs(root.right)\\n            \\n        \\n        dfs(root)\\n        # swap the nodes that are not in place\\n        if startnode and lastnode:\\n            startnode.val, lastnode.val = lastnode.val, startnode.val\\n```\\n\\n***Please upvote for motivation***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n       \\n        res = []     \\n        startnode = None\\n        prev = None\\n        lastnode = None\\n        \\n        def dfs(root):\\n            nonlocal res, startnode, prev, lastnode\\n            if not root:\\n                return \\n            # go to left  (inorder step 1)  \\n            dfs(root.left)\\n\\t\\t\\t\\n            # do processing....(inorder step 2)\\n\\t\\t\\t# get the first node where the sorted order is broken the first time and the last time\\n            if prev and prev.val > root.val:\\n                if not startnode:\\n                    startnode = prev\\n                lastnode = root\\n                \\n            prev = root\\n\\t\\t\\t\\n            # go to right (inorder step 3)    \\n            dfs(root.right)\\n            \\n        \\n        dfs(root)\\n        # swap the nodes that are not in place\\n        if startnode and lastnode:\\n            startnode.val, lastnode.val = lastnode.val, startnode.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1450119,
                "title": "intuitive-solution-explained-images",
                "content": "### Main idea - __*Inorder Traversal*__\\n\\n![image](https://assets.leetcode.com/users/images/dfb0dab7-b329-4fe6-9827-155227a556f1_1631084787.5005395.png)\\n![image](https://assets.leetcode.com/users/images/16060ed1-2d8c-479c-8d7f-1bc669f72f60_1631084843.3991785.png)\\n![image](https://assets.leetcode.com/users/images/023279fe-b5f2-4e4d-a203-e67a64e59826_1631016630.4750319.png)\\n![image](https://assets.leetcode.com/users/images/ff7e48bf-0485-4bc3-8d57-eb88a335a137_1631016655.0976954.png)\\n![image](https://assets.leetcode.com/users/images/51ab9566-fe0e-47d7-b418-db0fddef2476_1631016670.453483.png)\\n![image](https://assets.leetcode.com/users/images/6c3a4fcc-6088-413b-a357-6fce3dea0c06_1631016696.4263809.png)\\n\\ncode - \\n\\n```java\\n\\nclass Solution{\\npublic static ArrayList<TreeNode> arr;\\n\\n    public static void dfs(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root.left);\\n        arr.add(root);\\n        dfs(root.right);\\n    }\\n\\n    public static void solve(TreeNode root) {\\n        arr = new ArrayList<TreeNode>();\\n        dfs(root);\\n        TreeNode a = null;\\n        TreeNode b = null;\\n        int n = arr.size();\\n        for (int i = 0; i < n; i++) {\\n            int left = i - 1 >= 0 ? arr.get(i - 1).val : Integer.MIN_VALUE;\\n            int right = i + 1 < n ? arr.get(i + 1).val : Integer.MAX_VALUE;\\n            int curr = arr.get(i).val;\\n            if (curr > left && curr > right && left < right) {\\n                a = arr.get(i);\\n            } else if (curr < left && curr < right && left < right) {\\n                b = arr.get(i);\\n            }\\n        }\\n        if (a != null && b != null) {\\n            int temp = a.val;\\n            a.val = b.val;\\n            b.val = temp;\\n        }\\n    }\\n}\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```java\\n\\nclass Solution{\\npublic static ArrayList<TreeNode> arr;\\n\\n    public static void dfs(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root.left);\\n        arr.add(root);\\n        dfs(root.right);\\n    }\\n\\n    public static void solve(TreeNode root) {\\n        arr = new ArrayList<TreeNode>();\\n        dfs(root);\\n        TreeNode a = null;\\n        TreeNode b = null;\\n        int n = arr.size();\\n        for (int i = 0; i < n; i++) {\\n            int left = i - 1 >= 0 ? arr.get(i - 1).val : Integer.MIN_VALUE;\\n            int right = i + 1 < n ? arr.get(i + 1).val : Integer.MAX_VALUE;\\n            int curr = arr.get(i).val;\\n            if (curr > left && curr > right && left < right) {\\n                a = arr.get(i);\\n            } else if (curr < left && curr < right && left < right) {\\n                b = arr.get(i);\\n            }\\n        }\\n        if (a != null && b != null) {\\n            int temp = a.val;\\n            a.val = b.val;\\n            b.val = temp;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926227,
                "title": "100-fastest-swift-solution-time-o-n-space-o-h",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962740,
                "title": "python-simple-o-n-log-n-beats-94",
                "content": "This solution compares the in-order traversal of the tree, which in a correct binary tree should return the elements sorted in ascending order. We then compare this against the sorted elements and swap as soon as we find a mismatch.\\n\\n```python\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1356869,
                "title": "python-very-easy-to-understand-idea-inorder",
                "content": "\\n```\\nclass Solution:\\n    \\n    \"\"\"\\n        Brute force kind of thing\\n        -> Inorder Traversal returns sorted array\\n        -> find a swap btwn numbers to make sorted\\n        Make single swap to make array sorted\\n        [1, 2, 3, 4, 10, 6, 9, 5, 10, 12]\\n         x, x, x, x, x, No\\n            prev number is mismatch -> 10 is cause\\n        now go frm right to left\\n        [1, 2, 3, 4, 10, 6, 9, 5, 11, 12]\\n                            No x   x   x\\n                        mismatch with next number -> 5 is the cause\\n        swap 10, 5\\n        \\n        Eg: 2\\n        [3, 2, 1]\\n         x  No -> 3 is the cause\\n        [3, 2, 1]\\n         x  No -> 1 is the cause\\n        swap values -> 1, 3\\n    \"\"\"\\n    \\n    def inorder(self, root, li):\\n        if root is None:\\n            return li\\n        li = self.inorder(root.left, li)\\n        li.append(root)\\n        li = self.inorder(root.right, li)\\n        return li\\n    \\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        li = self.inorder(root, [])\\n        n = len(li)\\n        i, j = 1, n-2\\n        a = li[0]\\n        for i in range(1, n):\\n            if li[i].val < li[i-1].val:\\n                a = li[i-1]\\n                break\\n        b = li[-1]\\n        for i in range(n-2, -1, -1):\\n            if li[i].val > li[i+1].val:\\n                b = li[i+1]\\n                break\\n\\n        a.val,b.val = b.val, a.val\\n\\n```\\n\\nNote: We can do LDR, and RDL for 2 loops to get that root1, root2 values [Constant space Operation]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \"\"\"\\n        Brute force kind of thing\\n        -> Inorder Traversal returns sorted array\\n        -> find a swap btwn numbers to make sorted\\n        Make single swap to make array sorted\\n        [1, 2, 3, 4, 10, 6, 9, 5, 10, 12]\\n         x, x, x, x, x, No\\n            prev number is mismatch -> 10 is cause\\n        now go frm right to left\\n        [1, 2, 3, 4, 10, 6, 9, 5, 11, 12]\\n                            No x   x   x\\n                        mismatch with next number -> 5 is the cause\\n        swap 10, 5\\n        \\n        Eg: 2\\n        [3, 2, 1]\\n         x  No -> 3 is the cause\\n        [3, 2, 1]\\n         x  No -> 1 is the cause\\n        swap values -> 1, 3\\n    \"\"\"\\n    \\n    def inorder(self, root, li):\\n        if root is None:\\n            return li\\n        li = self.inorder(root.left, li)\\n        li.append(root)\\n        li = self.inorder(root.right, li)\\n        return li\\n    \\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        li = self.inorder(root, [])\\n        n = len(li)\\n        i, j = 1, n-2\\n        a = li[0]\\n        for i in range(1, n):\\n            if li[i].val < li[i-1].val:\\n                a = li[i-1]\\n                break\\n        b = li[-1]\\n        for i in range(n-2, -1, -1):\\n            if li[i].val > li[i+1].val:\\n                b = li[i+1]\\n                break\\n\\n        a.val,b.val = b.val, a.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448583,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. In-order dfs traverse the tree in ascending order (very Important)\\n2. Save a record of the previous node, if the current node is smaller than the previous node, that means we\\'ve found 2 potential elements that will be swapped.\\n3. Out of the 2 potential elements, we are sure that the bigger one must be swapped, however, the smaller one aren\\'t sure, so we need to continue the dfs.\\n*The idea of the swapping mechanism is exactly the same in \"sorting an almost sorted array\"\\n``` javascript\\nvar recoverTree = function(root) {\\n    let prev = null, big = null, small = null;\\n    let dfs = function(root) {\\n        if (!root) return;\\n        dfs(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            small = root; // potential smaller number that needs to be swapped\\n            if (!big) big = prev; // assured bigger number that needs to be swapped\\n            else return;\\n        }\\n        prev = root;\\n        dfs(root.right);\\n    }\\n    \\n    dfs(root);\\n    [big.val, small.val] = [small.val, big.val];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar recoverTree = function(root) {\\n    let prev = null, big = null, small = null;\\n    let dfs = function(root) {\\n        if (!root) return;\\n        dfs(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            small = root; // potential smaller number that needs to be swapped\\n            if (!big) big = prev; // assured bigger number that needs to be swapped\\n            else return;\\n        }\\n        prev = root;\\n        dfs(root.right);\\n    }\\n    \\n    dfs(root);\\n    [big.val, small.val] = [small.val, big.val];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32646,
                "title": "python-inorder-traversal-solution-based-on-validate-binary-search-tree",
                "content": "    class Solution:\\n    # @param root, a tree node\\n    # @return a tree node\\n    def recoverTree(self, root):\\n        it = self.isValidBST(root)\\n        a, b = next(it)\\n        c = next(it, None)\\n        if c:\\n            _, c = c\\n            a.val, c.val = c.val, a.val\\n        else:\\n            a.val, b.val = b.val, a.val\\n        return root\\n\\n    def isValidBST(self, root):\\n        pre, cur, stack = None, root, []\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            s = stack.pop()\\n            if pre and s.val <= pre.val:\\n                yield pre, s\\n            pre, cur = s, s.right\\n\\nThis is a simple O(n) space solution.\\n\\nAdd Java solution\\n\\n    TreeNode prev = null;\\n    LinkedList<TreeNode> result = new LinkedList<TreeNode>();\\n\\n    public void recoverTree(TreeNode root) {\\n        isValidBST(root);\\n        TreeNode first = result.poll();\\n        TreeNode last = result.pollLast();\\n        int temp = first.val;\\n        first.val = last.val;\\n        last.val = temp;\\n    }\\n\\n    private void isValidBST(TreeNode root) {\\n        if (root == null)\\n            return;\\n        isValidBST(root.left);\\n        if (prev != null && root.val < prev.val) {\\n            result.add(prev);\\n            result.add(root);\\n        }\\n        prev = root;\\n        isValidBST(root.right);\\n    }",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param root, a tree node\\n    # @return a tree node\\n    def recoverTree(self, root):\\n        it = self.isValidBST(root)\\n        a, b = next(it)\\n        c = next(it, None)\\n        if c:\\n            _, c = c\\n            a.val, c.val = c.val, a.val\\n        else:\\n            a.val, b.val = b.val, a.val\\n        return root\\n\\n    def isValidBST(self, root):\\n        pre, cur, stack = None, root, []\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            s = stack.pop()\\n            if pre and s.val <= pre.val:\\n                yield pre, s\\n            pre, cur = s, s.right\\n\\nThis is a simple O(n) space solution.\\n\\nAdd Java solution\\n\\n    TreeNode prev = null;\\n    LinkedList<TreeNode> result = new LinkedList<TreeNode>();\\n\\n    public void recoverTree(TreeNode root) {\\n        isValidBST(root);\\n        TreeNode first = result.poll();\\n        TreeNode last = result.pollLast();\\n        int temp = first.val;\\n        first.val = last.val;\\n        last.val = temp;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1962728,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    private TreeNode first = null;\\n    private TreeNode second = null;\\n    private TreeNode pre = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if(root==null) return;\\n\\n        //find swapped nodes\\n        inorder(root);\\n        \\n        //swap the nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        \\n        //find the first node which is at wrong position\\n        if(first==null && (pre==null ||pre.val>=root.val)){\\n            first = pre;\\n        }\\n        \\n        //find the second node which is at wrong position\\n        if(first!=null && pre.val>=root.val){\\n            second = root;\\n        }\\n        \\n        //store previus node to compare\\n        pre = root;\\n        inorder(root.right);\\n    }\\n}\\n```\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode first = null;\\n    private TreeNode second = null;\\n    private TreeNode pre = null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if(root==null) return;\\n\\n        //find swapped nodes\\n        inorder(root);\\n        \\n        //swap the nodes\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        \\n        //find the first node which is at wrong position\\n        if(first==null && (pre==null ||pre.val>=root.val)){\\n            first = pre;\\n        }\\n        \\n        //find the second node which is at wrong position\\n        if(first!=null && pre.val>=root.val){\\n            second = root;\\n        }\\n        \\n        //store previus node to compare\\n        pre = root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32607,
                "title": "beat-99-fast-java-solution-o-h-space-with-explanation",
                "content": "The basic idea is to use stack to do in-order traversal. In the processing of traversal, keep comparing the current value with the previous value. Since each previous value should be less than the current value, once an exception is found, record the previous node as the First Mistaken Node and the current node as Second. If one more exceptions are found, override the current node to the Second Mistaken Node. Because if a series of mistaken nodes are found, the only possible way to correct them with one swap is to switch the head and tail node. \\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tTreeNode pre = null, first = null, second = null;\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\t\\twhile (root != null) {\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\troot = root.left;\\n\\t\\t}\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode temp = stack.pop();\\n\\t\\t\\tif (pre != null)\\n\\t\\t\\t\\tif (pre.val > temp.val) {\\n\\t\\t\\t\\t\\tif (first == null)\\n\\t\\t\\t\\t\\t\\tfirst = pre;\\n\\t\\t\\t\\t\\tsecond = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tpre = temp;\\n\\t\\t\\tif (temp.right != null) {\\n\\t\\t\\t\\ttemp = temp.right;\\n\\t\\t\\t\\twhile (temp != null) {\\n\\t\\t\\t\\t\\tstack.push(temp);\\n\\t\\t\\t\\t\\ttemp = temp.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint temp = first.val;\\n\\t\\tfirst.val = second.val;\\n\\t\\tsecond.val = temp;\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to use stack to do in-order traversal. In the processing of traversal, keep comparing the current value with the previous value. Since each previous value should be less than the current value, once an exception is found, record the previous node as the First Mistaken Node and the current node as Second. If one more exceptions are found, override the current node to the Second Mistaken Node. Because if a series of mistaken nodes are found, the only possible way to correct them with one swap is to switch the head and tail node. \\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tTreeNode pre = null, first = null, second = null;\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\t\\twhile (root != null) {\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\troot = root.left;\\n\\t\\t}\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode temp = stack.pop();\\n\\t\\t\\tif (pre != null)\\n\\t\\t\\t\\tif (pre.val > temp.val) {\\n\\t\\t\\t\\t\\tif (first == null)\\n\\t\\t\\t\\t\\t\\tfirst = pre;\\n\\t\\t\\t\\t\\tsecond = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tpre = temp;\\n\\t\\t\\tif (temp.right != null) {\\n\\t\\t\\t\\ttemp = temp.right;\\n\\t\\t\\t\\twhile (temp != null) {\\n\\t\\t\\t\\t\\tstack.push(temp);\\n\\t\\t\\t\\t\\ttemp = temp.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint temp = first.val;\\n\\t\\tfirst.val = second.val;\\n\\t\\tsecond.val = temp;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1138233,
                "title": "self-explanatory-easy-solution-for-hard-question",
                "content": "- Prerequisites [**Validate Binary Search Tree**](https://leetcode.com/problems/validate-binary-search-tree) \\n- My [Solution for Validate BST](https://leetcode.com/problems/validate-binary-search-tree/discuss/1138232/Self-Explanatory-Easy-DFS-Solution)\\n- By Saurav Kumar Gupta\\n- Please **upvote** if it helps you.\\n\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr;\\n        TreeNode *first = nullptr;\\n        TreeNode *second = nullptr;\\n        \\n        stack<TreeNode *> S;\\n        \\n        while(root || !S.empty()) {\\n            while(root) {\\n                S.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = S.top(); S.pop();\\n            \\n            if(prev && prev->val > root->val) {\\n                if(!first) first = prev;\\n                second = root;\\n            }\\n            \\n            prev = root;\\n            root = root->right;\\n        }\\n        \\n        swap(first->val , second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr;\\n        TreeNode *first = nullptr;\\n        TreeNode *second = nullptr;\\n        \\n        stack<TreeNode *> S;\\n        \\n        while(root || !S.empty()) {\\n            while(root) {\\n                S.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = S.top(); S.pop();\\n            \\n            if(prev && prev->val > root->val) {\\n                if(!first) first = prev;\\n                second = root;\\n            }\\n            \\n            prev = root;\\n            root = root->right;\\n        }\\n        \\n        swap(first->val , second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32546,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Recover Binary Search Tree** https://leetcode.com/problems/recover-binary-search-tree/?tab=Description\\n\\n**Algorithm**\\n1. Use a tree example: [100, 50, 200, 25, 75, 99, 400]\\n2. Sorted Order: 25,50,75,100,150,200,400\\n3. You can have out of order 50 and 200: 25,**200**,75,100,150,**50**,400. Notice in this case we have 2 out of order pairs: (200,75) and (150,50). Simply swap 200 and 50.\\n4. What if 25/50 or 200/400 are swapped? In that case we will have just one out of order element.\\n5. 3 and 4 give us our algorithm.\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.order = []\\n        self.prev = None\\n        self.inorder(root)\\n        if len(self.order) == 2:\\n            self.swap(self.order[0][0], self.order[1][1])\\n        elif len(self.order) == 1:\\n            self.swap(self.order[0][0], self.order[0][1])\\n        return\\n    \\n    def inorder(self, root):\\n        if root == None:\\n            return\\n        self.inorder(root.left)\\n        if self.prev and self.prev.val > root.val:\\n            self.order.append((self.prev, root))\\n        self.prev = root\\n        self.inorder(root.right)\\n        return\\n    \\n    def swap(self, r1, r2):\\n        r1.val, r2.val = r2.val, r1.val\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.order = []\\n        self.prev = None\\n        self.inorder(root)\\n        if len(self.order) == 2:\\n            self.swap(self.order[0][0], self.order[1][1])\\n        elif len(self.order) == 1:\\n            self.swap(self.order[0][0], self.order[0][1])\\n        return\\n    \\n    def inorder(self, root):\\n        if root == None:\\n            return\\n        self.inorder(root.left)\\n        if self.prev and self.prev.val > root.val:\\n            self.order.append((self.prev, root))\\n        self.prev = root\\n        self.inorder(root.right)\\n        return\\n    \\n    def swap(self, r1, r2):\\n        r1.val, r2.val = r2.val, r1.val\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32592,
                "title": "an-elegent-o-n-time-complexity-and-o-1-space-complexity-algorithm",
                "content": "Note: 1. Given a sequence `{1, 4, 3, 7, 9}`, you find pair `4(!<=)3`, swap this pair and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa02. Given a sequence `{1, 9, 4, 5, 3, 10}`, you get first pair `9(!<=)4` and second pair `5(!<=)3`, swap pair `9(!<=)3` and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa03. Given a sequence, only in two above (general) cases, that you can just swap one pair numbers to convert an unordered sequence into ordered. <br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa04. You can tranverse BST inorder to get above sequence.<br/>So, my alg is:<br/>\\n\\n    void recover(TreeNode *root, TreeNode *&pre, TreeNode *&a, TreeNode *&b) {\\n        if (root)\\n        {\\n            recover(root->left, pre, a, b);\\n            \\n            if (root->val < pre->val)\\n            {\\n                if (!a) a = pre; //a should change once.\\n                b = root; //b could change twice.\\n            }\\n            pre = root;\\n            \\n            recover(root->right, pre, a, b);\\n        }\\n    }\\n    void recoverTree(TreeNode *root) {\\n        if (!root) return;\\n        \\n        TreeNode p(numeric_limits<int>::min());\\n        TreeNode *a, *b, *pre;\\n        a = b = 0;\\n        pre = &p;\\n        recover(root, pre, a, b);\\n        if (a && b)\\n        {\\n            swap(a->val, b->val);\\n        }\\n        return;\\n    }\\n\\nI think this problem requirement is strange. Does O(1) space complexity algorithm exists?\\n<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Does BST should be tranversed?<br/>&nbsp;&nbsp;&nbsp;&nbsp; 2. If answer of `1` is true, I don't think an O(1) space complexity exists, for there does not exists a BST tranverse algorithm taking O(1) space complexity.<br/>&nbsp;&nbsp;&nbsp;&nbsp;3. If answer of `1` is false, I just wonder how can you find the disordered pair.",
                "solutionTags": [],
                "code": "Note: 1. Given a sequence `{1, 4, 3, 7, 9}`, you find pair `4(!<=)3`, swap this pair and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa02. Given a sequence `{1, 9, 4, 5, 3, 10}`, you get first pair `9(!<=)4` and second pair `5(!<=)3`, swap pair `9(!<=)3` and sequence is in order.<br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa03. Given a sequence, only in two above (general) cases, that you can just swap one pair numbers to convert an unordered sequence into ordered. <br/>\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa0\\xa04. You can tranverse BST inorder to get above sequence.<br/>So, my alg is:<br/>\\n\\n    void recover(TreeNode *root, TreeNode *&pre, TreeNode *&a, TreeNode *&b) {\\n        if (root)\\n        {\\n            recover(root->left, pre, a, b);\\n            \\n            if (root->val < pre->val)\\n            {\\n                if (!a) a = pre; //a should change once.\\n                b = root; //b could change twice.\\n            }\\n            pre = root;\\n            \\n            recover(root->right, pre, a, b);\\n        }\\n    }\\n    void recoverTree(TreeNode *root) {\\n        if (!root) return;\\n        \\n        TreeNode p(numeric_limits<int>::min());\\n        TreeNode *a, *b, *pre;\\n        a = b = 0;\\n        pre = &p;\\n        recover(root, pre, a, b);\\n        if (a && b)\\n        {\\n            swap(a->val, b->val);\\n        }\\n        return;\\n    }\\n\\nI think this problem requirement is strange. Does O(1) space complexity algorithm exists?\\n<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Does BST should be tranversed?<br/>&nbsp;&nbsp;&nbsp;&nbsp; 2. If answer of `1` is true, I don't think an O(1) space complexity exists, for there does not exists a BST tranverse algorithm taking O(1) space complexity.<br/>&nbsp;&nbsp;&nbsp;&nbsp;3. If answer of `1` is false, I just wonder how can you find the disordered pair.",
                "codeTag": "Unknown"
            },
            {
                "id": 1962388,
                "title": "c-cheating-with-sort-vector-and-inorder-traversal",
                "content": "Couldn\\'t figure it out the big brain way, so here is the cheater\\'s solution.\\n\\n**SOLVED LIVE ON STREAM.  Everyday 6pm PT. Link in profile**\\n\\n```\\nclass Solution {\\n\\n    void dfs(TreeNode* root, vector<int>& cheat) {\\n        if(!root) return;\\n        \\n        dfs(root->left, cheat);\\n        cheat.push_back(root->val);\\n        dfs(root->right, cheat);\\n    }\\n    \\n    void cheatAgain(TreeNode* root, vector<int>& cheat, int& i) {\\n        if(!root) return;\\n        cheatAgain(root->left, cheat, i);\\n        if(root->val != cheat[i]) {\\n            root->val = cheat[i];\\n        }\\n        i++;\\n        cheatAgain(root->right, cheat, i);\\n        \\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> cheat;\\n        dfs(root, cheat);\\n        sort(cheat.begin(), cheat.end());\\n        int i = 0;\\n        cheatAgain(root, cheat, i);\\n        return;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    void dfs(TreeNode* root, vector<int>& cheat) {\\n        if(!root) return;\\n        \\n        dfs(root->left, cheat);\\n        cheat.push_back(root->val);\\n        dfs(root->right, cheat);\\n    }\\n    \\n    void cheatAgain(TreeNode* root, vector<int>& cheat, int& i) {\\n        if(!root) return;\\n        cheatAgain(root->left, cheat, i);\\n        if(root->val != cheat[i]) {\\n            root->val = cheat[i];\\n        }\\n        i++;\\n        cheatAgain(root->right, cheat, i);\\n        \\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> cheat;\\n        dfs(root, cheat);\\n        sort(cheat.begin(), cheat.end());\\n        int i = 0;\\n        cheatAgain(root, cheat, i);\\n        return;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917951,
                "title": "python-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=XHx4OQ5BLoE)\\nhttps://www.youtube.com/watch?v=XHx4OQ5BLoE\\n```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        curr = root\\n        prev = TreeNode(float(\\'-inf\\'))\\n        replace = []\\n        stack = []\\n        \\n        while curr or stack:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            \\n            temp = stack.pop()\\n            \\n            if temp.val < prev.val:\\n                replace.append((prev, temp))\\n            \\n            prev = temp\\n            curr = temp.right\\n        \\n        replace[0][0].val, replace[-1][1].val = replace[-1][1].val, replace[0][0].val \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        curr = root\\n        prev = TreeNode(float(\\'-inf\\'))\\n        replace = []\\n        stack = []\\n        \\n        while curr or stack:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            \\n            temp = stack.pop()\\n            \\n            if temp.val < prev.val:\\n                replace.append((prev, temp))\\n            \\n            prev = temp\\n            curr = temp.right\\n        \\n        replace[0][0].val, replace[-1][1].val = replace[-1][1].val, replace[0][0].val \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772201,
                "title": "c-solutions-easy-to-solve",
                "content": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339518,
                "title": "easy-to-understand-inorder-traversal",
                "content": "we first need to find the two nodes that are not valid under the condition for bst i.e the inorder of bst is always sorted, once we find the two nodes, we will normally swap it. \\nDone!!!\\n\\n\\n```\\nclass Solution {\\n    TreeNode prev = null;TreeNode first = null; TreeNode second = null;\\n    \\n    public void inorderHelper(TreeNode root)\\n    {\\n        if(root == null)  return;\\n        \\n        inorderHelper(root.left);\\n        \\n        if(first == null && prev != null && prev.val >= root.val)\\n            first = prev;\\n        \\n        if(first != null && prev.val >= root.val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderHelper(root.right);\\n    }\\n    \\n    public void swap(TreeNode first, TreeNode second)\\n    {\\n        int temp = first.val;\\n        \\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void recoverTree(TreeNode root)\\n    {\\n        prev = null; first = null; second = null;\\n        \\n        inorderHelper(root);\\n        \\n        swap(first,second);\\n    \\n    }\\n}\\n```\\n\\nthe cpp solution for the same\\n```\\nclass Solution {\\npublic:\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev = NULL;\\n    \\n    void inorderRecover(TreeNode*& root)\\n    {\\n        if(!root) return;\\n         \\n        inorderRecover(root->left);\\n        \\n        if(!first && prev && prev->val >= root->val)\\n            first = prev;\\n        \\n        if(first && prev->val >= root->val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderRecover(root->right);\\n    }\\n    \\n    void swap(TreeNode*& first, TreeNode*& second)\\n    {\\n        int temp = first->val;\\n        \\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        inorderRecover(root);\\n        \\n        swap(first,second);\\n    }\\n};\\n```\\n Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null;TreeNode first = null; TreeNode second = null;\\n    \\n    public void inorderHelper(TreeNode root)\\n    {\\n        if(root == null)  return;\\n        \\n        inorderHelper(root.left);\\n        \\n        if(first == null && prev != null && prev.val >= root.val)\\n            first = prev;\\n        \\n        if(first != null && prev.val >= root.val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderHelper(root.right);\\n    }\\n    \\n    public void swap(TreeNode first, TreeNode second)\\n    {\\n        int temp = first.val;\\n        \\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void recoverTree(TreeNode root)\\n    {\\n        prev = null; first = null; second = null;\\n        \\n        inorderHelper(root);\\n        \\n        swap(first,second);\\n    \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev = NULL;\\n    \\n    void inorderRecover(TreeNode*& root)\\n    {\\n        if(!root) return;\\n         \\n        inorderRecover(root->left);\\n        \\n        if(!first && prev && prev->val >= root->val)\\n            first = prev;\\n        \\n        if(first && prev->val >= root->val)\\n            second = root;\\n        \\n        prev = root;\\n        \\n        inorderRecover(root->right);\\n    }\\n    \\n    void swap(TreeNode*& first, TreeNode*& second)\\n    {\\n        int temp = first->val;\\n        \\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        inorderRecover(root);\\n        \\n        swap(first,second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225150,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        var lhs: TreeNode?, rhs: TreeNode?, prev: TreeNode?\\n        func bfs(_ root: TreeNode?) {\\n            guard let node = root else { return }\\n            bfs(node.left)\\n            if lhs == nil, let prev = prev, prev.val > node.val { lhs = prev }\\n            if lhs != nil, rhs == nil || node.val < rhs!.val { rhs = node }\\n            prev = node\\n            bfs(node.right)\\n        }\\n        bfs(root)\\n        if let lhs = lhs, let rhs = rhs {\\n            let tmp = lhs.val\\n            lhs.val = rhs.val\\n            rhs.val = tmp\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.034 (0.036) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test1() {\\n        let tree = TreeNode([1,3,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([3,1,nil,nil,2])?.val)\\n    }\\n    \\n    func test2() {\\n        let tree = TreeNode([3,1,4,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([2,1,4,nil,nil,3])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n\\n<details>\\n<summary><b>TreeNode</b></summary>\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ nums: [Int?]) {\\n        var arr = nums\\n        guard !arr.isEmpty, let head = arr.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let root = queue.removeFirst()\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.left = TreeNode(val)\\n                queue.append(root.left!)\\n            }\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.right = TreeNode(val)\\n                queue.append(root.right!)\\n            }\\n        }\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        var lhs: TreeNode?, rhs: TreeNode?, prev: TreeNode?\\n        func bfs(_ root: TreeNode?) {\\n            guard let node = root else { return }\\n            bfs(node.left)\\n            if lhs == nil, let prev = prev, prev.val > node.val { lhs = prev }\\n            if lhs != nil, rhs == nil || node.val < rhs!.val { rhs = node }\\n            prev = node\\n            bfs(node.right)\\n        }\\n        bfs(root)\\n        if let lhs = lhs, let rhs = rhs {\\n            let tmp = lhs.val\\n            lhs.val = rhs.val\\n            rhs.val = tmp\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test1() {\\n        let tree = TreeNode([1,3,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([3,1,nil,nil,2])?.val)\\n    }\\n    \\n    func test2() {\\n        let tree = TreeNode([3,1,4,nil,nil,2])\\n        solution.recoverTree(tree)\\n        XCTAssertEqual(tree?.val, TreeNode([2,1,4,nil,nil,3])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ nums: [Int?]) {\\n        var arr = nums\\n        guard !arr.isEmpty, let head = arr.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let root = queue.removeFirst()\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.left = TreeNode(val)\\n                queue.append(root.left!)\\n            }\\n            if !arr.isEmpty, let val = arr.removeFirst() {\\n                root.right = TreeNode(val)\\n                queue.append(root.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223843,
                "title": "detailed-explanation-of-solution-with-code",
                "content": "Inorder traversal of BST gives the elements in increasing order -> Almost all BST problems are based on this property.\\n\\nSolution 1: Using O(n) space, we can store the inorder traversal of the BST and then find the out-of-order elements, and swap them in the BST.\\nSolution 2: Using constant space and one pass of the BST. Let\\'s dive into it.\\n\\nThink about it. Do you really need to store all the elements to find the out-of-order numbers?\\nNo, you don\\'t. Since there are exactly 2 faulty nodes, we don\\'t need to store the entire traversal. How?\\nWe can keep track of the previously visited node, and compare its value with the current node. Whenever current.val < previous.val, we have found our anomaly.\\n\\nNow there can be 2 possible scenarios. Either the swapped elements are adjacent in the inorder traversal (not in the BST), or they are not.\\n\\nExample 1: Not adjacent\\n\\n        1\\n\\t  /\\n\\t3\\n      \\\\\\n        2\\n\\nThe inorder traversal of this tree is [3,2,1]. Here the swapped nodes are 1 and 3. \\n\\nExample 2: Adjacent\\n\\n        3\\n\\t  /   \\\\\\n\\t1       4\\n\\t      / \\n\\t    2 \\n\\nThe inorder traversal of this tree is [1,3,2,4]. Here the swapped nodes are 3 and 2. \\n\\n**Scenario 1**(Not adjacent) :\\n\\nIf you swap 2 non adjacent numbers in a sorted list, you would move a smaller number among bigger numbers and a bigger number among smaller numbers.\\n\\nFor instance, 1,2,3,4,5,6,7 => If you swap 3 with 6, you would move 6 between 2 and 4 (smaller than 6) and 3 between 5 and 7 (bigger than 3).\\nSo the faulty list will be [1,2,6,4,5,3,7]. Suppose this was our input to begin with. \\nWe will look for the anomaly now.\\n\\nprevious = 1, current = 2 Here previous < current => No anomaly. \\nprevious = 2, current = 6 Here previous < current => No anomaly.\\nprevious = 6, current = 4 Here previous > current => ANOMALY.\\nSimilarly, \\nprevious = 5, current = 3 Here previous > current => ANOMALY.\\n\\n**Scenario 2**(Adjacent)\\n\\nIn this case you will not find a second anomaly. So, swap previous with current.\\n\\nNow when we first encounter the anomaly, the faulty node is previous. But when we encounter 2nd anomaly, faulty node is current.\\n**Why? When you swap 2 non adjacent numbers in a sorted list, you would move a smaller number among bigger numbers and a bigger number among smaller numbers.**\\n\\nAlgorithm: \\n1. Initialise faultyA, faultyB, previous as null.\\n2. Visit every node, and keep track of the previous node.\\n3. if current < previous, then assign previous node to faultyA and current node to faultyB (for Scenario 2)\\n4. if current < previous is encountered again, or, if faultyA != null, assign currentNode to faultyB.\\n5. After traversal is complete, swap the faulty nodes.\\n\\nCode:\\n```\\nclass Solution {\\n    TreeNode faultyA = null;\\n    TreeNode faultyB = null;\\n    TreeNode mPrevious = null;\\n    public void recoverTree(TreeNode root) {\\n        findFaultyNodes(root);\\n        \\n        //Swap faulty nodes\\n        if(faultyA != null && faultyB != null) {\\n            int temp = faultyA.val;\\n            faultyA.val = faultyB.val;\\n            faultyB.val = temp;\\n        }\\n    }\\n    \\n    private void findFaultyNodes(TreeNode node) {\\n        if(node == null) {\\n            return;\\n        }\\n        \\n        findFaultyNodes(node.left);\\n        if(mPrevious != null) {\\n            if(node.val < mPrevious.val) {\\n                if(faultyA == null) {\\n                    faultyA = mPrevious;\\n                    faultyB = node;\\n                } else {\\n                    faultyB = node;\\n                }\\n            }\\n        }\\n        mPrevious = node;\\n        findFaultyNodes(node.right);\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    TreeNode faultyA = null;\\n    TreeNode faultyB = null;\\n    TreeNode mPrevious = null;\\n    public void recoverTree(TreeNode root) {\\n        findFaultyNodes(root);\\n        \\n        //Swap faulty nodes\\n        if(faultyA != null && faultyB != null) {\\n            int temp = faultyA.val;\\n            faultyA.val = faultyB.val;\\n            faultyB.val = temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3035927,
                "title": "c-inorder-traversal",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\nclass Solution {\\npublic:\\n  TreeNode *p = NULL;\\n  TreeNode *k = NULL;\\n  TreeNode *l = NULL;\\n  bool z = true;\\n  void solve(TreeNode *root) {\\n    if (root == NULL)\\n      return;\\n\\n    solve(root->left);\\n    if (z) {\\n      if (p == NULL || p->val < root->val) {\\n        p = root;\\n      } else {\\n        k = p;\\n        l = root;\\n        z = false;\\n        p = root;\\n      }\\n    } else {\\n        if (p == NULL || p->val < root->val) {\\n        p = root;\\n      } else {\\n        l = root;\\n      }\\n    }\\n    solve(root->right);\\n  }\\n\\n  void recoverTree(TreeNode *root) {\\n      solve(root);\\n      swap(k->val,l->val);\\n  }\\n};",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n  TreeNode *p = NULL;\\n  TreeNode *k = NULL;\\n  TreeNode *l = NULL;\\n  bool z = true;\\n  void solve(TreeNode *root) {\\n    if (root == NULL)\\n      return;\\n\\n    solve(root->left);\\n    if (z) {\\n      if (p == NULL || p->val < root->val) {\\n        p = root;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1548861,
                "title": "3-codes-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n  int index = 0;\\n    \\n    void res(TreeNode* root)\\n    {\\n      if(!root)\\n          return;\\n        \\n        res(root->left);\\n        root->val = tree[index++];\\n        res(root->right);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n        sort(tree.begin() , tree.end());\\n        res(root);\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n            int i, j;\\n        int n = tree.size();\\n    for (i = 0; i < n-1; i++)    \\n    for (j = 0; j < n-i-1; j++)\\n        if (tree[j]->val > tree[j+1]->val)\\n            swap(tree[j]->val, tree[j+1]->val);\\n\\n    }\\n};\\n```\\n```\\nvoid getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++)\\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n  int index = 0;\\n    \\n    void res(TreeNode* root)\\n    {\\n      if(!root)\\n          return;\\n        \\n        res(root->left);\\n        root->val = tree[index++];\\n        res(root->right);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n        sort(tree.begin() , tree.end());\\n        res(root);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    vector<TreeNode*> tree;\\n \\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root);\\n        inOrder(root->right);\\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n     inOrder(root);\\n            int i, j;\\n        int n = tree.size();\\n    for (i = 0; i < n-1; i++)    \\n    for (j = 0; j < n-i-1; j++)\\n        if (tree[j]->val > tree[j+1]->val)\\n            swap(tree[j]->val, tree[j+1]->val);\\n\\n    }\\n};\\n```\n```\\nvoid getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++)\\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485362,
                "title": "python3-o-n",
                "content": "```\\n    def inorder(self,root,arr):  # return sorted array of nodes\\n        if not root:\\n            return \\n        self.inorder(root.left,arr)\\n        arr.append(root)\\n        self.inorder(root.right,arr)\\n        return arr\\n    \\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        res = self.inorder(root,[])\\n        n = len(res)\\n                      \\n        a = res[0]      # default 1st wrong value from start\\n        for i in range(1,n):\\n            if res[i].val < res[i-1].val:\\n                a = res[i-1]\\n                break\\n            \\n        b = res[-1]   #default 1st wrong value from end\\n        for i in range(n-2,-1,-1):\\n            if res[i].val > res[i+1].val:\\n                b = res[i+1]\\n                break\\n        a.val,b.val = b.val,a.val       # swap\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def inorder(self,root,arr):  # return sorted array of nodes\\n        if not root:\\n            return \\n        self.inorder(root.left,arr)\\n        arr.append(root)\\n        self.inorder(root.right,arr)\\n        return arr\\n    \\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        res = self.inorder(root,[])\\n        n = len(res)\\n                      \\n        a = res[0]      # default 1st wrong value from start\\n        for i in range(1,n):\\n            if res[i].val < res[i-1].val:\\n                a = res[i-1]\\n                break\\n            \\n        b = res[-1]   #default 1st wrong value from end\\n        for i in range(n-2,-1,-1):\\n            if res[i].val > res[i+1].val:\\n                b = res[i+1]\\n                break\\n        a.val,b.val = b.val,a.val       # swap\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1466323,
                "title": "c-simple-approach",
                "content": "**Please Upvote if you like the Solution!**\\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    void fixBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return;\\n        fixBST(root->left);\\n        \\n        if(prev!=NULL && root->val<prev->val)\\n        {\\n            if(first==NULL)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        fixBST(root->right);\\n        \\n    }\\n    void recoverTree(TreeNode* root) \\n    {\\n        fixBST(root);\\n        swap(first->val,second->val);\\n    }",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "**Please Upvote if you like the Solution!**\\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    void fixBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return;\\n        fixBST(root->left);\\n        \\n        if(prev!=NULL && root->val<prev->val)\\n        {\\n            if(first==NULL)\\n                first=prev;\\n            second=root;\\n        }\\n        prev=root;\\n        fixBST(root->right);\\n        \\n    }\\n    void recoverTree(TreeNode* root) \\n    {\\n        fixBST(root);\\n        swap(first->val,second->val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 818965,
                "title": "java-3-different-solutions-morris-traversal-recursive-inorder-traversal-stack",
                "content": "1. main idea is to use inorder traversal because it will keep the order of values.\\n\\nMorris Traversal\\n```\\npublic void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // binary tree inorder traversal iteratively\\n        TreeNode parent = null;\\n        TreeNode current = root;\\n        while (current != null) {\\n            if (current.left != null) {\\n                parent = current.left;\\n                while (parent.right != null && parent.right != current) {\\n                    parent = parent.right;\\n                }\\n                if (parent.right == null) {\\n                    parent.right = current;\\n                    current = current.left;\\n                    continue;\\n                } else {\\n                    parent.right = null;\\n                }\\n            }\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```\\n\\n2. Recursive Inorder Traversal\\n```\\n public void recoverTree(TreeNode root) {\\n        final List<Integer> values = new ArrayList<>();\\n        final List<TreeNode> treeNodes = new ArrayList<>();\\n        inorderTraversal(root, values, treeNodes);\\n        Collections.sort(values);\\n        for (int i = 0; i < values.size(); i++) {\\n            treeNodes.get(i).val = values.get(i);\\n        }\\n    }\\n\\n    private void inorderTraversal(\\n            TreeNode root,\\n            List<Integer> values,\\n            List<TreeNode> treeNodes\\n    ) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, values, treeNodes);\\n        values.add(root.val);\\n        treeNodes.add(root);\\n        inorderTraversal(root.right, values, treeNodes);\\n    }\\n```\\n3. Stack Iterative Inorder Traversal\\n```\\n    public void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // template binary tree inorder traversal iteratively\\n        final Stack<TreeNode> stacks = new Stack<>();\\n        TreeNode current = root;\\n        while (current != null || !stacks.empty()) {\\n            while (current != null) {\\n                stacks.push(current);\\n                current = current.left;\\n            }\\n            current = stacks.pop();\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // binary tree inorder traversal iteratively\\n        TreeNode parent = null;\\n        TreeNode current = root;\\n        while (current != null) {\\n            if (current.left != null) {\\n                parent = current.left;\\n                while (parent.right != null && parent.right != current) {\\n                    parent = parent.right;\\n                }\\n                if (parent.right == null) {\\n                    parent.right = current;\\n                    current = current.left;\\n                    continue;\\n                } else {\\n                    parent.right = null;\\n                }\\n            }\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```\n```\\n public void recoverTree(TreeNode root) {\\n        final List<Integer> values = new ArrayList<>();\\n        final List<TreeNode> treeNodes = new ArrayList<>();\\n        inorderTraversal(root, values, treeNodes);\\n        Collections.sort(values);\\n        for (int i = 0; i < values.size(); i++) {\\n            treeNodes.get(i).val = values.get(i);\\n        }\\n    }\\n\\n    private void inorderTraversal(\\n            TreeNode root,\\n            List<Integer> values,\\n            List<TreeNode> treeNodes\\n    ) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, values, treeNodes);\\n        values.add(root.val);\\n        treeNodes.add(root);\\n        inorderTraversal(root.right, values, treeNodes);\\n    }\\n```\n```\\n    public void recoverTree(TreeNode root) {\\n        TreeNode previous = null;\\n        TreeNode first = null;\\n        TreeNode second = null;\\n        // template binary tree inorder traversal iteratively\\n        final Stack<TreeNode> stacks = new Stack<>();\\n        TreeNode current = root;\\n        while (current != null || !stacks.empty()) {\\n            while (current != null) {\\n                stacks.push(current);\\n                current = current.left;\\n            }\\n            current = stacks.pop();\\n            if (previous != null) {\\n                if (previous.val > current.val) {\\n                    if (first == null) {\\n                        first = previous;\\n                    }\\n                    second = current;\\n                }\\n            }\\n            previous = current;\\n            current = current.right;\\n        }\\n        // swap value\\n        final int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2129607,
                "title": "two-method-with-explanation",
                "content": "**Approch 1  O(N)**\\n1. traverse in inorder you get a sorted element if element is not sorted then mark the two element which are not sorted and swap it \\n2. In the question given only two element are not at it correct  position. you only need to point the two element \\n3. if you do inorder if previous element is greater than current element then you point that element.\\n```\\nclass Solution {\\n    TreeNode first=null, second=null, prev=null;\\n    public void recoverTree(TreeNode root) {\\n        inOrder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return;\\n        inOrder(root.left);\\n        if(prev!=null && prev.val>root.val){\\n            if(first==null)\\n            first=prev;\\n            second=root; \\n        }\\n        prev=root;\\n        inOrder(root.right);\\n    }\\n}\\n```\\n***Approch 2 O(NLOGN)***\\n1. in this approch inorder travese and store the element in the list and then sort the list and then traverse inorder if the list value if diffrent then root.val then store that list element to the root.val\\n```\\nclass Solution {\\n    int i=0;\\n    List <Integer> list;\\n    public void recoverTree(TreeNode root) {\\n        list=new ArrayList<>();\\n        inOrder(root);\\n        Collections.sort(list);\\n        change(root,list);\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return ;\\n        inOrder(root.left);\\n        list.add(root.val);\\n        inOrder(root.right);\\n    }\\n    void change(TreeNode root , List<Integer>list){\\n        if(root==null) return ;\\n        change(root.left,list);\\n        if(list.get(i)!=root.val){\\n           root.val=list.get(i); \\n        }\\n        i++;\\n        change(root.right,list);\\n    }\\n}\\n```\\n**please upvote \\nTHANKYOU***\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode first=null, second=null, prev=null;\\n    public void recoverTree(TreeNode root) {\\n        inOrder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return;\\n        inOrder(root.left);\\n        if(prev!=null && prev.val>root.val){\\n            if(first==null)\\n            first=prev;\\n            second=root; \\n        }\\n        prev=root;\\n        inOrder(root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int i=0;\\n    List <Integer> list;\\n    public void recoverTree(TreeNode root) {\\n        list=new ArrayList<>();\\n        inOrder(root);\\n        Collections.sort(list);\\n        change(root,list);\\n    }\\n    void inOrder(TreeNode root){\\n        if(root==null)return ;\\n        inOrder(root.left);\\n        list.add(root.val);\\n        inOrder(root.right);\\n    }\\n    void change(TreeNode root , List<Integer>list){\\n        if(root==null) return ;\\n        change(root.left,list);\\n        if(list.get(i)!=root.val){\\n           root.val=list.get(i); \\n        }\\n        i++;\\n        change(root.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963483,
                "title": "c-o-n-time-best-optimized-approach-recursive",
                "content": "Here I am using recusive approach to traverse the BST ;\\nYou can also use stack to traverse both will take same space ,depends on you as you wish ;\\n\\n\\n****upvote if it helps you****\\n\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\n\\tTreeNode*first;\\n    TreeNode*prev;\\n    TreeNode*last;\\n    void inorder(TreeNode*root){\\n        if(root==NULL) return ;\\n        inorder(root->left);\\n        if(prev!=NULL &&  (root->val < prev->val)) {\\n            if(first==NULL) {// this means that this the first voilation of rule;\\n                first = prev;\\n                last = root;\\n            }\\n            else \\n                last = root;    // if this is the second voilation of rule ;\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first = last = prev = NULL;\\n        inorder(root);\\n        if(first && last) swap(first->val, last->val);\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "Here I am using recusive approach to traverse the BST ;\\nYou can also use stack to traverse both will take same space ,depends on you as you wish ;\\n\\n\\n****upvote if it helps you****\\n\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\n\\tTreeNode*first;\\n    TreeNode*prev;\\n    TreeNode*last;\\n    void inorder(TreeNode*root){\\n        if(root==NULL) return ;\\n        inorder(root->left);\\n        if(prev!=NULL &&  (root->val < prev->val)) {\\n            if(first==NULL) {// this means that this the first voilation of rule;\\n                first = prev;\\n                last = root;\\n            }\\n            else \\n                last = root;    // if this is the second voilation of rule ;\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        first = last = prev = NULL;\\n        inorder(root);\\n        if(first && last) swap(first->val, last->val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1962655,
                "title": "java-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     TreeNode prev = null,first=null,second=null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first,second);\\n        return ;\\n    }\\n    void swap(TreeNode a,TreeNode b)\\n    {\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n      void helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return ;\\n        helper(root.left);\\n        \\n        if(prev!=null &&  prev.val > root.val)\\n        {\\n            if(first == null)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n         \\n        prev = root;\\n        helper(root.right);\\n    }\\n    \\n  \\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     TreeNode prev = null,first=null,second=null;\\n    \\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first,second);\\n        return ;\\n    }\\n    void swap(TreeNode a,TreeNode b)\\n    {\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n      void helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return ;\\n        helper(root.left);\\n        \\n        if(prev!=null &&  prev.val > root.val)\\n        {\\n            if(first == null)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n         \\n        prev = root;\\n        helper(root.right);\\n    }\\n    \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962302,
                "title": "python-o-1-space-14-lines-of-code",
                "content": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        done = True\\n        def recur(node, not_less_than, not_greater_than):\\n            nonlocal done\\n            if not_less_than and node.val < not_less_than.val:\\n                node.val, not_less_than.val = not_less_than.val, node.val\\n                done = True                \\n            if not_greater_than and node.val > not_greater_than.val:\\n                node.val, not_greater_than.val = not_greater_than.val, node.val\\n                done = True                \\n            if not done and node.left: recur(node.left, not_less_than, node)\\n            if not done and node.right: recur(node.right, node, not_greater_than)\\n        while done:                \\n            done = False\\n            recur(root, None, None)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        done = True\\n        def recur(node, not_less_than, not_greater_than):\\n            nonlocal done\\n            if not_less_than and node.val < not_less_than.val:\\n                node.val, not_less_than.val = not_less_than.val, node.val\\n                done = True                \\n            if not_greater_than and node.val > not_greater_than.val:\\n                node.val, not_greater_than.val = not_greater_than.val, node.val\\n                done = True                \\n            if not done and node.left: recur(node.left, not_less_than, node)\\n            if not done and node.right: recur(node.right, node, not_greater_than)\\n        while done:                \\n            done = False\\n            recur(root, None, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811866,
                "title": "c-clean-concise-inorder-traversal-98-4-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    \\n    void recover(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        recover(root->left);\\n        if(prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first=prev;\\n            }\\n            second=root;\\n        }\\n        prev=root;\\n        recover(root->right);  \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        recover(root);  \\n        swap(first->val,second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode *prev=NULL,*first=NULL,*second=NULL;\\n    \\n    void recover(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        recover(root->left);\\n        if(prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first=prev;\\n            }\\n            second=root;\\n        }\\n        prev=root;\\n        recover(root->right);  \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        recover(root);  \\n        swap(first->val,second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548853,
                "title": "c-o-n-solution-preorder-vector",
                "content": "```\\n    void getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++) // Just swap the 2 values which are not in Order \\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void getOrder(TreeNode* root, vector<TreeNode*> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root);\\n        getOrder(root->right, inOrder);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inOrder;\\n        getOrder(root, inOrder);\\n        int n = inOrder.size();\\n        \\n        for(int i = 1; i < n; i++) // Just swap the 2 values which are not in Order \\n            if(inOrder[i-1]->val > inOrder[i]->val)\\n            {\\n                int j = n-1;\\n                for(; j >= i; j--)\\n                {if(inOrder[j]->val < inOrder[j-1]->val) break;}\\n                swap(inOrder[j]->val, inOrder[i-1]->val);\\n                break;\\n            }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306519,
                "title": "c-recursion-o-1-memory",
                "content": "class Solution {\\n\\n\\t TreeNode *first=NULL,*second=NULL,*prev=NULL;   \\n    public:\\n    void fix(TreeNode *root){\\n        if(!root) return;\\n        fix(root->left);\\n        \\n        if(prev && root->val<prev->val){\\n            if(!first) first=prev;\\n            second=root;\\n        }\\n        \\n        prev=root;\\n        fix(root->right);\\n    }\\n    \\n    void recoverTree(TreeNode *root) {\\n        fix(root);\\n        swap(first->val,second->val);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n\\t TreeNode *first=NULL,*second=NULL,*prev=NULL;   \\n    public:\\n    void fix(TreeNode *root){\\n        if(!root) return;\\n        fix(root->left);\\n        \\n        if(prev && root->val<prev->val){\\n            if(!first) first=prev;\\n            second=root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 917307,
                "title": "java-dfs-comments",
                "content": "If you liked this solution, please upvote it\\n\\n```\\nclass Solution {\\n    TreeNode x, y, prev;\\n    public void recoverTree(TreeNode root) {\\n        if (root == null) return;\\n\\t\\t// first find x and y\\n        find(root);\\n\\t\\t// then swap\\n        swap(x, y);\\n    }\\n\\t\\t\\n\\t// goind to the end on left\\n    // looking for the first node, which val is greater than parent (left > root)\\n\\t// if will be writen to X\\n\\t// Then from top to bottom checking for the next value\\n\\t// in this case parent (prev) value should be greater than next; (root > right)\\n    public void find(TreeNode root) {\\n        if (root == null) return;\\n        find(root.left);\\n\\t\\tif (prev != null && prev.val > root.val) {\\n            y = root;\\n            if (x == null) {\\n                x = prev;\\n            } else {\\n                return;\\n            }\\n        }\\n        prev = root;\\n        find(root.right);\\n    }\\n    \\n    private void swap(TreeNode one, TreeNode two) {\\n        int tmp = one.val;\\n        one.val = two.val;\\n        two.val = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode x, y, prev;\\n    public void recoverTree(TreeNode root) {\\n        if (root == null) return;\\n\\t\\t// first find x and y\\n        find(root);\\n\\t\\t// then swap\\n        swap(x, y);\\n    }\\n\\t\\t\\n\\t// goind to the end on left\\n    // looking for the first node, which val is greater than parent (left > root)\\n\\t// if will be writen to X\\n\\t// Then from top to bottom checking for the next value\\n\\t// in this case parent (prev) value should be greater than next; (root > right)\\n    public void find(TreeNode root) {\\n        if (root == null) return;\\n        find(root.left);\\n\\t\\tif (prev != null && prev.val > root.val) {\\n            y = root;\\n            if (x == null) {\\n                x = prev;\\n            } else {\\n                return;\\n            }\\n        }\\n        prev = root;\\n        find(root.right);\\n    }\\n    \\n    private void swap(TreeNode one, TreeNode two) {\\n        int tmp = one.val;\\n        one.val = two.val;\\n        two.val = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660186,
                "title": "worst-sol-ever",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void recoverTree(TreeNode* root) {\\n     sol1(root);\\n        sort(v.begin(),v.end());\\n       sol2(root);\\n    }\\n    void sol1(TreeNode* n){\\n        if(!n)return;\\n        sol1(n->left);\\n        v.push_back(n->val);\\n        sol1(n->right);\\n    }\\n     void sol2(TreeNode* n){\\n         if(!n) return;\\n         sol2(n->left);\\n         n->val=v[i++];\\n         sol2(n->right);\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int i=0;\\n    void recoverTree(TreeNode* root) {\\n     sol1(root);\\n        sort(v.begin(),v.end());\\n       sol2(root);\\n    }\\n    void sol1(TreeNode* n){\\n        if(!n)return;\\n        sol1(n->left);\\n        v.push_back(n->val);\\n        sol1(n->right);\\n    }\\n     void sol2(TreeNode* n){\\n         if(!n) return;\\n         sol2(n->left);\\n         n->val=v[i++];\\n         sol2(n->right);\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338595,
                "title": "python-solution-with-comments-faster-than-99",
                "content": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n    # Idea: During in-order traversal, we keep checking that whether a node\\'s value is strictly larger than it\\'s predecessor\\'s value. If not, then abnormal nodes exist in the position.\\n        \\n        self.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\'))\\n\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                # find the abnormity -- self.prev.val >= node.val\\n                if self.prev.val >= node.val:\\n                    # When we find the first abnormal node first,\\n                    # we need to record the second one at the same time.\\n                    # When the first one is already found, we only need to update the second one\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = node\\n                self.prev = node  # prev is the pointer traversing the whole tree in in-order\\n                inorder(node.right)\\n\\n        inorder(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```\\n\\n- time complexity O(n)\\n- space complexity O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n    # Idea: During in-order traversal, we keep checking that whether a node\\'s value is strictly larger than it\\'s predecessor\\'s value. If not, then abnormal nodes exist in the position.\\n        \\n        self.first, self.second, self.prev = None, None, TreeNode(float(\\'-inf\\'))\\n\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                # find the abnormity -- self.prev.val >= node.val\\n                if self.prev.val >= node.val:\\n                    # When we find the first abnormal node first,\\n                    # we need to record the second one at the same time.\\n                    # When the first one is already found, we only need to update the second one\\n                    if not self.first:\\n                        self.first = self.prev\\n                    self.second = node\\n                self.prev = node  # prev is the pointer traversing the whole tree in in-order\\n                inorder(node.right)\\n\\n        inorder(root)\\n        self.first.val, self.second.val = self.second.val, self.first.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111021,
                "title": "o-n-space-c-solution",
                "content": "```\\n  void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        vector<int> vals;\\n        \\n        inorder(root, nodes, vals);\\n        sort(vals.begin(), vals.end());\\n        for (int i = 0; i < vals.size(); i++)\\n            nodes[i]->val = vals[i];\\n    }\\n    \\n    void inorder(TreeNode* root, vector<TreeNode*>& nodes, vector<int>& vals) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, vals);\\n        nodes.push_back(root);\\n        vals.push_back(root->val);\\n        inorder(root->right, nodes, vals);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        vector<int> vals;\\n        \\n        inorder(root, nodes, vals);\\n        sort(vals.begin(), vals.end());\\n        for (int i = 0; i < vals.size(); i++)\\n            nodes[i]->val = vals[i];\\n    }\\n    \\n    void inorder(TreeNode* root, vector<TreeNode*>& nodes, vector<int>& vals) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, vals);\\n        nodes.push_back(root);\\n        vals.push_back(root->val);\\n        inorder(root->right, nodes, vals);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32609,
                "title": "4ms-java-solution",
                "content": "    public class Solution {\\n        \\n         TreeNode first = null, second = null, pre = null;\\n        public void recoverTree(TreeNode root) {\\n            if(root==null)return;\\n            dfs(root);\\n            if(first!=null&&second!=null){\\n                int temp = first.val;\\n                first.val = second.val;\\n                second.val = temp;\\n            }\\n            \\n        }\\n        public void  dfs(TreeNode root){\\n            if(root.left!=null)dfs(root.left);\\n            if(pre!=null&&pre.val>root.val)\\n                {\\n                    if(first==null) first = pre;\\n                    if(first!=null)second = root;\\n                }\\n            pre = root;\\n            if(root.right!=null)dfs(root.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n         TreeNode first = null, second = null, pre = null;\\n        public void recoverTree(TreeNode root) {\\n            if(root==null)return;\\n            dfs(root);\\n            if(first!=null&&second!=null){\\n                int temp = first.val;\\n                first.val = second.val;\\n                second.val = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32617,
                "title": "18-line-of-cpp-solution-48ms-dfs",
                "content": "    class Solution {\\n    public:\\n        TreeNode* errorNodes[3];\\n        TreeNode* preNode = NULL;\\n        int found = 0;\\n    \\n        void dfs(TreeNode* node) {\\n            if (NULL != node->left) dfs(node->left);\\n            if (NULL != preNode) {\\n                if (preNode->val > node->val){\\n                    errorNodes[found] = preNode;\\n                    errorNodes[++found] = node;\\n                }\\n            }\\n            preNode = node;\\n            if (NULL != node->right && found <= 1) dfs(node->right);\\n        }\\n    \\n        void recoverTree(TreeNode* root) {\\n            dfs(root);\\n            if (0 != found) swap(errorNodes[0]->val, errorNodes[found]->val);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* errorNodes[3];\\n        TreeNode* preNode = NULL;\\n        int found = 0;\\n    \\n        void dfs(TreeNode* node) {\\n            if (NULL != node->left) dfs(node->left);\\n            if (NULL != preNode) {\\n                if (preNode->val > node->val){\\n                    errorNodes[found] = preNode;\\n                    errorNodes[++found] = node;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3516912,
                "title": "easy-c-solution-using-inorder-traversal",
                "content": "\\n# Approach\\nPLS UPVOTE IF YOU FIND THE SOLUTION EASY \\uD83D\\uDE09\\uD83D\\uDE09 \\nusing Inorder traversal , it can be done but dont use a vector to store the elements but keep 2 pointer so that at end u can swap them   \\nNow lets see.\\n1)Take 3 pointer prev ,start, end and intialize them with null  \\n2)Make a inorder function and the pointers  and the root \\n3)For the first iteration prev,will be null so put it at last after  the condition check \\n4)2nd iteration onwards prev wont be null so now check if first is null if yes then first will be prev and end will be root and then prev will be root \\n5)If everything goes according to the plan then first can be changed only one time when first is null\\nsame\\xA0for\\xA0the\\xA0second\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        // AS IN INORDER TRAVERSAL LNR SO LEFT TRAVERSAL WILL TAKE PLACE\\n        inorder(root->left, prev, first, end);\\n        if (prev!=NULL) \\n        {\\n            if (root->val < prev->val)\\n            {\\n                if(first==NULL)\\n                {\\n                    first = prev;\\n                }\\n            end = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right, prev, first, end);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr, *first = nullptr, *end = nullptr;\\n        inorder(root, prev, first, end);\\n        swap(first->val, end->val);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& end) {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        // AS IN INORDER TRAVERSAL LNR SO LEFT TRAVERSAL WILL TAKE PLACE\\n        inorder(root->left, prev, first, end);\\n        if (prev!=NULL) \\n        {\\n            if (root->val < prev->val)\\n            {\\n                if(first==NULL)\\n                {\\n                    first = prev;\\n                }\\n            end = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right, prev, first, end);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *prev = nullptr, *first = nullptr, *end = nullptr;\\n        inorder(root, prev, first, end);\\n        swap(first->val, end->val);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433687,
                "title": "java-100-faster-solution-using-inorder-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(log N) or O(H)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/f174fa1b-9f48-4193-9faf-7ca6c8884de1_1681883532.8229592.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private TreeNode first;   // The first node that violates the BST property\\n    private TreeNode middle;  // The middle node that violates the BST property\\n    private TreeNode last;    // The last node that violates the BST property\\n    private TreeNode prev;    // The previous node during the inorder traversal\\n\\n    public void inorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Traverse the left subtree\\n        inorder(root.left);\\n\\n        // Check if the current node violates the BST property\\n        if(prev != null && (root.val < prev.val)){\\n            // If this is the first time we\\'ve found a violation,\\n            // set first and middle to the nodes that violate the BST property\\n            if(first == null){\\n                first = prev;\\n                middle = root;\\n            }\\n            // If we\\'ve already found a violation, set last to the node that violates the BST property\\n            else{\\n                last = root;\\n            }\\n        }\\n        // Set prev to the current node, so that we can compare it to the next node\\n        prev = root;\\n\\n        // Traverse the right subtree\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        // Initialize the variables\\n        first = middle = last = null;\\n        // Initialize prev to a node with the minimum possible value, so that it will not violate the BST property\\n        prev = new TreeNode(Integer.MIN_VALUE);\\n\\n        // Perform an inorder traversal of the tree\\n        inorder(root);\\n\\n        // Swap the values of the nodes that violate the BST property, if any\\n        if(first != null && last != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are not adjacent to each other, swap the values of the first and last nodes\\n            int temp = first.val;\\n            first.val = last.val;\\n            last.val = temp;\\n        }\\n        else if(first != null && middle != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are adjacent to each other, swap the values of the first and middle nodes\\n            int temp = first.val;\\n            first.val = middle.val;\\n            middle.val = temp;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private TreeNode first;   // The first node that violates the BST property\\n    private TreeNode middle;  // The middle node that violates the BST property\\n    private TreeNode last;    // The last node that violates the BST property\\n    private TreeNode prev;    // The previous node during the inorder traversal\\n\\n    public void inorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Traverse the left subtree\\n        inorder(root.left);\\n\\n        // Check if the current node violates the BST property\\n        if(prev != null && (root.val < prev.val)){\\n            // If this is the first time we\\'ve found a violation,\\n            // set first and middle to the nodes that violate the BST property\\n            if(first == null){\\n                first = prev;\\n                middle = root;\\n            }\\n            // If we\\'ve already found a violation, set last to the node that violates the BST property\\n            else{\\n                last = root;\\n            }\\n        }\\n        // Set prev to the current node, so that we can compare it to the next node\\n        prev = root;\\n\\n        // Traverse the right subtree\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        // Initialize the variables\\n        first = middle = last = null;\\n        // Initialize prev to a node with the minimum possible value, so that it will not violate the BST property\\n        prev = new TreeNode(Integer.MIN_VALUE);\\n\\n        // Perform an inorder traversal of the tree\\n        inorder(root);\\n\\n        // Swap the values of the nodes that violate the BST property, if any\\n        if(first != null && last != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are not adjacent to each other, swap the values of the first and last nodes\\n            int temp = first.val;\\n            first.val = last.val;\\n            last.val = temp;\\n        }\\n        else if(first != null && middle != null){\\n            // If there are two nodes that violate the BST property,\\n            // and they are adjacent to each other, swap the values of the first and middle nodes\\n            int temp = first.val;\\n            first.val = middle.val;\\n            middle.val = temp;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963163,
                "title": "two-approaches-easy-understanding-solution",
                "content": "# BY TWO METHODS\\n**In O(n) Space**\\n```\\n//Please upvote if you like my solution :)\\nvoid solve(TreeNode* root,vector<TreeNode*> &inf){\\n        if(!root) return;\\n        solve(root->left,inf);\\n        inf.push_back(root);\\n        solve(root->right,inf);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inf;\\n        solve(root,inf);\\n        TreeNode* first, *second;\\n        for(int i=0;i<inf.size()-1;i++){\\n            if(inf[i]->val > inf[i+1]->val){\\n                first = inf[i];\\n                break;\\n            }\\n        }\\n        for(int i=inf.size()-1;i>=0;i--){\\n            if(inf[i]->val < first->val){\\n                second = inf[i];\\n                break;\\n            }\\n        }\\n        swap(first->val,second->val);\\n    }\\n```\\n**In O(1) Space**\\n```\\n//Please upvote if you like my solution :)\\nvoid inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        if(root->val < prev->val){\\n            if(!first){\\n                first = prev;\\n                middle = root;\\n            }else{\\n                last = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    TreeNode* first, *last , *middle , *prev;\\n    void recoverTree(TreeNode* root) {\\n        first = last = middle = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n        if(!last) swap(first->val,middle->val);\\n        else swap(first->val,last->val);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n//Please upvote if you like my solution :)\\nvoid solve(TreeNode* root,vector<TreeNode*> &inf){\\n        if(!root) return;\\n        solve(root->left,inf);\\n        inf.push_back(root);\\n        solve(root->right,inf);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> inf;\\n        solve(root,inf);\\n        TreeNode* first, *second;\\n        for(int i=0;i<inf.size()-1;i++){\\n            if(inf[i]->val > inf[i+1]->val){\\n                first = inf[i];\\n                break;\\n            }\\n        }\\n        for(int i=inf.size()-1;i>=0;i--){\\n            if(inf[i]->val < first->val){\\n                second = inf[i];\\n                break;\\n            }\\n        }\\n        swap(first->val,second->val);\\n    }\\n```\n```\\n//Please upvote if you like my solution :)\\nvoid inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        if(root->val < prev->val){\\n            if(!first){\\n                first = prev;\\n                middle = root;\\n            }else{\\n                last = root;\\n            }\\n        }\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    TreeNode* first, *last , *middle , *prev;\\n    void recoverTree(TreeNode* root) {\\n        first = last = middle = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n        if(!last) swap(first->val,middle->val);\\n        else swap(first->val,last->val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1476690,
                "title": "c-use-inorder-traversal",
                "content": "```\\nTreeNode *node_1 = NULL, *node_2 = NULL, *prev = NULL;\\n\\nvoid recoverTree(TreeNode* root) {\\n    // write your code here\\n    if (root == NULL) return;\\n    \\n    inorder(root);\\n    if (node_1 && node_2)\\n        swap(node_1->val, node_2->val);\\n}\\n\\nvoid inorder(TreeNode *root) {\\n    if (root == NULL) return;\\n    inorder(root->left);\\n    if (prev != NULL && root->val < prev->val) {\\n        if (node_1 == NULL) {\\n            node_1 = prev;\\n        } \\n        if (node_1 != NULL) {\\n            node_2 = root;\\n        }\\n    }\\n    prev = root;\\n    inorder(root->right);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTreeNode *node_1 = NULL, *node_2 = NULL, *prev = NULL;\\n\\nvoid recoverTree(TreeNode* root) {\\n    // write your code here\\n    if (root == NULL) return;\\n    \\n    inorder(root);\\n    if (node_1 && node_2)\\n        swap(node_1->val, node_2->val);\\n}\\n\\nvoid inorder(TreeNode *root) {\\n    if (root == NULL) return;\\n    inorder(root->left);\\n    if (prev != NULL && root->val < prev->val) {\\n        if (node_1 == NULL) {\\n            node_1 = prev;\\n        } \\n        if (node_1 != NULL) {\\n            node_2 = root;\\n        }\\n    }\\n    prev = root;\\n    inorder(root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917661,
                "title": "java-recover-bst-100-well-explained",
                "content": "\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n \\n    private TreeNode prev, node1, node2;\\n\\t //for a BST inorder traversal returns an increasing order, we keep a track of previous value and do inorder, if any value is smaller than prev, than we need to swap it with other similar value\\n  //since only 2 nodes were swapped this works\\n  \\n    public void recoverTree(TreeNode root) {\\n      inOrder(root);\\n      int temp = node2.val;\\n      node2.val = node1.val;\\n      node1.val = temp;\\n    }\\n  \\n  private void inOrder(TreeNode root){\\n    if(root==null)\\n      return;\\n\\n      inOrder(root.left);\\n      if(prev!=null && prev.val>root.val){\\n\\t  \\n        if(node1==null)\\n          node1 = prev;\\n        node2 = root;\\n      }\\n      prev = root;\\n      inOrder(root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n \\n    private TreeNode prev, node1, node2;\\n\\t //for a BST inorder traversal returns an increasing order, we keep a track of previous value and do inorder, if any value is smaller than prev, than we need to swap it with other similar value\\n  //since only 2 nodes were swapped this works\\n  \\n    public void recoverTree(TreeNode root) {\\n      inOrder(root);\\n      int temp = node2.val;\\n      node2.val = node1.val;\\n      node1.val = temp;\\n    }\\n  \\n  private void inOrder(TreeNode root){\\n    if(root==null)\\n      return;\\n\\n      inOrder(root.left);\\n      if(prev!=null && prev.val>root.val){\\n\\t  \\n        if(node1==null)\\n          node1 = prev;\\n        node2 = root;\\n      }\\n      prev = root;\\n      inOrder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531700,
                "title": "python-3-recursive-o-n",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        nodes = []\\n        values = []\\n        self.inorder(root, nodes, values)\\n        values.sort()\\n        for i in range(len(nodes)):\\n            nodes[i].val = values[i]\\n        \\n    def inorder(self, root, nodes, values):\\n        if root:\\n            self.inorder(root.left, nodes, values)\\n            nodes.append(root)\\n            values.append(root.val)\\n            self.inorder(root.right, nodes, values)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        nodes = []\\n        values = []\\n        self.inorder(root, nodes, values)\\n        values.sort()\\n        for i in range(len(nodes)):\\n            nodes[i].val = values[i]\\n        \\n    def inorder(self, root, nodes, values):\\n        if root:\\n            self.inorder(root.left, nodes, values)\\n            nodes.append(root)\\n            values.append(root.val)\\n            self.inorder(root.right, nodes, values)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231800,
                "title": "python-solution",
                "content": "Idea: We use the property that the inorder traversal of a BST is increasing. If two elements of a BST are swapped, then we can use inorder traversal to detect the two points where the increasing property breaks down. \\n\\nWe illustrate the algorithm with an example:\\n\\nSuppose the inorder traversal of a BST is the following: `[1,3,8,6,7,5,10]`. We initialize two pointers `left = None`, and `right = None` to denote the two elements that have been swapped. We use a pointer `trav` to denote the current node we are visiting during the traversal, and a pointer `prev` to denote the previous node. Suppose `prev.val > trav.val`, and `left == None`, (in this example, `prev.val = 8`, `trav.val = 6`) it means that we are at the first point where the increasing property breaks down. We assign `left = prev`, and another pointer `curr = trav` to record the current node. We continue with our tree traversal, and suppose  we are again in the scenario where `prev.val > trav.val`, but this time, `left != None`, (in this example, `prev.val = 7`, `trav.val = 5`) it means that we are at the second point where the increasing property breaks down. We assign `right = trav`. Finally, we swap the value of `left` and `right`: `left.val, right.val == right.val, left.val`.\\n\\nOne caveat is that, after the tree traversal, it might happen that `right` is still `None`. This happens whenever the two elements swapped are right next to each other. For example, if the inorder traversal of a tree yields `[1,3,5,7,6,8,10]`. Then after the traversal, we will find that `left.val = 7`, `curr.val = 6`, `right = None`. In this case, we just need to swap the value of `left` and `curr`: `left.val, curr.val = curr.val, left.val`. \\n\\nTime complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        trav = root\\n        prev = None\\n        left = None\\n        right = None\\n        while stack or trav:\\n            if trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                if prev and prev.val > u.val:\\n                    if not left:\\n                        left = prev\\n                        curr = u\\n                    else:\\n                        right = u\\n                prev = u\\n                trav = u.right\\n        if right:\\n            left.val, right.val = right.val, left.val\\n        else:\\n            left.val, curr.val = curr.val, left.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        trav = root\\n        prev = None\\n        left = None\\n        right = None\\n        while stack or trav:\\n            if trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                if prev and prev.val > u.val:\\n                    if not left:\\n                        left = prev\\n                        curr = u\\n                    else:\\n                        right = u\\n                prev = u\\n                trav = u.right\\n        if right:\\n            left.val, right.val = right.val, left.val\\n        else:\\n            left.val, curr.val = curr.val, left.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32530,
                "title": "std-cout-influence-test-result",
                "content": "The following cpp code can pass a specific test case\\n```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\n...\\n}\\n```\\nLater I add a std::cout like this:\\n```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\nstd::cout << now->val << std::endl;\\n...\\n}\\n```\\nSurprisingly,  the result, or the structure of the tree changed. It seems that std::cout influenced result, because if I annotate the line, the result will come back to an expected one. \\nMaybe something is wrong with pointers causing a memory pollution. Maybe the compiler misunderstood my code while optimizing it. But I can't understand how std::cout did it?",
                "solutionTags": [],
                "code": "```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\n...\\n}\\n```\n```\\n...\\nTreeNode *now;\\n...\\nwhile (now != NULL) {\\nstd::cout << now->val << std::endl;\\n...\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 32637,
                "title": "javascript-solution-with-inorder-traversal",
                "content": "    var recoverTree = function(root) {\\n      var node1, node2;\\n      var prev = new TreeNode(-Number.MAX_VALUE);\\n      traverse(root);\\n      var tmp = node1.val;\\n      node1.val = node2.val;\\n      node2.val = tmp;\\n      function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        if (node.val < prev.val) {\\n          node2 = node;\\n          if (!node1) node1 = prev;\\n        }\\n        prev = node;\\n        traverse(node.right);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var recoverTree = function(root) {\\n      var node1, node2;\\n      var prev = new TreeNode(-Number.MAX_VALUE);\\n      traverse(root);\\n      var tmp = node1.val;\\n      node1.val = node2.val;\\n      node2.val = tmp;\\n      function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        if (node.val < prev.val) {\\n          node2 = node;\\n          if (!node1) node1 = prev;\\n        }\\n        prev = node;\\n        traverse(node.right);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 32614,
                "title": "a-concise-java-solution-using-morris-inorder-o-n-time-o-1-space",
                "content": "    public class Solution {\\n        public void recoverTree(TreeNode root) {\\n            TreeNode first = null, second = null;\\n            TreeNode pre = new TreeNode(Integer.MIN_VALUE);\\n            while (root != null)\\n            {\\n                if (root.left != null)\\n                {\\n                    TreeNode p = root.left;\\n                    while (p.right != null && p.right != root)\\n                        p = p.right;\\n                    if (p.right == null)\\n                    {\\n                        p.right = root;\\n                        root = root.left;\\n                        continue;\\n                    }\\n                    else\\n                        p.right = null;\\n                }\\n                if (root.val < pre.val)\\n                {\\n                    if (first == null)\\n                    {\\n                        first = pre;\\n                    }\\n                    second = root;\\n                }\\n                pre = root;\\n                root = root.right;\\n            }\\n            int tmp = first.val;\\n            first.val = second.val;\\n            second.val = tmp;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void recoverTree(TreeNode root) {\\n            TreeNode first = null, second = null;\\n            TreeNode pre = new TreeNode(Integer.MIN_VALUE);\\n            while (root != null)\\n            {\\n                if (root.left != null)\\n                {\\n                    TreeNode p = root.left;\\n                    while (p.right != null && p.right != root)\\n                        p = p.right;\\n                    if (p.right == null)\\n                    {\\n                        p.right = root;\\n                        root = root.left;\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3554734,
                "title": "morris-traversal-o-1-s-c-c-code-with-explanation",
                "content": "# Please Do Upvote if it\\'s helpful \\n\\n# Intuition\\n* As we know the inorder traversal of a bst gives the nodes in sorted order and in this only two nodes aren\\'t in their sorted pos.\\n* We will find them and swap their values.\\n* We will use Morris Trversal for inorder to solve this problem.\\n* Morris Traversal will reduce the space complexity to O(1).\\n\\n\\n# Approach\\n\\n* Here we can see 2 cases\\n* *Case-1:* The swapped nodes aren\\'t adjacents.\\n    - eg: here is the inorder of a bst: `3 25 7 8 10 15 5`. See the node `25` and `5` are swapped and they aren\\'t adjacents.\\n* *Case-2:* The swapped nodes are adjacents.\\n    - eg: here is the inorder of a bst: `3 5 8 7 10 15 25`. See the node `8` and `7` are swapped and they are adjacents.\\n\\n* We will take 3 pointers first,mid and last.\\n* first will point to the node which violates the sorted condition first.\\n* mid will point to the next node of first (in inorder traversal).\\n* last will point to the node which violates the sorted condition second.\\n\\n* we will take another pointer prev which will point the last visited node in inorder.\\n* everytime we need to check if the curr node\\'s val is less than it\\'s prev node\\'s value or not if yes then the node violates the sorted condition.\\n\\n* In case-2 the sorted condition gets violated only 1 time. So the last pointer will be null in this case. So we will swap the first and middle.\\n* In case-1 the sorted condition gets violated 2 times so none of the 3 pointers will be null. So here we will swap first and last.\\n\\n---\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *first,*mid,*last,*prev;\\n        first=mid=last=nullptr;\\n        prev=new TreeNode(INT_MIN);\\n        TreeNode *curr=root;\\n        while(curr){\\n            if(!curr->left){ // left was done and we are at curr node\\n                // curr node is less than it\\'s inorder predecessor (not folllowing sorted conditi[[[[[[[[[[[[]()]()]()]()]()]()]()]()]()]()]()]()on)\\n                if(curr->val<prev->val){\\n                    // condition gets violated for the first time\\n                    if(!first){\\n                        first=prev;\\n                        mid=curr;\\n                    }\\n                    else last=curr;\\n                }\\n                prev=curr;\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode *now=curr->left;\\n                while(now->right && now->right!=curr)\\n                    now=now->right;\\n                if(!now->right){\\n                    now->right=curr;\\n                    curr=curr->left;\\n                }\\n                else{\\n                    now->right=nullptr;\\n                    if(curr->val<prev->val){\\n                        if(!first){\\n                            first=prev;\\n                            mid=curr;\\n                        }\\n                        else last=curr;\\n                    }\\n                    prev=curr;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        if(!last) swap(first->val,mid->val); // Case-2\\n        else swap(first->val,last->val); // Case-1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode *first,*mid,*last,*prev;\\n        first=mid=last=nullptr;\\n        prev=new TreeNode(INT_MIN);\\n        TreeNode *curr=root;\\n        while(curr){\\n            if(!curr->left){ // left was done and we are at curr node\\n                // curr node is less than it\\'s inorder predecessor (not folllowing sorted conditi[[[[[[[[[[[[]()]()]()]()]()]()]()]()]()]()]()]()on)\\n                if(curr->val<prev->val){\\n                    // condition gets violated for the first time\\n                    if(!first){\\n                        first=prev;\\n                        mid=curr;\\n                    }\\n                    else last=curr;\\n                }\\n                prev=curr;\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode *now=curr->left;\\n                while(now->right && now->right!=curr)\\n                    now=now->right;\\n                if(!now->right){\\n                    now->right=curr;\\n                    curr=curr->left;\\n                }\\n                else{\\n                    now->right=nullptr;\\n                    if(curr->val<prev->val){\\n                        if(!first){\\n                            first=prev;\\n                            mid=curr;\\n                        }\\n                        else last=curr;\\n                    }\\n                    prev=curr;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        if(!last) swap(first->val,mid->val); // Case-2\\n        else swap(first->val,last->val); // Case-1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280265,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector <int> nodes;\\n    int i = 0;\\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }\\n    void inorder(TreeNode* root, vector <int> nodes, int& i) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, i);\\n        if (root->val != nodes[i])\\n            root->val = nodes[i];\\n        i++;    \\n        inorder(root->right, nodes, i);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        traversal(root, nodes);\\n        sort(nodes.begin(), nodes.end());\\n        inorder(root, nodes, i);\\n    }\\n};\\n```\\n\\n# Approach 2\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* prev = new TreeNode(INT_MIN);\\n    TreeNode* first = NULL;\\n    TreeNode* middle = NULL;\\n    TreeNode* last = NULL;\\nprivate:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left);\\n        if (prev->val > root->val) {\\n            if (first == NULL) {\\n                first = prev;\\n                middle = root;\\n            } else {\\n                last = root;\\n            }\\n        }  \\n        prev = root; \\n        inorder(root->right);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if (last != NULL)\\n            swap(first->val, last->val);\\n        else\\n            swap(first->val, middle->val);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector <int> nodes;\\n    int i = 0;\\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }\\n    void inorder(TreeNode* root, vector <int> nodes, int& i) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left, nodes, i);\\n        if (root->val != nodes[i])\\n            root->val = nodes[i];\\n        i++;    \\n        inorder(root->right, nodes, i);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        traversal(root, nodes);\\n        sort(nodes.begin(), nodes.end());\\n        inorder(root, nodes, i);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* prev = new TreeNode(INT_MIN);\\n    TreeNode* first = NULL;\\n    TreeNode* middle = NULL;\\n    TreeNode* last = NULL;\\nprivate:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL)\\n            return;\\n        inorder(root->left);\\n        if (prev->val > root->val) {\\n            if (first == NULL) {\\n                first = prev;\\n                middle = root;\\n            } else {\\n                last = root;\\n            }\\n        }  \\n        prev = root; \\n        inorder(root->right);    \\n    }        \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        if (last != NULL)\\n            swap(first->val, last->val);\\n        else\\n            swap(first->val, middle->val);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992577,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* first=NULL;\\n    TreeNode* sec=NULL;\\n    TreeNode* prev=NULL;\\n    void dfs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        dfs(root->left);\\n        if(prev && prev->val>root->val)\\n        {\\n            if(first==NULL)\\n            first=prev;\\n            sec=root;\\n        }\\n        prev=root;\\n        dfs(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        dfs(root);\\n        int t=first->val;\\n        first->val=sec->val;\\n        sec->val=t;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* first=NULL;\\n    TreeNode* sec=NULL;\\n    TreeNode* prev=NULL;\\n    void dfs(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        dfs(root->left);\\n        if(prev && prev->val>root->val)\\n        {\\n            if(first==NULL)\\n            first=prev;\\n            sec=root;\\n        }\\n        prev=root;\\n        dfs(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        dfs(root);\\n        int t=first->val;\\n        first->val=sec->val;\\n        sec->val=t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892538,
                "title": "easy-to-understand",
                "content": "\\n\\n```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        inorder_nodes = []\\n        def inorder(root):\\n            if root:\\n                inorder(root.left)\\n                inorder_nodes.append(root)\\n                inorder(root.right)\\n                 \\n        inorder(root)\\n        sorted_nodes = sorted(inorder_nodes, key = lambda x: x.val)\\n        \\n        wrong = []\\n        for (i, node) in enumerate(sorted_nodes):\\n            if inorder_nodes[i].val != node.val:\\n                wrong.append(node)\\n                \\n        wrong[0].val, wrong[1].val = wrong[1].val, wrong[0].val\\n```\\n\\nThe time complexity of this solution is O(n log n), where n is the number of nodes in the tree. This is because the DFS traversal takes O(n) time, and sorting the keys in the dictionary takes O(n log n) time.\\n\\nThe space complexity of this solution is O(n), where n is the number of nodes in the tree. This is because the nodes dictionary and the sorted_keys list both take up O(n) space.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def recoverTree(self, root):\\n        inorder_nodes = []\\n        def inorder(root):\\n            if root:\\n                inorder(root.left)\\n                inorder_nodes.append(root)\\n                inorder(root.right)\\n                 \\n        inorder(root)\\n        sorted_nodes = sorted(inorder_nodes, key = lambda x: x.val)\\n        \\n        wrong = []\\n        for (i, node) in enumerate(sorted_nodes):\\n            if inorder_nodes[i].val != node.val:\\n                wrong.append(node)\\n                \\n        wrong[0].val, wrong[1].val = wrong[1].val, wrong[0].val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671908,
                "title": "2-approaches-with-line-to-line-explanation",
                "content": "Best Approach Using Inorder Traversal\\n    *TC: O(N)  \\n\\tSC: O(1)*\\n    \"prev\" stores the previous value in \"Inorder Travesal\"\\n   \"f\" -> first mis-placed element, \\n\\t\"s\" -> second im-positioned element \\n```\\nclass Solution {\\npublic:\\n    TreeNode *f=0,*s=0,*prev=new TreeNode(INT_MIN);\\n    void recoverTree(TreeNode* root) {\\n       traverse(root);\\n        int t=f->val;\\n        f->val=s->val;\\n        s->val=t;\\n    }\\n    void traverse(TreeNode* root){\\n        if(!root)return;\\n        traverse(root->left);\\n\\t\\t//if first element itself not found and and an order mis-match found in inorder, assing it to first element i.e. \\'f\\'\\n        if(!f and prev->val>root->val)f=prev;\\n\\t\\t\\n\\t\\t//if first element already found and and an order mis-match found in inorder, assing it to second element i.e. \\'s\\'\\n        if(f and prev->val>root->val)s=root;\\n        prev=root;\\n        traverse(root->right);\\n    }\\n};\\n```\\n\\n```\\n\\nSecond Approach\\nUsing Property: Inorder Travesal must give Sorted Result *TC: O(N)  SC: O(N)*\\n\\n vector<int>v;\\n    void recoverTree(TreeNode* root) {\\n\\t\\t//any tree traversal to store values of tree\\n        inorder(root);\\n\\t\\t// genearting inorder travesal of BST by sorting\\n        sort(v.begin(),v.end());\\n        int k=0;\\n\\t\\t//Level Order Traversal to assign values from sorted array to tree simply (copying)\\n        create(root,k);\\n    }\\n\\t//Any Travesal Method, Here Using Inorder\\n    void inorder(TreeNode* root){\\n        if(!root)return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        return ;   \\n    }\\n\\t\\n\\t//Inorder for copying sorted values from array\\n    void create(TreeNode* root,int &k){\\n        if(!root)return;\\n        if(root->left) {create(root->left,k);}\\n        root->val=v[k++];\\n        if(root->right) create(root->right,k);\\n         return ; \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *f=0,*s=0,*prev=new TreeNode(INT_MIN);\\n    void recoverTree(TreeNode* root) {\\n       traverse(root);\\n        int t=f->val;\\n        f->val=s->val;\\n        s->val=t;\\n    }\\n    void traverse(TreeNode* root){\\n        if(!root)return;\\n        traverse(root->left);\\n\\t\\t//if first element itself not found and and an order mis-match found in inorder, assing it to first element i.e. \\'f\\'\\n        if(!f and prev->val>root->val)f=prev;\\n\\t\\t\\n\\t\\t//if first element already found and and an order mis-match found in inorder, assing it to second element i.e. \\'s\\'\\n        if(f and prev->val>root->val)s=root;\\n        prev=root;\\n        traverse(root->right);\\n    }\\n};\\n```\n```\\n\\nSecond Approach\\nUsing Property: Inorder Travesal must give Sorted Result *TC: O(N)  SC: O(N)*\\n\\n vector<int>v;\\n    void recoverTree(TreeNode* root) {\\n\\t\\t//any tree traversal to store values of tree\\n        inorder(root);\\n\\t\\t// genearting inorder travesal of BST by sorting\\n        sort(v.begin(),v.end());\\n        int k=0;\\n\\t\\t//Level Order Traversal to assign values from sorted array to tree simply (copying)\\n        create(root,k);\\n    }\\n\\t//Any Travesal Method, Here Using Inorder\\n    void inorder(TreeNode* root){\\n        if(!root)return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        return ;   \\n    }\\n\\t\\n\\t//Inorder for copying sorted values from array\\n    void create(TreeNode* root,int &k){\\n        if(!root)return;\\n        if(root->left) {create(root->left,k);}\\n        root->val=v[k++];\\n        if(root->right) create(root->right,k);\\n         return ; \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451929,
                "title": "simple-c-inorder-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* first, *second, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(first->val, second->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(first == nullptr && root->val < pre->val)\\n\\t\\t\\tfirst = pre;\\n\\t\\tif(first != nullptr && root->val < pre->val)\\n\\t\\t\\tsecond = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```\\n**Please Upvote\\nthank you!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tTreeNode* first, *second, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(first->val, second->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(first == nullptr && root->val < pre->val)\\n\\t\\t\\tfirst = pre;\\n\\t\\tif(first != nullptr && root->val < pre->val)\\n\\t\\t\\tsecond = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967352,
                "title": "c-3-approaches-with-explanation-brute-optimised",
                "content": "Brute Force O(nlogn) time complexity and O(n) space\\n\\nAlgorithm:\\n\\n1. Traverse with Inorder Traversal and store data in Array\\n2. sort that Array\\n3. copy that Array with One more Inorder Traversal\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<int> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root->val);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n    \\n    void rec_add(TreeNode* root,vector<int> &v,int &i){\\n         if(root == NULL) return;\\n        \\n        rec_add(root->left,v,i);\\n    \\n        root->val = v[i++];\\n               \\n        rec_add(root->right,v,i);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<int> v;\\n        \\n        rec(root,v);\\n        sort(v.begin(),v.end());\\n        int i = 0;\\n        \\n        rec_add(root,v,i);\\n    }\\n\\n};\\n```\\n\\nO(n) time complexity and O(n) space\\n\\nIn this solution we reduced the time of sorting part , as we know that there will be exactly 2 numbers which are not in place we have to find them\\n\\nso we will traverse on array the first element we get with a[i] < a[i-1] at i-1 will be first one to swap , after geting this i-1 we will go for 2nd element we will store every num from first element with a[i] < a[i-1] and at last we end up getting 2nd number to be swaped.\\n\\nAlgorithm:\\n\\n1.Traverse Inorder on BST and store in Array\\n2.find first element and 2nd element to be swaped\\n3.swap that 2 numbers\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<TreeNode*> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<TreeNode*> v;\\n        \\n        rec(root,v);\\n       \\n        int swap_idx = -1;\\n        int swap_idx2 = -1;\\n        \\n        int i;\\n        \\n        for(i = 1;i<v.size();i++){\\n            if( v[i]->val < v[i-1]->val){\\n                if(swap_idx == -1 ){ \\n                \\n                 swap_idx = i-1;\\n                 swap_idx2 = i;\\n                \\n                }\\n                else {\\n                    \\n                    swap_idx2 = i;\\n                \\n                }\\n            }\\n        }\\n         \\n             int t = v[swap_idx]->val;\\n             v[swap_idx]->val = v[swap_idx2]->val;\\n             v[swap_idx2]->val = t;\\n        \\n    }\\n\\n};\\n```\\n\\nOptimised : O(n) time complexty with O(1) space complexity\\n\\nHere to get those 2 nodes to be swaped we will maintain 3 TreeNodes prev,TreeNode first,TreeNode second \\nand while traversing Inorderly we will check for those conditions as prev->val > root->val and update 1st and second node\\nafter rec calls ends we will have those 2 nodes finally we will swap them\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,TreeNode* &prev,TreeNode* &first,TreeNode* &second){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,prev,first,second);\\n    \\n        if(root->val < prev->val){\\n            \\n            if(first == NULL){\\n                first = prev;\\n                second = root;\\n            }else{\\n                second = root;\\n            }\\n            \\n        }\\n \\n        prev = root;\\n        rec(root->right,prev,first,second);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode* prev = new TreeNode(INT_MIN);\\n        TreeNode* a = NULL;\\n        TreeNode* b = NULL;\\n        \\n        rec(root,prev,a,b);\\n        \\n        int t = a->val;\\n        a->val = b->val;\\n        b->val = t;\\n       \\n    }\\n\\n};\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<int> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root->val);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n    \\n    void rec_add(TreeNode* root,vector<int> &v,int &i){\\n         if(root == NULL) return;\\n        \\n        rec_add(root->left,v,i);\\n    \\n        root->val = v[i++];\\n               \\n        rec_add(root->right,v,i);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<int> v;\\n        \\n        rec(root,v);\\n        sort(v.begin(),v.end());\\n        int i = 0;\\n        \\n        rec_add(root,v,i);\\n    }\\n\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,vector<TreeNode*> &v){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,v);\\n    \\n        v.push_back(root);\\n               \\n        rec(root->right,v);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        vector<TreeNode*> v;\\n        \\n        rec(root,v);\\n       \\n        int swap_idx = -1;\\n        int swap_idx2 = -1;\\n        \\n        int i;\\n        \\n        for(i = 1;i<v.size();i++){\\n            if( v[i]->val < v[i-1]->val){\\n                if(swap_idx == -1 ){ \\n                \\n                 swap_idx = i-1;\\n                 swap_idx2 = i;\\n                \\n                }\\n                else {\\n                    \\n                    swap_idx2 = i;\\n                \\n                }\\n            }\\n        }\\n         \\n             int t = v[swap_idx]->val;\\n             v[swap_idx]->val = v[swap_idx2]->val;\\n             v[swap_idx2]->val = t;\\n        \\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode* root,TreeNode* &prev,TreeNode* &first,TreeNode* &second){\\n        if(root == NULL) return;\\n        \\n        rec(root->left,prev,first,second);\\n    \\n        if(root->val < prev->val){\\n            \\n            if(first == NULL){\\n                first = prev;\\n                second = root;\\n            }else{\\n                second = root;\\n            }\\n            \\n        }\\n \\n        prev = root;\\n        rec(root->right,prev,first,second);\\n        \\n    }\\n\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode* prev = new TreeNode(INT_MIN);\\n        TreeNode* a = NULL;\\n        TreeNode* b = NULL;\\n        \\n        rec(root,prev,a,b);\\n        \\n        int t = a->val;\\n        a->val = b->val;\\n        b->val = t;\\n       \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963371,
                "title": "2-java-solution-from-extra-space-to-optimized",
                "content": "\\n**Approach 1->**\\n\\nFirst thing that comes into mind is that in-order traversal is sorted. so if we store in-order of tree to list and then we just need to find two nodes on which we want to swap values. i.e. start and end node.\\n1.iterate the list to check first occurence where ith element > i+1th element. now,we have start node \\n2.if we have start node with us . now check further if any value exists whose value is smaller then start node. store it as end node and break out of loop\\n3.now just swap start and end values.\\n\\nexample->\\ninorder if suppose is -> \\n-33,321,55,71,231,-13,399\\nfirst we will get start as 321. as 321>55\\nnow, we have start then we meet 321<399 condition. in such case -13 will be end.\\n\\n```\\npublic void recoverTree(TreeNode root) {\\n\\t\\tList<TreeNode> list = new ArrayList<>();\\n\\t\\tinorder(root, list);\\n\\t\\tint start = -1;\\n\\t\\tint end = list.size() - 1;\\n\\t\\tfor (int i = 0; i < list.size() - 1; i++) {\\n\\t\\t\\tif (start == -1 && list.get(i).val > list.get(i + 1).val) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t} else if (start != -1 && list.get(start).val < list.get(i + 1).val) {\\n\\t\\t\\t\\tend = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint temp = list.get(start).val;\\n\\t\\tlist.get(start).val = list.get(end).val;\\n\\t\\tlist.get(end).val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root, List<TreeNode> list) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left, list);\\n\\t\\t\\tlist.add(root);\\n\\t\\t\\tinorder(root.right, list);\\n\\t\\t}\\n\\t}\\n```\\n\\n\\n**Approach 2->**\\n\\n1. we can observe that at a time we just need ith and i+1th node to compare. i.e. prev and curr element. and once found start and end node also needed. i.e. total 4 nodes can serve the purpose. instead of entire list.\\n2. just convert above iterative loop into recursive approach->\\n```\\npublic class Solution {\\n\\n\\tTreeNode start = null;\\n\\tTreeNode end = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tprev = new TreeNode(Integer.MIN_VALUE);\\n\\t\\tinorder(root);\\n\\t\\tint temp = start.val;\\n\\t\\t//case where last node itself needed to be swapped\\n\\t\\tif (end == null) {\\n\\t\\t\\tend = prev;\\n\\t\\t}\\n\\t\\tstart.val = end.val;\\n\\t\\tend.val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left);\\n\\t\\t\\tif (start == null && prev.val > root.val) {\\n\\t\\t\\t\\tstart = prev;\\n\\t\\t\\t} else if (start != null && start.val < root.val) {\\n\\t\\t\\t\\tend = prev;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tprev = root;\\n\\t\\t\\tinorder(root.right);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic void recoverTree(TreeNode root) {\\n\\t\\tList<TreeNode> list = new ArrayList<>();\\n\\t\\tinorder(root, list);\\n\\t\\tint start = -1;\\n\\t\\tint end = list.size() - 1;\\n\\t\\tfor (int i = 0; i < list.size() - 1; i++) {\\n\\t\\t\\tif (start == -1 && list.get(i).val > list.get(i + 1).val) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t} else if (start != -1 && list.get(start).val < list.get(i + 1).val) {\\n\\t\\t\\t\\tend = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint temp = list.get(start).val;\\n\\t\\tlist.get(start).val = list.get(end).val;\\n\\t\\tlist.get(end).val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root, List<TreeNode> list) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left, list);\\n\\t\\t\\tlist.add(root);\\n\\t\\t\\tinorder(root.right, list);\\n\\t\\t}\\n\\t}\\n```\n```\\npublic class Solution {\\n\\n\\tTreeNode start = null;\\n\\tTreeNode end = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tprev = new TreeNode(Integer.MIN_VALUE);\\n\\t\\tinorder(root);\\n\\t\\tint temp = start.val;\\n\\t\\t//case where last node itself needed to be swapped\\n\\t\\tif (end == null) {\\n\\t\\t\\tend = prev;\\n\\t\\t}\\n\\t\\tstart.val = end.val;\\n\\t\\tend.val = temp;\\n\\t}\\n\\n\\tprivate void inorder(TreeNode root) {\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorder(root.left);\\n\\t\\t\\tif (start == null && prev.val > root.val) {\\n\\t\\t\\t\\tstart = prev;\\n\\t\\t\\t} else if (start != null && start.val < root.val) {\\n\\t\\t\\t\\tend = prev;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tprev = root;\\n\\t\\t\\tinorder(root.right);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963292,
                "title": "python-easy-python-solution-using-inorder-traversal-and-array",
                "content": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\tclass Solution:\\n\\t\\tdef recoverTree(self, root: Optional[TreeNode]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify root in-place instead.\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\tdef InOrder(node):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tInOrder(node.left)\\n\\t\\t\\t\\t\\tarray.append(node)\\n\\t\\t\\t\\t\\tInOrder(node.right)\\n\\n\\t\\t\\tInOrder(root)\\n\\n\\t\\t\\tlength = len(array)\\n\\n\\t\\t\\tfirst_node = array[0]\\n\\n\\t\\t\\tsecond_node = array[-1]\\n\\n\\t\\t\\tfor i in range(1,length):\\n\\t\\t\\t\\tif array[i].val < array[i-1].val:\\n\\t\\t\\t\\t\\tfirst_node = array[i-1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfor i in range(length-2,-1,-1):\\n\\t\\t\\t\\tif array[i].val > array[i+1].val:\\n\\t\\t\\t\\t\\tsecond_node = array[i+1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfirst_node.val , second_node.val = second_node.val , first_node.val",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n\\tclass Solution:\\n\\t\\tdef recoverTree(self, root: Optional[TreeNode]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify root in-place instead.\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tarray = []\\n\\n\\t\\t\\tdef InOrder(node):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tInOrder(node.left)\\n\\t\\t\\t\\t\\tarray.append(node)\\n\\t\\t\\t\\t\\tInOrder(node.right)\\n\\n\\t\\t\\tInOrder(root)\\n\\n\\t\\t\\tlength = len(array)\\n\\n\\t\\t\\tfirst_node = array[0]\\n\\n\\t\\t\\tsecond_node = array[-1]\\n\\n\\t\\t\\tfor i in range(1,length):\\n\\t\\t\\t\\tif array[i].val < array[i-1].val:\\n\\t\\t\\t\\t\\tfirst_node = array[i-1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfor i in range(length-2,-1,-1):\\n\\t\\t\\t\\tif array[i].val > array[i+1].val:\\n\\t\\t\\t\\t\\tsecond_node = array[i+1]\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\tfirst_node.val , second_node.val = second_node.val , first_node.val",
                "codeTag": "Java"
            },
            {
                "id": 1962494,
                "title": "go-inorder-dfs-clear-solution",
                "content": "```\\nfunc recoverTree(root *TreeNode)  {\\n    var prev, first, second *TreeNode\\n    \\n    var dfs func(node *TreeNode)\\n    dfs = func(node *TreeNode) {\\n        if node == nil { return }\\n        dfs(node.Left)\\n        if prev != nil {\\n            if first == nil && prev.Val >= node.Val { first = prev }\\n            if first != nil && prev.Val >= node.Val { second = node }\\n        }\\n        prev = node\\n        dfs(node.Right)\\n    }\\n    dfs(root)\\n\\t\\n    first.Val, second.Val = second.Val, first.Val\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc recoverTree(root *TreeNode)  {\\n    var prev, first, second *TreeNode\\n    \\n    var dfs func(node *TreeNode)\\n    dfs = func(node *TreeNode) {\\n        if node == nil { return }\\n        dfs(node.Left)\\n        if prev != nil {\\n            if first == nil && prev.Val >= node.Val { first = prev }\\n            if first != nil && prev.Val >= node.Val { second = node }\\n        }\\n        prev = node\\n        dfs(node.Right)\\n    }\\n    dfs(root)\\n\\t\\n    first.Val, second.Val = second.Val, first.Val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1962329,
                "title": "two-js-solutions-recursive-and-iterative",
                "content": "# Iterative Solution: \\n```\\nconst recoverTree = function (root) {\\n\\tconst stack = [];\\n\\tlet node = root,\\n\\t\\tprev = null,\\n\\t\\tx = null,\\n\\t\\ty = null;\\n\\twhile (stack.length || node) {\\n\\t\\tif (node) {\\n\\t\\t\\tstack.push(node);\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tnode = stack.pop();\\n\\t\\tif (prev && prev.val > node.val) {\\n\\t\\t\\ty = node;\\n\\t\\t\\tif (!x) x = prev;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tnode = node.right;\\n\\t}\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```\\n# Recursive Solution:\\n```\\nconst recoverTree = function (root) {\\n\\tlet x = null,\\n\\t\\ty = null,\\n\\t\\tprev = null;\\n\\tconst dfs = (node) => {\\n\\t\\tif (!node) return;\\n\\t\\tdfs(node.left);\\n\\t\\tif (prev && node.val < prev.val) {\\n\\t\\t\\tif (x == null) x = prev;\\n\\t\\t\\ty = node;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tdfs(node.right);\\n\\t};\\n\\tdfs(root);\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst recoverTree = function (root) {\\n\\tconst stack = [];\\n\\tlet node = root,\\n\\t\\tprev = null,\\n\\t\\tx = null,\\n\\t\\ty = null;\\n\\twhile (stack.length || node) {\\n\\t\\tif (node) {\\n\\t\\t\\tstack.push(node);\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tnode = stack.pop();\\n\\t\\tif (prev && prev.val > node.val) {\\n\\t\\t\\ty = node;\\n\\t\\t\\tif (!x) x = prev;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tnode = node.right;\\n\\t}\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```\n```\\nconst recoverTree = function (root) {\\n\\tlet x = null,\\n\\t\\ty = null,\\n\\t\\tprev = null;\\n\\tconst dfs = (node) => {\\n\\t\\tif (!node) return;\\n\\t\\tdfs(node.left);\\n\\t\\tif (prev && node.val < prev.val) {\\n\\t\\t\\tif (x == null) x = prev;\\n\\t\\t\\ty = node;\\n\\t\\t}\\n\\t\\tprev = node;\\n\\t\\tdfs(node.right);\\n\\t};\\n\\tdfs(root);\\n\\t[x.val, y.val] = [y.val, x.val];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534309,
                "title": "c-solution-with-easy-to-understand-explanation",
                "content": "```\\n    void recoverTree(TreeNode* root) {\\n        // when inorder traversing a BST, we would traverse the node with the values in increasing order\\n        // if there are only two nodes in the BST that their values are wrong, there\\'s only one situation:\\n        // a node with a larger value appears before a node with a smaller value in the inorder traversal result\\n        // during the inorder traversing, the first node which value is greater than the its successor must be one of the wrong nodes which has a larger value\\n        // for the smaller value wrong node, we can see that its value must be smaller than its predecessor\\n        // we can see that the last node which value is smaller than its predecessor in the inorder traversal must be the smaller wrong node.\\n        // to better understanding we can see that for an inorder traversal result 1 2 6 4 5 3 7\\n        // the first node that its value greater than its successor is the node with value 6\\n        // and the last node which value is smaller than its predecessor is the node with value 3\\n        // for an other example, 1 3 2 4\\n        // 3 is the first value which is greater than its successor and 2 is the last value which value is smaller than its predecessor\\n        TreeNode* largeNode = NULL;\\n        TreeNode* smallNode = NULL;\\n        TreeNode* preNode = NULL;\\n        inorderTraversal(root, largeNode, smallNode, preNode);\\n        int smallVal = smallNode->val;\\n        smallNode->val = largeNode->val;\\n        largeNode->val = smallVal;\\n    }\\n    \\n    void inorderTraversal(TreeNode* node, TreeNode*& largeNode, TreeNode*& smallNode, TreeNode*& preNode) {\\n        if (node == NULL) {\\n            return;\\n        }\\n        inorderTraversal(node->left, largeNode, smallNode, preNode);\\n        // the first node has no predecessor so we can\\'t tell whether it\\'s greater or smaller than its predecessor\\n        if (preNode != NULL && node->val < preNode->val) {\\n            // largeNode equals NULL means preNode is the first node whose value is greater than its successor\\n            // so preNode is the wrong larger node\\n            if (largeNode == NULL) {\\n                largeNode = preNode;\\n            }\\n            // there maybe two nodes with a smaller value than its predecessor, the successor of the larger wrong node and the real smaller wrong node\\n            // the last smallNode is the smaller wrong node which we want to get\\n            smallNode = node;\\n        }\\n        // node becomes preNode of the next node after being traversed\\n        preNode = node;\\n        inorderTraversal(node->right, largeNode, smallNode, preNode);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void recoverTree(TreeNode* root) {\\n        // when inorder traversing a BST, we would traverse the node with the values in increasing order\\n        // if there are only two nodes in the BST that their values are wrong, there\\'s only one situation:\\n        // a node with a larger value appears before a node with a smaller value in the inorder traversal result\\n        // during the inorder traversing, the first node which value is greater than the its successor must be one of the wrong nodes which has a larger value\\n        // for the smaller value wrong node, we can see that its value must be smaller than its predecessor\\n        // we can see that the last node which value is smaller than its predecessor in the inorder traversal must be the smaller wrong node.\\n        // to better understanding we can see that for an inorder traversal result 1 2 6 4 5 3 7\\n        // the first node that its value greater than its successor is the node with value 6\\n        // and the last node which value is smaller than its predecessor is the node with value 3\\n        // for an other example, 1 3 2 4\\n        // 3 is the first value which is greater than its successor and 2 is the last value which value is smaller than its predecessor\\n        TreeNode* largeNode = NULL;\\n        TreeNode* smallNode = NULL;\\n        TreeNode* preNode = NULL;\\n        inorderTraversal(root, largeNode, smallNode, preNode);\\n        int smallVal = smallNode->val;\\n        smallNode->val = largeNode->val;\\n        largeNode->val = smallVal;\\n    }\\n    \\n    void inorderTraversal(TreeNode* node, TreeNode*& largeNode, TreeNode*& smallNode, TreeNode*& preNode) {\\n        if (node == NULL) {\\n            return;\\n        }\\n        inorderTraversal(node->left, largeNode, smallNode, preNode);\\n        // the first node has no predecessor so we can\\'t tell whether it\\'s greater or smaller than its predecessor\\n        if (preNode != NULL && node->val < preNode->val) {\\n            // largeNode equals NULL means preNode is the first node whose value is greater than its successor\\n            // so preNode is the wrong larger node\\n            if (largeNode == NULL) {\\n                largeNode = preNode;\\n            }\\n            // there maybe two nodes with a smaller value than its predecessor, the successor of the larger wrong node and the real smaller wrong node\\n            // the last smallNode is the smaller wrong node which we want to get\\n            smallNode = node;\\n        }\\n        // node becomes preNode of the next node after being traversed\\n        preNode = node;\\n        inorderTraversal(node->right, largeNode, smallNode, preNode);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402315,
                "title": "c-solution-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int i=0;\\n    void find(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        find(root->left);\\n        v.push_back(root->val);\\n        find(root->right);\\n    }\\n    void check(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        check(root->left);\\n         root->val=v[i++];\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        find(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int i=0;\\n    void find(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        find(root->left);\\n        v.push_back(root->val);\\n        find(root->right);\\n    }\\n    void check(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        check(root->left);\\n         root->val=v[i++];\\n        check(root->right);\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        find(root);\\n        sort(v.begin(),v.end());\\n        check(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381752,
                "title": "simple-recursion-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev =NULL;\\n    \\n    void help(TreeNode*root){\\n        \\n        \\n    if(root == NULL) return;\\n    help(root->left);\\n    if(prev && first==NULL && prev->val>root->val) first = prev;\\n    if(prev && first!=NULL && prev->val>root->val) second = root;\\n    prev = root;\\n    help(root->right);\\n        \\n        \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        \\n    help(root);\\n    swap(first->val,second->val);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    TreeNode* prev =NULL;\\n    \\n    void help(TreeNode*root){\\n        \\n        \\n    if(root == NULL) return;\\n    help(root->left);\\n    if(prev && first==NULL && prev->val>root->val) first = prev;\\n    if(prev && first!=NULL && prev->val>root->val) second = root;\\n    prev = root;\\n    help(root->right);\\n        \\n        \\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        \\n    help(root);\\n    swap(first->val,second->val);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282486,
                "title": "o-1-space-time-complexity",
                "content": "```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=null;\\n    \\n    public void fix(TreeNode root){\\n        if(root==null) return;\\n        \\n        //traverse for left\\n        fix(root.left);\\n        \\n        //check for mistake\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null) first=prev;\\n            second=root;\\n        }\\n        \\n        //update previous to be root\\n        prev=root;\\n        \\n        //traverse for right\\n        fix(root.right);\\n    }\\n    \\n    public void recoverTree(TreeNode root) {\\n        fix(root);\\n        \\n        //swap first and second\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=null;\\n    \\n    public void fix(TreeNode root){\\n        if(root==null) return;\\n        \\n        //traverse for left\\n        fix(root.left);\\n        \\n        //check for mistake\\n        if(prev!=null&&root.val<prev.val){\\n            if(first==null) first=prev;\\n            second=root;\\n        }\\n        \\n        //update previous to be root\\n        prev=root;\\n        \\n        //traverse for right\\n        fix(root.right);\\n    }\\n    \\n    public void recoverTree(TreeNode root) {\\n        fix(root);\\n        \\n        //swap first and second\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194053,
                "title": "python-easy-and-understandable",
                "content": "```\\nimport math\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first = None\\n        sec = None\\n        prev = TreeNode(-math.inf)\\n        def check(root):\\n            nonlocal prev,first,sec\\n            if root==None:\\n                return\\n            check(root.left)\\n            if root.val<prev.val:\\n                if not first:\\n                    first = prev\\n                sec = root\\n            prev = root\\n            check(root.right)\\n        check(root)\\n        first.val,sec.val = sec.val,first.val\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nimport math\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first = None\\n        sec = None\\n        prev = TreeNode(-math.inf)\\n        def check(root):\\n            nonlocal prev,first,sec\\n            if root==None:\\n                return\\n            check(root.left)\\n            if root.val<prev.val:\\n                if not first:\\n                    first = prev\\n                sec = root\\n            prev = root\\n            check(root.right)\\n        check(root)\\n        first.val,sec.val = sec.val,first.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920369,
                "title": "python3-morris-in-order-traversal-generator-recover-binary-search-tree",
                "content": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        def morrisInOrder(root):\\n            while root:\\n                if not root.left:\\n                    yield root\\n                    root = root.right\\n                else:    \\n                    prev = root.left\\n                    while prev.right and prev.right != root:\\n                        prev = prev.right\\n                    if not prev.right:\\n                        prev.right = root\\n                        root = root.left\\n                    else:\\n                        yield root\\n                        prev.right = None\\n                        root = root.right\\n        prev, first, second = None, None, None\\n        for curr in morrisInOrder(root):\\n            if prev and prev.val > curr.val:\\n                if not first:\\n                    first = prev\\n                second = curr\\n            prev = curr\\n        first.val, second.val = second.val, first.val \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        def morrisInOrder(root):\\n            while root:\\n                if not root.left:\\n                    yield root\\n                    root = root.right\\n                else:    \\n                    prev = root.left\\n                    while prev.right and prev.right != root:\\n                        prev = prev.right\\n                    if not prev.right:\\n                        prev.right = root\\n                        root = root.left\\n                    else:\\n                        yield root\\n                        prev.right = None\\n                        root = root.right\\n        prev, first, second = None, None, None\\n        for curr in morrisInOrder(root):\\n            if prev and prev.val > curr.val:\\n                if not first:\\n                    first = prev\\n                second = curr\\n            prev = curr\\n        first.val, second.val = second.val, first.val \\n```",
                "codeTag": "Java"
            },
            {
                "id": 856474,
                "title": "commented-fully-explained",
                "content": "```\\n// There are two nodes not in their places, so one will be larger than the other, \\n// let\\'s say a is the larger node and b is the smaller node and both of them needs\\n// to be swapped in order to correct the binary search tree, so now, surely a is \\n// taking the place of a smaller number(b), so a will come earlier in the inorder\\n// traversal, so whenever we find a pair not following the non dec order in the \\n// inorder traversal, the first element is always the prev node. And to handle case\\n// when only the first occuring problematic pair needs to be sorted, we assign\\n// second to the current node as well, but if we a pair like this again, we will \\n// simply assign second to the current node as it is taking a place of a bigger node\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n// first points to first misplaced node and second points\\n// to the second one, prev points to the prev node in the\\n// inorder traversal.\\nTreeNode * first = NULL;\\nTreeNode * second = NULL;\\nTreeNode * prev = new TreeNode(INT_MIN);\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root);\\n        swap(first->val, second->val);   \\n    }\\n    \\n    void find(TreeNode * root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root->left);\\n        \\n        // in case we find inorder is not in non dec order, we assign first\\n        // as prev, we have talked about in brief earlier.\\n        if(prev->val > root->val && first ==NULL)\\n            first = prev;\\n        \\n        \\n        // we have not used else if here to avoid corner cases, whenever some\\n        // pair not following the non dec order occurs, we assign first and second\\n        // pointers to the nodes respectively, to handle the case where only both \\n        // of them are to be swapped. If we find some other node not following the \\n        // order, we will assign second to that node as this if condition will\\n        // satisfy for that as well.\\n        if(prev->val > root->val && first !=NULL)\\n            second = root;\\n        \\n        prev = root;   \\n        \\n        find(root->right);\\n        \\n        return;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// There are two nodes not in their places, so one will be larger than the other, \\n// let\\'s say a is the larger node and b is the smaller node and both of them needs\\n// to be swapped in order to correct the binary search tree, so now, surely a is \\n// taking the place of a smaller number(b), so a will come earlier in the inorder\\n// traversal, so whenever we find a pair not following the non dec order in the \\n// inorder traversal, the first element is always the prev node. And to handle case\\n// when only the first occuring problematic pair needs to be sorted, we assign\\n// second to the current node as well, but if we a pair like this again, we will \\n// simply assign second to the current node as it is taking a place of a bigger node\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n// first points to first misplaced node and second points\\n// to the second one, prev points to the prev node in the\\n// inorder traversal.\\nTreeNode * first = NULL;\\nTreeNode * second = NULL;\\nTreeNode * prev = new TreeNode(INT_MIN);\\n    \\n    void recoverTree(TreeNode* root) \\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root);\\n        swap(first->val, second->val);   \\n    }\\n    \\n    void find(TreeNode * root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        find(root->left);\\n        \\n        // in case we find inorder is not in non dec order, we assign first\\n        // as prev, we have talked about in brief earlier.\\n        if(prev->val > root->val && first ==NULL)\\n            first = prev;\\n        \\n        \\n        // we have not used else if here to avoid corner cases, whenever some\\n        // pair not following the non dec order occurs, we assign first and second\\n        // pointers to the nodes respectively, to handle the case where only both \\n        // of them are to be swapped. If we find some other node not following the \\n        // order, we will assign second to that node as this if condition will\\n        // satisfy for that as well.\\n        if(prev->val > root->val && first !=NULL)\\n            second = root;\\n        \\n        prev = root;   \\n        \\n        find(root->right);\\n        \\n        return;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543745,
                "title": "simple-and-efficient-java-solution-runs-in-1ms-in-order-traversal",
                "content": "```\\nclass Solution {\\n    private int preVal = Integer.MIN_VALUE;\\n    private TreeNode first;\\n    private TreeNode second;\\n    \\n    public void recoverTree(TreeNode root) {\\n        traverse(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if(root == null)\\n            return;\\n        \\n        traverse(root.left);\\n        \\n        if(preVal > root.val) second = root;\\n        if(second == null) first = root;\\n        preVal = root.val;\\n        \\n        traverse(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int preVal = Integer.MIN_VALUE;\\n    private TreeNode first;\\n    private TreeNode second;\\n    \\n    public void recoverTree(TreeNode root) {\\n        traverse(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if(root == null)\\n            return;\\n        \\n        traverse(root.left);\\n        \\n        if(preVal > root.val) second = root;\\n        if(second == null) first = root;\\n        preVal = root.val;\\n        \\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533030,
                "title": "java-simple-in-order-traversal-constant-space-with-detailed-explanation",
                "content": "When we meet BST, there are two features must be appeared in mind\\n1, in-order traversal is ascending\\n2, `root.left.val < root.val && root.right.val > root.val`, and recursively.\\n\\nThis question use first feature.\\n\\nIf we print the in-order array, correct BST\\'s picture will be a ascending line,\\nbut if we swap two node\\'s value, there will be two obviously point.\\n![image](https://assets.leetcode.com/users/yoha/image_1583660730.png)\\na is correct, b and c is two situation with swap.\\n```\\n    TreeNode pre = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    boolean one = false;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n\\t\\t// do swap\\n        int tmp = first.val;\\n        first.val = second.val;\\n        second.val = tmp;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (pre != null) {\\n            if (pre.val > root.val) {\\n                if (!one) {\\n                    first = pre;\\n                    one = true;\\n                }\\n                second = root;\\n            }\\n        }\\n        pre = root;\\n        inorder(root.right);\\n    }\\n```\\nAbove is recursion method, and you could use Stack to implement iterative method.",
                "solutionTags": [],
                "code": "```\\n    TreeNode pre = null;\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    boolean one = false;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n\\t\\t// do swap\\n        int tmp = first.val;\\n        first.val = second.val;\\n        second.val = tmp;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (pre != null) {\\n            if (pre.val > root.val) {\\n                if (!one) {\\n                    first = pre;\\n                    one = true;\\n                }\\n                second = root;\\n            }\\n        }\\n        pre = root;\\n        inorder(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256063,
                "title": "java-in-order-traversal-with-detailed-analysis-of-the-in-order-solution",
                "content": "There are several facts to know to solve this problem:\\nLet\\'s consider the in-order traversal of a normal bst, the sequence will be:\\n```\\n1 2 3 4 5 6\\n```\\nIf we swap any two nodes, like 2 and 5, the sequence can be:\\n```\\n1 [5] 3 4 [2] 6\\n```\\nSo how to detect the first node and the second node? We can keep checking that whether a node\\'s value is strictly larger than it\\'s predecessor\\'s value. If at some point this rule is broken, we know that there is some abnormal nodes. Let\\'s see when this will happen:\\nWhen we check 3, we will find 5 > 3. The rule is broken, and 5 is the **predecessor** of 3.\\nWhen we check 6, we will find 6 > 2. The rule is broken again, and 2 is the **predecessor** of 6.\\n\\nYou will find that no matter which nodes we swap, we can obey this rule to get the first and the second node that we need to swap them back. \\n\\nThere is another fact about how to keep track of the predecessor. For in-order traversal, we keep going left until there is no left child, then visit the node, and then visit right child. Thus, if the node choose to go left, there is no predecessor update. After the node visited itself and start going right, there should be a predecessor-update. \\n\\nAnd finally, according to these two facts, we can find the first & second node, with O(logn) space complexity and O(n) time complexity.\\n\\n```\\nclass Solution {\\n    TreeNode first = null, second = null, pred = null;\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void recover(TreeNode node) {\\n        if (node == null) return;\\n        recover(node.left);\\n        if (first == null && pred != null && pred.val > node.val) {\\n            first = pred;\\n        }\\n        if (first != null && pred.val > node.val) {\\n            second = node;\\n        }\\n        pred = node;\\n        recover(node.right);    \\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1 2 3 4 5 6\\n```\n```\\n1 [5] 3 4 [2] 6\\n```\n```\\nclass Solution {\\n    TreeNode first = null, second = null, pred = null;\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    private void recover(TreeNode node) {\\n        if (node == null) return;\\n        recover(node.left);\\n        if (first == null && pred != null && pred.val > node.val) {\\n            first = pred;\\n        }\\n        if (first != null && pred.val > node.val) {\\n            second = node;\\n        }\\n        pred = node;\\n        recover(node.right);    \\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244861,
                "title": "in-place-solution-with-explanation-44ms-and-28-4mb-beats-96-12-and-87-5-repectively",
                "content": "First of all, **Keep in mind there are only two elements place are wrong in BST**\\n\\nSo here are three different scenarios and its base solution for this problem:\\n1. One larger node locates at the left side of a subtree. try to find it, and store the larger node as ```largerNode```and its parent as ```tmpNode```. Swap the value of ```largerNode``` and ```tmpNode```.\\n2. One smaller node locates at the right side of a subtree. try to find it, and store the smaller node ```smallerNode``` and its parent as ```tmpNode```. Swap the value of ```smallerNode``` and ```tmpNode```.\\n3. Both 1 and 2 happens, swap ```largerNode``` and ```smallerNode```.\\n\\nBut the solution in 1 and 2 are not stable, obviously, so as 3. Considering BST [1,2,null,3]. after using current solution in case 1, the result BST is [2,1,null,3]. Recall, **only two elements place are wrong**. we need to thoroughly find every node which are larger than its parent or even higher - grandparent. But there are **Only two wrong placed elements**, image we reach TreeNode(5), and its left children or grandchildren are TreeNode(6), TreeNode(7), TreeNode(8). Swap the TreeNode(6) or TreeNode(7) cannot help us fix the BST, since TreeNode(8) is still larger than its grandparents. **Thus, for case 1, this reminder us we only need to save the largest node locates at left side of a subtree whose root has smaller value, the problem only could be solved by swapping the largest node and the subtree root (where the violation begins).** This also could be proven by contradiction, if this cannot fix BST for case 1, any other swap cannot as well.\\n\\nTo avoid of using any container, we only could solve it recursively, BFS or DFS. With above analysis, since we need to find the largest or smallest violation node exhaustively, DFS is the first choice. \\n\\nRecall above case 1-3 are highly depends on the given BST structure, our solution would need to try to find both ```largerNode``` and ```smallerNode```, and the make swap decision depends on whether ```largerNode``` and ```smallerNode``` is found after DFS finished.\\n\\n**Another DFS feature with BST is, the search order is predefined, left or right.** Assume left first, so that the search would firstly find ```largerNode``` and then ```smallerNode```. In each DFS, we also need to update the minimal node value and maximum node vaule to check the violation for current node, and more importantly, **find largeNode as larger as possible, find smallNode as smaller as possible, which violate BST feature**. \\n\\nWith above analysis, remaining issue is how to update search space in each DFS. Similarly, this also have three different scenarios:\\n1. No violation, using current node as a division point, search space for left children (curMinNode, curNode), search space for right childeren (curNode, curMaxNode)\\n2. Violate curMaxNode, which means the largeNode show at the left side of the subtree(or root). For left children, same search space as current one, due to this violation node may swap away, and we need to keep current maxNode smaller to narrow down the space for its left children. For right children, assume we may swap curNode with curMaxNode, so that the curNode becomes its grandparents, and curNode->right is its grandparent\\'s left grandchildren but its prarent\\'s right children, so that the search space is (curMaxNode, curNode)\\n3. Violate curMinNode, which means the smallNode show at the right side of the subtree (or root). Similar as 2, but with symmetry.\\n\\nAfter all, here is the solution:\\n\\n```\\nclass Solution {\\n    TreeNode* largeNode = nullptr;\\n    TreeNode* smallNode = nullptr; \\n    TreeNode* tmpNode = nullptr;\\n    \\n    void swapNodeValue(TreeNode* a, TreeNode* b) {\\n        if (!a || !b) return;\\n        int tVal = a->val;\\n        a->val = b->val;\\n        b->val = tVal;\\n        return;\\n    }\\n\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        dfs(root, nullptr, nullptr);\\n        if (largeNode && smallNode) {\\n            swapNodeValue(largeNode, smallNode);\\n        } else if (largeNode) {\\n            swapNodeValue(largeNode, tmpNode);\\n        } else if (smallNode) {\\n            swapNodeValue(smallNode, tmpNode);\\n        }\\n        return;\\n    }\\n    \\n    void dfs(TreeNode* node, TreeNode* minNode, TreeNode* maxNode) {\\n        if (node == nullptr) return;\\n\\t\\t// this is largeNode only if it is larger than its upper limit\\n        if (maxNode && node->val > maxNode->val) {\\n            if (!tmpNode) tmpNode = maxNode;\\n            if (!largeNode) largeNode = node;\\n            if (node->val > largeNode->val) largeNode = node;\\n            dfs(node->left, minNode, maxNode);\\n            dfs(node->right, maxNode, node);\\n            return;\\n        }\\n\\t\\t// this is smallNode only if it is larget than its lower limit\\n        if (minNode && node->val < minNode->val) {\\n            if (!tmpNode) tmpNode = minNode;\\n            if (!smallNode) smallNode = node;\\n            if (node->val < smallNode->val) smallNode = node;\\n            dfs(node->left, node, maxNode);\\n            dfs(node->right, minNode, maxNode);\\n            return;\\n        }\\n        dfs(node->left, minNode, node);\\n        dfs(node->right, node, maxNode);\\n        return;\\n    }\\n};\\n```\\n\\nWe only need to store ```tmpNode``` once for case 1 or case 2. When case 3 happens, we only need to swap ```largeNode``` and ```smallNode```, so that ```tmpNode```is not useful anymore.\\n\\nOverall, this is a good practice to solve tree problem using recursion, with the constant space challenge (stricktly speaking, function overheads also takes space in each recursion, I\\'d like to say it is IN-PLACE solution). It helps me a lot to utilize tree features and DFS in problem solving. Althought it is also my most failure submissions problem so far, but it feels really great when you finally solve it on your own **:)**\\n\\n",
                "solutionTags": [],
                "code": "```largerNode```\n```tmpNode```\n```largerNode```\n```tmpNode```\n```smallerNode```\n```tmpNode```\n```smallerNode```\n```tmpNode```\n```largerNode```\n```smallerNode```\n```largerNode```\n```smallerNode```\n```largerNode```\n```smallerNode```\n```largerNode```\n```smallerNode```\n```\\nclass Solution {\\n    TreeNode* largeNode = nullptr;\\n    TreeNode* smallNode = nullptr; \\n    TreeNode* tmpNode = nullptr;\\n    \\n    void swapNodeValue(TreeNode* a, TreeNode* b) {\\n        if (!a || !b) return;\\n        int tVal = a->val;\\n        a->val = b->val;\\n        b->val = tVal;\\n        return;\\n    }\\n\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        dfs(root, nullptr, nullptr);\\n        if (largeNode && smallNode) {\\n            swapNodeValue(largeNode, smallNode);\\n        } else if (largeNode) {\\n            swapNodeValue(largeNode, tmpNode);\\n        } else if (smallNode) {\\n            swapNodeValue(smallNode, tmpNode);\\n        }\\n        return;\\n    }\\n    \\n    void dfs(TreeNode* node, TreeNode* minNode, TreeNode* maxNode) {\\n        if (node == nullptr) return;\\n\\t\\t// this is largeNode only if it is larger than its upper limit\\n        if (maxNode && node->val > maxNode->val) {\\n            if (!tmpNode) tmpNode = maxNode;\\n            if (!largeNode) largeNode = node;\\n            if (node->val > largeNode->val) largeNode = node;\\n            dfs(node->left, minNode, maxNode);\\n            dfs(node->right, maxNode, node);\\n            return;\\n        }\\n\\t\\t// this is smallNode only if it is larget than its lower limit\\n        if (minNode && node->val < minNode->val) {\\n            if (!tmpNode) tmpNode = minNode;\\n            if (!smallNode) smallNode = node;\\n            if (node->val < smallNode->val) smallNode = node;\\n            dfs(node->left, node, maxNode);\\n            dfs(node->right, minNode, maxNode);\\n            return;\\n        }\\n        dfs(node->left, minNode, node);\\n        dfs(node->right, node, maxNode);\\n        return;\\n    }\\n};\\n```\n```tmpNode```\n```largeNode```\n```smallNode```\n```tmpNode```",
                "codeTag": "Java"
            },
            {
                "id": 223902,
                "title": "inorder-traversal-logical-thinking",
                "content": "> How do we detect swapped nodes?\\n> Inorder traversal of BST meets nodes in the sorted order - the swapped nodes break this rule.\\n\\n> We observe that 1 swap results in 1 or 2 decreasing flow\\n-  1 decreasing:\\ne.g. [1 2 3 4 5]\\nswap 2 and 3 to [1 3 2 4 5]\\n3 -> 2 decreasing -- the second to swap right after the first to swap\\n- 2 decreasing:\\ne.g. [1 2 3 4 5]\\nswap 2 and 4 to [1 4 3 2 5]\\n4 -> 3 decreasing\\n3 -> 2 decreasing -- the second to swap is the latter element of the second decreasing flow  \\n\\n****\\n> Scala\\n```\\n  var prevNode, fstToSwap, sndToSwap: TreeNode = _\\n\\n  def recoverTree(root: TreeNode): Unit = {\\n    prevNode = null\\n    fstToSwap = null\\n    sndToSwap = null\\n    \\n    inorderTraverse(root)\\n    \\n    val fstToSwapValue = fstToSwap.value\\n    fstToSwap.value = sndToSwap.value\\n    sndToSwap.value = fstToSwapValue\\n  }\\n  \\n  def inorderTraverse(root: TreeNode): Unit = {\\n    if (root != null) {\\n      inorderTraverse(root.left)\\n      \\n      if (prevNode != null && prevNode.value > root.value && fstToSwap == null) fstToSwap = prevNode\\n      if (prevNode != null && prevNode.value > root.value && fstToSwap != null) sndToSwap = root\\n\\n      prevNode = root\\n      \\n      inorderTraverse(root.right)\\n    }\\n  }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n  var prevNode, fstToSwap, sndToSwap: TreeNode = _\\n\\n  def recoverTree(root: TreeNode): Unit = {\\n    prevNode = null\\n    fstToSwap = null\\n    sndToSwap = null\\n    \\n    inorderTraverse(root)\\n    \\n    val fstToSwapValue = fstToSwap.value\\n    fstToSwap.value = sndToSwap.value\\n    sndToSwap.value = fstToSwapValue\\n  }\\n  \\n  def inorderTraverse(root: TreeNode): Unit = {\\n    if (root != null) {\\n      inorderTraverse(root.left)\\n      \\n      if (prevNode != null && prevNode.value > root.value && fstToSwap == null) fstToSwap = prevNode\\n      if (prevNode != null && prevNode.value > root.value && fstToSwap != null) sndToSwap = root\\n\\n      prevNode = root\\n      \\n      inorderTraverse(root.right)\\n    }\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 187755,
                "title": "go-solution",
                "content": "```\\nfunc Swap(x, y *TreeNode) {\\n    x.Val, y.Val = y.Val, x.Val\\n}\\n\\nfunc Inorder(c chan *TreeNode, root *TreeNode) {\\n    if root == nil {\\n        return\\n    }\\n    Inorder(c, root.Left)\\n    c <- root\\n    Inorder(c, root.Right)\\n}\\n\\nfunc recoverTree(root *TreeNode) {\\n    c := make(chan *TreeNode)\\n    go func() {\\n        Inorder(c, root)\\n        close(c)\\n    }()\\n\\n    var first, second *TreeNode\\n    prev := <-c\\n    for x := range c {\\n        if x.Val < prev.Val {\\n            if first == nil {\\n                first = prev\\n            } \\n            if first != nil {\\n                second = x\\n            }\\n        }\\n        prev = x\\n    }\\n    Swap(first, second)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc Swap(x, y *TreeNode) {\\n    x.Val, y.Val = y.Val, x.Val\\n}\\n\\nfunc Inorder(c chan *TreeNode, root *TreeNode) {\\n    if root == nil {\\n        return\\n    }\\n    Inorder(c, root.Left)\\n    c <- root\\n    Inorder(c, root.Right)\\n}\\n\\nfunc recoverTree(root *TreeNode) {\\n    c := make(chan *TreeNode)\\n    go func() {\\n        Inorder(c, root)\\n        close(c)\\n    }()\\n\\n    var first, second *TreeNode\\n    prev := <-c\\n    for x := range c {\\n        if x.Val < prev.Val {\\n            if first == nil {\\n                first = prev\\n            } \\n            if first != nil {\\n                second = x\\n            }\\n        }\\n        prev = x\\n    }\\n    Swap(first, second)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32582,
                "title": "simple-python-solution-with-real-o-1-space-by-using-morris-traversal-with-comments",
                "content": "\\n    def recoverTree(self, root):\\n        cur, prev, first, second, predec = root, None, None, None, None\\n        while cur:\\n            if cur.left is None:  # I have no left child so it's my turn\\n                if predec is not None and cur.val < predec.val:\\n                    if not first:\\n                        first = predec\\n                    second = cur\\n                predec = cur\\n                cur = cur.right  # After visit, go right\\n            else:\\n                # I need to find my predecessor and make me its right child\\n                # Second check in right is to make sure that I don't loop\\n                prev = cur.left\\n                while prev.right is not None and prev.right != cur:\\n                    prev = prev.right\\n                if prev.right is None:  # Not visited yet\\n                    prev.right = cur\\n                    cur = cur.left\\n                else:  # It's my turn\\n                    if predec is not None and cur.val < predec.val:\\n                        if not first:\\n                            first = predec\\n                        second = cur\\n                    predec = cur\\n                    # I remove the link after having visited\\n                    prev.right = None\\n                    cur = cur.right\\n        first.val, second.val = second.val, first.val",
                "solutionTags": [],
                "code": "\\n    def recoverTree(self, root):\\n        cur, prev, first, second, predec = root, None, None, None, None\\n        while cur:\\n            if cur.left is None:  # I have no left child so it's my turn\\n                if predec is not None and cur.val < predec.val:\\n                    if not first:\\n                        first = predec\\n                    second = cur\\n                predec = cur\\n                cur = cur.right  # After visit, go right\\n            else:\\n                # I need to find my predecessor and make me its right child\\n                # Second check in right is to make sure that I don't loop\\n                prev = cur.left\\n                while prev.right is not None and prev.right != cur:\\n                    prev = prev.right\\n                if prev.right is None:  # Not visited yet\\n                    prev.right = cur\\n                    cur = cur.left\\n                else:  # It's my turn\\n                    if predec is not None and cur.val < predec.val:\\n                        if not first:\\n                            first = predec\\n                        second = cur\\n                    predec = cur\\n                    # I remove the link after having visited\\n                    prev.right = None\\n                    cur = cur.right\\n        first.val, second.val = second.val, first.val",
                "codeTag": "Python3"
            },
            {
                "id": 32604,
                "title": "18ms-java-solution-with-in-order-traversal-and-sorting-o-nlogn-time-and-o-n-space",
                "content": "    public class Solution {\\n        public void recoverTree(TreeNode root) {\\n            // in-order traversal of treenodes, followed by sorting and reassignment of values\\n            List<TreeNode> inorder = inorder(root);\\n            List<Integer> inorderNumbers = new ArrayList<Integer>();\\n            for (TreeNode node : inorder) {\\n                inorderNumbers.add(node.val);\\n            }\\n            inorderNumbers.sort(null);\\n            for (int i = 0; i < inorder.size(); i++) {\\n                inorder.get(i).val = inorderNumbers.get(i);\\n            }\\n        }\\n        \\n        private List<TreeNode> inorder (TreeNode root) {\\n            List<TreeNode> result = new ArrayList<TreeNode>();\\n            if (root == null) {\\n                return result;\\n            }\\n            result.addAll(inorder(root.left));\\n            result.add(root);\\n            result.addAll(inorder(root.right));\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void recoverTree(TreeNode root) {\\n            // in-order traversal of treenodes, followed by sorting and reassignment of values\\n            List<TreeNode> inorder = inorder(root);\\n            List<Integer> inorderNumbers = new ArrayList<Integer>();\\n            for (TreeNode node : inorder) {\\n                inorderNumbers.add(node.val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32649,
                "title": "is-there-any-other-solution-which-doesn-t-apply-morris-traversal-to-satisfy-o-1-space-complexity",
                "content": "    // my solution is just applying the morris inorder traversal\\n    // O(2N) time complexity, O(1) space complexity\\n        \\n    TreeNode *first = NULL;\\n        TreeNode *second = NULL;\\n        TreeNode *previous = NULL;\\n        \\n        void recoverTree(TreeNode *root) {\\n            if (!root) return;\\n            previous = new TreeNode(INT_MIN);\\n            \\n            morris_inorder(root);\\n            int t = first->val;\\n            first->val = second->val;\\n            second->val = t;\\n        }\\n        \\n        void morris_inorder(TreeNode *root) {\\n            TreeNode *cur = root, *pre = NULL;\\n            \\n            while (cur) {\\n    \\t\\t    if (cur->left == NULL) {\\n    \\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t    if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t    previous = cur;\\n    \\t\\t\\t    cur = cur->right;\\n     \\t\\t    }\\n     \\t\\t    else {\\n     \\t\\t\\t    // find the predecessor\\n     \\t\\t\\t    pre = cur->left;\\n     \\t\\t\\t    while (pre->right && pre->right != cur)\\n     \\t\\t\\t\\t    pre = pre->right;\\n    \\n     \\t\\t\\t    if (pre->right == NULL) {\\n     \\t\\t\\t\\t    // set the backtrace link\\n     \\t\\t\\t\\t    pre->right = cur;\\n     \\t\\t\\t\\t    cur = cur->left;\\n     \\t\\t\\t    }\\n     \\t\\t\\t    else {\\n     \\t\\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t        if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t        previous = cur;\\n     \\t\\t\\t\\t    pre->right = NULL;\\n     \\t\\t\\t\\t    cur = cur->right;\\n     \\t\\t\\t    }\\n     \\t\\t    }\\n     \\t    }\\n        }",
                "solutionTags": [],
                "code": "    // my solution is just applying the morris inorder traversal\\n    // O(2N) time complexity, O(1) space complexity\\n        \\n    TreeNode *first = NULL;\\n        TreeNode *second = NULL;\\n        TreeNode *previous = NULL;\\n        \\n        void recoverTree(TreeNode *root) {\\n            if (!root) return;\\n            previous = new TreeNode(INT_MIN);\\n            \\n            morris_inorder(root);\\n            int t = first->val;\\n            first->val = second->val;\\n            second->val = t;\\n        }\\n        \\n        void morris_inorder(TreeNode *root) {\\n            TreeNode *cur = root, *pre = NULL;\\n            \\n            while (cur) {\\n    \\t\\t    if (cur->left == NULL) {\\n    \\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t    if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t    previous = cur;\\n    \\t\\t\\t    cur = cur->right;\\n     \\t\\t    }\\n     \\t\\t    else {\\n     \\t\\t\\t    // find the predecessor\\n     \\t\\t\\t    pre = cur->left;\\n     \\t\\t\\t    while (pre->right && pre->right != cur)\\n     \\t\\t\\t\\t    pre = pre->right;\\n    \\n     \\t\\t\\t    if (pre->right == NULL) {\\n     \\t\\t\\t\\t    // set the backtrace link\\n     \\t\\t\\t\\t    pre->right = cur;\\n     \\t\\t\\t\\t    cur = cur->left;\\n     \\t\\t\\t    }\\n     \\t\\t\\t    else {\\n     \\t\\t\\t        if (cur->val <= previous->val && !first) first = previous;\\n    \\t\\t\\t        if (cur->val <= previous->val && first) second = cur;\\n    \\t\\t\\t        previous = cur;\\n     \\t\\t\\t\\t    pre->right = NULL;\\n     \\t\\t\\t\\t    cur = cur->right;\\n     \\t\\t\\t    }\\n     \\t\\t    }\\n     \\t    }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3758168,
                "title": "java-solution-with-inorder-traversal-beats-100",
                "content": "# Intuition\\n-  We will traverse the tree in inorder fashion and check whether previous node had value less than the root.\\n- If yes, than note both of them.\\n- After the traversal we  will simply, swap both the nodes.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n) (Stack space for recursion)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode prev = null , first = null , sec = null;\\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first , sec);\\n        return;\\n    }\\n    private void swap (TreeNode a , TreeNode b){\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n    private void helper (TreeNode root){\\n        if(root == null)\\n        return;\\n\\n        helper(root.left);\\n\\n        if(prev != null && prev.val > root.val){\\n            if(first == null)\\n                first = prev;\\n            sec = root;\\n        }\\n\\n        prev = root;\\n\\n        helper(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode prev = null , first = null , sec = null;\\n    public void recoverTree(TreeNode root) {\\n        helper(root);\\n        swap(first , sec);\\n        return;\\n    }\\n    private void swap (TreeNode a , TreeNode b){\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n    private void helper (TreeNode root){\\n        if(root == null)\\n        return;\\n\\n        helper(root.left);\\n\\n        if(prev != null && prev.val > root.val){\\n            if(first == null)\\n                first = prev;\\n            sec = root;\\n        }\\n\\n        prev = root;\\n\\n        helper(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647453,
                "title": "easy-c-solution-inorder-efficient",
                "content": "# Intuition\\nSo the intuition here was that the inorder traversal of a binary search tree is always sorted . so if we find any element while traversing through the BST that it\\'s value is smaller than the previos node we visited we simple swap them until we traverse through the whole BST.\\n\\n# Approach\\nSo the basic approach here is maintaining four pointers previous , first, middle, last.\\ninitially the previous pointer holds the value of minimum integer value and others are null.\\nwhen we find the first elemnt we simply make it prev then if the value of root is less then previous means in inorder if the value is smaller of the enct elemnt while traversing through the bst it means it is not acceptaable and we will make it first violation into our code but that is not the end of the code , we keep traversing through the binary search tree to find the last violation and if we find last violation we simply swap first and last but if that is not the case we swap our first violation with middle elemnt whol violated the traversal.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity:O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private: \\n    TreeNode* prev;\\n    TreeNode* first;\\n    TreeNode* middle;\\n    TreeNode* last;\\n    private:\\n    void inorder( TreeNode* root){\\n        if(root==NULL) return;\\n        inorder( root->left);\\n        if( prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first = prev;\\n                middle = root;\\n            }\\n            else last = root;\\n        }\\n        prev = root;\\n        inorder(root-> right);\\n    }\\npublic:\\n\\n    void recoverTree(TreeNode* root) {\\n        first = middle = last = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n         if( first && last){\\n            swap(first -> val, last->val);\\n        }\\n        \\n        else if( first && middle ){\\n            swap(first->val, middle-> val);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private: \\n    TreeNode* prev;\\n    TreeNode* first;\\n    TreeNode* middle;\\n    TreeNode* last;\\n    private:\\n    void inorder( TreeNode* root){\\n        if(root==NULL) return;\\n        inorder( root->left);\\n        if( prev!=NULL && root->val < prev->val){\\n            if(first==NULL){\\n                first = prev;\\n                middle = root;\\n            }\\n            else last = root;\\n        }\\n        prev = root;\\n        inorder(root-> right);\\n    }\\npublic:\\n\\n    void recoverTree(TreeNode* root) {\\n        first = middle = last = NULL;\\n        prev = new TreeNode(INT_MIN);\\n        inorder(root);\\n         if( first && last){\\n            swap(first -> val, last->val);\\n        }\\n        \\n        else if( first && middle ){\\n            swap(first->val, middle-> val);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519166,
                "title": "pure-o-1-solution-using-morris-traversal",
                "content": "# Approach\\n1) Initialise the previous, start, middle, and end pointers with null.\\n2) Use Morris Traversal to perform an inorder traversal.\\n3) Keep the first and last numbers that are not in ascending sequence, and the middle element is the number next to the first.\\n4) Swap first and last if there is a second (final) descending element; otherwise, swap first and mid.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode* prev = NULL, *first = NULL, *mid = NULL, *last = NULL;\\n        TreeNode* cur = root;\\n        while(cur){\\n            if(!cur -> left){\\n                if(prev and cur -> val < prev -> val){\\n                    if(!first){\\n                        first = prev;\\n                        mid = cur;\\n                    }\\n                    else last = cur;\\n                }\\n                prev = cur;\\n                cur = cur -> right;\\n            }\\n            else{\\n                TreeNode* temp = cur -> left;\\n                while(temp -> right and temp -> right != cur) temp = temp -> right;\\n                if(!temp -> right){\\n                    temp -> right = cur;\\n                    cur = cur -> left;\\n                }\\n                else{\\n                    temp -> right = NULL;\\n                    if(prev and cur -> val < prev -> val){\\n                        if(!first){\\n                            first = prev;\\n                            mid = cur;\\n                        }\\n                        else last = cur;\\n                    }\\n                    prev = cur;\\n                    cur = cur -> right;\\n                }\\n            }\\n        }\\n        if(first and last) swap(first -> val, last -> val);\\n        else if(first and mid) swap(first -> val, mid -> val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        TreeNode* prev = NULL, *first = NULL, *mid = NULL, *last = NULL;\\n        TreeNode* cur = root;\\n        while(cur){\\n            if(!cur -> left){\\n                if(prev and cur -> val < prev -> val){\\n                    if(!first){\\n                        first = prev;\\n                        mid = cur;\\n                    }\\n                    else last = cur;\\n                }\\n                prev = cur;\\n                cur = cur -> right;\\n            }\\n            else{\\n                TreeNode* temp = cur -> left;\\n                while(temp -> right and temp -> right != cur) temp = temp -> right;\\n                if(!temp -> right){\\n                    temp -> right = cur;\\n                    cur = cur -> left;\\n                }\\n                else{\\n                    temp -> right = NULL;\\n                    if(prev and cur -> val < prev -> val){\\n                        if(!first){\\n                            first = prev;\\n                            mid = cur;\\n                        }\\n                        else last = cur;\\n                    }\\n                    prev = cur;\\n                    cur = cur -> right;\\n                }\\n            }\\n        }\\n        if(first and last) swap(first -> val, last -> val);\\n        else if(first and mid) swap(first -> val, mid -> val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187784,
                "title": "recover-binary-search-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this problem, we need to recover the binary search tree by fixing two nodes that were swapped by mistake. The solution to this problem can be achieved in two steps. In the first step, we will find the two nodes that are swapped, and in the second step, we will swap the nodes.\\n\\nTo find the two nodes that are swapped, we will use Morris Inorder Traversal. Morris Inorder Traversal is a space-optimized inorder traversal algorithm that allows us to traverse the tree using constant space.\\n\\nAlgorithm:\\n\\n1. Initialize two pointers current and pre to root.\\n2. While current is not null, do the following:\\na. If the current node does not have a left child, then move to the right child of the current node.\\nb. Else, find the inorder predecessor of the current node, i.e., the rightmost node in the left subtree of the current node.\\ni. If the right child of the inorder predecessor is null, then set it to the current node and move to the left child of the current node.\\nii. If the right child of the inorder predecessor is current, then set it to null, check if the pre node is not null, and if pre.val > current.val, then update the second node as current. Also, if pre is not null, then set pre.right to null. Finally, move to the right child of the current node.\\n3. If second node is not null, then swap the values of the first and second nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the number of nodes in the binary search tree.\\n\\n- Space complexity:\\nO(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first, second, pre = None, None, None\\n        current = root\\n        \\n        while current is not None:\\n            if current.left is None:\\n                if pre is not None and pre.val > current.val:\\n                    if first is None:\\n                        first = pre\\n                    second = current\\n                pre = current\\n                current = current.right\\n            else:\\n                node = current.left\\n                while node.right is not None and node.right != current:\\n                    node = node.right\\n                if node.right is None:\\n                    node.right = current\\n                    current = current.left\\n                else:\\n                    node.right = None\\n                    if pre is not None and pre.val > current.val:\\n                        if first is None:\\n                            first = pre\\n                        second = current\\n                    pre = current\\n                    current = current.right\\n        \\n        if first is not None and second is not None:\\n            first.val, second.val = second.val, first.val\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        first, second, pre = None, None, None\\n        current = root\\n        \\n        while current is not None:\\n            if current.left is None:\\n                if pre is not None and pre.val > current.val:\\n                    if first is None:\\n                        first = pre\\n                    second = current\\n                pre = current\\n                current = current.right\\n            else:\\n                node = current.left\\n                while node.right is not None and node.right != current:\\n                    node = node.right\\n                if node.right is None:\\n                    node.right = current\\n                    current = current.left\\n                else:\\n                    node.right = None\\n                    if pre is not None and pre.val > current.val:\\n                        if first is None:\\n                            first = pre\\n                        second = current\\n                    pre = current\\n                    current = current.right\\n        \\n        if first is not None and second is not None:\\n            first.val, second.val = second.val, first.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172286,
                "title": "c-brute-force-nlogn",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Depth-First Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(TreeNode* root, vector<int>& vec) {\\n        if(!root) return;\\n        dfs(root -> left, vec);\\n        vec.push_back(root -> val);\\n        dfs(root -> right, vec);\\n    }\\n    void in(TreeNode* root, vector<int>& vec, int &i) {\\n        if(!root) return;\\n        // i++;\\n        in(root -> left, vec, i);\\n        if(root -> val != vec[i]) root -> val = vec[i];\\n        i++;\\n        in(root -> right, vec, i);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> vec;\\n        dfs(root, vec);\\n        sort(vec.begin(), vec.end());\\n        int i = 0;\\n        in(root, vec, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(TreeNode* root, vector<int>& vec) {\\n        if(!root) return;\\n        dfs(root -> left, vec);\\n        vec.push_back(root -> val);\\n        dfs(root -> right, vec);\\n    }\\n    void in(TreeNode* root, vector<int>& vec, int &i) {\\n        if(!root) return;\\n        // i++;\\n        in(root -> left, vec, i);\\n        if(root -> val != vec[i]) root -> val = vec[i];\\n        i++;\\n        in(root -> right, vec, i);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        vector<int> vec;\\n        dfs(root, vec);\\n        sort(vec.begin(), vec.end());\\n        int i = 0;\\n        in(root, vec, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034824,
                "title": "solution-using-inorder-traversal-explained-in-details",
                "content": "# Intuition\\nA major property of Binary Search Tree is that if you get the inorder traversal of the tree, the resultant array will be sorted. Therefore, to solve this question, we can traverse the tree in an inorder fashion to obtain the sorted array which will have exactly two elements swapped. Then we can traverse the tree again and fix the swapped elements.\\n\\n# Approach\\nWe do an inorder traversal of the tree. Run a loop on the resultant array to obtain the swapped elements and save then in two globally declared variables. Traverse the tree again and swap the elements when when encountered!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int a, b;\\n\\n    void inorder(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    void swap(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        if (root->val == a)\\n            root->val = b;\\n        else if (root->val == b) \\n            root->val = a;\\n        \\n        swap(root->left);\\n        swap(root->right);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n\\n        for(int i = 0; i < v.size()-1; i++) {\\n            if (v[i] > v[i+1]) {\\n                a = v[i];\\n                break;\\n            }\\n        }\\n\\n        for(int i = v.size()-1; i > 0; i--) {\\n            if (v[i] < v[i-1]) {\\n                b = v[i];\\n                break;\\n            }\\n        }\\n\\n        swap(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int a, b;\\n\\n    void inorder(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    void swap(TreeNode*& root) {\\n        if (!root) \\n            return;\\n        \\n        if (root->val == a)\\n            root->val = b;\\n        else if (root->val == b) \\n            root->val = a;\\n        \\n        swap(root->left);\\n        swap(root->right);\\n    }\\n\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n\\n        for(int i = 0; i < v.size()-1; i++) {\\n            if (v[i] > v[i+1]) {\\n                a = v[i];\\n                break;\\n            }\\n        }\\n\\n        for(int i = v.size()-1; i > 0; i--) {\\n            if (v[i] < v[i-1]) {\\n                b = v[i];\\n                break;\\n            }\\n        }\\n\\n        swap(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796037,
                "title": "c-inorder-traversal",
                "content": "Please upvote if u like the solution\\n```\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root, vector<TreeNode*>& v) {\\n        if (root == NULL) return;\\n        inorderTraversal(root->left, v);\\n        v.push_back(root);\\n        inorderTraversal(root->right, v);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorderTraversal(root, v);\\n        pair<TreeNode*, TreeNode*> p{v[0], v.back()};\\n        for (int i = 1; i < v.size() - 1; ++ i ) {\\n            if (v[i]->val > v[i - 1]->val && v[i]->val > v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.first = v[i];\\n            if (v[i]->val < v[i - 1]->val && v[i]->val < v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.second = v[i];\\n        }\\n        swap(p.first->val, p.second->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root, vector<TreeNode*>& v) {\\n        if (root == NULL) return;\\n        inorderTraversal(root->left, v);\\n        v.push_back(root);\\n        inorderTraversal(root->right, v);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorderTraversal(root, v);\\n        pair<TreeNode*, TreeNode*> p{v[0], v.back()};\\n        for (int i = 1; i < v.size() - 1; ++ i ) {\\n            if (v[i]->val > v[i - 1]->val && v[i]->val > v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.first = v[i];\\n            if (v[i]->val < v[i - 1]->val && v[i]->val < v[i + 1]->val && v[i - 1]->val < v[i + 1]->val) p.second = v[i];\\n        }\\n        swap(p.first->val, p.second->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674879,
                "title": "inorder-traversal-best-explanation-easy-java",
                "content": "\\n#### **Explanation:**\\nif two values are swapped then its inorder will be something like this\\n 2 3 4 **8** 6 7 **5**\\n\\nin this case \\n  - first element will always be greater than its next element (8>6)\\n  - second element will always be lesser than its prev element (5<7)\\n\\nusing this, we can mark first and second element during inorder traversal.\\nand then we will swap the value of these two nodes.\\n\\n#### **Solution:**\\n\\n```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=new TreeNode(Integer.MIN_VALUE);\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        \\n\\t\\t// swap values\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n\\t\\t\\n        //mark first node\\n        if(first==null && prev.val>root.val)\\n            first=prev;\\n\\t\\t\\t\\n\\t\\t// mark second node\\n        if(first!=null && prev.val>root.val)\\n            second=root;\\n        \\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode first=null;\\n    TreeNode second=null;\\n    TreeNode prev=new TreeNode(Integer.MIN_VALUE);\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        \\n\\t\\t// swap values\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n\\t\\t\\n        //mark first node\\n        if(first==null && prev.val>root.val)\\n            first=prev;\\n\\t\\t\\t\\n\\t\\t// mark second node\\n        if(first!=null && prev.val>root.val)\\n            second=root;\\n        \\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668048,
                "title": "c-highly-commented-code-recursive-and-morris-both-free-meme",
                "content": "For complexity analysis and other stuff, **please** go [here](https://garmadon.notion.site/Recover-Binary-Search-Tree-f6bf43525e5a4a66be4c875e4740385d).\\n\\n**Recursive inorder traversal way**\\n```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Recursive inorder traversal to find the anomaly\\nvoid inorder(TreeNode* root)\\n{\\n    if(root != NULL)\\n    {\\n        inorder(root->left);\\n        \\n        //if this isn\\'t the first node you\\'re checking \\n        //and it\\'s value is less than prevNode, then \\n        //something\\'s fishy!\\n        if(prevNode != NULL and prevNode->val > root->val)\\n        {\\n            //if you haven\\'t found the first anomaly, then this is it!\\n            if(firstNode == NULL)\\n            firstNode = prevNode;\\n            \\n            //the current element may also be the anomaly\\n            secondNode = root;\\n        }\\n\\n        //update prevNode with the current node\\n        prevNode = root;\\n\\n        inorder(root->right);\\n    }\\n}\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n```\\n\\n**Morris Inorder traversal way**\\n```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n\\n//-------------------------------\\n\\n//Inorder using Morris Traversal\\nvoid inorder(TreeNode* root) \\n{\\n    //Initialise a pointer to traverse the tree\\n    TreeNode* curr = root;\\n\\n    while(curr != NULL)\\n    {\\n        //if there\\'s no left subtree, all you need to do is...\\n        if(curr->left == NULL)\\n        {\\n            //...find anomalies and...\\n            findAnomaly(curr);\\n            //traverse the right subtree.\\n            curr = curr->right;\\n        }\\n        //But if there is a left subtree,\\n        else\\n        {\\n            //Create a new pointer on left subtree\\'s root, \\n            TreeNode* findRight = curr->left;\\n\\n            //and go to the extreme right, until you find NULL or \\n            //a thread (link) to curr\\n            while(findRight->right != NULL and findRight->right != curr)\\n            {\\n                findRight = findRight->right;\\n            }\\n\\n            //If the extreme right is a NULL, create a thread to curr, \\n            //because that\\'s where we\\'ll go after this subtree is traversed\\n            if(findRight->right == NULL)\\n            {\\n                //Create the thread (link) to curr\\n                findRight->right = curr;\\n                //Now curr can traverse the left subtree (safely, lol)\\n                curr = curr->left;\\n            }\\n            //If the extreme right was a link to curr, \\n            //the left subtree has already been visited\\n            else \\n            {\\n                //So remove the link to curr \\n                findRight->right = NULL;\\n                //Find anomalies\\n                findAnomaly(curr);\\n                //And start traversing the right subtree\\n                curr = curr->right;\\n            }\\n        }\\n    }        \\n}\\n\\nvoid findAnomaly(TreeNode* root)\\n{\\n    //if this isn\\'t the first node you\\'re checking \\n    //and it\\'s value is less than prevNode, then \\n    //something\\'s fishy!\\n    if(prevNode != NULL and prevNode->val > root->val)\\n    {\\n        //if you haven\\'t found the first anomaly, then this is it!\\n        if(firstNode == NULL)\\n        firstNode = prevNode;\\n        \\n        //the current element may also be the anomaly\\n        secondNode = root;\\n    }\\n\\n    //update prevNode with the current node\\n    prevNode = root;\\n}\\n```\\n\\nFREE MEME\\n![image](https://assets.leetcode.com/users/images/9f989468-842e-4389-a3b0-05ba669e6e6e_1665049640.0128303.png)\\n\\n*Don\\'t you illiterate people forget to upvote!*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Recursive inorder traversal to find the anomaly\\nvoid inorder(TreeNode* root)\\n{\\n    if(root != NULL)\\n    {\\n        inorder(root->left);\\n        \\n        //if this isn\\'t the first node you\\'re checking \\n        //and it\\'s value is less than prevNode, then \\n        //something\\'s fishy!\\n        if(prevNode != NULL and prevNode->val > root->val)\\n        {\\n            //if you haven\\'t found the first anomaly, then this is it!\\n            if(firstNode == NULL)\\n            firstNode = prevNode;\\n            \\n            //the current element may also be the anomaly\\n            secondNode = root;\\n        }\\n\\n        //update prevNode with the current node\\n        prevNode = root;\\n\\n        inorder(root->right);\\n    }\\n}\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n```\n```\\n//Global variables\\nTreeNode* firstNode = NULL;\\nTreeNode* secondNode = NULL;\\nTreeNode* prevNode = NULL;\\n\\n//Program starts here\\nvoid recoverTree(TreeNode* root) \\n{\\n    //edge case - if 0 or 1 elements exist, return\\n    if(root == NULL or (root->left == NULL and root->right == NULL))\\n        return;        \\n\\n    //Search the BST using inorder traversal\\n    inorder(root);\\n\\n    //if there actually exists an anomaly... \\n    if(firstNode and secondNode)\\n        //...fix it\\n        swap(firstNode->val, secondNode->val);\\n}\\n\\n//-------------------------------\\n\\n//Inorder using Morris Traversal\\nvoid inorder(TreeNode* root) \\n{\\n    //Initialise a pointer to traverse the tree\\n    TreeNode* curr = root;\\n\\n    while(curr != NULL)\\n    {\\n        //if there\\'s no left subtree, all you need to do is...\\n        if(curr->left == NULL)\\n        {\\n            //...find anomalies and...\\n            findAnomaly(curr);\\n            //traverse the right subtree.\\n            curr = curr->right;\\n        }\\n        //But if there is a left subtree,\\n        else\\n        {\\n            //Create a new pointer on left subtree\\'s root, \\n            TreeNode* findRight = curr->left;\\n\\n            //and go to the extreme right, until you find NULL or \\n            //a thread (link) to curr\\n            while(findRight->right != NULL and findRight->right != curr)\\n            {\\n                findRight = findRight->right;\\n            }\\n\\n            //If the extreme right is a NULL, create a thread to curr, \\n            //because that\\'s where we\\'ll go after this subtree is traversed\\n            if(findRight->right == NULL)\\n            {\\n                //Create the thread (link) to curr\\n                findRight->right = curr;\\n                //Now curr can traverse the left subtree (safely, lol)\\n                curr = curr->left;\\n            }\\n            //If the extreme right was a link to curr, \\n            //the left subtree has already been visited\\n            else \\n            {\\n                //So remove the link to curr \\n                findRight->right = NULL;\\n                //Find anomalies\\n                findAnomaly(curr);\\n                //And start traversing the right subtree\\n                curr = curr->right;\\n            }\\n        }\\n    }        \\n}\\n\\nvoid findAnomaly(TreeNode* root)\\n{\\n    //if this isn\\'t the first node you\\'re checking \\n    //and it\\'s value is less than prevNode, then \\n    //something\\'s fishy!\\n    if(prevNode != NULL and prevNode->val > root->val)\\n    {\\n        //if you haven\\'t found the first anomaly, then this is it!\\n        if(firstNode == NULL)\\n        firstNode = prevNode;\\n        \\n        //the current element may also be the anomaly\\n        secondNode = root;\\n    }\\n\\n    //update prevNode with the current node\\n    prevNode = root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464305,
                "title": "java-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode a;\\n    TreeNode b;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n        inorder(root.left);\\n        if (root.val < prev.val && a == null) {\\n            a = prev;\\n            b = root;\\n        } else if (root.val < prev.val && a != null) {\\n            b = root;\\n        }\\n        prev = root;\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode a;\\n    TreeNode b;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n        inorder(root.left);\\n        if (root.val < prev.val && a == null) {\\n            a = prev;\\n            b = root;\\n        } else if (root.val < prev.val && a != null) {\\n            b = root;\\n        }\\n        prev = root;\\n        inorder(root.right);\\n    }\\n\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394811,
                "title": "c-o-n-time-o-1-space",
                "content": "* Assume we have been given a sorted array where only 2 elements are swapped and the array then becomes unsorted.\\n\\n* How to find the Two swapped elements ?? \\n\\n* We keep traversing the array and when the previous element becomes greater than next element, we can say there is a violation. **prev > next** and we store the index in some variable.\\n\\n* And When at some point in array , next violation occurs we store that position in some other variable.\\n\\n* In BST this behaviour can be achieved by keeping a `prev` pointer just behind the `root` pointer and checking the **violation condition**.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode *f  = nullptr , *s = nullptr , *prev = nullptr ;\\n    void solve(TreeNode * root){\\n        if(!root) return ;\\n        solve(root->left) ;\\n        if(!prev) prev = root ;\\n        else{\\n            if(prev ->val > root->val){\\n                if(!f) f = prev ;\\n                s = root ;\\n            }\\n        }\\n        prev = root ;\\n        \\n        solve(root->right) ;\\n        \\n    }\\n    void recoverTree(TreeNode* root) {\\n        solve(root) ;\\n        swap(f->val,s->val) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *f  = nullptr , *s = nullptr , *prev = nullptr ;\\n    void solve(TreeNode * root){\\n        if(!root) return ;\\n        solve(root->left) ;\\n        if(!prev) prev = root ;\\n        else{\\n            if(prev ->val > root->val){\\n                if(!f) f = prev ;\\n                s = root ;\\n            }\\n        }\\n        prev = root ;\\n        \\n        solve(root->right) ;\\n        \\n    }\\n    void recoverTree(TreeNode* root) {\\n        solve(root) ;\\n        swap(f->val,s->val) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346135,
                "title": "c-in-order-traversal-solution",
                "content": "1. Do the inorder traversal and store the the value in inorder.\\n2. sort the vector in increasing order, because BST inorder traversal is increasing.\\n3. Traverse the tree in inorder again, but this time change the value of node according to previously sorted array.\\n```c++\\nclass Solution {\\npublic:\\n\\t//This function will do the inorder traversal and store the value in vector v.\\n    void makeTree(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        makeTree(root->left, v);\\n        v.push_back(root->val);\\n        makeTree(root->right, v);\\n    }\\n\\t//This function will change the value of old given BST according to sorted data value.\\n    void changeNodeVal(TreeNode* root, vector<int>::iterator& it){\\n        if(!root) return;\\n        changeNodeVal(root->left, it);\\n        root->val = *it; it++;\\n        changeNodeVal(root->right, it);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        makeTree(root, v);\\n        sort(v.begin(), v.end());\\n\\t\\t//creating & Passing vector iterator to the function so that we won\\'t lose the track.\\n        vector<int>::iterator it = v.begin();\\n        changeNodeVal(root, it);\\n        return;\\n    }\\n};\\n```\\n\\nIf you have any doubt or optimization, comment below.\\n**Upvote if found useful. plz :)**\\nThanks, have a nice day!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n\\t//This function will do the inorder traversal and store the value in vector v.\\n    void makeTree(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        makeTree(root->left, v);\\n        v.push_back(root->val);\\n        makeTree(root->right, v);\\n    }\\n\\t//This function will change the value of old given BST according to sorted data value.\\n    void changeNodeVal(TreeNode* root, vector<int>::iterator& it){\\n        if(!root) return;\\n        changeNodeVal(root->left, it);\\n        root->val = *it; it++;\\n        changeNodeVal(root->right, it);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        makeTree(root, v);\\n        sort(v.begin(), v.end());\\n\\t\\t//creating & Passing vector iterator to the function so that we won\\'t lose the track.\\n        vector<int>::iterator it = v.begin();\\n        changeNodeVal(root, it);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345652,
                "title": "java-easy-understandable",
                "content": "```\\nclass Solution {\\n\\tTreeNode first = null;\\n\\tTreeNode second = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tinOrder(root);\\n\\t\\tif (first != null && second != null) {\\n\\t\\t\\tint temp = first.val;\\n\\t\\t\\tfirst.val = second.val;\\n\\t\\t\\tsecond.val = temp;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void inOrder(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tinOrder(root.left);\\n\\t\\tif (prev != null && root.val < prev.val) {\\n\\t\\t\\tif (first == null) {\\n\\t\\t\\t\\tfirst = prev;\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprev = root;\\n\\t\\tinOrder(root.right);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tTreeNode first = null;\\n\\tTreeNode second = null;\\n\\tTreeNode prev = null;\\n\\n\\tpublic void recoverTree(TreeNode root) {\\n\\t\\tinOrder(root);\\n\\t\\tif (first != null && second != null) {\\n\\t\\t\\tint temp = first.val;\\n\\t\\t\\tfirst.val = second.val;\\n\\t\\t\\tsecond.val = temp;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void inOrder(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tinOrder(root.left);\\n\\t\\tif (prev != null && root.val < prev.val) {\\n\\t\\t\\tif (first == null) {\\n\\t\\t\\t\\tfirst = prev;\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsecond = root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprev = root;\\n\\t\\tinOrder(root.right);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312758,
                "title": "java-optimizing-from-o-n-extra-space-to-o-1-excluding-call-stack",
                "content": "The question asks us to swap two values in a BST to make it valid.\\n##### But how do we know which elements are to be swapped?\\nAs we know the inorder traversal of a BST is in ascending order. We need to swap the first greatest element with the last smallest element.\\nFor eg. If we have our inorder traversal as: 5 2 3 4 1, we need to swap 5 and 1 such that 5 > 2 (first greatest element) and 4 > 1 (last smallest element)\\n\\nA very straight-forward approach will be storing the inorder traversal of the invalid BST provided to us in a List and then checking which elements are to be swapped.\\n\\n### Approach: \\n\\n```\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        getInorderList(root, list);\\n\\n        int i = 1;\\n        Integer first = null, second = null; \\n\\n        // Getting the first largest element and last smallest element\\n        while (i < list.size()) {\\n            if (first == null && list.get(i - 1) > list.get(i))\\n                first = list.get(i - 1);\\n            if (first != null && list.get(i - 1) > list.get(i))\\n                second = list.get(i);\\n            \\n            i++;\\n        }\\n\\n        swapValues(root, first, second);\\n    }\\n    \\n    public void getInorderList(TreeNode root, List<Integer> list) {\\n        if (root == null)\\n            return;\\n\\n        getInorderList(root.left, list);\\n        list.add(root.val);\\n        getInorderList(root.right, list);\\n    }\\n\\n    // Swapping the values of the two nodes in BST\\n    public void swapValues(TreeNode root, Integer num1, Integer num2) {\\n        if (root == null)\\n            return;\\n\\n        if (root.val == num1) \\n            root.val = num2;\\n        else if (root.val == num2)\\n            root.val = num1;\\n\\n        swapValues(root.left, num1, num2);\\n        swapValues(root.right, num1, num2);\\n    }\\n```\\n\\t\\nThis approach is time consuming and it uses extra O(n) space, to further optimize it, we can directly keep track of first and second nodes to be swapped while inorder traversing.\\n\\n### Optimized Approach:\\n\\n```\\n    // First and second nodes\\'s values are to be swapped\\n    // Prev is used to compare current node to previous node\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tinorder(root);\\n\\n        // Swapping the values\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        // If first isn\\'t assigned we will make first equals to the greater value (prev)\\n        // If first is assigned we keep updating second to the smaller value (root)\\n        if (first == null && prev.val > root.val)\\n            first = prev;\\n        if (first != null && prev.val > root.val)\\n            second = root;\\n\\n        prev = root;\\n\\n        inorder(root.right);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        getInorderList(root, list);\\n\\n        int i = 1;\\n        Integer first = null, second = null; \\n\\n        // Getting the first largest element and last smallest element\\n        while (i < list.size()) {\\n            if (first == null && list.get(i - 1) > list.get(i))\\n                first = list.get(i - 1);\\n            if (first != null && list.get(i - 1) > list.get(i))\\n                second = list.get(i);\\n            \\n            i++;\\n        }\\n\\n        swapValues(root, first, second);\\n    }\\n    \\n    public void getInorderList(TreeNode root, List<Integer> list) {\\n        if (root == null)\\n            return;\\n\\n        getInorderList(root.left, list);\\n        list.add(root.val);\\n        getInorderList(root.right, list);\\n    }\\n\\n    // Swapping the values of the two nodes in BST\\n    public void swapValues(TreeNode root, Integer num1, Integer num2) {\\n        if (root == null)\\n            return;\\n\\n        if (root.val == num1) \\n            root.val = num2;\\n        else if (root.val == num2)\\n            root.val = num1;\\n\\n        swapValues(root.left, num1, num2);\\n        swapValues(root.right, num1, num2);\\n    }\\n```\n```\\n    // First and second nodes\\'s values are to be swapped\\n    // Prev is used to compare current node to previous node\\n    TreeNode first = null;\\n    TreeNode second = null;\\n    TreeNode prev = new TreeNode(Integer.MIN_VALUE);\\n\\n    public void recoverTree(TreeNode root) {\\n\\t\\tinorder(root);\\n\\n        // Swapping the values\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n    \\n    public void inorder(TreeNode root) {\\n        if (root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        // If first isn\\'t assigned we will make first equals to the greater value (prev)\\n        // If first is assigned we keep updating second to the smaller value (root)\\n        if (first == null && prev.val > root.val)\\n            first = prev;\\n        if (first != null && prev.val > root.val)\\n            second = root;\\n\\n        prev = root;\\n\\n        inorder(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086394,
                "title": "c-inorder",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = NULL;\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(!first && prev && prev->val >= root->val) first = prev;\\n        if(first && prev->val >= root->val) second = root;\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        int temp = first->val;\\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n};\\n// please upvote if you like\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = NULL;\\n    TreeNode* first = NULL;\\n    TreeNode* second = NULL;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        if(!first && prev && prev->val >= root->val) first = prev;\\n        if(first && prev->val >= root->val) second = root;\\n        prev = root;\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        int temp = first->val;\\n        first->val = second->val;\\n        second->val = temp;\\n    }\\n};\\n// please upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989317,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```\\n\\n***Python***\\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```\\n\\n***JavaScript***\\n```\\nvar recoverTree = function(root) {\\n    let pre = null, n1 = null, n2 = null\\n    \\n    const dfs = (root) => {\\n        if (!root) return\\n        dfs(root.left)\\n        if (pre && pre.val > root.val) {\\n            n2 = root\\n            if (!n1) n1 = pre\\n        }\\n        pre = root\\n        dfs(root.right)\\n    }\\n    \\n    dfs(root)\\n    swap(n1, n2)\\n};\\n\\nconst swap = (n1, n2) => [n1.val, n2.val] = [n2.val, n1.val]\\n```\\n\\n***Kotlin***\\n```\\n  class Solution {\\n\\n  fun recoverTree(root: TreeNode?): Unit {\\n    var first: TreeNode? = null\\n    var second: TreeNode? = null\\n    var pre: TreeNode = TreeNode(Int.MIN_VALUE)\\n\\n    fun traverse(node: TreeNode?){\\n        if (node == null) return\\n        traverse(node.left)\\n\\n        if (first == null && pre.`val` > node.`val`){\\n            first = pre\\n        }\\n        if (first != null && pre.`val` > node.`val`){\\n            second = node\\n        }\\n        pre = node\\n\\n        traverse(node.right)\\n    }\\n    traverse(root)\\n    val temp = first!!.`val`\\n    first!!.`val` = second!!.`val`\\n    second!!.`val` = temp\\n\\t}\\n\\t}\\n```\\n\\n***Swift***\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null, first = null, second = null;\\n\\n    public void recoverTree(TreeNode root) {\\n        evalSwappedNodes(root);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n    }\\n\\n    private void evalSwappedNodes(TreeNode curr) {\\n        if (curr == null)\\n            return;\\n        evalSwappedNodes(curr.left);\\n        if (prev != null && prev.val > curr.val) {\\n            if (first == null)\\n                first = prev;\\n            second = curr;\\n        }\\n        prev = curr;\\n        evalSwappedNodes(curr.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* firstMistake, *secondMistake, *pre;\\n\\tvoid recoverTree(TreeNode* root) {\\n\\t\\tpre = new TreeNode(INT_MIN);\\n\\t\\tinorder(root);\\n\\t\\tswap(firstMistake->val, secondMistake->val);\\n\\t}\\n\\n\\tvoid inorder(TreeNode* root) {\\n\\t\\tif(root == nullptr) \\n\\t\\t\\treturn;\\n\\n\\t\\tinorder(root->left);\\n\\n\\t\\tif(firstMistake == nullptr && root->val < pre->val)\\n\\t\\t\\tfirstMistake = pre;\\n\\t\\tif(firstMistake != nullptr && root->val < pre->val)\\n\\t\\t\\tsecondMistake = root;\\n\\t\\tpre = root;\\n\\n\\t\\tinorder(root->right);\\n\\t}\\n};\\n```\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        in_order = []\\n        def inOrder(node):\\n            if node is None:\\n                return\\n            inOrder(node.left)\\n            in_order.append(node)\\n            inOrder(node.right)\\n        \\n        inOrder(root)\\n\\n        sorted_order = sorted(in_order, key=lambda x:x.val)\\n        for i in range(len(in_order)):\\n            if in_order[i] != sorted_order[i]:\\n                in_order[i].val, sorted_order[i].val = sorted_order[i].val, in_order[i].val\\n                return\\n```\n```\\nvar recoverTree = function(root) {\\n    let pre = null, n1 = null, n2 = null\\n    \\n    const dfs = (root) => {\\n        if (!root) return\\n        dfs(root.left)\\n        if (pre && pre.val > root.val) {\\n            n2 = root\\n            if (!n1) n1 = pre\\n        }\\n        pre = root\\n        dfs(root.right)\\n    }\\n    \\n    dfs(root)\\n    swap(n1, n2)\\n};\\n\\nconst swap = (n1, n2) => [n1.val, n2.val] = [n2.val, n1.val]\\n```\n```\\n  class Solution {\\n\\n  fun recoverTree(root: TreeNode?): Unit {\\n    var first: TreeNode? = null\\n    var second: TreeNode? = null\\n    var pre: TreeNode = TreeNode(Int.MIN_VALUE)\\n\\n    fun traverse(node: TreeNode?){\\n        if (node == null) return\\n        traverse(node.left)\\n\\n        if (first == null && pre.`val` > node.`val`){\\n            first = pre\\n        }\\n        if (first != null && pre.`val` > node.`val`){\\n            second = node\\n        }\\n        pre = node\\n\\n        traverse(node.right)\\n    }\\n    traverse(root)\\n    val temp = first!!.`val`\\n    first!!.`val` = second!!.`val`\\n    second!!.`val` = temp\\n\\t}\\n\\t}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(h), where h is the height of the binary tree.\\n\\n    private var first: TreeNode?\\n    private var second: TreeNode?\\n    private var prev = TreeNode(Int.min)\\n\\n    \\n    func recoverTree(_ root: TreeNode?) {\\n        traverse(root)\\n\\n        guard let first = first, let second = second else { return }\\n\\n        let tmp = first.val\\n        first.val = second.val\\n        second.val = tmp\\n    }\\n\\n\\n    private func traverse(_ root: TreeNode?) {\\n        guard let root = root else { return }\\n        traverse(root.left)\\n\\n        if first == nil, prev.val >= root.val { first = prev }\\n        if first != nil, prev.val >= root.val { second = root }\\n        prev = root\\n\\n        traverse(root.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963268,
                "title": "c-o-1-space-solution-w-full-explanations",
                "content": "**Case 1**: When both faulty node are not consecutive then swap( a with c) . Because bigger value must have \\ngone to array starting(a ) and smaller value(c) must have come to array ending side.\\n{ ![image](https://assets.leetcode.com/users/images/e3288207-2d6c-4d1f-ab40-80b282c16ada_1650358332.8541582.png)\\n\\n**Case 2**: When both faulty nodes are consecutive , all you need to do is swap both nodes value.\\n![image](https://assets.leetcode.com/users/images/56bacd50-4531-404a-8ecb-358711053a92_1650358332.8427744.png)\\t\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t//first and second fault in an inorder sorted arrray\\n\\t\\tTreeNode *f=NULL,*s=NULL;\\n\\t\\tTreeNode *prev=new TreeNode(INT_MIN);\\n\\t\\tvoid help(TreeNode *root,TreeNode *parent)\\n\\t\\t{\\n\\t\\t\\tif(root){\\n\\t\\t\\t\\thelp(root->left,root);\\n\\t\\t\\t\\tif(root->val<prev->val){\\n\\t\\t\\t\\t\\tif(f==s)\\n\\t\\t\\t\\t\\t\\tf=prev;\\n\\t\\t\\t\\t\\t\\ts=root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\ts=root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=root;\\n\\t\\t\\t\\thelp(root->right,root);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid recoverTree(TreeNode* root) {\\n\\t\\t\\thelp(root,nullptr);\\n\\t\\t\\tswap(f->val,s->val);\\n\\t\\t}\\n\\t};\\n\\t\\nPlease **Upvote** IF It was **helpful** !\\t",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//first and second fault in an inorder sorted arrray\\n\\t\\tTreeNode *f=NULL,*s=NULL;\\n\\t\\tTreeNode *prev=new TreeNode(INT_MIN);\\n\\t\\tvoid help(TreeNode *root,TreeNode *parent)\\n\\t\\t{\\n\\t\\t\\tif(root){\\n\\t\\t\\t\\thelp(root->left,root);\\n\\t\\t\\t\\tif(root->val<prev->val){\\n\\t\\t\\t\\t\\tif(f==s)\\n\\t\\t\\t\\t\\t\\tf=prev;\\n\\t\\t\\t\\t\\t\\ts=root;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1963094,
                "title": "python-inorder-solution-very-simple",
                "content": "We first get all the contents of a input BST using inorder traversal and store the contents in the list named as \"dfs\".\\n\\nIf you have noticed, then you would know that the inorder traversal of a BST is always sorted. So inorder to recover our original(correct) BST, we need to sort the list dfs.\\nNow we have to change the values of input BST. i.e we have to insert the sorted values into the tree. We do this by using same inorder travesal.\\nAnd all the stuff is done. No fancy alogirthm.Just 2 inorder traversal. \\n\\n(You could also avoid writing the same inorder function twice by passing the two differnt smaller functions for getting and inserting. refer to the first comment. Thanks to Tom.)\\n\\n```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        def inorder(root):\\n            \\n            if not root: return root\\n            inorder(root.left)\\n            dfs.append(root.val)\\n            inorder(root.right)\\n            \\n            \\n        inorder(root)\\n        dfs.sort()\\n        \\n        def inorder2(root):\\n            if not root: return root\\n            inorder2(root.left)\\n            root.val = dfs.pop(0)\\n            inorder2(root.right)\\n        \\n        inorder2(root)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\ndef recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        def inorder(root):\\n            \\n            if not root: return root\\n            inorder(root.left)\\n            dfs.append(root.val)\\n            inorder(root.right)\\n            \\n            \\n        inorder(root)\\n        dfs.sort()\\n        \\n        def inorder2(root):\\n            if not root: return root\\n            inorder2(root.left)\\n            root.val = dfs.pop(0)\\n            inorder2(root.right)\\n        \\n        inorder2(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1962956,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    vector<TreeNode*>t;\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        t.push_back(root);\\n        inorder(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        TreeNode *first,*mid,*last;\\n        first=mid=last=NULL;\\n        for(int i=0;i<t.size()-1;i++)\\n        {\\n            if(!first && t[i]->val>t[i+1]->val)\\n            {\\n                first=t[i];\\n                mid=t[i+1];\\n            }\\n            else if(t[i]->val>t[i+1]->val)\\n            {\\n                last=t[i+1];\\n            }\\n        }\\n        if(first && last)\\n            swap(first->val,last->val);\\n        else if(first && mid)\\n            swap(first->val,mid->val);\\n    }\\n};",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*>t;\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        t.push_back(root);\\n        inorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1962779,
                "title": "o-n-time-o-h-space-c",
                "content": "The idea is simple: When you do inorder traversal, you should going up (increasing) normally. If you notice going down, then something is off. \\nO(H) space is because of the recursion stack.\\n```\\nclass Solution {\\n    TreeNode *n1{nullptr}, *n2{nullptr}, *lastnode{nullptr}; //n1: first anomly, n2: second anomly, lastnode: last visited node\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        swap(n1->val, n2->val);\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        if(not root) return;\\n        inorder(root->left);\\n        if(lastnode and root->val < lastnode->val){\\n            if(n1) {\\n                n2 = root;\\n                return;\\n            }\\n            else //first anomly. Let n2 be current root first, in case it is ajacent swap\\n                n1 = lastnode, n2 = root;\\n        }\\n        lastnode = root;\\n        inorder(root->right);\\n    }\\n};\\n```\\nYou can check [Morris  Traversal](https://leetcode.com/problems/recover-binary-search-tree/discuss/1964374/O(1)-space-oror-O(n)-time-oror-Morris-traversal) for a true O(1) space solution. Although the difference is pretty small for the samples used here, after testing. (I guess tree provided are quite balanced)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode *n1{nullptr}, *n2{nullptr}, *lastnode{nullptr}; //n1: first anomly, n2: second anomly, lastnode: last visited node\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        swap(n1->val, n2->val);\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        if(not root) return;\\n        inorder(root->left);\\n        if(lastnode and root->val < lastnode->val){\\n            if(n1) {\\n                n2 = root;\\n                return;\\n            }\\n            else //first anomly. Let n2 be current root first, in case it is ajacent swap\\n                n1 = lastnode, n2 = root;\\n        }\\n        lastnode = root;\\n        inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962490,
                "title": "simple-and-efficient-java-o-n-solution",
                "content": "The Solution is Based on a observation that,\\n1. Since Inorder traversal gives sorted order, so we start looking from smaller values to larger values and hence we first get bigger part of the swapped integers\\n2. once we get the bigger part that is when x,y,z and x<y and y>z then we are sure that we need to remove y from this position\\n3. Henceforth we start finding a smaller value \\n```\\n\\nclass Solution {\\n    TreeNode big,small,prev;\\n    public void recoverTree(TreeNode root) {\\n        big=null;small=null;prev=null;\\n        rec(root);\\n        if(big!=null && small!=null){\\n            int temp=big.val;\\n            big.val=small.val;\\n            small.val=temp;     \\n        }\\n    }\\n    \\n    private void rec(TreeNode root){\\n        if(root==null) return ;\\n        rec(root.left);\\n        if(big!=null){\\n            if(small==null && root.val>big.val) big=root;\\n            else if(small!=null && root.val<small.val){\\n                small=root;\\n            }else if(small==null && root.val<prev.val){\\n                small=root;\\n            }\\n        }else{\\n            big=root;\\n        }\\n        prev=root;\\n        rec(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    TreeNode big,small,prev;\\n    public void recoverTree(TreeNode root) {\\n        big=null;small=null;prev=null;\\n        rec(root);\\n        if(big!=null && small!=null){\\n            int temp=big.val;\\n            big.val=small.val;\\n            small.val=temp;     \\n        }\\n    }\\n    \\n    private void rec(TreeNode root){\\n        if(root==null) return ;\\n        rec(root.left);\\n        if(big!=null){\\n            if(small==null && root.val>big.val) big=root;\\n            else if(small!=null && root.val<small.val){\\n                small=root;\\n            }else if(small==null && root.val<prev.val){\\n                small=root;\\n            }\\n        }else{\\n            big=root;\\n        }\\n        prev=root;\\n        rec(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962486,
                "title": "python-simple-morris-space-o-1",
                "content": "We can use Morris Traversal which takes space **O(1)**. We will be using inorder variant to go through the BST in increasing order.\\n\\n```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"                \\n        curr, prev, a, b = root, None, None, None        \\n        while curr:\\n            if not curr.left:   \\n\\t\\t\\t\\t# find the node that is violating the ordering \\n                if prev and curr.val < prev.val:\\t\\t\\t\\t\\t\\n                    if not a: # find the first node to swap\\n                        a = prev\\n                    b = curr                   \\n                prev = curr\\n                curr = curr.right                \\n            else:\\n                temp = curr.left\\n                while temp.right and temp.right is not curr:\\n                    temp = temp.right\\n                if temp.right is curr:\\n                    temp.right = None \\n                    if prev and curr.val < prev.val:\\n                        if not a:\\n                            a = prev\\n                        b = curr   \\n                    prev = curr\\n                    curr = curr.right\\n                else:\\n                    temp.right = curr\\n                    curr = curr.left\\n\\n\\t\\t# swap bide values\\n        a.val,b.val = b.val, a.val\\n```\\n\\n**Time = O(N) - Iterate through all nodes\\nSpace = O(1)**\\n\\n---\\n***Please upvote if you find it useful. Also feel free to share your thoughts in comments*.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"                \\n        curr, prev, a, b = root, None, None, None        \\n        while curr:\\n            if not curr.left:   \\n\\t\\t\\t\\t# find the node that is violating the ordering \\n                if prev and curr.val < prev.val:\\t\\t\\t\\t\\t\\n                    if not a: # find the first node to swap\\n                        a = prev\\n                    b = curr                   \\n                prev = curr\\n                curr = curr.right                \\n            else:\\n                temp = curr.left\\n                while temp.right and temp.right is not curr:\\n                    temp = temp.right\\n                if temp.right is curr:\\n                    temp.right = None \\n                    if prev and curr.val < prev.val:\\n                        if not a:\\n                            a = prev\\n                        b = curr   \\n                    prev = curr\\n                    curr = curr.right\\n                else:\\n                    temp.right = curr\\n                    curr = curr.left\\n\\n\\t\\t# swap bide values\\n        a.val,b.val = b.val, a.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962414,
                "title": "c-fast-easy-inordertraversal-explained",
                "content": "In the question, we do inorder traversal and find out the wrong placed numbers and there are two cases for that:\\n(i) both nodes are adjacent and hence there wont be third number wrong placed.\\n(ii)otherwise, if a number is misplaced, it\\'s next element will also seem to be mispalced as we\\'re checking with parent node. hence we store both parent and root as first and middle.\\n\\nWe\\'ll swap first and last if both nodes are separated or will swap first and middle if both nodes are adjacent.\\n#HareKrishna!\\n\\n```\\nclass Solution {\\n    #define Node TreeNode\\n    Node*prev;\\n    Node*first;\\n    Node*middle;\\n    Node*last;\\n    void solve(Node*root)\\n    {\\n        if(root==NULL)\\n            return;\\n        solve(root->left);\\n        if(root->val<prev->val)\\n        {\\n            if(first==NULL)\\n            {\\n                first=prev;\\n                middle=root;\\n            }\\n            else\\n            {\\n                last=root;\\n            }\\n        }\\n        prev=root;\\n        solve(root->right);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        first=middle=last=NULL;\\n        prev=new Node(INT_MIN); //keeps track of parent node\\n        solve(root);\\n        if(first&&last)\\n        {\\n            swap(first->val,last->val);\\n        }\\n        else\\n            swap(first->val,middle->val);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    #define Node TreeNode\\n    Node*prev;\\n    Node*first;\\n    Node*middle;\\n    Node*last;\\n    void solve(Node*root)\\n    {\\n        if(root==NULL)\\n            return;\\n        solve(root->left);\\n        if(root->val<prev->val)\\n        {\\n            if(first==NULL)\\n            {\\n                first=prev;\\n                middle=root;\\n            }\\n            else\\n            {\\n                last=root;\\n            }\\n        }\\n        prev=root;\\n        solve(root->right);\\n    }\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        first=middle=last=NULL;\\n        prev=new Node(INT_MIN); //keeps track of parent node\\n        solve(root);\\n        if(first&&last)\\n        {\\n            swap(first->val,last->val);\\n        }\\n        else\\n            swap(first->val,middle->val);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734486,
                "title": "using-inorder-traversal-and-then-sorting-elements",
                "content": "If we do traversal(here inorder) in the tree and store the values in an arraylist and sort the arraylist, we can get the right tree after inserting the sorted values in the tree again by inorder traversal.\\n```\\n//Doing inorderTraversal in the tree and then storing it in an arraylist and then sorting the list and again inserting the sorted values in the tree by doing inorder traversal.\\nclass Solution {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int count=0;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        Collections.sort(list); // Sorting the list \\n        insertinorder(root);\\n        \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val); // Adding to the list\\n        inorder(root.right);\\n    }\\n\\tpublic void insertinorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        insertinorder(root.left);\\n        root.val=list.get(count); // Changing the value of the node as per the sorted list\\n        count++;\\n        insertinorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Doing inorderTraversal in the tree and then storing it in an arraylist and then sorting the list and again inserting the sorted values in the tree by doing inorder traversal.\\nclass Solution {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int count=0;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        Collections.sort(list); // Sorting the list \\n        insertinorder(root);\\n        \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val); // Adding to the list\\n        inorder(root.right);\\n    }\\n\\tpublic void insertinorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        insertinorder(root.left);\\n        root.val=list.get(count); // Changing the value of the node as per the sorted list\\n        count++;\\n        insertinorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680987,
                "title": "c-in-order-traversal-only-3-extra-treenode",
                "content": "````\\nclass Solution {\\npublic:\\n    TreeNode* prev;\\n    TreeNode* x;\\n    TreeNode* y;\\n    void bfs(TreeNode* root){\\n        if(!root) return;\\n        bfs(root->left); // for in-order traversal: 1) left, 2) visit, 3) right\\n        \\n        if(prev && prev->val > root->val){\\n            if(!x){ // it is the first time we meet an unsorted value\\n                x = prev;\\n                y = root;\\n            } \\n            else if(x){ // if there is a second time it means we have to update the node\\n                y = root; \\n                return; // there are no more unsorted nodes, so we can exit\\n            } \\n        }\\n        prev = root;\\n        \\n        bfs(root->right);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        bfs(root); // by in-order traversal we go through the tree in a sorted order\\n        swap(x->val,y->val); // swap the values which make the tree unsorted\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* prev;\\n    TreeNode* x;\\n    TreeNode* y;\\n    void bfs(TreeNode* root){\\n        if(!root) return;\\n        bfs(root->left); // for in-order traversal: 1) left, 2) visit, 3) right\\n        \\n        if(prev && prev->val > root->val){\\n            if(!x){ // it is the first time we meet an unsorted value\\n                x = prev;\\n                y = root;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1529163,
                "title": "c-solution",
                "content": "```\\n    \\n    private TreeNode firstNode = null;\\n    private TreeNode secondNode = null;\\n    private TreeNode prev = new TreeNode(Int32.MinValue);\\n    \\n    public void RecoverTree(TreeNode root) {\\n        \\n        if(root == null)\\n            return;\\n        \\n        dfs(root);        \\n        int tmp = firstNode.val;\\n        firstNode.val = secondNode.val;\\n        secondNode.val = tmp;\\n    }\\n    \\n    private void dfs(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        dfs(root.left);\\n        \\n        if(firstNode == null && root.val < prev.val)\\n            firstNode = prev;\\n        \\n        if(firstNode != null && root.val < prev.val)\\n            secondNode = root;\\n        \\n        prev = root;\\n        \\n        dfs(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    \\n    private TreeNode firstNode = null;\\n    private TreeNode secondNode = null;\\n    private TreeNode prev = new TreeNode(Int32.MinValue);\\n    \\n    public void RecoverTree(TreeNode root) {\\n        \\n        if(root == null)\\n            return;\\n        \\n        dfs(root);        \\n        int tmp = firstNode.val;\\n        firstNode.val = secondNode.val;\\n        secondNode.val = tmp;\\n    }\\n    \\n    private void dfs(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        dfs(root.left);\\n        \\n        if(firstNode == null && root.val < prev.val)\\n            firstNode = prev;\\n        \\n        if(firstNode != null && root.val < prev.val)\\n            secondNode = root;\\n        \\n        prev = root;\\n        \\n        dfs(root.right);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507268,
                "title": "c-easy-to-understand-2-methods-o-1-space",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Time complexity O(N)\\nspace complexity O(N)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode *first=NULL,*second=NULL;\\n    TreeNode* prev=new TreeNode(INT_MIN);\\n    void inorder(TreeNode* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        if(first==NULL&&prev->val>root->val)\\n        first=prev;\\n        if(first!=NULL&&prev->val>root->val)\\n        second=root;\\n        prev=root;\\n        inorder(root->right,v);\\n    }    \\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n        int temp=second->val;\\n        second->val=first->val;\\n        first->val=temp;\\n    }\\n};\\n```\\n**Time complexity O(N)\\nSpace complexity O(1)**\\n```\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *first=NULL,*second=NULL;\\n    TreeNode* prev=new TreeNode(INT_MIN);\\n    void inorder(TreeNode* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        if(first==NULL&&prev->val>root->val)\\n        first=prev;\\n        if(first!=NULL&&prev->val>root->val)\\n        second=root;\\n        prev=root;\\n        inorder(root->right,v);\\n    }    \\n    void recoverTree(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n        int temp=second->val;\\n        second->val=first->val;\\n        first->val=temp;\\n    }\\n};\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466747,
                "title": "c-super-simple-and-clean",
                "content": "///2 Nodes of a BST are swapped by mistake. Recover the BST by reverse swapping those swapped nodes.\\n    /// Solution: Since BST Inorder traversal gives elements in increasing order, we can traverse bst in inorder and look \\n    /// for nodes which violates the increasing order.\\n    /// We just have to find and swap the violating keys\\n    /// \\n    /// There can be 2 cases.\\n    /// Case 1: When adjucent nodes are swapped  i.e. eg: 1,2,4,3,5,6\\n    ///  In this case we get only one violation (3) and that and it\\'s previous (4) needed to be swapped.\\n    ///  i.e. swap 4 and 3 and we get 1,2,3,4,5,6\\n    ///  \\n    /// Case 2: When non adjucent nodes are swapped i.e. eg: 1,6,3,4,5,2  {6 and 2 are swapped}\\n    /// Then first violation\\'s = 3\\n    /// 2nd violation = 2\\n    /// Swap previous of first violation with 2nd violation\\n    /// and we get 1,2,3,4,5,6\\n```\\n\\npublic class Solution {\\n    public void RecoverTree(TreeNode root) {\\n            TreeNode First = null;\\n            TreeNode Second = null;\\n            TreeNode Prev = null;\\n            InOrder(root,ref First,ref Second,ref Prev);\\n        \\n            var a = First.val;\\n            First.val = Second.val;\\n            Second.val = a;\\n    }\\n    public static void InOrder(TreeNode root, ref TreeNode First, ref TreeNode Second, ref TreeNode Prev)\\n        {\\n            if (root == null) return;\\n            InOrder(root.left,ref First, ref Second, ref Prev);\\n            if (Prev != null && root.val <Prev.val )\\n            {\\n                if (First == null) First = Prev;\\n                Second = root;\\n            }\\n\\n            Prev = root;\\n            InOrder(root.right, ref First, ref Second, ref Prev);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public void RecoverTree(TreeNode root) {\\n            TreeNode First = null;\\n            TreeNode Second = null;\\n            TreeNode Prev = null;\\n            InOrder(root,ref First,ref Second,ref Prev);\\n        \\n            var a = First.val;\\n            First.val = Second.val;\\n            Second.val = a;\\n    }\\n    public static void InOrder(TreeNode root, ref TreeNode First, ref TreeNode Second, ref TreeNode Prev)\\n        {\\n            if (root == null) return;\\n            InOrder(root.left,ref First, ref Second, ref Prev);\\n            if (Prev != null && root.val <Prev.val )\\n            {\\n                if (First == null) First = Prev;\\n                Second = root;\\n            }\\n\\n            Prev = root;\\n            InOrder(root.right, ref First, ref Second, ref Prev);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413793,
                "title": "nice-explanation-inorder-traversal-c-implementation-time-o-n",
                "content": "the key to solve this problem is : The **inorder traversal** of a BST produces a sorted array\\n\\n1.  a simple method is to store inorder traversal of the input tree in an auxiliary array. Sort the auxiliary       array. Finally, insert the auxiliary array elements back to the BST, keeping the structure of the BST         same. The time complexity of this method is O(nLogn) and the auxiliary space needed is O(n).w can     also make here some optimization by using insertion sort(for minimum complexity).\\n\\n2.  We can solve this in O(n) time and with a single traversal of the given BST. Since inorder traversal        of BST is always a sorted array, the problem can be reduced to a problem where two elements of a      sorted array are swapped. \\n\\n     Example : For example, Nodes 2 and 3 are swapped in [1,2,3]. \\n                      The inorder traversal of the given tree is [3,2,1] \\n\\tIf we observe carefully, during inorder traversal, we find node 2 is smaller than the previous visited      node 3. Here save the context of node 3 (previous node). Again, we find that node 1 is smaller      than the previous node 2. This time, we save the context of node 1 (the current node ). Finally, swap the two node\\u2019s values.\\n\\t\\n\\tExample, Nodes 2 and 3 are swapped in [1,2,3,4]. \\n  The inorder traversal of the given tree is [1,3,2,4]\\n  unlike previous example ,here only one point exists where a node value is smaller than the previous    node value.\\n  \\n    so, here we can note that when two elements of a sorted array are swapped. \\n   There are two cases that we need to handle:\\n   Firts : The swapped nodes are not adjacent in the inorder traversal of the BST. \\n   Second :  The swapped nodes are adjacent in the inorder traversal of BST.\\n   \\n    we can handle two cases by using FirstNode , SecondNode , PreviousNode For every node (except     the leftmost node of the tree), keep track of its previous node in prev. The current node being processed is stored in the curr.\\nIf during the traversal, we find a node that violates the BST order  previousNode->val > CurrentNode->val .we store PreviousNode into fFirst and CurrentNode into Second.\\nDuring further traversal, if we find another node that violates the BST criteria , previousNode->val > CurrentNode->val. but since, the First node had been already assigned a value. so we assign the current node(which violates BST criteria) to Second.\\nAfter execution of inorder traversal. swap the data of First and Second nodes and The tree gets fixed.\\n\\n\\n```\\n    void RecoverBinarySearchTree(TreeNode* CurrentNode ,TreeNode* &PreviousNode ,TreeNode* &First, TreeNode* &Second) {\\n        if(CurrentNode == NULL) return;\\n        RecoverBinarySearchTree(CurrentNode->left,PreviousNode,First,Second);\\n        if(PreviousNode != NULL && PreviousNode->val > CurrentNode->val) {\\n            if(First == NULL){\\n                First = PreviousNode;\\n                Second = CurrentNode;\\n            }else Second = CurrentNode;\\n        }\\n        PreviousNode = CurrentNode;\\n        RecoverBinarySearchTree(CurrentNode->right,PreviousNode,First,Second);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        TreeNode* First = NULL; TreeNode* Second = NULL; TreeNode* PreviousNode = NULL;\\n        RecoverBinarySearchTree(root,PreviousNode,First,Second);\\n        int temp = First->val;\\n        First->val = Second->val;\\n        Second->val = temp;\\n    }\\n```\\nTime Complexity : O(n)\\nSpace Complexity : O(1), nor data structure neither recursion stack space used.\\n\\nnote : in above code we pass First,Second and PreviousNode to function by refrence\\n          and it\\'s important! \\n\\t\\t  if we take a simple tset case : \\n\\t\\t  ![image](https://assets.leetcode.com/users/images/2b7f8775-5d5d-4d77-a017-03d57b0fb24c_1629391275.4167056.png)\\n1. here we pass to function :  node(1) and First = NULL , Second = NULL  and Previous = NULL\\n2. we will go to left : node(3) and  First = NULL , Second = NULL  and Previous = NULL\\n    and we go to left we will find NULL node so we will return and  update PreviousNode = node(3) \\n3. we will go to right : node(2) left is NULL and we will find previous is not NULL and previous is greater     than current node so it\\'s ok we will update First = PreviousNode , Second = CurrentNode\\n\\tand update PerviousNode : node(2) and it\\'s so important to keep track it with others node\\n\\tand will find right is NULL and i will return to : node : (3) , First :node(3) , Second : node(1) and     PreviousNode : node(2) and this why i call it by refrence to save it\\'s value when i return !\\n\\t\\ni hope you find this is helpful !\\n\\t\\t  \\n\\t\\t  \\n\\t\\t \\n\\t\\t  \\n\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\n    void RecoverBinarySearchTree(TreeNode* CurrentNode ,TreeNode* &PreviousNode ,TreeNode* &First, TreeNode* &Second) {\\n        if(CurrentNode == NULL) return;\\n        RecoverBinarySearchTree(CurrentNode->left,PreviousNode,First,Second);\\n        if(PreviousNode != NULL && PreviousNode->val > CurrentNode->val) {\\n            if(First == NULL){\\n                First = PreviousNode;\\n                Second = CurrentNode;\\n            }else Second = CurrentNode;\\n        }\\n        PreviousNode = CurrentNode;\\n        RecoverBinarySearchTree(CurrentNode->right,PreviousNode,First,Second);\\n    }\\n    \\n    void recoverTree(TreeNode* root) {\\n        TreeNode* First = NULL; TreeNode* Second = NULL; TreeNode* PreviousNode = NULL;\\n        RecoverBinarySearchTree(root,PreviousNode,First,Second);\\n        int temp = First->val;\\n        First->val = Second->val;\\n        Second->val = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384474,
                "title": "c-o-1-space-well-commented",
                "content": "```\\nclass Solution {\\n    public:\\n    vector<pair<TreeNode*,TreeNode*>> vec; // To store pairs that violates BST  \\n    TreeNode* prev = NULL; // keep track of previous node\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root == NULL)  return; // Base Condition\\n        \\n        solve(root->left); // First left\\n        // Than deal with Val \\n        \\n        /* if statement says : if previous node exists and previous node has a value more than next or any root that comes to the \\n\\t\\tright of prev than\\tin such case it violates BST condition so push that pair in vec for now, will deal withit later */\\n        if(prev && prev->val > root->val) vec.push_back({prev,root}); \\n        \\n        prev = root; // keep updating prev, for checking BST condition further\\n        solve(root->right); // At last right, this is inorder manner\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {    \\n        solve(root); // Inorder traversal\\n        \\n        /* If just 2 adjacent nodes violated BST , than there will be 1 key value pair in           \\n\\t\\tvec and we will swap it and problem is solved */\\n        if(vec.size() == 1) \\n            swap(vec[0].first->val, vec[0].second->val);\\n        \\n        /* We know its given in question that only 2 nodes of the tree were swapped, but what if those 2 nodes are not adjacent, in that case \\n\\t\\twe have 2 key value pairs which shows there is irregularity in 4 elements. (so size of vec is 2). eg: 1 2 3 4 , we change it to : 4 2 3 1 \\n\\t\\twhich leads to inconsistency in {4,2} and {3,1} so to solve it we swap first of 0th and second of 1th which are 4 and 1 respectively, \\n\\t\\twe can get 1 2 3 4 back, same is done below : */\\n        if(vec.size() == 2)\\n            swap(vec[0].first->val, vec[1].second->val);\\n    }\\n};\\n\\n// Time : O(N)\\n// Space : O(1)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    vector<pair<TreeNode*,TreeNode*>> vec; // To store pairs that violates BST  \\n    TreeNode* prev = NULL; // keep track of previous node\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root == NULL)  return; // Base Condition\\n        \\n        solve(root->left); // First left\\n        // Than deal with Val \\n        \\n        /* if statement says : if previous node exists and previous node has a value more than next or any root that comes to the \\n\\t\\tright of prev than\\tin such case it violates BST condition so push that pair in vec for now, will deal withit later */\\n        if(prev && prev->val > root->val) vec.push_back({prev,root}); \\n        \\n        prev = root; // keep updating prev, for checking BST condition further\\n        solve(root->right); // At last right, this is inorder manner\\n    }\\n    \\n    void recoverTree(TreeNode* root) \\n    {    \\n        solve(root); // Inorder traversal\\n        \\n        /* If just 2 adjacent nodes violated BST , than there will be 1 key value pair in           \\n\\t\\tvec and we will swap it and problem is solved */\\n        if(vec.size() == 1) \\n            swap(vec[0].first->val, vec[0].second->val);\\n        \\n        /* We know its given in question that only 2 nodes of the tree were swapped, but what if those 2 nodes are not adjacent, in that case \\n\\t\\twe have 2 key value pairs which shows there is irregularity in 4 elements. (so size of vec is 2). eg: 1 2 3 4 , we change it to : 4 2 3 1 \\n\\t\\twhich leads to inconsistency in {4,2} and {3,1} so to solve it we swap first of 0th and second of 1th which are 4 and 1 respectively, \\n\\t\\twe can get 1 2 3 4 back, same is done below : */\\n        if(vec.size() == 2)\\n            swap(vec[0].first->val, vec[1].second->val);\\n    }\\n};\\n\\n// Time : O(N)\\n// Space : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379643,
                "title": "java-o-1-space-simple-in-order-traversal-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    \\n    // It is true that if we swap any 2 nodes in a BST, both of those nodes\\n    // will break the rules of a BST. They are lawbreakers! (naughty). We need\\n    // to keep track of both of them. Left is the leftmost lawbreaker and right is \\n    // the rightmost lawbreaker aaccording to the BST\\'s in-order sequence.\\n    private TreeNode lawbreakerLeft, lawbreakerRight;\\n    \\n    // To check whether a node is a lawbreaker we need to see whether the current node\\n    // of an in-order traversal is not... well... in-order. If this was a BST of ascending\\n    // order, the highest value would be the current node and the second highest would be\\n    // the previous that we visited - unless we have a lawbreaker on our hands.\\n    private TreeNode secondHighestValue, highestValue;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        // Start performing the in-order traversal recursively.\\n        traverse(root);\\n        \\n        // Swap the values of the two lawbreakers so they are abiding the law once more.\\n        int temp = lawbreakerLeft.val;\\n        lawbreakerLeft.val = lawbreakerRight.val;\\n        lawbreakerRight.val = temp;\\n    }\\n    \\n    public void traverse(TreeNode curr) {\\n        if (curr == null) {\\n            return;\\n        }\\n        \\n        // As per in-order traversal rules, we will go left as much as possible, then visit the\\n        // current node, then go right. The rest of this method does just that.\\n        traverse(curr.left);\\n        \\n        // The special part comes with the \"visiting\" of the current node. The first thing we do\\n        // is make note of the current value. Since this is in-order traversal of a BST, the current value\\n        // must be the largest value, and the previously visited value must be the the second largest.\\n        secondHighestValue = highestValue;\\n        highestValue = curr;\\n        \\n        // If for some reason the previous value is greater than the current value... We have found a lawbreaker.\\n        //\\n        // The null check here is just for the case that we\\'re at the leftmost node, in which we can\\'t have set the previous\\n        // value just yet.\\n        if (secondHighestValue != null && secondHighestValue.val > highestValue.val) {\\n            \\n            // If we have not yet found our first lawbreaker, we must set it, while remembering to swap the\\n            // secondHighest and highest value around so that the ordering is correct. Otherwise we can be in a position\\n            // in the next recursion where the highest is not in fact the actual highest. We also set the right in the case that\\n            // by chance the two nodes that were swapped are right next to each other (otherwise it will be skipped).\\n            if (lawbreakerLeft == null) {\\n                lawbreakerLeft = secondHighestValue;\\n                lawbreakerRight = highestValue;\\n                \\n                highestValue = lawbreakerLeft;\\n            } else {\\n                // If the left lawbreaker has been found then we have found a right lawbreaker. You may notice if this has\\n                // already been set then we overwrite it - this is because we always set the right when we find the left most one\\n                // for that one-off case in the previous comment, but if it is not the case the right most lawbreaker node will\\n                // exist somewhere else in the tree.\\n                lawbreakerRight = highestValue;\\n            }\\n        }\\n        \\n        // Finally go and visit the right node!\\n        traverse(curr.right);\\n    }\\n}\\n```\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // It is true that if we swap any 2 nodes in a BST, both of those nodes\\n    // will break the rules of a BST. They are lawbreakers! (naughty). We need\\n    // to keep track of both of them. Left is the leftmost lawbreaker and right is \\n    // the rightmost lawbreaker aaccording to the BST\\'s in-order sequence.\\n    private TreeNode lawbreakerLeft, lawbreakerRight;\\n    \\n    // To check whether a node is a lawbreaker we need to see whether the current node\\n    // of an in-order traversal is not... well... in-order. If this was a BST of ascending\\n    // order, the highest value would be the current node and the second highest would be\\n    // the previous that we visited - unless we have a lawbreaker on our hands.\\n    private TreeNode secondHighestValue, highestValue;\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        // Start performing the in-order traversal recursively.\\n        traverse(root);\\n        \\n        // Swap the values of the two lawbreakers so they are abiding the law once more.\\n        int temp = lawbreakerLeft.val;\\n        lawbreakerLeft.val = lawbreakerRight.val;\\n        lawbreakerRight.val = temp;\\n    }\\n    \\n    public void traverse(TreeNode curr) {\\n        if (curr == null) {\\n            return;\\n        }\\n        \\n        // As per in-order traversal rules, we will go left as much as possible, then visit the\\n        // current node, then go right. The rest of this method does just that.\\n        traverse(curr.left);\\n        \\n        // The special part comes with the \"visiting\" of the current node. The first thing we do\\n        // is make note of the current value. Since this is in-order traversal of a BST, the current value\\n        // must be the largest value, and the previously visited value must be the the second largest.\\n        secondHighestValue = highestValue;\\n        highestValue = curr;\\n        \\n        // If for some reason the previous value is greater than the current value... We have found a lawbreaker.\\n        //\\n        // The null check here is just for the case that we\\'re at the leftmost node, in which we can\\'t have set the previous\\n        // value just yet.\\n        if (secondHighestValue != null && secondHighestValue.val > highestValue.val) {\\n            \\n            // If we have not yet found our first lawbreaker, we must set it, while remembering to swap the\\n            // secondHighest and highest value around so that the ordering is correct. Otherwise we can be in a position\\n            // in the next recursion where the highest is not in fact the actual highest. We also set the right in the case that\\n            // by chance the two nodes that were swapped are right next to each other (otherwise it will be skipped).\\n            if (lawbreakerLeft == null) {\\n                lawbreakerLeft = secondHighestValue;\\n                lawbreakerRight = highestValue;\\n                \\n                highestValue = lawbreakerLeft;\\n            } else {\\n                // If the left lawbreaker has been found then we have found a right lawbreaker. You may notice if this has\\n                // already been set then we overwrite it - this is because we always set the right when we find the left most one\\n                // for that one-off case in the previous comment, but if it is not the case the right most lawbreaker node will\\n                // exist somewhere else in the tree.\\n                lawbreakerRight = highestValue;\\n            }\\n        }\\n        \\n        // Finally go and visit the right node!\\n        traverse(curr.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370723,
                "title": "99-faster",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n\\n**Explanation :-** 1. There can be two cases where nodes are need to be swapped in the inorder traversal i.e. either they are adjacant to each other or are far from each other. \\n\\n**(a)** For example, Nodes 5 and 25 are swapped in {3 5 7 8 10 15 20 25}. \\n The inorder traversal of the given tree is 3 **25** 7 8 10 15 20 **5**\\nIf we observe carefully, during inorder traversal, we find node 7 is smaller than the previous visited node 25. Here save the context of node 25 (previous node). Again, we find that node 5 is smaller than the previous node 20. This time, we save the context of node 5 ( current node ). Finally swap the two node\\u2019s values.\\n\\n**(b)** The swapped nodes are adjacent in the inorder traversal of BST.\\n\\n  For example, Nodes 7 and 8 are swapped in {3 5 7 8 10 15 20 25}. \\n  The inorder traversal of the given tree is 3 5 **8** **7** 10 15 20 25 \\nUnlike case #1, here only one point exists where a node value is smaller than previous node value. e.g. node 7 is smaller than node 8.\\n\\n**How to Solve?** \\n**In case #1**\\nWe will maintain three pointers, first, prev and second. When we find the first point where current node value is smaller than previous node value, we update the first with the previous node. When we find the second point where current node value is smaller than previous node value, we update the second with the current node. Second will be updated when nodes are not adjacent.\\n**In case #2**\\nWe will find the first and second point only once when two swapped nodes of BST are adjacent.\\n```\\nclass Solution {\\npublic:\\n      void inorder(TreeNode *root , TreeNode *&first , TreeNode *&second , TreeNode *&prev)\\n      {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        inorder(root -> left , first , second , prev);\\n        if(prev != NULL && prev -> val > root -> val)\\n        {\\n            if(first == NULL)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n        prev = root;\\n        inorder(root -> right , first , second , prev);\\n     }\\n    \\n    void recoverTree(TreeNode* root)\\n    {\\n       TreeNode *first , *second , *prev;\\n       first = second = prev = NULL;\\n       inorder(root , first , second , prev);\\n       swap(first -> val , second -> val);\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n      void inorder(TreeNode *root , TreeNode *&first , TreeNode *&second , TreeNode *&prev)\\n      {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        inorder(root -> left , first , second , prev);\\n        if(prev != NULL && prev -> val > root -> val)\\n        {\\n            if(first == NULL)\\n            {\\n                first = prev;\\n            }\\n            second = root;\\n        }\\n        prev = root;\\n        inorder(root -> right , first , second , prev);\\n     }\\n    \\n    void recoverTree(TreeNode* root)\\n    {\\n       TreeNode *first , *second , *prev;\\n       first = second = prev = NULL;\\n       inorder(root , first , second , prev);\\n       swap(first -> val , second -> val);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347121,
                "title": "java-easy-recursive-solution-inorder",
                "content": "```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        if(prev!=null && root.val<prev.val){\\n            if(first==null){\\n                first=prev;\\n            }\\n              second=root; \\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev=null,first=null,second=null;\\n    public void recoverTree(TreeNode root) {\\n        inorder(root);\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left);\\n        if(prev!=null && root.val<prev.val){\\n            if(first==null){\\n                first=prev;\\n            }\\n              second=root; \\n        }\\n        prev=root;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314888,
                "title": "deal-with-duplicate-values-swap-nodes-instead-of-just-values-w-python-implementation",
                "content": "Submitting a solution that passes all test cases of this problem is simple. However, there are two points of this problem setting that really do NOT make sense. Neither does the official solution article take them into account:\\n1. According to the official solution article and all test cases used in this problem, we know that it\\'s assumed that there are no duplicate values in a tree, which is however never stated in the problem description.\\nIn general, the definition of BST includes \"equal\" situation, namely: the value in each node is **greater than or equal to** (less than or equal to) any values stored in its left (right) subtree. So a BST does not necessarily have unique value for each node. \\nSo the question would be be: \"how to handle duplicate cases?\" which is raised already by many other guys in the Discussion part (see: https://leetcode.com/problems/recover-binary-search-tree/discuss/32673/Does-the-BST-in-this-problem-include-duplicate-nodes, https://leetcode.com/problems/recover-binary-search-tree/discuss/32656/How-to-handle-the-case-when-there-are-duplicate-values-in-the-BST, and [etc](https://leetcode.com/problems/recover-binary-search-tree/discuss?currentPage=1&orderBy=most_relevant&query=duplicate).)\\n\\n2. It is assumed in this problem that it is the **values**(i.e., key of the node) of two nodes that got swapped. In a more reasonable setting, the two **TreeNodes** are swapped other than the mere values. (For example, in real application, a tree node might carry some satellite data.) In such scenarios,  we want a solution that swap nodes instead of just their (key) values.\\n\\n**To address the above concerns:**\\n\\n\\nThis is a more general solution that is able to handle duplicate values (only 1 pass)\\n```\\n# This solution uses stack. You can also do the similar thing with recursion or Morris traversal\\n# This solution is able to deal with duplicate values; therefore it\\'s a more general solution\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        \\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x = pred \\n                        y = root\\n                else:\\n                    if root.val <= y.val:\\n                        y = root\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred = root\\n            ### this is what we do to each traversed node ###\\n                \\n            root = root.right\\n        x.val, y.val = y.val, x.val\\n```\\n\\n\\nIf you also want to consider swapping nodes instead of values, here is what you need:\\n```\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        parent = None\\n        while stack or root:\\n            while root:\\n                stack.append((root, parent))\\n                root, parent = root.left, root\\n            root, parent = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x, x_parent = pred, pred_parent\\n                        y, y_parent = root, parent\\n                else:\\n                    if root.val <= y.val:\\n                        y, y_parent = root, parent\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred, pred_parent = root, parent\\n            ### this is what we do to each traversed node ###\\n                \\n            root, parent = root.right, root\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\ndef swap_nodes(x: TreeNode, y: TreeNode, x_parent: TreeNode, y_parent: TreeNode):\\n    if x_parent is y:\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n        if y.left is x:\\n            x.left, x.right, y.left, y.right = y, y.right, x.left, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y, x.left, x.right\\n\\n    elif y_parent is x:\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if x.left is y:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x.left, x\\n\\n    else:    \\n        x.left, x.right, y.left, y.right = y.left, y.right, x.left, x.right\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n```\\n\\n\\nFinally, I provide an optimal solution which has the asymtotically best time & space complexity (O(n) time and O(1) space) and also takes into account the aforementioned two points, using Morris traversal.\\n\\n```\\n# Morris traversal\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(1)\\nclass Solution:\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        x = y = predecessor = pred = None\\n        \\n        node = root\\n        while node:\\n            if not node.left: \\n                \\n                ### this is what we do to each traversed node ###\\n                if pred:\\n                    if x is None:\\n                        if node.val < pred.val:\\n                            x = pred \\n                            y = node\\n                    else:\\n                        if node.val <= y.val:\\n                            y = node\\n                if pred is None or node.val != pred.val:\\n                    pred = node\\n                ### this is what we do to each traversed node ###\\n                \\n                node = node.right            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    predecessor.right = node\\n                    node = node.left\\n                else:\\n                    predecessor.right = None \\n                    \\n                    ### this is what we do to each traversed node ###\\n                    if pred:\\n                        if x is None:\\n                            if node.val < pred.val:\\n                                x = pred \\n                                y = node\\n                        else:\\n                            if node.val <= y.val:\\n                                y = node\\n                    if pred is None or node.val != pred.val:\\n                        pred = node\\n                    ### this is what we do to each traversed node ###\\n                    \\n                    node = node.right \\n                    \\n        x_parent, y_parent = self.morris_preorder(root, x, y)\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\n    def morris_preorder(self, root, x, y):\\n        \\'\\'\\'\\n        This is used to find the parents of x, y in linear time and constant space\\n        \\'\\'\\'\\n        node, parent = root, None\\n        while node:\\n            if not node.left: \\n                \\n                ### check if we meet the parent ###\\n                if node is x:\\n                    x_parent = parent\\n                elif node is y:\\n                    y_parent = parent\\n                ### check if we meet the parent ###\\n                \\n                node, parent = node.right, node            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    \\n                    ### check if we meet the parent ###\\n                    if node is x:\\n                        x_parent = parent\\n                    elif node is y:\\n                        y_parent = parent\\n                    ### check if we meet the parent ###\\n                    \\n                    predecessor.right = node\\n                    node, parent = node.left, node\\n                else:\\n                    predecessor.right = None                     \\n                    node, parent = node.right, node\\n                    \\n        return x_parent, y_parent\\n```\\nNote that if your implementation swaps nodes instead of values, then the code won\\'t pass the test cases of this problem, since in some cases it swaps the root node and the LeetCode testing code of this problem won\\'t change the pointer to the original root to the new root so that you eventually end up with a subtree instead of the original entire tree.",
                "solutionTags": [],
                "code": "```\\n# This solution uses stack. You can also do the similar thing with recursion or Morris traversal\\n# This solution is able to deal with duplicate values; therefore it\\'s a more general solution\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        \\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x = pred \\n                        y = root\\n                else:\\n                    if root.val <= y.val:\\n                        y = root\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred = root\\n            ### this is what we do to each traversed node ###\\n                \\n            root = root.right\\n        x.val, y.val = y.val, x.val\\n```\n```\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(H) where H is the height of the tree. In the worst case it can deteriorate to O(N)\\nclass Solution:\\n    def recoverTree(self, root: TreeNode):\\n        \"\"\"\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        stack = []\\n        x = y = pred = None\\n        parent = None\\n        while stack or root:\\n            while root:\\n                stack.append((root, parent))\\n                root, parent = root.left, root\\n            root, parent = stack.pop()\\n            \\n            ### this is what we do to each traversed node ###\\n            if pred:\\n                if x is None:\\n                    if root.val < pred.val:\\n                        x, x_parent = pred, pred_parent\\n                        y, y_parent = root, parent\\n                else:\\n                    if root.val <= y.val:\\n                        y, y_parent = root, parent\\n                    if root.val > x.val:\\n                        break\\n            if pred is None or root.val != pred.val:\\n                pred, pred_parent = root, parent\\n            ### this is what we do to each traversed node ###\\n                \\n            root, parent = root.right, root\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\ndef swap_nodes(x: TreeNode, y: TreeNode, x_parent: TreeNode, y_parent: TreeNode):\\n    if x_parent is y:\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n        if y.left is x:\\n            x.left, x.right, y.left, y.right = y, y.right, x.left, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y, x.left, x.right\\n\\n    elif y_parent is x:\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if x.left is y:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x, x.right\\n        else:\\n            x.left, x.right, y.left, y.right = y.left, y.right, x.left, x\\n\\n    else:    \\n        x.left, x.right, y.left, y.right = y.left, y.right, x.left, x.right\\n        if x_parent:\\n            if x_parent.left is x:\\n                x_parent.left = y\\n            else:\\n                x_parent.right = y\\n        if y_parent:\\n            if y_parent.left is y:\\n                y_parent.left = x\\n            else:\\n                y_parent.right = x\\n```\n```\\n# Morris traversal\\n# This solution:\\n#    1. is able to deal with duplicate values\\n#    2. swaps nodes instead of values\\n# (we assume the two swapped nodes don\\'t have the same value.)\\n# Time complexity: O(N)\\n# Space complexity: O(1)\\nclass Solution:\\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        x = y = predecessor = pred = None\\n        \\n        node = root\\n        while node:\\n            if not node.left: \\n                \\n                ### this is what we do to each traversed node ###\\n                if pred:\\n                    if x is None:\\n                        if node.val < pred.val:\\n                            x = pred \\n                            y = node\\n                    else:\\n                        if node.val <= y.val:\\n                            y = node\\n                if pred is None or node.val != pred.val:\\n                    pred = node\\n                ### this is what we do to each traversed node ###\\n                \\n                node = node.right            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    predecessor.right = node\\n                    node = node.left\\n                else:\\n                    predecessor.right = None \\n                    \\n                    ### this is what we do to each traversed node ###\\n                    if pred:\\n                        if x is None:\\n                            if node.val < pred.val:\\n                                x = pred \\n                                y = node\\n                        else:\\n                            if node.val <= y.val:\\n                                y = node\\n                    if pred is None or node.val != pred.val:\\n                        pred = node\\n                    ### this is what we do to each traversed node ###\\n                    \\n                    node = node.right \\n                    \\n        x_parent, y_parent = self.morris_preorder(root, x, y)\\n        swap_nodes(x, y, x_parent, y_parent)\\n    \\n    def morris_preorder(self, root, x, y):\\n        \\'\\'\\'\\n        This is used to find the parents of x, y in linear time and constant space\\n        \\'\\'\\'\\n        node, parent = root, None\\n        while node:\\n            if not node.left: \\n                \\n                ### check if we meet the parent ###\\n                if node is x:\\n                    x_parent = parent\\n                elif node is y:\\n                    y_parent = parent\\n                ### check if we meet the parent ###\\n                \\n                node, parent = node.right, node            \\n            else:\\n                predecessor = node.left\\n                while predecessor.right and predecessor.right is not node:\\n                    predecessor = predecessor.right\\n                \\n                if not predecessor.right:\\n                    \\n                    ### check if we meet the parent ###\\n                    if node is x:\\n                        x_parent = parent\\n                    elif node is y:\\n                        y_parent = parent\\n                    ### check if we meet the parent ###\\n                    \\n                    predecessor.right = node\\n                    node, parent = node.left, node\\n                else:\\n                    predecessor.right = None                     \\n                    node, parent = node.right, node\\n                    \\n        return x_parent, y_parent\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264842,
                "title": "o-n-time-o-1-space-handles-duplicates-explanation-and-lessons-learned",
                "content": "I feel that the few comments I perused mostly contained code of which I did not fully understand what to do with it. Also I have a slight criticism to the task because it does not say that node-values are distinct, albeit in the test cases they are. For my solution, I will not assume that they are.\\n\\nThings I learned:\\n1) **Morris traversal**, you can traverse a binary tree with constant space (note that the recursion stack also counts as space). There are better explanations out in the internet, so I am not going to explain it. My function *inOrderTraversal* is an implementation of it.\\n2) **Pointers to member functions**, first time I encountered them and heard that they are difficult to normal function pointers. You have this crazy ->* syntax. Something to learn.\\n3) **Reduce to easier problems**. In my opinion this is the secret behind every good problem solver and it helped me understand the solution here to. I will jut down my thinking.\\n\\nHow I found my solution:\\nNormally, I do not like to bother people with how I came up with my solution (who cares), but here I do, since it gives me insights into how to solve general problems.\\n1) *First considering a list (ordered) with distinct values. Write one down and swap a) two consecutive values, b) two values one apart, c) two values two apart*. You will notices that in the resulting list the swapped values are found easily: It is the first value, which is larger then the follow-up value and the last value, which is smaller than its predecessor. Let us call them *firstFaulty* and *lastFaulty*.\\n2) *Now consider lists with non-distinct values.* You will notice that you have to replace *firstFaulty* by the last item, which has the value *firstFaulty* and *lastFaulty* with the first value which is equal to *lastFaulty*. I think you can quickly figure out that this is correct on paper and thus I will omit a proof of formal correctness. If you want to see one, quickly shoot me a comment and I will provide one.\\n3) *Now consider the general problem with trees*. Can we transform a tree into an ordered list? Not using O(1) space and \\'remembering\\' the tree-structure. But we can go through the tree in-order using *Morris-traversal* and O(1) space; it is similar to transforming the tree into a singly-linked list. We will traverse through our tree twice. First finding *firstFaulty* and *lastFaulty* as described in 1), then updating them as described in 2). Voila that is our algorithm.\\n\\nThe implementation was also a bit tricky. To avoid duplication of code, I only implemented the Morris-traversal once and learned a lot about method-function pointers in the process. But this is at most interesting to the C++-nerds among us; if at all.\\n\\n```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        firstFaulty=lastFaulty=0;\\n        previous=0;\\n        inOrderTraversal(root, &Solution::findFirstLastFaulty);\\n        if(firstFaulty){\\n            handleDuplicateValues(root);\\n            swap(firstFaulty->val,lastFaulty->val);\\n        }\\n    }\\nprivate:\\n    TreeNode* firstFaulty;\\n    TreeNode* lastFaulty;\\n    TreeNode* previous=0;\\n    bool lastFaultyFound;\\n    \\n    void inOrderTraversal(TreeNode *root, void (Solution::*check)(TreeNode*)){\\n        TreeNode* current=root;\\n        \\n        while(current){\\n            if(! current->left){\\n                (this->*check)(current);\\n                current=current->right;\\n            }else{\\n                TreeNode* predecessor=current->left;\\n                while(predecessor->right && predecessor->right!=current){\\n                    predecessor=predecessor->right;\\n                }\\n                if(!predecessor->right){\\n                    predecessor->right=current;\\n                    current=current->left;\\n                }else{\\n                    predecessor->right=0;\\n                    (this->*check)(current);\\n                    current=current->right;\\n                }\\n            }\\n        }\\n    }\\n    void findFirstLastFaulty(TreeNode* node){\\n        if(previous && previous->val > node->val){\\n            if(!firstFaulty)\\n                firstFaulty=previous;\\n            lastFaulty=node;\\n        }\\n        previous=node;\\n    }\\n    void handleDuplicateValues(TreeNode *root){\\n        lastFaultyFound=false;\\n        inOrderTraversal(root, &Solution::incorporateSimilarValues);\\n    }\\n    void incorporateSimilarValues(TreeNode* node){\\n        if(!lastFaultyFound && node->val == lastFaulty->val){\\n            lastFaultyFound=true;\\n            lastFaulty=node;\\n        }\\n        if(node->val == firstFaulty->val){\\n            firstFaulty=node;\\n        }\\n    }\\n};\\n```\\n\\n**Please comment** if you have questions, want explanations or even better find some way I can improve. I hope to use this site to learn how to explain well and code clean, next to helping people understanding how to solve problems (or learning from people how to solve problems -- thanks for the folks in prior discussions mentioning Morris traversal!).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* root) {\\n        firstFaulty=lastFaulty=0;\\n        previous=0;\\n        inOrderTraversal(root, &Solution::findFirstLastFaulty);\\n        if(firstFaulty){\\n            handleDuplicateValues(root);\\n            swap(firstFaulty->val,lastFaulty->val);\\n        }\\n    }\\nprivate:\\n    TreeNode* firstFaulty;\\n    TreeNode* lastFaulty;\\n    TreeNode* previous=0;\\n    bool lastFaultyFound;\\n    \\n    void inOrderTraversal(TreeNode *root, void (Solution::*check)(TreeNode*)){\\n        TreeNode* current=root;\\n        \\n        while(current){\\n            if(! current->left){\\n                (this->*check)(current);\\n                current=current->right;\\n            }else{\\n                TreeNode* predecessor=current->left;\\n                while(predecessor->right && predecessor->right!=current){\\n                    predecessor=predecessor->right;\\n                }\\n                if(!predecessor->right){\\n                    predecessor->right=current;\\n                    current=current->left;\\n                }else{\\n                    predecessor->right=0;\\n                    (this->*check)(current);\\n                    current=current->right;\\n                }\\n            }\\n        }\\n    }\\n    void findFirstLastFaulty(TreeNode* node){\\n        if(previous && previous->val > node->val){\\n            if(!firstFaulty)\\n                firstFaulty=previous;\\n            lastFaulty=node;\\n        }\\n        previous=node;\\n    }\\n    void handleDuplicateValues(TreeNode *root){\\n        lastFaultyFound=false;\\n        inOrderTraversal(root, &Solution::incorporateSimilarValues);\\n    }\\n    void incorporateSimilarValues(TreeNode* node){\\n        if(!lastFaultyFound && node->val == lastFaulty->val){\\n            lastFaultyFound=true;\\n            lastFaulty=node;\\n        }\\n        if(node->val == firstFaulty->val){\\n            firstFaulty=node;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139057,
                "title": "simple-java-dfs-beating-100-in-time",
                "content": "```\\nclass Solution {\\n    TreeNode left=null;\\n    TreeNode right=null;\\n    TreeNode last=null;\\n    public void recoverTree(TreeNode root) {\\n        dfs(root);\\n        int temp=left.val;\\n        left.val=right.val;\\n        right.val=temp;\\n    }\\n    private void dfs(TreeNode root){\\n        if(root==null) return;\\n        dfs(root.left);\\n        if(last!=null && left==null && last.val>root.val) left=last;\\n        if(last!=null && last.val>root.val) right=root;\\n        last=root;\\n        dfs(root.right);   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode left=null;\\n    TreeNode right=null;\\n    TreeNode last=null;\\n    public void recoverTree(TreeNode root) {\\n        dfs(root);\\n        int temp=left.val;\\n        left.val=right.val;\\n        right.val=temp;\\n    }\\n    private void dfs(TreeNode root){\\n        if(root==null) return;\\n        dfs(root.left);\\n        if(last!=null && left==null && last.val>root.val) left=last;\\n        if(last!=null && last.val>root.val) right=root;\\n        last=root;\\n        dfs(root.right);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053192,
                "title": "simple-c-o-1-inorder-traversal",
                "content": "```\\nclass Solution {\\n\\n        TreeNode* prev {};\\n        TreeNode* badNode1 {};\\n        TreeNode* badNode2 {};\\n\\n        void locateBadNodes(TreeNode* node) {\\n                if(node) {\\n                        locateBadNodes(node->left);\\n                        if(prev && prev->val > node->val) {\\n                                if(!badNode1) {\\n                                        badNode1 = prev;\\n                                        badNode2 = node;\\n                                }       else {\\n                                        badNode2 = node;\\n                                        return;\\n                                }\\n                        }\\n                        prev = node;\\n                        locateBadNodes(node->right);\\n                }\\n        }\\n\\npublic:\\n\\n        void recoverTree(TreeNode* root) {\\n                        locateBadNodes(root);\\n                        if(badNode1 && badNode2) {\\n                                std::swap(badNode1->val, badNode2->val);\\n                        }\\n        }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n        TreeNode* prev {};\\n        TreeNode* badNode1 {};\\n        TreeNode* badNode2 {};\\n\\n        void locateBadNodes(TreeNode* node) {\\n                if(node) {\\n                        locateBadNodes(node->left);\\n                        if(prev && prev->val > node->val) {\\n                                if(!badNode1) {\\n                                        badNode1 = prev;\\n                                        badNode2 = node;\\n                                }       else {\\n                                        badNode2 = node;\\n                                        return;\\n                                }\\n                        }\\n                        prev = node;\\n                        locateBadNodes(node->right);\\n                }\\n        }\\n\\npublic:\\n\\n        void recoverTree(TreeNode* root) {\\n                        locateBadNodes(root);\\n                        if(badNode1 && badNode2) {\\n                                std::swap(badNode1->val, badNode2->val);\\n                        }\\n        }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918268,
                "title": "python-inorder-traverse",
                "content": "Inorder traverse the tree, store the vals of nodes into a vector. Then sort the vals and change the val of nodes in order.\\n```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n\\t    def inorder(root):\\n            if not root: return []\\n            return inorder(root.left)+[root]+inorder(root.right)\\n            \\n        v=inorder(root)\\n        vals = sorted(x.val for x in v)\\n        \\n        for i in range(len(v)):\\n            v[i].val = vals[i]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n\\t    def inorder(root):\\n            if not root: return []\\n            return inorder(root.left)+[root]+inorder(root.right)\\n            \\n        v=inorder(root)\\n        vals = sorted(x.val for x in v)\\n        \\n        for i in range(len(v)):\\n            v[i].val = vals[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917633,
                "title": "intutive-inorder-traversal",
                "content": "First time I am posting my solution:\\n\\nDo inorder traversal. Find the node whose previous value and current node is not in order. (prevElement > currElement)\\nKeep track of first node and last node encountered like this and swap them.\\n**Explanation:** \\n1.The inorder traversal of BST should always give us ascending order but not when nodes are swapped.\\n2.Now if we know the point where the order is violated, we can find the nodes which violate it and then swap them.\\n```\\nclass Solution {\\nTreeNode preNode = null;\\nTreeNode firstNode =null, secondNode =null;\\n\\npublic void recoverTree(TreeNode root) {\\n    inorderTraversal(root);\\n    int temp = firstNode.val;\\n    firstNode.val = secondNode.val;\\n    secondNode.val = temp;\\n}\\npublic void inorderTraversal(TreeNode curr) {\\n    if(curr == null)\\n        return;\\n    inorderTraversal(curr.left);\\n    //Do the work\\n    if(preNode != null) {\\n        if(preNode.val > curr.val) {\\n            if(firstNode == null) {\\n                firstNode = preNode;\\n            }\\n            secondNode = curr;\\n        }\\n    }\\n    preNode = curr;\\n    inorderTraversal(curr.right);\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nTreeNode preNode = null;\\nTreeNode firstNode =null, secondNode =null;\\n\\npublic void recoverTree(TreeNode root) {\\n    inorderTraversal(root);\\n    int temp = firstNode.val;\\n    firstNode.val = secondNode.val;\\n    secondNode.val = temp;\\n}\\npublic void inorderTraversal(TreeNode curr) {\\n    if(curr == null)\\n        return;\\n    inorderTraversal(curr.left);\\n    //Do the work\\n    if(preNode != null) {\\n        if(preNode.val > curr.val) {\\n            if(firstNode == null) {\\n                firstNode = preNode;\\n            }\\n            secondNode = curr;\\n        }\\n    }\\n    preNode = curr;\\n    inorderTraversal(curr.right);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917330,
                "title": "c-simple-inorder-traversal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&bs){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,bs);\\n        bs.push_back(root->val);\\n        inorder(root->right,bs);\\n    }\\n    void recover(TreeNode* root,int &a,int &b,TreeNode* &r){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val==a && root!=r){\\n            root->val=b;\\n            r=root;\\n        }else if(root->val==b && root!=r){\\n            root->val=a;\\n            r=root;\\n        }\\n        recover(root->left,a,b,r);\\n        recover(root->right,a,b,r);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int>bs;\\n        inorder(root,bs);\\n        int a=-1,b=-1;\\n        int count=0;\\n        for(int i=0;i<bs.size()-1;i++){\\n            if(bs[i]>bs[i+1] && count==0){\\n                a=i;\\n                count++;\\n            }else if(bs[i]>bs[i+1] && count==1){\\n                b=bs[i+1];\\n                break;\\n            }\\n        }\\n        if(b==-1){\\n            b=bs[a+1];\\n        }\\n        a=bs[a];\\n        TreeNode* r;\\n        recover(root,a,b,r);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&bs){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,bs);\\n        bs.push_back(root->val);\\n        inorder(root->right,bs);\\n    }\\n    void recover(TreeNode* root,int &a,int &b,TreeNode* &r){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->val==a && root!=r){\\n            root->val=b;\\n            r=root;\\n        }else if(root->val==b && root!=r){\\n            root->val=a;\\n            r=root;\\n        }\\n        recover(root->left,a,b,r);\\n        recover(root->right,a,b,r);\\n    }\\n    void recoverTree(TreeNode* root) {\\n        vector<int>bs;\\n        inorder(root,bs);\\n        int a=-1,b=-1;\\n        int count=0;\\n        for(int i=0;i<bs.size()-1;i++){\\n            if(bs[i]>bs[i+1] && count==0){\\n                a=i;\\n                count++;\\n            }else if(bs[i]>bs[i+1] && count==1){\\n                b=bs[i+1];\\n                break;\\n            }\\n        }\\n        if(b==-1){\\n            b=bs[a+1];\\n        }\\n        a=bs[a];\\n        TreeNode* r;\\n        recover(root,a,b,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916653,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    boolean swapped = true;\\n    public void recoverTree(TreeNode root) {\\n        while(swapped) {\\n            swapped = false;\\n            dfs(root, null, null);\\n        }\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        if(max != null) {\\n            if (root.val > max.val) {\\n                swapped = swapped || true;\\n                swap(root, max);   \\n            }\\n        }\\n        \\n        if(min != null) {\\n            if(root.val < min.val) {\\n                swapped = swapped || true;\\n                swap(root, min);\\n            }\\n        }\\n        \\n        dfs(root.left, min, root);\\n        dfs(root.right, root, max);\\n        \\n    }\\n    \\n    private void swap(TreeNode a, TreeNode b) {\\n        int tmp = a.val;\\n        a.val = b.val;\\n        b.val = tmp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean swapped = true;\\n    public void recoverTree(TreeNode root) {\\n        while(swapped) {\\n            swapped = false;\\n            dfs(root, null, null);\\n        }\\n    }\\n    \\n    public void dfs(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        if(max != null) {\\n            if (root.val > max.val) {\\n                swapped = swapped || true;\\n                swap(root, max);   \\n            }\\n        }\\n        \\n        if(min != null) {\\n            if(root.val < min.val) {\\n                swapped = swapped || true;\\n                swap(root, min);\\n            }\\n        }\\n        \\n        dfs(root.left, min, root);\\n        dfs(root.right, root, max);\\n        \\n    }\\n    \\n    private void swap(TreeNode a, TreeNode b) {\\n        int tmp = a.val;\\n        a.val = b.val;\\n        b.val = tmp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831158,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\n    TreeNode *prev = NULL;\\n    TreeNode *mistake1 = NULL, *mistake2 = NULL;\\n    \\n    void inorder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        if (prev and root->val < prev->val) {\\n            if (!mistake1)\\n                mistake1 = prev;\\n            \\n            if (mistake1)\\n                mistake2 = root;\\n        }\\n    \\n        prev = root;\\n        \\n        inorder(root->right);\\n    }\\n    \\npublic:\\n    void recoverTree(TreeNode* root) {\\n        inorder(root);\\n        \\n        swap(mistake1->val, mistake2->val);\\n        \\n        return;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    TreeNode *prev = NULL;\\n    TreeNode *mistake1 = NULL, *mistake2 = NULL;\\n    \\n    void inorder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        if (prev and root->val < prev->val) {\\n            if (!mistake1)\\n                mistake1 = prev;\\n            \\n            if (mistake1)\\n                mistake2 = root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 791960,
                "title": "intuitive-solution-explaining-no-fancy-code",
                "content": "```\\nclass Solution {\\n    /*\\n\\t\\n\\tWe know the inorder of a binary search tree is a sorted array. \\n\\t\\n    The idea is essentailly to solve the problem:\\n    Recover an almost sorted array with TWO elements swapped. Swap them back to make \\n    the array sorted. \\n    \\n\\tSo, let\\'s first get the inorder list and find the two mismatched values\\n\\t\\n    To find the two values: \\n\\tTraverse the array from left side and find the first out of order element \\n\\t(element which is bigger than next element).\\n\\tTraverse from rightmost side and find the first out of order element \\n\\t(element at i which is smaller than previous element at i-1).\\n    \\n    */\\n\\t//Time: O(N)\\n\\t//Space: O(N)\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        getInorder(root, lst);\\n        \\n        // An almost sorted array with two elements swapped\\n        int mismatch1 = 0;\\n        int mismatch2 = 0;\\n        // from left to right\\n        for(int i = 0; i < lst.size()-1; i++){\\n            if(lst.get(i) > lst.get(i+1)){\\n                mismatch1 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // from right to left\\n        for(int i = lst.size()-1; i > 0; i--){\\n            if(lst.get(i) < lst.get(i-1)){\\n                mismatch2 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // find the two nodes with val to mismatch1 and 2\\n        dfs(root, mismatch1, mismatch2);\\n        \\n        // swap the value\\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void getInorder(TreeNode root, List<Integer> lst){\\n        if(root == null) return;\\n        getInorder(root.left, lst);\\n        lst.add(root.val);\\n        getInorder(root.right, lst);\\n    }\\n    \\n    public void dfs(TreeNode root, int mismatch1, int mismatch2){\\n        if(root == null) return;\\n        if(root.val == mismatch1){\\n            m1 = root;\\n        }else if(root.val == mismatch2){\\n            m2 = root;\\n        }\\n        \\n        dfs(root.left, mismatch1, mismatch2);\\n        dfs(root.right, mismatch1, mismatch2);\\n    }\\n    \\n}\\n```\\n\\nA slightly shorter version without populating into a List.\\nSame idea but just finding two mismatch while traversing \\nin inorder forward and backward\\n\\n```\\n// Time: O(N)\\n// Space: O(1) except the recursive stack\\nclass Solution {\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    boolean foundM1 = false;\\n    boolean foundM2 = false;\\n    public void recoverTree(TreeNode root) {\\n        inorderForward(root); // forward\\n        inorderBackward(root); // backward\\n       \\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void inorderForward(TreeNode root){\\n        if(root == null) return;\\n        inorderForward(root.left);\\n        \\n        if(m1 != null && m1.val > root.val){\\n            foundM1 = true;\\n            return;\\n        }\\n        if(!foundM1)\\n            m1 = root;\\n        inorderForward(root.right);\\n    }\\n    \\n    public void inorderBackward(TreeNode root){\\n        if(root == null) return;\\n        inorderBackward(root.right);\\n        if(m2 != null && m2.val < root.val){\\n            foundM2 = true;\\n            return;\\n        }\\n       \\n        if(!foundM2)\\n            m2 = root;\\n        inorderBackward(root.left);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n\\t\\n\\tWe know the inorder of a binary search tree is a sorted array. \\n\\t\\n    The idea is essentailly to solve the problem:\\n    Recover an almost sorted array with TWO elements swapped. Swap them back to make \\n    the array sorted. \\n    \\n\\tSo, let\\'s first get the inorder list and find the two mismatched values\\n\\t\\n    To find the two values: \\n\\tTraverse the array from left side and find the first out of order element \\n\\t(element which is bigger than next element).\\n\\tTraverse from rightmost side and find the first out of order element \\n\\t(element at i which is smaller than previous element at i-1).\\n    \\n    */\\n\\t//Time: O(N)\\n\\t//Space: O(N)\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    public void recoverTree(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        getInorder(root, lst);\\n        \\n        // An almost sorted array with two elements swapped\\n        int mismatch1 = 0;\\n        int mismatch2 = 0;\\n        // from left to right\\n        for(int i = 0; i < lst.size()-1; i++){\\n            if(lst.get(i) > lst.get(i+1)){\\n                mismatch1 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // from right to left\\n        for(int i = lst.size()-1; i > 0; i--){\\n            if(lst.get(i) < lst.get(i-1)){\\n                mismatch2 = lst.get(i);\\n                break;\\n            }\\n        }\\n        \\n        // find the two nodes with val to mismatch1 and 2\\n        dfs(root, mismatch1, mismatch2);\\n        \\n        // swap the value\\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void getInorder(TreeNode root, List<Integer> lst){\\n        if(root == null) return;\\n        getInorder(root.left, lst);\\n        lst.add(root.val);\\n        getInorder(root.right, lst);\\n    }\\n    \\n    public void dfs(TreeNode root, int mismatch1, int mismatch2){\\n        if(root == null) return;\\n        if(root.val == mismatch1){\\n            m1 = root;\\n        }else if(root.val == mismatch2){\\n            m2 = root;\\n        }\\n        \\n        dfs(root.left, mismatch1, mismatch2);\\n        dfs(root.right, mismatch1, mismatch2);\\n    }\\n    \\n}\\n```\n```\\n// Time: O(N)\\n// Space: O(1) except the recursive stack\\nclass Solution {\\n    TreeNode m1 = null;\\n    TreeNode m2 = null;\\n    boolean foundM1 = false;\\n    boolean foundM2 = false;\\n    public void recoverTree(TreeNode root) {\\n        inorderForward(root); // forward\\n        inorderBackward(root); // backward\\n       \\n        int temp = m1.val;\\n        m1.val = m2.val;\\n        m2.val = temp;\\n    }\\n    \\n    public void inorderForward(TreeNode root){\\n        if(root == null) return;\\n        inorderForward(root.left);\\n        \\n        if(m1 != null && m1.val > root.val){\\n            foundM1 = true;\\n            return;\\n        }\\n        if(!foundM1)\\n            m1 = root;\\n        inorderForward(root.right);\\n    }\\n    \\n    public void inorderBackward(TreeNode root){\\n        if(root == null) return;\\n        inorderBackward(root.right);\\n        if(m2 != null && m2.val < root.val){\\n            foundM2 = true;\\n            return;\\n        }\\n       \\n        if(!foundM2)\\n            m2 = root;\\n        inorderBackward(root.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779010,
                "title": "python-in-order-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # get in-order traversal, sort, check the difference\\n        container = []\\n        def traverse(node):\\n            if not node:\\n                return\\n            traverse(node.left)\\n            container.append((node.val, node))\\n            traverse(node.right)\\n        traverse(root)\\n        target = sorted(container)\\n        for i in range(len(container)):\\n            currNode, targetNode = container[i][1], target[i][1]\\n            if currNode != targetNode:\\n                currNode.val, targetNode.val = targetNode.val, currNode.val\\n                break\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverTree(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # get in-order traversal, sort, check the difference\\n        container = []\\n        def traverse(node):\\n            if not node:\\n                return\\n            traverse(node.left)\\n            container.append((node.val, node))\\n            traverse(node.right)\\n        traverse(root)\\n        target = sorted(container)\\n        for i in range(len(container)):\\n            currNode, targetNode = container[i][1], target[i][1]\\n            if currNode != targetNode:\\n                currNode.val, targetNode.val = targetNode.val, currNode.val\\n                break\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 744137,
                "title": "simple-golang-in-order-and-pointer-based-solution",
                "content": "```\\n/*\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\".\\n\\ncc https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal\\n*/\\nfunc recoverTree(root *TreeNode)  {\\n    var prevEle,firstEle,secondEle *TreeNode\\n    firstEle,secondEle = nil,nil\\n    INT_MIN := -1*int(1e10)\\n    prevEle = &TreeNode{Val:INT_MIN,Left:nil,Right:nil}\\n    traverse(root,&prevEle,&firstEle,&secondEle)\\n    if firstEle != nil && secondEle!= nil{\\n        firstEle.Val,secondEle.Val = secondEle.Val,firstEle.Val\\n    }\\n}\\n\\nfunc traverse(root *TreeNode, prevEle,firstEle,secondEle **TreeNode) {\\n    if root==nil{\\n        return\\n    }\\n    traverse(root.Left,prevEle,firstEle,secondEle)\\n    //fmt.Println(root.Val,(*prevEle).Val,*firstEle,*secondEle)\\n    if *firstEle == nil && (*prevEle).Val >= root.Val{\\n        *firstEle = *prevEle    \\n    }\\n    if *firstEle != nil && (*prevEle).Val >= root.Val{\\n        *secondEle = root    \\n    }\\n    *prevEle = root\\n    traverse(root.Right,prevEle,firstEle,secondEle)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/*\\nWe need to find the first and second elements that are not in order right?\\n\\nHow do we find these two elements? For example, we have the following tree that is printed as in order traversal:\\n\\n6, 3, 4, 5, 2\\n\\nWe compare each node with its next one and we can find out that 6 is the first element to swap because 6 > 3 and 2 is the second element to swap because 2 < 5.\\n\\nReally, what we are comparing is the current node and its previous node in the \"in order traversal\".\\n\\ncc https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal\\n*/\\nfunc recoverTree(root *TreeNode)  {\\n    var prevEle,firstEle,secondEle *TreeNode\\n    firstEle,secondEle = nil,nil\\n    INT_MIN := -1*int(1e10)\\n    prevEle = &TreeNode{Val:INT_MIN,Left:nil,Right:nil}\\n    traverse(root,&prevEle,&firstEle,&secondEle)\\n    if firstEle != nil && secondEle!= nil{\\n        firstEle.Val,secondEle.Val = secondEle.Val,firstEle.Val\\n    }\\n}\\n\\nfunc traverse(root *TreeNode, prevEle,firstEle,secondEle **TreeNode) {\\n    if root==nil{\\n        return\\n    }\\n    traverse(root.Left,prevEle,firstEle,secondEle)\\n    //fmt.Println(root.Val,(*prevEle).Val,*firstEle,*secondEle)\\n    if *firstEle == nil && (*prevEle).Val >= root.Val{\\n        *firstEle = *prevEle    \\n    }\\n    if *firstEle != nil && (*prevEle).Val >= root.Val{\\n        *secondEle = root    \\n    }\\n    *prevEle = root\\n    traverse(root.Right,prevEle,firstEle,secondEle)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712943,
                "title": "c-concise-morris-traversal",
                "content": "We know Inorder Traversal of BST gives elements in increasing order and if a pair of elements are swapped in BST then we will have two junction points at which increasing sequence is not followed. If all elements are distinct in BST, then at those junction points first element is greater than second element(which comes just after first element in Inorder Traversal).\\n\\nIn code below flag=0 represents 1st junction point and flag=1 represents 2nd junction point, also a and b represents first and second element respectively at a junction.\\nWe need to store first element at 1st junction and second element at 2nd junction and swap them at last to correct BST.\\nFor example Inorder traversal of a BST is given **[1, 2, 3, 4, 5, 6, 7, 8]** and **3 & 7** are swapped.\\nSo sequence we will have **[1, 2, 7, 4, 5, 6, 3, 8]** making **7,4** and **6,3** two junctions. Store *needed* values in variables and swap them at 2nd junction.\\nIf **4 & 5** is swapped then the two junctions will overlap and in this we need to do swapping of variables outside while loop.\\n\\nInorder Traversal can be done using recursion or stack, but then space complexity will be O(h) where h is height of tree.\\nUse Morris Traversal to do Inorder Traversal for O(1) space complexity.\\nTime Complexity: O(n).\\n\\nSee Morris Traversal at : https://youtu.be/wGXB9OWhPTg?list=PLrmLmBdmIlpv_jNDXtJGYTPNQ2L1gdHxu\\n\\n    class Solution {\\n    public:\\n    void recoverTree(TreeNode* A) {\\n        TreeNode *root=A;\\n        TreeNode *a=NULL, *b=NULL;\\n        int flag=0;\\n        TreeNode *l, *r;\\n        \\n        while(root){\\n            if(root->left==NULL){\\n                a=b;\\n                b=root;\\n                \\n                if(a && b && flag==0 && a->val>b->val){\\n                    l=a;\\n                    r=b;\\n                    flag=1;\\n                }\\n                else if(a && b && flag==1 && a->val>b->val){\\n                    r=b;\\n                    swap(l->val,r->val);\\n                    flag=2;\\n                }\\n                \\n                root=root->right;\\n            }\\n            else{\\n                TreeNode* pred=root->left;\\n                while(pred->right!=root && pred->right!=NULL){\\n                    pred=pred->right;\\n                }\\n                \\n                if(pred->right==NULL){\\n                    pred->right=root;\\n                    root=root->left;\\n                }\\n                else{\\n                    pred->right=NULL;\\n                    a=b;\\n                    b=root;\\n\\n                    if(a && b && flag==0 && a->val>b->val){\\n                        l=a;\\n                        r=b;\\n                        flag=1;\\n                    }\\n                    else if(a && b && flag==1 && a->val>b->val){\\n                        r=b;\\n                        swap(l->val,r->val);\\n                        flag=2;\\n                    }\\n                    \\n                    root=root->right;\\n                }\\n            }\\n        }\\n        \\n        if(flag==1) swap(l->val,r->val);\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    void recoverTree(TreeNode* A) {\\n        TreeNode *root=A;\\n        TreeNode *a=NULL, *b=NULL;\\n        int flag=0;\\n        TreeNode *l, *r;\\n        \\n        while(root){\\n            if(root->left==NULL){\\n                a=b;\\n                b=root;\\n                \\n                if(a && b && flag==0 && a->val>b->val){\\n                    l=a;\\n                    r=b;\\n                    flag=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 544391,
                "title": "go-inorder-traversal-solution",
                "content": "```\\nfunc recoverTree(root *TreeNode) {\\n\\tvar first, second, prev *TreeNode\\n\\ttraverse(root, &first, &second, &prev)\\n\\tfirst.Val, second.Val = second.Val, first.Val\\n}\\n\\nfunc traverse(root *TreeNode, first, second, prev **TreeNode) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\ttraverse(root.Left, first, second, prev)\\n\\tif *prev != nil && (*prev).Val >= root.Val {\\n\\t\\tif *first == nil {\\n\\t\\t\\t*first = *prev\\n\\t\\t}\\n\\t\\t*second = root\\n\\t}\\n\\t*prev = root\\n\\ttraverse(root.Right, first, second, prev)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc recoverTree(root *TreeNode) {\\n\\tvar first, second, prev *TreeNode\\n\\ttraverse(root, &first, &second, &prev)\\n\\tfirst.Val, second.Val = second.Val, first.Val\\n}\\n\\nfunc traverse(root *TreeNode, first, second, prev **TreeNode) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\ttraverse(root.Left, first, second, prev)\\n\\tif *prev != nil && (*prev).Val >= root.Val {\\n\\t\\tif *first == nil {\\n\\t\\t\\t*first = *prev\\n\\t\\t}\\n\\t\\t*second = root\\n\\t}\\n\\t*prev = root\\n\\ttraverse(root.Right, first, second, prev)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489570,
                "title": "java-solution-2ms-beats-90-java-submissions",
                "content": "My approach is simple I maintain two nodes (First and sec) and a node to keep track of prev Node.\\nWhenever I have prev node and value in prev is > val of current node (In Inorder Traversal) I check if I have first node == null or not.. If i have first == null -> I make sure first node will be prev (as prev.val > cur_node.val) and also i keep track of sec, make sec = cur_node\\n**Time Complexity -> O(N)**\\n**Space Complexity -> O(h) where h - height of BST O(logN)**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode first;\\n    public TreeNode sec;\\n    public TreeNode prev;\\n    public void recover(TreeNode root) {\\n        if (root == null) return;\\n        // go to left side \\n        recover(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            if (first == null) {\\n                first = prev;\\n            }\\n            sec = root;\\n        }\\n        prev = root;\\n        // go to right side\\n        recover(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        // swap the nodes\\n        if (first != null) {\\n            int tmp = first.val;\\n            first.val = sec.val;\\n            sec.val = tmp;\\n        }\\n    }\\n}\\n**Here is my code for swapping two nodes to correct a BST**\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode first;\\n    public TreeNode sec;\\n    public TreeNode prev;\\n    public void recover(TreeNode root) {\\n        if (root == null) return;\\n        // go to left side \\n        recover(root.left);\\n        if (prev != null && prev.val > root.val) {\\n            if (first == null) {\\n                first = prev;\\n            }\\n            sec = root;\\n        }\\n        prev = root;\\n        // go to right side\\n        recover(root.right);\\n    }\\n    public void recoverTree(TreeNode root) {\\n        recover(root);\\n        // swap the nodes\\n        if (first != null) {\\n            int tmp = first.val;\\n            first.val = sec.val;\\n            sec.val = tmp;\\n        }\\n    }\\n}\\n**Here is my code for swapping two nodes to correct a BST**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466643,
                "title": "2ms-java-solution-96-5-with-explanation",
                "content": "Let\\'s start with hypothesis that one swapped element is in the left subtree and another is in the right subtree.  In a valid BST we expect largest element in left subtree should be less than smallest element in the right subtree.  Let\\'s find largest element on the left and smallest element on the right.\\nIf largest on the left is larger than smallest on the right - congrats  - we have found two anomalies, let\\'s swap them and we are done.  If not, let\\'s check hypotehsis that root is one of the swapped elements, by checking the largest and smallest in subtrees against the root.  If the hypothesis that root is one of the swapped elements turns out to be wrong as well, the swap has happened in one of the subtrees, either in the left or right, so we apply our method recursively to left and right subtrees.\\n\\n```\\nclass Solution {\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root== null) {\\n            return;\\n        }\\n        TreeNode largest = findLargest(root.left, root);\\n        TreeNode smallest = findSmallest(root.right, root);       \\n        if (largest.val > smallest.val) {  //two anomalies are found\\n            swap(largest, smallest);\\n        } else if (smallest.val < root.val) { //root is one of the swapped elements\\n            swap(root, smallest);\\n        } else if (largest.val > root.val) {  //root is one of the swapped elements\\n            swap(largest, root); \\n        } else {  // swap has happened in one of the subtrees\\n            recoverTree(root.left);\\n            recoverTree(root.right);\\n        }\\n    }\\n    \\n\\n        \\n    TreeNode findLargest(TreeNode root, TreeNode max) {\\n        if (root==null) return max;\\n        if (root.val > max.val) {\\n            max = root;\\n        }\\n        TreeNode left = findLargest(root.left, max);\\n        if (left.val > max.val) {\\n            max = left;\\n        }\\n        TreeNode right = findLargest(root.right, max);\\n        if (right.val > max.val) {\\n            max = right;\\n        }\\n        return max;\\n    }\\n    \\n    TreeNode findSmallest(TreeNode root, TreeNode min) {\\n        if (root==null) return min;\\n        if (root.val < min.val) {\\n            min = root;\\n        }\\n        TreeNode left = findSmallest(root.left, min);\\n        if (left.val < min.val) {\\n            min = left;\\n        }\\n        TreeNode right = findSmallest(root.right, min);\\n        if (right.val < min.val) {\\n            min = right;\\n        }\\n        return min;\\n    }\\n    \\n    void swap(TreeNode a, TreeNode b) {\\n        int temp  = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public void recoverTree(TreeNode root) {\\n        if (root== null) {\\n            return;\\n        }\\n        TreeNode largest = findLargest(root.left, root);\\n        TreeNode smallest = findSmallest(root.right, root);       \\n        if (largest.val > smallest.val) {  //two anomalies are found\\n            swap(largest, smallest);\\n        } else if (smallest.val < root.val) { //root is one of the swapped elements\\n            swap(root, smallest);\\n        } else if (largest.val > root.val) {  //root is one of the swapped elements\\n            swap(largest, root); \\n        } else {  // swap has happened in one of the subtrees\\n            recoverTree(root.left);\\n            recoverTree(root.right);\\n        }\\n    }\\n    \\n\\n        \\n    TreeNode findLargest(TreeNode root, TreeNode max) {\\n        if (root==null) return max;\\n        if (root.val > max.val) {\\n            max = root;\\n        }\\n        TreeNode left = findLargest(root.left, max);\\n        if (left.val > max.val) {\\n            max = left;\\n        }\\n        TreeNode right = findLargest(root.right, max);\\n        if (right.val > max.val) {\\n            max = right;\\n        }\\n        return max;\\n    }\\n    \\n    TreeNode findSmallest(TreeNode root, TreeNode min) {\\n        if (root==null) return min;\\n        if (root.val < min.val) {\\n            min = root;\\n        }\\n        TreeNode left = findSmallest(root.left, min);\\n        if (left.val < min.val) {\\n            min = left;\\n        }\\n        TreeNode right = findSmallest(root.right, min);\\n        if (right.val < min.val) {\\n            min = right;\\n        }\\n        return min;\\n    }\\n    \\n    void swap(TreeNode a, TreeNode b) {\\n        int temp  = a.val;\\n        a.val = b.val;\\n        b.val = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319748,
                "title": "swift-100-beaten-using-van-morrison-traversal-o-n-lewptie-lewpz",
                "content": "The harder you lewp, the more you poop.\\n\\n```\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        \\n        var node: TreeNode! = root\\n        var prev: TreeNode!\\n        var parent: TreeNode!\\n        \\n        var swap1: TreeNode!\\n        var swap2: TreeNode!\\n        \\n        while node !== nil {\\n            \\n            if node.left === nil {\\n                if parent !== nil && node !== nil && parent.val > node.val {\\n                    if swap1 == nil { swap1 = parent }\\n                    swap2 = node\\n                }\\n                \\n                parent = node\\n                node = node.right\\n            } else {\\n                \\n                prev = node.left\\n                while prev.right !== nil && prev.right !== node { prev = prev.right }\\n                \\n                if prev.right === nil {\\n                    prev.right = node\\n                    node = node.left\\n                } else {\\n                    if parent !== nil && node !== nil && parent.val > node.val {\\n                        if swap1 == nil { swap1 = parent }\\n                        swap2 = node\\n                    }\\n                    parent = node\\n                    node = node.right\\n                    prev.right = nil\\n                }\\n            }\\n        }\\n        \\n        if swap1 !== nil && swap2 !== nil {\\n            var hold = swap1.val\\n            swap1.val = swap2.val\\n            swap2.val = hold\\n        }\\n    }\\n}\\n```\\n\\nKaboom, baby. We got the nukez.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func recoverTree(_ root: TreeNode?) {\\n        \\n        var node: TreeNode! = root\\n        var prev: TreeNode!\\n        var parent: TreeNode!\\n        \\n        var swap1: TreeNode!\\n        var swap2: TreeNode!\\n        \\n        while node !== nil {\\n            \\n            if node.left === nil {\\n                if parent !== nil && node !== nil && parent.val > node.val {\\n                    if swap1 == nil { swap1 = parent }\\n                    swap2 = node\\n                }\\n                \\n                parent = node\\n                node = node.right\\n            } else {\\n                \\n                prev = node.left\\n                while prev.right !== nil && prev.right !== node { prev = prev.right }\\n                \\n                if prev.right === nil {\\n                    prev.right = node\\n                    node = node.left\\n                } else {\\n                    if parent !== nil && node !== nil && parent.val > node.val {\\n                        if swap1 == nil { swap1 = parent }\\n                        swap2 = node\\n                    }\\n                    parent = node\\n                    node = node.right\\n                    prev.right = nil\\n                }\\n            }\\n        }\\n        \\n        if swap1 !== nil && swap2 !== nil {\\n            var hold = swap1.val\\n            swap1.val = swap2.val\\n            swap2.val = hold\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319133,
                "title": "c-using-morrison-traversal-o-n-no-recursion-no-bad-looping",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode *aNode = root;\\n        TreeNode *aPrev = NULL;\\n        TreeNode *aParent = NULL;\\n        \\n        TreeNode *aSwap1 = NULL;\\n        TreeNode *aSwap2 = NULL;\\n        \\n        while (aNode != NULL) {\\n            \\n            if (!aNode->left) {\\n                \\n                if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                    if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                    aSwap2 = aNode;\\n                }\\n                \\n                aParent = aNode;\\n                aNode = aNode->right;\\n            } else {\\n             \\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                \\n                if (aPrev->right == NULL) {\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                } else {\\n                    aPrev->right = NULL;\\n                    if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                        if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                        aSwap2 = aNode;\\n                    }\\n                    aParent = aNode;\\n                    aNode = aNode->right;\\n                }\\n            }\\n        }\\n        if (aSwap1 != NULL && aSwap2 != NULL) { swap(aSwap1->val, aSwap2->val); }\\n    }\\n    \\n    \\n};\\n```\\n\\nKaboom, awesome. Enjoy.",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        TreeNode *aNode = root;\\n        TreeNode *aPrev = NULL;\\n        TreeNode *aParent = NULL;\\n        \\n        TreeNode *aSwap1 = NULL;\\n        TreeNode *aSwap2 = NULL;\\n        \\n        while (aNode != NULL) {\\n            \\n            if (!aNode->left) {\\n                \\n                if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                    if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                    aSwap2 = aNode;\\n                }\\n                \\n                aParent = aNode;\\n                aNode = aNode->right;\\n            } else {\\n             \\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                \\n                if (aPrev->right == NULL) {\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                } else {\\n                    aPrev->right = NULL;\\n                    if (aParent != NULL && aNode != NULL && aParent->val > aNode->val) {\\n                        if (aSwap1 == NULL) { aSwap1 = aParent; }\\n                        aSwap2 = aNode;\\n                    }\\n                    aParent = aNode;\\n                    aNode = aNode->right;\\n                }\\n            }\\n        }\\n        if (aSwap1 != NULL && aSwap2 != NULL) { swap(aSwap1->val, aSwap2->val); }\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317222,
                "title": "java-inorder-traversal",
                "content": "Simple Java traversal.\\n\\n   \\n\\tpublic void recoverTree(TreeNode root) {\\n       \\n\\t    if (root == null) return;\\n\\t\\t\\n        TreeNode n1 = null, n2 = null;\\n        TreeNode last = null;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while (root != null) {\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            TreeNode cur = stack.pop();\\n            if (last != null) {\\n                if (cur.val < last.val) {\\n                    n2 = cur;\\n                    if (n1 == null) n1 = last;\\n                }\\n            }\\n            last = cur;\\n            if (cur.right != null) {\\n                cur = cur.right;\\n                while (cur != null) {\\n                    stack.push(cur);\\n                    cur = cur.left;\\n                }\\n            } else {\\n                while (!stack.isEmpty() && stack.peek().right == cur) {\\n                    cur = stack.pop();\\n                }\\n            }\\n        }\\n        \\n        int temp = n1.val;\\n        n1.val = n2.val;\\n        n2.val = temp;\\n    }",
                "solutionTags": [],
                "code": "Simple Java traversal.\\n\\n   \\n\\tpublic void recoverTree(TreeNode root) {\\n       \\n\\t    if (root == null) return;\\n\\t\\t\\n        TreeNode n1 = null, n2 = null;\\n        TreeNode last = null;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while (root != null) {\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        \\n        while (!stack.isEmpty()) {\\n            TreeNode cur = stack.pop();\\n            if (last != null) {\\n                if (cur.val < last.val) {\\n                    n2 = cur;\\n                    if (n1 == null) n1 = last;\\n                }\\n            }\\n            last = cur;\\n            if (cur.right != null) {\\n                cur = cur.right;\\n                while (cur != null) {\\n                    stack.push(cur);\\n                    cur = cur.left;\\n                }\\n            } else {\\n                while (!stack.isEmpty() && stack.peek().right == cur) {\\n                    cur = stack.pop();\\n                }\\n            }\\n        }\\n        \\n        int temp = n1.val;\\n        n1.val = n2.val;\\n        n2.val = temp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 295724,
                "title": "java-solution-with-explanation",
                "content": "**Idea**\\nIt is not hard to see that in-order traversal on BST should reveal misplaced elements. But the key point to understand is how do you judge which elements are misplaced when you do in-order since you only have min element to compare curr with and no max.\\nThat is, say BST min property violated at  `curr`, we found the first element (`min`) that is misplaced.\\nIf there is another element violating min property, then we found the two elements we need (`val1` is `min` identified eralier and `val2` is `curr`). But there could be a case, you do not see another element violating min property. In that case, both `min` and `curr` when we saw min property violated must be the elements swapped For ex: `[3,1,4,null,null,2]`.\\n\\n```\\nclass Solution {\\n    TreeNode val1 = null, val2 = null;\\n    TreeNode min = null;\\n    public void recoverTree(TreeNode root) {\\n        walk(root);\\n        int tmp = val1.val;\\n        val1.val = val2.val;\\n        val2.val = tmp;\\n    }\\n    private void walk(TreeNode curr){\\n        if(curr == null) return;\\n        walk(curr.left);\\n        if(min != null && curr.val < min.val){\\n            if(val1 == null){\\n                val1 = min;\\n                val2 = curr;\\n            }else\\n                val2 = curr; //override previous val2 since there are only two misplaced elems\\n        }\\n        min = curr;\\n        walk(curr.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode val1 = null, val2 = null;\\n    TreeNode min = null;\\n    public void recoverTree(TreeNode root) {\\n        walk(root);\\n        int tmp = val1.val;\\n        val1.val = val2.val;\\n        val2.val = tmp;\\n    }\\n    private void walk(TreeNode curr){\\n        if(curr == null) return;\\n        walk(curr.left);\\n        if(min != null && curr.val < min.val){\\n            if(val1 == null){\\n                val1 = min;\\n                val2 = curr;\\n            }else\\n                val2 = curr; //override previous val2 since there are only two misplaced elems\\n        }\\n        min = curr;\\n        walk(curr.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229230,
                "title": "python-in-order-traversal",
                "content": "Inspired by the brilient solution and explanation from @qwl5004 ([Link](https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal)). Here is the python version of the solution:\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.prevEle = TreeNode(-float(\\'inf\\'))\\n        self.firstEle = None\\n        self.secondEle = None\\n    \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if not self.firstEle and (root.val < self.prevEle.val):\\n            self.firstEle = self.prevEle\\n        if self.firstEle and (root.val < self.prevEle.val):\\n            self.secondEle = root\\n        \\n        self.prevEle = root\\n        self.inOrder(root.right)\\n    \\n    \\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        self.inOrder(root)\\n        if not self.firstEle or not self.secondEle:\\n            return\\n        self.firstEle.val, self.secondEle.val = self.secondEle.val, self.firstEle.val\\n        return\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.prevEle = TreeNode(-float(\\'inf\\'))\\n        self.firstEle = None\\n        self.secondEle = None\\n    \\n    def inOrder(self, root):\\n        if not root:\\n            return\\n        self.inOrder(root.left)\\n        \\n        if not self.firstEle and (root.val < self.prevEle.val):\\n            self.firstEle = self.prevEle\\n        if self.firstEle and (root.val < self.prevEle.val):\\n            self.secondEle = root\\n        \\n        self.prevEle = root\\n        self.inOrder(root.right)\\n    \\n    \\n    def recoverTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: void Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        self.inOrder(root)\\n        if not self.firstEle or not self.secondEle:\\n            return\\n        self.firstEle.val, self.secondEle.val = self.secondEle.val, self.firstEle.val\\n        return\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567676,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1565658,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1723131,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1566715,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1567858,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1787057,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575663,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1568921,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575958,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1572172,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1567676,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1565658,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1723131,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1566715,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1567858,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1787057,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575663,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1568921,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1575958,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1572172,
                "content": [
                    {
                        "username": "cusion",
                        "content": "what I came up with directly was a recursion, but I think this is actually an O(N) solution, so I struggled to find an O(1) solution. After I gave up and look around in discussion, I found everyone take recursion as O(1) space, this is kinda surprising. Recursion in my opinion is even more eager for memory than stack, and in the worst case, stack would store all nodes in order to do backtrace, so isn\\'t recursion an O(N) solution?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I believe the recursive call stack will be at most equal to the height of the tree. In the worst case where your BST degenerated into a singly linked list, it could be O(n) indeed, but for a well-balanced tree, it should be limited to O(logn) in average.\nBut I agree with you, a recursive solution is never O(1) space"
                    },
                    {
                        "username": "sftrytry",
                        "content": "You need a stack to do traversing. Either it is manual stack or system recursive one, it is O(log N) at least."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "There are O(1) tree traversals that do not use a stack, but instead move pointers around in cleaver ways. As long as you put the pointers back, you will be able to solve this problem in O(1) space just fine."
                    },
                    {
                        "username": "XOFJO",
                        "content": "if you do follow-up, this is a hard question"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/recover-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sort an Almost Sorted Array Where Two Elements Are Swapped\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Morris Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I noticed that most of the algorithms I've found assume that there are no duplicate values in the BST, which make it trivial to find two swapped elements.  However, how to find the swapped elements if there are duplicates in the BST? \\n\\nThanks."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Tree is jungle now, It\\'s too late to answer buddy!"
                    },
                    {
                        "username": "klinerr1",
                        "content": "[@jaredtewodros](/jaredtewodros) a BST can have duplicates. just in leetcode meta its typical to not allow them because it would break the puzzle. You need to definately check to see what kind of BST youre working with."
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "By definition, duplicates are not allowed in a BST. At least in most definitions I've seen, so I assumed this question followed suit. Would be a good clarifying question in an interview."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "the inorder traversal of bst is a sorted array.use that to your advantage."
                    },
                    {
                        "username": "Vikasss_7663",
                        "content": "Three cases for inorder traversal :\\ncase 1 : All are in ascending order\\nNo need to do anything\\nexample - [1, 2, 3, 4, 5]\\n\\ncase 2 : one pair is in descending order\\nswap both pairs\\nexample - [**2**, **1**, 3, 4, 5]\\n\\ncase 3 : two pairs are in descending order\\nswap first pair\\'s first value and second pair\\'s second value\\nexample - [**5**, **2**, 3, **4**, **1**]"
                    },
                    {
                        "username": "Charles_p",
                        "content": "As far as I know, there are more than one definition of BST, the differences of which are mainly about duplicate nodes. \\nDoes the BST include duplicate nodes? If it does, place the duplicate nodes to the left child or the right child?"
                    },
                    {
                        "username": "delcin",
                        "content": "For the case [2,3,1] two possible solutions are available.\\nSwap  3 and 1 or swap 2 and 3. But the latter is marked as wrong.\\nIt does not say we have to return correct inorder traversal in the question,"
                    },
                    {
                        "username": "jaredtewodros",
                        "content": "[@ajit_2828](/ajit_2828) This is correct. Swapping 2 and 3 would leave 3 as the root with 2 as its left child. This would still not be a valid BST because the new root 3 is great than its right child 1."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "swapping (3,1) is a only valid option here"
                    },
                    {
                        "username": "EMhacker",
                        "content": "IMHO, preorder serialization of binary trees are: parent -> left-subtree -> right-subtree, nulls included.\\nThus the tree\\n 1\\n  /\\n 3\\n  \\\\\\n   2\\n\\nshould be serialized as: [1, 3, null, 2, null, null, null] and not as suggested in the problem description.\\n"
                    }
                ]
            },
            {
                "id": 1963829,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1572798,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1572032,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1571212,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2071864,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2049985,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2027652,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2026209,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 2004429,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            },
            {
                "id": 1991777,
                "content": [
                    {
                        "username": "RaviSaini045",
                        "content": "BRUTE FORCE  ==> inorder nikalo -> sort inorder -> modify tree according sorted inorder"
                    },
                    {
                        "username": "chinmayncsu",
                        "content": "Some of the tests are failing in leetcode, while they work fine in Visual Studio"
                    },
                    {
                        "username": "kkkfei",
                        "content": "think Binary Search Tree as a sorted array"
                    },
                    {
                        "username": "benjaminlin",
                        "content": "here is the test case my code failed:\\n\\n\\t{146,71,-13,55,#,231,399,321,#,#,#,#,#,-33}\\n\\nthe answer is swapping 321 and -13, however -33 is on the left node of 399, that is also a wrong placement. \\n\\nNot sure if anyone running into same issue? or I interpreted the input wrong?\\n\\nthanks"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "My brute approach using inorder traversal is getting solution better than 90% wth. "
                    },
                    {
                        "username": "vaclavkosar",
                        "content": "The example 1 seems invalid. Because the left subtree of 2 is not smaller than nodes value 1, no? Can anybody comment?\\n```\\n     3\\n   /\\n1\\n  \\\\\\n    2\\n```"
                    },
                    {
                        "username": "vishwajeetfr",
                        "content": "return type is void?\\nhow do I return my answer?"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I understand the premise and know an approach to take, but how to return the output? The problem says we cannot modify the tree structure yet does not allow us to return anything from the main function"
                    },
                    {
                        "username": "Karilli",
                        "content": "you are supposed to swap the val attribute of those two nodes. not modifying the structure means dont touch left and right. it is wierdly worded, i didnt got it from the description either"
                    },
                    {
                        "username": "Tejas_0101",
                        "content": "Will interviewer ask Morris Traversal ?"
                    },
                    {
                        "username": "Karilli",
                        "content": "omfg, I thought that I am supposed to swap the nodes, but you are only suppossed to swap the values. That was so much pain..."
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Right Side View",
        "question_content": "<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 401px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5,null,4]\n<strong>Output:</strong> [1,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3]\n<strong>Output:</strong> [1,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 56012,
                "title": "my-simple-accepted-solution-java",
                "content": "The core idea of this algorithm: \\n\\n1.Each depth of the tree only select one node.  \\n2. View depth is current size of result list.\\n\\nHere is the code: \\n\\n    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            rightView(root, result, 0);\\n            return result;\\n        }\\n        \\n        public void rightView(TreeNode curr, List<Integer> result, int currDepth){\\n            if(curr == null){\\n                return;\\n            }\\n            if(currDepth == result.size()){\\n                result.add(curr.val);\\n            }\\n            \\n            rightView(curr.right, result, currDepth + 1);\\n            rightView(curr.left, result, currDepth + 1);\\n            \\n        }\\n    }\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            rightView(root, result, 0);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56003,
                "title": "my-c-solution-modified-preorder-traversal",
                "content": "    class Solution {\\n    public:\\n        void recursion(TreeNode *root, int level, vector<int> &res)\\n        {\\n            if(root==NULL) return ;\\n            if(res.size()<level) res.push_back(root->val);\\n            recursion(root->right, level+1, res);\\n            recursion(root->left, level+1, res);\\n        }\\n        \\n        vector<int> rightSideView(TreeNode *root) {\\n            vector<int> res;\\n            recursion(root, 1, res);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void recursion(TreeNode *root, int level, vector<int> &res)\\n        {\\n            if(root==NULL) return ;\\n            if(res.size()<level) res.push_back(root->val);\\n            recursion(root->right, level+1, res);\\n            recursion(root->left, level+1, res);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56064,
                "title": "5-9-lines-python-48-ms",
                "content": "Solution 1: **Recursive, combine right and left:** 5 lines, 56 ms\\n\\nCompute the right view of both right and left left subtree, then combine them. For very unbalanced trees, this can be O(n^2), though.\\n\\n    def rightSideView(self, root):\\n        if not root:\\n            return []\\n        right = self.rightSideView(root.right)\\n        left = self.rightSideView(root.left)\\n        return [root.val] + right + left[len(right):]\\n\\n---\\n\\nSolution 2: **Recursive, first come first serve:** 9 lines, 48 ms\\n\\nDFS-traverse the tree right-to-left, add values to the view whenever we first reach a new record depth. This is O(n).\\n\\n    def rightSideView(self, root):\\n        def collect(node, depth):\\n            if node:\\n                if depth == len(view):\\n                    view.append(node.val)\\n                collect(node.right, depth+1)\\n                collect(node.left, depth+1)\\n        view = []\\n        collect(root, 0)\\n        return view\\n\\n---\\n\\nSolution 3: **Iterative, level-by-level:** 7 lines, 48 ms\\n\\nTraverse the tree level by level and add the last value of each level to the view. This is O(n).\\n\\n    def rightSideView(self, root):\\n        view = []\\n        if root:\\n            level = [root]\\n            while level:\\n                view += level[-1].val,\\n                level = [kid for node in level for kid in (node.left, node.right) if kid]\\n        return view",
                "solutionTags": [
                    "Python"
                ],
                "code": "Solution 1: **Recursive, combine right and left:** 5 lines, 56 ms\\n\\nCompute the right view of both right and left left subtree, then combine them. For very unbalanced trees, this can be O(n^2), though.\\n\\n    def rightSideView(self, root):\\n        if not root:\\n            return []\\n        right = self.rightSideView(root.right)\\n        left = self.rightSideView(root.left)\\n        return [root.val] + right + left[len(right):]\\n\\n---\\n\\nSolution 2: **Recursive, first come first serve:** 9 lines, 48 ms\\n\\nDFS-traverse the tree right-to-left, add values to the view whenever we first reach a new record depth. This is O(n).\\n\\n    def rightSideView(self, root):\\n        def collect(node, depth):\\n            if node:\\n                if depth == len(view):\\n                    view.append(node.val)\\n                collect(node.right, depth+1)\\n                collect(node.left, depth+1)\\n        view = []\\n        collect(root, 0)\\n        return view\\n\\n---\\n\\nSolution 3: **Iterative, level-by-level:** 7 lines, 48 ms\\n\\nTraverse the tree level by level and add the last value of each level to the view. This is O(n).\\n\\n    def rightSideView(self, root):\\n        view = []\\n        if root:\\n            level = [root]\\n            while level:\\n                view += level[-1].val,\\n                level = [kid for node in level for kid in (node.left, node.right) if kid]\\n        return view",
                "codeTag": "Python3"
            },
            {
                "id": 56076,
                "title": "reverse-level-order-traversal-java",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            // reverse level traversal\\n            List<Integer> result = new ArrayList();\\n            Queue<TreeNode> queue = new LinkedList();\\n            if (root == null) return result;\\n            \\n            queue.offer(root);\\n            while (queue.size() != 0) {\\n                int size = queue.size();\\n                for (int i=0; i<size; i++) {\\n                    TreeNode cur = queue.poll();\\n                    if (i == 0) result.add(cur.val);\\n                    if (cur.right != null) queue.offer(cur.right);\\n                    if (cur.left != null) queue.offer(cur.left);\\n                }\\n                \\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            // reverse level traversal\\n            List<Integer> result = new ArrayList();\\n            Queue<TreeNode> queue = new LinkedList();\\n            if (root == null) return result;\\n            \\n            queue.offer(root);\\n            while (queue.size() != 0) {\\n                int size = queue.size();\\n                for (int i=0; i<size; i++) {\\n                    TreeNode cur = queue.poll();\\n                    if (i == 0) result.add(cur.val);\\n                    if (cur.right != null) queue.offer(cur.right);\\n                    if (cur.left != null) queue.offer(cur.left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3176211,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        queue<TreeNode*> q;\\n        if(root==NULL)\\n        return ans;\\n        q.push(root);\\n        while(1)\\n        {\\n            int size=q.size();\\n            if(size==0)\\n            return ans;\\n            vector<int> data;\\n            while(size--)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                data.push_back(temp->val);\\n                if(temp->left!=NULL)\\n                q.push(temp->left);\\n                if(temp->right!=NULL)\\n                q.push(temp->right);\\n            }\\n            ans.push_back(data.back());\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        queue = deque()\\n        if root is None:\\n            return []\\n        \\n        if root.left is None and root.right is None:\\n            return [root.val]\\n        \\n        result = []\\n        queue.append(root)\\n        while queue:\\n            child_queue = deque()\\n            prev = -1\\n            while queue:\\n                curr = queue.popleft()\\n\\n                if curr.left is not None:\\n                    child_queue.append(curr.left)\\n\\n                if curr.right is not None:\\n                    child_queue.append(curr.right)\\n                \\n                prev = curr\\n            \\n            result.append(prev.val)\\n            queue = child_queue\\n        \\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n    int maxlevel = 0;\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list  = new ArrayList<>();\\n        right(root,1,list);\\n        return list ;\\n    }\\n    void right(TreeNode root,int level,List<Integer> list){\\n        if(root==null){\\n            return ;\\n        }\\n        if(maxlevel<level){\\n            list.add(root.val);\\n            maxlevel=level;\\n        }\\n        right(root.right,level+1,list);\\n        right(root.left,level+1,list);\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        queue<TreeNode*> q;\\n        if(root==NULL)\\n        return ans;\\n        q.push(root);\\n        while(1)\\n        {\\n            int size=q.size();\\n            if(size==0)\\n            return ans;\\n            vector<int> data;\\n            while(size--)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                data.push_back(temp->val);\\n                if(temp->left!=NULL)\\n                q.push(temp->left);\\n                if(temp->right!=NULL)\\n                q.push(temp->right);\\n            }\\n            ans.push_back(data.back());\\n        }\\n    }\\n};\\n```\n```Python3 []\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        queue = deque()\\n        if root is None:\\n            return []\\n        \\n        if root.left is None and root.right is None:\\n            return [root.val]\\n        \\n        result = []\\n        queue.append(root)\\n        while queue:\\n            child_queue = deque()\\n            prev = -1\\n            while queue:\\n                curr = queue.popleft()\\n\\n                if curr.left is not None:\\n                    child_queue.append(curr.left)\\n\\n                if curr.right is not None:\\n                    child_queue.append(curr.right)\\n                \\n                prev = curr\\n            \\n            result.append(prev.val)\\n            queue = child_queue\\n        \\n        return result\\n```\n```Java []\\nclass Solution {\\n    int maxlevel = 0;\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list  = new ArrayList<>();\\n        right(root,1,list);\\n        return list ;\\n    }\\n    void right(TreeNode root,int level,List<Integer> list){\\n        if(root==null){\\n            return ;\\n        }\\n        if(maxlevel<level){\\n            list.add(root.val);\\n            maxlevel=level;\\n        }\\n        right(root.right,level+1,list);\\n        right(root.left,level+1,list);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56241,
                "title": "c-bfs-dfs",
                "content": "BFS (level-order traversal) is a good fit to this problem: just add the last node in each level to the result.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<int> view;\\n        queue<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                TreeNode* node = todo.front();\\n                todo.pop();\\n                if (i == n - 1) {\\n                    view.push_back(node -> val);\\n                }\\n                if (node -> left) {\\n                    todo.push(node -> left);\\n                }\\n                if (node -> right) {\\n                    todo.push(node -> right);\\n                }\\n            }\\n        }\\n        return view;\\n    }\\n};\\n```\\n\\nIt can also be solved using DFS.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> view;\\n        rightView(root, view, 0);\\n        return view;\\n    }\\nprivate:\\n    void rightView(TreeNode* root, vector<int>& view, int level) {\\n        if (!root) {\\n            return;\\n        }\\n        if (view.size() == level) {\\n            view.push_back(root -> val);\\n        }\\n        rightView(root -> right, view, level + 1);\\n        rightView(root -> left, view, level + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<int> view;\\n        queue<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                TreeNode* node = todo.front();\\n                todo.pop();\\n                if (i == n - 1) {\\n                    view.push_back(node -> val);\\n                }\\n                if (node -> left) {\\n                    todo.push(node -> left);\\n                }\\n                if (node -> right) {\\n                    todo.push(node -> right);\\n                }\\n            }\\n        }\\n        return view;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> view;\\n        rightView(root, view, 0);\\n        return view;\\n    }\\nprivate:\\n    void rightView(TreeNode* root, vector<int>& view, int level) {\\n        if (!root) {\\n            return;\\n        }\\n        if (view.size() == level) {\\n            view.push_back(root -> val);\\n        }\\n        rightView(root -> right, view, level + 1);\\n        rightView(root -> left, view, level + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56248,
                "title": "python-easy-to-understand-bfs-solution-level-by-level",
                "content": "```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        deque = collections.deque()\\n        if root:\\n            deque.append(root)\\n        res = []\\n        while deque:\\n            size, val = len(deque), 0\\n            for _ in range(size):\\n                node = deque.popleft()\\n                val = node.val # store last value in each level\\n                if node.left:\\n                    deque.append(node.left)\\n                if node.right:\\n                    deque.append(node.right)\\n            res.append(val)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        deque = collections.deque()\\n        if root:\\n            deque.append(root)\\n        res = []\\n        while deque:\\n            size, val = len(deque), 0\\n            for _ in range(size):\\n                node = deque.popleft()\\n                val = node.val # store last value in each level\\n                if node.left:\\n                    deque.append(node.left)\\n                if node.right:\\n                    deque.append(node.right)\\n            res.append(val)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266055,
                "title": "c-python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nThe demand of the question is to get the nodes at ```i``` level that are rightmost.\\nAny nodes left to that would not be included in answer.\\n\\n\\n**Level order traversal could help but that uses addtional space for the QUEUE**\\n\\n**APPROACH with no extra space**\\n\\nMaintain an array / vector.\\n\\n* TRAVERSAL -> **ROOT ->RIGHT -> LEFT** This is the way traversal is done in array so that rightmost node at ```i``` level is visited first.\\n\\n* When at ```i``` level, check in array/vector, if there is an element already present at index```i``` in the array. \\n[ index represents the level in tree ]->**[element at index i is rightmost node at level i]**\\n* If at that level, *element is present,*, just continue the traversal.\\n* Else if no element is present at index ```i``` -> add that node to answer ```[res]``` at the ```i``` index.\\n\\n![image](https://assets.leetcode.com/users/images/91ac2026-ca9a-46f0-9c30-69138cf4127c_1657511747.9057133.jpeg)\\n![image](https://assets.leetcode.com/users/images/34815618-d722-485c-a276-94e1d7aa5caf_1657511962.541216.png)\\n\\n\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(TreeNode* root, vector<int> res, int lvl){\\n        if (root==NULL){\\n            return res;\\n        }\\n        if (res.size()==lvl){                 // root\\n            res.push_back(root->val);\\n        }\\n        res = solve(root->right , res , lvl + 1);     // right\\n        res = solve(root->left , res , lvl + 1);       // left\\n        return res;\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        res = solve( root , res , 0 );\\n        return res;\\n    }\\n};\\n```\\n**UPVOTE IF HELPFuuL**\\n**PYTHON**\\n```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def solve(root, lvl):\\n        \\tif root:\\n        \\t\\tif len(res)==lvl:\\n        \\t\\t\\tres.append(root.val)\\n        \\t\\tsolve(root.right, lvl + 1)\\n        \\t\\tsolve(root.left, lvl + 1)\\n        \\treturn \\n\\n        res = []\\n        solve(root,0)\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3fa693e3-7795-467c-969d-59986cf0595f_1657516166.1903412.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```i```\n```i```\n```i```\n```i```\n```i```\n```[res]```\n```i```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(TreeNode* root, vector<int> res, int lvl){\\n        if (root==NULL){\\n            return res;\\n        }\\n        if (res.size()==lvl){                 // root\\n            res.push_back(root->val);\\n        }\\n        res = solve(root->right , res , lvl + 1);     // right\\n        res = solve(root->left , res , lvl + 1);       // left\\n        return res;\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        res = solve( root , res , 0 );\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def solve(root, lvl):\\n        \\tif root:\\n        \\t\\tif len(res)==lvl:\\n        \\t\\t\\tres.append(root.val)\\n        \\t\\tsolve(root.right, lvl + 1)\\n        \\t\\tsolve(root.left, lvl + 1)\\n        \\treturn \\n\\n        res = []\\n        solve(root,0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56203,
                "title": "simple-c-solution-btw-i-like-clean-codes",
                "content": "    class Solution {\\n    public:\\n        void dfs(TreeNode* root, int lv, vector<int> &res){\\n            if(!root)   return;\\n            if(lv>=res.size()) res.push_back(root->val);\\n            dfs(root->right,lv+1,res);\\n            dfs(root->left,lv+1,res);\\n        }\\n\\n        vector<int> rightSideView(TreeNode* root) {\\n            vector<int> res;\\n            dfs(root, 0, res);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void dfs(TreeNode* root, int lv, vector<int> &res){\\n            if(!root)   return;\\n            if(lv>=res.size()) res.push_back(root->val);\\n            dfs(root->right,lv+1,res);\\n            dfs(root->left,lv+1,res);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 559238,
                "title": "python-2-solutions-bfs-dfs-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS - Level by Level**\\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if root == None: return []\\n        ans = []\\n        q = deque([root])\\n        while q:\\n            lastNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                lastNode = cur\\n                if cur.left != None:\\n                    q.append(cur.left)\\n                if cur.right != None:\\n                    q.append(cur.right)\\n            ans.append(lastNode.val)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is the nunber of nodes in the binary tree.\\n- Space: `O(N)`, it\\'s the size of queue in the worst case.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DFS**\\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans = []\\n        \\n        def dfs(root, depth):\\n            if root == None: return\\n            if depth == len(self.ans):  # When we meet this `depth` for the first time, let\\'s add the first node as the right side most node.\\n                self.ans.append(root.val)\\n            dfs(root.right, depth + 1)  # Go right side first\\n            dfs(root.left, depth + 1)\\n            \\n        dfs(root, 0)\\n        return self.ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is the nunber of nodes in the binary tree.\\n- Space: `O(H)`, where `H` is the height of the binary tree, it\\'s the depth of stack memory.\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if root == None: return []\\n        ans = []\\n        q = deque([root])\\n        while q:\\n            lastNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                lastNode = cur\\n                if cur.left != None:\\n                    q.append(cur.left)\\n                if cur.right != None:\\n                    q.append(cur.right)\\n            ans.append(lastNode.val)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans = []\\n        \\n        def dfs(root, depth):\\n            if root == None: return\\n            if depth == len(self.ans):  # When we meet this `depth` for the first time, let\\'s add the first node as the right side most node.\\n                self.ans.append(root.val)\\n            dfs(root.right, depth + 1)  # Go right side first\\n            dfs(root.left, depth + 1)\\n            \\n        dfs(root, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549960,
                "title": "javascript-52ms-dfs",
                "content": "```\\nvar rightSideView = function(root) {\\n    if (!root) return [];\\n    let res = [];\\n    pre(root, 0);\\n    return res;\\n    \\n    function pre(node, h) {\\n        if (!node) return;\\n        res[h] = node.val;\\n        pre(node.left, h+1);\\n        pre(node.right, h+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar rightSideView = function(root) {\\n    if (!root) return [];\\n    let res = [];\\n    pre(root, 0);\\n    return res;\\n    \\n    function pre(node, h) {\\n        if (!node) return;\\n        res[h] = node.val;\\n        pre(node.left, h+1);\\n        pre(node.right, h+1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56178,
                "title": "simple-java-solution-w-recursion-2ms",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            ArrayList list = new ArrayList();\\n            rightSideView(root, 0, list);\\n            \\n            return list;\\n        }\\n        \\n        public void rightSideView(TreeNode root, int level, ArrayList list) {\\n            if(root == null) return;\\n\\n            if(list.size() == level)\\n                list.add(root.val);\\n\\n            rightSideView(root.right, level + 1, list);\\n            rightSideView(root.left, level + 1, list);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            ArrayList list = new ArrayList();\\n            rightSideView(root, 0, list);\\n            \\n            return list;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3125913,
                "title": "java-all-tree-views-easy-fast",
                "content": "# Intuition\\n\\n<p>\\n    Code for All Views of a tree\\n</p>\\n<p>\\n    Meathod Of Solving -> Just Imagine the tree visual and think any traversal meathod, U can carry on further\\uD83D\\uDE01\\uD83D\\uDE09.\\n<p>\\n    Note: I have provided some sample test cases for practice\\n</p>\\n<p>\\n    <b><h3>Upvote If U feel Helpful!!!\\uD83D\\uDE0E\\u270C\\uFE0F\\uD83D\\uDE09</h3></b>\\n</p>\\n\\n# Test Case:\\n```\\nInput: 1 3 2\\n       1\\n    /    \\\\\\n   3      2\\nOutput: 1 2\\n\\nInput: 10 20 30 40 60\\n     10\\n    /   \\\\\\n  20     30\\n /   \\\\\\n40  60 \\nOutput: 10 30 60\\n\\n```\\n\\n# Right View -> Recursion\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        var list = new ArrayList<Integer>();\\n        rec(root,list,0);\\n        return list;\\n    }\\n    void rec(TreeNode root,ArrayList<Integer> list, int depth){\\n        if (root == null) return;\\n        if(list.size()==depth) list.add(root.val);\\n        if(root.right!=null) rec(root.right,list,depth+1);\\n        if(root.left!=null) rec(root.left,list,depth+1);\\n    }\\n}\\n```\\n\\n# Test Case:\\n```\\nInput: 1 3 2\\n\\n   1\\n /  \\\\\\n3    2\\n\\nOutput: 1 3\\n\\nInput: 4 5 2 null null 3 1 6 7\\n\\n      4\\n    /   \\\\\\n   5     2\\n       /   \\\\\\n      3     1\\n    /  \\\\\\n   6    7\\n\\nOutput: 4 5 3 6\\n```\\n\\n# Left View -> Recursion\\n```\\n/* A Binary Tree node\\nclass Node\\n{\\n    int data;\\n    Node left, right;\\n\\n    Node(int item)\\n    {\\n        data = item;\\n        left = right = null;\\n    }\\n}*/\\nclass Tree\\n{\\n    //Function to return list containing elements of left view of binary tree.\\n    ArrayList<Integer> leftView(Node root)\\n    {\\n      // Your code here\\n      var list = new ArrayList<Integer>();\\n      rec(root,list,0);\\n      return list;\\n    }\\n    void rec(Node root, ArrayList<Integer> list, int depth){\\n        if(root==null) return;\\n        if(list.size()==depth) list.add(root.data);\\n        if(root.left!=null) rec(root.left,list,depth+1);\\n        if(root.right!=null) rec(root.right,list,depth+1);\\n    }\\n}\\n```\\n# Test Case:\\n```\\nInput: 1 2 3\\n\\n      1\\n   /    \\\\\\n  2      3\\n\\nOutput: 2 1 3\\n\\nInput: 10 20 30 40 60 90 100\\n\\n       10\\n    /      \\\\\\n  20        30\\n /   \\\\    /    \\\\\\n40   60  90    100\\n\\nOutput: 40 20 10 30 100\\n```\\n# Top View -> Lvl Order Traversal\\n```\\n/*\\nclass Node{\\n    int data;\\n    Node left;\\n    Node right;\\n    Node(int data){\\n        this.data = data;\\n        left=null;\\n        right=null;\\n    }\\n}\\n*/\\n\\nclass Pair{\\n    int ind;\\n    Node root;\\n    Pair(int _ind, Node _root){\\n        ind = _ind;\\n        root = _root;\\n    }\\n}\\n\\nclass Solution\\n{\\n    //Function to return a list of nodes visible from the top view \\n    //from left to right in Binary Tree.\\n    static ArrayList<Integer> topView(Node root)\\n    {\\n        // add your code\\n        var map = new TreeMap<Integer,Integer>();\\n        var q = new LinkedList<Pair>();\\n        var list = new ArrayList<Integer>();\\n        if(root==null) return list;\\n        q.add(new Pair(0,root));\\n        while(!q.isEmpty()){\\n            Pair pair = q.poll();\\n            int pos = pair.ind;\\n            Node node = pair.root;\\n            if(!map.containsKey(pos)) map.put(pos,node.data);\\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\\n            \\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            list.add(entry.getValue());\\n        } return list;\\n    }\\n}\\n```\\n# Test Case:\\n```\\nInput: 1 3 2\\n\\n       1\\n     /   \\\\\\n    3     2\\n\\nOutput: 3 1 2\\n\\nInput: 10 20 30 40 60\\n\\n         10\\n       /    \\\\\\n      20    30\\n     /  \\\\\\n    40   60\\n\\nOutput: 40 20 60 30\\n```\\n\\n# Bottom View -> Lvl Order Traversal\\n```\\n/*\\nclass Node{\\n    int data;\\n    Node left;\\n    Node right;\\n    Node(int data){\\n        this.data = data;\\n        left=null;\\n        right=null;\\n    }\\n}\\n*/\\nclass Pair{\\n    int ind;\\n    Node root;\\n    Pair(int _ind, Node _root){\\n        ind = _ind;\\n        root = _root;\\n    }\\n}\\n\\nclass Solution\\n{\\n    //Function to return a list of nodes visible from the bottom view \\n    //from left to right in Binary Tree.\\n    static ArrayList<Integer> bottomView(Node root)\\n    {\\n        // add your code\\n        var map = new TreeMap<Integer,Integer>();\\n        var q = new LinkedList<Pair>();\\n        var list = new ArrayList<Integer>();\\n        if(root==null) return list;\\n        q.add(new Pair(0,root));\\n        while(!q.isEmpty()){\\n            Pair pair = q.poll();\\n            int pos = pair.ind;\\n            Node node = pair.root;\\n            if(!map.containsKey(pos)) map.put(pos,node.data);\\n            if(map.containsKey(pos)) map.replace(pos,node.data);\\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\\n            \\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            list.add(entry.getValue());\\n        } return list;\\n    }\\n```\\n\\n<!-- ![image.png](https://assets.leetcode.com/users/images/2fe91f99-1d3b-47be-ba81-241e64c732fc_1675058149.943284.png) -->",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nInput: 1 3 2\\n       1\\n    /    \\\\\\n   3      2\\nOutput: 1 2\\n\\nInput: 10 20 30 40 60\\n     10\\n    /   \\\\\\n  20     30\\n /   \\\\\\n40  60 \\nOutput: 10 30 60\\n\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        var list = new ArrayList<Integer>();\\n        rec(root,list,0);\\n        return list;\\n    }\\n    void rec(TreeNode root,ArrayList<Integer> list, int depth){\\n        if (root == null) return;\\n        if(list.size()==depth) list.add(root.val);\\n        if(root.right!=null) rec(root.right,list,depth+1);\\n        if(root.left!=null) rec(root.left,list,depth+1);\\n    }\\n}\\n```\n```\\nInput: 1 3 2\\n\\n   1\\n /  \\\\\\n3    2\\n\\nOutput: 1 3\\n\\nInput: 4 5 2 null null 3 1 6 7\\n\\n      4\\n    /   \\\\\\n   5     2\\n       /   \\\\\\n      3     1\\n    /  \\\\\\n   6    7\\n\\nOutput: 4 5 3 6\\n```\n```\\n/* A Binary Tree node\\nclass Node\\n{\\n    int data;\\n    Node left, right;\\n\\n    Node(int item)\\n    {\\n        data = item;\\n        left = right = null;\\n    }\\n}*/\\nclass Tree\\n{\\n    //Function to return list containing elements of left view of binary tree.\\n    ArrayList<Integer> leftView(Node root)\\n    {\\n      // Your code here\\n      var list = new ArrayList<Integer>();\\n      rec(root,list,0);\\n      return list;\\n    }\\n    void rec(Node root, ArrayList<Integer> list, int depth){\\n        if(root==null) return;\\n        if(list.size()==depth) list.add(root.data);\\n        if(root.left!=null) rec(root.left,list,depth+1);\\n        if(root.right!=null) rec(root.right,list,depth+1);\\n    }\\n}\\n```\n```\\nInput: 1 2 3\\n\\n      1\\n   /    \\\\\\n  2      3\\n\\nOutput: 2 1 3\\n\\nInput: 10 20 30 40 60 90 100\\n\\n       10\\n    /      \\\\\\n  20        30\\n /   \\\\    /    \\\\\\n40   60  90    100\\n\\nOutput: 40 20 10 30 100\\n```\n```\\n/*\\nclass Node{\\n    int data;\\n    Node left;\\n    Node right;\\n    Node(int data){\\n        this.data = data;\\n        left=null;\\n        right=null;\\n    }\\n}\\n*/\\n\\nclass Pair{\\n    int ind;\\n    Node root;\\n    Pair(int _ind, Node _root){\\n        ind = _ind;\\n        root = _root;\\n    }\\n}\\n\\nclass Solution\\n{\\n    //Function to return a list of nodes visible from the top view \\n    //from left to right in Binary Tree.\\n    static ArrayList<Integer> topView(Node root)\\n    {\\n        // add your code\\n        var map = new TreeMap<Integer,Integer>();\\n        var q = new LinkedList<Pair>();\\n        var list = new ArrayList<Integer>();\\n        if(root==null) return list;\\n        q.add(new Pair(0,root));\\n        while(!q.isEmpty()){\\n            Pair pair = q.poll();\\n            int pos = pair.ind;\\n            Node node = pair.root;\\n            if(!map.containsKey(pos)) map.put(pos,node.data);\\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\\n            \\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            list.add(entry.getValue());\\n        } return list;\\n    }\\n}\\n```\n```\\nInput: 1 3 2\\n\\n       1\\n     /   \\\\\\n    3     2\\n\\nOutput: 3 1 2\\n\\nInput: 10 20 30 40 60\\n\\n         10\\n       /    \\\\\\n      20    30\\n     /  \\\\\\n    40   60\\n\\nOutput: 40 20 60 30\\n```\n```\\n/*\\nclass Node{\\n    int data;\\n    Node left;\\n    Node right;\\n    Node(int data){\\n        this.data = data;\\n        left=null;\\n        right=null;\\n    }\\n}\\n*/\\nclass Pair{\\n    int ind;\\n    Node root;\\n    Pair(int _ind, Node _root){\\n        ind = _ind;\\n        root = _root;\\n    }\\n}\\n\\nclass Solution\\n{\\n    //Function to return a list of nodes visible from the bottom view \\n    //from left to right in Binary Tree.\\n    static ArrayList<Integer> bottomView(Node root)\\n    {\\n        // add your code\\n        var map = new TreeMap<Integer,Integer>();\\n        var q = new LinkedList<Pair>();\\n        var list = new ArrayList<Integer>();\\n        if(root==null) return list;\\n        q.add(new Pair(0,root));\\n        while(!q.isEmpty()){\\n            Pair pair = q.poll();\\n            int pos = pair.ind;\\n            Node node = pair.root;\\n            if(!map.containsKey(pos)) map.put(pos,node.data);\\n            if(map.containsKey(pos)) map.replace(pos,node.data);\\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\\n            \\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            list.add(entry.getValue());\\n        } return list;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051930,
                "title": "python-simple-dfs-explained",
                "content": "Like in many other problems about binary trees, we need to somehow traverse our tree, using dfs (inorder, preorder or postorder) or bfs. There are different solutions here, I use almost **inorder** traversal, with just one small change: instead of going `Left -> Node -> Right`, we will go `Right -> Node -> Left`. In this way we first visit nodes on the right side of our tree. Algorithm will look like this:\\n\\n1. Create `ans` dictionary, which for each level `H` will keep the rightest node.\\n2. Traverse tree: first visit right children and if we do not have this `H` in `ans` yet, we put it there, then visit left children. Note again that with this order of traversal we always will put the rightest node for each level and next time we visit this level we will do nothing.\\n3. Finally, create list from our dictionary.\\n\\n**Complexity**: time complexity is `O(n)` for classical dfs, space is `O(h)`, again classical complexity for dfs as well as this amount of space we need to keep in our answer.\\n\\n```\\nclass Solution:\\n    def rightSideView(self, root):\\n        ans = {}\\n        def dfs(node, H):\\n            if not node: return \\n            \\n            dfs(node.right, H + 1)\\n            if H not in ans: ans[H] = node.val\\n            dfs(node.left, H + 1)\\n            \\n        dfs(root, 0)\\n        return [ans[i] for i in range(len(ans))]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root):\\n        ans = {}\\n        def dfs(node, H):\\n            if not node: return \\n            \\n            dfs(node.right, H + 1)\\n            if H not in ans: ans[H] = node.val\\n            dfs(node.left, H + 1)\\n            \\n        dfs(root, 0)\\n        return [ans[i] for i in range(len(ans))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052166,
                "title": "c-bfs-o-n-0ms-beats-100-easy-to-understand",
                "content": "**EXPLANATION (Easy)**\\n- Traverse the whole tree in **level order** fashion using **BFS** along with storing the **last processed node** (here it is stored in **```curr```**).\\n- Keep a **tag** ( here **```nullptr```**) at the **end of each level** to know that a particular level has *ended*.\\n- Whenever a level ends store the **last processed node value** to the **ans** vector.\\n- Return **ans**.\\n\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int>ans;\\n        if(root==nullptr)\\n            return ans;\\n        \\n        queue<TreeNode*>q;\\n        \\n        q.push(root); // Initially push the root node\\n        q.push(nullptr); // Then push nullptr, as level=0 contains only the root node\\n        \\n        TreeNode* curr;\\n        \\n        while(!q.empty()){\\n            if(q.front()!=nullptr){ // if the end of current level is not reached\\n                \\n                curr=q.front(); // keep the current node\\n                \\n                // push the left and right child of curr node into the queue if exists\\n                if(curr->left) q.push(curr->left);              \\n                if(curr->right) q.push(curr->right);\\n                \\n                q.pop(); //remove curr node from queue\\n            }\\n            else{ // nullptr signifies the end of the current level, so need to add the last element of this level to ans\\n                \\n                // last element of the level = last deleted element of queue from front\\n                ans.push_back(curr->val); // curr contains the last deleted element of queue from front\\n                \\n                q.pop(); // remove the nullptr, as this level has been processed \\n                \\n                //if the queue is not empty then again push nullptr to keep a tag at the end of the next level\\n                if(!q.empty()) q.push(nullptr);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**TIME COMPLEXITY**\\n**O(n)** [ *Since, each node is traversed exactly once* ]\\n\\n**SPACE COMPLEXITY**\\n**O(w)** [ *\\'w\\' is the maximum width of the tree* ]",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```curr```\n```nullptr```\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int>ans;\\n        if(root==nullptr)\\n            return ans;\\n        \\n        queue<TreeNode*>q;\\n        \\n        q.push(root); // Initially push the root node\\n        q.push(nullptr); // Then push nullptr, as level=0 contains only the root node\\n        \\n        TreeNode* curr;\\n        \\n        while(!q.empty()){\\n            if(q.front()!=nullptr){ // if the end of current level is not reached\\n                \\n                curr=q.front(); // keep the current node\\n                \\n                // push the left and right child of curr node into the queue if exists\\n                if(curr->left) q.push(curr->left);              \\n                if(curr->right) q.push(curr->right);\\n                \\n                q.pop(); //remove curr node from queue\\n            }\\n            else{ // nullptr signifies the end of the current level, so need to add the last element of this level to ans\\n                \\n                // last element of the level = last deleted element of queue from front\\n                ans.push_back(curr->val); // curr contains the last deleted element of queue from front\\n                \\n                q.pop(); // remove the nullptr, as this level has been processed \\n                \\n                //if the queue is not empty then again push nullptr to keep a tag at the end of the next level\\n                if(!q.empty()) q.push(nullptr);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56230,
                "title": "share-my-java-iterative-solution-based-on-level-order-traversal",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> ret = new ArrayList<Integer>();\\n            if(root == null) return ret;\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            q.offer(root);\\n            while(!q.isEmpty()){\\n                int cnt = q.size();\\n                for(int i = 0;i < cnt;i++){\\n                    TreeNode cur = q.poll();\\n                    if(i == cnt-1){\\n                        ret.add(cur.val);\\n                    }\\n                    if(cur.left != null){\\n                        q.offer(cur.left);\\n                    } \\n                    if(cur.right != null){\\n                        q.offer(cur.right);\\n                    } \\n                }\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> ret = new ArrayList<Integer>();\\n            if(root == null) return ret;\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            q.offer(root);\\n            while(!q.isEmpty()){\\n                int cnt = q.size();\\n                for(int i = 0;i < cnt;i++){\\n                    TreeNode cur = q.poll();\\n                    if(i == cnt-1){\\n                        ret.add(cur.val);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 56142,
                "title": "9ms-c-bfs-o-n-time-concise-with-explanation",
                "content": "**9ms C++ iterative, concise code with explanation**\\n\\nUsing a queue **mQ** to perform level order traversal. In the beginning of a level traversal, the last element is pushed into result array **ret**. The core idea is similar with [Binary Tree Level Order Traversal][1]\\n\\nO(n) time, O(logn) space\\n\\n    class Solution {\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n            queue<TreeNode*>mQ;\\n            vector<int> ret;\\n            if(!root)return ret;\\n            mQ.push(root);\\n            while(!mQ.empty()){\\n                ret.push_back(mQ.back()->val);\\n                for(int i=mQ.size();i>0;i--){\\n                    TreeNode *tn=mQ.front();\\n                    mQ.pop();\\n                    if(tn->left)mQ.push(tn->left);\\n                    if(tn->right)mQ.push(tn->right);\\n                }\\n            }\\n            return ret;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-level-order-traversal/",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n            queue<TreeNode*>mQ;\\n            vector<int> ret;\\n            if(!root)return ret;\\n            mQ.push(root);\\n            while(!mQ.empty()){\\n                ret.push_back(mQ.back()->val);\\n                for(int i=mQ.size();i>0;i--){\\n                    TreeNode *tn=mQ.front();\\n                    mQ.pop();\\n                    if(tn->left)mQ.push(tn->left);\\n                    if(tn->right)mQ.push(tn->right);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2269412,
                "title": "c-beats-96-recursive-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Solution  : Reverse PreOrder Traversal (Recursive)**\\n**Time complexity: O(N)**\\n**Space complexity: O(Height)**\\n\\n```\\n//! Using Reverse PreOrder Traversal (Recursive)\\nclass Solution {\\npublic:\\n    void RightView(TreeNode* root, int level, vector<int>&ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        if(level == ans.size())\\n            ans.push_back(root->val);\\n        \\n        RightView(root->right, level+1, ans);\\n        RightView(root->left, level+1, ans);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        RightView(root, 0, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//! Using Reverse PreOrder Traversal (Recursive)\\nclass Solution {\\npublic:\\n    void RightView(TreeNode* root, int level, vector<int>&ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        if(level == ans.size())\\n            ans.push_back(root->val);\\n        \\n        RightView(root->right, level+1, ans);\\n        RightView(root->left, level+1, ans);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        RightView(root, 0, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56062,
                "title": "java-solution-using-divide-and-conquer",
                "content": "    public List<Integer> rightSideView(TreeNode root) {\\n        if(root==null)\\n            return new ArrayList<Integer>();\\n        List<Integer> left = rightSideView(root.left);\\n        List<Integer> right = rightSideView(root.right);\\n        List<Integer> re = new ArrayList<Integer>();\\n        re.add(root.val);\\n        for(int i=0;i<Math.max(left.size(), right.size());i++){\\n            if(i>=right.size())\\n                re.add(left.get(i));\\n            else\\n                re.add(right.get(i));\\n        }\\n        return re;\\n    }",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "    public List<Integer> rightSideView(TreeNode root) {\\n        if(root==null)\\n            return new ArrayList<Integer>();\\n        List<Integer> left = rightSideView(root.left);\\n        List<Integer> right = rightSideView(root.right);\\n        List<Integer> re = new ArrayList<Integer>();\\n        re.add(root.val);\\n        for(int i=0;i<Math.max(left.size(), right.size());i++){\\n            if(i>=right.size())\\n                re.add(left.get(i));\\n            else\\n                re.add(right.get(i));\\n        }\\n        return re;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56229,
                "title": "python-solution",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        def rightSideView(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: List[int]\\n            \"\"\"\\n            if root==None:\\n                return []\\n            ans=[root.val]\\n            left=ans+self.rightSideView(root.left)\\n            right=ans+self.rightSideView(root.right)\\n            if len(right)>=len(left):\\n                return right\\n            return right+left[len(right):]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        def rightSideView(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: List[int]\\n            \"\"\"\\n            if root==None:\\n                return []\\n            ans=[root.val]\\n            left=ans+self.rightSideView(root.left)\\n            right=ans+self.rightSideView(root.right)\\n            if len(right)>=len(left):\\n                return right\\n            return right+left[len(right):]",
                "codeTag": "Java"
            },
            {
                "id": 2265940,
                "title": "beats-100-two-simple-solutions-recursive-queue-explanation",
                "content": "Our goal is to find the rightmost node of each layer, I use two ways to solve this problem.\\nThe first is Recursive, which is faster but relatively more difficult to understand.\\nWe always iterate the right node of the tree, if the size of the list is equal to the height of the node, we add the val. (This layer is over~)\\nIf we put the right node\\'s val into list, the size of list will increase, so when we iterate the left node in this layer, depth will not be equal to the size of the list!\\n\\n**Recursive**\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        helper(root, list, 0);\\n        return list;\\n    }\\n    \\n    private void helper(TreeNode node, List<Integer> list, int depth) {\\n        if (node != null) {\\n            if (depth == list.size())\\n                list.add(node.val);\\n            \\n            helper(node.right, list, depth + 1);\\n            helper(node.left, list, depth + 1);\\n        }\\n    }\\n}\\n```\\nThe second way use queue. We need to find the rightmost node of each layer, so each time we can iterate current layer\\'s nodes(during the iteration, add the next layer\\'s nodes), when we meet the last node in the layer, we add it into list.\\n**Queue**\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        \\n        if (root == null)\\n            return list;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n    \\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // store the number of nodes of current layer\\n            TreeNode node = null;\\n            while (size > 0) {\\n                node = queue.poll();\\n                if (node.left != null) // add next layer\\'s node\\n                    queue.offer(node.left);\\n                if (node.right != null)\\n                    queue.offer(node.right);\\n                size--;\\n            }\\n            list.add(node.val); // add the val of last node\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\nPlease vote if it helps\\uD83D\\uDE06",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        helper(root, list, 0);\\n        return list;\\n    }\\n    \\n    private void helper(TreeNode node, List<Integer> list, int depth) {\\n        if (node != null) {\\n            if (depth == list.size())\\n                list.add(node.val);\\n            \\n            helper(node.right, list, depth + 1);\\n            helper(node.left, list, depth + 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        \\n        if (root == null)\\n            return list;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n    \\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // store the number of nodes of current layer\\n            TreeNode node = null;\\n            while (size > 0) {\\n                node = queue.poll();\\n                if (node.left != null) // add next layer\\'s node\\n                    queue.offer(node.left);\\n                if (node.right != null)\\n                    queue.offer(node.right);\\n                size--;\\n            }\\n            list.add(node.val); // add the val of last node\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407352,
                "title": "easy-c-bfs-solution",
                "content": "**Do upvote if found useful and encourage me to document more!**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int count=q.size();\\n            for(int i=0;i<count;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(i==count-1)\\n                    v.push_back(curr->val);\\n                if(curr->left!=NULL)\\n                    q.push(curr->left);\\n                if(curr->right!=NULL)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int count=q.size();\\n            for(int i=0;i<count;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(i==count-1)\\n                    v.push_back(curr->val);\\n                if(curr->left!=NULL)\\n                    q.push(curr->left);\\n                if(curr->right!=NULL)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56292,
                "title": "recursive-solution",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            \\n            if(root == null) return res;\\n            \\n            visitLevel(root, 1, res);\\n            return res;\\n        }\\n        \\n        public void visitLevel(TreeNode root, int level, List<Integer> res){\\n            \\n            if(root == null) return;\\n            if(level > res.size()){\\n                res.add(root.val);    \\n            }\\n            \\n            visitLevel(root.right, level+1, res);\\n            visitLevel(root.left, level+1, res);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            \\n            if(root == null) return res;\\n            \\n            visitLevel(root, 1, res);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56210,
                "title": "python-straightforward-bfs",
                "content": "    def rightSideView(self, root):\\n        res, nxtL= [], [root] if root else []\\n        while nxtL:\\n            res.append(nxtL[-1].val) # right most val as to output\\n            curL, nxtL = nxtL, []\\n            for i in curL: # build the next level\\n                if i.left: nxtL.append(i.left)\\n                if i.right: nxtL.append(i.right)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def rightSideView(self, root):\\n        res, nxtL= [], [root] if root else []\\n        while nxtL:\\n            res.append(nxtL[-1].val) # right most val as to output\\n            curL, nxtL = nxtL, []\\n            for i in curL: # build the next level\\n                if i.left: nxtL.append(i.left)\\n                if i.right: nxtL.append(i.right)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1053080,
                "title": "c-super-simple-and-easy-recursive-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int height) {\\n        if (!root) return;\\n        if (height == res.size())\\n            res.push_back(root->val);\\n        dfs(root->right, height + 1);\\n        dfs(root->left, height + 1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n\\nprivate:\\n    vector<int> res;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int height) {\\n        if (!root) return;\\n        if (height == res.size())\\n            res.push_back(root->val);\\n        dfs(root->right, height + 1);\\n        dfs(root->left, height + 1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n\\nprivate:\\n    vector<int> res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805562,
                "title": "simple-c-recursive-approach-comments-included",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// h is the current level of the node, maxh is the maximum level reached at any given point of time.\\n    void traverse(TreeNode* root, int h, int& maxh, vector<int>& ans){\\n        if(!root) return ;\\n\\t\\t// if level is greater than maximum level then it will be seen at the right side. Try to visualize it.\\n        if(h > maxh){\\n            ans.push_back(root->val);\\n\\t\\t\\tmaxh = h;\\n        }\\n\\t\\t// first visiting the right side for right view.\\n        traverse(root->right, h+1, maxh, ans);\\n        \\n        traverse(root->left, h+1, maxh, ans);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        if(!root) return {};\\n        vector<int> ans;\\n        int maxh = 0;\\n        ans.push_back(root->val);\\n        traverse(root, 0, maxh, ans);\\n        return ans;\\n    }\\n};\\n```\\nIf you have any query, then do ask in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// h is the current level of the node, maxh is the maximum level reached at any given point of time.\\n    void traverse(TreeNode* root, int h, int& maxh, vector<int>& ans){\\n        if(!root) return ;\\n\\t\\t// if level is greater than maximum level then it will be seen at the right side. Try to visualize it.\\n        if(h > maxh){\\n            ans.push_back(root->val);\\n\\t\\t\\tmaxh = h;\\n        }\\n\\t\\t// first visiting the right side for right view.\\n        traverse(root->right, h+1, maxh, ans);\\n        \\n        traverse(root->left, h+1, maxh, ans);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        if(!root) return {};\\n        vector<int> ans;\\n        int maxh = 0;\\n        ans.push_back(root->val);\\n        traverse(root, 0, maxh, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382850,
                "title": "simple-javascript-bfs-solution-using-queue",
                "content": "BFS by layer, and only add the last one of each layer into the result array\\n\\n```\\nvar rightSideView = function(root) {\\n    const result = [];\\n    const queue = [];\\n    \\n    if (root === null) return result;\\n    \\n    queue.push(root);\\n    while(queue.length !== 0) {\\n        let size = queue.length;\\n        for (let i = 0; i < size; i++) {\\n            let n = queue.shift();\\n            if (i === size - 1) result.push(n.val);\\n            if (n.left !== null) queue.push(n.left);\\n            if (n.right !== null) queue.push(n.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar rightSideView = function(root) {\\n    const result = [];\\n    const queue = [];\\n    \\n    if (root === null) return result;\\n    \\n    queue.push(root);\\n    while(queue.length !== 0) {\\n        let size = queue.length;\\n        for (let i = 0; i < size; i++) {\\n            let n = queue.shift();\\n            if (i === size - 1) result.push(n.val);\\n            if (n.left !== null) queue.push(n.left);\\n            if (n.right !== null) queue.push(n.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2266347,
                "title": "c-using-both-level-order-and-faster-recursive-approach",
                "content": "**APPROACH - 1**\\n\\n* We know that in level order we visit the left most element int he end so we can simply push that in the `ans`.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        if(root==NULL)return ans;\\n        \\n\\t\\tqueue<TreeNode*>q;\\n        q.push(root);\\n        \\n\\t\\t// Level order transversal\\n\\t\\twhile(!q.empty()){\\n            int s=q.size();\\n            int dat=0;\\n\\t\\t\\t\\n            while(s){\\n                TreeNode*temp=q.front();\\n                q.pop();\\n                dat=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);\\n                s--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Simply push ush the last value\\n            ans.push_back(dat);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n**APPROACH - 2 (MUCH FASTER AND MORE MEMORY EFFICIENT)**\\n\\n* We can also transverse DFS but with right node first along with an `ans vector`.\\n* Which represent the last visited value on the respective level.\\n* We will recursively update the last value on the particular level as we travel.\\n```\\nclass Solution {\\npublic:\\n\\n\\t// Recursive function\\n    void helper(TreeNode* root, vector<int> &ans, int i){\\n        if(root == NULL) return;\\n        \\n        if(i == ans.size())\\n            ans.push_back(root->val);\\n        \\n\\t\\t// Right first DFS\\n        helper(root->right, ans, i+1);\\n        helper(root->left, ans, i+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        if(root==NULL)return ans;\\n        \\n\\t\\tqueue<TreeNode*>q;\\n        q.push(root);\\n        \\n\\t\\t// Level order transversal\\n\\t\\twhile(!q.empty()){\\n            int s=q.size();\\n            int dat=0;\\n\\t\\t\\t\\n            while(s){\\n                TreeNode*temp=q.front();\\n                q.pop();\\n                dat=temp->val;\\n                if(temp->left!=NULL)q.push(temp->left);\\n                if(temp->right!=NULL)q.push(temp->right);\\n                s--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Simply push ush the last value\\n            ans.push_back(dat);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\t// Recursive function\\n    void helper(TreeNode* root, vector<int> &ans, int i){\\n        if(root == NULL) return;\\n        \\n        if(i == ans.size())\\n            ans.push_back(root->val);\\n        \\n\\t\\t// Right first DFS\\n        helper(root->right, ans, i+1);\\n        helper(root->left, ans, i+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265539,
                "title": "simple-solution-both-iterative-and-recursive-solutions",
                "content": "**Upvote** if you like efficient solution code!\\n\\n**Join our discord** to meet other people preparing for interviews!\\n**https://discord.gg/Aj2uT5rP**\\n\\n**Iterative Level-Order Traversal**\\nKey idea: Go through level by level through the tree. Append the last node in each level to the result.\\n\\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        q = deque([root])\\n        ans = []\\n        while q:\\n            length = len(q)\\n            ans.append(q[-1].val)\\n            for _ in range(length):\\n                node = q.popleft()\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return ans\\n```\\n**Time Complexity**: O(n) - go through each node in the tree\\n**Space Complexity**: O(max_level) - max number of nodes in a level of the tree. Worst case, all nodes are in one level so O(n). \\n\\n\\n**Recursive Modified Pre-order Traversal**\\nKey idea: Go to the rightmost node first, in case the rightmost path doesn\\'t reach the max height, recurse on the left subtree. Since we are visiting the rightmost nodes first, if this is the first time we reach a certain depth, append it to the result.\\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        \\n        def dfs(node, depth):\\n            if not node:\\n                return\\n            if depth == len(ans):\\n                ans.append(node.val)\\n            dfs(node.right, depth + 1)\\n            dfs(node.left, depth + 1)\\n            \\n        dfs(root, 0)\\n        return ans        \\n```\\n**Time Complexity**: O(n) - go through each node in the tree\\n**Space Complexity**: O(height) - stack space for the recursion is at most the height of the tree. Worst case, the tree is degenerate (i.e. all nodes in a line) so O(n).\\n",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        q = deque([root])\\n        ans = []\\n        while q:\\n            length = len(q)\\n            ans.append(q[-1].val)\\n            for _ in range(length):\\n                node = q.popleft()\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        \\n        def dfs(node, depth):\\n            if not node:\\n                return\\n            if depth == len(ans):\\n                ans.append(node.val)\\n            dfs(node.right, depth + 1)\\n            dfs(node.left, depth + 1)\\n            \\n        dfs(root, 0)\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 56155,
                "title": "o-n-java-solution-i-myself-was-asked-this-question-by-amazon-in-phone-interview",
                "content": "    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> res = new LinkedList<Integer>();\\n        if(root == null) return res;\\n        List<TreeNode> candidates = new LinkedList<TreeNode>();\\n        candidates.add(root);\\n        while(!candidates.isEmpty()) {\\n            List<TreeNode> temp = new LinkedList<TreeNode>();\\n            res.add(candidates.get(0).val);\\n            for(TreeNode curr : candidates) {\\n                if(curr.right != null)\\n                    temp.add(curr.right);\\n                if(curr.left != null)\\n                    temp.add(curr.left);\\n            }\\n            candidates = temp;\\n        }\\n        return res;\\n    }\\n\\n**A variation of this question is to print a tree one level at a time.**",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> res = new LinkedList<Integer>();\\n        if(root == null) return res;\\n        List<TreeNode> candidates = new LinkedList<TreeNode>();\\n        candidates.add(root);\\n        while(!candidates.isEmpty()) {\\n            List<TreeNode> temp = new LinkedList<TreeNode>();\\n            res.add(candidates.get(0).val);\\n            for(TreeNode curr : candidates) {\\n                if(curr.right != null)\\n                    temp.add(curr.right);\\n                if(curr.left != null)\\n                    temp.add(curr.left);\\n            }\\n            candidates = temp;\\n        }\\n        return res;\\n    }\\n\\n**A variation of this question is to print a tree one level at a time.**",
                "codeTag": "Unknown"
            },
            {
                "id": 2267091,
                "title": "binary-tree-right-side-view-java-solution-level-order-traversal",
                "content": "**Approach:**\\nWe will do the level order traversal of the tree and keep on taking the last element of each level.\\n![image](https://assets.leetcode.com/users/images/70c2fefd-674e-46f0-b61b-6e2400c7d3db_1657526215.1977708.jpeg)\\n\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root==null)\\n            return ans;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            int r = q.peek().val;\\n            while(size-- > 0)\\n            {\\n                TreeNode temp = q.poll();\\n                r = temp.val;\\n                if(temp.left != null)\\n                    q.offer(temp.left);\\n                if(temp.right != null)\\n                    q.offer(temp.right);\\n            }\\n            ans.add(r);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root==null)\\n            return ans;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            int r = q.peek().val;\\n            while(size-- > 0)\\n            {\\n                TreeNode temp = q.poll();\\n                r = temp.val;\\n                if(temp.left != null)\\n                    q.offer(temp.left);\\n                if(temp.right != null)\\n                    q.offer(temp.right);\\n            }\\n            ans.add(r);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56263,
                "title": "java-solution-using-recursion",
                "content": "    public class Solution {\\n  \\n\\n     public List<Integer> rightSideView(TreeNode root) {\\n    \\t\\tArrayList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tif (root == null) return result;\\n    \\t\\treturn helper(root, result, 0);\\n    \\t}\\n\\n\\tpublic List<Integer> helper(TreeNode root, ArrayList<Integer> result,\\n\\t\\t\\tint height) {\\n\\t\\tif (height == result.size()) {\\n\\t\\t\\tresult.add(root.val);\\n\\t\\t}\\n\\n\\t\\tif (root.right != null) {\\n\\t\\t\\thelper(root.right, result, height + 1);\\n\\n\\t\\t}\\n\\t\\tif (root.left != null) {\\n\\t\\t\\thelper(root.left, result, height + 1);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n\\nComments: height == result.size() is the core part in this recursion, it limits the amount of Node add to the result in each level(height) of the Tree.\\n\\nSome thoughts: If the questions is asking for a left view of the binary tree, just swap the order of \\n\\n    if (root.right != null) {\\n\\t\\t\\thelper(root.right, result, height + 1);\\n\\n\\t\\t}\\nand\\n\\n    if (root.left != null) {\\n        helper(root.left, result, height + 1);\\n    }\\n\\nMoreover, if it's asking of the \"x-ray view\" of the binary tree, for example, display the second element from the right view(given a valid tree). The solution could be adding a counter inside\\n\\n    if (height == result.size()) {\\n\\t\\tresult.add(root.val);\\n    }\\n\\nand keep track of the counter.",
                "solutionTags": [],
                "code": "class Solution {\\n  \\n\\n     public List<Integer> rightSideView(TreeNode root) {\\n    \\t\\tArrayList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tif (root == null) return result;\\n    \\t\\treturn helper(root, result, 0);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1006996,
                "title": "c-beginner-step-by-step-explanation",
                "content": "### T = O(n) & S = O(n) due to queue \\n### stepwise\\n**1.** declare a vector storing int values\\n**2.** declare a queue storing node type value(TreeNode*)\\n**3.** push root into queue\\n**4.** work until queue is not empty\\n**5.** iterate until last element present in queue and push last element of current queue size\\n**6.** check for left and right node if null or not\\n**7.** Repeat steps from 4 to 6\\n**8.** return the vector.\\n\\n```\\nvector<int> rightSideView(TreeNode* root) {\\n        if(!root) {\\n            return {};\\n        }\\n        vector<int> v; //store values of nodes in the rightmost\\n        queue<TreeNode*> Q; //store node type values in queue \\n        Q.push(root); //push root\\n        while(!Q.empty()) { //repeat steps until queue is not empty\\n            \\n            int size = Q.size();  // current size of queue\\n            for(int i = 0; i < size; i++) {\\n              TreeNode* t = Q.front(); //declare a temp node and put front node of queue\\n                Q.pop(); \\n                if(i==size-1) {   //if node is rightmost \\n                    v.push_back(t->val); //push the value of rightmost node into vector\\n                }\\n                if(t->left) {   //if temp->left != NULL then push into queue\\n                    Q.push(t->left);\\n                }\\n                if(t->right) { //if temp->right != NULL then push into queue\\n                    Q.push(t->right);\\n                }\\n            }  \\n        }\\n        return v; //finally we have all values\\n    }\\n```\\n\\n**Do upvote if liked my solution and explanation :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nvector<int> rightSideView(TreeNode* root) {\\n        if(!root) {\\n            return {};\\n        }\\n        vector<int> v; //store values of nodes in the rightmost\\n        queue<TreeNode*> Q; //store node type values in queue \\n        Q.push(root); //push root\\n        while(!Q.empty()) { //repeat steps until queue is not empty\\n            \\n            int size = Q.size();  // current size of queue\\n            for(int i = 0; i < size; i++) {\\n              TreeNode* t = Q.front(); //declare a temp node and put front node of queue\\n                Q.pop(); \\n                if(i==size-1) {   //if node is rightmost \\n                    v.push_back(t->val); //push the value of rightmost node into vector\\n                }\\n                if(t->left) {   //if temp->left != NULL then push into queue\\n                    Q.push(t->left);\\n                }\\n                if(t->right) { //if temp->right != NULL then push into queue\\n                    Q.push(t->right);\\n                }\\n            }  \\n        }\\n        return v; //finally we have all values\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807741,
                "title": "java-100-faster-step-by-steo-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(log N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/397fadc1-2654-4031-a5a7-9b43568d0105_1690163803.475731.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        // Call the recursive rightView function to populate the right side view of the tree\\n        rightView(root, result, 0);\\n        return result;\\n    }\\n    \\n    // Recursive function to populate the right side view of the tree\\n    public void rightView(TreeNode curr, List<Integer> result, int currDepth){\\n        // If the current node is null, we have reached the end of the tree or a leaf node\\n        if(curr == null){\\n            return;\\n        }\\n        \\n        // If the current depth is equal to the size of the result list, it means we are\\n        // visiting the rightmost node at this depth for the first time\\n        // So, add the current node\\'s value to the result list for the right side view\\n        if(currDepth == result.size()){\\n            result.add(curr.val);\\n        }\\n        \\n        // Recursively call the rightView function on the right and left subtrees, \\n        // incrementing the current depth by 1 for each recursive call\\n        // The right subtree is processed before the left subtree, ensuring that the rightmost \\n        // node at each depth is added to the result list\\n        rightView(curr.right, result, currDepth + 1);\\n        rightView(curr.left, result, currDepth + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        // Call the recursive rightView function to populate the right side view of the tree\\n        rightView(root, result, 0);\\n        return result;\\n    }\\n    \\n    // Recursive function to populate the right side view of the tree\\n    public void rightView(TreeNode curr, List<Integer> result, int currDepth){\\n        // If the current node is null, we have reached the end of the tree or a leaf node\\n        if(curr == null){\\n            return;\\n        }\\n        \\n        // If the current depth is equal to the size of the result list, it means we are\\n        // visiting the rightmost node at this depth for the first time\\n        // So, add the current node\\'s value to the result list for the right side view\\n        if(currDepth == result.size()){\\n            result.add(curr.val);\\n        }\\n        \\n        // Recursively call the rightView function on the right and left subtrees, \\n        // incrementing the current depth by 1 for each recursive call\\n        // The right subtree is processed before the left subtree, ensuring that the rightmost \\n        // node at each depth is added to the result list\\n        rightView(curr.right, result, currDepth + 1);\\n        rightView(curr.left, result, currDepth + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266920,
                "title": "bfs-and-in-order-traversal-fully-explained-with-image-o-n",
                "content": "Upvote if you found it helpful <3\\n\\n# Intuition\\nWe are standing on the right side of the tree, which nodes do we see?\\n\\nWe will see a node for every level, but which node? the right-most node\\n\\n![image](https://assets.leetcode.com/users/images/aca04950-9a6e-4c79-abd7-c906b11e291d_1657523426.5545232.png)\\n\\nThe right most node isn\\'t blocked on it\\'s level, since this is what we\\'ll see from the right side.\\n\\nNow we just need to traverse the tree in the right order.\\n\\nWe will go about it with DFS, we will keep track of the levels and append the **left childs first**, **then the right childs**.\\n\\nThis way, if there is a right child, it will override the left child (block it, so the left isn\\'t seen anymore)\\n\\nWe will hold a dictionary that will save the nodes that we see on every level, and then we will return the values of the dictionary (since we don\\'t care about the node level)\\n\\n# Code\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        \\n        # Queue has (node, level) elements\\n        bfs_queue = deque([(root, 1)])\\n        \\n        # result has the rightmost element in each level\\n        answer_dict = {}\\n        \\n        while bfs_queue:\\n            node, level = bfs_queue.popleft()\\n            answer_dict[level] = node.val\\n            if node.left:\\n                bfs_queue.append((node.left, level + 1))\\n            if node.right:\\n                bfs_queue.append((node.right, level + 1))\\n        \\n        return answer_dict.values()\\n```\\n\\n# Complexity Analysis\\n* Time - O(n). We do a single traversal of the tree\\n* Space - O(n). We have a queue for the BFS\\n\\n\\n# In order traversal\\nWe can achieve the same thing with in-order traversal, because the right-most element on every level is visited last.\\n\\nI add the example for demonstration and learning purposes :)\\n\\nThis time we use an array directly, and the index is the `level-1` value.\\n\\n```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        \\n        answer = []\\n        self.in_order_traversal(root, 1, answer)\\n        return answer\\n    \\n    def in_order_traversal(self, root, level, answer):\\n        if not root: return\\n        \\n        self.in_order_traversal(root.left, level + 1, answer)\\n        \\n        # If it\\'s the first time on this level, let\\'s increase our array to match.\\n        while len(answer) < level:\\n\\t\\t\\t# we don\\'t care about the value we append, it will be over written anyway.\\n            answer.append(0)\\n        \\n        answer[level-1] = root.val\\n        self.in_order_traversal(root.right, level + 1, answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        \\n        # Queue has (node, level) elements\\n        bfs_queue = deque([(root, 1)])\\n        \\n        # result has the rightmost element in each level\\n        answer_dict = {}\\n        \\n        while bfs_queue:\\n            node, level = bfs_queue.popleft()\\n            answer_dict[level] = node.val\\n            if node.left:\\n                bfs_queue.append((node.left, level + 1))\\n            if node.right:\\n                bfs_queue.append((node.right, level + 1))\\n        \\n        return answer_dict.values()\\n```\n```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        \\n        answer = []\\n        self.in_order_traversal(root, 1, answer)\\n        return answer\\n    \\n    def in_order_traversal(self, root, level, answer):\\n        if not root: return\\n        \\n        self.in_order_traversal(root.left, level + 1, answer)\\n        \\n        # If it\\'s the first time on this level, let\\'s increase our array to match.\\n        while len(answer) < level:\\n\\t\\t\\t# we don\\'t care about the value we append, it will be over written anyway.\\n            answer.append(0)\\n        \\n        answer[level-1] = root.val\\n        self.in_order_traversal(root.right, level + 1, answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392858,
                "title": "top-view-bottom-view",
                "content": "#### approach 1 : Top View\\n\\nstep1 : handle edge case\\n\\nstep2 : \\n`map`, for tracking horizontal distance\\n`queue`, for tracking level order traversal\\n\\nstep4 : \\ndo normal,\\nlevel order traversal\\n\\nstep5 : \\nalong with level order traversal,\\nwe need to track the horizontal_distance also\\n\\nso, for that we need map\\n\\n\\n<hr> \\n\\n```\\n topView(root)\\n    {\\n        if(!root) return\\n    \\n        let map = new Map()\\n\\n        let queue = []\\n        queue.push([root, 0])             <----------------\\n\\t\\tlet node = 0, horizontal_distance = 0\\n        \\n\\n        while(queue.length > 0){\\n            const temp = queue.shift()\\n\\n            node = temp[0]              <---------\\n            horizontal_distance = temp[1]   <-----------\\n            \\n            \\n            if(!map.has(horizontal_distance))   <-------------\\n                map.set(horizontal_distance, node.val)\\n\\n            \\n            if(node.left != null)\\n                queue.push([node.left, horizontal_distance - 1]) <--------\\n                \\n            if(node.right != null)\\n                queue.push([node.right,horizontal_distance + 1]) <--------\\n        }\\n\\n\\n        let sortedMap = new Map([...map].sort(function(a,b){return a[0] - b[0]}))\\n        return Array.from(sortedMap.values())\\n        // let res = []\\n        // for(let [k,v] of sortedMap){\\n        //     res.push(v)\\n        // }\\n        // return res\\n    }\\n\\n```\\n\\n<hr> <br> <br><br><br> \\n\\n#### Bottom View : \\n\\nhere , we need to update the map,\\nfor the higher level\\'s node( niche wale level)\\n\\n\\n```\\n bottomView(root)\\n    {\\n        if(!root) return\\n    \\n        let map = new Map()\\n\\n        let queue = []\\n        queue.push([root, 0])          \\n\\t\\tlet node = 0, horizontal_distance = 0\\n        \\n\\n        while(queue.length > 0){\\n            const temp = queue.shift()\\n\\n            node = temp[0]              \\n            horizontal_distance = temp[1]  \\n            \\n            \\n            //if(!map.has(horizontal_distance))   <-------------\\n                map.set(horizontal_distance, node.val)\\n\\n            \\n            if(node.left != null)\\n                queue.push([node.left, horizontal_distance - 1])\\n                \\n            if(node.right != null)\\n                queue.push([node.right,horizontal_distance + 1])\\n        }\\n\\n\\n        let sortedMap = new Map([...map].sort(function(a,b){return a[0] - b[0]}))\\n        return Array.from(sortedMap.values())\\n   \\n    }\\n\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n topView(root)\\n    {\\n        if(!root) return\\n    \\n        let map = new Map()\\n\\n        let queue = []\\n        queue.push([root, 0])             <----------------\\n\\t\\tlet node = 0, horizontal_distance = 0\\n        \\n\\n        while(queue.length > 0){\\n            const temp = queue.shift()\\n\\n            node = temp[0]              <---------\\n            horizontal_distance = temp[1]   <-----------\\n            \\n            \\n            if(!map.has(horizontal_distance))   <-------------\\n                map.set(horizontal_distance, node.val)\\n\\n            \\n            if(node.left != null)\\n                queue.push([node.left, horizontal_distance - 1]) <--------\\n                \\n            if(node.right != null)\\n                queue.push([node.right,horizontal_distance + 1]) <--------\\n        }\\n\\n\\n        let sortedMap = new Map([...map].sort(function(a,b){return a[0] - b[0]}))\\n        return Array.from(sortedMap.values())\\n        // let res = []\\n        // for(let [k,v] of sortedMap){\\n        //     res.push(v)\\n        // }\\n        // return res\\n    }\\n\\n```\n```\\n bottomView(root)\\n    {\\n        if(!root) return\\n    \\n        let map = new Map()\\n\\n        let queue = []\\n        queue.push([root, 0])          \\n\\t\\tlet node = 0, horizontal_distance = 0\\n        \\n\\n        while(queue.length > 0){\\n            const temp = queue.shift()\\n\\n            node = temp[0]              \\n            horizontal_distance = temp[1]  \\n            \\n            \\n            //if(!map.has(horizontal_distance))   <-------------\\n                map.set(horizontal_distance, node.val)\\n\\n            \\n            if(node.left != null)\\n                queue.push([node.left, horizontal_distance - 1])\\n                \\n            if(node.right != null)\\n                queue.push([node.right,horizontal_distance + 1])\\n        }\\n\\n\\n        let sortedMap = new Map([...map].sort(function(a,b){return a[0] - b[0]}))\\n        return Array.from(sortedMap.values())\\n   \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300340,
                "title": "dfs-recursive-0-ms-and-bfs-iterative-1-ms-clean-code-in-java",
                "content": "Recursive DFS solution (Accepted 0ms):\\n```\\n/*\\nKeeping track of depth, i.e when going to a child node, increase depth and when coming back, decrease depth.\\nAt each new level (depth), add the rightmost node to the answer list.\\nSince we go to the **right child first** and then the left, when we arrive on a new level **for the first time**, we shall always arrive at the rightmost node.\\n*/\\nclass Solution {\\n    \\n    int depth = 0;\\n    List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        if(root == null)\\n            return ans;\\n        \\n        depth++;\\n        \\n        if (ans.size() < depth)\\n            ans.add(root.val);\\n        \\n        ans = rightSideView(root.right);\\n        ans = rightSideView(root.left);\\n        \\n        depth--;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nIterative BFS solution (without changing the signature of question, Accepted 1ms) :\\n```\\nclass Solution {\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        // create array to store answer\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        // check for edge case\\n        if (root == null)\\n            return ans;\\n        \\n        // make queue to store the nodes breadth first, add root\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        \\n        queue.add(root);\\n        queue.add(null); // a null indicates that the current level has ended, the next level begin from next node in the queue\\n        \\n        while (queue.size() != 0)\\n        {\\n            // get the first element from queue\\n            TreeNode cur = queue.remove();\\n            \\n            // if we get null, move to next level, check if queue is empty else it will result in infinite loop\\n            if (cur == null)\\n            {\\n                if (queue.size() == 0)\\n                    break;\\n                \\n                queue.add(null);\\n            }\\n            \\n            else\\n            {\\n                // the last element of each level (the element before null) will be seen from the right side\\n                if (queue.peek() == null)\\n                    ans.add(cur.val);\\n                \\n                // add the children of current element in queue, as part of the next level\\n                if (cur.left != null)\\n                    queue.add(cur.left);\\n                \\n                if (cur.right != null)\\n                    queue.add(cur.right);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\nKeeping track of depth, i.e when going to a child node, increase depth and when coming back, decrease depth.\\nAt each new level (depth), add the rightmost node to the answer list.\\nSince we go to the **right child first** and then the left, when we arrive on a new level **for the first time**, we shall always arrive at the rightmost node.\\n*/\\nclass Solution {\\n    \\n    int depth = 0;\\n    List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        if(root == null)\\n            return ans;\\n        \\n        depth++;\\n        \\n        if (ans.size() < depth)\\n            ans.add(root.val);\\n        \\n        ans = rightSideView(root.right);\\n        ans = rightSideView(root.left);\\n        \\n        depth--;\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        // create array to store answer\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        // check for edge case\\n        if (root == null)\\n            return ans;\\n        \\n        // make queue to store the nodes breadth first, add root\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        \\n        queue.add(root);\\n        queue.add(null); // a null indicates that the current level has ended, the next level begin from next node in the queue\\n        \\n        while (queue.size() != 0)\\n        {\\n            // get the first element from queue\\n            TreeNode cur = queue.remove();\\n            \\n            // if we get null, move to next level, check if queue is empty else it will result in infinite loop\\n            if (cur == null)\\n            {\\n                if (queue.size() == 0)\\n                    break;\\n                \\n                queue.add(null);\\n            }\\n            \\n            else\\n            {\\n                // the last element of each level (the element before null) will be seen from the right side\\n                if (queue.peek() == null)\\n                    ans.add(cur.val);\\n                \\n                // add the children of current element in queue, as part of the next level\\n                if (cur.left != null)\\n                    queue.add(cur.left);\\n                \\n                if (cur.right != null)\\n                    queue.add(cur.right);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114121,
                "title": "my-python-dfs-solution",
                "content": "```\\ndef rightSideView(self, root: TreeNode) -> List[int]:\\n        # Step 1: identify the end of the level\\n        # Step 2: add last node to the result\\n        \\n        # dfs\\n        # 1) prioritize right side\\n        # 2) keep track level of nodes\\n        \\n        res = []\\n        self.dfs(root, 0, res)\\n        return res\\n    \\n    def dfs(self, node, curLevel, res):\\n        if not node: #base case to return\\n            return\\n        \\n        if curLevel >= len(res): #push the value in\\n            res.append(node.val)\\n            \\n        #preorder traversal\\n        if node.right:\\n            self.dfs(node.right, curLevel+1, res)\\n        if node.left:\\n            self.dfs(node.left, curLevel+1, res)\\n# T: O(N)\\n# S: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef rightSideView(self, root: TreeNode) -> List[int]:\\n        # Step 1: identify the end of the level\\n        # Step 2: add last node to the result\\n        \\n        # dfs\\n        # 1) prioritize right side\\n        # 2) keep track level of nodes\\n        \\n        res = []\\n        self.dfs(root, 0, res)\\n        return res\\n    \\n    def dfs(self, node, curLevel, res):\\n        if not node: #base case to return\\n            return\\n        \\n        if curLevel >= len(res): #push the value in\\n            res.append(node.val)\\n            \\n        #preorder traversal\\n        if node.right:\\n            self.dfs(node.right, curLevel+1, res)\\n        if node.left:\\n            self.dfs(node.left, curLevel+1, res)\\n# T: O(N)\\n# S: O(N)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383023,
                "title": "simplest-python-recursion",
                "content": "The logic is simple:\\ni. get the right side view of the left and right sub-trees, minus the current node\\nii. if the left sub-tree is taller than the right sub-tree, append the end of the left sub-tree\\niii. otherwise the left sub-tree is totally blocked by the right sub-tree in the right side view.\\n\\n```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            left = self.rightSideView(root.left)\\n            right = self.rightSideView(root.right)\\n            if len(right) >= len(left):\\n                return [root.val] + right\\n            else:\\n                return [root.val] + right + left[len(right):]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            left = self.rightSideView(root.left)\\n            right = self.rightSideView(root.right)\\n            if len(right) >= len(left):\\n                return [root.val] + right\\n            else:\\n                return [root.val] + right + left[len(right):]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171119,
                "title": "python-bfs-dfs",
                "content": "### 199. Binary Tree Right Side View\\n```\\n> \\u7C7B\\u578B\\uFF1ABFS | DFS\\n> Time Complexity O(N)\\n> Space Complexity O(N)\\n```\\n\\n\\u601D\\u8DEF1\\uFF1ABFS, Level Order\\uFF0C\\u6253\\u5370\\u6700\\u53F3\\u8FB9\\n\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root: return []\\n        q, res = deque([root]), []\\n        while q:\\n            res.append(q[-1].val)\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                if cur.left:\\n                    q.append(cur.left)\\n                if cur.right:\\n                    q.append(cur.right)\\n        return res\\n```\\n\\n\\u601D\\u8DEF2\\uFF1A DFS\\uFF0C\\u5148\\u9012\\u5F52\\u53F3\\uFF0C\\u540E\\u9012\\u5F52\\u5DE6\\uFF0C\\u8BB0\\u5F55\\u4E00\\u4E2A\\u6DF1\\u5EA6\\uFF0C\\u5F53\\u8FDB\\u5165\\u65B0\\u7684\\u4E00\\u5C42\\u6DF1\\u5EA6\\uFF0C\\u5C06\\u5F53\\u524Droot.val\\u653E\\u5165return\\u6570\\u7EC4\\u91CC\\u3002\\n\\n```python\\nclass Solution:\\n    def rightSideView(self, root):\\n        self.res = []\\n        self.dfs(root, 0)\\n        return self.res\\n    \\n    def dfs(self, node, depth):\\n        if not node: return\\n        if depth == len(self.res):\\n            self.res.append(node.val)\\n        self.dfs(node.right, depth+1)\\n        self.dfs(node.left, depth+1)\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ABFS | DFS\\n> Time Complexity O(N)\\n> Space Complexity O(N)\\n```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root: return []\\n        q, res = deque([root]), []\\n        while q:\\n            res.append(q[-1].val)\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                if cur.left:\\n                    q.append(cur.left)\\n                if cur.right:\\n                    q.append(cur.right)\\n        return res\\n```\n```python\\nclass Solution:\\n    def rightSideView(self, root):\\n        self.res = []\\n        self.dfs(root, 0)\\n        return self.res\\n    \\n    def dfs(self, node, depth):\\n        if not node: return\\n        if depth == len(self.res):\\n            self.res.append(node.val)\\n        self.dfs(node.right, depth+1)\\n        self.dfs(node.left, depth+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265611,
                "title": "python3-dfs-recursion-10-lines-t-m-98-70",
                "content": "```\\nclass Solution:\\n                        # The plan here is to dfs the tree, right-first\\n                        # (opposite of  the usual left-first method), and\\n                        # keeping track of the tree levels as we proceed. The \\n                        # first node we visit on each level is the right-side view \\n                        # node. We know it\\'s the first because the level will be\\n                        # one greater than the length of the current answer list.\\n\\n    def rightSideView(self, root: TreeNode) -> list[int]:\\n        ans =[]\\n        \\n        def dfs(node =root,level=1):\\n            if not node: return\\n            \\n            if len(ans) < level: \\n                ans.append(node.val)\\n            dfs(node.right,level+1)         #  <--- right first\\n            dfs(node.left ,level+1)         #  <--- then left\\n\\n            return \\n\\n        dfs()\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n                        # The plan here is to dfs the tree, right-first\\n                        # (opposite of  the usual left-first method), and\\n                        # keeping track of the tree levels as we proceed. The \\n                        # first node we visit on each level is the right-side view \\n                        # node. We know it\\'s the first because the level will be\\n                        # one greater than the length of the current answer list.\\n\\n    def rightSideView(self, root: TreeNode) -> list[int]:\\n        ans =[]\\n        \\n        def dfs(node =root,level=1):\\n            if not node: return\\n            \\n            if len(ans) < level: \\n                ans.append(node.val)\\n            dfs(node.right,level+1)         #  <--- right first\\n            dfs(node.left ,level+1)         #  <--- then left\\n\\n            return \\n\\n        dfs()\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1299911,
                "title": "simple-c-recursive-solution-0ms-faster-than-100-clean-code-and-easy-to-understand",
                "content": "Approach : We have to store a global variable ``` maxLevel ``` to ensure the maxLevel upto which we have calculated the right side view of the tree and then we recursively check if current level is greater than maxLevel. Then only we will append the new variable in ```ans``` array.\\n\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments \\uD83D\\uDE42. Thanks for reading.\\n\\n    vector<int>ans ;\\n    \\n    int maxLevel = 0 ;\\n    \\n    void rightView(TreeNode* root,int level){\\n        \\n        if(root == NULL)\\n            return ;\\n        \\n        if(level>maxLevel)\\n        {\\n            ans.push_back(root->val);\\n            maxLevel += 1 ;\\n        }\\n        \\n        if(root->right)\\n            rightView(root->right,level+1);\\n        \\n        if(root->left)\\n            rightView(root->left,level+1);\\n        \\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        rightView(root,1);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "``` maxLevel ```\n```ans```",
                "codeTag": "Unknown"
            },
            {
                "id": 56167,
                "title": "dfs-solution-better-than-90-solutions",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if (root == null){\\n                return res;\\n            }\\n            dfs (root, res, 0);\\n            return res;\\n        }\\n        \\n        public void dfs (TreeNode root, List<Integer> res, int level){\\n            if (root == null){\\n                return;\\n            }\\n            if (res.size() == level){\\n                res.add (root.val);\\n            }\\n            if (root.right != null){\\n                dfs (root.right, res, level + 1);\\n            }\\n            if (root.left != null){\\n                dfs (root.left, res, level + 1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if (root == null){\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56183,
                "title": "simple-java-solution-with-bfs",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if(root==null) return result;\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            q.add(root);\\n            while(q.size()>0){\\n                int size = q.size();\\n                for(int i=0;i<size;i++){\\n                    TreeNode node= q.poll();\\n                    if(i==size-1)\\n                        result.add(node.val);\\n                    if(node.left!=null) q.add(node.left);\\n                    if(node.right!=null) q.add(node.right);\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if(root==null) return result;\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            q.add(root);\\n            while(q.size()>0){\\n                int size = q.size();\\n                for(int i=0;i<size;i++){\\n                    TreeNode node= q.poll();\\n                    if(i==size-1)\\n                        result.add(node.val);\\n                    if(node.left!=null) q.add(node.left);\\n                    if(node.right!=null) q.add(node.right);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1052104,
                "title": "c-4-steps-4ms-level-order-traversal-approach-o-n-time",
                "content": "### T = O(N) & S = O(logN)\\n\\n***Explanation :***\\n\\n1. Use `vector v` to store rightmost nodes.\\n2. Use `Queue  Q` to store level wise values.\\n3. At `every level` we will iterate from `(0 -> current Q.size())`  then store `(Q.size()-1)`**th** value into `vector v`.\\n4. ***Congrats*** you have all your `righmost nodes` values in `vector v`, Simply return vector  **: )**\\n\\n\\n```\\n vector<int> rightSideView(TreeNode* root) {\\n        if(!root) {\\n            return {};\\n        }\\n        vector<int> v; //store values of nodes in the rightmost\\n        queue<TreeNode*> Q; //store node type values in queue \\n        Q.push(root); //push root\\n        while(!Q.empty()) { //repeat steps until queue is not empty\\n            \\n            int size = Q.size();  // current size of queue\\n            for(int i = 0; i < size; i++) {\\n              TreeNode* t = Q.front(); //declare a temp node and put front node of queue\\n                Q.pop(); \\n                if(i==size-1) {   //if node is rightmost \\n                    v.push_back(t->val); //push the value of rightmost node into vector\\n                }\\n                if(t->left) {   //if temp->left != NULL then push into queue\\n                    Q.push(t->left);\\n                }\\n                if(t->right) { //if temp->right != NULL then push into queue\\n                    Q.push(t->right);\\n                }\\n            }  \\n        }\\n        return v; //finally we have all values\\n    }\\n```\\n\\n***If you feel any doubt feel free to comment : )***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n vector<int> rightSideView(TreeNode* root) {\\n        if(!root) {\\n            return {};\\n        }\\n        vector<int> v; //store values of nodes in the rightmost\\n        queue<TreeNode*> Q; //store node type values in queue \\n        Q.push(root); //push root\\n        while(!Q.empty()) { //repeat steps until queue is not empty\\n            \\n            int size = Q.size();  // current size of queue\\n            for(int i = 0; i < size; i++) {\\n              TreeNode* t = Q.front(); //declare a temp node and put front node of queue\\n                Q.pop(); \\n                if(i==size-1) {   //if node is rightmost \\n                    v.push_back(t->val); //push the value of rightmost node into vector\\n                }\\n                if(t->left) {   //if temp->left != NULL then push into queue\\n                    Q.push(t->left);\\n                }\\n                if(t->right) { //if temp->right != NULL then push into queue\\n                    Q.push(t->right);\\n                }\\n            }  \\n        }\\n        return v; //finally we have all values\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051937,
                "title": "python-c-bfs-explained",
                "content": "Trick here, is that we **always** need to store nodes of the left, because nodes on the right might end, but on the left tree will keep going down, so left\\'s nodes children might become *right side view* nodes.\\nSolution here is to go *down* one level and get right most value\\n\\n## Better example\\n```\\n         5 => [5]\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2\\n    /\\n   1\\n\\n         5\\n        / \\\\\\n       4   6 => [5, 6]\\n      / \\\\\\n     3   2\\n    /\\n   1\\n\\n         5\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2  => [5, 6, 2]\\n    /\\n   1\\n         5\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2\\n    /\\n   1   => [5, 6, 2, 1]\\n ```\\n\\n## Python code:\\n```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        result = []\\n        stack = [root] if root else []\\n        while stack:\\n            newStack = []\\n            result.append(stack[-1].val)\\n            for n in stack:\\n                if n.left: newStack.append(n.left)\\n                if n.right: newStack.append(n.right)\\n            stack = newStack\\n        return result\\n```\\n\\n## C++ code:\\n```\\nclass Solution {\\n  public:\\n    vector<int> rightSideView(TreeNode* root) {\\n      vector<int> result;\\n      vector<TreeNode*> stack;\\n      if (root) stack.push_back(root);\\n      while (stack.size()) {\\n        result.push_back(stack.back()->val);\\n        vector<TreeNode*> newStack;\\n        for (TreeNode* n : stack) {\\n          if (n->left) newStack.push_back(n->left);\\n          if (n->right) newStack.push_back(n->right);\\n        }\\n        stack = newStack;\\n      }\\n      return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n         5 => [5]\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2\\n    /\\n   1\\n\\n         5\\n        / \\\\\\n       4   6 => [5, 6]\\n      / \\\\\\n     3   2\\n    /\\n   1\\n\\n         5\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2  => [5, 6, 2]\\n    /\\n   1\\n         5\\n        / \\\\\\n       4   6\\n      / \\\\\\n     3   2\\n    /\\n   1   => [5, 6, 2, 1]\\n ```\n```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        result = []\\n        stack = [root] if root else []\\n        while stack:\\n            newStack = []\\n            result.append(stack[-1].val)\\n            for n in stack:\\n                if n.left: newStack.append(n.left)\\n                if n.right: newStack.append(n.right)\\n            stack = newStack\\n        return result\\n```\n```\\nclass Solution {\\n  public:\\n    vector<int> rightSideView(TreeNode* root) {\\n      vector<int> result;\\n      vector<TreeNode*> stack;\\n      if (root) stack.push_back(root);\\n      while (stack.size()) {\\n        result.push_back(stack.back()->val);\\n        vector<TreeNode*> newStack;\\n        for (TreeNode* n : stack) {\\n          if (n->left) newStack.push_back(n->left);\\n          if (n->right) newStack.push_back(n->right);\\n        }\\n        stack = newStack;\\n      }\\n      return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220522,
                "title": "199-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The idea is to perform a level order traversal of the tree and keep track of the last node at each level.\\n- We can use a queue to perform the traversal. We start by adding the root to the queue.\\n- At each level, we keep track of the length of the queue at the beginning of the level. We iterate over this length and pop the first element of the queue. If we are at the last element of the level, we add its value to the result list.\\n- We then add the left and right children of the current node to the queue, if they exist.\\n- Finally, we return the result list containing the right side view of the tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        result = []\\n        queue = collections.deque()\\n        queue.append(root)\\n        while queue:\\n            level_len = len(queue)\\n            for i in range(level_len):\\n                node = queue.popleft()\\n                if i == level_len - 1:\\n                    result.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        result = []\\n        queue = collections.deque()\\n        queue.append(root)\\n        while queue:\\n            level_len = len(queue)\\n            for i in range(level_len):\\n                node = queue.popleft()\\n                if i == level_len - 1:\\n                    result.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180039,
                "title": "elegant-bfs-approach-with-explanation",
                "content": "# Intuition\\nWe need to consider the tree top-down level by level and find the right most nodes for each level.\\n\\n# Approach\\nWe use Breadth-First Search implemented via queue. After traversing each level we find the right most node and collect its value in the result list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n\\n        rigthElements = []\\n        queue = [root]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.pop(0)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n\\n            rigthElements.append(node.val)\\n\\n        return rigthElements\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n\\n        rigthElements = []\\n        queue = [root]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.pop(0)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n\\n            rigthElements.append(node.val)\\n\\n        return rigthElements\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052029,
                "title": "javascript-clean-and-simple-bfs",
                "content": "```javascript\\nvar rightSideView = function(root) {\\n    if(!root) return []\\n    \\n    let queue = [root];\\n    const result = [root.val]\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let node of queue) {\\n            if(node.left) next.push(node.left);\\n            if(node.right) next.push(node.right);\\n        }\\n        if(next.length) result.push(next[next.length-1].val);\\n        queue = next;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar rightSideView = function(root) {\\n    if(!root) return []\\n    \\n    let queue = [root];\\n    const result = [root.val]\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let node of queue) {\\n            if(node.left) next.push(node.left);\\n            if(node.right) next.push(node.right);\\n        }\\n        if(next.length) result.push(next[next.length-1].val);\\n        queue = next;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051914,
                "title": "python-bfs",
                "content": "We need the rightmost entry of each level. Since we go level-by-level it is BFS.\\nOne thing is, we only want to add the last element of each level. Traverse the nodes from right-to-left and store the depth of each node. Add a node to answer only if its depth is larger than the maximum depth observed so far, i.e. `d > prev_d` below.\\n\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root: return []\\n        \\n        ans = []\\n        que = deque([(root, 0)])\\n        prev_d = -1\\n        while que:\\n            node, d = que.popleft()\\n            if node.right: que.append((node.right, d+1))\\n            if node.left: que.append((node.left, d+1))\\n            if d>prev_d: ans.append(node.val)\\n            prev_d = d\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import deque\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root: return []\\n        \\n        ans = []\\n        que = deque([(root, 0)])\\n        prev_d = -1\\n        while que:\\n            node, d = que.popleft()\\n            if node.right: que.append((node.right, d+1))\\n            if node.left: que.append((node.left, d+1))\\n            if d>prev_d: ans.append(node.val)\\n            prev_d = d\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755360,
                "title": "easy-to-understand-dfs-bfs-faster-simple-python-solutions",
                "content": "The DFS part (recursive)\\n\\n```\\n\\tdef dfs(self, root):\\n\\t\\tout = []\\n\\t\\tdef rec(node, level):\\n\\t\\t\\tif node:\\n\\t\\t\\t\\tif len(out) > level:\\n\\t\\t\\t\\t\\tout[level] = node.val\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tout.append(node.val)\\n\\t\\t\\t\\trec(node.left, level + 1)\\n\\t\\t\\t\\trec(node.right, level + 1)\\n\\n\\t\\trec(root, 0)\\n\\treturn out\\n    \\n```\\n\\n\\nThe BFS part (Iterative)\\n\\n```\\ndef bfs(self, root):\\n        if not root: return []\\n        queue = deque()\\n        queue.append(root)\\n        arr = []\\n        while len(queue):\\n            temp = deque()\\n            tarr = []\\n            while len(queue):\\n                top = queue.popleft()\\n                tarr.append(top.val)\\n                if top.left: temp.append(top.left)\\n                if top.right: temp.append(top.right)\\n            _ = len(tarr) and arr.append(tarr[-1])\\n            queue = temp\\n        return arr\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\tdef dfs(self, root):\\n\\t\\tout = []\\n\\t\\tdef rec(node, level):\\n\\t\\t\\tif node:\\n\\t\\t\\t\\tif len(out) > level:\\n\\t\\t\\t\\t\\tout[level] = node.val\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tout.append(node.val)\\n\\t\\t\\t\\trec(node.left, level + 1)\\n\\t\\t\\t\\trec(node.right, level + 1)\\n\\n\\t\\trec(root, 0)\\n\\treturn out\\n    \\n```\n```\\ndef bfs(self, root):\\n        if not root: return []\\n        queue = deque()\\n        queue.append(root)\\n        arr = []\\n        while len(queue):\\n            temp = deque()\\n            tarr = []\\n            while len(queue):\\n                top = queue.popleft()\\n                tarr.append(top.val)\\n                if top.left: temp.append(top.left)\\n                if top.right: temp.append(top.right)\\n            _ = len(tarr) and arr.append(tarr[-1])\\n            queue = temp\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 751120,
                "title": "c-bfs-vs-dfs-solutions-compared-and-explained-100-time-80-space",
                "content": "So, pretty straightfoward solution, if you ask me: BFS is the way to go and while I see it doable also with a DFS approach (either storing a lot more data in or building a painfully tricky backtrack system), I will once again fully and passionately embrace the [KISS approach](https://en.wikipedia.org/wiki/KISS_principle) on this one.\\n\\nWe start creating an empty vector `res`; if the tree is empty itself (ie: `!root`, then we just return it).\\n\\nIf not, we know we have at least one layer to grind through our BFS routine: we can initialise a queue container `layer` to store all the nodes at each level as we go and we pre-populate it with `root`.\\n\\nA few more support variable might be worth initialisation here and we are going to dive into our breadth first search until `layer` has at least one surviving element.\\n\\nUnlike other similar problems, here we can start directly from the end result - we push the rightmost value of each `layer` into `res`. And then we move on to populate `layer` for the next iteration, extracting each single note and checking if it has any `left` or `right` children to pass down.\\n\\nOnce there are no more nodess to be scanned, we are finally done and we can return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        // exiting with an empty tree\\n        if (!root) return res;\\n        // some useful variable initialisation\\n        queue<TreeNode*> layer;\\n        layer.push(root);\\n        int len;\\n        TreeNode *currNode;\\n        // BFS loop\\n        while (layer.size()) {\\n            // first of all, let\\'s update res\\n            res.push_back(layer.back()->val);\\n            // then let\\'s prepare layer for the next run\\n            len = layer.size();\\n            while (len--) {\\n                currNode = layer.front();\\n                layer.pop();\\n                if (currNode->left) layer.push(currNode->left);\\n                if (currNode->right) layer.push(currNode->right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCan we do better? Probably, since queues are hardly the top performing solution you might get for this kind of problem.\\n\\nAnd going with a DFS is still cool, nevertheless.\\n\\nTo solve this problem, we then refactored and created `res` at class level and then called the helper function `dfs` to populate it.\\n\\nThis function is taking 2 parameters, `root` (our starting node) and `layer` (defaulted to `0`).\\n\\nAt each call, we will:\\n* just `return` is `root` is `NULL`;\\n* store the value of the current node:\\n\\t* replacing the current value of `res[layer]` when there was already one (`res.size() > layer`), since we proceed with a preorder, so we know that the last element is always the rightmost);\\n\\t* add it to `res` otherwise;\\n* recursively call it `dfs` on the `left` and `right` branches.\\n\\nOnce done, we can just return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // support variable\\n    vector<int> res;\\n    void dfs(TreeNode *root, int layer = 0) {\\n        // edge case: no node\\n        if (!root) return;\\n        // updating the node on that layer if existing\\n        if (res.size() > layer) res[layer] = root->val;\\n        // adding it to res if there was no previous element\\n        else res.push_back(root->val);\\n        // recursive calls\\n        dfs(root->left, ++layer);\\n        dfs(root->right, layer);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        // exiting with an empty tree\\n        if (!root) return res;\\n        // some useful variable initialisation\\n        queue<TreeNode*> layer;\\n        layer.push(root);\\n        int len;\\n        TreeNode *currNode;\\n        // BFS loop\\n        while (layer.size()) {\\n            // first of all, let\\'s update res\\n            res.push_back(layer.back()->val);\\n            // then let\\'s prepare layer for the next run\\n            len = layer.size();\\n            while (len--) {\\n                currNode = layer.front();\\n                layer.pop();\\n                if (currNode->left) layer.push(currNode->left);\\n                if (currNode->right) layer.push(currNode->right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // support variable\\n    vector<int> res;\\n    void dfs(TreeNode *root, int layer = 0) {\\n        // edge case: no node\\n        if (!root) return;\\n        // updating the node on that layer if existing\\n        if (res.size() > layer) res[layer] = root->val;\\n        // adding it to res if there was no previous element\\n        else res.push_back(root->val);\\n        // recursive calls\\n        dfs(root->left, ++layer);\\n        dfs(root->right, layer);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56195,
                "title": "concise-java-solution-based-on-bfs",
                "content": "The basic idea is using level by level BFS to traverse the tree: add the right-most node of each level to the  result.\\n\\n**Runtime complexity = O(n)**\\n\\nn is the number of the nodes in the tree: because each node is visited only once, so the runtime complexity is O(n).\\n\\n    public List<Integer> rightSideView(TreeNode root) {\\n    \\tList<Integer>res = new ArrayList<Integer>();\\n    \\tif (root == null) return res;\\n    \\tQueue<TreeNode>queue = new LinkedList<TreeNode>();\\n    \\t\\n    \\tqueue.offer(root);\\t\\t\\n    \\twhile (!queue.isEmpty()) {//Level by level BFS \\n    \\t\\tint count = queue.size();\\n    \\t\\tfor (int i = 0; i < count; i++) {\\n    \\t\\t\\tTreeNode node = queue.poll();\\n    \\t\\t\\tif (i == count - 1) // The right-most node of the current level\\n    \\t\\t\\t\\tres.add(node.val);\\n    \\t\\t\\tif (node.left != null)\\n    \\t\\t\\t\\tqueue.offer(node.left);\\n    \\t\\t\\tif (node.right != null)\\n    \\t\\t\\t\\tqueue.offer(node.right);\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is using level by level BFS to traverse the tree: add the right-most node of each level to the  result.\\n\\n**Runtime complexity = O(n)**\\n\\nn is the number of the nodes in the tree: because each node is visited only once, so the runtime complexity is O(n).\\n\\n    public List<Integer> rightSideView(TreeNode root) {\\n    \\tList<Integer>res = new ArrayList<Integer>();\\n    \\tif (root == null) return res;\\n    \\tQueue<TreeNode>queue = new LinkedList<TreeNode>();\\n    \\t\\n    \\tqueue.offer(root);\\t\\t\\n    \\twhile (!queue.isEmpty()) {//Level by level BFS \\n    \\t\\tint count = queue.size();\\n    \\t\\tfor (int i = 0; i < count; i++) {\\n    \\t\\t\\tTreeNode node = queue.poll();\\n    \\t\\t\\tif (i == count - 1) // The right-most node of the current level\\n    \\t\\t\\t\\tres.add(node.val);\\n    \\t\\t\\tif (node.left != null)\\n    \\t\\t\\t\\tqueue.offer(node.left);\\n    \\t\\t\\tif (node.right != null)\\n    \\t\\t\\t\\tqueue.offer(node.right);\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3708277,
                "title": "clean-python-3-10-solution-without-deque",
                "content": "# Intuition\\nThis Python 3.10 solution leverages the enhanced readability and functionality provided by the latest version of Python\\'s typing system. The approach ditches the deque data structure for a simple list, presenting a cleaner and more elegant solution.\\n\\n# Approach\\nThe strategy of this solution is to employ a classic breadth-first search (BFS) technique, facilitated by a queue data structure. This queue is not the traditional double-ended queue (deque), but a standard list. We iteratively traverse the binary tree level by level, from left to right. During this traversal, the rightmost node at each level is the one visible from the right side. By keeping track of the nodes in our queue, we ensure that the rightmost node is always added to our result list, providing the correct output for the problem.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: up to $$O(n/2)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: TreeNode | None) -> List[int]:\\n        if not root:\\n            return []\\n\\n        ans = []        \\n        q = [root]\\n\\n        while q:            \\n            ans.append(q[-1].val)\\n            q = [child for node in q for child in (node.left, node.right) if child]\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: TreeNode | None) -> List[int]:\\n        if not root:\\n            return []\\n\\n        ans = []        \\n        q = [root]\\n\\n        while q:            \\n            ans.append(q[-1].val)\\n            q = [child for node in q for child in (node.left, node.right) if child]\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775274,
                "title": "visual-explaination-bfs-python-easy",
                "content": "![image](https://assets.leetcode.com/users/images/8fd72686-e397-411c-a9db-6ee4c0aa3c5b_1645001232.0804284.png)\\n\\n\\n* Traverse level wise.\\n* Append `LAST` element of each level to `new list.`\\n*` RETURN list.`\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        a=self.bfs(root)\\n        res=[]\\n        for i in a:\\n            res.append(i[-1])\\n        return res\\n        \\n        #BFS TRAVERSAL    \\n    def bfs(self,root):\\n            res=[]\\n            q=collections.deque()\\n            q.append(root)\\n\\n            while q:\\n                level=[]\\n                len_q=len(q)\\n                for i in range(len_q):\\n                    node=q.popleft()\\n                    if node:\\n                        level.append(node.val)\\n                        q.append(node.left)\\n                        q.append(node.right)\\n                if level:\\n                    res.append(level)\\n            return res\\n       \\n        \\n        \\n        \\n```\\nPlease **UPVOTE  \\u23CF\\uFE0F if it helped you.**",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        a=self.bfs(root)\\n        res=[]\\n        for i in a:\\n            res.append(i[-1])\\n        return res\\n        \\n        #BFS TRAVERSAL    \\n    def bfs(self,root):\\n            res=[]\\n            q=collections.deque()\\n            q.append(root)\\n\\n            while q:\\n                level=[]\\n                len_q=len(q)\\n                for i in range(len_q):\\n                    node=q.popleft()\\n                    if node:\\n                        level.append(node.val)\\n                        q.append(node.left)\\n                        q.append(node.right)\\n                if level:\\n                    res.append(level)\\n            return res\\n       \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510330,
                "title": "javascript-super-easy-bfs-solution",
                "content": "```\\nvar rightSideView = function(root) {\\n    if(!root) return [];\\n    const q = [root];\\n    const result = [];\\n    while(q.length){\\n        const size = q.length;\\n        result.push(q[size-1].val);\\n        for(let i=0; i<size; i++){\\n            const node = q.shift();\\n            node.left && q.push(node.left);\\n            node.right && q.push(node.right);\\n        }\\n    }\\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nvar rightSideView = function(root) {\\n    if(!root) return [];\\n    const q = [root];\\n    const result = [];\\n    while(q.length){\\n        const size = q.length;\\n        result.push(q[size-1].val);\\n        for(let i=0; i<size; i++){\\n            const node = q.shift();\\n            node.left && q.push(node.left);\\n            node.right && q.push(node.right);\\n        }\\n    }\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 708928,
                "title": "python-bfs-97-80",
                "content": "```\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root:\\n            return []\\n        \\n        results, q = [root.val], [root]\\n        \\n        while q:\\n            next_level = []\\n            for node in q:\\n                if node.left:\\n                    next_level.append(node.left)\\n                if node.right:\\n                    next_level.append(node.right)\\n            if next_level:\\n                results.append(next_level[-1].val)\\n            q = next_level\\n        \\n        return results",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root):\\n        if not root:\\n            return []\\n        \\n        results, q = [root.val], [root]\\n        \\n        while q:\\n            next_level = []\\n            for node in q:\\n                if node.left:\\n                    next_level.append(node.left)\\n                if node.right:\\n                    next_level.append(node.right)\\n            if next_level:\\n                results.append(next_level[-1].val)\\n            q = next_level\\n        \\n        return results",
                "codeTag": "Java"
            },
            {
                "id": 671688,
                "title": "intuitive-javascript-solution-with-9-lines-of-code-recursive-dfs-memory-o-h-time-o-n",
                "content": "\\n```\\nvar rightSideView = function(root) {\\n    \\n  const result = []\\n\\n  var traverse = function(node,level){\\n      if (!node) return\\n      result[level] = node.val\\n      traverse(node.left,level+1)\\n      traverse(node.right,level+1)\\n  }\\n  \\n  traverse(root,0)\\n  return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar rightSideView = function(root) {\\n    \\n  const result = []\\n\\n  var traverse = function(node,level){\\n      if (!node) return\\n      result[level] = node.val\\n      traverse(node.left,level+1)\\n      traverse(node.right,level+1)\\n  }\\n  \\n  traverse(root,0)\\n  return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413132,
                "title": "bfs-java-2-x-100-solution-with-explanation",
                "content": "BFS is really useful in the tree stucture and 2D DP solution based matrix, It is worth time to master this algorithem!\\nThe basic idea is that BFS will find all the child node in the same level, and we just need to reutrn the last node value for each level.\\n\\n[Othe questions can solve by BFS:]\\n102,103\\tBinary Tree Level Order Traversal \\n116,117 Populating Next Right Pointers in Each Node  \\n429\\tN-ary Tree Level Order Traversal\\n513, 515 Find Bottom Left Tree Value\\n\\nHere is my code:\\n```\\npublic List<Integer> rightSideView(TreeNode root) {\\n        Queue<TreeNode> q= new ArrayDeque<>();\\n        List<Integer> res = new ArrayList<>();\\n        if(root == null) return res;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i< size; i++){\\n                TreeNode node = q.poll();\\n                if(i == size-1) res.add(node.val);\\n                if(node.left != null) q.offer(node.left);\\n                if(node.right != null) q.offer(node.right);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic List<Integer> rightSideView(TreeNode root) {\\n        Queue<TreeNode> q= new ArrayDeque<>();\\n        List<Integer> res = new ArrayList<>();\\n        if(root == null) return res;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i< size; i++){\\n                TreeNode node = q.poll();\\n                if(i == size-1) res.add(node.val);\\n                if(node.left != null) q.offer(node.left);\\n                if(node.right != null) q.offer(node.right);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56153,
                "title": "o-n-java-solution-using-level-order-traversal",
                "content": "    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            List<Integer> rst = new ArrayList<>();\\n            if(root == null) return rst;\\n            \\n            queue.offer(root);\\n            while(!queue.isEmpty()){\\n                int levelNum = queue.size();\\n                for(int i = 0; i < levelNum; i++){\\n                    if(queue.peek().left != null) queue.offer(queue.peek().left);\\n                    if(queue.peek().right != null) queue.offer(queue.peek().right);\\n                    if(i == levelNum - 1) rst.add(queue.poll().val);\\n                    else queue.poll();\\n                }\\n            }\\n            return rst;\\n        }\\n    }\\n\\nUsing level order traversal and put the last one of each level into the result list.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            List<Integer> rst = new ArrayList<>();\\n            if(root == null) return rst;\\n            \\n            queue.offer(root);\\n            while(!queue.isEmpty()){\\n                int levelNum = queue.size();\\n                for(int i = 0; i < levelNum; i++){\\n                    if(queue.peek().left != null) queue.offer(queue.peek().left);\\n                    if(queue.peek().right != null) queue.offer(queue.peek().right);\\n                    if(i == levelNum - 1) rst.add(queue.poll().val);\\n                    else queue.poll();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3648112,
                "title": "c-easy-method",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    void dfs(TreeNode* root, int l){\\n        if(root==NULL)return;\\n        if(m.find(l)==m.end()){\\n            m[l]=root->val;\\n        }\\n        dfs(root->right,l+1);\\n        dfs(root->left,l+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>a;\\n        if(!root)return a;\\n        dfs(root,1);\\n        for(auto i:m)a.push_back(i.second);\\n        return a;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/ce7300c9-d190-497c-aad5-363de8fd7bb8_1686996867.939819.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    void dfs(TreeNode* root, int l){\\n        if(root==NULL)return;\\n        if(m.find(l)==m.end()){\\n            m[l]=root->val;\\n        }\\n        dfs(root->right,l+1);\\n        dfs(root->left,l+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>a;\\n        if(!root)return a;\\n        dfs(root,1);\\n        for(auto i:m)a.push_back(i.second);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265618,
                "title": "java-solution-recursion",
                "content": "```java \\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        ArrayList<Integer> a = new ArrayList<Integer>();\\n        traverse(root,a,0);\\n        return a;\\n    }\\n    \\n    private void traverse(TreeNode root,ArrayList<Integer> a,int c)\\n    {\\n        if(root==null)\\n            return;\\n        if(c==a.size())    //level no. should be equal to index no. in list\\n        a.add(root.val);\\n        traverse(root.right,a,c+1);\\n        traverse(root.left,a,c+1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        ArrayList<Integer> a = new ArrayList<Integer>();\\n        traverse(root,a,0);\\n        return a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1951025,
                "title": "java-1ms-bfs-explanation-simple-o-n",
                "content": "The trick to solve this problem is to fully understand either **Breadth-First-Search (BFS) or Depth-First-Search (DFS)**.  Without understanding and being very comfortable with these concepts, this problem will be tricky. If you are not familiar with both of these concept, I would recommend reading up on them more. They are extremely useful when it comes to graph traversal.\\n\\nFor this problem, I chose to use **Breadth-First-Search (BFS) to solve it**. This seemed the most natural to me as the question lends itself well to **Level-Order Traversal**.\\n\\nThe idea is simple as long as you have a good understanding of **Breadth-First-Search (BFS)**. We just need to add the last element in each level to the output result List\\\\<Integer\\\\>.\\n\\n*See below the solution for a quick explanation of Breadth-First-Search (BFS) as it relates to this problem.*\\n\\nIt is also worth mentioning, I saw a clever solution to the problem using recursion and **Depth-First-Search (DFS)** which I had not originally thought of. I personally would prefer a **Breadth-First** approach to this problem, but the **Depth-First solution is clever** and I will post a [link to one written in Python](https://leetcode.com/problems/binary-tree-right-side-view/discuss/1950338/DFS-python-solution.).\\n\\n**Runtime Complexity - O(N)**\\n**Memory Complexity - O(N)**\\nwhere N is the number of nodes in the input Tree.\\n```\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        if(root == null) return toReturn;\\n        \\n        Queue<TreeNode> nodeQueue = new LinkedList<>();\\n        nodeQueue.offer(root);\\n        \\n        while(!nodeQueue.isEmpty()) {\\n            int levelSize = nodeQueue.size();\\n            \\n            for(int i = 0; i < levelSize; i++) {\\n                TreeNode currentNode = nodeQueue.poll();\\n                \\n                if(currentNode.left != null) nodeQueue.offer(currentNode.left);\\n                if(currentNode.right != null) nodeQueue.offer(currentNode.right);\\n                \\n                if(i == levelSize - 1) toReturn.add(currentNode.val);\\n            }\\n        }\\n        \\n        return toReturn;\\n    }\\n```\\n\\nThe entire **idea of Breadth-First-Search (BFS)** for those unfamiliar, is to search a **graph** from some starting point in the order of visiting the current nodes closest **neighbors first**. In the **context of a tree**, that is **each level / height of the tree**. Put in another way, **Breadth-First-Search (BFS)** searches \"wide\" (from left to right) first before going deeper.\\n\\nThe true trick to **implementing Breadth-First-Search (BFS)** and being able to distinguish between elements from a single level from elements currently being added for the next level, is to keep track of the **size of the queue before starting the traversal of the current level**.\\n\\nThis is because, prior to the start of a level, the queue will only contain items from the level that is about to be processed. That being said, if we only iterate nodeQueue.size() times, then we can add new deeper nodes to the queue without those nodes being mixed with nodes from the current level.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        if(root == null) return toReturn;\\n        \\n        Queue<TreeNode> nodeQueue = new LinkedList<>();\\n        nodeQueue.offer(root);\\n        \\n        while(!nodeQueue.isEmpty()) {\\n            int levelSize = nodeQueue.size();\\n            \\n            for(int i = 0; i < levelSize; i++) {\\n                TreeNode currentNode = nodeQueue.poll();\\n                \\n                if(currentNode.left != null) nodeQueue.offer(currentNode.left);\\n                if(currentNode.right != null) nodeQueue.offer(currentNode.right);\\n                \\n                if(i == levelSize - 1) toReturn.add(currentNode.val);\\n            }\\n        }\\n        \\n        return toReturn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753031,
                "title": "c-simple-o-n-recursive-solution-using-preorder-traversal",
                "content": "```\\npublic class Solution {\\n    public IList<int> RightSideView(TreeNode root) {\\n        List<int> result = new List<int>();\\n        RightSideDFS(root, 1, result);\\n        return result;\\n    }\\n    \\n    private void RightSideDFS(TreeNode node, int depth, List<int> result) {\\n        if (node == null)\\n            return;\\n        if (result.Count < depth)\\n            result.Add(node.val);\\n        RightSideDFS(node.right, depth+1, result);\\n        RightSideDFS(node.left, depth+1, result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> RightSideView(TreeNode root) {\\n        List<int> result = new List<int>();\\n        RightSideDFS(root, 1, result);\\n        return result;\\n    }\\n    \\n    private void RightSideDFS(TreeNode node, int depth, List<int> result) {\\n        if (node == null)\\n            return;\\n        if (result.Count < depth)\\n            result.Add(node.val);\\n        RightSideDFS(node.right, depth+1, result);\\n        RightSideDFS(node.left, depth+1, result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56159,
                "title": "clear-c-bfs-solution",
                "content": "    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        if(!root)\\n            return res;\\n        queue<TreeNode*> que;\\n        que.push(root);\\n        int count = 1;\\n        while(!que.empty()){\\n            TreeNode *temp = que.front();\\n            que.pop();\\n            if(temp->left)\\n                que.push(temp->left);\\n            if(temp->right)\\n                que.push(temp->right);\\n            count--;\\n            if(count == 0){\\n                count = que.size();\\n                res.push_back(temp->val);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        if(!root)\\n            return res;\\n        queue<TreeNode*> que;\\n        que.push(root);\\n        int count = 1;\\n        while(!que.empty()){\\n            TreeNode *temp = que.front();\\n            que.pop();\\n            if(temp->left)\\n                que.push(temp->left);\\n            if(temp->right)\\n                que.push(temp->right);\\n            count--;\\n            if(count == 0){\\n                count = que.size();\\n                res.push_back(temp->val);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56251,
                "title": "java-solution-of-10-lines-code-dfs",
                "content": "    public class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        help(root,1,result);\\n        return result;\\n    }\\n    public void help(TreeNode root, int depth, List<Integer> result){\\n        if(root==null) return;\\n        if(result.size()<depth) result.add(root.val);\\n        help(root.right,depth+1,result);\\n        help(root.left,depth+1,result);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        help(root,1,result);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 56258,
                "title": "my-4ms-c-iteratvie-solution",
                "content": "My c++ solution is based on level order traversal. The run time is 4ms.\\n\\n    vector<int> rightSideView(TreeNode* root){\\n    \\tvector<int> res;\\n    \\tif (!root)\\n    \\t\\treturn res;\\n    \\tqueue<TreeNode*> q;\\n    \\tq.push(root);\\n    \\tint len;\\n    \\tTreeNode* t;\\n    \\twhile(!q.empty()){\\n    \\t\\tlen = q.size();\\n    \\t\\tfor(int i = 0; i < len; ++i){\\n    \\t\\t\\tt = q.front();\\n    \\t\\t\\tq.pop();\\t\\t\\t\\n    \\t\\t\\tif(t->left)\\n    \\t\\t\\t\\tq.push(t->left);\\n    \\t\\t\\tif(t->right)\\n    \\t\\t\\t\\tq.push(t->right);\\n    \\t\\t}\\n    \\t\\tres.push_back(t->val);\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "My c++ solution is based on level order traversal. The run time is 4ms.\\n\\n    vector<int> rightSideView(TreeNode* root){\\n    \\tvector<int> res;\\n    \\tif (!root)\\n    \\t\\treturn res;\\n    \\tqueue<TreeNode*> q;\\n    \\tq.push(root);\\n    \\tint len;\\n    \\tTreeNode* t;\\n    \\twhile(!q.empty()){\\n    \\t\\tlen = q.size();\\n    \\t\\tfor(int i = 0; i < len; ++i){\\n    \\t\\t\\tt = q.front();\\n    \\t\\t\\tq.pop();\\t\\t\\t\\n    \\t\\t\\tif(t->left)\\n    \\t\\t\\t\\tq.push(t->left);\\n    \\t\\t\\tif(t->right)\\n    \\t\\t\\t\\tq.push(t->right);\\n    \\t\\t}\\n    \\t\\tres.push_back(t->val);\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56291,
                "title": "18-line-recursive-c-solution-in-7-ms",
                "content": "    class Solution {\\n        int level = 0;//number of numbers that have been \"seen\".\\n        vector<int> answer;\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n            if (root!=NULL) travDown(root,0);\\n            return answer;\\n        }\\n        void travDown(TreeNode* nd, int N){//travel down, always go right first\\n            if (N>=level) {\\n                answer.push_back(nd->val);\\n                level++;\\n            }\\n            ++N;\\n            if (nd->right!=NULL) travDown(nd->right,N);\\n            if (nd->left!=NULL) travDown(nd->left,N);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        int level = 0;//number of numbers that have been \"seen\".\\n        vector<int> answer;\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n            if (root!=NULL) travDown(root,0);\\n            return answer;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56304,
                "title": "my-7ms-c-accepted-code",
                "content": "     /**\\n    * Definition for binary tree\\n    * struct TreeNode {\\n    *     int val;\\n    *     TreeNode *left;\\n    *     TreeNode *right;\\n    *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n    * };\\n    */\\n    class Solution {\\n    public:\\n    \\tvector<int> rightSideView(TreeNode *root) {\\n    \\t\\tvector<int> right_side;\\n    \\t\\trightSide(root, right_side, 0);\\n    \\t\\treturn right_side;\\n    \\t}\\n    \\tvoid rightSide(TreeNode *r, vector<int> &a, int i)\\n    \\t{\\n    \\t\\tif (r == NULL)return;\\n    \\t\\tif (i == a.size())\\n    \\t\\t\\ta.push_back(r->val);\\n    \\t\\trightSide(r->right, a, i + 1);\\n    \\t\\trightSide(r->left, a, i + 1);\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<int> rightSideView(TreeNode *root) {\\n    \\t\\tvector<int> right_side;\\n    \\t\\trightSide(root, right_side, 0);\\n    \\t\\treturn right_side;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3831809,
                "title": "c-solutions-recursive-solution-with-visulaization-easy-to-understand",
                "content": "![IMG_3019.jpg](https://assets.leetcode.com/users/images/40da9fd4-2645-479a-bf08-b7f7c94d172b_1690608755.8318143.jpeg)\\n![IMG_3020.jpg](https://assets.leetcode.com/users/images/0b552e33-d467-4444-b393-faf0645d6209_1690608768.7683325.jpeg)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        int level = 0;\\n        rightside(root, level, ans);\\n        return ans;\\n    }\\n\\nprivate:\\n    void rightside(TreeNode* root, int level, std::vector<int>& ans) {\\n        if (root == NULL) {\\n            return ;\\n        }\\n\\n        if (ans.size() == level) {\\n            ans.push_back(root->val);\\n        }\\n\\n        rightside(root->right, level + 1, ans);\\n        rightside(root->left, level + 1, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        int level = 0;\\n        rightside(root, level, ans);\\n        return ans;\\n    }\\n\\nprivate:\\n    void rightside(TreeNode* root, int level, std::vector<int>& ans) {\\n        if (root == NULL) {\\n            return ;\\n        }\\n\\n        if (ans.size() == level) {\\n            ans.push_back(root->val);\\n        }\\n\\n        rightside(root->right, level + 1, ans);\\n        rightside(root->left, level + 1, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625528,
                "title": "simple-solution-in-c-using-maps-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m,m1;\\n    void inorder(TreeNode *root,int c)\\n    {\\n        if(root!=NULL)\\n        {\\n            if(m1[c]==0)\\n            {\\n                m1[c]=1;\\n                m[c]=root->val;\\n            }\\n            inorder(root->right,c+1);\\n            inorder(root->left,c+1);\\n        }\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        inorder(root,1);\\n        vector<int>v;\\n        for(auto l:m)\\n        {\\n            v.push_back(l.second);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m,m1;\\n    void inorder(TreeNode *root,int c)\\n    {\\n        if(root!=NULL)\\n        {\\n            if(m1[c]==0)\\n            {\\n                m1[c]=1;\\n                m[c]=root->val;\\n            }\\n            inorder(root->right,c+1);\\n            inorder(root->left,c+1);\\n        }\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        inorder(root,1);\\n        vector<int>v;\\n        for(auto l:m)\\n        {\\n            v.push_back(l.second);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265980,
                "title": "c-bfs-2method-while-currsize-0-and-using-a-mark-point-with-null-100-0ms",
                "content": "IF you understand please give a **UPVOTE**\\u2B06\\uFE0F\\n**In lymann language** : the Question says if we put a mirror at the right of the tree then return all those nodes who can see their face in mirror.\\n**In Coding Language** : we have to return all those nodes which are rightmost at their respective levels.\\n### Method-1\\n\\n##### Everytime we insert the first node in ans vector ( becoz we traverse left <-- right)  \\nthe first node is desired node. After that we just pushes the other nodes and their respective childs and pop accordingly.\\nHere\\'s the code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return {};\\n        }\\n        vector<int> v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()!=0)\\n        {\\n           int s=q.size();\\n            v.push_back(q.front()->val);\\n            while(s>0)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->right) \\n                {\\n                    q.push(node->right);\\n                }\\n                if(node->left) \\n                {\\n                    q.push(node->left);\\n                }\\n                s--;\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```\\n### Method 2\\nIt\\'s like a mark point\\nIn this approach we insert NULL at the end of level so that when we encounter after the particular node aftr that queue.front ==NULL  then it shows that its a desired node .Wwe push again NULL it will go to the last of the queue and signify the end of next level.\\ntheir are three of cases:\\ni) encounter the null : just leave the node;\\nii) meet with the node with next is NULL ;\\niii) other between nodes just put their child nodes.\\nHere\\'s the code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return {};\\n        }\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(q.size()!=0)\\n        {\\n            auto node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                continue;\\n            }\\n            else if(q.front()==NULL)\\n            {\\n                ans.push_back(node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                q.push(NULL);\\n            }\\n            else\\n            {\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nIF you understand please give a **UPVOTE**\\u2B06\\uFE0F\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return {};\\n        }\\n        vector<int> v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()!=0)\\n        {\\n           int s=q.size();\\n            v.push_back(q.front()->val);\\n            while(s>0)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->right) \\n                {\\n                    q.push(node->right);\\n                }\\n                if(node->left) \\n                {\\n                    q.push(node->left);\\n                }\\n                s--;\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return {};\\n        }\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(q.size()!=0)\\n        {\\n            auto node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                continue;\\n            }\\n            else if(q.front()==NULL)\\n            {\\n                ans.push_back(node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                q.push(NULL);\\n            }\\n            else\\n            {\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265840,
                "title": "simple-java-solution-w-video-explanation-1ms",
                "content": "*Please **Upvote** if you find this helpful*\\n\\n**Video Explanation**\\n[Binary Tree Right Side View | YouTube](https://www.youtube.com/watch?v=kZcqs4BZgjY&feature=youtu.be)\\n\\n**Java Solution**\\n```\\n//1ms\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        dfs(root,ans,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, List<Integer> ans, int depth){\\n        if(root == null)return;\\n        \\n        if(depth == ans.size()) ans.add(root.val);\\n        \\n        dfs(root.right,ans,depth+1);\\n        dfs(root.left,ans,depth+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n//1ms\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        dfs(root,ans,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, List<Integer> ans, int depth){\\n        if(root == null)return;\\n        \\n        if(depth == ans.size()) ans.add(root.val);\\n        \\n        dfs(root.right,ans,depth+1);\\n        dfs(root.left,ans,depth+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265812,
                "title": "go-python-c-java-iterative-bfs-w-comments",
                "content": "<iframe src=\"https://leetcode.com/playground/NMEs9yiU/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Go"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/NMEs9yiU/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1861280,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t\\tview = []\\n\\t\\t\\tqueue = []\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn view\\n\\t\\t\\tqueue.append(root)\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tfor i in range(len(queue)):\\n\\t\\t\\t\\t\\tnode = queue.pop(0)\\n\\t\\t\\t\\t\\tif node.left:  queue.append(node.left)\\n\\t\\t\\t\\t\\tif node.right: queue.append(node.right)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tview.append(node.val)     #this will be at right most \\n\\t\\t\\treturn view\\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\' If any doubt regarding solution please ask \\n\\t\\t\\t if you like it please upvote\\'\\'\\'\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t\\tview = []\\n\\t\\t\\tqueue = []\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn view\\n\\t\\t\\tqueue.append(root)\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tfor i in range(len(queue)):\\n\\t\\t\\t\\t\\tnode = queue.pop(0)\\n\\t\\t\\t\\t\\tif node.left:  queue.append(node.left)\\n\\t\\t\\t\\t\\tif node.right: queue.append(node.right)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tview.append(node.val)     #this will be at right most \\n\\t\\t\\treturn view\\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\' If any doubt regarding solution please ask \\n\\t\\t\\t if you like it please upvote\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 1823845,
                "title": "golang-dfs-100-time-and-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc rightSideView(root *TreeNode) []int {\\n    output := []int{}\\n\\tvar recurse func(root *TreeNode, level int)\\n\\trecurse = func(root *TreeNode, level int) {\\n\\t\\tif root == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif level == len(output) {\\n\\t\\t\\toutput = append(output, root.Val)\\n\\t\\t}\\n\\n\\t\\tif root.Right != nil {\\n\\t\\t\\trecurse(root.Right, level + 1)\\n\\t\\t}\\n\\n\\t\\tif root.Left != nil {\\n\\t\\t\\trecurse(root.Left, level + 1)\\n\\t\\t}\\n\\t}\\n\\n\\trecurse(root, 0)\\n\\treturn output\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc rightSideView(root *TreeNode) []int {\\n    output := []int{}\\n\\tvar recurse func(root *TreeNode, level int)\\n\\trecurse = func(root *TreeNode, level int) {\\n\\t\\tif root == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif level == len(output) {\\n\\t\\t\\toutput = append(output, root.Val)\\n\\t\\t}\\n\\n\\t\\tif root.Right != nil {\\n\\t\\t\\trecurse(root.Right, level + 1)\\n\\t\\t}\\n\\n\\t\\tif root.Left != nil {\\n\\t\\t\\trecurse(root.Left, level + 1)\\n\\t\\t}\\n\\t}\\n\\n\\trecurse(root, 0)\\n\\treturn output\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765813,
                "title": "idiomatic-rust-0-ms-solution-using-bfs",
                "content": "Interacting with trees and other data structures with rust can be a pain because of the issues needing mutable pointers to an immutable object. Definitely read the [Smart pointers](/https://doc.rust-lang.org/book/ch15-00-smart-pointers.html/) Chapter of the rust documentation, if you haven\\'t already/don\\'t know about smart pointers.\\n\\nHigh level overview, the question employs a  little misdirection so you won\\'t immediately realize it is a problem that can easily be solved by breadth-first-search (BFS). The wording given is basically the same as return the rightmost value for every row in the tree. If you recall, BFS traverses the tree by each row in left to right order, if you keep track of each row, you\\'ll be traversing the tree in level-order-traversal. So we\\'ll just get each of the row\\'s last value and push it onto the ans array. There are a lot of BFS and level-order-traversal resources, so I will focus on satisfying with the Rust compilier instead :) All comments are in line.\\n\\nFirst let\\'s look at the function declaration: `pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32>`\\nRust is a strongly typed language, so we need to know the type of the each root node. It\\'s the [Option enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) containing a smart pointer to a `TreeNode` struct. \\n\\n```\\npub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n\\t// Create the vector that we will return, notice rust compiler can figure out the type\\n\\tlet mut ans = vec![]; \\n\\t\\n\\t// Create Vec<Rc<RefCell<TreeNode>> we will use to do our BFS\\n\\t// We no longer use Option<T> because it we will only push onto this vec\\n\\t// if the enum is some (which we will enforce with pattern matching.\\n\\n\\tlet mut bfs = vec![]; \\n\\t\\n\\t// First example of pattern matching. If root contains something,\\n\\t// we\\'ll push the inner part of the enum onto the back of our bfs queue.\\n\\t// If it contains nothing, we\\'ll do nothing a.k.a. ()\\n\\tmatch root {\\n\\t\\tSome(x) => bfs.push(x),\\n\\t\\tNone => ()\\n\\t}\\n    \\n\\t// main loop of BFS, keep going if there is something in the queue.\\n\\twhile bfs.len() != 0 {\\n\\t\\t// First think we want to do is get the value of the TreeNode at the rightmost val\\n\\t\\t// of the bfs vec\\n\\t\\tans.push(bfs[bfs.len()-1].borrow().val);\\n        // Note we have to borrow the node to get access to follow the smart pointer to \\n\\t\\t// the struct itself.\\n\\t\\t\\n\\t\\t// now we\\'re ready to find the next row/level\\n\\t\\tlet mut row = vec![];\\n\\t\\tfor node in bfs.iter() {\\n\\t\\t\\t// another match statement as before, except this time we borrow the left value as a reference.\\n\\t\\t\\tmatch node.borrow().left.as_ref() {\\n\\t\\t\\t\\t// only push onto row if the node actually contains something.\\n\\t\\t\\t\\tSome(x) => row.push(Rc::clone(x)), \\n\\t\\t\\t\\tNone => (),\\n\\t\\t\\t};\\n\\t\\t\\t// We also have to clone the pointer, as opposed to before. Why? Both the TreeNode and our row will \\n\\t\\t\\t// point to the leaf in the tree. That\\'s a problem because rust worries about things like double\\n\\t\\t\\t// free errors. You need to do the reference counting yourself, and the memory will only be deallocated\\n\\t\\t\\t// when there are no strong references to a particular struct/object. \\n\\t\\t\\t// This is basically manual garbage collection and does incur a runtime penalty\\n\\t\\t\\t\\n\\t\\t\\t// Nothing fancy rustwise here. just the same thing \\n\\t\\t\\tmatch node.borrow().right.as_ref() {\\n\\t\\t\\t\\tSome(x) => row.push(Rc::clone(x)),\\n\\t\\t\\t\\tNone => (),\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\t// make the queue equal to the row we just built, and go back to the while loop.\\n\\t\\tbfs = row;\\n\\t}\\n\\t// return ans\\n\\tans\\n}\\n",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "Interacting with trees and other data structures with rust can be a pain because of the issues needing mutable pointers to an immutable object. Definitely read the [Smart pointers](/https://doc.rust-lang.org/book/ch15-00-smart-pointers.html/) Chapter of the rust documentation, if you haven\\'t already/don\\'t know about smart pointers.\\n\\nHigh level overview, the question employs a  little misdirection so you won\\'t immediately realize it is a problem that can easily be solved by breadth-first-search (BFS). The wording given is basically the same as return the rightmost value for every row in the tree. If you recall, BFS traverses the tree by each row in left to right order, if you keep track of each row, you\\'ll be traversing the tree in level-order-traversal. So we\\'ll just get each of the row\\'s last value and push it onto the ans array. There are a lot of BFS and level-order-traversal resources, so I will focus on satisfying with the Rust compilier instead :) All comments are in line.\\n\\nFirst let\\'s look at the function declaration: `pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32>`\\nRust is a strongly typed language, so we need to know the type of the each root node. It\\'s the [Option enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) containing a smart pointer to a `TreeNode` struct. \\n\\n```\\npub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n\\t// Create the vector that we will return, notice rust compiler can figure out the type\\n\\tlet mut ans = vec![]; \\n\\t\\n\\t// Create Vec<Rc<RefCell<TreeNode>> we will use to do our BFS\\n\\t// We no longer use Option<T> because it we will only push onto this vec\\n\\t// if the enum is some (which we will enforce with pattern matching.\\n\\n\\tlet mut bfs = vec![]; \\n\\t\\n\\t// First example of pattern matching. If root contains something,\\n\\t// we\\'ll push the inner part of the enum onto the back of our bfs queue.\\n\\t// If it contains nothing, we\\'ll do nothing a.k.a. ()\\n\\tmatch root {\\n\\t\\tSome(x) => bfs.push(x),\\n\\t\\tNone => ()\\n\\t}\\n    \\n\\t// main loop of BFS, keep going if there is something in the queue.\\n\\twhile bfs.len() != 0 {\\n\\t\\t// First think we want to do is get the value of the TreeNode at the rightmost val\\n\\t\\t// of the bfs vec\\n\\t\\tans.push(bfs[bfs.len()-1].borrow().val);\\n        // Note we have to borrow the node to get access to follow the smart pointer to \\n\\t\\t// the struct itself.\\n\\t\\t\\n\\t\\t// now we\\'re ready to find the next row/level\\n\\t\\tlet mut row = vec![];\\n\\t\\tfor node in bfs.iter() {\\n\\t\\t\\t// another match statement as before, except this time we borrow the left value as a reference.\\n\\t\\t\\tmatch node.borrow().left.as_ref() {\\n\\t\\t\\t\\t// only push onto row if the node actually contains something.\\n\\t\\t\\t\\tSome(x) => row.push(Rc::clone(x)), \\n\\t\\t\\t\\tNone => (),\\n\\t\\t\\t};\\n\\t\\t\\t// We also have to clone the pointer, as opposed to before. Why? Both the TreeNode and our row will \\n\\t\\t\\t// point to the leaf in the tree. That\\'s a problem because rust worries about things like double\\n\\t\\t\\t// free errors. You need to do the reference counting yourself, and the memory will only be deallocated\\n\\t\\t\\t// when there are no strong references to a particular struct/object. \\n\\t\\t\\t// This is basically manual garbage collection and does incur a runtime penalty\\n\\t\\t\\t\\n\\t\\t\\t// Nothing fancy rustwise here. just the same thing \\n\\t\\t\\tmatch node.borrow().right.as_ref() {\\n\\t\\t\\t\\tSome(x) => row.push(Rc::clone(x)),\\n\\t\\t\\t\\tNone => (),\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\t// make the queue equal to the row we just built, and go back to the while loop.\\n\\t\\tbfs = row;\\n\\t}\\n\\t// return ans\\n\\tans\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 327960,
                "title": "python-solution-with-no-additional-space-and-96-61-faster",
                "content": "The idea is to do reverse preorder traversal and add only one (right most) node at each level:\\n\\n```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        res, max_level = [], -1\\n        \\n        def traverse_tree(node, level):\\n            nonlocal res, max_level\\n            if not node:\\n                return\\n            if max_level < level:\\n                res.append(node.val)\\n                max_level = level\\n            traverse_tree(node.right, level + 1)\\n            traverse_tree(node.left, level + 1)\\n        \\n        traverse_tree(root, 0)\\n        return res\\n```\\n\\nWe traverse the tree from right to left.  The variable max_level is used to track if we have already added the right most element for that level. The time complexity is O(n) and space complexity is O(1). If we consider recursion, then it is O(n) for call stack.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        res, max_level = [], -1\\n        \\n        def traverse_tree(node, level):\\n            nonlocal res, max_level\\n            if not node:\\n                return\\n            if max_level < level:\\n                res.append(node.val)\\n                max_level = level\\n            traverse_tree(node.right, level + 1)\\n            traverse_tree(node.left, level + 1)\\n        \\n        traverse_tree(root, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254146,
                "title": "java-dfs-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root == null)\\n            return result;\\n        rightSideViewHelper(root, result, 0);\\n        return result;\\n    }\\n    \\n    private void rightSideViewHelper(TreeNode node, List<Integer> result, int level){\\n        if(node == null)\\n            return;\\n        \\n        if(result.size() == level){\\n            result.add(node.val);            \\n        }\\n        \\n        rightSideViewHelper(node.right, result, level+1);\\n        rightSideViewHelper(node.left, result, level+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if(root == null)\\n            return result;\\n        rightSideViewHelper(root, result, 0);\\n        return result;\\n    }\\n    \\n    private void rightSideViewHelper(TreeNode node, List<Integer> result, int level){\\n        if(node == null)\\n            return;\\n        \\n        if(result.size() == level){\\n            result.add(node.val);            \\n        }\\n        \\n        rightSideViewHelper(node.right, result, level+1);\\n        rightSideViewHelper(node.left, result, level+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56189,
                "title": "java-easy-solution-beats-90-using-dfs",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> view = new ArrayList<Integer>();\\n            if(null==root) return view;\\n            dfs(view, root, 1);\\n            return view;\\n        }\\n        private void dfs(List<Integer> view, TreeNode root, int layer){\\n            if(root == null) return;\\n            if(layer > view.size()) view.add(root.val);\\n            dfs(view, root.right, layer+1);\\n            dfs(view, root.left, layer+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> rightSideView(TreeNode root) {\\n            List<Integer> view = new ArrayList<Integer>();\\n            if(null==root) return view;\\n            dfs(view, root, 1);\\n            return view;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4092411,
                "title": "c-dfs-pre-order-traversal-easy",
                "content": "# Intution\\n    We will use DFS instead of BFS because it is more space optimized.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    \\n    We will Traverse through root->right->left unlike trivial\\n    pre-order traversal which is root->left->right.\\n\\n    Whenever the traversal level equals to ans size, we push the root \\n    value in ans, which will be right View.\\n    \\n    Similarly for left view we can use trivial PreOrder Traversal i.e,\\n    root->left->right.\\n\\n    Go through the code for more clear concept.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      void helper(TreeNode* root,vector<int>&ans,int level){\\n        if(root== NULL)\\n        return;\\n        if(ans.size() == level){\\n            ans.push_back(root->val);\\n        }\\n        helper(root->right,ans,level+1);\\n        helper(root->left,ans,level+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        int level = 0;\\n        helper(root,ans,level);\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(number of nodes)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(height of tree)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      void helper(TreeNode* root,vector<int>&ans,int level){\\n        if(root== NULL)\\n        return;\\n        if(ans.size() == level){\\n            ans.push_back(root->val);\\n        }\\n        helper(root->right,ans,level+1);\\n        helper(root->left,ans,level+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        int level = 0;\\n        helper(root,ans,level);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955744,
                "title": "2-easy-c-solutions-recursive-and-iterative-approach-beats-100",
                "content": "# Code\\n```\\n// Iterative solution\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL)\\n            return ans;\\n    \\n        map<int, int> mp;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            pair<TreeNode*, int> temp = q.front();\\n            q.pop();\\n\\n            TreeNode *node = temp.first;\\n            int level = temp.second;\\n\\n            mp[level] = node->val;\\n        \\n            if(node->left != NULL)\\n                q.push({node->left, level+1});\\n            if(node->right != NULL)\\n                q.push({node->right, level+1});\\n        }\\n\\n        for(auto it : mp)\\n            ans.push_back(it.second);\\n        \\n        return ans;\\n    }\\n};\\n\\n// Recursive solution\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root, int level, vector<int> &ans){\\n        if(root==NULL) \\n            return ;\\n        \\n        if(ans.size()<level) \\n            ans.push_back(root->val);\\n        \\n        recursion(root->right, level+1, ans);\\n        recursion(root->left, level+1, ans);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode *root) {\\n        vector<int> ans;\\n        recursion(root, 1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Iterative solution\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL)\\n            return ans;\\n    \\n        map<int, int> mp;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            pair<TreeNode*, int> temp = q.front();\\n            q.pop();\\n\\n            TreeNode *node = temp.first;\\n            int level = temp.second;\\n\\n            mp[level] = node->val;\\n        \\n            if(node->left != NULL)\\n                q.push({node->left, level+1});\\n            if(node->right != NULL)\\n                q.push({node->right, level+1});\\n        }\\n\\n        for(auto it : mp)\\n            ans.push_back(it.second);\\n        \\n        return ans;\\n    }\\n};\\n\\n// Recursive solution\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root, int level, vector<int> &ans){\\n        if(root==NULL) \\n            return ;\\n        \\n        if(ans.size()<level) \\n            ans.push_back(root->val);\\n        \\n        recursion(root->right, level+1, ans);\\n        recursion(root->left, level+1, ans);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode *root) {\\n        vector<int> ans;\\n        recursion(root, 1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571333,
                "title": "easy-c-dfs-bfs-both-codes",
                "content": "\\n\\n\\n\\n# THE DFS Code\\n```\\n\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root,int level, vector<int>&t)\\n{\\n     if(root==NULL) return ;\\n        if(t.size()==level) t.push_back(root->val);\\n        helper(root->right, level+1,t);\\n        helper(root->left, level+1,t);\\n\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n    if(!root)\\n    return {};\\n\\n    vector<int>t;\\n    \\n   helper(root,0,t);      \\n\\n    return t;\\n     }\\n};\\n```\\n\\n# THE BFS CODE\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> rightSideView(TreeNode* root) {\\n    if(!root)\\n    return {};\\n\\n    vector<int>temp;\\n    \\n       \\n  queue<TreeNode*> q;\\n  q.push(root);\\n  while(!q.empty())\\n  {\\n       int sz=q.size();\\n       for(int i=0;i<sz;i++)\\n       {\\n            auto it=q.front();\\n            if(i==sz-1)\\n            temp.push_back(q.front()->val);\\n           if(it->left)\\n            q.push(it->left);\\n           if(it->right)\\n            q.push(it->right);\\n          \\n            q.pop();\\n       }\\n  }\\n\\n    return temp;\\n     }\\n};\\n```\\n\\n\\nPlease upvote if you like it.\\nAny suggestion would be highly appreciated thanks for clicking in",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root,int level, vector<int>&t)\\n{\\n     if(root==NULL) return ;\\n        if(t.size()==level) t.push_back(root->val);\\n        helper(root->right, level+1,t);\\n        helper(root->left, level+1,t);\\n\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n    if(!root)\\n    return {};\\n\\n    vector<int>t;\\n    \\n   helper(root,0,t);      \\n\\n    return t;\\n     }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> rightSideView(TreeNode* root) {\\n    if(!root)\\n    return {};\\n\\n    vector<int>temp;\\n    \\n       \\n  queue<TreeNode*> q;\\n  q.push(root);\\n  while(!q.empty())\\n  {\\n       int sz=q.size();\\n       for(int i=0;i<sz;i++)\\n       {\\n            auto it=q.front();\\n            if(i==sz-1)\\n            temp.push_back(q.front()->val);\\n           if(it->left)\\n            q.push(it->left);\\n           if(it->right)\\n            q.push(it->right);\\n          \\n            q.pop();\\n       }\\n  }\\n\\n    return temp;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428186,
                "title": "beats-100-dfs-using-recursion",
                "content": "\\n\\n# Approach\\nLet\\'s take an example which will cover almost all test cases. \\n\\n`Visualize a tree :- [1,2,3,4,null,null,null and an empty list =[]`\\n\\n![WhatsApp Image 2023-04-18 at 00.28.27.jpeg](https://assets.leetcode.com/users/images/92f74e24-251f-4c61-aa86-3b6e636ef1e2_1681757958.9612167.jpeg)\\n\\n\\nThe root of the tree is at a depth 0. and size of the list is also 0 at first so \\n\\n`if (depth==list.size())\\nlist.add(root.val)`\\n\\nSo our list becomes \\n\\n`list=[1]`\\n\\nNow we use recursion to traverse the right subtree and apply the aforementioned logic until we get `list=[1,3]` before traversing the left subtree.\\n\\nAs we traverse the left subtree, when we reach node 2, we won\\'t add it to list because `depth(node2)=1) which is not equal to list.size() =2`\\n\\nThen when we reach node 4, `depth==list.size()` so we add it to list and the list becomes `list=[1,3,4]`\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer>list = new ArrayList();\\n        recursion(root,list,0);\\n        return list;\\n    }\\n    public void recursion (TreeNode root, List<Integer> list, int depth) {\\n        if (root==null)\\n        return;\\n\\n        if(depth==list.size())\\n        list.add(root.val);\\n\\n        recursion(root.right,list,depth+1);\\n        recursion(root.left,list,depth+1);\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer>list = new ArrayList();\\n        recursion(root,list,0);\\n        return list;\\n    }\\n    public void recursion (TreeNode root, List<Integer> list, int depth) {\\n        if (root==null)\\n        return;\\n\\n        if(depth==list.size())\\n        list.add(root.val);\\n\\n        recursion(root.right,list,depth+1);\\n        recursion(root.left,list,depth+1);\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356560,
                "title": "solution-using-both-approach-bfs-and-dfs-in-c",
                "content": "\\n\\n# Code\\n```\\n                                DFS\\npreorder krenge serch bs differ itnhoga left ke jgh right child pehle view krwayenge -and jb level or vector ans ka size same hoga hum wo element store kr lenge kyunki wo us level ka sbse right element hoga\\n t.c:O(n)\\n s.c:O(height)\\n\\nclass Solution {\\npublic:\\n vector<int> answer; \\n    void dfs(TreeNode* root,int level=0){\\n        if(!root)return;\\n        if(answer.size()==level)answer.push_back(root->val);\\n        dfs(root->right,level+1);  \\n        dfs(root->left,level+1);  \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n      dfs(root);\\n      return answer;\\n    }\\n};\\n                                 BFS\\nLevel order serch where we will see the rightmost element\\n t.c:O(n)\\n s.c:O(n)\\n\\nclass Solution {\\npublic:\\n vector<int> answer; \\n    vector<int> rightSideView(TreeNode* root) {\\n      if(!root)return answer;\\n      int size;\\n      TreeNode* top;\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      while(!q.empty()){\\n      size=q.size();\\n      for(int i=0;i<size;i++){\\n        top=q.front();\\n        q.pop();\\n        if(top->left)q.push(top->left);\\n        if(top->right)q.push(top->right);\\n      }\\n       answer.push_back(top->val);\\n      }\\n      return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n                                DFS\\npreorder krenge serch bs differ itnhoga left ke jgh right child pehle view krwayenge -and jb level or vector ans ka size same hoga hum wo element store kr lenge kyunki wo us level ka sbse right element hoga\\n t.c:O(n)\\n s.c:O(height)\\n\\nclass Solution {\\npublic:\\n vector<int> answer; \\n    void dfs(TreeNode* root,int level=0){\\n        if(!root)return;\\n        if(answer.size()==level)answer.push_back(root->val);\\n        dfs(root->right,level+1);  \\n        dfs(root->left,level+1);  \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n      dfs(root);\\n      return answer;\\n    }\\n};\\n                                 BFS\\nLevel order serch where we will see the rightmost element\\n t.c:O(n)\\n s.c:O(n)\\n\\nclass Solution {\\npublic:\\n vector<int> answer; \\n    vector<int> rightSideView(TreeNode* root) {\\n      if(!root)return answer;\\n      int size;\\n      TreeNode* top;\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      while(!q.empty()){\\n      size=q.size();\\n      for(int i=0;i<size;i++){\\n        top=q.front();\\n        q.pop();\\n        if(top->left)q.push(top->left);\\n        if(top->right)q.push(top->right);\\n      }\\n       answer.push_back(top->val);\\n      }\\n      return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355761,
                "title": "simple-to-understand-c-solution",
                "content": "# Approach\\nThis problem can be solved using both DFS and BFS.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> answer;\\n    vector<int> rightSideView(TreeNode* root) {\\n        if(root == NULL){\\n            return answer;\\n        }\\n        dfs(root,0);\\n        return answer;\\n    }\\n    void dfs(TreeNode* root,int lvl){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(lvl == answer.size()){\\n            answer.push_back(root->val);\\n        }\\n        dfs(root->right,lvl+1);\\n        dfs(root->left,lvl+1);\\n\\n    }\\n};  \\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> answer;\\n    vector<int> rightSideView(TreeNode* root) {\\n        if(root == NULL){\\n            return answer;\\n        }\\n        dfs(root,0);\\n        return answer;\\n    }\\n    void dfs(TreeNode* root,int lvl){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(lvl == answer.size()){\\n            answer.push_back(root->val);\\n        }\\n        dfs(root->right,lvl+1);\\n        dfs(root->left,lvl+1);\\n\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252612,
                "title": "c-easy-recursive-solution",
                "content": "<!-- # Intuition -->\\n<!-- Right Side View - Set of nodes visible when the tree is seen from the right side.  -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int> &ans, int level)\\n    {\\n        // base case\\n        if (root == NULL)\\n        {\\n            return ; \\n        }\\n\\n        // we entered a new level \\n        if (level == ans.size())\\n        {\\n            ans.push_back(root -> val) ; \\n        }\\n\\n        solve(root -> right, ans, level + 1) ; \\n        solve(root -> left, ans, level + 1 ) ; \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans ; \\n        int level = 0 ; \\n\\n        solve(root, ans, level) ;\\n        \\n        return ans ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/bb6c318f-9c6e-4df4-99cd-4a29f658aa43_1677859076.491966.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int> &ans, int level)\\n    {\\n        // base case\\n        if (root == NULL)\\n        {\\n            return ; \\n        }\\n\\n        // we entered a new level \\n        if (level == ans.size())\\n        {\\n            ans.push_back(root -> val) ; \\n        }\\n\\n        solve(root -> right, ans, level + 1) ; \\n        solve(root -> left, ans, level + 1 ) ; \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans ; \\n        int level = 0 ; \\n\\n        solve(root, ans, level) ;\\n        \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225070,
                "title": "c-bfs-dfs",
                "content": "# Approach 1\\nBFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<int> view;\\n        queue<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                TreeNode* node = todo.front();\\n                todo.pop();\\n                if (i == n - 1) {\\n                    view.push_back(node -> val);\\n                }\\n                if (node -> left) {\\n                    todo.push(node -> left);\\n                }\\n                if (node -> right) {\\n                    todo.push(node -> right);\\n                }\\n            }\\n        }\\n        return view;\\n    }\\n};\\n```\\n\\n# Approach 2\\nDFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector <int> ans;\\n        traversal(root, 0, ans);\\n        return ans;\\n    }\\nprivate:\\n    void traversal(TreeNode* root, int level, vector <int>& ans) {\\n        if (root == NULL)\\n            return;\\n        if (ans.size() == level)\\n            ans.push_back(root->val);\\n        traversal(root->right, level + 1, ans); \\n        traversal(root->left, level + 1, ans);        \\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<int> view;\\n        queue<TreeNode*> todo;\\n        todo.push(root);\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                TreeNode* node = todo.front();\\n                todo.pop();\\n                if (i == n - 1) {\\n                    view.push_back(node -> val);\\n                }\\n                if (node -> left) {\\n                    todo.push(node -> left);\\n                }\\n                if (node -> right) {\\n                    todo.push(node -> right);\\n                }\\n            }\\n        }\\n        return view;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector <int> ans;\\n        traversal(root, 0, ans);\\n        return ans;\\n    }\\nprivate:\\n    void traversal(TreeNode* root, int level, vector <int>& ans) {\\n        if (root == NULL)\\n            return;\\n        if (ans.size() == level)\\n            ans.push_back(root->val);\\n        traversal(root->right, level + 1, ans); \\n        traversal(root->left, level + 1, ans);        \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087412,
                "title": "beats-100-best-c-solution",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        if(root==NULL)\\n        return ans;\\n\\n        while(1){\\n\\n            int size=q.size();\\nif(size==0)\\nreturn ans;\\nint data=0;\\nwhile(size>0){\\nTreeNode* temp =q.front();\\nq.pop();\\ndata=temp->val;\\n\\nif(temp->left !=NULL)\\nq.push(temp->left);\\n\\nif(temp->right!=NULL)\\nq.push(temp->right);\\n\\nsize--;\\n}\\nans.push_back(data);\\n        }\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        if(root==NULL)\\n        return ans;\\n\\n        while(1){\\n\\n            int size=q.size();\\nif(size==0)\\nreturn ans;\\nint data=0;\\nwhile(size>0){\\nTreeNode* temp =q.front();\\nq.pop();\\ndata=temp->val;\\n\\nif(temp->left !=NULL)\\nq.push(temp->left);\\n\\nif(temp->right!=NULL)\\nq.push(temp->right);\\n\\nsize--;\\n}\\nans.push_back(data);\\n        }\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935783,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int>& ans, int h)\\n    {\\n        if(!root)\\n            return;\\n        if(h==ans.size())\\n        ans.push_back(root->val);\\n        f(root->right,ans,h+1);\\n        f(root->left,ans,h+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int>& ans, int h)\\n    {\\n        if(!root)\\n            return;\\n        if(h==ans.size())\\n        ans.push_back(root->val);\\n        f(root->right,ans,h+1);\\n        f(root->left,ans,h+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680849,
                "title": "python-3-simple-bfs-solution",
                "content": "```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        ans = []\\n        if not root: return ans\\n        \\n        q = [root]\\n        \\n        while q:\\n            lv = []\\n            \\n            ans.append(q[-1].val)\\n            \\n            for node in q:\\n                if node.left: lv.append(node.left)\\n                if node.right: lv.append(node.right)\\n            \\n            q = lv\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        ans = []\\n        if not root: return ans\\n        \\n        q = [root]\\n        \\n        while q:\\n            lv = []\\n            \\n            ans.append(q[-1].val)\\n            \\n            for node in q:\\n                if node.left: lv.append(node.left)\\n                if node.right: lv.append(node.right)\\n            \\n            q = lv\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602768,
                "title": "c-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<int> result;\\n        if(root) q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                if(i==(size-1)) result.push_back(curr->val);\\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<int> result;\\n        if(root) q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                if(i==(size-1)) result.push_back(curr->val);\\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568234,
                "title": "javascript-diagram-easy-to-understand",
                "content": "**Iterative Solution**\\n\\nWhen you first look at this problem, one may think you should follow the rightmost path and add it to an array. This may work for the example testcase, but it is not the correct answer. If the left child has more levels than the right child, you will still see them when looking from the right, but this solution does not capture this case.\\n![image](https://assets.leetcode.com/users/images/b329291c-520c-4832-bfb8-88f0a83bca42_1663009178.848718.jpeg)\\n\\nA simple **breadth-first traversal** will capture each level and you will be able to use the rightmost value of each of these levels.\\n![image](https://assets.leetcode.com/users/images/6a6af1c6-50d5-45ca-bc97-2975d180ecac_1663009198.459198.jpeg)\\n\\nFirstly, let\\'s create a base case to return an empty array in case root is null.\\n```\\n    if(!r) return [];\\n```\\nSecond, lets initialize vals to an empty array and queue to an array with the root.\\n```\\n    let vals = [], q = [ r ];\\n```\\nThird, lets iterate through the queue using a while loop. As well as declaring the variable size to be the current length of the queue, and declaring level to an empty array. We will fill this level array with all of the values from this level of the binary tree. Size is used in the below for loop to cut us off from adding values from the next level.\\n```\\n    while(q.length){\\n        let size = q.length;\\n        let lvl = [];\\n```\\nLets access each of the nodes currently in the queue. Push them into the level array. If the node has a right or left child, lets add them to the queue. Since we are utilizing the for loop, we will not access these children until the next while iteration.\\n```\\n        for(let i = 0; i < size; i++){\\n            let c = q.shift();\\n            lvl.push(c.val);\\n            if(c.left) q.push(c.left);\\n            if(c.right) q.push(c.right);\\n        }\\n```\\nAfter we create each level array, let\\'s add the rightmost value from that level to the values array.\\n```\\n        vals.push(lvl.at(-1));\\n    }\\n```\\nFinally, return the values array. It now consists of the rightmost value from each level of the binary tree.\\n```\\n    return vals;\\n```\\n\\nHere is the final iterative solution.\\n```\\nfunction rightSideView (r) {\\n    if(!r) return [];\\n    let vals = [];\\n    let q = [ r ];\\n    \\n    while(q.length){\\n        let size = q.length;\\n        let lvl = [];\\n        for(let i = 0; i < size; i++){\\n            let c = q.shift();\\n            lvl.push(c.val);\\n            if(c.left) q.push(c.left);\\n            if(c.right) q.push(c.right);\\n        }\\n        vals.push(lvl.at(-1));\\n    }\\n    return vals;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    if(!r) return [];\\n```\n```\\n    let vals = [], q = [ r ];\\n```\n```\\n    while(q.length){\\n        let size = q.length;\\n        let lvl = [];\\n```\n```\\n        for(let i = 0; i < size; i++){\\n            let c = q.shift();\\n            lvl.push(c.val);\\n            if(c.left) q.push(c.left);\\n            if(c.right) q.push(c.right);\\n        }\\n```\n```\\n        vals.push(lvl.at(-1));\\n    }\\n```\n```\\n    return vals;\\n```\n```\\nfunction rightSideView (r) {\\n    if(!r) return [];\\n    let vals = [];\\n    let q = [ r ];\\n    \\n    while(q.length){\\n        let size = q.length;\\n        let lvl = [];\\n        for(let i = 0; i < size; i++){\\n            let c = q.shift();\\n            lvl.push(c.val);\\n            if(c.left) q.push(c.left);\\n            if(c.right) q.push(c.right);\\n        }\\n        vals.push(lvl.at(-1));\\n    }\\n    return vals;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2520730,
                "title": "python-bfs-queue-easy",
                "content": "```\\nclass Solution:\\n\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        res = []\\n        \\n        q = collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            \\n            qlen = len(q)\\n            \\n            level = []\\n            \\n            for i in range(qlen):\\n                node = q.popleft()\\n                if node:\\n                    level.append(node.val)\\n                    q.append(node.left)\\n                    q.append(node.right)\\n            if level:\\n                res.append(level[-1])\\n        \\n        return res         \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        res = []\\n        \\n        q = collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            \\n            qlen = len(q)\\n            \\n            level = []\\n            \\n            for i in range(qlen):\\n                node = q.popleft()\\n                if node:\\n                    level.append(node.val)\\n                    q.append(node.left)\\n                    q.append(node.right)\\n            if level:\\n                res.append(level[-1])\\n        \\n        return res         \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266254,
                "title": "easy-understandable-level-order-traversal",
                "content": "Simply use BFS (right-to-left level order) to get the right side view of every level of the tree using queue data structure.\\n* Start by adding root node in the queue\\n* Add top of queue to result list, as the top will be the rightmost node of the level. \\n* Then for the remaining nodes in the entire level add their children to the queue (first right then left child) by removing each one of them.\\n* Repeat 2nd and 3rd step until the queue becomes empty.\\n\\n**Pls note:** Taking queue of pair of TreeNode(to access children) and Integer(to check for level). \\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        if(root == null) return l;\\n        \\n        // first -> node\\n        // second-> node level\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        \\n        // Starting traversal with root node having level 0\\n        int level = 0;\\n        q.add(new Pair(root, level));\\n        \\n        while(!q.isEmpty()){\\n            \\n            // Node at the top of the queue (for rightmost node of the level)\\n            l.add(q.peek().getKey().val);\\n            \\n            // Clear the complete level from queue after adding children in queue\\n            while(q.peek() != null && q.peek().getValue() == level){\\n                TreeNode temp = q.remove().getKey();\\n                if(temp.right != null) q.add(new Pair(temp.right, level+1));\\n                if(temp.left != null) q.add(new Pair(temp.left, level+1));\\n            }\\n            \\n            level++;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        if(root == null) return l;\\n        \\n        // first -> node\\n        // second-> node level\\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        \\n        // Starting traversal with root node having level 0\\n        int level = 0;\\n        q.add(new Pair(root, level));\\n        \\n        while(!q.isEmpty()){\\n            \\n            // Node at the top of the queue (for rightmost node of the level)\\n            l.add(q.peek().getKey().val);\\n            \\n            // Clear the complete level from queue after adding children in queue\\n            while(q.peek() != null && q.peek().getValue() == level){\\n                TreeNode temp = q.remove().getKey();\\n                if(temp.right != null) q.add(new Pair(temp.right, level+1));\\n                if(temp.left != null) q.add(new Pair(temp.left, level+1));\\n            }\\n            \\n            level++;\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265974,
                "title": "c-solution",
                "content": "```\\nvoid input(struct TreeNode* root, int* returnSize, int* ans, int now){\\n    if(root == NULL){\\n        return;\\n    }\\n    if(now > *returnSize){\\n        ans[*returnSize] = root->val;\\n        *returnSize += 1;\\n    }\\n    input(root->right, returnSize, ans, now+1);\\n    input(root->left, returnSize, ans, now+1);\\n}\\n\\nint* rightSideView(struct TreeNode* root, int* returnSize){\\n    if (root == NULL){\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    int* ans = malloc(sizeof(int)*100);\\n    *returnSize = 0;\\n    input(root, returnSize, ans, 1);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid input(struct TreeNode* root, int* returnSize, int* ans, int now){\\n    if(root == NULL){\\n        return;\\n    }\\n    if(now > *returnSize){\\n        ans[*returnSize] = root->val;\\n        *returnSize += 1;\\n    }\\n    input(root->right, returnSize, ans, now+1);\\n    input(root->left, returnSize, ans, now+1);\\n}\\n\\nint* rightSideView(struct TreeNode* root, int* returnSize){\\n    if (root == NULL){\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    int* ans = malloc(sizeof(int)*100);\\n    *returnSize = 0;\\n    input(root, returnSize, ans, 1);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2177979,
                "title": "c-bfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int> ans;\\n        if( !root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while( !q.empty()){\\n            int siz = q.size();\\n            while(siz--){\\n                TreeNode* p = q.front();\\n                q.pop();\\n                if( siz == 0 ) {\\n                    ans.push_back(p->val);\\n                }\\n                if( p->left ) q.push(p->left);\\n                if( p->right) q.push(p->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int> ans;\\n        if( !root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while( !q.empty()){\\n            int siz = q.size();\\n            while(siz--){\\n                TreeNode* p = q.front();\\n                q.pop();\\n                if( siz == 0 ) {\\n                    ans.push_back(p->val);\\n                }\\n                if( p->left ) q.push(p->left);\\n                if( p->right) q.push(p->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750766,
                "title": "cpp-100-faster-0ms",
                "content": "upvote if u understand \\n```\\n vector<int> rightSideView(TreeNode* root) {\\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* t=q.front();\\n            q.pop();\\n            if(t==NULL)\\n            {\\n                if(q.empty())\\n                    break;\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(q.front()==NULL)\\n                v.push_back(t->val);\\n            \\n            if(t->left)\\n                q.push(t->left);\\n            if(t->right)\\n                q.push(t->right);\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n vector<int> rightSideView(TreeNode* root) {\\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* t=q.front();\\n            q.pop();\\n            if(t==NULL)\\n            {\\n                if(q.empty())\\n                    break;\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(q.front()==NULL)\\n                v.push_back(t->val);\\n            \\n            if(t->left)\\n                q.push(t->left);\\n            if(t->right)\\n                q.push(t->right);\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745865,
                "title": "right-left-top-bottom-view-of-binary-tree",
                "content": "\\nright view of tree using bfs\\n```\\nvector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode *> pending;\\n        if(!root) return {};\\n        vector<int> answer;\\n        pending.push(root);\\n        while(!pending.empty()){\\n            int len = pending.size();\\n            while(len--){\\n                TreeNode * curr = pending.front();\\n                pending.pop();\\n                if(curr->left)pending.push(curr->left);\\n                if(curr->right)pending.push(curr->right);\\n                if(len == 0){\\n                    answer.push_back(curr->val);\\n                }\\n            }\\n        }\\n        return answer;\\n```\\n\\nleft side view\\n```\\nvector<int> leftSideView(TreeNode* root) {\\n        \\n        queue<TreeNode *> pending;\\n        if(!root) return {};\\n        vector<int> answer;\\n        pending.push(root);\\n        while(!pending.empty()){\\n            int len = pending.size();\\n            int initLen = len;\\n            while(len--){\\n                TreeNode * curr = pending.front();\\n                pending.pop();\\n                if(curr->left)pending.push(curr->left);\\n                if(curr->right)pending.push(curr->right);\\n                if(len == initLen-1){\\n                    answer.push_back(curr->val);\\n                }\\n            }\\n        }\\n        return answer;\\n```\\n\\ntop view\\n```\\nvector<int> topView(TreeNode* root) {\\n        \\n        vector<int> answer;\\n        stack<pair<int,TreeNode *>> pending;\\n        TreeNode * curr = root, * prev = NULL;\\n        map<int,int> pos2val;\\n        int pos=0;\\n        while(!pending.empty() || curr){\\n            while(curr){\\n                pending.push(make_pair(pos--,exchange(curr,curr->left)));\\n            }\\n            int idx = pending.top().first;\\n            TreeNode * top = pending.top().second;\\n            if(!top->right || prev == top->right){\\n                pending.pop();\\n                prev = top;\\n                pos2val[idx] = top->val;\\n            }else{\\n                curr = top->right;\\n                pos = idx+1;\\n            }\\n        }\\n        for(auto i = pos2val.begin(); i!=pos2val.end();i++){\\n            answer.push_back(i->second);\\n        }\\n        return answer;\\n```\\n\\nbottom view\\ni think this solution will fail when some elements of right subtree will overlap the elements of the left subtree.\\nalso when two elements at the same depth come at the same position which one should we choose ? Any comments and suggestions are welcome.\\n```\\nvector<int> bottomView(TreeNode* root) {\\n        \\n        vector<int> answer;\\n        stack<pair<int,TreeNode *>> pending;\\n        TreeNode * curr = root, * prev = NULL;\\n        map<int,int> pos2val;\\n        int pos=0;\\n        while(!pending.empty() || curr){\\n            while(curr){\\n                pending.push(make_pair(pos--,exchange(curr,curr->left)));\\n            }\\n            int idx = pending.top().first;\\n            TreeNode * top = pending.top().second;\\n            if(!top->right || prev == top->right){\\n                pending.pop();\\n                prev = top;\\n                if(pos2val.find(idx)==pos2val.end()){\\n                    pos2val[idx] = top->val;  \\n                }\\n                \\n            }else{\\n                curr = top->right;\\n                pos = idx+1;\\n            }\\n        }\\n        for(auto i = pos2val.begin(); i!=pos2val.end();i++){\\n            answer.push_back(i->second);\\n        }\\n        return answer;\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nvector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode *> pending;\\n        if(!root) return {};\\n        vector<int> answer;\\n        pending.push(root);\\n        while(!pending.empty()){\\n            int len = pending.size();\\n            while(len--){\\n                TreeNode * curr = pending.front();\\n                pending.pop();\\n                if(curr->left)pending.push(curr->left);\\n                if(curr->right)pending.push(curr->right);\\n                if(len == 0){\\n                    answer.push_back(curr->val);\\n                }\\n            }\\n        }\\n        return answer;\\n```\n```\\nvector<int> leftSideView(TreeNode* root) {\\n        \\n        queue<TreeNode *> pending;\\n        if(!root) return {};\\n        vector<int> answer;\\n        pending.push(root);\\n        while(!pending.empty()){\\n            int len = pending.size();\\n            int initLen = len;\\n            while(len--){\\n                TreeNode * curr = pending.front();\\n                pending.pop();\\n                if(curr->left)pending.push(curr->left);\\n                if(curr->right)pending.push(curr->right);\\n                if(len == initLen-1){\\n                    answer.push_back(curr->val);\\n                }\\n            }\\n        }\\n        return answer;\\n```\n```\\nvector<int> topView(TreeNode* root) {\\n        \\n        vector<int> answer;\\n        stack<pair<int,TreeNode *>> pending;\\n        TreeNode * curr = root, * prev = NULL;\\n        map<int,int> pos2val;\\n        int pos=0;\\n        while(!pending.empty() || curr){\\n            while(curr){\\n                pending.push(make_pair(pos--,exchange(curr,curr->left)));\\n            }\\n            int idx = pending.top().first;\\n            TreeNode * top = pending.top().second;\\n            if(!top->right || prev == top->right){\\n                pending.pop();\\n                prev = top;\\n                pos2val[idx] = top->val;\\n            }else{\\n                curr = top->right;\\n                pos = idx+1;\\n            }\\n        }\\n        for(auto i = pos2val.begin(); i!=pos2val.end();i++){\\n            answer.push_back(i->second);\\n        }\\n        return answer;\\n```\n```\\nvector<int> bottomView(TreeNode* root) {\\n        \\n        vector<int> answer;\\n        stack<pair<int,TreeNode *>> pending;\\n        TreeNode * curr = root, * prev = NULL;\\n        map<int,int> pos2val;\\n        int pos=0;\\n        while(!pending.empty() || curr){\\n            while(curr){\\n                pending.push(make_pair(pos--,exchange(curr,curr->left)));\\n            }\\n            int idx = pending.top().first;\\n            TreeNode * top = pending.top().second;\\n            if(!top->right || prev == top->right){\\n                pending.pop();\\n                prev = top;\\n                if(pos2val.find(idx)==pos2val.end()){\\n                    pos2val[idx] = top->val;  \\n                }\\n                \\n            }else{\\n                curr = top->right;\\n                pos = idx+1;\\n            }\\n        }\\n        for(auto i = pos2val.begin(); i!=pos2val.end();i++){\\n            answer.push_back(i->second);\\n        }\\n        return answer;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1636033,
                "title": "2-approaches-dfs-iterative-simple-easy-c",
                "content": "Implementation\\n\\n**BFS\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n         while(!q.empty()){            \\n            int size = q.size();\\n            res.push_back(q.front()->val);\\n            \\n            for(int itr = 0; itr < size; itr++){\\n                TreeNode* temp = q.front();\\n                q.pop();                \\n                                \\n                if(temp->right) q.push(temp->right);\\n                if(temp->left) q.push(temp->left);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**DFS\\nTime Complexity = O(N), Space Complexity = O(H), where H is the height of the binary tree**\\n```\\nclass Solution {\\npublic:\\n    void findRightSideView(TreeNode* root, vector<int> &res, int level){\\n        if(!root) return;\\n        if(level > res.size()) res.push_back(root->val);\\n        findRightSideView(root->right, res, level+1);\\n        findRightSideView(root->left, res, level+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        findRightSideView(root, res, 1);\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n         while(!q.empty()){            \\n            int size = q.size();\\n            res.push_back(q.front()->val);\\n            \\n            for(int itr = 0; itr < size; itr++){\\n                TreeNode* temp = q.front();\\n                q.pop();                \\n                                \\n                if(temp->right) q.push(temp->right);\\n                if(temp->left) q.push(temp->left);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void findRightSideView(TreeNode* root, vector<int> &res, int level){\\n        if(!root) return;\\n        if(level > res.size()) res.push_back(root->val);\\n        findRightSideView(root->right, res, level+1);\\n        findRightSideView(root->left, res, level+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> res;\\n        findRightSideView(root, res, 1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588558,
                "title": "java-easy-solution-0ms-100-faster-recursion",
                "content": "**Code**\\n```java\\npublic List<Integer> rightSideView(TreeNode root) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\trightViewUtil(root, list, 0);\\n\\treturn list;\\n}\\n\\npublic void rightViewUtil(TreeNode root, List<Integer> list, int level) {\\n\\tif(root == null) return;\\n\\n\\tif(level == list.size()) {\\n\\t\\tlist.add(root.val);\\n\\t}\\n\\n\\trightViewUtil(root.right, list, level+1);\\n\\trightViewUtil(root.left, list, level+1);\\n}\\n```\\n\\n**Explanation**\\nThe point here is to move level wise to each node and add that if it is the first node from the right side which is what we want.\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\npublic List<Integer> rightSideView(TreeNode root) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\trightViewUtil(root, list, 0);\\n\\treturn list;\\n}\\n\\npublic void rightViewUtil(TreeNode root, List<Integer> list, int level) {\\n\\tif(root == null) return;\\n\\n\\tif(level == list.size()) {\\n\\t\\tlist.add(root.val);\\n\\t}\\n\\n\\trightViewUtil(root.right, list, level+1);\\n\\trightViewUtil(root.left, list, level+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582380,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        rightView(root, 0, list);\\n        return list;\\n    }\\n    private void rightView(TreeNode root, int depth, List<Integer> list){\\n        if(root == null)    return;\\n        if(depth == list.size())  list.add(root.val);\\n        rightView(root.right, depth+1, list);\\n        rightView(root.left, depth+1, list);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar rightSideView = function(root) {\\n    let list = []\\n    rightView(root, 0, list)\\n    return list\\n};\\n\\nfunction rightView(root, depth, list){\\n    if(!root)   return\\n    if(depth == list.length)    list.push(root.val)\\n    rightView(root.right, depth+1, list)\\n    rightView(root.left, depth+1, list)\\n}\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        lst = []\\n        self.rightView(root, 0, lst)\\n        return lst\\n    \\n    def rightView(self, root, depth, lst):\\n        if not root:\\n            return \\n        if depth == len(lst):\\n            lst.append(root.val)\\n        self.rightView(root.right, depth+1, lst)\\n        self.rightView(root.left, depth+1, lst)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        rightView(root, 0, list);\\n        return list;\\n    }\\n    private void rightView(TreeNode root, int depth, List<Integer> list){\\n        if(root == null)    return;\\n        if(depth == list.size())  list.add(root.val);\\n        rightView(root.right, depth+1, list);\\n        rightView(root.left, depth+1, list);\\n    }\\n}\\n```\n```\\nvar rightSideView = function(root) {\\n    let list = []\\n    rightView(root, 0, list)\\n    return list\\n};\\n\\nfunction rightView(root, depth, list){\\n    if(!root)   return\\n    if(depth == list.length)    list.push(root.val)\\n    rightView(root.right, depth+1, list)\\n    rightView(root.left, depth+1, list)\\n}\\n```\n```\\nclass Solution(object):\\n    def rightSideView(self, root):\\n        lst = []\\n        self.rightView(root, 0, lst)\\n        return lst\\n    \\n    def rightView(self, root, depth, lst):\\n        if not root:\\n            return \\n        if depth == len(lst):\\n            lst.append(root.val)\\n        self.rightView(root.right, depth+1, lst)\\n        self.rightView(root.left, depth+1, lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085732,
                "title": "python-simple-solution-beats-99-submissions",
                "content": "Baiscally, the idea of finding the view from the right hand side is focusing on the right branch. \\nThe fastest solution can finish all work within one look on all nodes. How?\\n\\nThe right side view is looking at the rightest node, when there are several nodes of same height. Hence, the idea is find the right most node.\\nWe set a global variable h, to represent the deepest height we have achieved. When we update h, as long as we ensure that the node with height greater than h is the right most possible node, we append it to the answer list.\\n\\nThe right most property is guaranteed by always searching the right branch first. By doing so, for nodes of same height, we guaranteed the right most node to be the one update global h and be appended to the list.\\n\"\"\"\\nclass Solution(object):\\n\\n    def rightSideView(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = []\\n        self.h = -1\\n        def prog(root,height):\\n            if root is None:\\n                return\\n            if height > self.h:\\n                ans.append(root.val)\\n                self.h = height\\n            prog(root.right, height + 1)\\n            prog(root.left, height + 1)\\n        prog(root,0)\\n        return ans\\n\"\"\"",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Baiscally, the idea of finding the view from the right hand side is focusing on the right branch. \\nThe fastest solution can finish all work within one look on all nodes. How?\\n\\nThe right side view is looking at the rightest node, when there are several nodes of same height. Hence, the idea is find the right most node.\\nWe set a global variable h, to represent the deepest height we have achieved. When we update h, as long as we ensure that the node with height greater than h is the right most possible node, we append it to the answer list.\\n\\nThe right most property is guaranteed by always searching the right branch first. By doing so, for nodes of same height, we guaranteed the right most node to be the one update global h and be appended to the list.\\n\"\"\"\\nclass Solution(object):\\n\\n    def rightSideView(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = []\\n        self.h = -1\\n        def prog(root,height):\\n            if root is None:\\n                return\\n            if height > self.h:\\n                ans.append(root.val)\\n                self.h = height\\n            prog(root.right, height + 1)\\n            prog(root.left, height + 1)\\n        prog(root,0)\\n        return ans\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 1052359,
                "title": "python-level-traverse-using-bfs-w-comment",
                "content": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\'\\'\\'\\nw: level order traversal\\nh: traverse the tree level by level\\n    only record the last node of each level\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        res = []\\n        deque = collections.deque([root])\\n        \\n        while deque:\\n            size = len(deque)\\n            \\n            for i in range(size):\\n                node = deque.popleft()\\n                if i == size - 1:\\n                    res.append(node.val)\\n                \\n                if node.left:\\n                    deque.append(node.left)\\n                \\n                if node.right:\\n                    deque.append(node.right)\\n            \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\'\\'\\'\\nw: level order traversal\\nh: traverse the tree level by level\\n    only record the last node of each level\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def rightSideView(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        res = []\\n        deque = collections.deque([root])\\n        \\n        while deque:\\n            size = len(deque)\\n            \\n            for i in range(size):\\n                node = deque.popleft()\\n                if i == size - 1:\\n                    res.append(node.val)\\n                \\n                if node.left:\\n                    deque.append(node.left)\\n                \\n                if node.right:\\n                    deque.append(node.right)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773284,
                "title": "faster-than-90-c",
                "content": "\\n    class Solution {\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n           if(root==NULL)\\n              return {};\\n\\t       vector<int> v;\\n           queue<TreeNode*> q;\\n           q.push(root);\\n           TreeNode *temp;\\n           int len;\\n           while(!q.empty()){\\n              len=q.size();\\n              for(int i=0;i<len;i++){\\n                   temp=q.front();\\n                   q.pop();\\n                   if(i==len-1)\\n                        v.push_back(temp->val);\\n\\n                  if(temp->left) q.push(temp->left);\\n                  if(temp->right) q.push(temp->right);\\n               }\\n           }\\n         return v;\\n       }\\n    };\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> rightSideView(TreeNode *root) {\\n           if(root==NULL)\\n              return {}",
                "codeTag": "Java"
            },
            {
                "id": 650387,
                "title": "javascript-bfs",
                "content": "\\tvar rightSideView = function(root) {\\n\\t\\tif(!root) return []\\n\\n\\t\\tlet queue = [[0,root]], levelObj={},result=[]\\n\\n\\n\\t\\twhile(queue.length>0){\\n\\t\\t\\tlet [level, current] = queue.shift()\\n\\t\\t\\tif(!levelObj[level]) levelObj[level]=[]\\n\\t\\t\\tlevelObj[level].push(current.val)\\n\\n\\t\\t\\tif(current.left) queue.push([level+1,current.left])\\n\\t\\t\\tif(current.right) queue.push([level+1,current.right])\\n\\n\\t\\t}\\n\\n\\t\\tfor(let key in levelObj){\\n\\t\\t\\t// push each level last value\\n\\t\\t\\tresult.push(levelObj[key][levelObj[key].length-1])\\n\\t\\t}\\n\\t\\treturn result\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "\\tvar rightSideView = function(root) {\\n\\t\\tif(!root) return []\\n\\n\\t\\tlet queue = [[0,root]], levelObj={},result=[]\\n\\n\\n\\t\\twhile(queue.length>0){\\n\\t\\t\\tlet [level, current] = queue.shift()\\n\\t\\t\\tif(!levelObj[level]) levelObj[level]=[]\\n\\t\\t\\tlevelObj[level].push(current.val)\\n\\n\\t\\t\\tif(current.left) queue.push([level+1,current.left])\\n\\t\\t\\tif(current.right) queue.push([level+1,current.right])\\n\\n\\t\\t}\\n\\n\\t\\tfor(let key in levelObj){\\n\\t\\t\\t// push each level last value\\n\\t\\t\\tresult.push(levelObj[key][levelObj[key].length-1])\\n\\t\\t}\\n\\t\\treturn result\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 497922,
                "title": "java-100-solution",
                "content": "```\\nclass Solution {\\n    List<Integer> res;\\n    public List<Integer> rightSideView(TreeNode root) {\\n        res = new ArrayList<>();\\n        helper(0,root);\\n        return res;\\n    }\\n    private void helper(int index , TreeNode cur){\\n        if(cur == null){\\n            return;\\n        }\\n        if(index == res.size()){\\n            res.add(cur.val);\\n        }\\n        helper(index+1,cur.right);\\n        helper(index+1,cur.left);\\n    }     \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> res;\\n    public List<Integer> rightSideView(TreeNode root) {\\n        res = new ArrayList<>();\\n        helper(0,root);\\n        return res;\\n    }\\n    private void helper(int index , TreeNode cur){\\n        if(cur == null){\\n            return;\\n        }\\n        if(index == res.size()){\\n            res.add(cur.val);\\n        }\\n        helper(index+1,cur.right);\\n        helper(index+1,cur.left);\\n    }     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363020,
                "title": "simple-c-solution",
                "content": "My simple C# solution \\n     \\n  ```\\nvoid helper(TreeNode root,IList<int> lst,int level)\\n        {\\n            if (root == null) return;\\n            if(level>lst.Count)\\n            {\\n                lst.Add(root.val);\\n            }\\n            helper(root.right, lst, level + 1);\\n            helper(root.left, lst, level + 1);\\n        }\\n        public IList<int> RightSideView(TreeNode root)\\n        {\\n            IList<int> list = new List<int>();\\n            helper(root, list, 1);\\n            return list;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid helper(TreeNode root,IList<int> lst,int level)\\n        {\\n            if (root == null) return;\\n            if(level>lst.Count)\\n            {\\n                lst.Add(root.val);\\n            }\\n            helper(root.right, lst, level + 1);\\n            helper(root.left, lst, level + 1);\\n        }\\n        public IList<int> RightSideView(TreeNode root)\\n        {\\n            IList<int> list = new List<int>();\\n            helper(root, list, 1);\\n            return list;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335805,
                "title": "rust-solution",
                "content": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>, level: usize) {\\n        if let Some(node) = node {\\n            if level == res.len() {\\n                res.push(node.borrow().val);\\n            }\\n            Self::traversal(node.borrow().right.clone(), res, level+1);\\n            Self::traversal(node.borrow().left.clone(), res, level+1);            \\n        }\\n\\n    }\\n    \\n    pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res: Vec<i32> = vec![];\\n        Self::traversal(root, &mut res, 0);\\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>, level: usize) {\\n        if let Some(node) = node {\\n            if level == res.len() {\\n                res.push(node.borrow().val);\\n            }\\n            Self::traversal(node.borrow().right.clone(), res, level+1);\\n            Self::traversal(node.borrow().left.clone(), res, level+1);            \\n        }\\n\\n    }\\n    \\n    pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res: Vec<i32> = vec![];\\n        Self::traversal(root, &mut res, 0);\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319566,
                "title": "java-2-approaches",
                "content": "Iterative:\\n\\n```\\npublic List<Integer> rightSideView(TreeNode root) {\\n      List<Integer> res = new ArrayList<>();\\n      if (root == null) {\\n          return res;\\n      }\\n      LinkedList<TreeNode> list = new LinkedList<>();\\n      list.add(root);\\n      while(!list.isEmpty()) {\\n         int n = list.size();\\n         for (int i = 0; i < n; i++) {\\n            TreeNode node = list.remove();\\n            if (i + 1 == n) {\\n               res.add(node.val);\\n            }\\n            if (node.left != null) {\\n               list.add(node.left);\\n            }\\n            if (node.right != null) {\\n               list.add(node.right);\\n            }\\n         }\\n      }\\n      return res;\\n   }\\n```\\n\\nRecursive:\\n\\n```\\nList<Integer> righSideViewResult = new ArrayList<>();\\n   void rightViewUtil(TreeNode node, int level, int[] maxLevel) {\\n      if (node == null)\\n         return;\\n      if (maxLevel[0] < level) {\\n         righSideViewResult.add(node.val);\\n         maxLevel[0] = level;\\n      }\\n      rightViewUtil(node.right, level + 1, maxLevel);\\n      rightViewUtil(node.left, level + 1, maxLevel);\\n   }\\n\\n   public List<Integer> rightSideView(TreeNode node) {\\n      rightViewUtil(node, 1, new int[] {0});\\n      return righSideViewResult;\\n   }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> rightSideView(TreeNode root) {\\n      List<Integer> res = new ArrayList<>();\\n      if (root == null) {\\n          return res;\\n      }\\n      LinkedList<TreeNode> list = new LinkedList<>();\\n      list.add(root);\\n      while(!list.isEmpty()) {\\n         int n = list.size();\\n         for (int i = 0; i < n; i++) {\\n            TreeNode node = list.remove();\\n            if (i + 1 == n) {\\n               res.add(node.val);\\n            }\\n            if (node.left != null) {\\n               list.add(node.left);\\n            }\\n            if (node.right != null) {\\n               list.add(node.right);\\n            }\\n         }\\n      }\\n      return res;\\n   }\\n```\n```\\nList<Integer> righSideViewResult = new ArrayList<>();\\n   void rightViewUtil(TreeNode node, int level, int[] maxLevel) {\\n      if (node == null)\\n         return;\\n      if (maxLevel[0] < level) {\\n         righSideViewResult.add(node.val);\\n         maxLevel[0] = level;\\n      }\\n      rightViewUtil(node.right, level + 1, maxLevel);\\n      rightViewUtil(node.left, level + 1, maxLevel);\\n   }\\n\\n   public List<Integer> rightSideView(TreeNode node) {\\n      rightViewUtil(node, 1, new int[] {0});\\n      return righSideViewResult;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287507,
                "title": "swift-bfs",
                "content": "```\\nclass Solution {\\n    func rightSideView(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        var queue = [root]\\n        var ans = [root.val]\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var added = false\\n            for i in 0..<count {\\n                let curr = queue.removeFirst()\\n                if let val = (curr.right?.val ?? curr.left?.val), !added {\\n                    ans.append(val)\\n                    added = true\\n                }\\n                if let right = curr.right {\\n                    queue.append(right)\\n                }\\n                if let left = curr.left {\\n                    queue.append(left)\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func rightSideView(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        var queue = [root]\\n        var ans = [root.val]\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var added = false\\n            for i in 0..<count {\\n                let curr = queue.removeFirst()\\n                if let val = (curr.right?.val ?? curr.left?.val), !added {\\n                    ans.append(val)\\n                    added = true\\n                }\\n                if let right = curr.right {\\n                    queue.append(right)\\n                }\\n                if let left = curr.left {\\n                    queue.append(left)\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246638,
                "title": "javascript-dfs-5-lines",
                "content": "```\\nvar rightSideView = function(root, depth = 0, result = []) {\\n    if(root == null) return result\\n    result[depth] = root.val\\n    rightSideView(root.left, depth+1, result)\\n    rightSideView(root.right, depth+1, result)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rightSideView = function(root, depth = 0, result = []) {\\n    if(root == null) return result\\n    result[depth] = root.val\\n    rightSideView(root.left, depth+1, result)\\n    rightSideView(root.right, depth+1, result)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 221004,
                "title": "swift-12ms",
                "content": "```\\nfunc rightSideView(_ root: TreeNode?) -> [Int] {\\n        guard let node = root else { return [] }\\n        var queue: [TreeNode] = []\\n        queue.append(node)\\n        var result: [Int] = []\\n        \\n        while !queue.isEmpty {\\n            \\n            var count = queue.count - 1\\n            \\n            while count >= 0 {\\n                let node = queue.removeFirst()\\n                if count == 0 { result.append(node.val) }\\n                if let leftChild = node.left { queue.append(leftChild) }\\n                if let rightChild = node.right  { queue.append(rightChild) }\\n                count -= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc rightSideView(_ root: TreeNode?) -> [Int] {\\n        guard let node = root else { return [] }\\n        var queue: [TreeNode] = []\\n        queue.append(node)\\n        var result: [Int] = []\\n        \\n        while !queue.isEmpty {\\n            \\n            var count = queue.count - 1\\n            \\n            while count >= 0 {\\n                let node = queue.removeFirst()\\n                if count == 0 { result.append(node.val) }\\n                if let leftChild = node.left { queue.append(leftChild) }\\n                if let rightChild = node.right  { queue.append(rightChild) }\\n                count -= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207417,
                "title": "javascript",
                "content": "```\\nvar rightSideView = function(root) {\\n    let result = []\\n    dfs(root, 0)\\n    \\n    function dfs(root, level) {\\n        if(!root)\\n            return\\n        if(!result[level])\\n            result.push(root.val)\\n        dfs(root.right, level + 1)\\n        dfs(root.left, level + 1)\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rightSideView = function(root) {\\n    let result = []\\n    dfs(root, 0)\\n    \\n    function dfs(root, level) {\\n        if(!root)\\n            return\\n        if(!result[level])\\n            result.push(root.val)\\n        dfs(root.right, level + 1)\\n        dfs(root.left, level + 1)\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56188,
                "title": "sharing-my-c-solution-iterative-bfs-using-a-queue-documented-code",
                "content": "    vector<int> rightSideView(TreeNode* root) \\n    {\\n        vector<int> ret;        // This is the vector we will return\\n        queue<TreeNode*> q;     // This is how we will track levels\\n        \\n        if(!root)               // If we have no root, we see nothing\\n            return ret;\\n            \\n        q.push(root);           // Push root node onto the queue\\n        \\n        while(!q.empty())       // Loop until we're out of nodes\\n        {\\n            ret.push_back(q.front()->val);  // Ever time we reach this line, we will be on the right most node\\n            \\n            int count = q.size();           // This is to make sure that we break at every level\\n            \\n            while(count > 0)                // While node at a given level are in the queue\\n            {\\n                if(q.front()->right)            // Enqueue their children right to left\\n                    q.push(q.front()->right);\\n                if(q.front()->left)\\n                    q.push(q.front()->left);\\n                    \\n                q.pop();                        // Pop the node who's children you enqueued off\\n                \\n                count--;                        // decrese the level count\\n            }\\n            \\n            // Because we enqueued right to left, the right most node will be at the front\\n            // of the queue, so when we reset to the top of the while loop, we record it\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    vector<int> rightSideView(TreeNode* root) \\n    {\\n        vector<int> ret;        // This is the vector we will return\\n        queue<TreeNode*> q;     // This is how we will track levels\\n        \\n        if(!root)               // If we have no root, we see nothing\\n            return ret;\\n            \\n        q.push(root);           // Push root node onto the queue\\n        \\n        while(!q.empty())       // Loop until we're out of nodes\\n        {\\n            ret.push_back(q.front()->val);  // Ever time we reach this line, we will be on the right most node\\n            \\n            int count = q.size();           // This is to make sure that we break at every level\\n            \\n            while(count > 0)                // While node at a given level are in the queue\\n            {\\n                if(q.front()->right)            // Enqueue their children right to left\\n                    q.push(q.front()->right);\\n                if(q.front()->left)\\n                    q.push(q.front()->left);\\n                    \\n                q.pop();                        // Pop the node who's children you enqueued off\\n                \\n                count--;                        // decrese the level count\\n            }\\n            \\n            // Because we enqueued right to left, the right most node will be at the front\\n            // of the queue, so when we reset to the top of the while loop, we record it\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56202,
                "title": "my-2ms-level-order-easy-to-uderstand",
                "content": "Using level Order Travaling:Travel each level ,find the last TreeNode of the level and add its val into our result .\\n\\u5199\\u82f1\\u8bed\\u53ea\\u80fd\\u8d39\\u52b2\\u554a\\uff0c\\u4e2d\\u6587\\u5427\\uff0c\\u5c42\\u5e8f\\u904d\\u5386\\uff0c\\u627e\\u5230\\u6bcf\\u5c42\\u91cc\\u9762\\u6700\\u540e\\u90a3\\u4e2a\\u8282\\u70b9\\uff0c\\u52a0\\u5230\\u7ed3\\u679c\\u96c6\\u5408\\u91cc\\uff0c\\u8017\\u65f6\\u4e24\\u6beb\\u79d2\\uff0c\\u7ed9\\u522b\\u4eba\\u4e00\\u4e2a\\u53c2\\u8003\\u5427\\u3002\\n\\n  public class Solution {\\n\\n      public List<Integer> rightSideView(TreeNode root) {\\n          List<Integer> res=new ArrayList<Integer>();\\n          if(root==null) return res;\\n          Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n          queue.add(root);\\n          while(queue.size()!=0){\\n            int level=queue.size();\\n            for(int i=1;i<=level;i++){\\n               TreeNode temp=queue.poll();\\n               if(level==i) res.add(temp.val);\\n               if(temp.left!=null) queue.add(temp.left);\\n               if(temp.right!=null) queue.add(temp.right);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n      public List<Integer> rightSideView(TreeNode root) {\\n          List<Integer> res=new ArrayList<Integer>();\\n          if(root==null) return res;\\n          Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n          queue.add(root);\\n          while(queue.size()!=0){\\n            int level=queue.size();\\n            for(int i=1;i<=level;i++){\\n               TreeNode temp=queue.poll();\\n               if(level==i) res.add(temp.val);\\n               if(temp.left!=null) queue.add(temp.left);\\n               if(temp.right!=null) queue.add(temp.right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56302,
                "title": "java-solution-using-depth-first-search",
                "content": "If we visit right child first, then we just need to add the node to result if we visit a new level. The code is quite simple\\n\\n    public class Solution {\\n        private List<Integer> r = new ArrayList<>();\\n        private int cur = 0;\\n        public List<Integer> rightSideView(TreeNode root) {\\n            gen(root,1,r);\\n            return r;\\n        }\\n        \\n        public void gen(TreeNode root, int level, List<Integer> r){\\n            if(root == null){\\n                return;\\n            }\\n            if(level>cur){\\n                r.add(root.val);\\n                cur = level;\\n            }\\n            gen(root.right,level+1,r);\\n            gen(root.left,level+1,r);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        private List<Integer> r = new ArrayList<>();\\n        private int cur = 0;\\n        public List<Integer> rightSideView(TreeNode root) {\\n            gen(root,1,r);\\n            return r;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3700974,
                "title": "easy-to-understand-c-solution-using-bfs",
                "content": "Please upvote if you liked it!\\n\\n```\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root){return ans;}\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            TreeNode * elem = q.front();\\n            q.pop();\\n            ans.push_back(elem->val);\\n            if(elem->right){q.push(elem->right);}\\n            if(elem->left){q.push(elem->left);}\\n            for(int i = 1;i<s;++i){\\n                TreeNode * temp = q.front();\\n                q.pop();      \\n            if(temp->right){q.push(temp->right);}\\n            if(temp->left){q.push(temp->left);}\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "Please upvote if you liked it!\\n\\n```\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root){return ans;}\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            TreeNode * elem = q.front();\\n            q.pop();\\n            ans.push_back(elem->val);\\n            if(elem->right){q.push(elem->right);}\\n            if(elem->left){q.push(elem->left);}\\n            for(int i = 1;i<s;++i){\\n                TreeNode * temp = q.front();\\n                q.pop();      \\n            if(temp->right){q.push(temp->right);}\\n            if(temp->left){q.push(temp->left);}\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3545612,
                "title": "day-415-dfs-bfs-0ms-100-python-java-c-explained",
                "content": "\\n\\n\\n# Code for recursive\\n```java []\\npublic List<Integer> rightSideView(TreeNode root) {\\n    List<Integer> A = new ArrayList<>();\\n    rec(root,0,A);\\n    return A;        \\n}\\nvoid rec(TreeNode root,int level,List<Integer> A){\\n    if(root==null) return;\\n    if(level==A.size()) A.add(root.val);//every first node in that level is part of right side \\n    rec(root.right,level+1,A);\\n    rec(root.left,level+1,A);//level order from right side view\\n}\\n```\\n\\n# code for iterative \\n\\n```java []\\npublic List<Integer> rightSideView(TreeNode root) {\\n    List<Integer> A = new ArrayList<>();\\n    if(root==null) return  A;\\n    Queue<TreeNode> q  = new LinkedList<>();\\n    q.add(root);\\n    while(!q.isEmpty()){\\n        int size = q.size();\\n        for(int i=0;i<size;i++){\\n            TreeNode node = q.poll();\\n            if(i==size-1)A.add(node.val);//every last node in that level is part of right side \\n            if(node.left!=null) q.add(node.left);\\n            if(node.right!=null)q.add(node.right);\\n        }\\n    }\\nreturn A;\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(h)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```java []\\npublic List<Integer> rightSideView(TreeNode root) {\\n    List<Integer> A = new ArrayList<>();\\n    rec(root,0,A);\\n    return A;        \\n}\\nvoid rec(TreeNode root,int level,List<Integer> A){\\n    if(root==null) return;\\n    if(level==A.size()) A.add(root.val);//every first node in that level is part of right side \\n    rec(root.right,level+1,A);\\n    rec(root.left,level+1,A);//level order from right side view\\n}\\n```\n```java []\\npublic List<Integer> rightSideView(TreeNode root) {\\n    List<Integer> A = new ArrayList<>();\\n    if(root==null) return  A;\\n    Queue<TreeNode> q  = new LinkedList<>();\\n    q.add(root);\\n    while(!q.isEmpty()){\\n        int size = q.size();\\n        for(int i=0;i<size;i++){\\n            TreeNode node = q.poll();\\n            if(i==size-1)A.add(node.val);//every last node in that level is part of right side \\n            if(node.left!=null) q.add(node.left);\\n            if(node.right!=null)q.add(node.right);\\n        }\\n    }\\nreturn A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522883,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    IList<int> ans = new List<int>();\\n    public IList<int> RightSideView(TreeNode root) {\\n        Helper(root, 0);\\n        return ans;\\n    }\\n\\n    void Helper(TreeNode root, int level)\\n    {\\n        if(root == null)\\n        {\\n            return;\\n        }\\n\\n        if(ans.Count == level)\\n        {\\n            ans.Add(root.val);\\n        }\\n\\n        Helper(root.right, level+1);\\n        Helper(root.left, level+1);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    IList<int> ans = new List<int>();\\n    public IList<int> RightSideView(TreeNode root) {\\n        Helper(root, 0);\\n        return ans;\\n    }\\n\\n    void Helper(TreeNode root, int level)\\n    {\\n        if(root == null)\\n        {\\n            return;\\n        }\\n\\n        if(ans.Count == level)\\n        {\\n            ans.Add(root.val);\\n        }\\n\\n        Helper(root.right, level+1);\\n        Helper(root.left, level+1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467506,
                "title": "python-simple-clean-solution-using-bfs",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return root\\n        q = [root]\\n        ans = []\\n        while q:\\n            t = q.copy()\\n            q.clear()\\n\\n            r = 0\\n            for node in t:\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n                r = node.val\\n            ans.append(r)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return root\\n        q = [root]\\n        ans = []\\n        while q:\\n            t = q.copy()\\n            q.clear()\\n\\n            r = 0\\n            for node in t:\\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n                r = node.val\\n            ans.append(r)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294502,
                "title": "easy-solution-o-n-space-and-time-complexity",
                "content": "> # Approach\\nLet\\'s traverse the given tree in level order and all right most node of every level will be visible if we see the tree in right view so add all right most node value into output list which is returned as right view.\\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        if(root==null) return new LinkedList<>();\\n        LinkedList<List<Integer>> lists = new LinkedList<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        TreeNode curr = root;\\n        queue.add(root);\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            LinkedList<Integer> list = new LinkedList<>();\\n            while(size>0){\\n                curr=queue.poll();\\n                list.add(curr.val);\\n                if(curr.left!=null) queue.add(curr.left);\\n                if(curr.right!=null) queue.add(curr.right);\\n                size--;\\n            }\\n            lists.add(list);\\n        }\\n        LinkedList<Integer> res = new LinkedList<>();\\n        for(int i=0;i<lists.size();i++){\\n            res.add(lists.get(i).get(lists.get(i).size()-1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        if(root==null) return new LinkedList<>();\\n        LinkedList<List<Integer>> lists = new LinkedList<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        TreeNode curr = root;\\n        queue.add(root);\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            LinkedList<Integer> list = new LinkedList<>();\\n            while(size>0){\\n                curr=queue.poll();\\n                list.add(curr.val);\\n                if(curr.left!=null) queue.add(curr.left);\\n                if(curr.right!=null) queue.add(curr.right);\\n                size--;\\n            }\\n            lists.add(list);\\n        }\\n        LinkedList<Integer> res = new LinkedList<>();\\n        for(int i=0;i<lists.size();i++){\\n            res.add(lists.get(i).get(lists.get(i).size()-1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277600,
                "title": "left-and-right-side-view-of-a-binary-trees-iterative-and-recursive-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor right side view just view the tree along the right boundary and it will be 1,3,7,6 and for left side it will be 1,2,4,6\\n![WhatsApp Image 2023-03-09 at 23.54.22.jpg](https://assets.leetcode.com/users/images/8d614aa7-0157-435a-81c1-d87d402a1874_1678386299.3958485.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1,3,7,6 are the last nodes of the level so we can simply calculate the level order traversal or any recursive traversal and can find the views. Also, 1,2,4,6 are first nodes of the levels so it can be found using the traversals\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nright side view of binary tree using recursive traversals\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root ,int level , vector<int> & ans){\\n        if(root==NULL) return;\\n        if(ans.size() == level) ans.push_back(root->val);\\n        dfs(root -> right ,  level + 1 , ans);\\n        dfs(root-> left ,  level + 1 , ans) ;\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root , 0 , ans);\\n        return ans;\\n    }\\n\\n};\\nleft side view of binary tree using recursive traversal\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root ,int level , vector<int> & ans){\\n        if(root==NULL) return;\\n        if(ans.size() == level) ans.push_back(root->val);\\n        dfs(root -> left ,  level + 1 , ans);\\n        dfs(root-> right,  level + 1 , ans) ;\\n    }\\n    vector<int> leftSideView(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root , 0 , ans);\\n        return ans;\\n    }\\n};\\nRight side view of binary tree iterative solution\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n       vector<int> result;\\n       queue<TreeNode* > q;\\n       q.push(root);\\n       if(root == NULL) return {};\\n       while( !q.empty() ) {\\n           int n = q.size();\\n           while(n--) {\\n               root = q.front();\\n               q.pop();\\n               \\n               if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n           }\\n           result.emplace_back(root->val);\\n       }\\n       return result;\\n    }\\n};\\nBinary tree left side view using iterative traversal \\n \\n    vector<int> leftSideView(TreeNode* root) {\\n       vector<int> result;\\n       queue<TreeNode* > q;\\n       q.push(root);\\n       if(root == NULL) return {};\\n       while( !q.empty() ) {\\n           int n = q.size();\\n           while(n--) {\\n               root = q.front();\\n               q.pop();\\n               \\n               if(root->right)\\n                    q.push(root->right);\\n                if(root->left)\\n                    q.push(root->left);\\n           }\\n           result.emplace_back(root->val);\\n       }\\n       return result;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nright side view of binary tree using recursive traversals\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root ,int level , vector<int> & ans){\\n        if(root==NULL) return;\\n        if(ans.size() == level) ans.push_back(root->val);\\n        dfs(root -> right ,  level + 1 , ans);\\n        dfs(root-> left ,  level + 1 , ans) ;\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root , 0 , ans);\\n        return ans;\\n    }\\n\\n};\\nleft side view of binary tree using recursive traversal\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root ,int level , vector<int> & ans){\\n        if(root==NULL) return;\\n        if(ans.size() == level) ans.push_back(root->val);\\n        dfs(root -> left ,  level + 1 , ans);\\n        dfs(root-> right,  level + 1 , ans) ;\\n    }\\n    vector<int> leftSideView(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root , 0 , ans);\\n        return ans;\\n    }\\n};\\nRight side view of binary tree iterative solution\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n       vector<int> result;\\n       queue<TreeNode* > q;\\n       q.push(root);\\n       if(root == NULL) return {};\\n       while( !q.empty() ) {\\n           int n = q.size();\\n           while(n--) {\\n               root = q.front();\\n               q.pop();\\n               \\n               if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n           }\\n           result.emplace_back(root->val);\\n       }\\n       return result;\\n    }\\n};\\nBinary tree left side view using iterative traversal \\n \\n    vector<int> leftSideView(TreeNode* root) {\\n       vector<int> result;\\n       queue<TreeNode* > q;\\n       q.push(root);\\n       if(root == NULL) return {};\\n       while( !q.empty() ) {\\n           int n = q.size();\\n           while(n--) {\\n               root = q.front();\\n               q.pop();\\n               \\n               if(root->right)\\n                    q.push(root->right);\\n                if(root->left)\\n                    q.push(root->left);\\n           }\\n           result.emplace_back(root->val);\\n       }\\n       return result;\\n    }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145406,
                "title": "c-bfs",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Breadth-First Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> vec;\\n        if(!root) return vec;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()) {\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                root = q.front();\\n                q.pop();\\n                if(i == size - 1) vec.push_back(root -> val);\\n                if(root -> left) q.push(root -> left);\\n                if(root -> right) q.push(root -> right);\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> vec;\\n        if(!root) return vec;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.size()) {\\n            int size = q.size();\\n            for(int i=0;i<size;i++) {\\n                root = q.front();\\n                q.pop();\\n                if(i == size - 1) vec.push_back(root -> val);\\n                if(root -> left) q.push(root -> left);\\n                if(root -> right) q.push(root -> right);\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117601,
                "title": "5-line-code-c-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, int level, vector<int> &ans){\\n        // Base Case\\n        if(root == NULL) return;\\n        if(level == ans.size()) ans.push_back(root -> val);\\n        solve(root->right,level+1,ans);\\n        solve(root->left,level+1,ans);\\n\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, int level, vector<int> &ans){\\n        // Base Case\\n        if(root == NULL) return;\\n        if(level == ans.size()) ans.push_back(root -> val);\\n        solve(root->right,level+1,ans);\\n        solve(root->left,level+1,ans);\\n\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058417,
                "title": "100-beat-0ms-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int l=0;\\nvoid tra(TreeNode *root,vector<int>&ans,int k){\\n    if(root==0){\\n        return;\\n    }\\n    k++;\\n    if(l<k){\\n        ans.push_back(root->val);\\n        l=max(l,k);\\n    }\\n    tra(root->right,ans,k);\\n    tra(root->left,ans,k);\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n   int k=0;\\n   tra(root,ans,k);\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int l=0;\\nvoid tra(TreeNode *root,vector<int>&ans,int k){\\n    if(root==0){\\n        return;\\n    }\\n    k++;\\n    if(l<k){\\n        ans.push_back(root->val);\\n        l=max(l,k);\\n    }\\n    tra(root->right,ans,k);\\n    tra(root->left,ans,k);\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n   int k=0;\\n   tra(root,ans,k);\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940688,
                "title": "c-bfs-level-wise-dfs",
                "content": "**If Helpful Please Like Or Upvoke**\\n```\\nclass Solution {\\npublic:\\n          \\n    vector<int> rightSideView(TreeNode* root) {\\n         vector<int>v;\\n        if(!root) return v;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n       \\n        while(!q.empty()){\\n            int n=q.size();\\n          for(int i=0; i<n; i++){\\n              TreeNode* node =q.front();q.pop();\\n              if(i==n-1)v.push_back(node->val);\\n              if(node->left)q.push(node->left);\\n              if(node->right)q.push(node->right);\\n          }\\n        \\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n**DFS**\\n```\\nclass Solution {\\npublic:\\n          void f(TreeNode* root, int level, vector<int>&v ){\\n             if(root==NULL) return ;\\n              if(v.size()==level){\\n                  v.push_back(root->val);\\n              }\\n              f(root->right, level+1, v);\\n              f(root->left, level+1, v);\\n         }\\n    vector<int> rightSideView(TreeNode* root) {\\n           vector<int>v;\\n           f( root, 0, v);\\n        return v; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n          \\n    vector<int> rightSideView(TreeNode* root) {\\n         vector<int>v;\\n        if(!root) return v;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n       \\n        while(!q.empty()){\\n            int n=q.size();\\n          for(int i=0; i<n; i++){\\n              TreeNode* node =q.front();q.pop();\\n              if(i==n-1)v.push_back(node->val);\\n              if(node->left)q.push(node->left);\\n              if(node->right)q.push(node->right);\\n          }\\n        \\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n          void f(TreeNode* root, int level, vector<int>&v ){\\n             if(root==NULL) return ;\\n              if(v.size()==level){\\n                  v.push_back(root->val);\\n              }\\n              f(root->right, level+1, v);\\n              f(root->left, level+1, v);\\n         }\\n    vector<int> rightSideView(TreeNode* root) {\\n           vector<int>v;\\n           f( root, 0, v);\\n        return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935779,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int>& ans, int h)\\n    {\\n        if(!root)\\n            return;\\n        if(h==ans.size())\\n        ans.push_back(root->val);\\n        f(root->right,ans,h+1);\\n        f(root->left,ans,h+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int>& ans, int h)\\n    {\\n        if(!root)\\n            return;\\n        if(h==ans.size())\\n        ans.push_back(root->val);\\n        f(root->right,ans,h+1);\\n        f(root->left,ans,h+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751650,
                "title": "easy-c-solution-level-order-traversal",
                "content": "Here is my C++ Solution using Level Order Traversal:- \\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if (root==NULL)return ans;\\n        // har level ke end ka element:\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()){\\n            int size= q.size();\\n            int ele;\\n            for (int i=0; i<size; i++){\\n                ele= q.front()->val;  \\n                if (q.front()->left)q.push(q.front()->left);\\n                if (q.front()->right)q.push(q.front()->right);\\n                q.pop();\\n            }\\n            ans.push_back(ele);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if (root==NULL)return ans;\\n        // har level ke end ka element:\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()){\\n            int size= q.size();\\n            int ele;\\n            for (int i=0; i<size; i++){\\n                ele= q.front()->val;  \\n                if (q.front()->left)q.push(q.front()->left);\\n                if (q.front()->right)q.push(q.front()->right);\\n                q.pop();\\n            }\\n            ans.push_back(ele);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622581,
                "title": "accepted-dfs-and-bfs-approaches-with-good-explanations-easy-to-understand",
                "content": "**Read the below both approaches to understand the logic.**\\n\\n***Please upvote if you like it!!***\\n\\n**Approach 1 : (BFS using queue)**\\n\\n1. Take a queue data structure and push root into it.\\n2. Take a loop iterate until queue became empty.\\n\\t* At each iteration take sz as current size of queue and declare temp as node variable\\n\\t\\t* Take a another loop inside previous loop iterate it until sz became zero.\\n\\t\\t* Set temp as front node of queue and pop front value of queue.\\n\\t\\t* push left and right node of temp node if not NULL.\\n\\t* push last temp node value into our ans vector.\\n3. At the end return ans node. \\n\\n**C++ Code:-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz=q.size();\\n            TreeNode* temp;\\n            while(sz--){\\n                temp=q.front();\\n                q.pop();\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            ans.push_back(temp->val);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2: (DFS)**\\nApproach: \\n\\n1. Create an vector data structure inside both the left and the right side view function\\n2. Call for the recursive _left and recursive_right function respectively with the (root,level,vector). Here level will be initially passed as 0.\\n3. Return the vector.\\n4. Now in the recursive_left function\\n\\t* If vector size is equal to the level then push_back its node value to the vector data structure.\\n\\t* Otherwise call recursive_left for (node->left,level+1,vector)\\n\\t* Call recursive_left for (node->right,level+1,vector)\\n5. Now in the recursive_right function\\n\\t* If vector size is equal to the level then push_back its node value to the vector data structure.\\n\\t* Otherwise call recursive_right for (node->right,level+1,vector)\\n\\t* Call recursive_right for (node->left,level+1,vector)\\n\\n***Tip:*** The Code for the Left and the Right View is almost identical. \\n\\nIn the Right view code first, you have to call the recursive function for the right then the left node\\n**AND**\\nIn the Right view code first, you have to call the recursive function for the Left than the right node\\n\\n**~Time Complexity: O(N)**\\n**~Space Complexity: O(H) (H -> Height of the Tree)**\\n\\n**Paper dry run:**\\n\\n![image](https://assets.leetcode.com/users/images/8b1f0561-a363-4cdc-bee4-d01d91ed2b1f_1664104871.5050604.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int>& ans,int len){\\n        if(!root) return;\\n        if(ans.size()==len){\\n            ans.push_back(root->val);\\n        }\\n        solve(root->right,ans,len+1);\\n        solve(root->left,ans,len+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz=q.size();\\n            TreeNode* temp;\\n            while(sz--){\\n                temp=q.front();\\n                q.pop();\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            ans.push_back(temp->val);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int>& ans,int len){\\n        if(!root) return;\\n        if(ans.size()==len){\\n            ans.push_back(root->val);\\n        }\\n        solve(root->right,ans,len+1);\\n        solve(root->left,ans,len+1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608331,
                "title": "199-binary-tree-right-side-view",
                "content": "```\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans=new ArrayList<>();\\n        getAns(ans,root,0);\\n            return ans;\\n    }\\n    public void getAns(List<Integer> ans,TreeNode root, int level)\\n    {\\n        if(root==null) // base case\\n            return ;\\n        if(level==ans.size())\\n            ans.add(root.val);\\n        // just observe how smartly we have used the rec \\n        // even on the left the level is +1 that\\'s how it working\\n          getAns(ans,root.right,level+1);\\n          getAns(ans,root.left,level+1);\\n    }\\n}\\n// if you find my simple sol helpful pls upvote :)",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> ans=new ArrayList<>();\\n        getAns(ans,root,0);\\n            return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2602767,
                "title": "c-simple-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                if(i==n-1){\\n                    ans.push_back(temp->val);\\n                }\\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                q.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                if(i==n-1){\\n                    ans.push_back(temp->val);\\n                }\\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n                q.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597266,
                "title": "my-java-solution-1ms-using-queue-using-recursion-4-lines",
                "content": "by using queue :\\n```\\npublic List<Integer> rightSideView(TreeNode root) {        \\n        List<Integer> res= new ArrayList<Integer>();\\n        if(root == null){\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        TreeNode last = root;\\n        res.add(root.val);\\n        queue.add(null);\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr == null){\\n                if(queue.isEmpty()){\\n                    break;\\n                }\\n                res.add(last.val);\\n                queue.add(null);\\n            }\\n            else{\\n                if(curr.left != null){\\n                    queue.add(curr.left);\\n                    last = curr.left;\\n                }\\n                if(curr.right != null){\\n                    queue.add(curr.right);\\n                    last = curr.right;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n```\\nusing recursion :\\n```\\n public void helper(TreeNode root,List<Integer> res , int currLevel){\\n        if(root == null) return;\\n        if(res.size() == currLevel) res.add(root.val);\\n        helper(root.right , res,currLevel + 1);\\n        helper(root.left , res,currLevel + 1);\\n    }\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        helper(root , res , 0);\\n        return res;\\n    }\\n```\\n**If this helps you , then Upvote.**",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> rightSideView(TreeNode root) {        \\n        List<Integer> res= new ArrayList<Integer>();\\n        if(root == null){\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        TreeNode last = root;\\n        res.add(root.val);\\n        queue.add(null);\\n        while(!queue.isEmpty()){\\n            TreeNode curr = queue.poll();\\n            if(curr == null){\\n                if(queue.isEmpty()){\\n                    break;\\n                }\\n                res.add(last.val);\\n                queue.add(null);\\n            }\\n            else{\\n                if(curr.left != null){\\n                    queue.add(curr.left);\\n                    last = curr.left;\\n                }\\n                if(curr.right != null){\\n                    queue.add(curr.right);\\n                    last = curr.right;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n```\n```\\n public void helper(TreeNode root,List<Integer> res , int currLevel){\\n        if(root == null) return;\\n        if(res.size() == currLevel) res.add(root.val);\\n        helper(root.right , res,currLevel + 1);\\n        helper(root.left , res,currLevel + 1);\\n    }\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        helper(root , res , 0);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2470140,
                "title": "simple-easy-java-solution-by-recursion",
                "content": "```\\n    public List<Integer> rightSideView(TreeNode root) {\\n      List <Integer> result = new ArrayList<Integer>();\\n      rightView(root, result , 0);\\n      return result ;\\n    }\\n    public void rightView(TreeNode root, List <Integer> result ,int currDepth){\\n      // null\\n      if ( root == null){\\n        return ;\\n      }\\n\\t  //If Height is equal to size of ds add it\\n      if ( currDepth == result.size()){\\n        result.add(root.val);\\n      }\\n     //right side\\n      rightView(root.right , result , currDepth + 1);\\n     //left  side\\n      rightView(root.left , result , currDepth + 1);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public List<Integer> rightSideView(TreeNode root) {\\n      List <Integer> result = new ArrayList<Integer>();\\n      rightView(root, result , 0);\\n      return result ;\\n    }\\n    public void rightView(TreeNode root, List <Integer> result ,int currDepth){\\n      // null\\n      if ( root == null){\\n        return ;\\n      }\\n\\t  //If Height is equal to size of ds add it\\n      if ( currDepth == result.size()){\\n        result.add(root.val);\\n      }\\n     //right side\\n      rightView(root.right , result , currDepth + 1);\\n     //left  side\\n      rightView(root.left , result , currDepth + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2284291,
                "title": "simple-depth-first-search-using-queue-of-treenode",
                "content": "```\\nclass Solution {\\n\\tpublic List<Integer> rightSideView(TreeNode root) {\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tqueue.add(root);\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\troot = queue.poll();\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tlist.add(root.val);\\n\\t\\t\\t\\tif (root.right != null)\\n\\t\\t\\t\\t\\tqueue.add(root.right);\\n\\t\\t\\t\\tif (root.left != null)\\n\\t\\t\\t\\t\\tqueue.add(root.left);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic List<Integer> rightSideView(TreeNode root) {\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tqueue.add(root);\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\troot = queue.poll();\\n\\t\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\t\\tlist.add(root.val);\\n\\t\\t\\t\\tif (root.right != null)\\n\\t\\t\\t\\t\\tqueue.add(root.right);\\n\\t\\t\\t\\tif (root.left != null)\\n\\t\\t\\t\\t\\tqueue.add(root.left);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269884,
                "title": "bfs-and-dfs-solution-c",
                "content": "# DFS Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        \\n        \\n      // we are maintaining an mx int for max level we reached        \\n        int mx = 0;\\n        push_right(root,ans,mx,1);\\n        return ans;\\n    }\\n    \\n    void push_right(TreeNode* root,vector<int> &ans,int &max,int h){\\n        \\n        if(root == NULL) return;\\n        \\n        // if we have reached any right node before on the same height or less we will skip this step\\n        if(max < h){\\n            max = h;\\n            ans.push_back(root->val);\\n        }\\n        \\n        // we will iterate as Right then left so that we will have right sided nodes\\n        push_right(root->right,ans,max,h+1);\\n        push_right(root->left,ans,max,h+1);\\n        \\n    }\\n    \\n};\\n```\\n\\n# BFS Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int> ans;\\n        \\n        if(root == NULL) return ans;\\n        \\n        queue<pair<TreeNode*,int>> q;  \\n        q.push(make_pair(root,0));\\n        \\n        pair<TreeNode*,int> temp;\\n        \\n        ans.push_back(root->val);\\n        int i;\\n        \\n        while(!q.empty()){\\n            \\n        temp = q.front();\\n        i = temp.second;    \\n        q.pop();\\n         if(ans.size() < i+1){\\n                ans.push_back(temp.first->val);\\n            }else{\\n                ans[i] = temp.first->val;\\n            }\\n            \\n        if(temp.first->left != NULL){ \\n            q.push(make_pair(temp.first->left,i+1));\\n        }   \\n        \\n        if(temp.first->right != NULL){\\n              q.push(make_pair(temp.first->right,i+1));\\n        }    \\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        \\n        \\n      // we are maintaining an mx int for max level we reached        \\n        int mx = 0;\\n        push_right(root,ans,mx,1);\\n        return ans;\\n    }\\n    \\n    void push_right(TreeNode* root,vector<int> &ans,int &max,int h){\\n        \\n        if(root == NULL) return;\\n        \\n        // if we have reached any right node before on the same height or less we will skip this step\\n        if(max < h){\\n            max = h;\\n            ans.push_back(root->val);\\n        }\\n        \\n        // we will iterate as Right then left so that we will have right sided nodes\\n        push_right(root->right,ans,max,h+1);\\n        push_right(root->left,ans,max,h+1);\\n        \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        vector<int> ans;\\n        \\n        if(root == NULL) return ans;\\n        \\n        queue<pair<TreeNode*,int>> q;  \\n        q.push(make_pair(root,0));\\n        \\n        pair<TreeNode*,int> temp;\\n        \\n        ans.push_back(root->val);\\n        int i;\\n        \\n        while(!q.empty()){\\n            \\n        temp = q.front();\\n        i = temp.second;    \\n        q.pop();\\n         if(ans.size() < i+1){\\n                ans.push_back(temp.first->val);\\n            }else{\\n                ans[i] = temp.first->val;\\n            }\\n            \\n        if(temp.first->left != NULL){ \\n            q.push(make_pair(temp.first->left,i+1));\\n        }   \\n        \\n        if(temp.first->right != NULL){\\n              q.push(make_pair(temp.first->right,i+1));\\n        }    \\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269275,
                "title": "c-fast-simple-easy-solution-binary-tree-right-side-view",
                "content": "class Solution {\\npublic:\\n\\n    void helper(TreeNode* root, vector<int> &ans, int i){\\n        if(root == NULL) return;\\n        \\n        if(i == ans.size())\\n            ans.push_back(root->val);\\n        \\n        helper(root->right, ans, i+1);\\n        helper(root->left, ans, i+1);\\n    }\\n    \\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    void helper(TreeNode* root, vector<int> &ans, int i){\\n        if(root == NULL) return;\\n        \\n        if(i == ans.size())\\n            ans.push_back(root->val);\\n        \\n        helper(root->right, ans, i+1);\\n        helper(root->left, ans, i+1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2267389,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q; // bfs queue \\n        if(root) q.push(root);\\n        while(!q.empty()){\\n            int l=q.size();\\n            ans.push_back(0);\\n            // look at all nodes at the current level \\n            while(l--){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n                ans[ans.size()-1]=node->val; // at the end of the loop, the right most value at the current level will be there at that position.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q; // bfs queue \\n        if(root) q.push(root);\\n        while(!q.empty()){\\n            int l=q.size();\\n            ans.push_back(0);\\n            // look at all nodes at the current level \\n            while(l--){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n                ans[ans.size()-1]=node->val; // at the end of the loop, the right most value at the current level will be there at that position.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266472,
                "title": "c-recursive-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    unordered_map<int,int> m;\\n    void right(TreeNode* root, int level ,int max_level){\\n      if(root==NULL)return;\\n        \\n      if(max_level < level){\\n          m[level]++;\\n          if(m[level]==1){\\n          res.push_back(root->val);\\n          max_level = level;\\n          }    \\n      }  \\n      right(root->right,level+1,max_level);\\n      right(root->left,level+1,max_level);  \\n        \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n       int max_level =0;\\n       right(root,1,max_level);\\n      return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    unordered_map<int,int> m;\\n    void right(TreeNode* root, int level ,int max_level){\\n      if(root==NULL)return;\\n        \\n      if(max_level < level){\\n          m[level]++;\\n          if(m[level]==1){\\n          res.push_back(root->val);\\n          max_level = level;\\n          }    \\n      }  \\n      right(root->right,level+1,max_level);\\n      right(root->left,level+1,max_level);  \\n        \\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n       int max_level =0;\\n       right(root,1,max_level);\\n      return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266364,
                "title": "easy-c-sol-recursive-iterative-time-o-n",
                "content": "```\\n// Iterative Sol :: Time : O(N) :: Aux_Space : O(N)\\n\\n /**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n\\n        if(!root)\\n            return {};\\n\\n        vector<int> res;\\n\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n\\n            int n = q.size();\\n\\n            for(int i=0;i<n;i++){\\n\\n                TreeNode*curr = q.front();\\n                q.pop();\\n\\n                if(i == n-1)\\n                    res.push_back(curr->val);\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n// Recursive Sol :: Time : O(N) :: Aux_Space : O(H) [H is the Height of the Tree]\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void reversePreorder(TreeNode* root, int level , vector<int> &res){\\n\\n        if(root == NULL)\\n            return;\\n\\n        if(res.size() == level){\\n            res.push_back(root->val);\\n        }\\n\\n        reversePreorder(root->right,level+1,res);\\n        reversePreorder(root->left,level+1,res);\\n\\n    }\\n\\n    vector<int> rightSideView(TreeNode* root) {\\n\\n        vector<int> res;\\n\\n        reversePreorder(root,0,res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n\\n        if(!root)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 2266106,
                "title": "c-iterative-recursive-approach",
                "content": "**Upvote if you like it :)**\\n\\n**Intuition:**\\nThe main intuition of the problem is that we basically need to get the `i` level nodes that are `rightmost`.\\nOnly the one\\'s in the `right` of each `level` are consider and pushed in to the `answer`.\\n\\n**Iterative Approach:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)\\n            return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode * node = q.front();\\n                q.pop();\\n                if(i==size-1)\\n                    ans.push_back(node->val);\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:O(N)**\\n**Space Complexity: O(Maximum Level)**\\n****\\n**Recursive Approach:**\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int level, vector<int>&res){\\n        if(!root)\\n            return;\\n        if(res.size()==level) res.push_back(root->val);\\n        dfs(root->right,level+1,res);\\n        dfs(root->left,level+1,res);\\n    }\\n\\n    vector<int> rightSideView(TreeNode* root){\\n        vector<int> res;\\n        dfs(root,0,res);\\n        return res;\\n    }\\n};\\n```\\n****\\n**Time Complexity:O(N)**\\n**Space Complexity: O(Height of the Tree)**\\n****",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)\\n            return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode * node = q.front();\\n                q.pop();\\n                if(i==size-1)\\n                    ans.push_back(node->val);\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int level, vector<int>&res){\\n        if(!root)\\n            return;\\n        if(res.size()==level) res.push_back(root->val);\\n        dfs(root->right,level+1,res);\\n        dfs(root->left,level+1,res);\\n    }\\n\\n    vector<int> rightSideView(TreeNode* root){\\n        vector<int> res;\\n        dfs(root,0,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265802,
                "title": "optimised-easy-recursive-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode *root,vector<int>&ans,int level)\\n{\\n   if(root==NULL)\\n   return;\\n   if(ans.size()==level)\\n   ans.push_back(root->val);\\n   solve(root->right,ans,level+1);\\n    solve(root->left,ans,level+1);\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n  solve(root,ans,0);\\n  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode *root,vector<int>&ans,int level)\\n{\\n   if(root==NULL)\\n   return;\\n   if(ans.size()==level)\\n   ans.push_back(root->val);\\n   solve(root->right,ans,level+1);\\n    solve(root->left,ans,level+1);\\n}\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n  solve(root,ans,0);\\n  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219802,
                "title": "0ms-100-fast-java-solution-recursive-approach",
                "content": "```\\nclass Solution {\\n    \\n    private int maxL = 0;\\n    \\n    private List<Integer> rViewCalc(List<Integer> ls, TreeNode root, int level) {\\n        \\n        if(root == null)\\n            return ls;\\n        \\n        if(maxL < level) {\\n            \\n            ls.add(root.val);\\n            maxL = level;\\n        }\\n        \\n        rViewCalc(ls, root.right, level + 1);\\n        rViewCalc(ls, root.left, level + 1);\\n        \\n        return ls;        \\n    }\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        List<Integer> rView = new ArrayList<Integer>();\\n        \\n        return rViewCalc(rView, root, 1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int maxL = 0;\\n    \\n    private List<Integer> rViewCalc(List<Integer> ls, TreeNode root, int level) {\\n        \\n        if(root == null)\\n            return ls;\\n        \\n        if(maxL < level) {\\n            \\n            ls.add(root.val);\\n            maxL = level;\\n        }\\n        \\n        rViewCalc(ls, root.right, level + 1);\\n        rViewCalc(ls, root.left, level + 1);\\n        \\n        return ls;        \\n    }\\n    \\n    public List<Integer> rightSideView(TreeNode root) {\\n        \\n        List<Integer> rView = new ArrayList<Integer>();\\n        \\n        return rViewCalc(rView, root, 1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205588,
                "title": "simple-c-o-n-solution-recursive-2ms",
                "content": "Order of Traversal => root -> right -> left\\nFor each level(height) maintain a map, to check if we have taken a node from this level or not.\\nThe order of our traversal ensures that we visit rightmost node at any level first. Push that node in answer vector and mark that level as visited or 1.\\n**Recursive implementation of the above idea**:\\n```\\nclass Solution {\\npublic:\\n    map<int, int> m;\\n    vector<int> ans;\\n    void rec(TreeNode *root, int h) {\\n        if(root == NULL) return;\\n        if(m[h] == 0) {\\n            ans.push_back(root -> val);\\n            m[h] = 1;\\n        }\\n        rec(root -> right, h + 1);\\n        rec(root -> left, h + 1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        rec(root, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int> m;\\n    vector<int> ans;\\n    void rec(TreeNode *root, int h) {\\n        if(root == NULL) return;\\n        if(m[h] == 0) {\\n            ans.push_back(root -> val);\\n            m[h] = 1;\\n        }\\n        rec(root -> right, h + 1);\\n        rec(root -> left, h + 1);\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        rec(root, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156122,
                "title": "c-solution-for-binary-tree-right-side-view-with-comments",
                "content": "Solution for **Binary Tree Right Side View** :)\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL) return ans;\\n        // queue to store the nodes\\n        queue<TreeNode*> q;\\n        \\n        // push the root node first\\n        q.push(root);\\n        \\n        // iterate till q is not empty\\n        while(!q.empty())\\n        {\\n            // check the size of the queue which will be equal to the\\n            // number of nodes in that particular level\\n            int n = q.size();\\n            int val;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* cur = q.front();\\n                q.pop();\\n                // update the val variable such that\\n                // it always stores the last node of that level\\n                val = cur->val;\\n                \\n                // check if left child is not null and push into queue\\n                if(cur->left != NULL) q.push(cur->left);\\n                // check if right child is not null and push into queue\\n                if(cur->right != NULL) q.push(cur->right);\\n            }\\n            \\n            // append val to the vector\\n            ans.push_back(val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL) return ans;\\n        // queue to store the nodes\\n        queue<TreeNode*> q;\\n        \\n        // push the root node first\\n        q.push(root);\\n        \\n        // iterate till q is not empty\\n        while(!q.empty())\\n        {\\n            // check the size of the queue which will be equal to the\\n            // number of nodes in that particular level\\n            int n = q.size();\\n            int val;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* cur = q.front();\\n                q.pop();\\n                // update the val variable such that\\n                // it always stores the last node of that level\\n                val = cur->val;\\n                \\n                // check if left child is not null and push into queue\\n                if(cur->left != NULL) q.push(cur->left);\\n                // check if right child is not null and push into queue\\n                if(cur->right != NULL) q.push(cur->right);\\n            }\\n            \\n            // append val to the vector\\n            ans.push_back(val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099208,
                "title": "recursive-solution-using-preorder-approch",
                "content": "\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> rightSideView(TreeNode* root,int level=0) {\\n        if(!root) return {};\\n        if(ans.size()==level) ans.push_back(root->val);\\n        rightSideView(root->right , level+1); //call for right\\n        rightSideView(root->left , level+1);  //call for left\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> rightSideView(TreeNode* root,int level=0) {\\n        if(!root) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2094856,
                "title": "python3-o-n-time-easy-to-understand-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n        if not root: return res\\n        \\n        q = collections.deque()\\n        q.append(root)\\n        \\n        while q:\\n            res.append(q[-1].val)  # the top element of q is the right-most\\n            n = len(q)             # popping all elements of a level at a time\\n            for i in range(n):     # first n nodes of q are nodes of current level\\n                node = q.popleft()\\n                if node.left: q.append(node.left)\\n                if node.right: q.append(node.right)\\n        \\n        return res\\n    \\n# Instead of using array as a queue we should use collections.deque()\\n# as pop() 0\\'th element from deque is of O(1) time.\\n\\n# Time: O(N)\\n# Space: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n        if not root: return res\\n        \\n        q = collections.deque()\\n        q.append(root)\\n        \\n        while q:\\n            res.append(q[-1].val)  # the top element of q is the right-most\\n            n = len(q)             # popping all elements of a level at a time\\n            for i in range(n):     # first n nodes of q are nodes of current level\\n                node = q.popleft()\\n                if node.left: q.append(node.left)\\n                if node.right: q.append(node.right)\\n        \\n        return res\\n    \\n# Instead of using array as a queue we should use collections.deque()\\n# as pop() 0\\'th element from deque is of O(1) time.\\n\\n# Time: O(N)\\n# Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784233,
                "title": "easy-to-understand-simplest-stack-version-during-an-interview-java",
                "content": "\\n\\tclass Solution {\\n\\t\\tpublic List<Integer> rightSideView(TreeNode root) {\\n\\t\\t\\tint height = 0; \\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tif(root == null) return ans;\\n        \\n        Node newRoot = new Node(root, height);\\n        \\n        Deque<Node> stack = new ArrayDeque<>();\\n        \\n        stack.push(newRoot);\\n        \\n        while(!stack.isEmpty()){\\n            Node n = stack.pop();\\n            TreeNode cur = n.node;\\n            height = n.height;\\n            \\n            if(height == ans.size()) ans.add(cur.val);\\n            \\n            \\n            if(cur.left != null) stack.push(new Node(cur.left, height + 1));\\n            if(cur.right != null) stack.push(new Node(cur.right, height + 1));\\n            \\n        }\\n        return ans;\\n    }\\n\\t}\\n\\n\\tclass Node{\\n\\t\\tTreeNode node;\\n\\t\\tint height;\\n    \\n    public Node(TreeNode node, int height){\\n        this.node = node;\\n        this.height = height;\\n    }\\n\\t}\\n\\t\\n\\tN is number of all the nodes in this tree\\n\\tTime : O(N) //time would be always O(N) no matter which method you use, this is tree traversal\\n\\t\\n\\tH is height of the tree;\\n\\tSpace: O(H) \\n\\tmax space would be \"a straight line\" all the way from the \"root\" (actually, left of root) of the tree to its any leaf node\\n\\t\\n\\t\\n\\tInstead of using two stack, one for treversing the whole tree, one for storing the height, \\n\\twe, on the other hand, \\n\\tcreate a class and encapsulate both of the TreeNode and its height to this class.\\n\\twe treverse the tree with the order node -> right -> left, \\n\\tsince each time when we are at a new level, \\n\\twe want to add the the right most node.val to our final list;\\n\\t\\n\\tPlease let me know if you have any question, I will try to make everyone understand if possible :)\\n\\t\\n\\tI was actually asked to solve this question using stack, during an interview, \\n\\tso I think it would be helpful to share my thought on this question to the public \\n\\tso we all can better prepare for our next techical interview!!!",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> rightSideView(TreeNode root) {\\n\\t\\t\\tint height = 0; \\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tif(root == null) return ans;\\n        \\n        Node newRoot = new Node(root, height);\\n        \\n        Deque<Node> stack = new ArrayDeque<>();\\n        \\n        stack.push(newRoot);\\n        \\n        while(!stack.isEmpty()){\\n            Node n = stack.pop();\\n            TreeNode cur = n.node;\\n            height = n.height;\\n            \\n            if(height == ans.size()) ans.add(cur.val);\\n            \\n            \\n            if(cur.left != null) stack.push(new Node(cur.left, height + 1));\\n            if(cur.right != null) stack.push(new Node(cur.right, height + 1));\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1683523,
                "title": "c-0ms-faster-than-100-and-99-21-less-memory-used",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    //just to initialise the size of our result vector\\n    //height = number of elements in the vector\\n    //Geeks for Geeks function code for height of a tree\\n    int maxDepth(TreeNode* node){ \\n        if (!node) return 0;\\n        else{ \\n            /* compute the depth of each subtree */\\n            int lDepth = maxDepth(node->left); \\n            int rDepth = maxDepth(node->right); \\n\\n            /* use the larger one */\\n            if (lDepth > rDepth) \\n                return(lDepth + 1); \\n            else return(rDepth + 1); \\n        } \\n    }\\n    //all we have to do is to use the rightmost node in every level\\n    //we keep updating the index with the newest value obtained\\n    //which is the rightmost since we traverse from left to right\\n    void fill(vector<int> &nums, TreeNode* root, int level){\\n        //base case\\n        if(level == n) return;\\n        if(!root) return;\\n        //recursive case\\n        nums[level] = root->val;\\n        fill(nums, root->left, level+1);\\n        fill(nums, root->right, level+1);\\n        return;\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        n = maxDepth(root);\\n        if(!n) return {};\\n        vector<int> res(n);\\n        fill(res, root, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    //just to initialise the size of our result vector\\n    //height = number of elements in the vector\\n    //Geeks for Geeks function code for height of a tree\\n    int maxDepth(TreeNode* node){ \\n        if (!node) return 0;\\n        else{ \\n            /* compute the depth of each subtree */\\n            int lDepth = maxDepth(node->left); \\n            int rDepth = maxDepth(node->right); \\n\\n            /* use the larger one */\\n            if (lDepth > rDepth) \\n                return(lDepth + 1); \\n            else return(rDepth + 1); \\n        } \\n    }\\n    //all we have to do is to use the rightmost node in every level\\n    //we keep updating the index with the newest value obtained\\n    //which is the rightmost since we traverse from left to right\\n    void fill(vector<int> &nums, TreeNode* root, int level){\\n        //base case\\n        if(level == n) return;\\n        if(!root) return;\\n        //recursive case\\n        nums[level] = root->val;\\n        fill(nums, root->left, level+1);\\n        fill(nums, root->right, level+1);\\n        return;\\n    }\\n    vector<int> rightSideView(TreeNode* root) {\\n        n = maxDepth(root);\\n        if(!n) return {};\\n        vector<int> res(n);\\n        fill(res, root, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674849,
                "title": "java-1-ms-easy-solution-with-comments",
                "content": "```\\n//LOGIC::\\n// AFTER ADDING A LEVEL IN QUEUE LAST ELEMENT WILL ALWAYS BE RIGHT SIDE ELEMENT SO WHEN I REACHES LAST ELEMENT IN QUEUE IT WILL GIVE US RIGHT SIDE ELEMENT IN  BINARY TREE\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list=new ArrayList<>();\\n        if(root==null)\\n        {\\n            return new ArrayList<>();\\n        }\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode t=q.poll();\\n                 if(i==n-1)\\n                {\\n                    list.add(t.val);\\n                }\\n                if(t.left!=null)\\n                {\\n                    q.add(t.left);\\n                }\\n                if(t.right!=null)\\n                {\\n                    q.add(t.right);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n//LOGIC::\\n// AFTER ADDING A LEVEL IN QUEUE LAST ELEMENT WILL ALWAYS BE RIGHT SIDE ELEMENT SO WHEN I REACHES LAST ELEMENT IN QUEUE IT WILL GIVE US RIGHT SIDE ELEMENT IN  BINARY TREE\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> list=new ArrayList<>();\\n        if(root==null)\\n        {\\n            return new ArrayList<>();\\n        }\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode t=q.poll();\\n                 if(i==n-1)\\n                {\\n                    list.add(t.val);\\n                }\\n                if(t.left!=null)\\n                {\\n                    q.add(t.left);\\n                }\\n                if(t.right!=null)\\n                {\\n                    q.add(t.right);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567599,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1921663,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567413,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1896366,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1842676,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568432,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573517,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1859798,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569652,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566727,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567599,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1921663,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567413,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1896366,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1842676,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568432,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573517,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1859798,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569652,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566727,
                "content": [
                    {
                        "username": "trannguyen",
                        "content": "Give the `root` of the binary tree, return the values of the right most node at each level of the tree from top to bottom.\\n\\nA useful test case for this problem would be:\\n**Input**: root = [1,2,3,null,5,6,null,4]\\n\\nTree visualizer: \\n\\n<img src=\"https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"350\" height=\"250\"/>\\n\\nThe output would be: [1,3,6,4]\\n\\n"
                    },
                    {
                        "username": "superkjp",
                        "content": "life saver"
                    },
                    {
                        "username": "pearcepallen",
                        "content": "I really think they should add this test case to the question. Was only able to fully understand after seeing this."
                    },
                    {
                        "username": "ingoscardan",
                        "content": "[@TielaRose](/TielaRose) Thanks for sharing! The example is clear and for me worked just perfect to fully understand the assignment "
                    },
                    {
                        "username": "TielaRose",
                        "content": "This is such a helpful explanation, I really didn\\'t understand what the problem was actually asking before reading this comment. Thank you!"
                    },
                    {
                        "username": "stridemann",
                        "content": "In other words we need to print the last node of each level in \"Level Order traversal\" algorithm."
                    },
                    {
                        "username": "ethanxu001",
                        "content": "Thank you! I was so confused thinking why not just keep referencing the right node and that\\'s it, until I found your comment. They really should use your example."
                    },
                    {
                        "username": "jyim3",
                        "content": "this is a good test case to call out, im wondering if they purposely left this out to encourage you to come up with it."
                    },
                    {
                        "username": "ccho515",
                        "content": "i legit could not understand what this question was asking until i saw this. thank you for the clarification"
                    },
                    {
                        "username": "bellicose100xp",
                        "content": "Thank you for the rephrasing. Leetcode should use this directly to clarify the problem."
                    },
                    {
                        "username": "UselessTM",
                        "content": "Thank you, now it makes sense. The description was really not clear and the examples didn\\'t help at all... "
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "super helpful"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Horrible examples again :) thought the problem was easy  and traverse right. "
                    },
                    {
                        "username": "asish_cse",
                        "content": "For input [1,2], output should be 1 only but they accept output as [1,2]. how this happened? Can anyone explain it?"
                    },
                    {
                        "username": "edilsonvilarinho",
                        "content": "I didn\\'t understand either."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "for this testcase 1 is the root and after that comes 2 which is it\\'s left child but since there\\'s no right child of 1, it means 2 will be visible from the right view of the tree.\\n"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "because we need to return the last element(on right side) of every level.\\nmeans if you are sitting on right of tree then what are the element visible to you at every level "
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Cmon leetcode. For once, could you give me a useful testcase and not the bullshit sample case that you have given above?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "I second that"
                    },
                    {
                        "username": "ahmedsamara",
                        "content": "Ambiguous description."
                    },
                    {
                        "username": "AcerPacemaker",
                        "content": "There is only one example. What do they mean when they say right side? One of the test cases is [1,2,3,4] and the answer is [1,3,4]. I thought the answer would be [1,3] because that is the right side of the tree. But obviously that\\'s not what they mean. Can someone explain the prompt a bit more?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "I think the question was the values from the perspective of Viewing the tree from Right side .\\nSo if \\n    1\\n  2    3      <-View from here\\n4 \\nIt is going to be [1,3,4]"
                    },
                    {
                        "username": "mddrill",
                        "content": "What does \"the right side of the tree\" mean? That could be enterpreted many ways."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use classical BFS algorithm, Find out left and right values at each root node and add it into queue, once you find childrens for root note, pick most recently added element to the queue which will be most right element.\\n\\n"
                    },
                    {
                        "username": "chrisportka",
                        "content": "Poor wording and example in this one.  I believe what you're saying is that we want rightmost node on every level of the tree.  Otherwise it reads (and the example shows) we just want the rightmost all the time - like a DFS that is always going right."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "I would expect the right most node of a level that is exclusive to the roots left child to not be included, the leetcode description is terrible."
                    },
                    {
                        "username": "globalcomacct",
                        "content": "![image](https://assets.leetcode.com/users/globalcomacct/image_1571183520.png)\\n\\nhow is expected [1,2] ?? 2 is on the left!!"
                    },
                    {
                        "username": "shreyash_Padeer_15",
                        "content": "Study the array representation of binary tree\\nyou will find that : \\n1. left child = at index 2i\\n2. right child = at index 2i+1\\n\\nso [1,2] means 2 is left child of 1\\nand [1,null,2] means 2 is right child of 1"
                    },
                    {
                        "username": "shail7826",
                        "content": "Because there is no right, therefore 2. Imagine you are standing on the right side and looking at a one dimenional tree, if there is no right node then the left node will not be hidden. Thus, 2 is also printed as it is not hidden from a right node "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-right-side-view/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** BFS: Two Queues\n\n  \n**Approach 2:** BFS: One Queue + Sentinel\n\n  \n**Approach 3:** BFS: One Queue + Level Size Measurements\n\n  \n**Approach 4:** Recursive DFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566643,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1573508,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1947874,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1574568,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1574249,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1960118,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1683458,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 1576036,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 2062131,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 2040481,
                "content": [
                    {
                        "username": "satyans24",
                        "content": "[https://youtu.be/oVijJs6_HjI](http://)"
                    },
                    {
                        "username": "abhishekhandacse",
                        "content": "Please consider this test case\\n\\n[1,2,4,3,null,null,5,null,6,7,null,null,8,9,null,null,10,12,null]\\nIts output logically should be 1,4,5,7,9,10\\nBut Expected code gives Its output  1,4,5,7,9,12\\nAnd Amazingly LOT also seems to work fine since Traversal starts from 10 and 12 becomes Rightmost node...\\n@admin Please Consider this question correctness again....\\nSeems like its made to favour reverse inorder  traversal and everyone is blindly follwing the norm"
                    },
                    {
                        "username": "atharv_26",
                        "content": "can someone explain the output of this input:\\n[0,1,2,null,3,4,null,null,5,9,null,null,6,10,null]\\nExpected: [0,2,4,9,10]\\nbut Ac to me it should be:[0,2,4,5,6]"
                    },
                    {
                        "username": "espertusnu",
                        "content": "Root is 0. Its left and right children are 1 and 2, respectively.\\n1 has right child 3, has right child 5, has right child 6.\\n2 has left child 4, has left child 9, has left child 10."
                    },
                    {
                        "username": "daniel520",
                        "content": "hi,\\nAs far as I understnad base on https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nthe insertion is preorder, this means in my example 1 is the root and 2 sits on the left, so output base on my understanding is [1] but I get errors expected [1,2]\\nAm I missing someting?"
                    },
                    {
                        "username": "lazydev69",
                        "content": "[@imnv](/imnv) this is the best explanation I\\'ve found, thank you."
                    },
                    {
                        "username": "imnv",
                        "content": "just imagine yourself standing to the right side of tree and now the nodes that you can see are the output\\n"
                    },
                    {
                        "username": "forbesmiyasato",
                        "content": "for test case: [1,null,3,2,5,null,null,4]\\nHow can null have child nodes 2 and 5? Am I trippin or is this test case faulty?\\n\\nThanks in advanced."
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "1 has l-child null and r-child 3 ofc null can\\'t have children\\n3 has l-child 2 and r-child 5 \\n2 has both null\\n5 has l-child 4"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Which traversal should we prefer here? My intuition led me to do a BFS but it seems like we can use a DFS as well, considering we can simply keep track of the level we\\'re on given the number of nodes we\\'ve \\'seen\\' on the right side so far.\\n\\nI feel that the BFS is more intuitive, so I\\'d prefer it in a \\'clean\\' sense, but that\\'s entirely subjective."
                    },
                    {
                        "username": "Avlek",
                        "content": "You can use BFS."
                    },
                    {
                        "username": "gaurav__pareek",
                        "content": "The number of nodes from right side will be equal to height of the tree,so first find out the height of the tree and then solve recursively.The approach is similar to the level order traversal.\\n![image](https://assets.leetcode.com/users/images/1419ddd8-a9e3-482a-b931-096b1132faeb_1638376887.0747201.png)\\n"
                    },
                    {
                        "username": "s3stan",
                        "content": "On test 26, it becomes clear that we need to return more than just the right side of the tree.\\nWe need to return all that tree that is visible when looking at the tree from the right side.\\nThat is, if at some nth level there are no longer nodes on the right side of the tree, then we need to return the nodes of this level on the left side of the tree."
                    },
                    {
                        "username": "apple_shakey",
                        "content": "The nodes on the right border are called here as nodes which are visible from right. To solve this problem, I used Breadth First Search."
                    }
                ]
            },
            {
                "id": 2022521,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 2017223,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1998303,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1995494,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1987889,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1984873,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1979876,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1977882,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1961950,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1945465,
                "content": [
                    {
                        "username": "mr__ray",
                        "content": "The question is asking you to return the rightmost node at each layer of the tree. "
                    },
                    {
                        "username": "moMo383734",
                        "content": "This question needs more examples and a better explanation."
                    },
                    {
                        "username": "pamphlet",
                        "content": "For the love of all that is holy, please improve your examples. The description for the problem is awful again."
                    },
                    {
                        "username": "Rhujisie",
                        "content": "var rightSideView = function(root) {\\n \\n    let queue = [root]\\n    let result = []\\n\\n    if(!root) return root\\n    console.log(\\'queue\\', queue)\\n    while(queue.length){\\n        let len = queue.length\\n        let node = queue[len - 1]\\n        while(len--){\\n            let curr = queue?.shift()\\n            if(curr?.left) queue.push(curr.left)\\n            if(curr?.right) queue.push(curr.right)\\n        }\\n        result.push(node.val)\\n    }\\n    console.log(\\'result\\', result)\\n    return result\\n}; \\n\\n\\nSome how the while loop runs again after it exits the loop.  After the code exits the while loop (i.e. when the queue is empty) some how the queue is set to [1,null, 3]. Someone please explain."
                    },
                    {
                        "username": "lamasonmez",
                        "content": "The intuition behind this approach is to iteratively obtain the number of nodes at each level in the current round of processing. The process involves looping until all the nodes at the current level are processed. During each iteration, the algorithm retrieves the next node and continues this loop until all nodes at the current level are handled. Once all nodes at the current level are processed, the last retrieved node is pushed into result array . This iterative process continues until all nodes in the entire structure are processed, following the same pattern at each level. , the time complexity of it will be O(N) where N is the number in the tree , and the space complexity will be approximately O(n/2), which simplifies to O(n) in the worst case."
                    },
                    {
                        "username": "enochchigbu",
                        "content": "why are the example test cases always so bad???\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "This is so poorly worded. The fact that I have to dive into the comments to understand this problem and find other struggling as well shows it\\'s not descriptive enough. \\nFor a simple understanding, imagine as the height of the tree grows, so does the size of your \"eye\" that you\\'re viewing it i.e you\\'re seeing this laterally"
                    },
                    {
                        "username": "danek1313",
                        "content": "Hint: If you are looking at a tree from the right and the left side is longer than the right side, you would be able to see some of the left values lower down the tree.\\n\\nI thought this was a super easy question at first until I hit submit and saw which cases failed. Then I realized what it is asking."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Should be an easy problem not medium."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ recursive DFS sol\\n\\n# Approach\\n1. Start by creating an empty list called `ans` to store the elements of the right side view of the binary tree.\\n2. Invoke a recursive helper function called `rec` with the root node of the binary tree, the `ans` list, and the initial level of 0.\\n3. Inside the `rec` function:\\n   - Check if the `root` node is null. If so, return from the function.\\n   - If the current `level` is equal to the size of the `ans` list, it means we have reached a new level in the tree. In this case, append the value of the `root` node to the `ans` list.\\n   - Recursively call the `rec` function on the right child of the `root` node, incrementing the level by 1.\\n   - Recursively call the `rec` function on the left child of the `root` node, incrementing the level by 1.\\n4. After the recursive calls are completed, return the `ans` list as the result, containing the right side view elements of the binary tree.\\n\\n----------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C-O(h) stack space. h==height of tree.\\n----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-right-side-view/solutions/3685377/c-recursive-dfs-sol/\\n"
                    }
                ]
            },
            {
                "id": 1933755,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1892256,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1866797,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1862311,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1862300,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1856699,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1854654,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1832936,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1812112,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            },
            {
                "id": 1793001,
                "content": [
                    {
                        "username": "A-125Ocean",
                        "content": "Hello I wanted to know what is happening with my code.\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> rightSideView(TreeNode root) {\\n        List<Integer> toReturn = new ArrayList<>();\\n        Queue<TreeNode> toCheck = new LinkedList<TreeNode>();\\n        Stack<TreeNode> toAdd = new Stack<>();\\n        toCheck.add(root);\\n        int counter = 0;\\n\\n        while (!toCheck.isEmpty()) {\\n            toAdd = new Stack<>();\\n\\n            toReturn.add(toCheck.peek().val);\\n            while (!toCheck.isEmpty()) {\\n                toAdd.push(toCheck.remove());\\n            }\\n            while (toAdd.size() != 0) {\\n                TreeNode toGet = toAdd.pop();\\n                \\n                \\n                if (toGet.right != null) {\\n                    toCheck.add(toGet.right);\\n                } \\n                if (toGet.left != null) {\\n                    toCheck.add(toGet.left);\\n                }\\n       \\n\\n            }\\n            counter++;\\n            System.out.println(counter);\\n\\n        }\\n        return toReturn;\\n\\n\\n\\n        \\n    }\\n}\\n\\nBasically there\\'s a really weird error. Counter is incrementing each time then it\\'s somehow decrementing and I have no idea why this may be the case. Here is the output:\\n1\\n2\\n3\\n1\\n2"
                    },
                    {
                        "username": "PRS19524",
                        "content": "class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        queue<TreeNode*> arr;\\n        arr.push(root);\\n        arr.push(NULL);\\n        int val;\\n        vector<int> answer;\\n        while(!arr.empty()){\\n            if(arr.front()!=NULL){\\n                TreeNode* temp = arr.front();\\n                arr.pop();\\n                val = temp->val;\\n                cout<<\"line no 26 \"<<temp->val<<\"\\\\n\";\\n                if(temp->left!=NULL){\\n                    cout<<\"Inserting thevleft value of\"<<temp->val<<\" \"<<temp->left->val<<\"\\\\n\";\\n                    arr.push(temp->left);\\n                }\\n                if(temp->right!=NULL){\\n                    cout<<\"Inserting the right value of\"<<temp->val<<\" \"<<temp->right->val<<\"\\\\n\";\\n                    arr.push(temp->right);\\n                }\\n            }else{\\n                answer.push_back(val);\\n                arr.pop();\\n                if(arr.size()!=0){\\n                arr.push(NULL);\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\nThis is my code and at last again the root is getting insert, can anyone please tell, why ?\\n"
                    },
                    {
                        "username": "alexmyn",
                        "content": "The following code takes testcase where `[1,2]` returns, `[1,2]`. \n\nYou should take into consider that in case of [1,2] there is no leftmost value, so the node takes rightmost one, in our case `if i == n - 1` takes left most side and also, takes in rightsided values\n\n```class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        res = []\n        q = deque([root])\n        while q:\n            n = len(q)\n            for i in range(n):\n                node = q.popleft()\n                if i == n - 1:\n                    res.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return res"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD37 if you have a deep understanding of dfs and bfs then trees will we a pancake for you"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 storing the right most element at each level"
                    },
                    {
                        "username": "Sarthak0304",
                        "content": "\"No module named queue\\n    from queue import Queue\" no queues?"
                    },
                    {
                        "username": "harsitsinha",
                        "content": "HINT: think of level order traversal"
                    },
                    {
                        "username": "pratham-dhorage",
                        "content": "getting memory limit exceeded bro.."
                    },
                    {
                        "username": "Shweta_Jha___",
                        "content": "You can modify level order traversal as per requirement. I believe that\\'s the simplest way to solve the question. \\nAt each level just take the last node value. That\\'ll server the purpose. "
                    },
                    {
                        "username": "anipaul",
                        "content": "What is wrong with it?\\n`class Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(0);\\n\\n        vector<int> v;\\n        int x = 0;\\n        while (!q.empty()) {\\n            TreeNode *n = q.front();\\n            q.pop();\\n\\n\\n            if (n) {\\n                printf(\"Curr:%d\\\\n\", n->val);\\n                if (n->left) q.push(n->left);\\n                if (n->right) q.push(n->right);\\n\\n                if (q.front() == 0) v.push_back(n->val);\\n            } else {\\n                printf(\"BULL:%d\\\\n\", x++);\\n                if (!q.empty()) {\\n                    q.push(0);\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};` `your inline code...your inline code...`"
                    },
                    {
                        "username": "luckyrapper2",
                        "content": "Question unclear!!!!!!\\n[1,2,3,null,4,5,null,null,6,7,null,null,8,9,null,null,10,9,null,null,10,9,null,null,10]\\nshould output :\\n1 3 5 6 8 10 10 10"
                    }
                ]
            }
        ]
    }
]