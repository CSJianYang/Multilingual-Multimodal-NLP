[
    {
        "title": "Robot Bounded In Circle",
        "question_content": "On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that:\n\tThe north direction is the positive direction of the y-axis.\n\tThe south direction is the negative direction of the y-axis.\n\tThe east direction is the positive direction of the x-axis.\n\tThe west direction is the negative direction of the x-axis.\nThe robot can receive one of three instructions:\n\t\"G\": go straight 1 unit.\n\t\"L\": turn 90 degrees to the left (i.e., anti-clockwise direction).\n\t\"R\": turn 90 degrees to the right (i.e., clockwise direction).\nThe robot performs the instructions given in order, and repeats them forever.\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n&nbsp;\nExample 1:\nInput: instructions = \"GGLLGG\"\nOutput: true\nExplanation: The robot is initially at (0, 0) facing the north direction.\n\"G\": move one step. Position: (0, 1). Direction: North.\n\"G\": move one step. Position: (0, 2). Direction: North.\n\"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West.\n\"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South.\n\"G\": move one step. Position: (0, 1). Direction: South.\n\"G\": move one step. Position: (0, 0). Direction: South.\nRepeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (0, 2) --> (0, 1) --> (0, 0).\nBased on that, we return true.\nExample 2:\nInput: instructions = \"GG\"\nOutput: false\nExplanation: The robot is initially at (0, 0) facing the north direction.\n\"G\": move one step. Position: (0, 1). Direction: North.\n\"G\": move one step. Position: (0, 2). Direction: North.\nRepeating the instructions, keeps advancing in the north direction and does not go into cycles.\nBased on that, we return false.\nExample 3:\nInput: instructions = \"GL\"\nOutput: true\nExplanation: The robot is initially at (0, 0) facing the north direction.\n\"G\": move one step. Position: (0, 1). Direction: North.\n\"L\": turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West.\n\"G\": move one step. Position: (-1, 1). Direction: West.\n\"L\": turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South.\n\"G\": move one step. Position: (-1, 0). Direction: South.\n\"L\": turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East.\n\"G\": move one step. Position: (0, 0). Direction: East.\n\"L\": turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North.\nRepeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (-1, 1) --> (-1, 0) --> (0, 0).\nBased on that, we return true.\n&nbsp;\nConstraints:\n\t1 <= instructions.length <= 100\n\tinstructions[i] is 'G', 'L' or, 'R'.",
        "solutions": [
            {
                "id": 290856,
                "title": "java-c-python-let-chopper-help-explain",
                "content": "I expect this problem to be medium problem.\\n![image](https://assets.leetcode.com/users/lee215/image_1557633739.png)\\n\\n## **Intuition**\\nLet chopper help explain.\\n\\nStarting at the origin and face north `(0,1)`,\\nafter one sequence of `instructions`,\\n1. if chopper return to the origin, he is obvious in an circle.\\n2. if chopper finishes with face not towards north,\\nit will get back to the initial status in another one or three sequences.\\n<br>\\n\\n## **Explanation**\\n`(x,y)` is the location of chopper.\\n`d[i]` is the direction he is facing.\\n`i = (i + 1) % 4` will turn right\\n`i = (i + 3) % 4` will turn left\\nCheck the final status after `instructions`.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n\\n<br>\\n\\n**Java:**\\n```\\n    public boolean isRobotBounded(String ins) {\\n        int x = 0, y = 0, i = 0, d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (int j = 0; j < ins.length(); ++j)\\n            if (ins.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; y += d[i][1];\\n            }\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n```\\n\\n**C++:**\\n```\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, i = 0;\\n        vector<vector<int>> d = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (char & ins : instructions)\\n            if (ins == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins == \\'L\\')\\n                i = (i + 3) % 4;\\n            else\\n                x += d[i][0], y += d[i][1];\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def isRobotBounded(self, instructions):\\n        x, y, dx, dy = 0, 0, 0, 1\\n        for i in instructions:\\n            if i == \\'R\\': dx, dy = dy, -dx\\n            if i == \\'L\\': dx, dy = -dy, dx\\n            if i == \\'G\\': x, y = x + dx, y + dy\\n        return (x, y) == (0, 0) or (dx, dy) != (0,1)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public boolean isRobotBounded(String ins) {\\n        int x = 0, y = 0, i = 0, d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (int j = 0; j < ins.length(); ++j)\\n            if (ins.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; y += d[i][1];\\n            }\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n```\n```\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, i = 0;\\n        vector<vector<int>> d = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (char & ins : instructions)\\n            if (ins == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins == \\'L\\')\\n                i = (i + 3) % 4;\\n            else\\n                x += d[i][0], y += d[i][1];\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n```\n```\\n    def isRobotBounded(self, instructions):\\n        x, y, dx, dy = 0, 0, 0, 1\\n        for i in instructions:\\n            if i == \\'R\\': dx, dy = dy, -dx\\n            if i == \\'L\\': dx, dy = -dy, dx\\n            if i == \\'G\\': x, y = x + dx, y + dy\\n        return (x, y) == (0, 0) or (dx, dy) != (0,1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 850969,
                "title": "my-java-solution-with-the-thought-process",
                "content": "```\\nclass Solution {\\n    /*\\n    My thought process:\\n    So in question its given we are initially at 0, 0 at North directions. So we need to keep track of the points as well as the directions in which the robot travels. So we can have x, y = 0 and directions = North\\n    \\n    Now our problem is to find whether the robot is moving outside the circle after following some instructions. So the robot leaves the circle if it keep moving in the North direction.\\n    \\n    So lets loop through each and every character from the instruction string, then:\\n    1. We check whether its G, if G then we have to move one point from the current position.\\n        SO if we are at North direction, then if we consider the coordinate, we are at +y directions, so we will move only up, just understand like that, SO we increment our y by 1, by following this pattern we can automatically deduce that if we are at South, then decrement y by 1. Same way for East, increment x by 1 and for West decrement x by 1.\\n    2. Next we check wheter its L, then we have to move 90 degree left wards.\\n                    North\\n            West                East    , So do a counter clockwise assumption. If we are at a directions North, then its \\n                                          counter clockwis, yes West update direction by west, Same way if our directions is                          South                West, them its counter clockwise south, same way for direction south, update                                                     direction by east. So just rememebr if chaarcter is L, then counter clockwise.\\n    3. Next whetehr the character if R, then we already got it rememebr about clockwise direction and update direction according to it\\n    \\n    Finally we check whetehr the robot get back to the position, if yes, return true as the robot donot go out of the circle.\\n    We check whether the direction is still North, then it will sure go out of the circle, so return false.\\n    If none of the above condition satisfies, then also the robot will be some where inside the circle, so return true.\\n    */\\n    public boolean isRobotBounded(String instructions) {\\n        if (instructions.length() == 0)\\n            return false;\\n        int x = 0;\\n        int y = 0;  // initial points of the robot\\n        String directions = \"North\"; // initial direction of robot\\n        /*\\n                    North\\n            West                East\\n                    South\\n                    \\n        */\\n        for (char ch: instructions.toCharArray()) {\\n            if (ch == \\'G\\') {\\n                if (directions.equals(\"North\"))\\n                    y += 1;\\n                else if (directions.equals(\"South\"))\\n                    y -= 1;\\n                else if(directions.equals(\"East\"))\\n                    x += 1;\\n                else\\n                    x -= 1;\\n            }\\n            else if (ch == \\'L\\') {\\n                if (directions.equals(\"North\"))\\n                    directions = \"West\";\\n                else if (directions.equals(\"West\"))\\n                    directions = \"South\";\\n                else if (directions.equals(\"South\"))\\n                    directions = \"East\";\\n                else directions = \"North\";\\n            }\\n            else if (ch == \\'R\\') {\\n                if (directions.equals(\"North\"))\\n                    directions = \"East\";\\n                else if (directions.equals(\"East\"))\\n                    directions = \"South\";\\n                else if (directions.equals(\"South\"))\\n                    directions = \"West\";\\n                else directions = \"North\";\\n            }\\n        }\\n        if (x == 0 && y == 0)\\n            return true;\\n        if (directions.equals(\"North\"))\\n            return false;\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    My thought process:\\n    So in question its given we are initially at 0, 0 at North directions. So we need to keep track of the points as well as the directions in which the robot travels. So we can have x, y = 0 and directions = North\\n    \\n    Now our problem is to find whether the robot is moving outside the circle after following some instructions. So the robot leaves the circle if it keep moving in the North direction.\\n    \\n    So lets loop through each and every character from the instruction string, then:\\n    1. We check whether its G, if G then we have to move one point from the current position.\\n        SO if we are at North direction, then if we consider the coordinate, we are at +y directions, so we will move only up, just understand like that, SO we increment our y by 1, by following this pattern we can automatically deduce that if we are at South, then decrement y by 1. Same way for East, increment x by 1 and for West decrement x by 1.\\n    2. Next we check wheter its L, then we have to move 90 degree left wards.\\n                    North\\n            West                East    , So do a counter clockwise assumption. If we are at a directions North, then its \\n                                          counter clockwis, yes West update direction by west, Same way if our directions is                          South                West, them its counter clockwise south, same way for direction south, update                                                     direction by east. So just rememebr if chaarcter is L, then counter clockwise.\\n    3. Next whetehr the character if R, then we already got it rememebr about clockwise direction and update direction according to it\\n    \\n    Finally we check whetehr the robot get back to the position, if yes, return true as the robot donot go out of the circle.\\n    We check whether the direction is still North, then it will sure go out of the circle, so return false.\\n    If none of the above condition satisfies, then also the robot will be some where inside the circle, so return true.\\n    */\\n    public boolean isRobotBounded(String instructions) {\\n        if (instructions.length() == 0)\\n            return false;\\n        int x = 0;\\n        int y = 0;  // initial points of the robot\\n        String directions = \"North\"; // initial direction of robot\\n        /*\\n                    North\\n            West                East\\n                    South\\n                    \\n        */\\n        for (char ch: instructions.toCharArray()) {\\n            if (ch == \\'G\\') {\\n                if (directions.equals(\"North\"))\\n                    y += 1;\\n                else if (directions.equals(\"South\"))\\n                    y -= 1;\\n                else if(directions.equals(\"East\"))\\n                    x += 1;\\n                else\\n                    x -= 1;\\n            }\\n            else if (ch == \\'L\\') {\\n                if (directions.equals(\"North\"))\\n                    directions = \"West\";\\n                else if (directions.equals(\"West\"))\\n                    directions = \"South\";\\n                else if (directions.equals(\"South\"))\\n                    directions = \"East\";\\n                else directions = \"North\";\\n            }\\n            else if (ch == \\'R\\') {\\n                if (directions.equals(\"North\"))\\n                    directions = \"East\";\\n                else if (directions.equals(\"East\"))\\n                    directions = \"South\";\\n                else if (directions.equals(\"South\"))\\n                    directions = \"West\";\\n                else directions = \"North\";\\n            }\\n        }\\n        if (x == 0 && y == 0)\\n            return true;\\n        if (directions.equals(\"North\"))\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676710,
                "title": "well-detailed-explaination-java-c-easy-for-mind-to-accept-it",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# IMPORTANT TIP FOR YOU\\n```\\nIf, you are preperaing for `AMAZON interview` or will prepare. Then according to `LeetCode premium` it is no.1 most asked Question by **Amazon** as per now\\n\\n*`So, Ladies n Gentlemen without any further due, let\\'s start:`*\\n**Intution:**\\nThe robot can face in at most four directions in the 2dimensional plane, such as \"North\", \"South\", \"East\", \"West\".\\n\\nIf the robot\\'s position is bounded in a fix circular radius, the robot must eventually return to its starting position after a fixed number of instruction\\'s.\\n\\n**Approach Explained :**\\n\\nSo, suppose we have a **2 dimensional grid** we have. WIth an instruction of **\"GGLLGG\"**. which states **go-go | turn to left 90 degree-turn to left 90 degree | go-go**. If we gonna repeat forever, we will get **stuck in an infinite loop** for now.. \\n1. Let\\'s kind of simulate it 1st, we intially **start at the origin**. And let\\'s have our direction facing **North** intially we are facing north, we gonna move **twice** and still facing **North** so, what happen is we move by 1, then move by 2 we gonna be in this position **still facing North.**\\n2. And then we **turn left twice**. So, if we turn left 1 90 degree we will be facing Left, if we do twice then we are **facing Down**.\\n3. Then, we **go-go.** Go, down 1 - Go down 2 and we start back at the **origin**. The only difference is now, **instead of facing North** we are **facing South**. But, obviously we get back to start.\\n\\n`Let me show you in a diagram:`\\n![image](https://assets.leetcode.com/users/images/b1e29303-3a2b-4046-a2ee-b53d57add0dc_1641692678.0059028.png)\\n\\n**Now you can ask, can we go for an another loop**. Just as we did before? My answer is **YES**, this path is some kind of a **Vector** on this 2 dimensional grid. So, in the above case the **vector was Up by 2** & then went **staright down by 2**. So, in **total the vector was a net difference of \"0\"** So, basically it started where it\\'s end.\\n\\nEven though, **first we facing North**, now we **facing South**, it\\'s gonna **follow that same path**. It\\'s gonna move by 2 and go back in same direction it\\'s came from. Because **this Vector is a \"0\" vector doesn\\'t move any where**.\\n![image](https://assets.leetcode.com/users/images/05c49dff-1b73-4445-91da-afa6e003011a_1641693089.1963322.png)\\n\\nSo, with this atleast yes, we gonna **return True**. Because this robot stuck in an infinite loop and we only end, if we see a **circlular path**\\n\\n*Now, let\\'s code it up:*\\n`Code each line explained : Similar for C++ & Java`\\n* Step1:\\n```\\n// we know that robot can move in 4 direction\\'s\\n        // Up, left, down, right\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0; // we have to keep tracking those cases where it\\'s not rotating.\\n        // if in the end of execution, we see it\\'s not rotating we will gonna return false;\\n       \\n        // it\\'s origin\\n        int x = 0;\\n        int y = 0;\\n```\\n* Step2:\\n```\\n// let\\'s write an for loop & iterate through the instructions. So, we keep 1 instructions at a time. \\n// And we will keep checking the position of the robot after executing particular instruction.\\n        for(int s = 0; s < instructions.length(); s++){\\n            // Now, we are checking is it a rotation\\n            if(instructions.charAt(s) == \\'L\\'){ // If it\\'s left then update it\\'s head rotation\\n                i = (i + 1) % 4; // since we are increment \"i\". To avoid array out of bound exception, we are moduling by 4\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){ // If it\\'s right then update it\\'s head rotation\\n                i = (i + 3) % 4;\\n            }\\n            // We are checking it\\'s direction\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n```\\n* Final Step:\\n```\\n// LAST EDIT : for (x == 0 && y == 0) We are checking is our intial position from where we started and end position where we are finishing both are same! \\n// If so,  return true;\\n\\n// If the robot perform 1 rotation, it means  \"i != 0\" then it will gauranteed perform a circle & after certain rotation it will come back to the origin.\\n        // But if \"i is  0\" , it mean\\'s robot is moving straight, hence there is no cycle. It will never come back to origin. \\n        return x == 0 && y == 0 || i != 0;\\n```\\n**Complete Code :**\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.length(); s++){\\n            if(instructions.charAt(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<vector<int>> dir = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.size(); s++){\\n            if(instructions.at(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.at(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(1)\\n\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# IMPORTANT TIP FOR YOU\\n```\n```\\n// we know that robot can move in 4 direction\\'s\\n        // Up, left, down, right\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0; // we have to keep tracking those cases where it\\'s not rotating.\\n        // if in the end of execution, we see it\\'s not rotating we will gonna return false;\\n       \\n        // it\\'s origin\\n        int x = 0;\\n        int y = 0;\\n```\n```\\n// let\\'s write an for loop & iterate through the instructions. So, we keep 1 instructions at a time. \\n// And we will keep checking the position of the robot after executing particular instruction.\\n        for(int s = 0; s < instructions.length(); s++){\\n            // Now, we are checking is it a rotation\\n            if(instructions.charAt(s) == \\'L\\'){ // If it\\'s left then update it\\'s head rotation\\n                i = (i + 1) % 4; // since we are increment \"i\". To avoid array out of bound exception, we are moduling by 4\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){ // If it\\'s right then update it\\'s head rotation\\n                i = (i + 3) % 4;\\n            }\\n            // We are checking it\\'s direction\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n```\n```\\n// LAST EDIT : for (x == 0 && y == 0) We are checking is our intial position from where we started and end position where we are finishing both are same! \\n// If so,  return true;\\n\\n// If the robot perform 1 rotation, it means  \"i != 0\" then it will gauranteed perform a circle & after certain rotation it will come back to the origin.\\n        // But if \"i is  0\" , it mean\\'s robot is moving straight, hence there is no cycle. It will never come back to origin. \\n        return x == 0 && y == 0 || i != 0;\\n```\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.length(); s++){\\n            if(instructions.charAt(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<vector<int>> dir = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.size(); s++){\\n            if(instructions.at(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.at(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291221,
                "title": "python-o-n-time-o-1-space-beats-100-detailed-explanations",
                "content": "There are only two scenarios where the robot can come back to its original location:\\n1) the robot is already back to its origin by the end of the string traversal, and \\n2) the robot is away from the origin, but heading to a direction different from its initial direction. For example, if the robot is facing left by the end of the first string traversal, after three other traversals of left->left->left, it is back to the origin. A second example is that if the robot is facing down by the end of the first string traversal, it only takes another traversal for it to get back to the origin.\\n\\nAnother tip on how to change the directions. You actually do not need to keep a list of all possible directions [(0,1), (-1,0), (0,-1), (1,0)]. Just swap dx and dy and add a negative sign to one of it to rotate the direction by 90 degrees. The proof is that the dot product of (dx,dy) and (dy,-dx) is 0, meaning that these two vectors are perpendicular to each other. \\n```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        di = (0,1)\\n        x,y = 0,0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x,y = x+di[0],y+di[1]\\n            elif instruction == \\'L\\':\\n                di = (-di[1],di[0])\\n            else:\\n                di = (di[1],-di[0])\\n            \\n        return (x==0 and y==0) or di!=(0,1)\\n```\\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        di = (0,1)\\n        x,y = 0,0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x,y = x+di[0],y+di[1]\\n            elif instruction == \\'L\\':\\n                di = (-di[1],di[0])\\n            else:\\n                di = (di[1],-di[0])\\n            \\n        return (x==0 and y==0) or di!=(0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677199,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanation-and-dry-run",
                "content": "**Reframing of question :-**\\nThere is a robo who stands at (0,0) and faces north . The robo has three functionalities \\n1. \"G\" =>go straight 1 unit.\\n2. \"L\" =>turn 90 degrees to left.\\n3. \"R\"=>turn 90 degrees to right.\\n\\n**@@A very imp note:-** *The robot performs the instructions given in order, and repeats them forever.*\\nReturn true if the robo comes back to his original position after executing the instructions else return false .\\n***\\n**Intuition:-**\\nThe intuition we can get from question is that if the robo comes back to origin we return true and if not than return false . Let\\'s understand more from the below examples :)\\n***\\n\\n**Now let\\'s take some example dry runs :-**\\nSorry for the bad drawing btw you should also try this dry runs it will help you a lot .\\n![image](https://assets.leetcode.com/users/images/8737467c-8711-4012-b769-37ee68e5dd7b_1641706847.1176744.jpeg)\\n![image](https://assets.leetcode.com/users/images/ef864c3a-070f-4d27-9736-523061d52684_1641706848.979658.jpeg)\\n\\n*From the above dry runs we can conclude that:-*\\n* If the robo comes back to origin the answer is true.\\n* If the robo is facing NORTH direction the answer is always false since we are drifting away from origin.\\n* If the robo is facing any direction except north the answer will be  true since it will became a loop and come back to origin\\n***\\n**Algorithm:-**\\n1. Let `x` and `y` be the co-ordinate points and the ongoing direction that robo depicts be as `current_dir` . Let the 4 directions be North `N`, South `S`, West `W`, EAST `E` . Let current instruction char be depicted by `incoming` .\\n2. After initialization we will create a `originVerifier`  function to chek whether the co-ordinates are origin or not\\n3. We need to loop the `instructions` . During the treaversing of string `instructions ` we have two cases \\n* **1st case:-** If we get `G` as instuction than we need to go straight 1 unit in that current direction\\n* **2nd case:-** In this case there is a chance that we will face directions  `N`, `S`, `W`, `E`. Once we find any of this direction just replace the currrent direction with this direction . \\n4. Now if the robo is at origin or the current direction is not north than return trueor else reutn false [Discussed during dry run\\n***\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    //returns true if the co-ordinates are at origin\\n    bool originVerifier(int x,int y){\\n        if(x == 0 && y == 0)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        //given\\n        char current_dir = \\'N\\';\\n        //co-ordinate points\\n        int x = 0, y= 0;\\n        for(int i=0;i<instructions.length();i++){ \\n            //Case1: If \\'G\\' is in the instruction string\\n            if(instructions[i] == \\'G\\'){\\n                y += current_dir ==\\'N\\' ? 1 : 0;\\n\\t\\t\\t\\ty += current_dir ==\\'S\\' ? -1 : 0;\\n\\t\\t\\t\\tx += current_dir == \\'E\\' ? 1 : 0;\\n\\t\\t\\t\\tx += current_dir == \\'W\\' ? -1 : 0;\\n            }\\n            //case2: If we found \\'directions\\'\\n            else{\\n                char incoming = instructions[i];\\n                if(current_dir == \\'N\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(current_dir == \\'W\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(current_dir == \\'S\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    current_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        //if the robo is at origin or the current direction is not north than return true\\n        if(originVerifier(x,y) || current_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n***\\nActually there is one more way to solve this and while i was trying to figure out a good explanation for that, came across this beautiful post so linking his post is the best way to give him credits ;)\\n**2nd Well optimized approach by @SVishal19 :-**\\nhttps://leetcode.com/problems/robot-bounded-in-circle/discuss/1680010/detailed-explanation-cpp-thought-process\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n***\\n**If you have some doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote ;)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //returns true if the co-ordinates are at origin\\n    bool originVerifier(int x,int y){\\n        if(x == 0 && y == 0)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        //given\\n        char current_dir = \\'N\\';\\n        //co-ordinate points\\n        int x = 0, y= 0;\\n        for(int i=0;i<instructions.length();i++){ \\n            //Case1: If \\'G\\' is in the instruction string\\n            if(instructions[i] == \\'G\\'){\\n                y += current_dir ==\\'N\\' ? 1 : 0;\\n\\t\\t\\t\\ty += current_dir ==\\'S\\' ? -1 : 0;\\n\\t\\t\\t\\tx += current_dir == \\'E\\' ? 1 : 0;\\n\\t\\t\\t\\tx += current_dir == \\'W\\' ? -1 : 0;\\n            }\\n            //case2: If we found \\'directions\\'\\n            else{\\n                char incoming = instructions[i];\\n                if(current_dir == \\'N\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(current_dir == \\'W\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(current_dir == \\'S\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    current_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        //if the robo is at origin or the current direction is not north than return true\\n        if(originVerifier(x,y) || current_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290859,
                "title": "java-solution-clear-explanation",
                "content": "First of all, this isn\\'t an easy question. I thought hard about this one. there are two things I found important. One, if you end up where you started, it is a circle. Two, if you end up in a different place with facing north (again), hence you are drifting away. All other scenarios are going to be in a circle (or come back) in infinity no matter. You can think that the starting and the end point form a vector. Unless the end direction is north, concataned vectors will always end up on the starting point eventually (infinity). \\n\\n```\\n    public boolean isRobotBounded(String instructions) {\\n        int[] cur = new int[] {0, 0};\\n        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int dir = 0; // 0:north(up), 1: right, 2: down, 3: left\\n        \\n        for (char in : instructions.toCharArray()) {\\n            if (in == \\'G\\') {\\n                cur[0] += dirs[dir][0];\\n                cur[1] += dirs[dir][1];\\n            } else if (in == \\'L\\') {\\n                dir = (dir + 3) % 4;\\n            } else {\\n                dir = (dir + 1) % 4;\\n            }\\n        }\\n        if (cur[0] == 0 && cur[1] == 0) { // ended up at the same place\\n            return true;\\n        }\\n        if (dir == 0 && !(cur[0] == 0 && cur[1] == 0)) { // if the direction is north and location has changed\\n            return false;\\n        }\\n        return true; // it is always true\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isRobotBounded(String instructions) {\\n        int[] cur = new int[] {0, 0};\\n        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int dir = 0; // 0:north(up), 1: right, 2: down, 3: left\\n        \\n        for (char in : instructions.toCharArray()) {\\n            if (in == \\'G\\') {\\n                cur[0] += dirs[dir][0];\\n                cur[1] += dirs[dir][1];\\n            } else if (in == \\'L\\') {\\n                dir = (dir + 3) % 4;\\n            } else {\\n                dir = (dir + 1) % 4;\\n            }\\n        }\\n        if (cur[0] == 0 && cur[1] == 0) { // ended up at the same place\\n            return true;\\n        }\\n        if (dir == 0 && !(cur[0] == 0 && cur[1] == 0)) { // if the direction is north and location has changed\\n            return false;\\n        }\\n        return true; // it is always true\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850437,
                "title": "python-o-n-solution-explained",
                "content": "Let `dx, dy` be directions of our robot and `x,y` be its coordinates. Then using linear algepra we can say that if we rotate to the left, then `dx, dy = -dy, dx`, similar if we rotate to the right. So, now we can easily follow the place of our robot. How to understand if his path will be bounded by some circle? We need to understand if he is going to loop. There are `3` possible options where path will be bounded.\\n1. In the end it will arrive to the starting position.\\n2. It will not arrive to the starting position and his orientation is rotated to the left or to the right. Then it can be shown easily that after `4` loops robot will return to the original place.\\n3. It will not arrive to the start and his orientation is opposite, then after `2` loops he will arrive at the starting place.\\n\\nSo, let us just check that after `4` times we traverse our `instructions` robot will be at the start, that is all!\\n\\n**Complexity**: Time complexity is `O(4n)`, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions):\\n        dx, dy, x, y = 0, 1, 0, 0\\n        for l in 4*instructions:\\n            if l == \"G\": \\n                x, y = x+dx, y+dy\\n            elif l == \"L\":\\n                dx, dy = -dy, dx\\n            else:\\n                dx, dy = dy, -dx\\n                \\n        return (x,y) == (0,0)\\n```\\n\\n**PS** I realized that we do not really need to traverse `instructions` 4 times, we can just return `(x,y) == 0 or (dx, dy) != (0,1)`, but this solution was already provided by others, so I left my solution as it is.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions):\\n        dx, dy, x, y = 0, 1, 0, 0\\n        for l in 4*instructions:\\n            if l == \"G\": \\n                x, y = x+dx, y+dy\\n            elif l == \"L\":\\n                dx, dy = -dy, dx\\n            else:\\n                dx, dy = dy, -dx\\n                \\n        return (x,y) == (0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731267,
                "title": "easy-java-accepted-solution",
                "content": "i=0, j=0, dir=1 starting position.\\ndir can be 1 = North, 2 = East, 3 = South, 4 = West.\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        int i=0;\\n        int j=0;\\n        int dir=1;\\n        \\n        for(char c : instructions.toCharArray()){  // Loop through to follow every instruction\\n            \\n            if(c == \\'G\\'){\\n                if(dir == 1) j++;  //if direction is north, move forward\\n                else if(dir == 2) i++;  //if direction is East, move right\\n                else if(dir == 3) j--;  //if direction is South, move downward\\n                else i--;  //if direction is west, move West\\n            }\\n            else if(c == \\'L\\'){  // if asked to turn left\\n                dir = dir == 1 ? 4 : dir-1; // subtract 1 from current direction to turn left, if  dir == 1 i.e. North, we need to turn towards west i.e. 4\\n            }\\n            else if(c == \\'R\\'){ // if asked to turn right\\n                dir = dir == 4 ? 1 : dir+1;  // add 1 from current direction to turn right, if  dir == 4 i.e. West, we need to turn towards North i.e. 1\\n            }\\n            \\n        }\\n        \\n        return i == 0 && j == 0 || dir > 1;   // check the current position and direction and decide\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        int i=0;\\n        int j=0;\\n        int dir=1;\\n        \\n        for(char c : instructions.toCharArray()){  // Loop through to follow every instruction\\n            \\n            if(c == \\'G\\'){\\n                if(dir == 1) j++;  //if direction is north, move forward\\n                else if(dir == 2) i++;  //if direction is East, move right\\n                else if(dir == 3) j--;  //if direction is South, move downward\\n                else i--;  //if direction is west, move West\\n            }\\n            else if(c == \\'L\\'){  // if asked to turn left\\n                dir = dir == 1 ? 4 : dir-1; // subtract 1 from current direction to turn left, if  dir == 1 i.e. North, we need to turn towards west i.e. 4\\n            }\\n            else if(c == \\'R\\'){ // if asked to turn right\\n                dir = dir == 4 ? 1 : dir+1;  // add 1 from current direction to turn right, if  dir == 4 i.e. West, we need to turn towards North i.e. 1\\n            }\\n            \\n        }\\n        \\n        return i == 0 && j == 0 || dir > 1;   // check the current position and direction and decide\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850634,
                "title": "python-simple-fastest-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=xgJh5HPCi3A)\\nhttps://www.youtube.com/watch?v=xgJh5HPCi3A\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direction = (0,1)\\n        start = [0,0]\\n        \\n        for x in instructions:\\n            if x == \\'G\\':\\n                start[0] += direction[0]\\n                start[1] += direction[1]\\n            elif x == \\'L\\':\\n                direction = (-direction[1], direction[0])\\n            elif x == \\'R\\':\\n                direction = (direction[1], -direction[0])\\n        \\n        return start == [0,0] or direction != (0,1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direction = (0,1)\\n        start = [0,0]\\n        \\n        for x in instructions:\\n            if x == \\'G\\':\\n                start[0] += direction[0]\\n                start[1] += direction[1]\\n            elif x == \\'L\\':\\n                direction = (-direction[1], direction[0])\\n            elif x == \\'R\\':\\n                direction = (direction[1], -direction[0])\\n        \\n        return start == [0,0] or direction != (0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851232,
                "title": "easy-direction-wise-c-soution-beats-100",
                "content": "Think by placing yourself at origin.\\nTwo cases arise after the an iteration :\\n1. You end up back at origin.\\n2. You end up somewhere else.\\n\\n**Case 1.**\\nIf you are at origin, answer is true.\\n**Case 2.**\\n1. **Case 2(i) :** You are facing **NORTH** -  Answer is false.\\n2. **Case2(ii) :** You are **Not facing NORTH** - Answer is true.\\n\\n``` \\nclass Solution {\\npublic:\\n    \\n    bool check_origin(unordered_map<char,int> map){\\n        \\n        if(map[\\'N\\'] == map[\\'S\\'] && map[\\'E\\'] == map[\\'W\\'])\\n            return true;\\n        return false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        \\n        char curr_dir = \\'N\\';\\n    \\n        unordered_map<char,int> map;\\n        \\n        for(int i=0;i<instructions.length();i++){ \\n            if(instructions[i] == \\'G\\'){\\n                map[curr_dir]++;\\n            }\\n            else{\\n                char incoming = instructions[i];\\n                if(curr_dir == \\'N\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(curr_dir == \\'W\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(curr_dir == \\'S\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    curr_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        if(check_origin(map) || curr_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```\\n\\n**EDIT - 1**\\nWe don\\'t need to keep a map to store the steps in every direction. We can do this just with the help of 2 variables.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check_origin(int h,int v){\\n        if(h == 0 && v == 0)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        \\n        char curr_dir = \\'N\\';\\n    \\n        //unordered_map<char,int> map;\\n        int vertical = 0, horizontal= 0;\\n        for(int i=0;i<instructions.length();i++){ \\n            if(instructions[i] == \\'G\\'){\\n                vertical += curr_dir ==\\'N\\' ? 1 : 0;\\n\\t\\t\\t\\tvertical += curr_dir ==\\'S\\' ? -1 : 0;\\n\\t\\t\\t\\thorizontal += curr_dir == \\'E\\' ? 1 : 0;\\n\\t\\t\\t\\thorizontal += curr_dir == \\'W\\' ? -1 : 0;\\n            }\\n            else{\\n                char incoming = instructions[i];\\n                if(curr_dir == \\'N\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(curr_dir == \\'W\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(curr_dir == \\'S\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    curr_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        if(check_origin(horizontal,vertical) || curr_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    \\n    bool check_origin(unordered_map<char,int> map){\\n        \\n        if(map[\\'N\\'] == map[\\'S\\'] && map[\\'E\\'] == map[\\'W\\'])\\n            return true;\\n        return false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        \\n        char curr_dir = \\'N\\';\\n    \\n        unordered_map<char,int> map;\\n        \\n        for(int i=0;i<instructions.length();i++){ \\n            if(instructions[i] == \\'G\\'){\\n                map[curr_dir]++;\\n            }\\n            else{\\n                char incoming = instructions[i];\\n                if(curr_dir == \\'N\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(curr_dir == \\'W\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(curr_dir == \\'S\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    curr_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        if(check_origin(map) || curr_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool check_origin(int h,int v){\\n        if(h == 0 && v == 0)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        \\n        char curr_dir = \\'N\\';\\n    \\n        //unordered_map<char,int> map;\\n        int vertical = 0, horizontal= 0;\\n        for(int i=0;i<instructions.length();i++){ \\n            if(instructions[i] == \\'G\\'){\\n                vertical += curr_dir ==\\'N\\' ? 1 : 0;\\n\\t\\t\\t\\tvertical += curr_dir ==\\'S\\' ? -1 : 0;\\n\\t\\t\\t\\thorizontal += curr_dir == \\'E\\' ? 1 : 0;\\n\\t\\t\\t\\thorizontal += curr_dir == \\'W\\' ? -1 : 0;\\n            }\\n            else{\\n                char incoming = instructions[i];\\n                if(curr_dir == \\'N\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(curr_dir == \\'W\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(curr_dir == \\'S\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    curr_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        if(check_origin(horizontal,vertical) || curr_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677124,
                "title": "c-python-java-simple-one-pass-simulation-100-faster",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* After One-Pass simulation, we can easily get the direction `di` and the position `(x, y)` at last.\\n* 4 possible cases\\n\\t*  `x == 0 and y == 0`, certainly `return True`\\n\\t* `di == 2`, the robot reversed direction, after going through all the instructions **once again, robot comes back to (0, 0)**\\n\\t* `di == 1 or di == 3`, the robot turns left or right, after going through all the instructions **3 times again, robot comes back to (0, 0)**\\n\\t* `di == 0 and not (x == 0 and y == 0)`, the robot moved in one direction and **never came back**.\\n\\n\\n**Python**\\n```\\n#  Runtime: 8 ms, faster than 99.64%\\nclass Solution(object):\\n    def isRobotBounded(self, I):\\n        d = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        di = x = y = 0\\n        for i in I:\\n            if i == \\'L\\': di = (di + 1) % 4\\n            elif i == \\'R\\': di = (di - 1) % 4\\n            else: x, y = x + d[di][0], y + d[di][1]\\n        if x == 0 and y == 0 or di > 0: return True\\n        return False\\n```\\n\\n**C++**\\n```\\n// Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string I) {\\n        int d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int di = 0, x = 0, y = 0;\\n        \\n        for (int i = 0; i < I.size(); i ++) {\\n            switch (I[i])\\n            {\\n                case \\'L\\': \\n                    di = (di + 1) % 4; \\n                    break;\\n                case \\'R\\': \\n                    di = (di + 3) % 4;\\n                    break;\\n                default:\\n                    x = x + d[di][0];\\n                    y = y + d[di][1];\\n            }\\n        }\\n        if (x == 0 && y == 0 || di > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\n// Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\n    public boolean isRobotBounded(String I) {\\n        int[][] d = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int di = 0, x = 0, y = 0;\\n        \\n        for (int i = 0; i < I.length(); i ++) {\\n            switch (I.charAt(i))\\n            {\\n                case \\'L\\': \\n                    di = (di + 1) % 4; \\n                    break;\\n                case \\'R\\': \\n                    di = (di + 3) % 4;\\n                    break;\\n                default:\\n                    x = x + d[di][0];\\n                    y = y + d[di][1];\\n            }\\n        }\\n        if (x == 0 && y == 0 || di > 0)\\n            return true;\\n        return false;\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n#  Runtime: 8 ms, faster than 99.64%\\nclass Solution(object):\\n    def isRobotBounded(self, I):\\n        d = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        di = x = y = 0\\n        for i in I:\\n            if i == \\'L\\': di = (di + 1) % 4\\n            elif i == \\'R\\': di = (di - 1) % 4\\n            else: x, y = x + d[di][0], y + d[di][1]\\n        if x == 0 and y == 0 or di > 0: return True\\n        return False\\n```\n```\\n// Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string I) {\\n        int d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int di = 0, x = 0, y = 0;\\n        \\n        for (int i = 0; i < I.size(); i ++) {\\n            switch (I[i])\\n            {\\n                case \\'L\\': \\n                    di = (di + 1) % 4; \\n                    break;\\n                case \\'R\\': \\n                    di = (di + 3) % 4;\\n                    break;\\n                default:\\n                    x = x + d[di][0];\\n                    y = y + d[di][1];\\n            }\\n        }\\n        if (x == 0 && y == 0 || di > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n```\n```\\n// Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\n    public boolean isRobotBounded(String I) {\\n        int[][] d = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int di = 0, x = 0, y = 0;\\n        \\n        for (int i = 0; i < I.length(); i ++) {\\n            switch (I.charAt(i))\\n            {\\n                case \\'L\\': \\n                    di = (di + 1) % 4; \\n                    break;\\n                case \\'R\\': \\n                    di = (di + 3) % 4;\\n                    break;\\n                default:\\n                    x = x + d[di][0];\\n                    y = y + d[di][1];\\n            }\\n        }\\n        if (x == 0 && y == 0 || di > 0)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290915,
                "title": "python-concise-explanation",
                "content": "In order for the robot to stay within a circle, you need to move in a cycle. The only way you move in a cycle is if you end where you start (the origin at (0, 0)). \\n\\nThe minimum number of instructions you need to repeat is 4 in order to figure out if you\\'re in a cycle.  \\n\\nFor example, if each instruction only rotates 90 degrees, you need to repeat the instructions 4 times to possibly end where you start. \\nIf each instruction rotates 180 degrees, you need to repeat the instructions 2 times to possibly end where you start. \\nIf each instruction rotates 270 degrees, you need to repeat the instruction 4 times to possibly end where you start. \\n\\nIm the real word, you could stop the algo if you have repeated the instructions 2x and it ends on (0,0), but here it is still O(N).\\n\\n```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        #up, left, down, right\\n        dir, start, d = ([-1, 0], [0, -1], [1, 0], [0, 1]), [0,0], 0\\n        for i in range(4):\\n            for x in instructions:\\n                if x == \"G\":\\n                    start[0] += dir[d][0]\\n                    start[1] += dir[d][1]\\n                if x == \"L\": d = (d + 1) % 4 \\n                if x == \"R\": d = (d - 1) % 4\\n        return True if start == [0,0] else False \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        #up, left, down, right\\n        dir, start, d = ([-1, 0], [0, -1], [1, 0], [0, 1]), [0,0], 0\\n        for i in range(4):\\n            for x in instructions:\\n                if x == \"G\":\\n                    start[0] += dir[d][0]\\n                    start[1] += dir[d][1]\\n                if x == \"L\": d = (d + 1) % 4 \\n                if x == \"R\": d = (d - 1) % 4\\n        return True if start == [0,0] else False \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680010,
                "title": "detailed-explanation-cpp-thought-process",
                "content": "**[Leetcode Question](https://leetcode.com/problems/robot-bounded-in-circle/)** \\n\\nWe have to find if we can make a circle on the infinite plane such that the robot only remains in the circle. So, we have to find where the robot is finishing after each simulation of the string. \\nNow, to figure out the final position of the robot after one simulation we have to find values which should be added to the current position of the robot depending on the direction the robot is facing.\\n\\nSo, on observation\\n\\n| Direction | Add | L | R |\\n| ----------|-----|---|---|\\n| North | (0, 1) | West | East |\\n| West  | (-1, 0) | South | North |\\n| East | (1, 0) | North | South |\\n| South | (0, -1) | East | West |\\n\\nSo, we can make use of the above direction matrix to add the correspoding x and y values in the current position and also to identify the final direction the robot is facing.\\n\\nSo, the key point is.... **Since we are simulating the same string infinite number of times, robot will be contrainted in the same area only when it keeps on rotating the same circular path i.e. after some k simulations of the string the robot should definitely come back to it\\'s original position i.e. (0, 0).**\\n\\n<span style=\"color: red\">**_So the conclusion comes out that - after one simulation the direction of the robot should be changed or if the direction does not change, then the robot should be at (0, 0), i.e. it did not move from it\\'s starting point or again came back to it\\'s starting point after one simulation._**<span>\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n        vector<pair<int, int>> direction{{1, 2}, {3, 0}, {0, 3}, {2, 1}};\\n        vector<pair<int, int>> addPoints{{0, 1}, {-1, 0}, {1, 0}, {0, -1}};\\n        \\n        if(count(ins.begin(), ins.end(), \\'G\\') == 0) {\\n            return true;\\n        }\\n        \\n        int x = 0, y = 0;\\n        int dir = 0;\\n        for(int i=0; i<ins.size(); i++) {\\n            if(ins[i] == \\'G\\') {\\n                x += addPoints[dir].first;\\n                y += addPoints[dir].second;\\n            } else {\\n                dir = ins[i] == \\'L\\' ? direction[dir].first : direction[dir].second;\\n            }\\n        }\\n        \\n        if((dir != 0) || (x == 0 && y == 0)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n### A more better way of handling directions\\n----------\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n                \\n        int dir = 0;\\n        int x = 0, y = 0;\\n        for(int i=0; i<ins.size(); i++) {\\n            if(ins[i] == \\'G\\') {\\n                x += directions[dir][0];\\n                y += directions[dir][1];\\n            } else {\\n                dir = ins[i] == \\'L\\' ? (dir - 1 + 4)%4 : (dir +1)%4;\\n            }\\n        }\\n        \\n        return (dir != 0) || (x == 0 && y == 0);\\n    }\\n};\\n```\\n\\n### How is the directions working?\\n```\\ni = (i+1) % 4 will turn right\\ni = (i+3) % 4 will turn left\\n```\\n\\nIt\\'s actually like this, we store the directions in an array like this\\n\\n`vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}` \\n\\nIt is basically `[\\'N\\', \\'E\\', \\'S\\', \\'W\\']` all the directions in clockwise directions.\\n\\nNow the initial direction is North i.e. 0, let\\'s save this in the variable i\\nso initially `i = 0`\\n\\nNow, when the robot turns left i.e. we are moving in an anticlockwise direction, our next direction will be west. Since we are storing the directions in a clockwise manner we need to decrement the i value by 1, but the catch is while decrementing i can become negative. \\n\\nFor eg: `i = 0 and then we turn left so i = i - 1 which gives i = -1, turning left when we are facing north results into west direction so to maintain the indexing we do the addition of 4.`\\n\\nSo, final expression becomes `i = (i-1 + 4)%4 = (i+3)%4`\\n\\nThe same thing happens when we turn right, turning right is clockwise so we do increment by 1\\n `i = (i+1)%4` we do a modulo here because after \\'W\\' we will again face \\'N\\' again.\\n\\n\\n**If the post helped you, then please consider up voting. Happy Coding :)**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n        vector<pair<int, int>> direction{{1, 2}, {3, 0}, {0, 3}, {2, 1}};\\n        vector<pair<int, int>> addPoints{{0, 1}, {-1, 0}, {1, 0}, {0, -1}};\\n        \\n        if(count(ins.begin(), ins.end(), \\'G\\') == 0) {\\n            return true;\\n        }\\n        \\n        int x = 0, y = 0;\\n        int dir = 0;\\n        for(int i=0; i<ins.size(); i++) {\\n            if(ins[i] == \\'G\\') {\\n                x += addPoints[dir].first;\\n                y += addPoints[dir].second;\\n            } else {\\n                dir = ins[i] == \\'L\\' ? direction[dir].first : direction[dir].second;\\n            }\\n        }\\n        \\n        if((dir != 0) || (x == 0 && y == 0)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n                \\n        int dir = 0;\\n        int x = 0, y = 0;\\n        for(int i=0; i<ins.size(); i++) {\\n            if(ins[i] == \\'G\\') {\\n                x += directions[dir][0];\\n                y += directions[dir][1];\\n            } else {\\n                dir = ins[i] == \\'L\\' ? (dir - 1 + 4)%4 : (dir +1)%4;\\n            }\\n        }\\n        \\n        return (dir != 0) || (x == 0 && y == 0);\\n    }\\n};\\n```\n```\\ni = (i+1) % 4 will turn right\\ni = (i+3) % 4 will turn left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678306,
                "title": "well-explained-linear-solution-1-loop-javascript-python-typescript-o-n-time-o-1-space",
                "content": "There are only two ways the robot can come back to its original location:\\n 1. The robot completed all the provided operations and made a loop in one iteration.\\n 2. The robot is not on the origin spot, but heading to any direction different from its initial direction (North). \\n  ***It can complete 1 or 3 additional iterations over the provided operations to make a loop.***\\n\\n\\tLet\\'s look at some examples to make it clear.\\n\\tI drew some paths the robot could face with and:\\n\\t* can make a loop in 4 iterations `\"GGRG\"`\\n\\t* can make a loop in 1 iteration (gets back to the origin) `\"GLGLGLG\"`\\n\\t  *You might see it heads to a different direction and will go through a different path on the next iteration, but it\\'s still a loop*\\n\\t * can make a loop in 2 iterations `\"GGRGR\"`\\n\\t * can\\'t make a loop `\"GGRGL\"`\\n\\n\\n\\t![image](https://assets.leetcode.com/users/images/e70ca499-df6e-4c69-a595-4c16874540ac_1641736376.2303495.png)\\n\\n\\t**Explanation**\\n\\t\\n\\t`x, y` is a set of coordinates\\n\\t`dirs` for all possible direction\\n\\t`[[0, 1], [1, 0], [0, -1], [-1, 0]]`\\n\\t` --^up  ---^right --^down --  ^left `\\n\\n\\t**We can change the direction by using mod operaor:**\\n\\t\\n\\t*On the left turn:*\\n\\t`currentDirectionIndex\\t= (4 + currentDirectionIndex - 1)  %  4`\\n\\t*On the right turn:*\\n\\t`currentDirectionIndex\\t= (4 + currentDirectionIndex + 1)  %  4`\\n\\t\\n\\t**Note that we have to add 4 to get a positive value (but we can simply omit this addition in python language)**\\n\\twhere 4 is the lenght of all possible directions array\\n\\tcurrentDirectionIndex has a default direction 0 (Up) and might take a value of 0, 1 ,2 or 3 (Up, Right, Down, Left respectively)\\n\\t\\n\\t**Complexity** \\n\\t\\n\\tTime `O(N)`\\n\\tSpace `O(1)`\\n\\t\\n\\n\\n\\t### \\tIf you have any doubts feel free to reach me down in the comments section or If you liked my explanation don\\'t forget to *upvote* \\uD83C\\uDF7B\\n\\n\\t\\n\\t**JavaScript**\\n\\t```\\n\\tfunction isRobotBounded(instructions) {\\n\\t\\tconst dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\tlet head = 0;\\n\\t\\tlet x = 0;\\n\\t\\tlet y = 0;\\n\\t\\t\\n\\t\\tfor (const instruction of instructions) { \\n\\t\\t\\tif (instruction === \\'G\\') {\\n\\t\\t\\t\\tx = x + dirs[head][0];\\n\\t\\t\\t\\ty = y + dirs[head][1];\\n\\t\\t\\t} else if (instruction === \\'L\\') {\\n\\t\\t\\t\\thead = (4 + head - 1) % 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thead = (4 + head + 1) % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst isAtOrigin = (x === 0 && y === 0);\\n\\t\\tconst isHeadingNorth = head === 0\\n\\n\\t\\treturn isAtOrigin || (! isHeadingNorth);\\n\\t};\\n\\t```\\n\\t\\n\\t**Python**\\n\\t```\\n\\tdef isRobotBounded(self, instructions):\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        x, y = 0,0\\n\\t\\thead = 0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x, y = x + dirs[head][0], y + dirs[head][1]\\n            elif instruction == \\'L\\':\\n                head =  (4 + head - 1) % 4\\n            else:\\n\\t\\t\\t\\thead =  (4 + head + 1) % 4\\n\\t\\t\\t\\t\\n\\t\\tisHeadingNorth = head == 0\\n\\t\\tisAtOrigin = (x == 0 and y == 0)\\n            \\n        return isAtOrigin or (not isHeadingNorth)\\n\\t```\\n\\t\\n\\t**TypeScript**\\n\\t```\\n\\tfunction isRobotBounded(instructions: string): boolean {\\n\\t\\tconst dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\tlet head = 0;\\n\\t\\tlet x = 0;\\n\\t\\tlet y = 0;\\n\\t\\t\\n\\t\\tfor (const instruction of instructions) { \\n\\t\\t\\tif (instruction === \\'G\\') {\\n\\t\\t\\t\\tx = x + dirs[head][0];\\n\\t\\t\\t\\ty = y + dirs[head][1];\\n\\t\\t\\t} else if (instruction === \\'L\\') {\\n\\t\\t\\t\\thead = (4 + head - 1) % 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thead = (4 + head + 1) % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst isAtOrigin = (x === 0 && y === 0);\\n\\t\\tconst isHeadingNorth = head === 0\\n\\n\\t\\treturn isAtOrigin || (! isHeadingNorth);\\n\\t};\\n\\t```\\n\\t\\n\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n\\tfunction isRobotBounded(instructions) {\\n\\t\\tconst dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\tlet head = 0;\\n\\t\\tlet x = 0;\\n\\t\\tlet y = 0;\\n\\t\\t\\n\\t\\tfor (const instruction of instructions) { \\n\\t\\t\\tif (instruction === \\'G\\') {\\n\\t\\t\\t\\tx = x + dirs[head][0];\\n\\t\\t\\t\\ty = y + dirs[head][1];\\n\\t\\t\\t} else if (instruction === \\'L\\') {\\n\\t\\t\\t\\thead = (4 + head - 1) % 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thead = (4 + head + 1) % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst isAtOrigin = (x === 0 && y === 0);\\n\\t\\tconst isHeadingNorth = head === 0\\n\\n\\t\\treturn isAtOrigin || (! isHeadingNorth);\\n\\t};\\n\\t```\n```\\n\\tdef isRobotBounded(self, instructions):\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        x, y = 0,0\\n\\t\\thead = 0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x, y = x + dirs[head][0], y + dirs[head][1]\\n            elif instruction == \\'L\\':\\n                head =  (4 + head - 1) % 4\\n            else:\\n\\t\\t\\t\\thead =  (4 + head + 1) % 4\\n\\t\\t\\t\\t\\n\\t\\tisHeadingNorth = head == 0\\n\\t\\tisAtOrigin = (x == 0 and y == 0)\\n            \\n        return isAtOrigin or (not isHeadingNorth)\\n\\t```\n```\\n\\tfunction isRobotBounded(instructions: string): boolean {\\n\\t\\tconst dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\tlet head = 0;\\n\\t\\tlet x = 0;\\n\\t\\tlet y = 0;\\n\\t\\t\\n\\t\\tfor (const instruction of instructions) { \\n\\t\\t\\tif (instruction === \\'G\\') {\\n\\t\\t\\t\\tx = x + dirs[head][0];\\n\\t\\t\\t\\ty = y + dirs[head][1];\\n\\t\\t\\t} else if (instruction === \\'L\\') {\\n\\t\\t\\t\\thead = (4 + head - 1) % 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thead = (4 + head + 1) % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst isAtOrigin = (x === 0 && y === 0);\\n\\t\\tconst isHeadingNorth = head === 0\\n\\n\\t\\treturn isAtOrigin || (! isHeadingNorth);\\n\\t};\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 853248,
                "title": "explained-in-detail-java-o-n-beats-100-0ms-runtime",
                "content": "Intution: \\n1) The robot faces north initially at coordinates (0,0). So after 1 iteration if you come back to the same coordinate (0,0) with direction as North then it will definitely form a loop. Example: GRGRGRGR.\\n\\n2) What if you came back to (0,0) but your position is not North, you\\'ll still come back to the initial coordinates after 4 iterations. Hence you\\'ll always be in a circle. For example in **GRGRGRG**, Since you\\'re always turning Right\\n\\n     i) You\\'ll face West after 1st iteration . \\n              (0,1) N, (1,1) E, (1,0) S, (0,0) W.\\n\\n    ii) You\\'ll face South after 2nd iteration.\\n\\t         (-1,0) W, (-1,1) N, (0,1) E, (0,0) S.\\n\\n    iii) You\\'ll face East after 3rd iteration.\\n              (0,-1) S, (-1,-1) W, (-1,0) N, (0,0) E.\\n\\n    iv) You\\'ll face North after 4th iteration.\\n             (1,0) E, (1,-1) S, (0,-1) W, (0,0) N.\\n\\n3) What if you don\\'t end up at (0,0) and you\\'re position is not North. You\\'ll still be inside the same circle since you\\'ll change direction after every iteration. For example if you end with direction left and face West , then in next iteration you\\'ll end at South, next East , next North and so on.\\n\\n\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n       int x=0, y=0, direction = 0;\\n\\n//          N 0\\n//     W 3       E 1\\n//          S 2\\n    \\n        \\n        for(char ch : instructions.toCharArray()){\\n            if(ch == \\'G\\'){         \\n                switch (direction){\\n                case 0: y++; break;\\n                case 1: x++; break;\\n                case 2: y--; break;\\n                case 3: x--; break;\\n                }\\n               \\n            }else if(ch == \\'L\\'){\\n                direction = direction == 0 ? 3 : (direction-1);\\n                \\n            }else if(ch == \\'R\\'){\\n                direction = (direction + 1)%4;\\n            }\\n        }\\n        if(direction!= 0 || (x == 0 && y == 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n       int x=0, y=0, direction = 0;\\n\\n//          N 0\\n//     W 3       E 1\\n//          S 2\\n    \\n        \\n        for(char ch : instructions.toCharArray()){\\n            if(ch == \\'G\\'){         \\n                switch (direction){\\n                case 0: y++; break;\\n                case 1: x++; break;\\n                case 2: y--; break;\\n                case 3: x--; break;\\n                }\\n               \\n            }else if(ch == \\'L\\'){\\n                direction = direction == 0 ? 3 : (direction-1);\\n                \\n            }else if(ch == \\'R\\'){\\n                direction = (direction + 1)%4;\\n            }\\n        }\\n        if(direction!= 0 || (x == 0 && y == 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229659,
                "title": "js-solution-w-explanation",
                "content": "```\\n/*\\nIf robot (1) comes back to origin OR (2) faces the north after instructions, the robot is in a circle.\\nTurn right -> i = (i + 1) mod 4, where DIRECTIONS[i] is the direction robot is facing\\nTurn left -> i = (i + 3) mod 4, DIRECTIONS[i] is the direction robot is facing\\n\\nKey points:\\n1. Don\\'t think about middle operations. Think about the start and the end only. We start at (0,0) and\\nend at (x,y). (a) If (x,y) is origin, we\\'ve come back to the origin. No matter where we end up facing, we\\'ll\\nalways come back to origin if we start at origin. (b) If (x,y) is not origin and robot is facing the north,\\nas we repeat instructions, robot will go to (2x,2y), (3x,3y) and so on. Hence, it is NOT in a circle. (c) If (x,y) is not origin and robot is facing a direction other than the north, it will come back to the origin. Why?\\nYou can draw yourself to better understand but the basic idea is if its starting direction and ending direction\\nare different, it will change its direction by the same amount each time instructions are executed. Hence, robot will eventually come back to the origin. In fact, it will be back in 4 times of instructions at most.\\n*/\\nvar isRobotBounded = function(instructions) { \\n    let x = 0, y = 0;\\n    // DIRECTIONS[i] = [x,y], from north to west\\n    let DIRECTIONS = [[0,1],[1,0],[0,-1],[-1,0]];\\n    let i = 0;\\n    for (let j = 0; j < instructions.length; j++) {\\n        if (instructions[j] === \"R\") {\\n            i = (i + 1) % 4;\\n        } else if (instructions[j] === \"L\") {\\n            i = (i + 3) % 4; \\n        } else {\\n            x += DIRECTIONS[i][0];\\n            y += DIRECTIONS[i][1];\\n        }\\n    }\\n    return (x === 0 && y === 0) || i > 0;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nIf robot (1) comes back to origin OR (2) faces the north after instructions, the robot is in a circle.\\nTurn right -> i = (i + 1) mod 4, where DIRECTIONS[i] is the direction robot is facing\\nTurn left -> i = (i + 3) mod 4, DIRECTIONS[i] is the direction robot is facing\\n\\nKey points:\\n1. Don\\'t think about middle operations. Think about the start and the end only. We start at (0,0) and\\nend at (x,y). (a) If (x,y) is origin, we\\'ve come back to the origin. No matter where we end up facing, we\\'ll\\nalways come back to origin if we start at origin. (b) If (x,y) is not origin and robot is facing the north,\\nas we repeat instructions, robot will go to (2x,2y), (3x,3y) and so on. Hence, it is NOT in a circle. (c) If (x,y) is not origin and robot is facing a direction other than the north, it will come back to the origin. Why?\\nYou can draw yourself to better understand but the basic idea is if its starting direction and ending direction\\nare different, it will change its direction by the same amount each time instructions are executed. Hence, robot will eventually come back to the origin. In fact, it will be back in 4 times of instructions at most.\\n*/\\nvar isRobotBounded = function(instructions) { \\n    let x = 0, y = 0;\\n    // DIRECTIONS[i] = [x,y], from north to west\\n    let DIRECTIONS = [[0,1],[1,0],[0,-1],[-1,0]];\\n    let i = 0;\\n    for (let j = 0; j < instructions.length; j++) {\\n        if (instructions[j] === \"R\") {\\n            i = (i + 1) % 4;\\n        } else if (instructions[j] === \"L\") {\\n            i = (i + 3) % 4; \\n        } else {\\n            x += DIRECTIONS[i][0];\\n            y += DIRECTIONS[i][1];\\n        }\\n    }\\n    return (x === 0 && y === 0) || i > 0;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850516,
                "title": "c-c-simple-clean-solution-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions)\\n    {\\n        vector position = {0, 0}, direction = {0, 1};\\n        \\n        for (size_t i = 0; i < instructions.length(); i++)\\n        {\\n            switch(instructions[i])\\n            {\\n                case \\'L\\':\\n                    direction = {-direction[1], direction[0]};\\n                    break;\\n                case \\'R\\':\\n                    direction = {direction[1], -direction[0]};\\n                    break;\\n                default:\\n                    position = {position[0] + direction[0], position[1] + direction[1]};\\n            }\\n        }\\n        return  (position[0] == 0 && position[1] == 0) || (direction[0] != 0 || direction[1] != 1) ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions)\\n    {\\n        vector position = {0, 0}, direction = {0, 1};\\n        \\n        for (size_t i = 0; i < instructions.length(); i++)\\n        {\\n            switch(instructions[i])\\n            {\\n                case \\'L\\':\\n                    direction = {-direction[1], direction[0]};\\n                    break;\\n                case \\'R\\':\\n                    direction = {direction[1], -direction[0]};\\n                    break;\\n                default:\\n                    position = {position[0] + direction[0], position[1] + direction[1]};\\n            }\\n        }\\n        return  (position[0] == 0 && position[1] == 0) || (direction[0] != 0 || direction[1] != 1) ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850890,
                "title": "java-solution",
                "content": "```\\npublic boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n\\t\\t//Keep track of directions\\n        String dir = \"North\";\\n    //     N\\n    // W<----->E\\n    //     S\\n\\t\\n\\t//Caluculate position\\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'G\\'){\\n                if(dir.equals(\"North\")){y++;}\\n                else if(dir.equals(\"East\")){x++;}\\n                else if(dir.equals(\"South\")){y--;}\\n                else {x--;}\\n            }\\n            else if(c == \\'L\\'){\\n                if(dir.equals(\"North\")){dir = \"West\";}\\n                else if(dir.equals(\"East\")){dir = \"North\";}\\n                else if(dir.equals(\"South\")){dir = \"East\";}\\n                else {dir = \"South\";}\\n            }\\n            else{\\n                if(dir.equals(\"North\")){dir = \"East\";}\\n                else if(dir.equals(\"East\")){dir = \"South\";}\\n                else if(dir.equals(\"South\")){dir = \"West\";}\\n                else {dir = \"North\";}\\n            }\\n        }\\n        //Check if calutucated position is starting position\\n        if(x == 0 && y == 0){\\n            return true;\\n        }\\n\\t\\t//check if the final faced direction is not North(Strarting DIrection)\\n        if(dir.equals(\"North\")){\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n\\t\\t//Keep track of directions\\n        String dir = \"North\";\\n    //     N\\n    // W<----->E\\n    //     S\\n\\t\\n\\t//Caluculate position\\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'G\\'){\\n                if(dir.equals(\"North\")){y++;}\\n                else if(dir.equals(\"East\")){x++;}\\n                else if(dir.equals(\"South\")){y--;}\\n                else {x--;}\\n            }\\n            else if(c == \\'L\\'){\\n                if(dir.equals(\"North\")){dir = \"West\";}\\n                else if(dir.equals(\"East\")){dir = \"North\";}\\n                else if(dir.equals(\"South\")){dir = \"East\";}\\n                else {dir = \"South\";}\\n            }\\n            else{\\n                if(dir.equals(\"North\")){dir = \"East\";}\\n                else if(dir.equals(\"East\")){dir = \"South\";}\\n                else if(dir.equals(\"South\")){dir = \"West\";}\\n                else {dir = \"North\";}\\n            }\\n        }\\n        //Check if calutucated position is starting position\\n        if(x == 0 && y == 0){\\n            return true;\\n        }\\n\\t\\t//check if the final faced direction is not North(Strarting DIrection)\\n        if(dir.equals(\"North\")){\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850801,
                "title": "swift-solution-clean-concise",
                "content": "**Approach**\\nRepresent the direction using an `(x, y)` coordinate. For example \\n- `(0, 1)` represents facing up \\n- `(1, 0)` represents facing right\\n- `(0, -1)` represents facing down \\n- `(-1, 0)` represents facing left\\n\\nThen changing direction is easy \\n- To go right, swap the coordinates and negate the `y` coordinate \\n- To go left, swap the coordinates and negate the `x` coordinate\\n\\n**Solution**\\n```swift\\nfunc isRobotBounded(_ instructions: String) -> Bool {\\n\\tvar pos = (0, 0) \\n\\tvar dir = (0, 1) \\n\\n\\tfor cmd in instructions {\\n\\t\\tswitch cmd {\\n\\t\\tcase \"G\":\\n\\t\\t\\tpos.0 += dir.0 \\n\\t\\t\\tpos.1 += dir.1 \\n\\t\\tcase \"L\": \\n\\t\\t\\tdir = (-dir.1, dir.0)\\n\\t\\tcase \"R\":\\n\\t\\t\\tdir = (dir.1, -dir.0)\\n\\t\\tdefault:\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn (dir != (0, 1)) || (pos == (0, 0))\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc isRobotBounded(_ instructions: String) -> Bool {\\n\\tvar pos = (0, 0) \\n\\tvar dir = (0, 1) \\n\\n\\tfor cmd in instructions {\\n\\t\\tswitch cmd {\\n\\t\\tcase \"G\":\\n\\t\\t\\tpos.0 += dir.0 \\n\\t\\t\\tpos.1 += dir.1 \\n\\t\\tcase \"L\": \\n\\t\\t\\tdir = (-dir.1, dir.0)\\n\\t\\tcase \"R\":\\n\\t\\t\\tdir = (dir.1, -dir.0)\\n\\t\\tdefault:\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn (dir != (0, 1)) || (pos == (0, 0))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677844,
                "title": "c-python-simple-and-short-solution-explained-0ms-faster-than-100",
                "content": "**Idea:**\\nWe initialize position to 0,0 and direction to north.\\n\\n**Example - going left:**\\n* if pos is [1,1], direction is [0,1] we want to go left - we have to add to pos [-1,0] (left in graph)\\n* if pos is [1,1], direction is [-1,0] we want to go left - we have to add to pos [0,-1] (down in graph)\\n* if pos is [1,1], direction is [0,-1] we want to go left - we have to add to pos [1,0] (right in graph)\\n        \\nThat calculation brings us to the conclusion that for going left we change the direction [x,y] to [-y,x]\\nand for going right we change the direction [x,y] to [y,-x]\\n\\nIf position got back to original, or we changed original direction, the answer is True.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        pair<int, int> pos = {0, 0}, dir = {0, 1};\\n        \\n        for (auto instruct : instructions) {\\n            if (instruct == \\'L\\')\\n                dir = {-dir.second, dir.first};\\n\\n            else if (instruct == \\'R\\')\\n                dir = {dir.second, -dir.first};\\n\\n            else\\n                pos = {pos.first + dir.first, pos.second + dir.second};\\n        }\\n\\n        return ((pos.first == 0 && pos.second == 0) || (dir.first != 0 || dir.second != 1));\\n    }\\n};\\n```\\n****\\n**Python:**\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        pos = [0,0]\\n        direc = [0,1]\\n\\t\\t\\n        for instruct in instructions:\\n            if instruct == \"L\":\\n                direc[0], direc[1] = -direc[1], direc[0]\\n            elif instruct == \"R\":\\n                direc[0], direc[1] = direc[1], -direc[0]\\n            else:\\n                pos[0], pos[1] = pos[0]+direc[0], pos[1]+direc[1]\\n\\n        return pos == [0,0] or direc != [0,1]\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        pair<int, int> pos = {0, 0}, dir = {0, 1};\\n        \\n        for (auto instruct : instructions) {\\n            if (instruct == \\'L\\')\\n                dir = {-dir.second, dir.first};\\n\\n            else if (instruct == \\'R\\')\\n                dir = {dir.second, -dir.first};\\n\\n            else\\n                pos = {pos.first + dir.first, pos.second + dir.second};\\n        }\\n\\n        return ((pos.first == 0 && pos.second == 0) || (dir.first != 0 || dir.second != 1));\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        pos = [0,0]\\n        direc = [0,1]\\n\\t\\t\\n        for instruct in instructions:\\n            if instruct == \"L\":\\n                direc[0], direc[1] = -direc[1], direc[0]\\n            elif instruct == \"R\":\\n                direc[0], direc[1] = direc[1], -direc[0]\\n            else:\\n                pos[0], pos[1] = pos[0]+direc[0], pos[1]+direc[1]\\n\\n        return pos == [0,0] or direc != [0,1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161778,
                "title": "straightforward-o-n-time-beats-95-python-solution-without-thinking-too-much-about-rotations",
                "content": "Many solutions used the fact that if the character in the string is an \"L\", you can do something like `di = (-di[1],di[0])` , however, in an interview setting it may be a little difficult to intuitively come up with this. So, what I did differently is to think about every case in which you can be pointing in a certain direction (given where you are currently looking at and if you will be turning left/right)\\n\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        curr_pos = [0, 0]\\n        curr_dir = \"N\"\\n        directions = {\"N\": (0, 1), \"S\": (0, -1), \"W\": (-1, 0), \"E\": (1, 0)}\\n\\n        # Calculate the final vector of how the robot travels after executing all instructions once - it consists of a change in position plus a change in direction.\\n        for char in instructions:\\n            if char == \"G\":\\n                curr_pos[0] += directions[curr_dir][0]\\n                curr_pos[1] += directions[curr_dir][1]\\n            elif (curr_dir == \"N\" and char == \"L\") or (curr_dir == \"S\" and char == \"R\"):\\n                curr_dir = \"W\"\\n            elif (curr_dir == \"W\" and char == \"L\") or (curr_dir == \"E\" and char == \"R\"):\\n                curr_dir = \"S\"\\n            elif (curr_dir == \"S\" and char == \"L\") or (curr_dir == \"N\" and char == \"R\"):\\n                curr_dir = \"E\"\\n            elif (curr_dir == \"E\" and char == \"L\") or (curr_dir == \"W\" and char == \"R\"):\\n                curr_dir = \"N\"\\n        \\n        # The robot stays in the circle iff (looking at the final vector) it changes direction (ie. doesn\\'t stay pointing north), or it moves 0.``\\n        return curr_dir != \"N\" or curr_pos == [0, 0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Many solutions used the fact that if the character in the string is an \"L\", you can do something like `di = (-di[1],di[0])` , however, in an interview setting it may be a little difficult to intuitively come up with this. So, what I did differently is to think about every case in which you can be pointing in a certain direction (given where you are currently looking at and if you will be turning left/right)\\n\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        curr_pos = [0, 0]\\n        curr_dir = \"N\"\\n        directions = {\"N\": (0, 1), \"S\": (0, -1), \"W\": (-1, 0), \"E\": (1, 0)}\\n\\n        # Calculate the final vector of how the robot travels after executing all instructions once - it consists of a change in position plus a change in direction.\\n        for char in instructions:\\n            if char == \"G\":\\n                curr_pos[0] += directions[curr_dir][0]\\n                curr_pos[1] += directions[curr_dir][1]\\n            elif (curr_dir == \"N\" and char == \"L\") or (curr_dir == \"S\" and char == \"R\"):\\n                curr_dir = \"W\"\\n            elif (curr_dir == \"W\" and char == \"L\") or (curr_dir == \"E\" and char == \"R\"):\\n                curr_dir = \"S\"\\n            elif (curr_dir == \"S\" and char == \"L\") or (curr_dir == \"N\" and char == \"R\"):\\n                curr_dir = \"E\"\\n            elif (curr_dir == \"E\" and char == \"L\") or (curr_dir == \"W\" and char == \"R\"):\\n                curr_dir = \"N\"\\n        \\n        # The robot stays in the circle iff (looking at the final vector) it changes direction (ie. doesn\\'t stay pointing north), or it moves 0.``\\n        return curr_dir != \"N\" or curr_pos == [0, 0]",
                "codeTag": "Python3"
            },
            {
                "id": 1130234,
                "title": "c-each-line-commented-clearly",
                "content": "` I also did not know the solution, but they were so poorly written that I have to understand it and then I wrote it in the easiest way possible after getting a proper understanding`\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string s) {\\n        int x=0,y=0,i=0;\\n        // x and y are the co-ordinates and i=0 is the current direction which is North.\\n        vector<vector<int>> dir={{0,1},{1,0},{0,-1},{-1,0}}; // N,E,S,W\\n        // dir vector is a 2d vector which stoes all directions Cordinates \\n        \\n        int n=s.length();\\n        for(int j=0;j<n;j++) {\\n            switch(s[j]) {\\n                case \\'G\\':  // Go 1 unit forward\\n                    x+=dir[i][0]; // pick the x part in whichever direction our robot is ponting\\n                    y+=dir[i][1]; // pick the y part in whichever direction our robot is ponting\\n                    break;\\n                case \\'L\\': // If we have to turn left\\n                    i=(i+3)%4; //left is West, which is 3 units in clockwise direction, so just turn left from your current facing position which is my current i value and we did %4 because we are moving in those direction given in the input array infinitely, so %4 basically gives you the correct index between 0 and last index.\\n                    break;\\n                case \\'R\\':\\n                    i=(i+1)%4; //Right is east, which is 1 units in clockwise direction, so just turn right from your current facing position which is my current i value\\n                    break;\\n            }\\n        }\\n        \\n        if((x==0 && y==0) || i != 0) return true; // either we returned to origin OR we are not facing North, which was 0\\n        return false;\\n    }\\n};\\n```\\n\\n```\\nTime Complexity: O(4*N) because in worst case, we have to access the array 4 times, to complete the circle.\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string s) {\\n        int x=0,y=0,i=0;\\n        // x and y are the co-ordinates and i=0 is the current direction which is North.\\n        vector<vector<int>> dir={{0,1},{1,0},{0,-1},{-1,0}}; // N,E,S,W\\n        // dir vector is a 2d vector which stoes all directions Cordinates \\n        \\n        int n=s.length();\\n        for(int j=0;j<n;j++) {\\n            switch(s[j]) {\\n                case \\'G\\':  // Go 1 unit forward\\n                    x+=dir[i][0]; // pick the x part in whichever direction our robot is ponting\\n                    y+=dir[i][1]; // pick the y part in whichever direction our robot is ponting\\n                    break;\\n                case \\'L\\': // If we have to turn left\\n                    i=(i+3)%4; //left is West, which is 3 units in clockwise direction, so just turn left from your current facing position which is my current i value and we did %4 because we are moving in those direction given in the input array infinitely, so %4 basically gives you the correct index between 0 and last index.\\n                    break;\\n                case \\'R\\':\\n                    i=(i+1)%4; //Right is east, which is 1 units in clockwise direction, so just turn right from your current facing position which is my current i value\\n                    break;\\n            }\\n        }\\n        \\n        if((x==0 && y==0) || i != 0) return true; // either we returned to origin OR we are not facing North, which was 0\\n        return false;\\n    }\\n};\\n```\n```\\nTime Complexity: O(4*N) because in worst case, we have to access the array 4 times, to complete the circle.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851445,
                "title": "java-robot-bounded-in-circle",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        char direction=\\'N\\';\\n        \\n        int x=0;\\n        int y=0;\\n        \\n        for(char ch: instructions.toCharArray()){\\n            \\n            if(ch==\\'G\\'){\\n                \\n                if(direction==\\'N\\')  y++; \\n                else if(direction==\\'S\\')  y--; \\n                else if(direction==\\'E\\')  x++; \\n                else if(direction==\\'W\\')  x--; \\n            }\\n            else if(ch==\\'L\\'){\\n                \\n                if(direction==\\'N\\')  direction=\\'W\\'; \\n                else if(direction==\\'S\\')  direction=\\'E\\'; \\n                else if(direction==\\'E\\')  direction=\\'N\\'; \\n                else if(direction==\\'W\\')  direction=\\'S\\'; \\n            }\\n            else if(ch==\\'R\\'){\\n                \\n                if(direction==\\'N\\')  direction=\\'E\\'; \\n                else if(direction==\\'S\\')  direction=\\'W\\'; \\n                else if(direction==\\'E\\')  direction=\\'S\\'; \\n                else if(direction==\\'W\\')  direction=\\'N\\'; \\n            }\\n        }\\n        \\n        if(direction!=\\'N\\' || x==0 && y==0) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        char direction=\\'N\\';\\n        \\n        int x=0;\\n        int y=0;\\n        \\n        for(char ch: instructions.toCharArray()){\\n            \\n            if(ch==\\'G\\'){\\n                \\n                if(direction==\\'N\\')  y++; \\n                else if(direction==\\'S\\')  y--; \\n                else if(direction==\\'E\\')  x++; \\n                else if(direction==\\'W\\')  x--; \\n            }\\n            else if(ch==\\'L\\'){\\n                \\n                if(direction==\\'N\\')  direction=\\'W\\'; \\n                else if(direction==\\'S\\')  direction=\\'E\\'; \\n                else if(direction==\\'E\\')  direction=\\'N\\'; \\n                else if(direction==\\'W\\')  direction=\\'S\\'; \\n            }\\n            else if(ch==\\'R\\'){\\n                \\n                if(direction==\\'N\\')  direction=\\'E\\'; \\n                else if(direction==\\'S\\')  direction=\\'W\\'; \\n                else if(direction==\\'E\\')  direction=\\'S\\'; \\n                else if(direction==\\'W\\')  direction=\\'N\\'; \\n            }\\n        }\\n        \\n        if(direction!=\\'N\\' || x==0 && y==0) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850862,
                "title": "c-solution-using-complex-numbers",
                "content": "**Explanation of strategy:**\\n\\nEach time the instruction sequence is executed, the robot ends up at some location, having altered its orientation. The interesting fact we can use here is, the robot rotates by the same angle after each execution of the instruction, so after 4 repetitions of the instruction sequence, the robot will ALWAYS be facing the same direction it started with. (To see this, picture how rotating left, right, or 180 degrees four times in a row will end up facing in the original direction.) If we want it to stay confined in a certain region, the location of the robot after 4 instructions should also match the location where it started (the origin), otherwise it will continue to move away in the original direction, infinitely far away from the origin.\\n\\nTo actually implement this, we can make use of complex number mathematics. The complex number \\'1j\\' represents a rotation of 90 degrees counter-clockwise on the complex plane, while \\'-1j\\' rotates clockwise; we can use these facts to easily simulate rotating the robot left or right. Since complex numbers add component-wise just like vectors, we can add the direction of the robot to its position when going straight. We loop over the instruction string 4 times, and after we\\'re done, we compare the position of the robot to the origin (where it started). Note that the original direction of the robot doesn\\'t matter here, but I just initialized it as \\'1j\\' to represent that the robot started moving north.\\n\\n**Accompanying code:**\\n\\n```\\nclass Solution {\\n    public:\\n        bool isRobotBounded(string instructions) {\\n            complex<float> p=0, o=0, d = 1j, L = 1j; // p = position, o = origin, d = direction, L = \"turn left\"\\n            for (int it=0;it<4;it++)                 // Loop 4 times\\n                for (char c : instructions)          // Loop over each character in the instructions string\\n                    if (c==\\'L\\') d *= L;              // Multiplying by 1j \"rotates\" the robot counter-clockwise\\n                    else if (c==\\'R\\') d *= (-L);      // Multiplying by -1j \"rotates\" the robot\\'s direction clockwise\\n                    else if (c==\\'G\\') p += d;         // Adding the direction complex number to the current position\\n            return p == o;                           // If it\\'s still at the origin after 4 iterations, we\\'ve found a cycle\\n        }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isRobotBounded(string instructions) {\\n            complex<float> p=0, o=0, d = 1j, L = 1j; // p = position, o = origin, d = direction, L = \"turn left\"\\n            for (int it=0;it<4;it++)                 // Loop 4 times\\n                for (char c : instructions)          // Loop over each character in the instructions string\\n                    if (c==\\'L\\') d *= L;              // Multiplying by 1j \"rotates\" the robot counter-clockwise\\n                    else if (c==\\'R\\') d *= (-L);      // Multiplying by -1j \"rotates\" the robot\\'s direction clockwise\\n                    else if (c==\\'G\\') p += d;         // Adding the direction complex number to the current position\\n            return p == o;                           // If it\\'s still at the origin after 4 iterations, we\\'ve found a cycle\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 712970,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        short x=0,y=0,dir=0;\\n        for(auto c : instructions)\\n        {  \\n            if (c==\\'G\\')\\n            {\\n                //down:0, left:1, up:2, right:3\\n                if (dir == 0) y+=1;\\n                else if (dir == 1) x-=1;\\n                else if (dir == 2) y-=1;\\n                else x+=1;\\n            }\\n            else if (c==\\'R\\')\\n                dir++;\\n            else\\n                dir--;\\n            dir&=0x3;\\n        }\\n        return ((x==0 && y==0) || dir != 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        short x=0,y=0,dir=0;\\n        for(auto c : instructions)\\n        {  \\n            if (c==\\'G\\')\\n            {\\n                //down:0, left:1, up:2, right:3\\n                if (dir == 0) y+=1;\\n                else if (dir == 1) x-=1;\\n                else if (dir == 2) y-=1;\\n                else x+=1;\\n            }\\n            else if (c==\\'R\\')\\n                dir++;\\n            else\\n                dir--;\\n            dir&=0x3;\\n        }\\n        return ((x==0 && y==0) || dir != 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291382,
                "title": "javascript-60-ms-solution-o-n",
                "content": "```\\nvar isRobotBounded = function(instructions) {\\n    let steps = [\\n        [-1,0],\\n        [0,1],\\n        [1,0],\\n        [0,-1]\\n    ];\\n    let x = y = 0;\\n    \\n    let currStep = 1;\\n    let turn = (direction) =>{\\n        if(direction === \"L\") currStep--;\\n        else if(direction === \"R\") currStep++;\\n        else if(direction === \"G\") {\\n            x += steps[currStep][0];\\n            y += steps[currStep][1];\\n        }\\n        if(currStep < 0) currStep = 3;\\n        if(currStep === 4) currStep = 0;\\n    }\\n    \\n    \\n    for(let i=0; i<instructions.length*4; i++){\\n        turn(instructions[i]);\\n    }\\n\\t// I was stucked at the last return. The following line might be the key line for this problem.\\n\\t// as lone as the robot is at (0,0) or not going north, it should be true.\\n    return (currStep !== 1) || (x ===0 && y===0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isRobotBounded = function(instructions) {\\n    let steps = [\\n        [-1,0],\\n        [0,1],\\n        [1,0],\\n        [0,-1]\\n    ];\\n    let x = y = 0;\\n    \\n    let currStep = 1;\\n    let turn = (direction) =>{\\n        if(direction === \"L\") currStep--;\\n        else if(direction === \"R\") currStep++;\\n        else if(direction === \"G\") {\\n            x += steps[currStep][0];\\n            y += steps[currStep][1];\\n        }\\n        if(currStep < 0) currStep = 3;\\n        if(currStep === 4) currStep = 0;\\n    }\\n    \\n    \\n    for(let i=0; i<instructions.length*4; i++){\\n        turn(instructions[i]);\\n    }\\n\\t// I was stucked at the last return. The following line might be the key line for this problem.\\n\\t// as lone as the robot is at (0,0) or not going north, it should be true.\\n    return (currStep !== 1) || (x ===0 && y===0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3672987,
                "title": "python-solution-pretty-intuitive",
                "content": "My first time posting a solution on Leetcode and I think the solution was unique so really proud of it.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of sorry for bad English.\\nPretty Intuitive Solution.\\nTook help from the hint given for the question to check if the circle is forming or not.\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        initial_pos = curr_pos = [0, 0]\\n        directions = {\\n            \\'N\\': [0, 1],\\n            \\'S\\': [0, -1],\\n            \\'E\\': [1, 0],\\n            \\'W\\': [-1, 0]\\n        }\\n        nesw = [\\'N\\', \\'E\\', \\'S\\', \\'W\\']\\n        dir = \\'N\\'\\n        for i in range(len(instructions)):\\n            if instructions[i] == \\'G\\':\\n                curr_pos = [x + y for x, y in zip(curr_pos, directions[dir])]\\n            elif instructions[i] == \\'L\\':\\n                dir = nesw[(nesw.index(dir) - 1) % len(nesw)]\\n            elif instructions[i] == \\'R\\':\\n                dir = nesw[(nesw.index(dir) + 1) % len(nesw)]\\n        return initial_pos == curr_pos or dir != \\'N\\'\\n```\\nUpvote pls thx.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        initial_pos = curr_pos = [0, 0]\\n        directions = {\\n            \\'N\\': [0, 1],\\n            \\'S\\': [0, -1],\\n            \\'E\\': [1, 0],\\n            \\'W\\': [-1, 0]\\n        }\\n        nesw = [\\'N\\', \\'E\\', \\'S\\', \\'W\\']\\n        dir = \\'N\\'\\n        for i in range(len(instructions)):\\n            if instructions[i] == \\'G\\':\\n                curr_pos = [x + y for x, y in zip(curr_pos, directions[dir])]\\n            elif instructions[i] == \\'L\\':\\n                dir = nesw[(nesw.index(dir) - 1) % len(nesw)]\\n            elif instructions[i] == \\'R\\':\\n                dir = nesw[(nesw.index(dir) + 1) % len(nesw)]\\n        return initial_pos == curr_pos or dir != \\'N\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676693,
                "title": "python3-simple-4-loops-o-n-time-o-1-space",
                "content": "The idea is to think of the the result of 1 iteration through the instructions, instead of zooming in to every little detail. At every loop, the total rotation will be similar. Example: If the robot turns 90 degrees the first iteration, it will keep turning 90 degrees at future iterations. This implies that the robot will look North within at most 4 iterations. When that happens, we can compare the current position to the robot\\'s initial position (0, 0), and then return true if they are equal, and false otherwise.\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x = y = 0\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        i = 0\\n        while True:\\n            for do in instructions:\\n                if do == \\'G\\':\\n                    x += directions[i][0]\\n                    y += directions[i][1]\\n                elif do == \\'R\\':\\n                    i = (i + 1) % 4\\n                else:\\n                    i = (i - 1) % 4\\n                    \\n            if i == 0:\\n                return x == 0 and y == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x = y = 0\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        i = 0\\n        while True:\\n            for do in instructions:\\n                if do == \\'G\\':\\n                    x += directions[i][0]\\n                    y += directions[i][1]\\n                elif do == \\'R\\':\\n                    i = (i + 1) % 4\\n                else:\\n                    i = (i - 1) % 4\\n                    \\n            if i == 0:\\n                return x == 0 and y == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112624,
                "title": "golang-faster-than-100-solution-with-explanation-and-images",
                "content": "**What the problem is asking:**\\n\\nThe problem says that it will give a string with the letters ` \"L\", \"R\"` and `\"G\"` to command a robot. `\"L\"` means to turn left 90 degrees, `\"R\"` means to turn right 90 degrees, and `\"G\"` means to go forward one unit. The problem says to return `true` if the robot can continue in that pattern forever and keep going in a circle. This can be shown with the following example:\\n\\n```\\ninput := \"GL\"\\nexpected output := true\\n```\\n\\nI have depicted how this example works with the following picture:\\n\\n![image](https://assets.leetcode.com/users/images/1855d28f-e9d3-4d48-b4cb-8dd094856b18_1615912827.6652634.jpeg)\\n\\n\\n\\n> * In the first image, we start off at the point `(0, 0)`\\n> * In the second image, we do the input `\"GL\"`, we go up one unit and then turn left, *(I have put a dotted line with an arrow to signify that we are going left in the next move)*\\n> * In the following image, we do the `\"GL\"` again.\\n> * In the fourth image, we do `\"GL\"` again.\\n> * In the fifth image, we have finished the circle by doing `\"GL\"` again.\\n> * And in the sixth image, we can see that this keeps on repeating.\\n>\\n> I have not added anymore because I think it is pretty self-explanatory\\n\\n**What my code is doing:**\\n\\nWe use the variables `x, y\\' and `degree`. `x` and `y` signify where the current position is. And `degree` is what angle you are pointing at. We use `4` numbers to signify this:\\n\\n* `degree = 0` means pointing up\\n* `degree = 1` means pointing right\\n* `degree = 2` means pointing down\\n* `degree = 3` means pointing left\\n\\nNext, we have to know when to add and subtract from `x` and `y\\'.\\n\\n* If `degree == 0 && letter == \\'G\\'` then add one to `y`\\n* If `degree == 1 && letter == \\'G\\'` then add one to `x`\\n* If `degree == 2 && letter == \\'G\\'` then subtract one to `y`\\n* If `degree == 3 && letter == \\'G\\'` then subtract one to `x`\\n\\nThen to check whether `return true || return false`. We can see that if the robot returns to the origin at its last move, it has to be going in a circle, and if it is not facing `up` we know that it will make a circle after some time. If you don\\'t understand the part of not facing up, look at the image below.\\n\\n![image](https://assets.leetcode.com/users/images/01643d29-a9f7-43c2-9ec1-847c85dd5c05_1615912841.1667998.jpeg)\\n\\n\\n> This is the same example as the example above `input := \"GL\"`, when we go through the string we get the image above, as we saw in the last instance, if we continue to make this pattern, we get a circle so as return `true` for this. \\n>\\n> You can try this with an example. It will be `true` for any degree that is not facing up.\\n\\n\\n**The Code:**\\n\\n``` go\\nfunc isRobotBounded(instructions string) bool {\\n    x, y, degree := 0, 0, 0\\n\\n    for _, i := range instructions {\\n        if i == \\'R\\' {\\n            degree = (degree + 1) % 4\\n            continue\\n        } else if i == \\'L\\' {\\n            degree = (degree + 3) % 4\\n            continue\\n        } \\n\\n        switch degree {\\n        case 0:\\n            y++\\n        case 1:\\n            x++\\n        case 2:\\n            y--\\n        case 3:\\n            x--\\n        }\\n    }\\n    return x == 0 && y == 0 || degree != 0\\n}\\n```\\n\\n**We can take out the switch case and make the code:**\\n\\n``` go\\nfunc isRobotBounded(instructions string) bool {\\n    x, y, degree := 0, 0, 0\\n    addSubtractXAndY := []int{1, 1, -1, -1}\\n\\n    for _, i := range instructions {\\n        if i == \\'R\\' {\\n            degree = (degree + 1) % 4\\n        } else if i == \\'L\\' {\\n            degree = (degree + 3) % 4\\n        } else {\\n            if degree == 0 || degree == 2 {\\n                y += addSubtractXAndY[degree]\\n            } else {\\n                x += addSubtractXAndY[degree]\\n            }\\n        }\\n    }\\n    return x == 0 && y == 0 || degree != 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ninput := \"GL\"\\nexpected output := true\\n```\n``` go\\nfunc isRobotBounded(instructions string) bool {\\n    x, y, degree := 0, 0, 0\\n\\n    for _, i := range instructions {\\n        if i == \\'R\\' {\\n            degree = (degree + 1) % 4\\n            continue\\n        } else if i == \\'L\\' {\\n            degree = (degree + 3) % 4\\n            continue\\n        } \\n\\n        switch degree {\\n        case 0:\\n            y++\\n        case 1:\\n            x++\\n        case 2:\\n            y--\\n        case 3:\\n            x--\\n        }\\n    }\\n    return x == 0 && y == 0 || degree != 0\\n}\\n```\n``` go\\nfunc isRobotBounded(instructions string) bool {\\n    x, y, degree := 0, 0, 0\\n    addSubtractXAndY := []int{1, 1, -1, -1}\\n\\n    for _, i := range instructions {\\n        if i == \\'R\\' {\\n            degree = (degree + 1) % 4\\n        } else if i == \\'L\\' {\\n            degree = (degree + 3) % 4\\n        } else {\\n            if degree == 0 || degree == 2 {\\n                y += addSubtractXAndY[degree]\\n            } else {\\n                x += addSubtractXAndY[degree]\\n            }\\n        }\\n    }\\n    return x == 0 && y == 0 || degree != 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276579,
                "title": "shortest-solution-c-100-faster",
                "content": "C++ Solution for the given problem. The code has been split block wise for better understanding.\\n\\nQUESTION : The problem wants us to return \\'TRUE\\' if it is possible to find a circle such that the circle always bounds the robot\\'s postions otherwise wants us to return \\'FALSE\\'\\n\\nLOGIC : If we try to visualise the situation with a pen and paper we observe that the condition required by the problem can only be achieved, if after executing the segment of instructions once or more number of times we are able to return to origin. \\n\\nTARGET : We need to check whether it is possible to return to origin by executing the given segment of instructions by some number of times.\\n\\nEXPLANATION :\\n\\n1. This block has variables indicating position of the robot after following some given instructions\\n2. This block has the variables indicating the direction in which robot is facing (x, y) = (0, 1) -> positive y or north direction. similarily (1, 0) -> positive x or east direction, (0, -1) -> negative y or south direction and (-1, 0) -> negative x or west direction.\\n3. (I\\'ll discuss in the end)\\n4. for each \\'G\\' we get we are incrementing (or decrementing) x (or y) since because of our choice exactly one of them will have a non-zero value the other of dx or dy will be zero.\\n5. as far as this is concerned you can see if we are facing north and we turn left we start looking west imply (0, 1) -> (-1, 0)->(0, -1) ->(1, 0) you can see this is captured in the operations that we are doing (this is a sleek way of writing the code it just hit me)\\n6. This is same as part 5 just for right turns.\\n7. if after all the operations of one segment of instructions I remain at the origin ( x==0 and y==0) then this case returns a true.\\n\\nbut here we have considered only the case in which we reach at origin after one segment of instructions, but is there a case where one segment might not reach at origin but multiple such segments may.... well it seems there are such cases (for example \"GL\") but there is a slight observation that any such case which satisfy the condition will have(must have) to satisfy it for segment of instructions applied 4 times hence this is being managed in point no. 3. in which I\\'m doubling the segment of instructions twice making it 4 times. \\n\\nThis concludes the explanation for the question, I hope you found it useful :)\\n\\n\\n\\n\\n\\n\\t\\'\\'\\'\\n\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n    \\n    bool isRobotBounded(string ins) {\\n        \\n        int y = 0;  // block 1\\n        int x = 0; \\n        \\n        int dy = 1;  // block 2\\n        int dx = 0; \\n        \\n        ins+=ins;  // block 3\\n        ins+=ins; \\n        \\n        for(int i=0; i<ins.size(); i++){\\n            \\n            if(ins[i]==\\'G\\') { // block 4\\n                y+=dy; x+=dx;\\n            } \\n            else if(ins[i]==\\'L\\'){ // block 5\\n                swap(dx, dy);\\n                dx*=-1;\\n            } \\n            else{ // block 6\\n                swap(dx, dy);\\n                dy*=-1;\\n            }\\n            \\n        }\\n        \\n        \\n\\t\\t\\tif(y==0 and x==0) return true; // block 7\\n\\t\\t\\telse return false;\\n\\t\\t}\\n\\t};\\n\\t\\n\\n\\' \\' \\'",
                "solutionTags": [
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n    \\n    bool isRobotBounded(string ins) {\\n        \\n        int y = 0;  // block 1\\n        int x = 0; \\n        \\n        int dy = 1;  // block 2\\n        int dx = 0; \\n        \\n        ins+=ins;  // block 3\\n        ins+=ins; \\n        \\n        for(int i=0; i<ins.size(); i++){\\n            \\n            if(ins[i]==\\'G\\') { // block 4\\n                y+=dy; x+=dx;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1076689,
                "title": "javascript-with-dx-dy",
                "content": "```\\nRuntime: 76 ms, faster than 87.40% of JavaScript online submissions for Robot Bounded In Circle.\\nMemory Usage: 38.6 MB, less than 68.90% of JavaScript online submissions for Robot Bounded In Circle.\\n```\\n```\\nvar isRobotBounded = function(instructions) {\\n    let x = 0;\\n    let y = 0;\\n    let dx = 0;\\n    let dy = 1;\\n\\n    for (let direction of instructions) {\\n        if (direction === \"R\") {\\n            let temp = dx;\\n            dx = dy;\\n            dy = -temp;\\n        } else if (direction === \"L\") {\\n            let temp = dy;\\n            dy = dx;\\n            dx = -temp;\\n        } else {\\n            x = x + dx;\\n            y = y + dy;\\n        }\\n    }\\n    return (!x && !y) || dy !== 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nRuntime: 76 ms, faster than 87.40% of JavaScript online submissions for Robot Bounded In Circle.\\nMemory Usage: 38.6 MB, less than 68.90% of JavaScript online submissions for Robot Bounded In Circle.\\n```\n```\\nvar isRobotBounded = function(instructions) {\\n    let x = 0;\\n    let y = 0;\\n    let dx = 0;\\n    let dy = 1;\\n\\n    for (let direction of instructions) {\\n        if (direction === \"R\") {\\n            let temp = dx;\\n            dx = dy;\\n            dy = -temp;\\n        } else if (direction === \"L\") {\\n            let temp = dy;\\n            dy = dx;\\n            dx = -temp;\\n        } else {\\n            x = x + dx;\\n            y = y + dy;\\n        }\\n    }\\n    return (!x && !y) || dy !== 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850825,
                "title": "99-better-javascript-solution",
                "content": "```\\nvar isRobotBounded = function(instructions) {\\n    const DIRECTION = { \"N\": [0,1], \"S\": [0,-1], \"E\": [1,0], \"W\": [-1,0] };\\n    const LEFT = { \"N\" : \"W\",  \"W\" : \"S\", \"S\" : \"E\", \"E\" : \"N\" };\\n    const RIGHT = { \"N\" : \"E\",  \"E\" : \"S\", \"S\" : \"W\", \"W\" : \"N\" };\\n    // initial starting point of the robot\\n    let robot = [0,0];\\n    // the direction our robot is currently facing (initialized to north)\\n    let facing = \"N\";\\n\\t\\n    for (let i of instructions) {\\n\\t\\t// if G, update the current position of the robot based on the direction\\n        if (i === \"G\") robot = [robot[0] + DIRECTION[facing][0], robot[1] + DIRECTION[facing][1]];\\n\\t\\t// if L, change facing direction of the robot using LEFT\\n        else if (i === \"L\") facing = LEFT[facing];\\n\\t\\t// otherwise (R), change the facing direction of the robot using RIGHT \\n        else facing = RIGHT[facing];\\n    }\\n\\t\\n\\t// if we are facing a new direction or we have not moved we are in a circular pattern, return true\\n    if (facing !== \"N\" || (robot[0] === 0 && robot[1] === 0)) return true;\\n\\t// otherwise return false\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isRobotBounded = function(instructions) {\\n    const DIRECTION = { \"N\": [0,1], \"S\": [0,-1], \"E\": [1,0], \"W\": [-1,0] };\\n    const LEFT = { \"N\" : \"W\",  \"W\" : \"S\", \"S\" : \"E\", \"E\" : \"N\" };\\n    const RIGHT = { \"N\" : \"E\",  \"E\" : \"S\", \"S\" : \"W\", \"W\" : \"N\" };\\n    // initial starting point of the robot\\n    let robot = [0,0];\\n    // the direction our robot is currently facing (initialized to north)\\n    let facing = \"N\";\\n\\t\\n    for (let i of instructions) {\\n\\t\\t// if G, update the current position of the robot based on the direction\\n        if (i === \"G\") robot = [robot[0] + DIRECTION[facing][0], robot[1] + DIRECTION[facing][1]];\\n\\t\\t// if L, change facing direction of the robot using LEFT\\n        else if (i === \"L\") facing = LEFT[facing];\\n\\t\\t// otherwise (R), change the facing direction of the robot using RIGHT \\n        else facing = RIGHT[facing];\\n    }\\n\\t\\n\\t// if we are facing a new direction or we have not moved we are in a circular pattern, return true\\n    if (facing !== \"N\" || (robot[0] === 0 && robot[1] === 0)) return true;\\n\\t// otherwise return false\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850699,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn is_robot_bounded(instructions: String) -> bool {\\n        let mut d = (0, 1);\\n        let mut p = (0, 0);\\n        for c in instructions.chars() {\\n            match c {\\n                \\'G\\' => p = (p.0 + d.0, p.1 + d.1),\\n                \\'L\\' => d = (-d.1, d.0),\\n                \\'R\\' => d = (d.1, -d.0),\\n                _ => {}\\n            }\\n        }\\n        p == (0, 0) || d != (0, 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_robot_bounded(instructions: String) -> bool {\\n        let mut d = (0, 1);\\n        let mut p = (0, 0);\\n        for c in instructions.chars() {\\n            match c {\\n                \\'G\\' => p = (p.0 + d.0, p.1 + d.1),\\n                \\'L\\' => d = (-d.1, d.0),\\n                \\'R\\' => d = (d.1, -d.0),\\n                _ => {}\\n            }\\n        }\\n        p == (0, 0) || d != (0, 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675196,
                "title": "c-100-faster-2-solutions",
                "content": "1. Iterating the string 4 times and then checking the position\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dir = 100;\\n        int up = 0;\\n        int side = 0;\\n        for(int j = 0;j<4;j++){\\n            for(int i = 0;i<instructions.length();i++){\\n                if(instructions[i]==\\'G\\'){\\n                    if(dir%4==0){\\n                        up++;\\n                    }\\n                    else if(dir%4==1){\\n                        side++;\\n                    }\\n                    else if(dir%4==2){\\n                        up--;\\n                    }\\n                    else{\\n                        side--;\\n                    }\\n                }\\n                else if(instructions[i]==\\'L\\'){\\n                    dir--;\\n                }\\n                else{\\n                    dir++;\\n                }\\n            }\\n            if(up==0 && side==0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n2. Iterating once and checking the status:-\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dir = 100;\\n        int up = 0;\\n        int side = 0;\\n        for(int i = 0;i<instructions.length();i++){\\n            if(instructions[i]==\\'G\\'){\\n                if(dir%4==0){\\n                    up++;\\n                }\\n                else if(dir%4==1){\\n                    side++;\\n                }\\n                else if(dir%4==2){\\n                    up--;\\n                }\\n                else{\\n                    side--;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\'){\\n                dir--;\\n            }\\n            else{\\n                dir++;\\n            }\\n        }\\n        if((up==0 && side==0) || (dir%4!=0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dir = 100;\\n        int up = 0;\\n        int side = 0;\\n        for(int j = 0;j<4;j++){\\n            for(int i = 0;i<instructions.length();i++){\\n                if(instructions[i]==\\'G\\'){\\n                    if(dir%4==0){\\n                        up++;\\n                    }\\n                    else if(dir%4==1){\\n                        side++;\\n                    }\\n                    else if(dir%4==2){\\n                        up--;\\n                    }\\n                    else{\\n                        side--;\\n                    }\\n                }\\n                else if(instructions[i]==\\'L\\'){\\n                    dir--;\\n                }\\n                else{\\n                    dir++;\\n                }\\n            }\\n            if(up==0 && side==0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dir = 100;\\n        int up = 0;\\n        int side = 0;\\n        for(int i = 0;i<instructions.length();i++){\\n            if(instructions[i]==\\'G\\'){\\n                if(dir%4==0){\\n                    up++;\\n                }\\n                else if(dir%4==1){\\n                    side++;\\n                }\\n                else if(dir%4==2){\\n                    up--;\\n                }\\n                else{\\n                    side--;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\'){\\n                dir--;\\n            }\\n            else{\\n                dir++;\\n            }\\n        }\\n        if((up==0 && side==0) || (dir%4!=0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300372,
                "title": "python-4-instructions-o-n",
                "content": "This solution is to run the instruction 4 times to see whether the robot can move back to origin\\n```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        instructions *= 4\\n        direction = \\'N\\'\\n        directionNext = {\\'N\\': (\\'W\\', \\'E\\'), \\'E\\': (\\'N\\', \\'S\\'), \\'S\\': (\\'E\\', \\'W\\'), \\'W\\': (\\'S\\', \\'N\\')}\\n        x, y = 0, 0\\n        for move in instructions:\\n            if move == \\'G\\':\\n                if direction == \\'N\\':\\n                    y += 1\\n                elif direction == \\'E\\':\\n                    x += 1\\n                elif direction == \\'S\\':\\n                    y -= 1\\n                else:\\n                    x -= 1\\n            elif move == \\'L\\':\\n                direction = directionNext[direction][0]\\n            else: \\n                direction = directionNext[direction][1]\\n        return x == 0 and y == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        instructions *= 4\\n        direction = \\'N\\'\\n        directionNext = {\\'N\\': (\\'W\\', \\'E\\'), \\'E\\': (\\'N\\', \\'S\\'), \\'S\\': (\\'E\\', \\'W\\'), \\'W\\': (\\'S\\', \\'N\\')}\\n        x, y = 0, 0\\n        for move in instructions:\\n            if move == \\'G\\':\\n                if direction == \\'N\\':\\n                    y += 1\\n                elif direction == \\'E\\':\\n                    x += 1\\n                elif direction == \\'S\\':\\n                    y -= 1\\n                else:\\n                    x -= 1\\n            elif move == \\'L\\':\\n                direction = directionNext[direction][0]\\n            else: \\n                direction = directionNext[direction][1]\\n        return x == 0 and y == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678806,
                "title": "c-with-easy-explanation-bruteforce-and-optimal-easy-to-understand",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivates me to create better post like this \\u270D\\uFE0F\\n![image](https://assets.leetcode.com/users/images/9fac89e7-d694-4f28-9f06-53edd5587bda_1641750744.1594224.png)\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* we have to find wheather the robot repeat the same path it means if we starts from origin at some point it should came again at origin return true else false.\\n\\n#### \\u2714\\uFE0F **Solution - I (Naive Approach)**\\n##### **Intuition :-**\\n* I have made condition for every instruction.\\n* It is the most basic and easy approach.\\n* If you can\\'t think of optimal try atleast for bruteforce.\\n##### **Code :-**\\n```\\nbool isRobotBounded(string instructions)\\n{\\n     int x = 0;\\n     int y = 0;\\n     char direction = \\'N\\';\\n     int count = 100;\\n     while (count--)\\n     {\\n          for (int i = 0; i < instructions.size(); i++)\\n          {\\n               if (instructions[i] == \\'G\\')\\n                    if (direction == \\'N\\')\\n                         y = y + 1;\\n                    else if (direction == \\'W\\')\\n                         x = x - 1;\\n                    else if (direction == \\'E\\')\\n                         x = x + 1;\\n                    else\\n                         y = y - 1;\\n               else if (instructions[i] == \\'L\\')\\n                    if (direction == \\'N\\')\\n                         direction = \\'W\\';\\n                    else if (direction == \\'W\\')\\n                         direction = \\'S\\';\\n                    else if (direction == \\'S\\')\\n                         direction = \\'E\\';\\n                    else\\n                         direction = \\'N\\';\\n               else if (instructions[i] == \\'R\\')\\n                    if (direction == \\'N\\')\\n                         direction = \\'E\\';\\n                    else if (direction == \\'E\\')\\n                         direction = \\'S\\';\\n                    else if (direction == \\'S\\')\\n                         direction = \\'W\\';\\n                    else\\n                         direction = \\'N\\';\\n          }\\n          if (x == 0 && y == 0)\\n               return true;\\n     }\\n     return false;\\n}\\n```\\n**Time Complexity** : `O(maximum instructions = 100)`, as the limit of instruction are less than 100.\\n**Space Complexity** : `O(1)`, no extra space is used.\\n\\n#### \\u2714\\uFE0F **Solution - II (Best Approach)**\\n##### **Intuition :-**\\n* (x,y) is the location of chopper.\\n* d[i] is the direction he is facing.\\n* i = (i + 1) % 4 will turn right\\n* i = (i + 3) % 4 will turn left\\nCheck the final status after instructions.\\n\\n##### **Code :-**\\n```\\nbool isRobotBounded(string instructions)\\n{\\n     int x = 0, y = 0, i = 0;\\n     vector<vector<int>> direction = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n     for (char &ins : instructions)\\n          if (ins == \\'R\\')\\n               i = (i + 1) % 4;\\n          else if (ins == \\'L\\')\\n               i = (i + 3) % 4;\\n          else\\n               x += direction[i][0], y += direction[i][1];\\n     return x == 0 && y == 0 || i > 0;\\n}\\n```\\n**Time Complexity** : `O(N)`, executed instruction only one time.\\n**Space Complexity** : `O(1)`, constant space is used.\\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isRobotBounded(string instructions)\\n{\\n     int x = 0;\\n     int y = 0;\\n     char direction = \\'N\\';\\n     int count = 100;\\n     while (count--)\\n     {\\n          for (int i = 0; i < instructions.size(); i++)\\n          {\\n               if (instructions[i] == \\'G\\')\\n                    if (direction == \\'N\\')\\n                         y = y + 1;\\n                    else if (direction == \\'W\\')\\n                         x = x - 1;\\n                    else if (direction == \\'E\\')\\n                         x = x + 1;\\n                    else\\n                         y = y - 1;\\n               else if (instructions[i] == \\'L\\')\\n                    if (direction == \\'N\\')\\n                         direction = \\'W\\';\\n                    else if (direction == \\'W\\')\\n                         direction = \\'S\\';\\n                    else if (direction == \\'S\\')\\n                         direction = \\'E\\';\\n                    else\\n                         direction = \\'N\\';\\n               else if (instructions[i] == \\'R\\')\\n                    if (direction == \\'N\\')\\n                         direction = \\'E\\';\\n                    else if (direction == \\'E\\')\\n                         direction = \\'S\\';\\n                    else if (direction == \\'S\\')\\n                         direction = \\'W\\';\\n                    else\\n                         direction = \\'N\\';\\n          }\\n          if (x == 0 && y == 0)\\n               return true;\\n     }\\n     return false;\\n}\\n```\n```\\nbool isRobotBounded(string instructions)\\n{\\n     int x = 0, y = 0, i = 0;\\n     vector<vector<int>> direction = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n     for (char &ins : instructions)\\n          if (ins == \\'R\\')\\n               i = (i + 1) % 4;\\n          else if (ins == \\'L\\')\\n               i = (i + 3) % 4;\\n          else\\n               x += direction[i][0], y += direction[i][1];\\n     return x == 0 && y == 0 || i > 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678562,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.length(); s++){\\n            if(instructions.charAt(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.length(); s++){\\n            if(instructions.charAt(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677147,
                "title": "c-best-solution-easy-explanation",
                "content": "The main intuition behind the problem is that there is always a finitely big circle to bind a robot\\'s path, unless it has a **path that goes to infinity**. So, when can the robot go to infinity?\\n\\nIf you think a bit with some examples, suppose the final displacement vector (final position - initial position) after one iteration of instructions is a vector to the east with the robot facing east. (You can make a rotation of the coordinate axis to make any vector that is not pointing east follow this. For example, if you suppose your vector is 45 degrees to the north west, you can rotate the axis 135 degrees with no loss of generality and have it point east). In only 4 iterations, it will return back to its original position. \\n\\n![image](https://assets.leetcode.com/users/images/34cb4ec7-fbb4-429d-833a-0ef0524fecdc_1641705499.4991412.png)\\n\\nAs it turns out, the robot will only go to infinity if in its final position, it is facing north. Then, the displacement vector will continue to get farther and farther away instead of forming some polygonal path. In every other instance, there will be a polygon formed.\\n\\nWhy is the first fact true? The second iteration of the instructions will make a vector exactly the same as the first vector, and so these vectors will keep on adding in the same direction and go to infinity. In any other case, the vectors will circle around to form a polygon. \\n\\n**Corner Case**: The robot can return to its original position after one instruction iteration despite facing north. Obviously, it can be bound by a circle in this case.\\n\\nThus, the solution is trivial after we realize this.\\n\\n\\n```class Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0;\\n        int dir = 0; // 0 representing north, 1 representing east, 2 representing south, 3 representing west. A concept similar to the Spiral Matrix II problem.\\n        for (int i = 0; i < instructions.size(); ++i) {\\n            if (instructions[i]==\\'G\\') {\\n                if (dir==0) y++;\\n                if (dir==1) x++;\\n                if (dir==2) y--;\\n                if (dir==3) x--;\\n            }\\n            else if (instructions[i]==\\'L\\') {\\n                dir--;\\n                dir = (dir+4)%4; // So that direction is positive after taking mod\\n            }\\n            else {\\n                dir++;\\n                dir %= 4;\\n            }\\n        }\\n        return dir!=0 || (x==0 & y==0);\\n    }\\n};\\n```\\n\\n**Time Complexity: O(N)\\nSpace Complexity: O(1)**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0;\\n        int dir = 0; // 0 representing north, 1 representing east, 2 representing south, 3 representing west. A concept similar to the Spiral Matrix II problem.\\n        for (int i = 0; i < instructions.size(); ++i) {\\n            if (instructions[i]==\\'G\\') {\\n                if (dir==0) y++;\\n                if (dir==1) x++;\\n                if (dir==2) y--;\\n                if (dir==3) x--;\\n            }\\n            else if (instructions[i]==\\'L\\') {\\n                dir--;\\n                dir = (dir+4)%4; // So that direction is positive after taking mod\\n            }\\n            else {\\n                dir++;\\n                dir %= 4;\\n            }\\n        }\\n        return dir!=0 || (x==0 & y==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634298,
                "title": "for-those-who-can-t-start-tip",
                "content": "I just want to provide a direction in which people can start thinking. Start with a pen and paper trace few examples. Try to find when it will not be in a circle. The answer is when the direction on ending is same as the direction of starting. There would be 2 cases:\\n1) When the net direction is 90 or 270 it forms a square every 4 times the machine repeats the instructions.\\n2) When the net is 180 it forms a line, when it\\'s 360 it\\'s not going to be in a circle.\\n\\nOnly exception for the 360 angle is if it ends at the starting point. i.e 0 displacement.\\nIn this case it already made the journey.\\n\\nSimple code which does exactly what I mentioned\\n\\n```\\ndef isRobotBounded(self, ins: str) -> bool:\\n        direc = 0\\n        dist = [0,0,0,0]\\n        i = 0\\n        for ele in ins:\\n            if ele==\\'L\\':\\n                direc += 90\\n                i+= 1\\n            elif ele==\\'R\\':\\n                direc -= 90\\n                i-= 1\\n            else:\\n                dist[i] += 1\\n            i %=4\\n        ud = abs(dist[0] - dist[2])\\n        lr = abs(dist[1] - dist[3])\\n        # print(ud,lr)\\n        if direc%360==0 and ud+lr != 0:\\n            return False\\n        return True\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef isRobotBounded(self, ins: str) -> bool:\\n        direc = 0\\n        dist = [0,0,0,0]\\n        i = 0\\n        for ele in ins:\\n            if ele==\\'L\\':\\n                direc += 90\\n                i+= 1\\n            elif ele==\\'R\\':\\n                direc -= 90\\n                i-= 1\\n            else:\\n                dist[i] += 1\\n            i %=4\\n        ud = abs(dist[0] - dist[2])\\n        lr = abs(dist[1] - dist[3])\\n        # print(ud,lr)\\n        if direc%360==0 and ud+lr != 0:\\n            return False\\n        return True\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1459979,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "**Understanding the Problem:**\\n\\nAs per the problem, the robot starts at (0,0) facing north and we have to find if the robot is not going to leave the circle. \\nBased on this assumption we can say - if after travelling some (x,y) distance, the robot continues to be in the north direction then the robot will leave the circle till which it has travelled till now. If it is in any other direction then we say it is going to be in the circle.\\n\\nFrom this understanding we can deduce the following -\\n- If the robot is in (x, y) plane facing northward/upward and not in the starting position (0,0) then it is **not in a circle**\\n- In all other cases the robot is considered to be **in a circle**\\n\\t- Robot is in starting position (0, 0) pointing to any direction\\n\\t- Robot is in any position (x, y) other than starting, but facing in any of the directions - East, West, South, other than North.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n\\n        // Denotes the \\'N\\', \\'E\\', \\'S\\', \\'W\\' co-ordinates\\n        int dir[][] = {\\n            {0,1},  //North\\n            {1,0},  //East\\n            {0,-1}, //South\\n            {-1,0}  //West\\n        };\\n        \\n        // Co-ordinates in the dir[][] plane\\n        // dir[*][0] --> x\\n        // dir[*][1] --> y\\n        int x=0, y=0;\\n\\n        // Index denoting the direction \\n        // i = 0 --> North/Up\\n        // i = 1 --> East/Right\\n        // i = 2 --> South/Down\\n        // i = 3 --> West/Left\\n        int i=0; \\n                \\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'L\\') \\n                i = (i + 3) % 4;\\n            else if(c == \\'R\\') \\n                i = (i + 1) % 4;\\n            else {\\n                x += dir[i][0]; // Calculating the x distance\\n                y += dir[i][1]; // Calculating the y distance\\n            }\\n        }\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n\\n        // Denotes the \\'N\\', \\'E\\', \\'S\\', \\'W\\' co-ordinates\\n        int dir[][] = {\\n            {0,1},  //North\\n            {1,0},  //East\\n            {0,-1}, //South\\n            {-1,0}  //West\\n        };\\n        \\n        // Co-ordinates in the dir[][] plane\\n        // dir[*][0] --> x\\n        // dir[*][1] --> y\\n        int x=0, y=0;\\n\\n        // Index denoting the direction \\n        // i = 0 --> North/Up\\n        // i = 1 --> East/Right\\n        // i = 2 --> South/Down\\n        // i = 3 --> West/Left\\n        int i=0; \\n                \\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'L\\') \\n                i = (i + 3) % 4;\\n            else if(c == \\'R\\') \\n                i = (i + 1) % 4;\\n            else {\\n                x += dir[i][0]; // Calculating the x distance\\n                y += dir[i][1]; // Calculating the y distance\\n            }\\n        }\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382214,
                "title": "c-beats-100-simple-trick-and-short-solution",
                "content": "the main idea is simple \\n\"the number of moves that he makes to the left must be equal to number of moves he takes to right \"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t**and** \\n\"the number of moves that he makes to the up must be equal to number of moves he takes to down\" \\nwe can achive that by keeping an array of lenghth 4 where index 0,1,2,3 represents the number of moves he had done in the top,left,down,right respectively. we can check to which direction we are facing by simply keeping maintaing a variable d and increase or decrease depending on the left or right reespectively.\\n ```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string A) {\\n        A=A+A+A+A;\\n        int n=A.size();\\n        int no_moves[]={0,0,0,0};\\n        // top left down right\\n        int d=0;// to detrmine the which direction am i going \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] == \\'G\\')no_moves[d]++;\\n            else if(A[i] == \\'L\\')d++;\\n            else {\\n                d+=4;\\n                d--;\\n            }\\n            d%=4;\\n        }\\n        return (no_moves[0] == no_moves[2] && no_moves[1] == no_moves[3]);\\n    }\\n};\\n```\\nupvote if you like !!!!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string A) {\\n        A=A+A+A+A;\\n        int n=A.size();\\n        int no_moves[]={0,0,0,0};\\n        // top left down right\\n        int d=0;// to detrmine the which direction am i going \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] == \\'G\\')no_moves[d]++;\\n            else if(A[i] == \\'L\\')d++;\\n            else {\\n                d+=4;\\n                d--;\\n            }\\n            d%=4;\\n        }\\n        return (no_moves[0] == no_moves[2] && no_moves[1] == no_moves[3]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158977,
                "title": "python-very-intuitive-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    cur_dir = \\'N\\'\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        self.cur_dir = \\'N\\'\\n        cur_pos = [0,0]\\n        for ins in instructions:\\n            if ins == \\'G\\':\\n                self.ChangePos(cur_pos)\\n            else:\\n                self.ChangeDirection(ins)\\n        if cur_pos[0] == 0 and cur_pos[1] == 0:\\n            return True\\n        if self.cur_dir != \\'N\\':\\n            return True\\n        return False\\n        \\n    def ChangePos(self,cur_pos):\\n        if self.cur_dir == \\'N\\':\\n            cur_pos[1] += 1\\n        elif self.cur_dir == \\'S\\':\\n            cur_pos[1] -= 1\\n        elif self.cur_dir == \\'W\\':\\n            cur_pos[0] -= 1\\n        elif self.cur_dir == \\'E\\':\\n            cur_pos[0] += 1\\n            \\n    #think of a compass...and all possiblities of change in direction\\n    def ChangeDirection(self,d):\\n        if self.cur_dir == \\'N\\' and d == \\'L\\':\\n            self.cur_dir = \\'W\\'\\n        elif self.cur_dir == \\'N\\' and d == \\'R\\':\\n            self.cur_dir = \\'E\\'\\n        elif self.cur_dir == \\'S\\' and d == \\'L\\':\\n            self.cur_dir = \\'E\\'\\n        elif self.cur_dir == \\'S\\' and d == \\'R\\':\\n            self.cur_dir = \\'W\\'\\n        elif self.cur_dir == \\'W\\' and d == \\'L\\':\\n            self.cur_dir = \\'S\\'\\n        elif self.cur_dir == \\'W\\' and d == \\'R\\':\\n            self.cur_dir = \\'N\\'\\n        elif self.cur_dir == \\'E\\' and d == \\'L\\':\\n            self.cur_dir = \\'N\\'\\n        elif self.cur_dir == \\'E\\' and d == \\'R\\':\\n            self.cur_dir = \\'S\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    cur_dir = \\'N\\'\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        self.cur_dir = \\'N\\'\\n        cur_pos = [0,0]\\n        for ins in instructions:\\n            if ins == \\'G\\':\\n                self.ChangePos(cur_pos)\\n            else:\\n                self.ChangeDirection(ins)\\n        if cur_pos[0] == 0 and cur_pos[1] == 0:\\n            return True\\n        if self.cur_dir != \\'N\\':\\n            return True\\n        return False\\n        \\n    def ChangePos(self,cur_pos):\\n        if self.cur_dir == \\'N\\':\\n            cur_pos[1] += 1\\n        elif self.cur_dir == \\'S\\':\\n            cur_pos[1] -= 1\\n        elif self.cur_dir == \\'W\\':\\n            cur_pos[0] -= 1\\n        elif self.cur_dir == \\'E\\':\\n            cur_pos[0] += 1\\n            \\n    #think of a compass...and all possiblities of change in direction\\n    def ChangeDirection(self,d):\\n        if self.cur_dir == \\'N\\' and d == \\'L\\':\\n            self.cur_dir = \\'W\\'\\n        elif self.cur_dir == \\'N\\' and d == \\'R\\':\\n            self.cur_dir = \\'E\\'\\n        elif self.cur_dir == \\'S\\' and d == \\'L\\':\\n            self.cur_dir = \\'E\\'\\n        elif self.cur_dir == \\'S\\' and d == \\'R\\':\\n            self.cur_dir = \\'W\\'\\n        elif self.cur_dir == \\'W\\' and d == \\'L\\':\\n            self.cur_dir = \\'S\\'\\n        elif self.cur_dir == \\'W\\' and d == \\'R\\':\\n            self.cur_dir = \\'N\\'\\n        elif self.cur_dir == \\'E\\' and d == \\'L\\':\\n            self.cur_dir = \\'N\\'\\n        elif self.cur_dir == \\'E\\' and d == \\'R\\':\\n            self.cur_dir = \\'S\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851918,
                "title": "c-solution-with-notes",
                "content": "**Intuition**\\n**The first challenge is how to effectively get the new direction after making a turn.**\\nWe first define a 2-dementional array ```dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}}``` to represent north, east, south and west in order, and also treat ```dirs``` as a **cyclic array**. Now let\\'s assume the current direction is ```dirs[i]```.\\n* For a right turn, we can think of the directions are: ```north -> east -> south -> west -> north ->...```. Making a right turn is equivalent to moving the current direction to its next. So the new directin will be ```dirs[(i + 1) % 4]```.\\n* For a left turn, it can be treated as moving the current direction to its previous one. So the new direction will be ```dirs[(i-1) % 4]```, since we need to ensure ```index >= 0```, so we change ```dirs[(i-1) % 4]```  to ```dirs[(i - 1 + 4) % 4]```, which is ```dirs[(i + 3) % 4]```.\\n\\n**The second challenge is how can we determine the robot can be bounded in a circle.**\\nThere are two cases where the robot will be bounded in a circle.\\n* case 1: Robot is at the original position ```(0,0)``` after finishing the instruction.\\n* case 1: Robot is not at the original position ```(0,0)``` && not facing towards north after finishing the instruction.\\n\\nIn case 1, the robot will go back the original position every time when the instruction is executed. In case 2, we can think of the path that the robot moves as below. So after executing the instruction at most 4 times, the robot will go back to the original position.\\n![image](https://assets.leetcode.com/users/images/0d740ebf-146d-4961-b70c-7ea22db818e0_1621460437.057373.png)\\n\\n\\n\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        if(instructions == null || instructions.Length == 0)\\n            return true;\\n        \\n        int[,] dirs = new int[,]{{0,1}, {1,0}, {0,-1}, {-1,0}}; // north, east, sourth, west\\n        int i = 0, x = 0, y = 0;\\n        foreach(var c in instructions)\\n        {\\n            if(c == \\'G\\')\\n            {\\n                x += dirs[i,0];\\n                y += dirs[i,1];\\n            }\\n            else if(c == \\'L\\')\\n                i = (i + 3) % 4; // (i - 1 + 4) % 4, % is the remainder operator, -1 % 4 = -1\\n            else\\n                i = (i + 1) % 4;\\n        }\\n        \\n        return (x == 0 && y == 0) || i != 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}}```\n```dirs```\n```dirs[i]```\n```north -> east -> south -> west -> north ->...```\n```dirs[(i + 1) % 4]```\n```dirs[(i-1) % 4]```\n```index >= 0```\n```dirs[(i-1) % 4]```\n```dirs[(i - 1 + 4) % 4]```\n```dirs[(i + 3) % 4]```\n```(0,0)```\n```(0,0)```\n```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        if(instructions == null || instructions.Length == 0)\\n            return true;\\n        \\n        int[,] dirs = new int[,]{{0,1}, {1,0}, {0,-1}, {-1,0}}; // north, east, sourth, west\\n        int i = 0, x = 0, y = 0;\\n        foreach(var c in instructions)\\n        {\\n            if(c == \\'G\\')\\n            {\\n                x += dirs[i,0];\\n                y += dirs[i,1];\\n            }\\n            else if(c == \\'L\\')\\n                i = (i + 3) % 4; // (i - 1 + 4) % 4, % is the remainder operator, -1 % 4 = -1\\n            else\\n                i = (i + 1) % 4;\\n        }\\n        \\n        return (x == 0 && y == 0) || i != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850881,
                "title": "robot-bounded-in-circle-c-easy-switch-case",
                "content": "```\\nbool isRobotBounded(string instructions) {\\n\\tpair<int,int> position = {0,0};\\n\\tconst vector<pair<int,int>> directions = {{0,1},{-1,0},{0,-1},{1,0}};\\n\\tint direction = 0;\\n\\tfor(const auto i : instructions) {\\n\\t\\tswitch(i) {\\n\\t\\t\\tcase \\'G\\':\\n\\t\\t\\t\\tposition.first += directions[direction].first;\\n\\t\\t\\t\\tposition.second += directions[direction].second;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tdirection = (direction+1)%4;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'R\\':\\n\\t\\t\\t\\tdirection = (direction+3)%4;\\n\\t\\t}\\n\\t}\\n\\treturn direction != 0 || (position.first == 0 && position.second == 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isRobotBounded(string instructions) {\\n\\tpair<int,int> position = {0,0};\\n\\tconst vector<pair<int,int>> directions = {{0,1},{-1,0},{0,-1},{1,0}};\\n\\tint direction = 0;\\n\\tfor(const auto i : instructions) {\\n\\t\\tswitch(i) {\\n\\t\\t\\tcase \\'G\\':\\n\\t\\t\\t\\tposition.first += directions[direction].first;\\n\\t\\t\\t\\tposition.second += directions[direction].second;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tdirection = (direction+1)%4;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'R\\':\\n\\t\\t\\t\\tdirection = (direction+3)%4;\\n\\t\\t}\\n\\t}\\n\\treturn direction != 0 || (position.first == 0 && position.second == 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850540,
                "title": "java-simple-self-explanatory-solution-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int direction = 0, x = 0, y = 0;\\n        for(int i = 0; i < instructions.length(); i++) {\\n            if(instructions.charAt(i) == \\'G\\') {\\n                if(direction == 0) {\\n                    y++;\\n                }\\n                else if(direction == 1) {\\n                    x--;\\n                }\\n                else if(direction == 2) {\\n                    y--;\\n                }\\n                else if(direction == 3) {\\n                    x++;\\n                }\\n            }\\n            else if(instructions.charAt(i) == \\'L\\') {\\n                direction = (direction + 1) % 4;\\n            }\\n            else if(instructions.charAt(i) == \\'R\\') {\\n                direction = direction != 0 ? (direction - 1) : 3;\\n            }\\n        }\\n        if(direction != 0 || (x == 0 && y == 0)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int direction = 0, x = 0, y = 0;\\n        for(int i = 0; i < instructions.length(); i++) {\\n            if(instructions.charAt(i) == \\'G\\') {\\n                if(direction == 0) {\\n                    y++;\\n                }\\n                else if(direction == 1) {\\n                    x--;\\n                }\\n                else if(direction == 2) {\\n                    y--;\\n                }\\n                else if(direction == 3) {\\n                    x++;\\n                }\\n            }\\n            else if(instructions.charAt(i) == \\'L\\') {\\n                direction = (direction + 1) % 4;\\n            }\\n            else if(instructions.charAt(i) == \\'R\\') {\\n                direction = direction != 0 ? (direction - 1) : 3;\\n            }\\n        }\\n        if(direction != 0 || (x == 0 && y == 0)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850464,
                "title": "python-3-simulation-explanation",
                "content": "### Explanation\\n- `direc` is the direction, `pos` is current position `[x, y]`\\n- Simulate the process and find out where the point is at for every instruction\\n- If `pos` return to origin `[0, 0]` or `direction` not facing initial state (`0`), then there is a loop\\n### Implementation\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direc, pos = 0, [0, 0]\\n        for c in instructions:\\n            if c == \"L\": direc = (direc + 1) % 4\\n            elif c == \"R\": direc = (direc - 1) % 4\\n            elif c == \"G\":\\n                if direc == 0: pos[1] += 1\\n                elif direc == 1: pos[0] -= 1\\n                elif direc == 2: pos[1] -= 1\\n                else: pos[0] += 1\\n        return pos == [0, 0] or direc != 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direc, pos = 0, [0, 0]\\n        for c in instructions:\\n            if c == \"L\": direc = (direc + 1) % 4\\n            elif c == \"R\": direc = (direc - 1) % 4\\n            elif c == \"G\":\\n                if direc == 0: pos[1] += 1\\n                elif direc == 1: pos[0] -= 1\\n                elif direc == 2: pos[1] -= 1\\n                else: pos[0] += 1\\n        return pos == [0, 0] or direc != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850441,
                "title": "python-simple-solution-with-explanations",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        # initialize position and direction to north:\\n        pos = [0,0]\\n        direc = [0,1]\\n        \\n        # example - going left:\\n        # if pos is [1,1], direction is [0,1] we want to go left - we have to add to pos [-1,0] (left in graph)\\n        # if pos is [1,1], direction is [-1,0] we want to go left - we have to add to pos [0,-1] (down in graph)\\n        # if pos is [1,1], direction is [0,-1] we want to go left - we have to add to pos [1,0] (right in graph)\\n        \\n        # that calculation brings us to the conclusion that for going left we change the direction [x,y] to [-y,x]\\n        # and for going right we change the direction [x,y] to [y,-x]\\n\\t\\t\\n        for instruct in instructions:\\n            if instruct == \"L\":\\n                direc[0], direc[1] = -direc[1], direc[0]\\n            elif instruct == \"R\":\\n                direc[0], direc[1] = direc[1], -direc[0]\\n            else:\\n                pos[0], pos[1] = pos[0]+direc[0], pos[1]+direc[1]\\n\\n        # if position got back to original, or we changed original direction\\n        if pos == [0,0] or direc != [0,1]:\\n            return True\\n        return False\\n```\\n**Like it? please upvote...**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        # initialize position and direction to north:\\n        pos = [0,0]\\n        direc = [0,1]\\n        \\n        # example - going left:\\n        # if pos is [1,1], direction is [0,1] we want to go left - we have to add to pos [-1,0] (left in graph)\\n        # if pos is [1,1], direction is [-1,0] we want to go left - we have to add to pos [0,-1] (down in graph)\\n        # if pos is [1,1], direction is [0,-1] we want to go left - we have to add to pos [1,0] (right in graph)\\n        \\n        # that calculation brings us to the conclusion that for going left we change the direction [x,y] to [-y,x]\\n        # and for going right we change the direction [x,y] to [y,-x]\\n\\t\\t\\n        for instruct in instructions:\\n            if instruct == \"L\":\\n                direc[0], direc[1] = -direc[1], direc[0]\\n            elif instruct == \"R\":\\n                direc[0], direc[1] = direc[1], -direc[0]\\n            else:\\n                pos[0], pos[1] = pos[0]+direc[0], pos[1]+direc[1]\\n\\n        # if position got back to original, or we changed original direction\\n        if pos == [0,0] or direc != [0,1]:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403284,
                "title": "javascript-o-n-simple-solution-explained",
                "content": "There are two ways to make the robot going cicrle:\\n1. after one round it returns to the start position\\n2. after one round it changes direction from the north\\n\\nSo, I decided to store separately directions and current coordinates:\\n\\n```\\n const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n```\\nWhere dir object means coordinates of the vector: north means vector {0, 1}, west {1, 0}, south {0, -1} and east {-1, 0}.\\n\\nThen we just go through each letter of input and check wether it\\'s \\'G\\', \\'R\\' or \\'L\\'.\\nIn case it\\'s \\'G\\', we change our coordinates depending on dir object:\\n```\\ncoord.x += dir.x;\\ncoord.y += dir.y;\\n```\\n\\nIn case it\\'s \\'L\\' or \\'R\\' I decided to check every possible case (there are four of them depending on vector\\'s direction): x = 0 and y = 1, x = 0 and y = -1, x = 1 and y = 0, x = -1 and y = 0. There might be a better mathematical approach, if you know how to get rid of unnessary if else conditions, lmk in the comments.\\n\\nAfter going through the whole string we just need to check wether the coordinate is {0, 0} again or the vector doesn\\'t point to north (in this case we will end up coming back eventually), and in this case return true, otherwise return false.\\n\\nThe whole solution is:\\n```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nvar isRobotBounded = function(instructions) {\\n    const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        switch(instructions[i]) {\\n            case \\'G\\':\\n                coord.x += dir.x;\\n                coord.y += dir.y;\\n                break;\\n            case \\'L\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.y === 0 && dir.x === -1){\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                } else if(dir.y === 0 && dir.x === 1) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                }\\n                break;\\n            case \\'R\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === -1 && dir.y === 0) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                } else if(dir.x === 1 && dir.y === 0) {\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                }\\n                break;\\n        }\\n    }\\n            \\n    if(coord.x === 0 && coord.y === 0) return true;\\n    if(dir.y !== 1) return true;\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n```\n```\\ncoord.x += dir.x;\\ncoord.y += dir.y;\\n```\n```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nvar isRobotBounded = function(instructions) {\\n    const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        switch(instructions[i]) {\\n            case \\'G\\':\\n                coord.x += dir.x;\\n                coord.y += dir.y;\\n                break;\\n            case \\'L\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.y === 0 && dir.x === -1){\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                } else if(dir.y === 0 && dir.x === 1) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                }\\n                break;\\n            case \\'R\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === -1 && dir.y === 0) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                } else if(dir.x === 1 && dir.y === 0) {\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                }\\n                break;\\n        }\\n    }\\n            \\n    if(coord.x === 0 && coord.y === 0) return true;\\n    if(dir.y !== 1) return true;\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2266083,
                "title": "python-simple-solution-with-detailed-explanation",
                "content": "# Explanation\\nWe use simulation to simulate the path the robot goes in. We know if the robot will end up in a circle if it ends back where it is (`x` and `y` both are `0`) or the robot isn\\'t still facing the same direction (direction change is sitll `0, 1`)\\n\\nSo, in the end we only need to check if `x` and `y` are the same or if `di` is still `(0, 1)` north.\\n__________________________________________________________________________________________\\nWe also don\\'t need to store a whole array of directions: to swap the following directions:\\n**left** - set `dx` the opposite of `dy` and `dy` as `dx`. \\n**right** - set `dy` to the opposite of `dx` and `dx` as `dy`.\\nThis is a bit tricky, but once you expand it you\\'ll get it.\\n\\n#### In-Depth Code Explanation\\n1. Define `di` as a tuple where `di[0]` is the change of `x` and `di[1]` is the change of `y`\\n2. Define `x` and `y` coordinates\\n3. Iterate through the list of instructions:\\n4. If the instruction is `\\'G\\'`: add `di` to `x` and `y` (make them move forward in same direction)\\n5. If the instruction is `\\'L\\'`: turn robot left (see above for detailed explanation for how)\\n6. If the instruction is `\\'R\\'`: turn robot right (see above for detailed explanation for how)\\n7. Check if `x` and `y` are still `0` or if `di` is not still `(0, 1)`\\n\\n```py\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        di = (0,1)\\n        x, y = 0, 0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x, y = x + di[0], y + di[1]\\n            elif instruction == \\'L\\':\\n                di = (-di[1], di[0])\\n            elif instruction == \\'R\\':\\n                di = (di[1], -di[0])\\n            \\n        return (x == 0 and y == 0) or di != (0, 1)\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        di = (0,1)\\n        x, y = 0, 0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x, y = x + di[0], y + di[1]\\n            elif instruction == \\'L\\':\\n                di = (-di[1], di[0])\\n            elif instruction == \\'R\\':\\n                di = (di[1], -di[0])\\n            \\n        return (x == 0 and y == 0) or di != (0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252616,
                "title": "python-simple-solution-using-dict-no-maths",
                "content": "Hello, I have a simpler solution that involves less of maths and more of logical thinking. \\n\\n```\\n\\tdef isRobotBounded(self, instructions: str) -> bool:\\n        curr_dir = \\'N\\'\\n        curr_pos = [0,0]\\n        directions = {\\'N\\':[0,1], \\'E\\':[1,0], \\'W\\':[-1,0], \\'S\\':[0,-1]}\\n        change_dir = {\\n            \\'N\\':{\\'L\\':\\'W\\', \\'R\\':\\'E\\'},\\n            \\'E\\':{\\'L\\':\\'N\\', \\'R\\':\\'S\\'},\\n            \\'W\\':{\\'L\\':\\'S\\', \\'R\\':\\'N\\'},\\n            \\'S\\':{\\'L\\':\\'E\\', \\'R\\':\\'W\\'}\\n        }\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                curr_pos[1] += directions[curr_dir][1]\\n                curr_pos[0] += directions[curr_dir][0]\\n            else:\\n                curr_dir=change_dir[curr_dir][instruction]\\n        if curr_dir != \\'N\\' or curr_pos == [0,0]:\\n            return True\\n        else:\\n            return False\\n```\\n\\n\\nHope it helps!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\tdef isRobotBounded(self, instructions: str) -> bool:\\n        curr_dir = \\'N\\'\\n        curr_pos = [0,0]\\n        directions = {\\'N\\':[0,1], \\'E\\':[1,0], \\'W\\':[-1,0], \\'S\\':[0,-1]}\\n        change_dir = {\\n            \\'N\\':{\\'L\\':\\'W\\', \\'R\\':\\'E\\'},\\n            \\'E\\':{\\'L\\':\\'N\\', \\'R\\':\\'S\\'},\\n            \\'W\\':{\\'L\\':\\'S\\', \\'R\\':\\'N\\'},\\n            \\'S\\':{\\'L\\':\\'E\\', \\'R\\':\\'W\\'}\\n        }\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                curr_pos[1] += directions[curr_dir][1]\\n                curr_pos[0] += directions[curr_dir][0]\\n            else:\\n                curr_dir=change_dir[curr_dir][instruction]\\n        if curr_dir != \\'N\\' or curr_pos == [0,0]:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2029141,
                "title": "clean-and-clear-python-solution-easy-to-understand",
                "content": "An interesting question!\\n\\n**Two cases** that could make the robot never leaves the circle:\\n**Case 1**: Return to (0, 0).\\n**Case 2**: Face other directions.\\n\\n**Time:** O(n)\\n**Space:** O(1)\\n\\n```\\nDIRECTIONS = {\\n    0: (0, 1),\\n    1: (-1, 0),\\n    2: (0, -1),\\n    3: (1, 0)\\n}\\n\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n        x = y = 0\\n        face = 0\\n        \\n        for i in instructions:\\n            if i == \"L\":\\n                face = (face + 1) % 4\\n            elif i == \"R\":\\n                face = (face + 3) % 4\\n            else:\\n                x += DIRECTIONS[face][0]\\n                y += DIRECTIONS[face][1]\\n\\n        return (x == 0 and y == 0) or face != 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nDIRECTIONS = {\\n    0: (0, 1),\\n    1: (-1, 0),\\n    2: (0, -1),\\n    3: (1, 0)\\n}\\n\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n        x = y = 0\\n        face = 0\\n        \\n        for i in instructions:\\n            if i == \"L\":\\n                face = (face + 1) % 4\\n            elif i == \"R\":\\n                face = (face + 3) % 4\\n            else:\\n                x += DIRECTIONS[face][0]\\n                y += DIRECTIONS[face][1]\\n\\n        return (x == 0 and y == 0) or face != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949358,
                "title": "easy-java-solution-using-hashmap-1ms",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        char[] ins = instructions.toCharArray();\\n        \\n        int[] start = new int[]{0,0};\\n        \\n        Map<Character, int[]> map = new HashMap<>();\\n        map.put(\\'N\\',new int[]{0,1});\\n        map.put(\\'S\\',new int[]{0,-1});\\n        map.put(\\'E\\',new int[]{1,0});\\n        map.put(\\'W\\',new int[]{-1,0});\\n        char facing = \\'N\\';\\n        int i =0;\\n       \\n        while(i < ins.length){\\n            if(ins[i] == \\'G\\'){\\n                start[0] = start[0]+map.get(facing)[0];\\n                start[1] = start[1]+map.get(facing)[1];\\n            } else if(ins[i] == \\'L\\'){\\n                if(facing == \\'N\\') facing = \\'W\\';\\n                else if(facing == \\'W\\') facing = \\'S\\';\\n                else if(facing == \\'S\\') facing = \\'E\\';\\n                else if(facing == \\'E\\') facing = \\'N\\';\\n            } else if(ins[i] == \\'R\\'){\\n                if(facing == \\'N\\') facing = \\'E\\';\\n                else if(facing == \\'E\\') facing = \\'S\\';\\n                else if(facing == \\'S\\') facing = \\'W\\';\\n                else if(facing == \\'W\\') facing = \\'N\\';\\n            }\\n            i++;\\n         \\n        }\\n        if(start[0] == 0 && start[1] == 0) return true;\\n        if(facing == \\'N\\') return false;// This means, robot will go out of circle\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        char[] ins = instructions.toCharArray();\\n        \\n        int[] start = new int[]{0,0};\\n        \\n        Map<Character, int[]> map = new HashMap<>();\\n        map.put(\\'N\\',new int[]{0,1});\\n        map.put(\\'S\\',new int[]{0,-1});\\n        map.put(\\'E\\',new int[]{1,0});\\n        map.put(\\'W\\',new int[]{-1,0});\\n        char facing = \\'N\\';\\n        int i =0;\\n       \\n        while(i < ins.length){\\n            if(ins[i] == \\'G\\'){\\n                start[0] = start[0]+map.get(facing)[0];\\n                start[1] = start[1]+map.get(facing)[1];\\n            } else if(ins[i] == \\'L\\'){\\n                if(facing == \\'N\\') facing = \\'W\\';\\n                else if(facing == \\'W\\') facing = \\'S\\';\\n                else if(facing == \\'S\\') facing = \\'E\\';\\n                else if(facing == \\'E\\') facing = \\'N\\';\\n            } else if(ins[i] == \\'R\\'){\\n                if(facing == \\'N\\') facing = \\'E\\';\\n                else if(facing == \\'E\\') facing = \\'S\\';\\n                else if(facing == \\'S\\') facing = \\'W\\';\\n                else if(facing == \\'W\\') facing = \\'N\\';\\n            }\\n            i++;\\n         \\n        }\\n        if(start[0] == 0 && start[1] == 0) return true;\\n        if(facing == \\'N\\') return false;// This means, robot will go out of circle\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678874,
                "title": "python-o-n-time-o-1-space-simple-solution",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direction = 0\\n        distX = 0\\n        distY = 0\\n        for instruction in instructions:\\n            if instruction == \\'L\\':\\n                direction -= 90\\n            elif instruction == \\'R\\':\\n                direction += 90\\n            else:\\n                if direction == 0:\\n                    distY += 1\\n                elif direction == 90 or direction == -270:\\n                    distX += 1\\n                elif direction == -90 or direction == 270:\\n                    distX -= 1\\n                else:\\n                    distY -= 1\\n            direction %= 360\\n        return direction != 0 or (distX == 0 and distY == 0)\\n```\\n\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direction = 0\\n        distX = 0\\n        distY = 0\\n        for instruction in instructions:\\n            if instruction == \\'L\\':\\n                direction -= 90\\n            elif instruction == \\'R\\':\\n                direction += 90\\n            else:\\n                if direction == 0:\\n                    distY += 1\\n                elif direction == 90 or direction == -270:\\n                    distX += 1\\n                elif direction == -90 or direction == 270:\\n                    distX -= 1\\n                else:\\n                    distY -= 1\\n            direction %= 360\\n        return direction != 0 or (distX == 0 and distY == 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678663,
                "title": "simplest-solution-c",
                "content": "- Idea is to traverse the whole string and check how far we can go in every four direction `+ x, - x, + y, - y`.\\n- after sufficient iteration I store the max values. \\n- then again iterate over string several times. \\n- at the end I compare if the `stored_maximum`, `stored_minimum` values still same with the updated `maxs, mins` or not.\\n- rest is the implementation\\n\\n```cpp\\nclass Solution {\\n    public:\\n    int max_x, max_y, min_x, min_y;\\n    int x, y;\\n    bool is_vertical;\\n    bool is_positive;\\n\\n    void update() {\\n        max_x = max(max_x, x);\\n        min_x = min(min_x, x);\\n        max_y = max(max_y, y);\\n        min_y = min(min_y, y);\\n    }\\n    void traverse(const string &s) {\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'G\\') {\\n                if (is_vertical)\\n                    (is_positive) ? y++ : y--;\\n                else\\n                    (is_positive) ? x++ : x--;\\n                update();\\n            } else if (s[i] == \\'L\\') {\\n                if (is_vertical)\\n                    (is_positive) ? (is_vertical = is_positive = false)\\n                    : (is_vertical = false, is_positive = true);\\n                else\\n                    (is_positive) ? (is_vertical = is_positive = true)\\n                    : (is_vertical = true, is_positive = false);\\n\\n            } else {\\n                if (is_vertical)\\n                    (is_positive) ? (is_vertical = false, is_positive = true)\\n                    : (is_vertical = false, is_positive = false);\\n                else\\n                    (is_positive) ? (is_vertical = true, is_positive = false)\\n                    : (is_vertical = true, is_positive = true);\\n            }\\n        }\\n    }\\n    bool isRobotBounded(string s) {\\n        max_x = INT_MIN, max_y = INT_MIN, min_x = INT_MAX, min_y = INT_MAX;\\n        x = 0, y = 0;\\n        is_vertical = false;\\n        is_positive = true;\\n\\n        for (int i = 0; i <= s.size(); i++)\\n            traverse(s);\\n\\n        int curr_max_x = max_x, curr_mx_y = max_y;\\n        int curr_min_x = min_x, curr_mn_y = min_y;\\n\\n        for (int i = 0; i < s.size(); i++)\\n            traverse(s);\\n\\n        return (curr_max_x == max_x and curr_mx_y == max_y and\\n                curr_min_x == min_x and curr_mn_y == min_y)\\n            ? true\\n            : false;\\n    }\\n} ob;\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n    public:\\n    int max_x, max_y, min_x, min_y;\\n    int x, y;\\n    bool is_vertical;\\n    bool is_positive;\\n\\n    void update() {\\n        max_x = max(max_x, x);\\n        min_x = min(min_x, x);\\n        max_y = max(max_y, y);\\n        min_y = min(min_y, y);\\n    }\\n    void traverse(const string &s) {\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'G\\') {\\n                if (is_vertical)\\n                    (is_positive) ? y++ : y--;\\n                else\\n                    (is_positive) ? x++ : x--;\\n                update();\\n            } else if (s[i] == \\'L\\') {\\n                if (is_vertical)\\n                    (is_positive) ? (is_vertical = is_positive = false)\\n                    : (is_vertical = false, is_positive = true);\\n                else\\n                    (is_positive) ? (is_vertical = is_positive = true)\\n                    : (is_vertical = true, is_positive = false);\\n\\n            } else {\\n                if (is_vertical)\\n                    (is_positive) ? (is_vertical = false, is_positive = true)\\n                    : (is_vertical = false, is_positive = false);\\n                else\\n                    (is_positive) ? (is_vertical = true, is_positive = false)\\n                    : (is_vertical = true, is_positive = true);\\n            }\\n        }\\n    }\\n    bool isRobotBounded(string s) {\\n        max_x = INT_MIN, max_y = INT_MIN, min_x = INT_MAX, min_y = INT_MAX;\\n        x = 0, y = 0;\\n        is_vertical = false;\\n        is_positive = true;\\n\\n        for (int i = 0; i <= s.size(); i++)\\n            traverse(s);\\n\\n        int curr_max_x = max_x, curr_mx_y = max_y;\\n        int curr_min_x = min_x, curr_mn_y = min_y;\\n\\n        for (int i = 0; i < s.size(); i++)\\n            traverse(s);\\n\\n        return (curr_max_x == max_x and curr_mx_y == max_y and\\n                curr_min_x == min_x and curr_mn_y == min_y)\\n            ? true\\n            : false;\\n    }\\n} ob;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678536,
                "title": "java-clear-crisp-approach-logic",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        int x = 0 , y = 0 ;\\n        // Initial Coordinate of  Robot(0,0)\\n        \\n        char currDirection = \\'N\\' ;\\n        // Initial Direction of our Robot         \\n        for(int i = 0 ; i < instructions.length() ; i++){\\n            \\n            //If the current instruction is \\'G\\' that means we need to check the current Direction of the Robot\\n            if(instructions.charAt(i) == \\'G\\'){\\n                y += currDirection == \\'N\\'? 1 : 0 ;  // If Robot goes North that means it gains a coordinate in y-axis \\n                y += currDirection == \\'S\\'?-1 : 0 ;  // If Robot goes South that means it loses a coordinate in y-axis \\n                x += currDirection == \\'E\\'? 1 : 0 ;  // If Robot goes East that means it gains a coordinate in x-axis \\n                x += currDirection == \\'W\\'?-1 : 0 ;  // If Robot goes West that means it loses a coordinate in x-axis \\n                \\n            }\\n            // If current Instruction is not \\'G\\' i.e it is either \\'L\\' or \\'R\\' int that case we have to change the current Direction of the Robot\\n            else{\\n                char ch = instructions.charAt(i) ; // ch holds current instruction\\n                \\n                /*\\n                 * If Robot is facing \\'North\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'West\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'East\\'\\n                */\\n                if(currDirection == \\'N\\'){\\n                    currDirection = ch==\\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'West\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'South\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'North\\'\\n                */\\n                else if(currDirection == \\'W\\'){\\n                    currDirection = ch==\\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'South\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'East\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'West\\'\\n                */\\n                else if(currDirection == \\'S\\'){\\n                    currDirection = ch==\\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'East\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'North\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'South\\'\\n                */\\n                else if(currDirection == \\'E\\'){\\n                    currDirection = ch==\\'L\\' ? \\'N\\' : \\'S\\' ;\\n                }\\n                \\n            }\\n            \\n        }\\n        /*Observation*/\\n        if((x==0 && y==0) || currDirection != \\'N\\' ){\\n            return true ;\\n        }\\n        return false ;\\n    }\\n}\\n```\\n**Observation :**\\n1.   If on complete execution of instruction the final direction is \\'**N**\\' this means no matter how many times we execute the instructions again and again the direction will not change i,e the Robot will go infinitely to \\'**N**\\' direction only and never return to the original starting point.\\n \\n2.  If on complete execution of instruction the final direction is either of \\'**S**\\' or \\'**E**\\' or \\'**W**\\' this means the Robot may be far from original starting point but it  has made some progress in terms of direction.\\nAfter  some other repetation of instructions there definitaly will come a point where it will be back to its starting position.\\n\\nThink practically, suppose there are only 2 directions right and left.\\nIf you go to a certain distance and at the end you face in other direction and repeat the same instruction, you will be back at the original starting point.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        int x = 0 , y = 0 ;\\n        // Initial Coordinate of  Robot(0,0)\\n        \\n        char currDirection = \\'N\\' ;\\n        // Initial Direction of our Robot         \\n        for(int i = 0 ; i < instructions.length() ; i++){\\n            \\n            //If the current instruction is \\'G\\' that means we need to check the current Direction of the Robot\\n            if(instructions.charAt(i) == \\'G\\'){\\n                y += currDirection == \\'N\\'? 1 : 0 ;  // If Robot goes North that means it gains a coordinate in y-axis \\n                y += currDirection == \\'S\\'?-1 : 0 ;  // If Robot goes South that means it loses a coordinate in y-axis \\n                x += currDirection == \\'E\\'? 1 : 0 ;  // If Robot goes East that means it gains a coordinate in x-axis \\n                x += currDirection == \\'W\\'?-1 : 0 ;  // If Robot goes West that means it loses a coordinate in x-axis \\n                \\n            }\\n            // If current Instruction is not \\'G\\' i.e it is either \\'L\\' or \\'R\\' int that case we have to change the current Direction of the Robot\\n            else{\\n                char ch = instructions.charAt(i) ; // ch holds current instruction\\n                \\n                /*\\n                 * If Robot is facing \\'North\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'West\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'East\\'\\n                */\\n                if(currDirection == \\'N\\'){\\n                    currDirection = ch==\\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'West\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'South\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'North\\'\\n                */\\n                else if(currDirection == \\'W\\'){\\n                    currDirection = ch==\\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'South\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'East\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'West\\'\\n                */\\n                else if(currDirection == \\'S\\'){\\n                    currDirection = ch==\\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'East\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'North\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'South\\'\\n                */\\n                else if(currDirection == \\'E\\'){\\n                    currDirection = ch==\\'L\\' ? \\'N\\' : \\'S\\' ;\\n                }\\n                \\n            }\\n            \\n        }\\n        /*Observation*/\\n        if((x==0 && y==0) || currDirection != \\'N\\' ){\\n            return true ;\\n        }\\n        return false ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678163,
                "title": "detailed-explanation-of-lee215-solution-intution-code-with-comments",
                "content": "**Intution**\\n// There are two cases in which the robot never leaves a circle\\n1) After the first iteration, the final coordinates of Robot are same as initial coordinates (i.e. [0,0])\\n2) If after first iteration the final coordinates are different but it points in some other direction except North, then in that case it will return to its initial position([0,0]) after max 3 more iterations.\\n    2.1) Suppose after first iteration it points in East Direction (90 degree clockwise) then after second iteration it will point in South Direction (90 degree clockwise) then after third iteration in West then in fourth iteration in North Direction (back to its origin)\\n    2.2) Suppose after first iteration it points in South Direction (180 degree clockwise) then after second iteration it will point in North Direction (180 degree clockwise) then after third iteration in South then in fourth iteration in North Direction (back to its origin)\\n    2.3) Suppose after first iteration it points in West Direction (270 degree clockwise) then after second iteration it will point in South Direction (180 degree clockwise) then after third iteration in East then in fourth iteration in North Direction (back to its origin).\\n  \\n// There is one case in which robot will leave a circle    \\n\\n 1. If robot points in North direction with different coordinates than its initial position after first iteration, then in second, third abd fourth iterations, it will continue to move forward inn north direction and will never comeback to origin\\n    \\n**Code Expanation**\\nLet the directions be\\nNorth = 0\\nEast = 1\\nSouth = 2\\nWest = 3\\n    \\nSo if robot is facing in North and we move it left, then it points in East direction i.e i+1. (since north is 0 and east is 1)\\n   if robot is facing in North and we move it right, then it points in West direction i.e i+3. (since north is 0 and west is 3)\\n      \\nGeneralising if we move the robot in Left then i=(i+1)%4\\n             if we move the ronot in Right then i=(i+3)%4\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {        \\n        int x=0, y=0;\\n        int i = 0;\\n        vector<vector<int>>dir ={{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        for(auto it: instructions) {\\n            if(it==\\'G\\') { //Moving it in the direction its pointing by one step\\n                x+=dir[i][0];\\n                y+=dir[i][1];\\n            }\\n            else if(it==\\'L\\') { //changing the direction rotating it 270 degree clockwise\\n                i=(i+3)%4;\\n            }\\n            else if(it==\\'R\\') { //changing the direction rotating it 90 degree clockwise\\n                i=(i+1)%4;\\n            }\\n        }\\n        // After one iteration either it doesnt point in north direction or it returns back to its initial coordinates{0,0}\\n        return (i!=0) || (x==0 && y==0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {        \\n        int x=0, y=0;\\n        int i = 0;\\n        vector<vector<int>>dir ={{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        for(auto it: instructions) {\\n            if(it==\\'G\\') { //Moving it in the direction its pointing by one step\\n                x+=dir[i][0];\\n                y+=dir[i][1];\\n            }\\n            else if(it==\\'L\\') { //changing the direction rotating it 270 degree clockwise\\n                i=(i+3)%4;\\n            }\\n            else if(it==\\'R\\') { //changing the direction rotating it 90 degree clockwise\\n                i=(i+1)%4;\\n            }\\n        }\\n        // After one iteration either it doesnt point in north direction or it returns back to its initial coordinates{0,0}\\n        return (i!=0) || (x==0 && y==0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677481,
                "title": "javascript-98-runtime-80-memory-usage-explained",
                "content": "Robot\\'s position is changed only if **G** instruction is executed. For **L** and **R** instructions only direction is changed. \\nTo track the position of the robot we need one variable ***dir*** which tells us that how the coordinates of the robot are changed if it moves to **east**, **west**, **north** or **south** direction.\\n\\n* **East**: x + 1, y \\n* **West**: x - 1, y\\n* **North**: x, y + 1\\n* **South**: x, y - 1 \\n\\nNow, We have to track that if robot follows instructions either ***G***, ***L*** or ***R*** then in which direction its face would be.\\nLet\\'s say currently robot\\'s face is in **North** direction and following instructions are executed.\\n* Instruction ***G***: **North** facing\\n* Instruction ***L***: **West** facing\\n* Instruction ***R***: **East** facing\\n\\nSimilarly, We keep all other scenarios in the ***face*** variable.\\n\\n**Algorithm:**\\n1. create ***dir*** and ***face*** variables as discussed above.\\n2. Initialize robot\\'s initial position and direction\\n3. Execute the instructions.\\n4. For each instruction, Change the position and direction\\n5. After executing all the instructions, \\n\\t\\t1. If robots reaches its initial position then return true; or\\n\\t\\t2. If its face is not in the North direction then return true\\n\\t\\t3. Otherwise, return false\\n\\n\\n\\n\\n\\n\\n```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nvar isRobotBounded = function(instructions) {\\n    const dir = {\\n        E: [1, 0],\\n        W: [-1, 0],\\n        N: [0, 1],\\n        S: [0, -1]\\n    };\\n    \\n    const face = {\\n        E: {\\n            G: \\'E\\',\\n            L: \\'N\\',\\n            R: \\'S\\'\\n        },\\n        W: {\\n            G: \\'W\\',\\n            L: \\'S\\',\\n            R: \\'N\\'\\n        },\\n        N: {\\n            G: \\'N\\',\\n            L: \\'W\\',\\n            R: \\'E\\'\\n        },\\n        S: {\\n            G: \\'S\\',\\n            L: \\'E\\',\\n            R: \\'W\\'\\n        }\\n    }\\n    \\n    let faced = \\'N\\';\\n    let pos = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        if(instructions[i] === \\'G\\') {\\n            pos.x += dir[faced][0];\\n            pos.y += dir[faced][1];   \\n        }\\n        faced = face[faced][instructions[i]];\\n    }\\n    \\n    if((pos.x === 0 && pos.y === 0) || faced !== \\'N\\') {\\n        return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nvar isRobotBounded = function(instructions) {\\n    const dir = {\\n        E: [1, 0],\\n        W: [-1, 0],\\n        N: [0, 1],\\n        S: [0, -1]\\n    };\\n    \\n    const face = {\\n        E: {\\n            G: \\'E\\',\\n            L: \\'N\\',\\n            R: \\'S\\'\\n        },\\n        W: {\\n            G: \\'W\\',\\n            L: \\'S\\',\\n            R: \\'N\\'\\n        },\\n        N: {\\n            G: \\'N\\',\\n            L: \\'W\\',\\n            R: \\'E\\'\\n        },\\n        S: {\\n            G: \\'S\\',\\n            L: \\'E\\',\\n            R: \\'W\\'\\n        }\\n    }\\n    \\n    let faced = \\'N\\';\\n    let pos = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        if(instructions[i] === \\'G\\') {\\n            pos.x += dir[faced][0];\\n            pos.y += dir[faced][1];   \\n        }\\n        faced = face[faced][instructions[i]];\\n    }\\n    \\n    if((pos.x === 0 && pos.y === 0) || faced !== \\'N\\') {\\n        return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677136,
                "title": "c-100-faster",
                "content": "* Key Observation \\n\\t* If the robot follows the same path 4 times and reaches the starting point then answer is true else it is false \\n* Code \\n\\t* ``` move ``` function returns the final co-ordinates after following the given path and starting co-ordinates\\n   \\n   \\n ````\\n \\n class Solution {\\npublic:\\n    \\n    pair<int,int> move(int x,int y,string &path)\\n    {\\n        \\n        int dx[4]={0,1,0,-1};\\n        int dy[4]={1,0,-1,0};\\n        \\n        int curr=0;\\n        \\n        int i=0;\\n        while(i<path.size())\\n        {\\n            if(path[i]==\\'G\\')\\n            {\\n                x+=dx[curr];\\n                y+=dy[curr];\\n            }\\n            else if(path[i]==\\'R\\')\\n            {\\n                curr=(curr+1)%4;\\n            }\\n            \\n            else\\n            {\\n                if(curr==0)curr=3;\\n                else curr--;\\n            }        \\n        \\n            \\n            i++;\\n        }\\n        pair<int,int> ret={x,y};\\n        return ret;\\n    }\\n    bool isRobotBounded(string p) {\\n     \\n        string path=p;\\n        path+=path;\\n        path+=path;\\n        pair<int,int> last =move(0,0,path);\\n\\n        if(last.first==0&&last.second==0)return true;\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "``` move ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676677,
                "title": "c-with-clear-explanation",
                "content": "After one simulation, there are 3 situations:\\n1. the Destination == Origin, in this case, the robot will always be trapped in a circle. (easy to understand)\\n2. the Destination != Origin && new_direction == old_direction, in this case, the robot will head towards one direction forever, so return false.\\n3. the Destination != Origin && new_direction != old_direction.\\n\\tThis case is a little bit complex.\\n\\tDraw a line between Destination and Origin, when you repeat the instructions, there will be edges that can build up a rectangle. (if we allow the robot to move in all directions, rectangle will be replaced by a equilateral polygon.)\\n\\tSo actually there is only one situation that we need to return false.\\n```\\nclass Solution {\\npublic:\\n    const int\\n        NORTH = 0,\\n        EAST = 1,\\n        SOUTH = 2,\\n        WEST = 3;\\n\\n\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0; // init position;\\n        int dir = NORTH;\\n        for(int i = 0; instructions[i]; i++) {\\n            if (instructions[i] == \\'L\\') {\\n                dir = (dir - 1 + 4) % 4;\\n            } else if (instructions[i] == \\'R\\') {\\n                dir = (dir + 1 + 4) % 4;\\n            } else {\\n                switch(dir) {\\n                    case 0:\\n                        y += 1;\\n                        break;\\n                    case 2:\\n                        y -= 1;\\n                        break;\\n                    case 3:\\n                        x -= 1;\\n                        break;\\n                    case 1:\\n                        x += 1;\\n                        break;\\n                }\\n            }\\n        }\\n        if ((x != 0 || y != 0) && dir == NORTH)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int\\n        NORTH = 0,\\n        EAST = 1,\\n        SOUTH = 2,\\n        WEST = 3;\\n\\n\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0; // init position;\\n        int dir = NORTH;\\n        for(int i = 0; instructions[i]; i++) {\\n            if (instructions[i] == \\'L\\') {\\n                dir = (dir - 1 + 4) % 4;\\n            } else if (instructions[i] == \\'R\\') {\\n                dir = (dir + 1 + 4) % 4;\\n            } else {\\n                switch(dir) {\\n                    case 0:\\n                        y += 1;\\n                        break;\\n                    case 2:\\n                        y -= 1;\\n                        break;\\n                    case 3:\\n                        x -= 1;\\n                        break;\\n                    case 1:\\n                        x += 1;\\n                        break;\\n                }\\n            }\\n        }\\n        if ((x != 0 || y != 0) && dir == NORTH)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348726,
                "title": "c-easy-understanding-with-comments-and-explantion",
                "content": "```\\n/**\\n * @brief \\n * A robot stands on initially stands at (0, 0) and face North.\\n * Using G, L, R instruction to assemble a command\\n * Return true, if exists a circle.\\n \\n * [Important] \\n *  Key of this question is the rotate instruction is 90 degrees, and 90 is a factor of 180 degrees.\\n *  This provides us an aspect, after a series of movements we might able elimates each movement.\\n *  With command movement k, there will eventually exist a movement that is 180 degree opposite of k.\\n *   - k + -k = 0\\n *  This represents the robot will finally get to the start spot.\\n * \\n *  However, if the robot remain in the same direction after a command and it\\'s location is not (0,0)\\n *  , the ideal situation would not occurs.\\n *  \\n *  As a result, if we want the result be true = circle exist, we should follow the condition below:\\n *  1. After a movement the direction is not north. \\n *  2. if it\\'s remain to north, it should be in (0,0)\\n */\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // movement - {x, y} with four direction\\n        vector<pair<int, int>> movement{\\n            {0, 1}, // N - idx 0\\n            {1, 0}, // E - idx 1\\n            {0, -1}, // S - idx 2\\n            {-1, 0} // W - idx 3\\n        };\\n        \\n        int locationX = 0, locationY = 0;\\n        int rotationIdx = 0;\\n\\n        for(int instr: instructions) {\\n            if(instr == \\'R\\') {\\n                rotationIdx++;\\n            }\\n            else if(instr == \\'L\\') {\\n                rotationIdx--;\\n            }\\n            else {\\n                // instr == \\'G\\', move the robot\\'s location according to the current facing side\\n                rotationIdx = rotationIdx % 4;\\n                if(rotationIdx < 0) {\\n                    // deal with a negative index\\n                    rotationIdx += 4;\\n                }\\n                locationX += movement[rotationIdx].first;\\n                locationY += movement[rotationIdx].second;\\n            }\\n        }\\n        \\n        if(rotationIdx % 4 == 0) {\\n            if(locationX == 0 && locationY == 0) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * @brief \\n * A robot stands on initially stands at (0, 0) and face North.\\n * Using G, L, R instruction to assemble a command\\n * Return true, if exists a circle.\\n \\n * [Important] \\n *  Key of this question is the rotate instruction is 90 degrees, and 90 is a factor of 180 degrees.\\n *  This provides us an aspect, after a series of movements we might able elimates each movement.\\n *  With command movement k, there will eventually exist a movement that is 180 degree opposite of k.\\n *   - k + -k = 0\\n *  This represents the robot will finally get to the start spot.\\n * \\n *  However, if the robot remain in the same direction after a command and it\\'s location is not (0,0)\\n *  , the ideal situation would not occurs.\\n *  \\n *  As a result, if we want the result be true = circle exist, we should follow the condition below:\\n *  1. After a movement the direction is not north. \\n *  2. if it\\'s remain to north, it should be in (0,0)\\n */\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // movement - {x, y} with four direction\\n        vector<pair<int, int>> movement{\\n            {0, 1}, // N - idx 0\\n            {1, 0}, // E - idx 1\\n            {0, -1}, // S - idx 2\\n            {-1, 0} // W - idx 3\\n        };\\n        \\n        int locationX = 0, locationY = 0;\\n        int rotationIdx = 0;\\n\\n        for(int instr: instructions) {\\n            if(instr == \\'R\\') {\\n                rotationIdx++;\\n            }\\n            else if(instr == \\'L\\') {\\n                rotationIdx--;\\n            }\\n            else {\\n                // instr == \\'G\\', move the robot\\'s location according to the current facing side\\n                rotationIdx = rotationIdx % 4;\\n                if(rotationIdx < 0) {\\n                    // deal with a negative index\\n                    rotationIdx += 4;\\n                }\\n                locationX += movement[rotationIdx].first;\\n                locationY += movement[rotationIdx].second;\\n            }\\n        }\\n        \\n        if(rotationIdx % 4 == 0) {\\n            if(locationX == 0 && locationY == 0) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238856,
                "title": "brute-force-approach-traversing-4-times",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        \\n        int x = 0, y = 0;\\n        char dir = \\'N\\';\\n        int count = 4;\\n        \\n        while(count--) {\\n            \\n            for(char ch : instructions) {\\n                \\n                if(ch == \\'G\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        y += 1;\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        y -= 1;\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        x += 1;\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        x -= 1;\\n                    }\\n                }\\n                \\n                else if(ch == \\'L\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        dir = \\'W\\';\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        dir = \\'E\\';\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        dir = \\'N\\';\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        dir = \\'S\\';\\n                    }\\n                }\\n                \\n                else if(ch == \\'R\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        dir = \\'E\\';\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        dir = \\'W\\';\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        dir = \\'S\\';\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        dir = \\'N\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (x == 0 and y == 0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        \\n        int x = 0, y = 0;\\n        char dir = \\'N\\';\\n        int count = 4;\\n        \\n        while(count--) {\\n            \\n            for(char ch : instructions) {\\n                \\n                if(ch == \\'G\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        y += 1;\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        y -= 1;\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        x += 1;\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        x -= 1;\\n                    }\\n                }\\n                \\n                else if(ch == \\'L\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        dir = \\'W\\';\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        dir = \\'E\\';\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        dir = \\'N\\';\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        dir = \\'S\\';\\n                    }\\n                }\\n                \\n                else if(ch == \\'R\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        dir = \\'E\\';\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        dir = \\'W\\';\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        dir = \\'S\\';\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        dir = \\'N\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (x == 0 and y == 0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225836,
                "title": "clean-javascript-solution-split-into-functions",
                "content": "```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nconst isRobotBounded = instructions => {\\n    let position = { x: 0, y: 0 };\\n    let orientation = \\'north\\';\\n    \\n    for (const instruction of [...instructions]) {\\n        ({ position, orientation } = execute(instruction, position, orientation));\\n    }\\n    \\n    return orientation !== \\'north\\' || (position.x === 0 && position.y === 0);\\n};\\n\\nconst execute = (instruction, position, orientation) => {\\n    switch (instruction) {\\n        case \\'G\\':\\n            return goOneUnit(position, orientation);\\n        case \\'L\\':\\n            return rotateLeft(position, orientation);\\n        case \\'R\\':\\n            return rotateRight(position, orientation);\\n    }\\n    \\n    throw new Error(`Unsupported operation ${instruction}`);\\n};\\n\\nconst goOneUnit = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position: {\\n                    x: position.x,\\n                    y: position.y + 1,\\n                },\\n                orientation,\\n            };\\n        case \\'east\\':\\n            return {\\n                position: {\\n                    x: position.x + 1,\\n                    y: position.y,\\n                },\\n                orientation,\\n            };\\n        case \\'south\\':\\n            return {\\n                position: {\\n                    x: position.x,\\n                    y: position.y -1,\\n                },\\n                orientation,\\n            };\\n        case \\'west\\':\\n            return {\\n                position: {\\n                    x: position.x - 1,\\n                    y: position.y,\\n                },\\n                orientation,\\n            };\\n    }\\n    \\n    throw new Error(`Invalid orientation ${orientation}`);\\n};\\n\\nconst rotateLeft = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position,\\n                orientation: \\'west\\',\\n            };\\n        case \\'west\\':\\n            return {\\n                position,\\n                orientation: \\'south\\',\\n            };\\n        case \\'south\\':\\n            return {\\n                position,\\n                orientation: \\'east\\',\\n            };\\n        case \\'east\\':\\n            return {\\n                position,\\n                orientation: \\'north\\',\\n            };\\n    }\\n    \\n    throw new Error(`Invalid rotate left operation: ${orientation}`);\\n}\\n\\nconst rotateRight = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position,\\n                orientation: \\'east\\',\\n            };\\n        case \\'east\\':\\n            return {\\n                position,\\n                orientation: \\'south\\',\\n            };\\n        case \\'south\\':\\n            return {\\n                position,\\n                orientation: \\'west\\',\\n            };\\n        case \\'west\\':\\n            return {\\n                position,\\n                orientation: \\'north\\',\\n            };\\n    }\\n    \\n    throw new Error(`Invalid rotate right operation: ${orientation}`);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nconst isRobotBounded = instructions => {\\n    let position = { x: 0, y: 0 };\\n    let orientation = \\'north\\';\\n    \\n    for (const instruction of [...instructions]) {\\n        ({ position, orientation } = execute(instruction, position, orientation));\\n    }\\n    \\n    return orientation !== \\'north\\' || (position.x === 0 && position.y === 0);\\n};\\n\\nconst execute = (instruction, position, orientation) => {\\n    switch (instruction) {\\n        case \\'G\\':\\n            return goOneUnit(position, orientation);\\n        case \\'L\\':\\n            return rotateLeft(position, orientation);\\n        case \\'R\\':\\n            return rotateRight(position, orientation);\\n    }\\n    \\n    throw new Error(`Unsupported operation ${instruction}`);\\n};\\n\\nconst goOneUnit = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position: {\\n                    x: position.x,\\n                    y: position.y + 1,\\n                },\\n                orientation,\\n            };\\n        case \\'east\\':\\n            return {\\n                position: {\\n                    x: position.x + 1,\\n                    y: position.y,\\n                },\\n                orientation,\\n            };\\n        case \\'south\\':\\n            return {\\n                position: {\\n                    x: position.x,\\n                    y: position.y -1,\\n                },\\n                orientation,\\n            };\\n        case \\'west\\':\\n            return {\\n                position: {\\n                    x: position.x - 1,\\n                    y: position.y,\\n                },\\n                orientation,\\n            };\\n    }\\n    \\n    throw new Error(`Invalid orientation ${orientation}`);\\n};\\n\\nconst rotateLeft = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position,\\n                orientation: \\'west\\',\\n            };\\n        case \\'west\\':\\n            return {\\n                position,\\n                orientation: \\'south\\',\\n            };\\n        case \\'south\\':\\n            return {\\n                position,\\n                orientation: \\'east\\',\\n            };\\n        case \\'east\\':\\n            return {\\n                position,\\n                orientation: \\'north\\',\\n            };\\n    }\\n    \\n    throw new Error(`Invalid rotate left operation: ${orientation}`);\\n}\\n\\nconst rotateRight = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position,\\n                orientation: \\'east\\',\\n            };\\n        case \\'east\\':\\n            return {\\n                position,\\n                orientation: \\'south\\',\\n            };\\n        case \\'south\\':\\n            return {\\n                position,\\n                orientation: \\'west\\',\\n            };\\n        case \\'west\\':\\n            return {\\n                position,\\n                orientation: \\'north\\',\\n            };\\n    }\\n    \\n    throw new Error(`Invalid rotate right operation: ${orientation}`);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079387,
                "title": "simple-easy-to-understand-java-solution-0ms-with-instructions",
                "content": "Here my goal is to find the final direction and position of the robot after a set of instructions. \\ndir = 0 means North; \\ndir = 1 means east; \\ndir = 2 means south; \\ndir = 3 means west; \\nand x = 0 and y=0 initially.\\n\\nNow using the **move() function** i am going to make a move(which is easy to understand). \\nfinally, If the robot is pointing a different direction then it will definitely come back after 4 moves so return true. Now, there is a case, If the direction is same but it is on the exact starting point then it will repeat that and it is bounded so return true.\\n\\nelse it will always moving in a direction and pointing to north after the instructions. So the displacement will always increase and hence will never come back.\\n```\\nclass Solution {\\n    int x,y,dir;\\n    public boolean isRobotBounded(String instructions) {\\n        x=0;\\n        y=0;\\n        dir=0;\\n        for(char c:instructions.toCharArray()){\\n            move(c);\\n        }\\n        \\n        if(dir!=0)return true;\\n        if(x==0 && y==0)return true;\\n        \\n        return false;\\n    }\\n    public void move(char c){\\n        if(c==\\'L\\'){\\n            dir++;\\n            if(dir==4)dir=0;\\n        }\\n        else if(c==\\'R\\'){\\n            dir--;\\n            if(dir==-1)dir=3;\\n        }\\n        else{ // it\\'s G\\n            if(dir==0){\\n                x--;\\n            }\\n            else if(dir==1){\\n                y++;\\n            }\\n            else if(dir==2){\\n                x++;\\n            }\\n            else{//dir ==3\\n                y--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int x,y,dir;\\n    public boolean isRobotBounded(String instructions) {\\n        x=0;\\n        y=0;\\n        dir=0;\\n        for(char c:instructions.toCharArray()){\\n            move(c);\\n        }\\n        \\n        if(dir!=0)return true;\\n        if(x==0 && y==0)return true;\\n        \\n        return false;\\n    }\\n    public void move(char c){\\n        if(c==\\'L\\'){\\n            dir++;\\n            if(dir==4)dir=0;\\n        }\\n        else if(c==\\'R\\'){\\n            dir--;\\n            if(dir==-1)dir=3;\\n        }\\n        else{ // it\\'s G\\n            if(dir==0){\\n                x--;\\n            }\\n            else if(dir==1){\\n                y++;\\n            }\\n            else if(dir==2){\\n                x++;\\n            }\\n            else{//dir ==3\\n                y--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950608,
                "title": "standard-java-solution",
                "content": "### Theory\\nNo tricks here, just simulate the robot movement. The robot is constraint if it ends back at the origin or if ends up elsewhere facing any direction but north.\\n\\n### Solution\\n```\\n    public boolean isRobotBounded(String instructions) {\\n        DIRECTION dir = DIRECTION.NORTH;\\n        int[] pos = new int[] {0, 0};\\n        for (int i = 0; i < instructions.length(); i++) {\\n            Character c = instructions.charAt(i);\\n            if (c == \\'G\\') move(dir, pos);\\n            else dir = turn(dir, c);\\n        }\\n        \\n        boolean atOrigin = pos[0] == 0 && pos[1] == 0;\\n        boolean facingNorth = dir == DIRECTION.NORTH;\\n        \\n        \\n        return atOrigin || !facingNorth;\\n        \\n    }\\n    \\n    private void move(DIRECTION dir, int[] pos) {\\n        if (dir == DIRECTION.NORTH) {\\n            pos[1]++;\\n        } else if (dir == DIRECTION.SOUTH) {\\n            pos[1]--;\\n        } else if (dir == DIRECTION.EAST) {\\n            pos[0]++;\\n        } else {\\n            pos[0]--;\\n        }\\n    }\\n    \\n    private DIRECTION turn(DIRECTION dir, Character c) {\\n        if (c == \\'L\\') {\\n            if (dir == DIRECTION.NORTH) return DIRECTION.WEST;\\n            else if (dir == DIRECTION.WEST) return DIRECTION.SOUTH;\\n            else if (dir == DIRECTION.SOUTH) return DIRECTION.EAST;\\n            else if (dir == DIRECTION.EAST) return DIRECTION.NORTH;\\n            return null;\\n        } else {\\n            if (dir == DIRECTION.NORTH) return DIRECTION.EAST;\\n            else if (dir == DIRECTION.EAST) return DIRECTION.SOUTH;\\n            else if (dir == DIRECTION.SOUTH) return DIRECTION.WEST;\\n            else if (dir == DIRECTION.WEST) return DIRECTION.NORTH;\\n            return null;\\n        }\\n    }\\n    \\n    private enum DIRECTION {\\n        NORTH, WEST, SOUTH, EAST;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isRobotBounded(String instructions) {\\n        DIRECTION dir = DIRECTION.NORTH;\\n        int[] pos = new int[] {0, 0};\\n        for (int i = 0; i < instructions.length(); i++) {\\n            Character c = instructions.charAt(i);\\n            if (c == \\'G\\') move(dir, pos);\\n            else dir = turn(dir, c);\\n        }\\n        \\n        boolean atOrigin = pos[0] == 0 && pos[1] == 0;\\n        boolean facingNorth = dir == DIRECTION.NORTH;\\n        \\n        \\n        return atOrigin || !facingNorth;\\n        \\n    }\\n    \\n    private void move(DIRECTION dir, int[] pos) {\\n        if (dir == DIRECTION.NORTH) {\\n            pos[1]++;\\n        } else if (dir == DIRECTION.SOUTH) {\\n            pos[1]--;\\n        } else if (dir == DIRECTION.EAST) {\\n            pos[0]++;\\n        } else {\\n            pos[0]--;\\n        }\\n    }\\n    \\n    private DIRECTION turn(DIRECTION dir, Character c) {\\n        if (c == \\'L\\') {\\n            if (dir == DIRECTION.NORTH) return DIRECTION.WEST;\\n            else if (dir == DIRECTION.WEST) return DIRECTION.SOUTH;\\n            else if (dir == DIRECTION.SOUTH) return DIRECTION.EAST;\\n            else if (dir == DIRECTION.EAST) return DIRECTION.NORTH;\\n            return null;\\n        } else {\\n            if (dir == DIRECTION.NORTH) return DIRECTION.EAST;\\n            else if (dir == DIRECTION.EAST) return DIRECTION.SOUTH;\\n            else if (dir == DIRECTION.SOUTH) return DIRECTION.WEST;\\n            else if (dir == DIRECTION.WEST) return DIRECTION.NORTH;\\n            return null;\\n        }\\n    }\\n    \\n    private enum DIRECTION {\\n        NORTH, WEST, SOUTH, EAST;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906465,
                "title": "explanation-with-drawings",
                "content": "The trick I found after several drawings of different trajectories is that, what really matters is the ***end point*** of the trajectory as well as the ***direction*** when the robot reaches the end point, regardless of what exactly the trajectory is. Thus, we can use a vector from start to end to represent all the trajectories from the same start to the same end. \\n\\nAs shown in the drawing below, each vector represents a trajectory with the given instructions. At the starting point, the robot is facing north. After excuting the instructions once, the robot stops at a point which is to the right of the direction that it faces at the beginning (North), with a angle of *theta*. There are four possible directions when the robot reaches the point:\\n1) Face north (upward), as the short black arrow. Then, when repeating the instructions, the robot will keep moving in the same direction forever. In this case, the robot can get back to the origin only if it returns to the origin after each excution of the given instructions (i.e., the vector has length 0).\\n2) Face south (downward), as the short blue arrow. Then, with one more excution of the instructions, the robot will return to the origin facing north, as when it starts.\\n3) Face east (right), as the short red arrow. In this case, note that the current direction (east) is 90 degrees to the right of the initial direction (north), and with each excution of the given instructions, the robot moves to a point which is to the right of the direction that it faces with a angle of *theta*. So the second vector is 90 degrees to the right of the direction of the first vector, the third vector is 90 degrees to the right of the direction of the second vector, and so on. Thus, four excutions of the instructions form a square and the robot moves back to the origin then.\\n4) Face west (left), as the short green arrow. It is the same as the red case but in opposite direction.\\n\\n***To summerize, the robot cannot return to origin only if after excuting the instructions once, it stops at a point which is not origin and face north.***\\n\\n![image](https://assets.leetcode.com/users/images/1310a8cd-165b-4232-9eda-1d4106e533f6_1603412056.5589578.png)\\n\\nNow, the problem is to:\\n1) find the ***direction*** at the end point (if not facing north, return True)\\n2) find the ***end point*** of each trajectory (if it is the origin, return True)\\n\\nTo find the direction at the end point, we only need to care about the number of \"L\" and \"R\" instructions. One \"L\" can cancel out one \"R\". In the code below, variable *count* denotes the amount (# of \"L\" - # of \"R\"). Once a \"L\" in the instructions, *count = count + 1*, once a \"R\" in the instructions, *count = count - 1*. *count* is reset to 0 once either \"L\" or \"R\" appears four times (i.e., *count == 4* or *count == -4*). If at last *count == 0*, it means the direction of the robot doesn\\'t change (i.e., face north).\\n\\nTo find the end point of a trajectory, just start from point (0, 0) and follow the instructions given to move the robot in the four directions [(0, 1), (-1, 0), (0, -1), (1, 0)] respectively.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        count = 0\\n        d     = 0\\n        \\n        loc   = (0, 0)\\n        dirs  = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n        \\n        for l in instructions:\\n            if l == \\'L\\':\\n                count = (count + 1) % 4\\n                d     = (d + 1) % 4\\n            \\n            if l == \\'R\\':\\n                count = (count - 1) % 4\\n                d     = (d - 1) % 4\\n            \\n            if l == \\'G\\':\\n                loc = (loc[0] + dirs[d][0], loc[1] + dirs[d][1])\\n        \\n        return count != 0 or loc == (0, 0)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        count = 0\\n        d     = 0\\n        \\n        loc   = (0, 0)\\n        dirs  = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n        \\n        for l in instructions:\\n            if l == \\'L\\':\\n                count = (count + 1) % 4\\n                d     = (d + 1) % 4\\n            \\n            if l == \\'R\\':\\n                count = (count - 1) % 4\\n                d     = (d - 1) % 4\\n            \\n            if l == \\'G\\':\\n                loc = (loc[0] + dirs[d][0], loc[1] + dirs[d][1])\\n        \\n        return count != 0 or loc == (0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851262,
                "title": "robot-bounded-in-circle-python-geometry-explanation-approaching-to-geometry",
                "content": "Before starting, I personally define this problem as a GEOMETRY problem because it uses coordiates and degrees.\\nAlthough the usage in this is simple and not as much difficult or complecated as that in questions possibly labeled hard, it is one of geometry questions.\\n\\nNow, we are going to move a robot which follows simple sets of rules.\\n1. Move 1 unit toward its facing direction by a single instruction of \\'G\\'.\\n2. Turn 90 degrees to the left with \\'L\\', whereas turn the same degree to the right with \\'R\\'.\\n\\nThe result will be ```true``` iff it creates a circle after being repeated.\\n\\nSince we have two values for the result, ```true``` or ```false```, we can choose that we are going to filter true things out or do it for the opposite direction. In this problem, choosing either way doesn\\'t make any difference. However, in certain problems, choosing one way makes your life much easier than doing the other way, or sometimes it would be the only way to solve a problem.\\n\\nI\\'m going to focus on finding **true cases** because I think I might read some clues in the description. The first thing we have to do is finding conditions to draw a circle. Needless to say, if a robot doesn\\'t move, it\\'ll draw a circle. Also, we can check it after 2 performs, 3 performs, ... to N performs.\\n\\nSo, the terminate conditions can be reduced to these two cases.\\n1. A robot returns to the origin after a set of instructions, 1 perform.\\n2. A robot returns to the origin after several sets of instructions, N performs.\\n\\nThe obstacle at this point is that the 2nd condition is not going to be helpful for us at all. Then, we should re-write it or approach this question from finding false cases.\\nThe conditions for false cases are\\n1. A robot **doesn\\'t return** to the origin after a set of instructions, 1 perform.\\n2. A robot **doesn\\'t return** to the origin after several sets of instructions, N performs.\\n\\nand the pain point was the number of performs so that it is not going to be helpful.\\nWhich means rewriting the 2nd condition is the only option to solve it and the key will be finding N, the number of performs.\\n\\nIt describs \\'*repeats instructions forever*\\' in the question, but it is quite obvious that we don\\'t need to play it infinitely to check whether it makes a circle after about 100 years later. Rather than that, it is more reasonable and delightful for us that it will be determined after several iterations. In other words, the key is recognizing how many times we have to repeat the same set of instructions to conclude and the number should be very small.\\n\\nSo, let\\'s find the number.\\nSomething of which property contains repeativeness in this problem is *degree*.\\nIt is a well-known fact that 360 degrees on a 2D coordiate system represents 0 degree as well. Since each ```\\'L\\'```, ```\\'R\\'``` operations rotates to the left and the right, respectively, a robot will face one of folloing four directions, *North, West, South, East*, at the end of instructions. And those points of compass can be denoted to ```(0,1), (-1, 0), (0, -1), (1, 0)```, respectively, as a vector representation.\\n\\nThanks to the property of degree, I think we have found the maximum N which is 4 because\\n* The possible cases of where a robot is facing after each perfom are North, West, South, East, which are the results of rotations of 0(or 360), 90, 180, 270 degrees toward the left, respectively \\n* In case of West, East, they need at least 4 performs to be a multiplication of 360 degrees\\n* In case of South, it needs at least two performs to be a multiplication of 360 degrees\\n* In case of North, it has to return after one perform; otherwise it goes somewhere else\\n\\nand 4 is L.C.M of 1,2,4.\\n\\nBecause 4 performs contain 1 peform, the naive code will be\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tinstructions *= 4\\n\\t\\tturns = [(0, 1), (-1,0), (0, -1), (1, 0)]\\n\\t\\tface = 0\\n\\t\\tx, y = 0, 0\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                face += 1\\n            elif instruction == \\'R\\':\\n                face -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdx, dy = turns[face%4]\\n\\t\\t\\t\\tx += dx\\n\\t\\t\\t\\ty += dy\\n\\t\\treturn x == 0 and y == 0\\n```\\nTime complexity is ```O(N)``` derived from ```O(4*N)```, where N is the length of instructions.\\nSpace complexity is the same because I assigned instructions again.\\n\\nAt this point, somebody wants not to multiply 4 because it wastes space, and I totally agree with that idea. Then, what if we can derive other terminate condition from findinds?\\n\\nMultiplied by 4 is performed to cover the results of facing West and East at the end of a instructions set. In other words, when a robot faces West and East, it returns to the origin after 4 performs. All we have to do is it is going to be applied to all situations. \\n\\nAccroding to these,\\n* Moving toward (x, y) and doing toward (-x, -y) after the movemet change nothing \\n* Changing sequence of movements doesn\\'t affect anything if the direction is perserved\\n* A set of instructions can be denoted to (x, y), which is the coordination of the point at the end of the instructions\\n\\nThe first perform moves the point toward (x, y) and the third perform will return the point to the origin because of changing sequence availibility. So does the combination of the second perform and the fourth perform, which are the reflection of each other. \\n\\nNow we can remove ```N``` in cases of facing West and East. \\nFunny thing is that in case of facing South, 2 performs exactly reflects each other. Of course, there is no possibility when a robot doesn\\'t return to the origin while facing North. That means we can define the terminate conditions again such that\\n* ```(x, y) == (0, 0)``` after singe perform\\n* ```(x, y) != (0, 0)``` and not facing North after single perfom\\n\\nWe can improve the code like\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tturns = [(0, 1), (-1,0), (0, -1), (1, 0)]\\n\\t\\tface = 0\\n\\t\\tx, y = 0, 0\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                face += 1\\n            elif instruction == \\'R\\':\\n                face -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdx, dy = turns[face%4]\\n\\t\\t\\t\\tx += dx\\n\\t\\t\\t\\ty += dy\\n\\t\\treturn (x, y) == (0, 0) or face%4\\n```\\n\\nAlso it could be \\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tx, y, dx, dy = 0, 0, 0, 1 # turns=[(0,1), (-1,0), (0,-1), (1,0)]\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                dx, dy = -dy, dx\\n            elif instruction == \\'R\\':\\n                dx, dy = dy, -dx\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx, y = x+dx, y+dy\\n\\t\\treturn (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n```\\nto reduce space usages by using direction\\'s charactar of repeativeness.\\n\\nTIme complexity is not going to be changed while Space complexity will be ```O(1)```.\\n\\nLast one.\\nAt this point, it is cristal clear that it can be easily solved if we started with vectors.\\nThat\\'s right. A lot of geometry and coordiation problems will be easier when you find the connection with vectors.\\nDespite the fact, I wanted to show how to approach to the answer in case of not recognizing it is a vector problem at the point of an interview or not having a solid confidence in math.\\n\\nI hope it would be helpful.\\n\\nAlso, I\\'m a very big fan of writing pythonic-code although this isn\\'t obviously.\\nSo, if you guys have a woderful idea, please don\\'t hesitate to share for others.\\n\\nThanks a lot for your attention.\\n\\np.s.) Any comment will be welcomed including typo, gramatical error since English is my second language.\\n",
                "solutionTags": [
                    "Python",
                    "Geometry"
                ],
                "code": "```true```\n```true```\n```false```\n```\\'L\\'```\n```\\'R\\'```\n```(0,1), (-1, 0), (0, -1), (1, 0)```\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tinstructions *= 4\\n\\t\\tturns = [(0, 1), (-1,0), (0, -1), (1, 0)]\\n\\t\\tface = 0\\n\\t\\tx, y = 0, 0\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                face += 1\\n            elif instruction == \\'R\\':\\n                face -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdx, dy = turns[face%4]\\n\\t\\t\\t\\tx += dx\\n\\t\\t\\t\\ty += dy\\n\\t\\treturn x == 0 and y == 0\\n```\n```O(N)```\n```O(4*N)```\n```N```\n```(x, y) == (0, 0)```\n```(x, y) != (0, 0)```\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tturns = [(0, 1), (-1,0), (0, -1), (1, 0)]\\n\\t\\tface = 0\\n\\t\\tx, y = 0, 0\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                face += 1\\n            elif instruction == \\'R\\':\\n                face -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdx, dy = turns[face%4]\\n\\t\\t\\t\\tx += dx\\n\\t\\t\\t\\ty += dy\\n\\t\\treturn (x, y) == (0, 0) or face%4\\n```\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tx, y, dx, dy = 0, 0, 0, 1 # turns=[(0,1), (-1,0), (0,-1), (1,0)]\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                dx, dy = -dy, dx\\n            elif instruction == \\'R\\':\\n                dx, dy = dy, -dx\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx, y = x+dx, y+dy\\n\\t\\treturn (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 850427,
                "title": "c-simple-solution-explained-100-time-60-space",
                "content": "The intuition to solve this problem is that our finite state machine is going to be in a cyclical condition in 2 cases:\\n* it does not move at the end of the tick;\\n* it points in a different direction.\\n\\nIn order to verify that, we set a few variables:\\n* `dir`, representing our direction in a `0 - 3` range, initially set to `0` (North);\\n* `x` and `y`, both initialised to `0` and meant to register the overall movement from the start;\\n* `moves` an array of updates associated with movements for different values of `dir`, which I admitted doing just to avoid having to type 4 different conditionals to update the coordinates, sacrificing a bit more of memory.\\n\\nThen we parse through the string of commands character by character, updating either `dir` (for either `\\'L\\'` or `\\'G\\'`) or `x` and `y` (for `\\'G\\'`) as we go.\\n\\nAt the end, I return if the robot either did not move at all at the end of the turn (both `x` and `y` are `0`) or if did not change its direction (`dir` is still set to `0`) :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // dir 0 => N, 1 => W, 2 => S, 3 => E\\n        int dir = 0, x = 0, y = 0,\\n\\t\\t// moving N, W, S and E\\n\\t\\tmoves[4][2] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        for (char c: instructions) {\\n            switch(c) {\\n                // going forward\\n\\t\\t\\t\\tcase \\'G\\':\\n                    // updating the coordinates\\n\\t\\t\\t\\t\\tx += moves[dir][0];\\n                    y += moves[dir][1];\\n                    break;\\n                // turning left\\n\\t\\t\\t\\tcase \\'L\\':\\n                    dir = (dir + 1) % 4;\\n                    break;\\n                // turning right\\n                case \\'R\\':\\n                    dir = (dir + 3) % 4;\\n                    break;\\n            }\\n        }\\n        // return if it didn\\'t move or didn\\'t turn\\n\\t\\treturn !x && !y || dir;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // dir 0 => N, 1 => W, 2 => S, 3 => E\\n        int dir = 0, x = 0, y = 0,\\n\\t\\t// moving N, W, S and E\\n\\t\\tmoves[4][2] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        for (char c: instructions) {\\n            switch(c) {\\n                // going forward\\n\\t\\t\\t\\tcase \\'G\\':\\n                    // updating the coordinates\\n\\t\\t\\t\\t\\tx += moves[dir][0];\\n                    y += moves[dir][1];\\n                    break;\\n                // turning left\\n\\t\\t\\t\\tcase \\'L\\':\\n                    dir = (dir + 1) % 4;\\n                    break;\\n                // turning right\\n                case \\'R\\':\\n                    dir = (dir + 3) % 4;\\n                    break;\\n            }\\n        }\\n        // return if it didn\\'t move or didn\\'t turn\\n\\t\\treturn !x && !y || dir;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293201,
                "title": "0ms-java-solution-fairly-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0, y = 0, vx = 0, vy = 1; // position (x, y), direction (vx, vy). \\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'G\\'){ // go 1 step along the direction (vx, vy), new positon = old position + 1*(vx, vy). \\n                x += vx; \\n                y += vy;\\n            }else if(c == \\'L\\'){ // turn left is (vx, vy) ->(-vy, vx)\\n                int tmp = vx;\\n                vx = -vy;\\n                vy = tmp;\\n            }else{ // trun right is (vx, vy) -> (vy, -vx)\\n                int tmp = vx;\\n                vx = vy;\\n                vy = -tmp;\\n            }\\n        }\\n        if(x*x + y*y > 0 && vx == 0 && vy == 1) return false; //if we travel some distance, in the meanwhile facing the north, sky is the limit!\\n        else return true; //stay the same position or travel an angle, with many steps you will be back, stuck in limbo. \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0, y = 0, vx = 0, vy = 1; // position (x, y), direction (vx, vy). \\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'G\\'){ // go 1 step along the direction (vx, vy), new positon = old position + 1*(vx, vy). \\n                x += vx; \\n                y += vy;\\n            }else if(c == \\'L\\'){ // turn left is (vx, vy) ->(-vy, vx)\\n                int tmp = vx;\\n                vx = -vy;\\n                vy = tmp;\\n            }else{ // trun right is (vx, vy) -> (vy, -vx)\\n                int tmp = vx;\\n                vx = vy;\\n                vy = -tmp;\\n            }\\n        }\\n        if(x*x + y*y > 0 && vx == 0 && vy == 1) return false; //if we travel some distance, in the meanwhile facing the north, sky is the limit!\\n        else return true; //stay the same position or travel an angle, with many steps you will be back, stuck in limbo. \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713619,
                "title": "java-simple-solution",
                "content": "# Intuition\\nIf robot is still facing north and not at origin, return false\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf robot is still facing north and not at origin, return false\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0, y = 0;\\n        char dir = \\'N\\';\\n        for(char ch : instructions.toCharArray()){\\n            if(ch == \\'G\\'){\\n                switch(dir){\\n                    case \\'N\\':   y++; break;\\n                    case \\'E\\':   x++; break;\\n                    case \\'W\\':   x--; break;\\n                    case \\'S\\':   y--; break;          \\n                }\\n            }\\n            else if( ch == \\'L\\'){\\n                switch(dir){\\n                    case \\'N\\':   dir = \\'W\\'; break;\\n                    case \\'E\\':   dir = \\'N\\'; break;\\n                    case \\'W\\':   dir = \\'S\\'; break;\\n                    case \\'S\\':   dir = \\'E\\'; break;       \\n                } \\n            }\\n            else{\\n                switch(dir){\\n                    case \\'N\\':   dir = \\'E\\'; break;\\n                    case \\'E\\':   dir = \\'S\\'; break;\\n                    case \\'W\\':   dir = \\'N\\'; break;\\n                    case \\'S\\':   dir = \\'W\\'; break;          \\n                }\\n            }\\n        }\\n\\n        if(x == 0 && y == 0) return true;\\n\\n        if(dir == \\'N\\') return false;\\n        \\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0, y = 0;\\n        char dir = \\'N\\';\\n        for(char ch : instructions.toCharArray()){\\n            if(ch == \\'G\\'){\\n                switch(dir){\\n                    case \\'N\\':   y++; break;\\n                    case \\'E\\':   x++; break;\\n                    case \\'W\\':   x--; break;\\n                    case \\'S\\':   y--; break;          \\n                }\\n            }\\n            else if( ch == \\'L\\'){\\n                switch(dir){\\n                    case \\'N\\':   dir = \\'W\\'; break;\\n                    case \\'E\\':   dir = \\'N\\'; break;\\n                    case \\'W\\':   dir = \\'S\\'; break;\\n                    case \\'S\\':   dir = \\'E\\'; break;       \\n                } \\n            }\\n            else{\\n                switch(dir){\\n                    case \\'N\\':   dir = \\'E\\'; break;\\n                    case \\'E\\':   dir = \\'S\\'; break;\\n                    case \\'W\\':   dir = \\'N\\'; break;\\n                    case \\'S\\':   dir = \\'W\\'; break;          \\n                }\\n            }\\n        }\\n\\n        if(x == 0 && y == 0) return true;\\n\\n        if(dir == \\'N\\') return false;\\n        \\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642530,
                "title": "simulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, d = 0;\\n        for(char c : instructions) {\\n            if(c == \\'G\\') {\\n                if(d % 4 == 0) y++;\\n                else if(d % 4 == 1) x++;\\n                else if(d % 4 == 2) y--;\\n                else x--;\\n            }\\n            else if(c == \\'R\\') d++;\\n            else d += 3; \\n        }\\n        return x == 0 && y == 0 || d % 4 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, d = 0;\\n        for(char c : instructions) {\\n            if(c == \\'G\\') {\\n                if(d % 4 == 0) y++;\\n                else if(d % 4 == 1) x++;\\n                else if(d % 4 == 2) y--;\\n                else x--;\\n            }\\n            else if(c == \\'R\\') d++;\\n            else d += 3; \\n        }\\n        return x == 0 && y == 0 || d % 4 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598330,
                "title": "c-hot-and-trending-solution-super-easy-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string s) {\\n        int x = 0;\\n        int y = 0;\\n        char dir = \\'N\\';\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'G\\'){\\n                switch(dir){\\n                    case \\'N\\': y += 1; break;\\n                    case \\'S\\': y -= 1; break;\\n                    case \\'E\\': x += 1; break;\\n                    case \\'W\\': x -= 1;\\n                }\\n            }\\n            else if(s[i] == \\'L\\'){\\n                switch(dir){\\n                    case \\'N\\': dir = \\'W\\'; break;\\n                    case \\'S\\': dir = \\'E\\'; break;\\n                    case \\'E\\': dir = \\'N\\'; break;\\n                    case \\'W\\': dir = \\'S\\';\\n                }\\n            }\\n            else{\\n                switch(dir){\\n                    case \\'N\\': dir = \\'E\\'; break;\\n                    case \\'S\\': dir = \\'W\\'; break;\\n                    case \\'E\\': dir = \\'S\\'; break;\\n                    case \\'W\\': dir = \\'N\\';\\n                }\\n            }\\n        }\\n        if(x == 0 && y == 0) return true;\\n        if(dir == \\'N\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string s) {\\n        int x = 0;\\n        int y = 0;\\n        char dir = \\'N\\';\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'G\\'){\\n                switch(dir){\\n                    case \\'N\\': y += 1; break;\\n                    case \\'S\\': y -= 1; break;\\n                    case \\'E\\': x += 1; break;\\n                    case \\'W\\': x -= 1;\\n                }\\n            }\\n            else if(s[i] == \\'L\\'){\\n                switch(dir){\\n                    case \\'N\\': dir = \\'W\\'; break;\\n                    case \\'S\\': dir = \\'E\\'; break;\\n                    case \\'E\\': dir = \\'N\\'; break;\\n                    case \\'W\\': dir = \\'S\\';\\n                }\\n            }\\n            else{\\n                switch(dir){\\n                    case \\'N\\': dir = \\'E\\'; break;\\n                    case \\'S\\': dir = \\'W\\'; break;\\n                    case \\'E\\': dir = \\'S\\'; break;\\n                    case \\'W\\': dir = \\'N\\';\\n                }\\n            }\\n        }\\n        if(x == 0 && y == 0) return true;\\n        if(dir == \\'N\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527420,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0;\\n        char d=\\'u\\';\\n        for(int i=0; i<instructions.size(); i++){\\n            if(instructions[i]==\\'G\\'){\\n                if(d==\\'u\\'){\\n                    y++;\\n                }\\n                else if(d==\\'d\\'){\\n                    y--;\\n                }\\n                else if(d==\\'l\\'){\\n                    x--;\\n                }\\n                else if(d==\\'r\\'){\\n                    x++;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\'){\\n                if(d==\\'u\\'){\\n                    d=\\'l\\';\\n                }\\n                else if(d==\\'d\\'){\\n                    d=\\'r\\';\\n                }\\n                else if(d==\\'l\\'){\\n                    d=\\'d\\';\\n                }\\n                else if(d==\\'r\\'){\\n                    d=\\'u\\';\\n                }\\n            }\\n            else if(instructions[i]==\\'R\\'){\\n                if(d==\\'u\\'){\\n                    d=\\'r\\';\\n                }\\n                else if(d==\\'d\\'){\\n                    d=\\'l\\';\\n                }\\n                else if(d==\\'l\\'){\\n                    d=\\'u\\';\\n                }\\n                else if(d==\\'r\\'){\\n                    d=\\'d\\';\\n                }\\n            }\\n        }\\n        if(x==0 && y==0 || d!=\\'u\\'){return true;}\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0;\\n        char d=\\'u\\';\\n        for(int i=0; i<instructions.size(); i++){\\n            if(instructions[i]==\\'G\\'){\\n                if(d==\\'u\\'){\\n                    y++;\\n                }\\n                else if(d==\\'d\\'){\\n                    y--;\\n                }\\n                else if(d==\\'l\\'){\\n                    x--;\\n                }\\n                else if(d==\\'r\\'){\\n                    x++;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\'){\\n                if(d==\\'u\\'){\\n                    d=\\'l\\';\\n                }\\n                else if(d==\\'d\\'){\\n                    d=\\'r\\';\\n                }\\n                else if(d==\\'l\\'){\\n                    d=\\'d\\';\\n                }\\n                else if(d==\\'r\\'){\\n                    d=\\'u\\';\\n                }\\n            }\\n            else if(instructions[i]==\\'R\\'){\\n                if(d==\\'u\\'){\\n                    d=\\'r\\';\\n                }\\n                else if(d==\\'d\\'){\\n                    d=\\'l\\';\\n                }\\n                else if(d==\\'l\\'){\\n                    d=\\'u\\';\\n                }\\n                else if(d==\\'r\\'){\\n                    d=\\'d\\';\\n                }\\n            }\\n        }\\n        if(x==0 && y==0 || d!=\\'u\\'){return true;}\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509395,
                "title": "c-easy-and-simple-solution-time-o-n-space-o-1",
                "content": "# Intuition\\nIn this problem we see that we just have to follow given instructions and see the outcome or the final position to check wether a loop will be created or not.\\nWe start at the origin facing north, we follow the given instruction once. after that we chck if we are  back at the origin or not. if we are back at the origin, it means that it is a loop and we return true.\\nNow the catch is that these statements/instructions are followed infinitely so, even after we follow the instructions once and do not reach the origin, we have to check the dirction we are facing at that time. If we are facing north direction, it means that we are not at the starting point and we will be moving towards north i.e. we will be moving away from the starting point thus no loop is created and we return false. If we are not facing north direction at the end, it means we will be not moving away from the starting point and thus a loop will be created later on.\\n\\n# Approach\\nWe take two variables x and y for the current position of the robot and a variable d for the current direction it is facing.\\niterate the instructions and update the values of x,y,d accordingly.\\nat last check if x==0 && y==0 || d!=north. if the condition is satisfied,return true otherwise return false.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0,y=0;char d=\\'N\\';  //starting pos and direction of robot\\n        for(auto i:instructions){\\n            if(i==\\'G\\'){ //updating the curr pos of the robot according to the direction\\n                if(d==\\'N\\'){y++;}\\n                else if(d==\\'E\\'){x++;}\\n                else if(d==\\'S\\'){y--;}\\n                else{x--;}    \\n            }\\n            else if(i==\\'L\\'){  // updating direction if left instruction\\n                if(d==\\'N\\'){d=\\'W\\';}  //change to west, if curr direction is north and so forth according to the left \\n                else if(d==\\'E\\'){d=\\'N\\';}\\n                else if(d==\\'S\\'){d=\\'E\\';}\\n                else{d=\\'S\\';}\\n            }\\n            else{   //updating direction if right instruction\\n                if(d==\\'N\\'){d=\\'E\\';}  //change to east, if curr direction is north and so forth according to the right\\n                else if(d==\\'E\\'){d=\\'S\\';}\\n                else if(d==\\'S\\'){d=\\'W\\';}\\n                else{d=\\'N\\';}\\n            }\\n        }\\n        if(x==0 && y==0 || d!=\\'N\\'){return true;} //cheacking the final conditions\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0,y=0;char d=\\'N\\';  //starting pos and direction of robot\\n        for(auto i:instructions){\\n            if(i==\\'G\\'){ //updating the curr pos of the robot according to the direction\\n                if(d==\\'N\\'){y++;}\\n                else if(d==\\'E\\'){x++;}\\n                else if(d==\\'S\\'){y--;}\\n                else{x--;}    \\n            }\\n            else if(i==\\'L\\'){  // updating direction if left instruction\\n                if(d==\\'N\\'){d=\\'W\\';}  //change to west, if curr direction is north and so forth according to the left \\n                else if(d==\\'E\\'){d=\\'N\\';}\\n                else if(d==\\'S\\'){d=\\'E\\';}\\n                else{d=\\'S\\';}\\n            }\\n            else{   //updating direction if right instruction\\n                if(d==\\'N\\'){d=\\'E\\';}  //change to east, if curr direction is north and so forth according to the right\\n                else if(d==\\'E\\'){d=\\'S\\';}\\n                else if(d==\\'S\\'){d=\\'W\\';}\\n                else{d=\\'N\\';}\\n            }\\n        }\\n        if(x==0 && y==0 || d!=\\'N\\'){return true;} //cheacking the final conditions\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383283,
                "title": "c-very-simple-approach-for-handling-directions-by-degree",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find if the robot in the end remains at any other position than origin(beginning point) and is in north direction, then by this we can conclude it will never be able to reach back at the same position with same direction.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is length of the string.\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int degree = 0, pointx = 0, pointy = 0;\\n        for(int i=0; i<instructions.size(); i++){\\n            if(instructions[i] == \\'G\\'){\\n                if(degree == 0) pointy += 1;\\n                else if(degree == 90 || degree == -270) pointx += 1;\\n                else if(degree == 180 || degree == -180) pointy -= 1;\\n                else if(degree == -90 || degree == 270) pointx -= 1;\\n            }\\n            else if(instructions[i] == \\'L\\'){\\n                degree -= 90;\\n                if(degree == -360) degree = 0;\\n            }\\n            else if(instructions[i] == \\'R\\'){\\n                degree += 90;\\n                if(degree == 360) degree = 0;\\n            }\\n        }\\n        if(degree == 0 && (pointx != 0 || pointy != 0)) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int degree = 0, pointx = 0, pointy = 0;\\n        for(int i=0; i<instructions.size(); i++){\\n            if(instructions[i] == \\'G\\'){\\n                if(degree == 0) pointy += 1;\\n                else if(degree == 90 || degree == -270) pointx += 1;\\n                else if(degree == 180 || degree == -180) pointy -= 1;\\n                else if(degree == -90 || degree == 270) pointx -= 1;\\n            }\\n            else if(instructions[i] == \\'L\\'){\\n                degree -= 90;\\n                if(degree == -360) degree = 0;\\n            }\\n            else if(instructions[i] == \\'R\\'){\\n                degree += 90;\\n                if(degree == 360) degree = 0;\\n            }\\n        }\\n        if(degree == 0 && (pointx != 0 || pointy != 0)) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974561,
                "title": "100-0-ms-easy-concise-proof",
                "content": "# UPVOTE PLS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/e1e3d1af-35d4-45d3-8239-a83fd4b6cf56_1672474349.4752996.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    public boolean isRobotBounded(String I) {\\n        int x=0,y=0,i=0,l=I.length(),D[][]={{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int j=0;j<l;j++){ char ch=I.charAt(j);\\n            if(ch==\\'L\\')  i=(i+3)%4;\\n            else if(ch==\\'R\\') i=(i+1)%4;\\n            else {\\n                x+=D[i][0];y+=D[i][1];\\n            }\\n        }return x==0 && y==0 || i>0;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    public boolean isRobotBounded(String I) {\\n        int x=0,y=0,i=0,l=I.length(),D[][]={{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int j=0;j<l;j++){ char ch=I.charAt(j);\\n            if(ch==\\'L\\')  i=(i+3)%4;\\n            else if(ch==\\'R\\') i=(i+1)%4;\\n            else {\\n                x+=D[i][0];y+=D[i][1];\\n            }\\n        }return x==0 && y==0 || i>0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2822746,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, i = 0;\\n        vector<vector<int>> d = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (char & ins : instructions)\\n            if (ins == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins == \\'L\\')\\n                i = (i + 3) % 4;\\n            else\\n                x += d[i][0], y += d[i][1];\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, i = 0;\\n        vector<vector<int>> d = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (char & ins : instructions)\\n            if (ins == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins == \\'L\\')\\n                i = (i + 3) % 4;\\n            else\\n                x += d[i][0], y += d[i][1];\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607311,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    vector <int> dx = {0,1,0,-1};\\n    vector <int> dy = {1,0,-1,0};\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int direction = 0,x=0,y=0;\\n        for(int i=0;i<instructions.length();i++){\\n            if(instructions[i] == \\'L\\')\\n                direction--;\\n            else if(instructions[i] == \\'R\\')\\n                direction++;\\n            else{\\n                x += dx[direction];\\n                y += dy[direction];\\n            }\\n            direction = (direction+4) % 4;\\n        }\\n        if(direction != 0 || (!x && !y))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    vector <int> dx = {0,1,0,-1};\\n    vector <int> dy = {1,0,-1,0};\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int direction = 0,x=0,y=0;\\n        for(int i=0;i<instructions.length();i++){\\n            if(instructions[i] == \\'L\\')\\n                direction--;\\n            else if(instructions[i] == \\'R\\')\\n                direction++;\\n            else{\\n                x += dx[direction];\\n                y += dy[direction];\\n            }\\n            direction = (direction+4) % 4;\\n        }\\n        if(direction != 0 || (!x && !y))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459963,
                "title": "c-100-faster-easy-to-understand",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int counter = 0;        bool shift = true;\\n        pair<int, int> pos = {0, 0};        \\n        int x = 0, y = 1;\\n        for(int i = 0; i < instructions.size(); ++i){\\n            if(instructions[i] == \\'L\\'){\\n                if(y == 1){\\n                    x = -1, y = 0;\\n                } else if(y == 0 && x == -1){\\n                    x = 0, y = -1;\\n                } else if(y == -1 && x == 0){\\n                    x = 1, y = 0;\\n                } else{\\n                    x = 0, y = 1;\\n                }\\n                ++counter;\\n            } else if(instructions[i] == \\'R\\'){\\n                if(y == 1){\\n                    x = 1, y = 0;\\n                } else if(y == 0 && x == -1){\\n                    x = 0, y = 1;\\n                } else if(y == -1 && x == 0){\\n                    x = -1, y = 0;\\n                } else{\\n                    x = 0, y = -1;\\n                }\\n                --counter;\\n            } else{\\n                pos = {pos.first + x, pos.second + y};\\n                shift = true;\\n            }\\n        }\\n        counter = counter % 4;\\n        \\n      \\n        if(counter != 0 || !shift || (pos.first == 0 && pos.second == 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Output**\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Robot Bounded In Circle.\\nMemory Usage: 6.2 MB, less than 52.55% of C++ online submissions for Robot Bounded In Circle.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int counter = 0;        bool shift = true;\\n        pair<int, int> pos = {0, 0};        \\n        int x = 0, y = 1;\\n        for(int i = 0; i < instructions.size(); ++i){\\n            if(instructions[i] == \\'L\\'){\\n                if(y == 1){\\n                    x = -1, y = 0;\\n                } else if(y == 0 && x == -1){\\n                    x = 0, y = -1;\\n                } else if(y == -1 && x == 0){\\n                    x = 1, y = 0;\\n                } else{\\n                    x = 0, y = 1;\\n                }\\n                ++counter;\\n            } else if(instructions[i] == \\'R\\'){\\n                if(y == 1){\\n                    x = 1, y = 0;\\n                } else if(y == 0 && x == -1){\\n                    x = 0, y = 1;\\n                } else if(y == -1 && x == 0){\\n                    x = -1, y = 0;\\n                } else{\\n                    x = 0, y = -1;\\n                }\\n                --counter;\\n            } else{\\n                pos = {pos.first + x, pos.second + y};\\n                shift = true;\\n            }\\n        }\\n        counter = counter % 4;\\n        \\n      \\n        if(counter != 0 || !shift || (pos.first == 0 && pos.second == 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Robot Bounded In Circle.\\nMemory Usage: 6.2 MB, less than 52.55% of C++ online submissions for Robot Bounded In Circle.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416399,
                "title": "simple-java-with-explanation",
                "content": "```\\n/*\\n    The below solution might seem long, but is very easy if you understand the intuition.\\n    If we think deep, at the end of the execution of all instructions if the robot remained in the \\n    initial coordinate, it is running into circles. \\n    Or if the direction has changed say for ex: S is the direction at the end of execution of instructions.\\n    that means if we execute the same instruction again, it would face north and go back the steps it has \\n    taken.\\n    \\n    Similarly, if the direction is set to E or W, if we execute the instruction 3 more times it would go back \\n    to where it was initially.\\n    \\n    So just return true, if initial direction has changed or if the coordinate hasnot changed.\\n*/\\n```\\n\\nclass Solution {\\n    \\n    class Coordinate{\\n        int x;\\n        int y;\\n        Coordinate(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public boolean isRobotBounded(String instructions) {\\n        char direction = \\'N\\';\\n        Coordinate curr = new Coordinate(0,0);\\n        \\n        for(int i=0;i<instructions.length();i++){\\n            char ins = instructions.charAt(i);\\n            direction = changeDirection(ins,direction);\\n            curr = changeCoordinate(ins, direction,curr);\\n        }\\n        \\n        int x = curr.x;\\n        int y= curr.y;\\n        return (curr.x==0 && curr.y==0) || direction!=\\'N\\';\\n    }\\n    \\n    // helper method to change coordinate.\\n    private Coordinate changeCoordinate(char ins, char currDir,Coordinate currCor){\\n        switch(currDir){\\n            case \\'N\\': \\n                if(ins==\\'G\\')\\n                    return new Coordinate(currCor.x,currCor.y+1);\\n                \\n            case \\'E\\': \\n                if(ins==\\'G\\')\\n                    return new Coordinate(currCor.x+1,currCor.y);\\n                \\n            case \\'W\\': \\n                if(ins==\\'G\\')\\n                    return new Coordinate(currCor.x-1,currCor.y);\\n\\n            case \\'S\\': \\n                if(ins==\\'G\\')\\n                    return new Coordinate(currCor.x,currCor.y-1);\\n                \\n            default: return currCor;\\n        }\\n    }\\n    \\n    //helper method to change direction.\\n    private char changeDirection(char ins,char currDir){\\n        switch(currDir){\\n            case \\'N\\':\\n                if(ins==\\'L\\')\\n                    return \\'W\\';\\n                else if(ins==\\'R\\')\\n                    return \\'E\\';\\n            case \\'W\\':\\n                if(ins==\\'L\\')\\n                    return \\'S\\';\\n                else if(ins==\\'R\\')\\n                    return \\'N\\';\\n            case \\'E\\':\\n                if(ins==\\'L\\')\\n                    return \\'N\\';\\n                else if(ins==\\'R\\')\\n                    return \\'S\\';\\n            case \\'S\\':\\n                if(ins==\\'L\\')\\n                    return \\'E\\';\\n                else if(ins==\\'R\\')\\n                    return \\'W\\';\\n            default:\\n                return currDir;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    The below solution might seem long, but is very easy if you understand the intuition.\\n    If we think deep, at the end of the execution of all instructions if the robot remained in the \\n    initial coordinate, it is running into circles. \\n    Or if the direction has changed say for ex: S is the direction at the end of execution of instructions.\\n    that means if we execute the same instruction again, it would face north and go back the steps it has \\n    taken.\\n    \\n    Similarly, if the direction is set to E or W, if we execute the instruction 3 more times it would go back \\n    to where it was initially.\\n    \\n    So just return true, if initial direction has changed or if the coordinate hasnot changed.\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2378324,
                "title": "best-beats-100-submissions",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool isRobotBounded(string S) {\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n\\n            for(int i = 0; i < S.size(); i++)\\n            {\\n                if(S[i] == \\'L\\')\\n                    direction = (direction + 3) % 4;\\n                else if(S[i] == \\'R\\')\\n                    direction = (direction + 1) % 4;\\n                else\\n                {\\n                    switch(direction)\\n                    {\\n                        case 0: {\\n                            y++;\\n                            break;\\n                        }\\n                        case 1: {\\n                            x++;\\n                            break;\\n                        }\\n                        case 2:{\\n                            y--;\\n                            break;\\n                        }\\n                        case 3:{\\n                            x--;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n\\n        if(direction != 0 || (x == 0 && y == 0))\\n                return true;\\n        else \\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isRobotBounded(string S) {\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n\\n            for(int i = 0; i < S.size(); i++)\\n            {\\n                if(S[i] == \\'L\\')\\n                    direction = (direction + 3) % 4;\\n                else if(S[i] == \\'R\\')\\n                    direction = (direction + 1) % 4;\\n                else\\n                {\\n                    switch(direction)\\n                    {\\n                        case 0: {\\n                            y++;\\n                            break;\\n                        }\\n                        case 1: {\\n                            x++;\\n                            break;\\n                        }\\n                        case 2:{\\n                            y--;\\n                            break;\\n                        }\\n                        case 3:{\\n                            x--;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n\\n        if(direction != 0 || (x == 0 && y == 0))\\n                return true;\\n        else \\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298635,
                "title": "python-straightforward-o-n-solution",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        hashmap={}\\n        start=[0,0]\\n        facing=\"N\"\\n        LA={\"N\":\"W\",\"W\":\"S\",\"S\":\"E\",\"E\":\"N\"}\\n        RC={\"N\":\"E\",\"E\":\"S\",\"S\":\"W\",\"W\":\"N\"}\\n        res=[]\\n        for i in instructions:\\n            if i==\"G\":\\n                if facing==\"N\": start[1] += 1\\n                elif facing==\"E\": start[0] += 1\\n                elif facing==\"W\": start[0] -= 1\\n                elif facing==\"S\": start[1] -= 1\\n            elif i==\"L\":\\n                facing=LA[facing]\\n            elif i==\"R\":\\n                facing=RC[facing]\\n        if start==[0,0] or facing!=\"N\": return True\\n        else: return False\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        hashmap={}\\n        start=[0,0]\\n        facing=\"N\"\\n        LA={\"N\":\"W\",\"W\":\"S\",\"S\":\"E\",\"E\":\"N\"}\\n        RC={\"N\":\"E\",\"E\":\"S\",\"S\":\"W\",\"W\":\"N\"}\\n        res=[]\\n        for i in instructions:\\n            if i==\"G\":\\n                if facing==\"N\": start[1] += 1\\n                elif facing==\"E\": start[0] += 1\\n                elif facing==\"W\": start[0] -= 1\\n                elif facing==\"S\": start[1] -= 1\\n            elif i==\"L\":\\n                facing=LA[facing]\\n            elif i==\"R\":\\n                facing=RC[facing]\\n        if start==[0,0] or facing!=\"N\": return True\\n        else: return False\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094926,
                "title": "c-solution-explained-100-faster-time-o-n-space-o-1",
                "content": "**It can be proved that after following the instruction once, if we are back at the origin or if we are at some other position and not facing towards north, then we will eventually reach the origin either after one or three more repetitions of the instructions**\\nThe proof for it requires a some mathematical understanding of co-ordinate geometry. Hence, I am skipping the proof in this discussion. I suggest you to try proving this once on your own if you are curious. If you are unable to prove this then I would be more than happy to share the proof with you (just ping me up once in the comments, if you wish to know the proof as well).\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // 0: North,  1: East, 2: South, 3: West\\n        vector<vector<int>>movement={{0,1},{1,0},{0,-1},{-1,0}}; // Movements in x, y co-ordinate according to direction \\n        int x=0,y=0,i=0;\\n        for(char c: instructions)\\n        {\\n            if(c==\\'R\\') i=(i+1)%4; // changing direction\\n            if(c==\\'L\\') i=(i+3)%4; // changing direction\\n            if(c==\\'G\\')\\n            {\\n                //  Moving according to current direction\\n                x+=movement[i][0];\\n                y+=movement[i][1];\\n            }\\n        }\\n        // In the end if we are at (0,0) then return true. Or if, we are at some other place and we are not facing North then we will reach at (0,0) either after 1 or 3 more steps. Hence return true.\\n        return  ((x==0 && y==0 ) || i!=0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // 0: North,  1: East, 2: South, 3: West\\n        vector<vector<int>>movement={{0,1},{1,0},{0,-1},{-1,0}}; // Movements in x, y co-ordinate according to direction \\n        int x=0,y=0,i=0;\\n        for(char c: instructions)\\n        {\\n            if(c==\\'R\\') i=(i+1)%4; // changing direction\\n            if(c==\\'L\\') i=(i+3)%4; // changing direction\\n            if(c==\\'G\\')\\n            {\\n                //  Moving according to current direction\\n                x+=movement[i][0];\\n                y+=movement[i][1];\\n            }\\n        }\\n        // In the end if we are at (0,0) then return true. Or if, we are at some other place and we are not facing North then we will reach at (0,0) either after 1 or 3 more steps. Hence return true.\\n        return  ((x==0 && y==0 ) || i!=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994516,
                "title": "c-easy-to-understand-robot-bounded",
                "content": "Irrespective of what path you take, the result is only based on your final direction and final distance from the origin. Possible cases to be in a cycle are:\\n1. First one is that after following the instructions, you **end up at origin** which clearly indicates that you are in a cycle irrespective of what direction you end up facing. This is because after following the instructions at max 4 times, you will be in initial state at origin and direction (0,1)\\n2. Second one is if you do not end up at origin after following the instructions, you must have a **direction different from the initial direction** to be in a cycle. This is because summing 4 vectors of same length from origin to final position and each at +90deg in case final direction is \\'L\\' or (-1,0) (or -90 in case final direction is \\'R\\' or (1,0)) will lead you to origin. Or in case the final direction is (0,-1), the vector will take you back to origin after two cycles only.\\n```\\nbool isRobotBounded(string instructions) {\\n        pair<int,int> start = make_pair(0,0), init_direction = make_pair(0,1);\\n        pair<int,int> direction = init_direction, dist = make_pair(0,0);\\n        for(auto& i:instructions) {\\n            switch(i) {\\n                case \\'G\\': {\\n                    dist.first += direction.first;\\n                    dist.second += direction.second; \\n                    break;\\n                }\\n                case \\'L\\': {\\n                    swap(direction.first, direction.second);\\n                    direction.first *= -1; \\n                    break;\\n                }\\n                case \\'R\\': {\\n                    swap(direction.first, direction.second);\\n                    direction.second *= -1; \\n                    break;\\n                }\\n            }\\n        }\\n        return (direction != init_direction || (!dist.first && !dist.second));\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Irrespective of what path you take, the result is only based on your final direction and final distance from the origin. Possible cases to be in a cycle are:\\n1. First one is that after following the instructions, you **end up at origin** which clearly indicates that you are in a cycle irrespective of what direction you end up facing. This is because after following the instructions at max 4 times, you will be in initial state at origin and direction (0,1)\\n2. Second one is if you do not end up at origin after following the instructions, you must have a **direction different from the initial direction** to be in a cycle. This is because summing 4 vectors of same length from origin to final position and each at +90deg in case final direction is \\'L\\' or (-1,0) (or -90 in case final direction is \\'R\\' or (1,0)) will lead you to origin. Or in case the final direction is (0,-1), the vector will take you back to origin after two cycles only.\\n```\\nbool isRobotBounded(string instructions) {\\n        pair<int,int> start = make_pair(0,0), init_direction = make_pair(0,1);\\n        pair<int,int> direction = init_direction, dist = make_pair(0,0);\\n        for(auto& i:instructions) {\\n            switch(i) {\\n                case \\'G\\': {\\n                    dist.first += direction.first;\\n                    dist.second += direction.second; \\n                    break;\\n                }\\n                case \\'L\\': {\\n                    swap(direction.first, direction.second);\\n                    direction.first *= -1; \\n                    break;\\n                }\\n                case \\'R\\': {\\n                    swap(direction.first, direction.second);\\n                    direction.second *= -1; \\n                    break;\\n                }\\n            }\\n        }\\n        return (direction != init_direction || (!dist.first && !dist.second));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1699551,
                "title": "c-self-explanatory-easy-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        char dir=\\'N\\';\\n        int x=0;int y=0;\\n        int n=instructions.size();\\n        for(int i=0;i<n;i++){\\n            \\n            //move straight\\n            if(instructions[i] == \\'G\\'){\\n                if(dir == \\'N\\') y+=1;\\n                else if(dir == \\'S\\') y-=1;\\n                else if(dir == \\'E\\') x+=1;\\n                else x-=1;\\n            }\\n            \\n            //turning to left direction\\n            else if(instructions[i] == \\'L\\'){\\n                if(dir == \\'N\\') dir=\\'W\\';\\n                else if(dir == \\'S\\') dir=\\'E\\';\\n                else if(dir == \\'E\\') dir=\\'N\\';\\n                else dir=\\'S\\';\\n            }\\n            \\n            //turning to right direction\\n            else{\\n                if(dir == \\'N\\') dir=\\'E\\';\\n                else if(dir == \\'S\\') dir=\\'W\\';\\n                else if(dir == \\'E\\') dir=\\'S\\';\\n                else dir=\\'N\\';\\n            }            \\n        }\\n        if(x==0 && y==0) return true;       //means it returns to original points.\\n        if(dir == \\'N\\') return false;               //since we are moving away from origin.\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        char dir=\\'N\\';\\n        int x=0;int y=0;\\n        int n=instructions.size();\\n        for(int i=0;i<n;i++){\\n            \\n            //move straight\\n            if(instructions[i] == \\'G\\'){\\n                if(dir == \\'N\\') y+=1;\\n                else if(dir == \\'S\\') y-=1;\\n                else if(dir == \\'E\\') x+=1;\\n                else x-=1;\\n            }\\n            \\n            //turning to left direction\\n            else if(instructions[i] == \\'L\\'){\\n                if(dir == \\'N\\') dir=\\'W\\';\\n                else if(dir == \\'S\\') dir=\\'E\\';\\n                else if(dir == \\'E\\') dir=\\'N\\';\\n                else dir=\\'S\\';\\n            }\\n            \\n            //turning to right direction\\n            else{\\n                if(dir == \\'N\\') dir=\\'E\\';\\n                else if(dir == \\'S\\') dir=\\'W\\';\\n                else if(dir == \\'E\\') dir=\\'S\\';\\n                else dir=\\'N\\';\\n            }            \\n        }\\n        if(x==0 && y==0) return true;       //means it returns to original points.\\n        if(dir == \\'N\\') return false;               //since we are moving away from origin.\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694103,
                "title": "java-easiest-solution-readable",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        String currentpos=\"north\";\\n        int x=0;\\n        int y=0;\\n        for(int i=0;i<instructions.length();i++){\\n            char alpha=instructions.charAt(i);\\n            switch(alpha){\\n                case \\'G\\':\\n                    currentpos=currentpos;\\n                    if(currentpos==\"north\"){\\n                        y+=1;\\n                    }else if(currentpos==\"west\"){\\n                        x-=1;\\n                    }else if(currentpos==\"south\"){\\n                        y-=1;\\n                    }else if(currentpos==\"east\"){\\n                        x+=1;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if(currentpos==\"north\"){\\n                        currentpos=\"west\";\\n                    }else if(currentpos==\"west\"){\\n                        currentpos=\"south\";\\n                    }else if(currentpos==\"south\"){\\n                        currentpos=\"east\";\\n                    }else if(currentpos==\"east\"){\\n                        currentpos=\"north\";\\n                    }\\n                    break;\\n                case \\'R\\':\\n                    if(currentpos==\"north\"){\\n                        currentpos=\"east\";\\n                    }else if(currentpos==\"east\"){\\n                        currentpos=\"south\";\\n                    }else if(currentpos==\"south\"){\\n                        currentpos=\"west\";\\n                    }else if(currentpos==\"west\"){\\n                        currentpos=\"north\";\\n                    }\\n                    break;\\n                \\n                    \\n            }\\n        }\\n        if(x==0&&y==0){return true;}\\n        if(currentpos==\"north\"){return false;}//if the robot is facing north then it\\'s not bounded inside a circle.\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        String currentpos=\"north\";\\n        int x=0;\\n        int y=0;\\n        for(int i=0;i<instructions.length();i++){\\n            char alpha=instructions.charAt(i);\\n            switch(alpha){\\n                case \\'G\\':\\n                    currentpos=currentpos;\\n                    if(currentpos==\"north\"){\\n                        y+=1;\\n                    }else if(currentpos==\"west\"){\\n                        x-=1;\\n                    }else if(currentpos==\"south\"){\\n                        y-=1;\\n                    }else if(currentpos==\"east\"){\\n                        x+=1;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if(currentpos==\"north\"){\\n                        currentpos=\"west\";\\n                    }else if(currentpos==\"west\"){\\n                        currentpos=\"south\";\\n                    }else if(currentpos==\"south\"){\\n                        currentpos=\"east\";\\n                    }else if(currentpos==\"east\"){\\n                        currentpos=\"north\";\\n                    }\\n                    break;\\n                case \\'R\\':\\n                    if(currentpos==\"north\"){\\n                        currentpos=\"east\";\\n                    }else if(currentpos==\"east\"){\\n                        currentpos=\"south\";\\n                    }else if(currentpos==\"south\"){\\n                        currentpos=\"west\";\\n                    }else if(currentpos==\"west\"){\\n                        currentpos=\"north\";\\n                    }\\n                    break;\\n                \\n                    \\n            }\\n        }\\n        if(x==0&&y==0){return true;}\\n        if(currentpos==\"north\"){return false;}//if the robot is facing north then it\\'s not bounded inside a circle.\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687315,
                "title": "c-easy-solution-19-lines-code-0-ms-runtime",
                "content": "When you run the instructions 4 times continuously and if you\\'re coming back to 0,0 then it can be contained inside a circle else not\\n\\n```\\nbool isRobotBounded(string s) {\\n        int l=0,x=0,y=0;\\n        s+=s;\\n        s+=s;\\n        for(char c:s){\\n            l+=c==\\'L\\';\\n            l-=c==\\'R\\';\\n            if(c==\\'G\\'){\\n                l=l%4;\\n                l+=4;\\n                l=l%4;\\n                if(l==0)y++;\\n                else if(l==1) x--;\\n                else if(l==2) y--;\\n                else if(l==3) x++;\\n            }\\n        }\\n        return x==0 && y==0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isRobotBounded(string s) {\\n        int l=0,x=0,y=0;\\n        s+=s;\\n        s+=s;\\n        for(char c:s){\\n            l+=c==\\'L\\';\\n            l-=c==\\'R\\';\\n            if(c==\\'G\\'){\\n                l=l%4;\\n                l+=4;\\n                l=l%4;\\n                if(l==0)y++;\\n                else if(l==1) x--;\\n                else if(l==2) y--;\\n                else if(l==3) x++;\\n            }\\n        }\\n        return x==0 && y==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679424,
                "title": "java-0-ms-explained",
                "content": "**Idea:**\\n* To change position (G), move one step along the current facing direction\\n* To turn left, `(X, Y) -> (-Y, X)`. [Read more here](https://math.stackexchange.com/questions/1330161/how-to-rotate-points-through-90-degree/1330166#1330166)\\n* To turn right, `(X, Y) -> (Y, -X)`\\n* At the end the robot is bounded if:\\n\\t* it returns to Origin (zero displacement), or\\n\\t* the facing direction has changed, which can happen with a change in either horizontal or vertical component of the direction\\n>**T/S:** O(n)/O(1), where n = size(instructions)\\n```\\npublic boolean isRobotBounded(String instructions) {\\n\\tvar x = 0; // horizontal position\\n\\tvar y = 0; // vertical position\\n\\tvar dirs = new int[]{0, 1}; // horizontal and vertical directions respectively, initially facing north\\n\\n\\tfor (var i = 0; i < instructions.length(); i++)\\n\\t\\tswitch (instructions.charAt(i)) {\\n\\t\\t\\tcase \\'G\\' -> {\\n\\t\\t\\t\\tx += dirs[0];\\n\\t\\t\\t\\ty += dirs[1];\\n\\t\\t\\t}\\n\\t\\t\\tcase \\'L\\' -> swap(dirs, true);\\n\\t\\t\\tcase \\'R\\' -> swap(dirs, false);\\n\\t\\t}\\n\\n\\treturn x == 0 && y == 0 || dirs[0] != 0 || dirs[1] != 1;\\n}\\n\\nprivate void swap(int[] dirs, boolean negativeY) {\\n\\tvar temp = dirs[0];\\n\\tdirs[0] = negativeY ? -dirs[1] : dirs[1];\\n\\tdirs[1] = negativeY ? temp : -temp;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n\\tvar x = 0; // horizontal position\\n\\tvar y = 0; // vertical position\\n\\tvar dirs = new int[]{0, 1}; // horizontal and vertical directions respectively, initially facing north\\n\\n\\tfor (var i = 0; i < instructions.length(); i++)\\n\\t\\tswitch (instructions.charAt(i)) {\\n\\t\\t\\tcase \\'G\\' -> {\\n\\t\\t\\t\\tx += dirs[0];\\n\\t\\t\\t\\ty += dirs[1];\\n\\t\\t\\t}\\n\\t\\t\\tcase \\'L\\' -> swap(dirs, true);\\n\\t\\t\\tcase \\'R\\' -> swap(dirs, false);\\n\\t\\t}\\n\\n\\treturn x == 0 && y == 0 || dirs[0] != 0 || dirs[1] != 1;\\n}\\n\\nprivate void swap(int[] dirs, boolean negativeY) {\\n\\tvar temp = dirs[0];\\n\\tdirs[0] = negativeY ? -dirs[1] : dirs[1];\\n\\tdirs[1] = negativeY ? temp : -temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679049,
                "title": "c-o-n-solution-100-time-thinking-process-explained",
                "content": "# Let us think through the algo\\n\\n\\uD83E\\uDD14 **My thoughts were like**\\n- Oh, let\\u2018s just add 1 if it turns left, and subtract 1 if right, then if we had (counter mod 4) == 1 -> we won... *wait why is it medium then* ><\\n- Although it helped with all the type-1 problems, we had type-2 problems (check picture) -> I decided to handle the exceptions, but there was too many of them\\n- So I thought to play with the resulting vector\\u2019s coordinates a little bit.\\n\\n![image](https://assets.leetcode.com/users/images/2a376280-7fe2-46d2-aedb-48d2fe92ec12_1641757488.1144092.jpeg)\\n\\n\\uD83E\\uDD16 **Thinking of the resulting move after the first set of commands, one can easily notice, that:**\\n- If we didn\\u2018t move after the whole bunch of instructions execution, we can catch our robot in a circle easily :)\\n- If we moved somewhere, but at the end we are pointing north again, the circle does not exist at all, it is like a building block for our robot to escape the circle. Check the picture if my explaination is too cloudy for you)\\n\\n![image](https://assets.leetcode.com/users/images/3c308f6a-57a3-4df8-b851-9c8cbfb25fed_1641758390.9230664.jpeg)\\n\\n\\uD83D\\uDED1 This is the way of deciding whether the circle exists, the rest is about code, then let\\u2018s go coding!\\n\\nProof that this is a 100%-time code: ![image](https://assets.leetcode.com/users/images/0c4e2d98-a935-4491-bd70-170cd3f02aa3_1641758701.2274578.png)\\n\\n\\uD83D\\uDCBB Code with comments downhere, **upvote if the explaination was helpful** please!\\n\\n```\\nclass Solution {\\n public:\\n  bool isRobotBounded(string instructions) {\\n    // current coords vector in (x, y)-form\\n    int current_vec[2] = {0, 0};\\n    // all turns possibilities clockwise in (x, y)-form\\n    int turns[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    // where is our robot pointing, index at turned list\\n    int index = 0;\\n    \\n    for (auto iteration : instructions) {\\n      if (iteration == \\'L\\' or iteration == \\'R\\') {\\n        // if we are turning left -> pointing ar index-1,\\n        // if right -> index+1\\n\\t\\t    index += iteration == \\'L\\' ? -1 : 1;\\n        // because -1 % 4 is still -1 -> out of bounds error\\n        index = (index % 4 + 4) % 4;\\n      }\\n      else if (iteration == \\'G\\') {\\n        // after all the turns going by the pointing vector\\n        current_vec[0] += turns[index][0];\\n        current_vec[1] += turns[index][1];\\n      }\\n    }\\n    // our robot stays in the circle iff it either changes direction...\\n    bool no_sideways_turn = !(turns[index][0] == 0 and turns[index][1] == 1); \\n    // ...or if it did not move at all!\\n    bool no_place_change = current_vec[0] == 0 and current_vec[1] == 0;\\n    \\n    return no_place_change or no_sideways_turn;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool isRobotBounded(string instructions) {\\n    // current coords vector in (x, y)-form\\n    int current_vec[2] = {0, 0};\\n    // all turns possibilities clockwise in (x, y)-form\\n    int turns[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    // where is our robot pointing, index at turned list\\n    int index = 0;\\n    \\n    for (auto iteration : instructions) {\\n      if (iteration == \\'L\\' or iteration == \\'R\\') {\\n        // if we are turning left -> pointing ar index-1,\\n        // if right -> index+1\\n\\t\\t    index += iteration == \\'L\\' ? -1 : 1;\\n        // because -1 % 4 is still -1 -> out of bounds error\\n        index = (index % 4 + 4) % 4;\\n      }\\n      else if (iteration == \\'G\\') {\\n        // after all the turns going by the pointing vector\\n        current_vec[0] += turns[index][0];\\n        current_vec[1] += turns[index][1];\\n      }\\n    }\\n    // our robot stays in the circle iff it either changes direction...\\n    bool no_sideways_turn = !(turns[index][0] == 0 and turns[index][1] == 1); \\n    // ...or if it did not move at all!\\n    bool no_place_change = current_vec[0] == 0 and current_vec[1] == 0;\\n    \\n    return no_place_change or no_sideways_turn;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678891,
                "title": "c-clean-and-clear-code-beats-100-fast-and-simple",
                "content": "```\\n bool isRobotBounded(string instructions) {\\n     /* North : 0,East:1,South:2,West:3\\n        Right : +1 ,Left : -1\\n        Coordinate change in each Direction N,E,S,W resp.\\n                    {0,1,0,-1}\\n                    {1,0,-1,0}\\n        */\\n        vector<int> xCo = {0,1,0,-1};\\n        vector<int> yCo = {1,0,-1,0};\\n        int x=0,y=0;//Initial coordinates of Robots\\n        int currentDirection =0;//North\\n        for(int i=0;i<instructions.size();i++)\\n        {\\n            if(instructions[i]==\\'R\\')\\n            {\\n                currentDirection = (currentDirection+1)%4;\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                currentDirection = (4+(currentDirection-1))%4; \\n            }\\n            else\\n            {\\n                x+=xCo[currentDirection];\\n                y+=yCo[currentDirection];\\n            }\\n        }\\n        return currentDirection != 0 || (x==0 && y==0);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool isRobotBounded(string instructions) {\\n     /* North : 0,East:1,South:2,West:3\\n        Right : +1 ,Left : -1\\n        Coordinate change in each Direction N,E,S,W resp.\\n                    {0,1,0,-1}\\n                    {1,0,-1,0}\\n        */\\n        vector<int> xCo = {0,1,0,-1};\\n        vector<int> yCo = {1,0,-1,0};\\n        int x=0,y=0;//Initial coordinates of Robots\\n        int currentDirection =0;//North\\n        for(int i=0;i<instructions.size();i++)\\n        {\\n            if(instructions[i]==\\'R\\')\\n            {\\n                currentDirection = (currentDirection+1)%4;\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                currentDirection = (4+(currentDirection-1))%4; \\n            }\\n            else\\n            {\\n                x+=xCo[currentDirection];\\n                y+=yCo[currentDirection];\\n            }\\n        }\\n        return currentDirection != 0 || (x==0 && y==0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678696,
                "title": "javascript-easy-to-understand-1-loop",
                "content": "// Image an x-y plane, the original posion is [0, 0], the final position is [x, y];\\n    // The following situations that robot will go away which is a false result:\\n    // the final posion is not original posion and direction is not changed.\\n    // And other situations will result to a circulation movement, that means robot won\\'t leave a circle,\\n    // and return true\\n    // This is why it happens. If the final posion is on the original position, no matter how the directions change, the next operations will take it back to original position.\\n    // If the final position is not original position, that means an offset happens at some direction and some distance. If the final direction is not changed, the same offset will happen after another operation. That is the robot will go away forever.\\n    // If the final direction is changed by 180 degree, the next operation will result to an oppsite offset which bring the robot back to the original position.\\n    // If the final direction is changed by 90 degree, the next operation will result to an 90 degree offset with the same distance changes. And four times of this happens will brings the robot to the original positions\\n    // set direction 0 -> up, 1 -> right, 2 -> down, 3 -> left.\\n    // if next direction is L, then direction substract 1 and add 4 then mod 4 (add 4 in case the number is less than 0)\\n    // which is simply plus 3 then mod 4.\\n    // if next direction is R, then direction add 1 then mod 4.\\n    // set original posion is [0, 0], original direction is 0 -> up.\\n    // record the final position and final direction.\\n\\t// If the final position is not original position and the final direction is still 0 (up), then return false, else return true\\n \\n ```\\nvar isRobotBounded = function(instructions) {\\n    let x = 0, y = 0;\\n    let direction = 0;\\n    for (let operation of instructions) {\\n        if (operation === \\'G\\') {\\n            if (direction === 0) { // up\\n                y++;\\n            } else if (direction === 1) { // right\\n                x++;\\n            } else if (direction === 2) { // down\\n                y--;\\n            } else { // left\\n                x--;\\n            }\\n        } else if (operation === \\'L\\') {\\n            direction = (direction + 3) % 4;\\n        } else {\\n            direction = (direction + 1) % 4;\\n        }\\n    }\\n    if ((x !== 0 || y !== 0) && direction === 0) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isRobotBounded = function(instructions) {\\n    let x = 0, y = 0;\\n    let direction = 0;\\n    for (let operation of instructions) {\\n        if (operation === \\'G\\') {\\n            if (direction === 0) { // up\\n                y++;\\n            } else if (direction === 1) { // right\\n                x++;\\n            } else if (direction === 2) { // down\\n                y--;\\n            } else { // left\\n                x--;\\n            }\\n        } else if (operation === \\'L\\') {\\n            direction = (direction + 3) % 4;\\n        } else {\\n            direction = (direction + 1) % 4;\\n        }\\n    }\\n    if ((x !== 0 || y !== 0) && direction === 0) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678569,
                "title": "c-solution-daily-leetcoding-challenge-jan-9",
                "content": "The robot can travel these 4 directions: d (0-up, 1-left, 2-down, 3-right) when it is in the north direction. The variables  `x` and `y` shows the positions of the robot on the plane . The variable `d` shows the direction of the robot.\\n\\nThe conditons to return true after all the iterations:\\n1. `d` should not be equal to 0\\n2.  The robot should return to origin, i.e., `x == 0 && y == 0`.\\n\\nTime Complexity : O(n)\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Robot Bounded In Circle.\\nMemory Usage: 6.3 MB, less than 19.45% of C++ online submissions for Robot Bounded In Circle.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) \\n    {\\n        int x = 0, y = 0;\\n        int d = 0;\\n        vector<vector<int>> pos= {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(auto i : instructions)\\n        {\\n            if(i == \\'G\\')\\n            {\\n                x += pos[d][0];\\n                y += pos[d][1];\\n            }\\n            else if(i == \\'L\\')\\n            {\\n                d = (d+3) % 4;\\n            }\\n            else if(i == \\'R\\')\\n            {\\n                d = (d+1) % 4;\\n            }\\n        }\\n        return (d != 0 || (x == 0 && y == 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Robot Bounded In Circle.\\nMemory Usage: 6.3 MB, less than 19.45% of C++ online submissions for Robot Bounded In Circle.\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) \\n    {\\n        int x = 0, y = 0;\\n        int d = 0;\\n        vector<vector<int>> pos= {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(auto i : instructions)\\n        {\\n            if(i == \\'G\\')\\n            {\\n                x += pos[d][0];\\n                y += pos[d][1];\\n            }\\n            else if(i == \\'L\\')\\n            {\\n                d = (d+3) % 4;\\n            }\\n            else if(i == \\'R\\')\\n            {\\n                d = (d+1) % 4;\\n            }\\n        }\\n        return (d != 0 || (x == 0 && y == 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678243,
                "title": "python-solution-leetcode-solution-neetcode-s-explanation",
                "content": "Idea:\\nExample - going left:\\n\\nif pos is [1,1],\\n\\n* (North in graph)\\ndirection is [0,1]  - we want to go left - we have to add to pos [-1,0] \\n\\n* (west in graph) \\ndirection is [-1,0]  - we want to go left - we have to add to pos [0,-1] \\n \\n* (south in graph) \\ndirection is [0,-1] we want to go left - we have to add to pos [1,0] \\n\\n* (east in graph) \\ndirection is [1,0] we want to go left - we have to add to pos [0,1] \\n\\nExample - going right:\\n\\nif pos is [1,1], \\n* (North in graph)\\ndirection is [0,1] we want to go right - we have to add to pos [1,0] \\n\\n* (west in graph) \\ndirection is [-1,0] we want to go right - we have to add to pos [0,1] \\n\\n* (south in graph)\\ndirection is [0,-1] we want to go right - we have to add to pos [-1,0] \\n\\n* (east in graph)\\ndirection is [1,0] we want to go right - we have to add to pos [0,-1] \\n\\nThat calculation brings us to the conclusion that:\\n* For going left we change the direction [x,y] to [-y,x]\\n* For going right we change the direction [x,y] to [y,-x]\\n\\nWe initialize position to 0,0 and direction to north.\\nIf position got back to original, or we changed original direction, the answer is True.\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirX, dirY = 0 , 1 # north\\n        x , y = 0 , 0\\n        \\n        for i in instructions:\\n            if i == \"G\":\\n                x , y = x + dirX, y + dirY\\n            elif i == \"L\":\\n                dirX, dirY = -1 * dirY , dirX\\n            else:\\n                dirX, dirY = dirY , -1 * dirX\\n                \\n        return (x,y) == (0,0) or (dirX , dirY) != (0,1) # if we are back at same point or if direction is not facing north after first circle. Then we are bound to come back and form a circle.\\n```\\n\\nWe do not need to run 4 cycles to identify the limit cycle trajectory. One cycle is enough. There could be two situations here.\\n\\nFirst, if the robot returns to the initial point after one cycle, that\\'s the limit cycle trajectory.\\n\\nSecond, if the robot doesn\\'t face north at the end of the first cycle, that\\'s the limit cycle trajectory. Once again, that\\'s the consequence of the plane symmetry for the repeated cycles.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirX, dirY = 0 , 1 # north\\n        x , y = 0 , 0\\n        \\n        for i in instructions:\\n            if i == \"G\":\\n                x , y = x + dirX, y + dirY\\n            elif i == \"L\":\\n                dirX, dirY = -1 * dirY , dirX\\n            else:\\n                dirX, dirY = dirY , -1 * dirX\\n                \\n        return (x,y) == (0,0) or (dirX , dirY) != (0,1) # if we are back at same point or if direction is not facing north after first circle. Then we are bound to come back and form a circle.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677892,
                "title": "1041-java-solution-robot-bounded-in-circle",
                "content": "Here is my solution for the Robot Bounded In Circle\\n```\\n    public boolean isRobotBounded(String instructions) {\\n        int[][] directions = {{0,1},{-1,0},{0,-1},{1,0}};       // Direction array [up, left, down, right]. Its index will be used in the below dir variable.\\n\\t\\tint mx = 0;                                                       // moving x coordinate of the robot\\n\\t\\tint my = 0;                                                       // moving y coordinate of the robot\\n        int dir = 0;          // direction variable to fetch the data from above direction array, default value is 0[up]. \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t// Now we will loop through the string instructions\\n\\t\\t// If we counter \\'G\\' then we will add the x and y coordinate of that particular x and y direction in the mx and my. \\n\\t\\t// If we counter \\'L\\' or \\'R\\' then as per the previous direction we will change the dir variable. \\n\\t\\tfor(int i = 0; i<instructions.length(); i++){  \\n            char ch = instructions.charAt(i);\\n            if(ch == \\'G\\'){\\n                mx += directions[dir][0];\\n                my += directions[dir][1];\\n            }else if(ch == \\'L\\'){\\n                if(dir == 0) dir = 1;\\n                else if(dir == 1) dir = 2;\\n                else if(dir == 2) dir = 3;\\n                else dir = 0;\\n            }else if(ch == \\'R\\'){\\n                if(dir == 0) dir = 3;\\n                else if(dir == 3) dir = 2;\\n                else if(dir == 2) dir = 1;\\n                else dir = 0;\\n            }\\n        }\\n        \\n\\t\\t// After the loop ends, there are two conditions to check. If they satisy return true or return false\\n\\t\\t// 1. If the robot\\'s x and y coordinate is 0 and 0 then it means that it has reached to its original position \\n\\t\\t// OR \\n\\t\\t// 2. If the direction is changed i.e dir is not 0 that means at some later point of time it will reach to its original position.\\n\\t\\t//( Think in the way of vectors)\\n        if((mx == 0 && my == 0)||(dir != 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n    public boolean isRobotBounded(String instructions) {\\n        int[][] directions = {{0,1},{-1,0},{0,-1},{1,0}};       // Direction array [up, left, down, right]. Its index will be used in the below dir variable.\\n\\t\\tint mx = 0;                                                       // moving x coordinate of the robot\\n\\t\\tint my = 0;                                                       // moving y coordinate of the robot\\n        int dir = 0;          // direction variable to fetch the data from above direction array, default value is 0[up]. \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t// Now we will loop through the string instructions\\n\\t\\t// If we counter \\'G\\' then we will add the x and y coordinate of that particular x and y direction in the mx and my. \\n\\t\\t// If we counter \\'L\\' or \\'R\\' then as per the previous direction we will change the dir variable. \\n\\t\\tfor(int i = 0; i<instructions.length(); i++){  \\n            char ch = instructions.charAt(i);\\n            if(ch == \\'G\\'){\\n                mx += directions[dir][0];\\n                my += directions[dir][1];\\n            }else if(ch == \\'L\\'){\\n                if(dir == 0) dir = 1;\\n                else if(dir == 1) dir = 2;\\n                else if(dir == 2) dir = 3;\\n                else dir = 0;\\n            }else if(ch == \\'R\\'){\\n                if(dir == 0) dir = 3;\\n                else if(dir == 3) dir = 2;\\n                else if(dir == 2) dir = 1;\\n                else dir = 0;\\n            }\\n        }\\n        \\n\\t\\t// After the loop ends, there are two conditions to check. If they satisy return true or return false\\n\\t\\t// 1. If the robot\\'s x and y coordinate is 0 and 0 then it means that it has reached to its original position \\n\\t\\t// OR \\n\\t\\t// 2. If the direction is changed i.e dir is not 0 that means at some later point of time it will reach to its original position.\\n\\t\\t//( Think in the way of vectors)\\n        if((mx == 0 && my == 0)||(dir != 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677690,
                "title": "my-attempt-to-give-an-intuitive-explanation-as-to-why-most-accepted-solutions-work",
                "content": "### There are four states in which robot may end up after executing the instruction one number of time:\\n\\n- Robots returns to its initial position in one operation hence `x = 0 & y = 0` in this case. (example: `GLLG`)\\n- Robot ends at some point `(x, y)` but faces `South` direction at the end so doing one more operation will reverse the changes and it returns to it initial position. (example: `GLL`)\\n- Robot ends up at some point `(x,y)` and faces either `West` or `East` direction which will take 3 more instructions to reverse the changes so in total of 4 times executions of the instruction robot will return to its original initial position.(example: `GL`)\\n- Robot ends up at some point `(x,y)` and faces `North` direction in which case it will never ever return to it\\'s initial position even after infinite numbers of executions of the instruction.(example: `GLR`)\\n\\n**JAVA Solution implementing above idea:**\\n\\n```java\\nclass Solution {\\n    public boolean isRobotBounded(String ins) {\\n        int x = 0, y = 0, i = 0, d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (int j = 0; j < ins.length(); ++j)\\n            if (ins.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; y += d[i][1];\\n            }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isRobotBounded(String ins) {\\n        int x = 0, y = 0, i = 0, d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (int j = 0; j < ins.length(); ++j)\\n            if (ins.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; y += d[i][1];\\n            }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677476,
                "title": "c-easy-robot-bounded-in-circle-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0,y=0;\\n        int dir = 0; //{ 0 = N, 1 = E , 2 = S , 3 = W}\\n        for(char c: instructions)\\n        {\\n            if(c==\\'G\\')\\n            {\\n                if(dir == 0)\\n                    x++;\\n                else if (dir == 1)\\n                    y++;\\n                else if (dir == 2)\\n                    x--;\\n                else if(dir == 3)\\n                    y--;\\n            }\\n            else if(c==\\'L\\')\\n                dir = (dir+1)%4;\\n            \\n            else if (c==\\'R\\')\\n                dir = (dir + 4 -1)%4;\\n        }\\n        \\n        //checking if it is on origin or not\\n        if(x==0 && y==0)\\n            return true;\\n        \\n        //checking if the vector is pointing towards north\\n        if(dir == 0)\\n            return false;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0,y=0;\\n        int dir = 0; //{ 0 = N, 1 = E , 2 = S , 3 = W}\\n        for(char c: instructions)\\n        {\\n            if(c==\\'G\\')\\n            {\\n                if(dir == 0)\\n                    x++;\\n                else if (dir == 1)\\n                    y++;\\n                else if (dir == 2)\\n                    x--;\\n                else if(dir == 3)\\n                    y--;\\n            }\\n            else if(c==\\'L\\')\\n                dir = (dir+1)%4;\\n            \\n            else if (c==\\'R\\')\\n                dir = (dir + 4 -1)%4;\\n        }\\n        \\n        //checking if it is on origin or not\\n        if(x==0 && y==0)\\n            return true;\\n        \\n        //checking if the vector is pointing towards north\\n        if(dir == 0)\\n            return false;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677067,
                "title": "simple-math-solution-python",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        position = [0, 0]\\n        direction = [0, 1]\\n        d = {\"L\": [[0, -1], [1, 0]], \"R\": [[0, 1], [-1, 0]]}\\n        \\n        for action in instructions:\\n            if action == \"G\":\\n                position[0] += direction[0]\\n                position[1] += direction[1]\\n            elif action == \"L\":\\n                direction = self.mal_mul(d[\"L\"], direction)\\n            else:\\n                direction = self.mal_mul(d[\"R\"], direction)\\n                \\n        return position == [0, 0] or direction != [0, 1]\\n                \\n        \\n        \\n        \\n    def mal_mul(self, M, v):\\n        \\n        return [M[0][0] * v[0] + M[0][1] * v[1], M[1][0] * v[0] + M[1][1] * v[1]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        position = [0, 0]\\n        direction = [0, 1]\\n        d = {\"L\": [[0, -1], [1, 0]], \"R\": [[0, 1], [-1, 0]]}\\n        \\n        for action in instructions:\\n            if action == \"G\":\\n                position[0] += direction[0]\\n                position[1] += direction[1]\\n            elif action == \"L\":\\n                direction = self.mal_mul(d[\"L\"], direction)\\n            else:\\n                direction = self.mal_mul(d[\"R\"], direction)\\n                \\n        return position == [0, 0] or direction != [0, 1]\\n                \\n        \\n        \\n        \\n    def mal_mul(self, M, v):\\n        \\n        return [M[0][0] * v[0] + M[0][1] * v[1], M[1][0] * v[0] + M[1][1] * v[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677059,
                "title": "easy-c-approach-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dirx=1, diry=0 , x=0,y=0,d=0;\\n        int dir[4][2]={{1,0},\\n                {0,1},\\n                {-1,0},\\n                {0,-1}};\\n        for(auto a: instructions){\\n            if(a==\\'G\\'){\\n                if(dirx!=0){\\n                    x+=dirx;\\n                }else{\\n                    y+=diry;\\n                }\\n            }else if(a==\\'L\\'){\\n                d++;\\n                d%=4;\\n                dirx=dir[d][0];\\n                diry=dir[d][1];\\n            }else{\\n                d+=3;\\n                d%=4;\\n                dirx=dir[d][0];\\n                diry=dir[d][1];\\n            }\\n        }\\n        if(x==0 and y==0)return true;\\n        if(dirx!=1 or diry!=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dirx=1, diry=0 , x=0,y=0,d=0;\\n        int dir[4][2]={{1,0},\\n                {0,1},\\n                {-1,0},\\n                {0,-1}};\\n        for(auto a: instructions){\\n            if(a==\\'G\\'){\\n                if(dirx!=0){\\n                    x+=dirx;\\n                }else{\\n                    y+=diry;\\n                }\\n            }else if(a==\\'L\\'){\\n                d++;\\n                d%=4;\\n                dirx=dir[d][0];\\n                diry=dir[d][1];\\n            }else{\\n                d+=3;\\n                d%=4;\\n                dirx=dir[d][0];\\n                diry=dir[d][1];\\n            }\\n        }\\n        if(x==0 and y==0)return true;\\n        if(dirx!=1 or diry!=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677046,
                "title": "easy-java-solution",
                "content": "```\\n// In case of Left and right just change face.\\n// In case of \\'G\\' just move towards face. \\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n        char[] fx = instructions.toCharArray();\\n\\n        char face = \\'N\\';\\n        int counter = 4;\\n        while(counter-- > 0){\\n            for (char c: fx) {\\n                if (c == \\'L\\') {\\n                    if (face == \\'N\\') face = \\'W\\';\\n                    else if (face == \\'W\\') face = \\'S\\';\\n                    else if (face == \\'S\\') face = \\'E\\';\\n                    else face = \\'N\\';\\n                }\\n\\n                if (c == \\'R\\') {\\n                    if (face == \\'N\\') face = \\'E\\';\\n                    else if (face == \\'E\\') face = \\'S\\';\\n                    else if (face == \\'S\\') face = \\'W\\';\\n                    else face = \\'N\\';\\n                }\\n\\n                if(c == \\'G\\'){\\n                    if (face == \\'N\\') y += 1;\\n                    if (face == \\'S\\') y -= 1;\\n                    if (face == \\'W\\') x -= 1;\\n                    if (face == \\'E\\') x += 1;\\n                }\\n            }\\n            if(x == 0 && y == 0)break;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n        char[] fx = instructions.toCharArray();\\n\\n        char face = \\'N\\';\\n        int counter = 4;\\n        while(counter-- > 0){\\n            for (char c: fx) {\\n                if (c == \\'L\\') {\\n                    if (face == \\'N\\') face = \\'W\\';\\n                    else if (face == \\'W\\') face = \\'S\\';\\n                    else if (face == \\'S\\') face = \\'E\\';\\n                    else face = \\'N\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1676814,
                "title": "c-intuitive-solution-w-clear-explanation",
                "content": "* By intuition, if after a sequence of indstructions, the robot returns to the initial position or changes direction, then it\\'s bounded in a circle otherwise not.\\n \\n* If the intruction is ```\\'G\\'```, ```x``` & ```y``` coordinates of the robot change according to the following rules :\\n        1.  If current direction is North, then \\u2018G\\u2019 increments y and doesn\\u2019t change x. \\n        2. If current direction is East, then \\u2018G\\u2019 increments x and doesn\\u2019t change y. \\n        3. If current direction is South, then \\u2018G\\u2019 decrements y and doesn\\u2019t change x. \\n        4. If current direction is West, then \\u2018G\\u2019 decrements x and doesn\\u2019t change y.\\n* If the instructions are ```\\'L\\'``` & ```\\'R\\'```, then ```x``` & ```y``` coordinates don\\'t change but the direction changes accoding to the following rules :\\n       1. If current direction is North, then \\u2018L\\u2019 changes direction to West and \\u2018R\\u2019 changes to East \\n       2. If current direction is East, then \\u2018L\\u2019 changes direction to North and \\u2018R\\u2019 changes to South \\n       3. If current direction is South, then \\u2018L\\u2019 changes direction to East and \\u2018R\\u2019 changes to West \\n       4. If current direction is West, then \\u2018L\\u2019 changes direction to South and \\u2018R\\u2019 changes to North.\\n\\nLet\\'s implement this idea using code ;)\\n\\n**Code :**\\n```\\n#define N 0\\n#define W 1\\n#define S 2\\n#define E 3\\n\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0, i=0;\\n        for(auto ins : instructions){\\n            if(ins == \\'G\\'){\\n                switch(i){\\n                    case 0 :  //N\\n                        y++;\\n                        break;\\n                    case 1 :  //W\\n                        x--;\\n                        break;\\n                    case 2 :  //S\\n                        y--;\\n                        break;\\n                    case 3 :  //E\\n                        x++;\\n                        break;\\n                }\\n            }else if(ins == \\'L\\') i = (i+1)%4; //%4 is done so that i remains in range [0, 3]\\n            \\n            else i = (i+3)%4;\\n        }\\n        return x==0 && y==0 || i != 0;\\n    }\\n};\\n```\\n\\nLet\\'s modify the above code a little bit :)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions){\\n        vector<vector<int>> dir = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        \\n        int i=0, x=0, y=0;\\n        \\n        for(auto ins : instructions){\\n            if(ins == \\'G\\'){\\n                x += dir[i][0]; y += dir[i][1];\\n            }\\n            else if(ins == \\'L\\') i = (i+1)%4;\\n            \\n            else i = (i+3)%4;   \\n        }\\n        return (x==0 && y==0) || i!=0;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(n) - n=size of the string\\n\\n**Space Complexity :** O(1)\\n\\n**If you like my solutions & explanation, please do upvote my post :)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\'G\\'```\n```x```\n```y```\n```\\'L\\'```\n```\\'R\\'```\n```x```\n```y```\n```\\n#define N 0\\n#define W 1\\n#define S 2\\n#define E 3\\n\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0, i=0;\\n        for(auto ins : instructions){\\n            if(ins == \\'G\\'){\\n                switch(i){\\n                    case 0 :  //N\\n                        y++;\\n                        break;\\n                    case 1 :  //W\\n                        x--;\\n                        break;\\n                    case 2 :  //S\\n                        y--;\\n                        break;\\n                    case 3 :  //E\\n                        x++;\\n                        break;\\n                }\\n            }else if(ins == \\'L\\') i = (i+1)%4; //%4 is done so that i remains in range [0, 3]\\n            \\n            else i = (i+3)%4;\\n        }\\n        return x==0 && y==0 || i != 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions){\\n        vector<vector<int>> dir = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        \\n        int i=0, x=0, y=0;\\n        \\n        for(auto ins : instructions){\\n            if(ins == \\'G\\'){\\n                x += dir[i][0]; y += dir[i][1];\\n            }\\n            else if(ins == \\'L\\') i = (i+1)%4;\\n            \\n            else i = (i+3)%4;   \\n        }\\n        return (x==0 && y==0) || i!=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676745,
                "title": "python3-linear-explained",
                "content": "The robot stays in the circle only if at the end of instructions the angle between the final heading vector and the initial vector is not equal to 0. Only one exclusion is the case when the final position is the initial position. In this case, the final heading is not important, because it doesn\\'t matter where the robot moves, it will always return to the start point. To find angle between two vectors we could use formula `cos(angle) = a dot b / |a| * |b|`. But in our case, the robot can have just 4 different directions, so comparing the initial and final headings will be enough.\\n\\nWhy the angle between two directions is important? The robot executes instructions forever, so if at the end of the first run it looks in the same directions and it\\'s not in the starting position that means the distance from the start will increase constantly as the robot will repeat THE SAME moves over and over again. If the angle is different that means that the robot will spin within a certain bounded area.\\n\\nTime: **O(n)** - for instructions\\nSpace: **O(1)** - nothing stored\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        pos, head = (0, 0), 0\\n\\t\\t\\n        for ch in instructions:\\n            if ch == \"G\":\\n                pos = (pos[0] + dirs[head][0], pos[1] + dirs[head][1])\\n            elif ch == \"L\":\\n                head = (head - 1) % 4\\n            else:\\n                head = (head + 1) % 4\\n\\n        return pos == (0, 0) or head != 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        pos, head = (0, 0), 0\\n\\t\\t\\n        for ch in instructions:\\n            if ch == \"G\":\\n                pos = (pos[0] + dirs[head][0], pos[1] + dirs[head][1])\\n            elif ch == \"L\":\\n                head = (head - 1) % 4\\n            else:\\n                head = (head + 1) % 4\\n\\n        return pos == (0, 0) or head != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676591,
                "title": "simple-4-loops-in-python",
                "content": "Perform the given instruction for **at most four times**, and if the robot does not come back to the origin, then it never comes back to the origin no matter how many times it keeps performing the instruction. Because the direction is only 4 ways and after performing the instruction 4 times, it should head to the north. \\n\\nYou can prove this like this:\\nIf we represent each direction in integer (0 to 3), the possible change of the directions are like this.\\n(Here, 0=North, 1=West, 2=South, 3=East)\\n\\n* 0 -> 1 -> 2 -> 3 -> 0\\n* 0 -> 2 -> 0 -> 2 -> 0\\n* 0 -> 3 -> 2 -> 1 -> 0\\n* 0 -> 0 -> 0 -> 0 -> 0\\n\\nIn any case, the direction is north after performing 4 instructions.\\n\\nWhen it is facing north, the position must be the origin in order to be in the circle. If the position is not the origin, then it keeps going away from the origin.\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        def do_instruction(i, j, dir):\\n            for char in instructions:\\n                if char == \\'G\\':\\n                    if dir == 0:\\n                        i -= 1\\n                    elif dir == 1:\\n                        j -= 1\\n                    elif dir == 2:\\n                        i += 1\\n                    else:\\n                        j += 1\\n                elif char == \\'L\\':\\n                    dir = (dir + 1) % 4\\n                else:\\n                    dir = (dir - 1) % 4\\n            return i, j, dir\\n        \\n        i, j, dir = 0, 0, 0\\n        for _ in range(4):\\n            i, j, dir = do_instruction(i, j, dir)\\n            if i == 0 and j == 0:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        def do_instruction(i, j, dir):\\n            for char in instructions:\\n                if char == \\'G\\':\\n                    if dir == 0:\\n                        i -= 1\\n                    elif dir == 1:\\n                        j -= 1\\n                    elif dir == 2:\\n                        i += 1\\n                    else:\\n                        j += 1\\n                elif char == \\'L\\':\\n                    dir = (dir + 1) % 4\\n                else:\\n                    dir = (dir - 1) % 4\\n            return i, j, dir\\n        \\n        i, j, dir = 0, 0, 0\\n        for _ in range(4):\\n            i, j, dir = do_instruction(i, j, dir)\\n            if i == 0 and j == 0:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676588,
                "title": "c-with-detailed-explanation-0-ms-o-n-100-faster",
                "content": "We need to first of all take care of the instructions and to not get that messy in the actual code, I created a function named follow to take instructions and do accordingly. \\nTake two directions ```x``` and ```y```, and the increments as ```dx``` and ```dy```. Initially set ```x = 0, y = 0, dx = 1 and dy = 0```. Now if our robot takes a left turn change dx and dy accordingly. Similar for a right turn. Now, if robot takes one step forward, now ```x``` will become ```x + dx```\\nand ```y``` will become ```y + dy```. \\nFinally, we just need to see that to complete a circle or a bounded path robot must return to the initial state of ```x = 0, y = 0, dx = 1, dy = 0``` which means that all the movements made by robot have been nullified by other movements after 4 rotations. If so happens, then robot is moving in a bound path.\\n\\nI have attached my code below for reference :)\\n```\\nclass Solution {\\npublic:\\n    void follow(int& x, int& y, int& dx, int& dy, char instruction)\\n    {\\n        if(instruction == \\'L\\')\\n        {\\n            if(dx == 1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = 1;\\n            }\\n            else if(dx == -1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = -1;\\n            }\\n            else if(dx == 0 && dy == 1)\\n            {\\n                dx = -1;\\n                dy = 0;\\n            }\\n            else if(dx == 0 && dy == -1)\\n            {\\n                dx = 1;\\n                dy = 0;\\n            }\\n        }\\n        else if(instruction == \\'R\\')\\n        {\\n            if(dx == 1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = -1;\\n            }\\n            else if(dx == -1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = 1;\\n            }\\n            else if(dx == 0 && dy == 1)\\n            {\\n                dx = 1;\\n                dy = 0;\\n            }\\n            else if(dx == 0 && dy == -1)\\n            {\\n                dx = -1;\\n                dy = 0;\\n            }\\n        }\\n        else\\n        {\\n            x += dx;\\n            y += dy;\\n        }\\n    }\\n    \\n    bool isRobotBounded(string instructions) {\\n        int dx = 1;\\n        int dy = 0;\\n        int x = 0;\\n        int y = 0;\\n\\t\\tint n = 4;\\n\\t\\t\\n        while(n--)\\n\\t\\t\\tfor(int i = 0; i < instructions.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfollow(x,y,dx,dy,instructions[i]);\\n\\t\\t\\t}\\n        }\\n        \\n        if(x == 0 && y == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```x```\n```y```\n```dx```\n```dy```\n```x = 0, y = 0, dx = 1 and dy = 0```\n```x```\n```x + dx```\n```y```\n```y + dy```\n```x = 0, y = 0, dx = 1, dy = 0```\n```\\nclass Solution {\\npublic:\\n    void follow(int& x, int& y, int& dx, int& dy, char instruction)\\n    {\\n        if(instruction == \\'L\\')\\n        {\\n            if(dx == 1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = 1;\\n            }\\n            else if(dx == -1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = -1;\\n            }\\n            else if(dx == 0 && dy == 1)\\n            {\\n                dx = -1;\\n                dy = 0;\\n            }\\n            else if(dx == 0 && dy == -1)\\n            {\\n                dx = 1;\\n                dy = 0;\\n            }\\n        }\\n        else if(instruction == \\'R\\')\\n        {\\n            if(dx == 1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = -1;\\n            }\\n            else if(dx == -1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = 1;\\n            }\\n            else if(dx == 0 && dy == 1)\\n            {\\n                dx = 1;\\n                dy = 0;\\n            }\\n            else if(dx == 0 && dy == -1)\\n            {\\n                dx = -1;\\n                dy = 0;\\n            }\\n        }\\n        else\\n        {\\n            x += dx;\\n            y += dy;\\n        }\\n    }\\n    \\n    bool isRobotBounded(string instructions) {\\n        int dx = 1;\\n        int dy = 0;\\n        int x = 0;\\n        int y = 0;\\n\\t\\tint n = 4;\\n\\t\\t\\n        while(n--)\\n\\t\\t\\tfor(int i = 0; i < instructions.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfollow(x,y,dx,dy,instructions[i]);\\n\\t\\t\\t}\\n        }\\n        \\n        if(x == 0 && y == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676581,
                "title": "python-solution-with-complex-numbers",
                "content": "We know the robot will be contained in a circle if it eventually ends up back where it started. We simulate the robot\\'s movement. If the robot can make it back, it will after 1, 2, or 4 runs, so we run its movements 4 times. We can ~~abuse~~ utilize complex numbers and Python\\'s `complex` class.\\n\\n\\n```python\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirs = {\"L\": 0 + 1j, \"R\": 0 - 1j}\\n        pos = 0j\\n        face = 1j\\n        for _ in range(4):\\n            for c in instructions:\\n                if c in \"LR\":\\n                    face *= dirs[c]\\n                else:\\n                    pos += face\\n        return pos == 0j\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirs = {\"L\": 0 + 1j, \"R\": 0 - 1j}\\n        pos = 0j\\n        face = 1j\\n        for _ in range(4):\\n            for c in instructions:\\n                if c in \"LR\":\\n                    face *= dirs[c]\\n                else:\\n                    pos += face\\n        return pos == 0j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634939,
                "title": "advertise-java-solution-with-detailed-explanation",
                "content": "Firstly I will give the conclusion, **how to we determine the the rob is bounded in a circle**? 2 cases:\\n\\n1. After the instruction is executed once, it goes back to orignal position `[0, 0]` no matter what is the direction after the execution\\n2. It goes to a different position, but in a different direction compared with initial direction\\n\\nThe proval is simple, we just need to focus on **the relative rob position between intial and final state, and forgot the middle process!** I will exlain each rule one by one below\\n\\n---\\n**For the 1st rule**:  After the instruction is executed once, it goes back to orignal position `[0, 0]` no matter what is the direction after the execution\\n1. If it goes to original position after one execution, let\\'s forget the middle process, only care about the effect of the instruction. The effect is: **Stay in the same place, and change direction**. Then if we execute it multiple times, then **it will still stay in the same place as well, only direction changed.** But we do not care of direction, we only care about where it falls into finally. So it is bounded in a circle\\n**We can drill down a little bit**:  Let\\'s say we changed the direction from \"North\" to \"West\" in the 1st execution. If we execute the instruction the 2nd time, then it will stay in the place, and **the final direction will be changed in relative to \"West\"**. **Relative** means: you simulate move the map to make \\u201DWest\" side to \"North\" side and execute the instruction. Or you can understand from this way: For the 1st execution, direction changed from \"North\" to \"West\", so **direction turns left**. Then the 2nd execution, it will do the same thing, the direction change left too, so **\"West\" turns left is \"South\"**. Then multiple execution will be like:\\n\\n\\t```\\n\\t\"Same Position, North to West\" -> \"Same Position, West to South\" -> \"Same Position, South to East\" -> \"Same Position, East to North\"\\n\\t```\\n\\t\\n\\tAnd repeat in this pattern\\n\\n**For the 2nd rule**: It goes to a different position, but in a different direction compared with initial direction\\n1. First understand if position changes, and direction is still \"North\" after execution, **why it is not in circle**?\\nBecause **it will just repeat the postion changes in the same direction(direction here means position change direction)**, e.g. if it moves to bottom right position 2 from 1, then next execution will moves it position to bottom right again based on new postion 2, i.e. move from 2 to 3 and so on. We can see it is not bounded in a circle\\n![image](https://assets.leetcode.com/users/images/8809b519-f09f-42d3-af2b-3f7b681af9f1_1639877832.7344205.png)\\n\\n\\n2. **If it is other directions, then it will definitely move back the original position**. why?\\nIt is simple, if the execution changes direction, then the angel changed is definitely multiple of 90 degree, i.e. one of them: 90, 180, 270(or -90), (not including 360 as we are talking about the case where the direction changed)\\n- If direction change is 180 degree, next instruction execution, the direction change will still be 180 degree, and position change will be 180 degree as well, then it will be like:\\n\\n\\t![image](https://assets.leetcode.com/users/images/57ed613d-9bc0-4584-9d88-d2d0b761706c_1639878920.8232384.png)\\n\\t\\n\\tIt will go back to origin place like **a round trip**\\n- If direction change is 90 or -90(270) degree, then **next execution, the direction change and position direction change will change 90 or -90 degree as well**. After 3 times execution, it will be 90 \\\\* 4=360 degree or -360 degree. If we draw the robot position in each step in the picture, it will form an square, and go back to original position. For example, 90 degree will be as below:\\n\\n![image](https://assets.leetcode.com/users/images/0d725cdf-0155-46a3-9e94-a3afcac17087_1639885781.0605257.png)\\n\\nIt will be the similar for -90 degree, I will skip it. \\n\\n**Conclusion**\\n- If direction change is 0 degree, then it will only change direction, position will not change\\n- If direction change is 90 or -90(270) degree with a position change, then after 4 execution, it will go back to original position. Since 90 * 4 = 360 degree\\n- If direction is 180 degree, then 2 executions will bring robot back. Because 180 * 2 = 360 degree\\n\\n---\\n**Final Code**\\n```java\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        // intial direction is [0, 0]\\n        int[] pos = new int[]{0, 0};\\n        \\n\\t\\t// represents north, east, south, west each direction change\\n        int[][] directions = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        int dirIdx = 0;\\n        \\n        for(char instruction : instructions.toCharArray()){\\n            if(instruction == \\'G\\'){\\n                pos[0] += directions[dirIdx][0];\\n                pos[1] += directions[dirIdx][1]; \\n            }else if(instruction == \\'L\\'){\\n                dirIdx = dirIdx - 1 < 0 ? 3 : dirIdx - 1;\\n            }else{\\n                dirIdx = dirIdx + 1 > 3 ? 0 : dirIdx + 1;\\n            }\\n        }\\n        \\n        if(pos[0] == 0 && pos[1] == 0) return true;\\n        if(dirIdx == 0) return false;\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n**Complexity Analysis**\\n- Time: `O(n)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```\\n\\t\"Same Position, North to West\" -> \"Same Position, West to South\" -> \"Same Position, South to East\" -> \"Same Position, East to North\"\\n\\t```\n```java\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        // intial direction is [0, 0]\\n        int[] pos = new int[]{0, 0};\\n        \\n\\t\\t// represents north, east, south, west each direction change\\n        int[][] directions = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        int dirIdx = 0;\\n        \\n        for(char instruction : instructions.toCharArray()){\\n            if(instruction == \\'G\\'){\\n                pos[0] += directions[dirIdx][0];\\n                pos[1] += directions[dirIdx][1]; \\n            }else if(instruction == \\'L\\'){\\n                dirIdx = dirIdx - 1 < 0 ? 3 : dirIdx - 1;\\n            }else{\\n                dirIdx = dirIdx + 1 > 3 ? 0 : dirIdx + 1;\\n            }\\n        }\\n        \\n        if(pos[0] == 0 && pos[1] == 0) return true;\\n        if(dirIdx == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620979,
                "title": "c-basic-solution",
                "content": "After little bit of experimenting on paper, one can realize that the only situation that it does not land up at origin is if we do not end up on origin after one round and are also facing north.\\nThe other two cases are:\\n- Ending up on origin: Obviously it is `true`\\n- Not ending up on origin but facing South/East/West: This is also true because after 2 rounds(South) or 4 rounds(East/West), we will again land at origin.\\n\\nNow for implementation, we will use three variables:\\n- `a` for x-coordinate\\n- `b` for y-coordinate\\n- `c` for direction\\n\\nAll 3 are integers. One important thing to notice is that we can use `c` variable for direction as follows:\\n- If you see \\'L\\',  increment c by 1\\n- If you see \\'R\\', increment c by 3\\n- If you see \\'G\\', do not change c\\n\\nFurther we can check which direction we are facing:\\n- `c%4=0` means North\\n- `c%4=1` means West\\n- `c%4=2` means South\\n- `c%4=3` means East\\n\\n\\nNow the logic is that:\\n- If you see G, find out which direction you are facing and modify the coordinates accordingly. This will change either a or b.\\n- If you see L or R, change the variable c as per rule given above. Variables a and b do not change in this case.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int a=0,b=0,c=0;\\n        for(char ch: instructions)\\n        {\\n            if(ch==\\'G\\')\\n            {\\n                if(c%4==0)b++;\\n                if(c%4==1)a--;\\n                if(c%4==2)b--;\\n                if(c%4==3)a++;\\n            }\\n            if(ch==\\'L\\') c++;\\n            if(ch==\\'R\\') c+=3;\\n        }\\n        cout << a << \\' \\' << b << \\' \\' << c << endl;\\n        if(c%4==0 && (a!=0 || b!=0)) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int a=0,b=0,c=0;\\n        for(char ch: instructions)\\n        {\\n            if(ch==\\'G\\')\\n            {\\n                if(c%4==0)b++;\\n                if(c%4==1)a--;\\n                if(c%4==2)b--;\\n                if(c%4==3)a++;\\n            }\\n            if(ch==\\'L\\') c++;\\n            if(ch==\\'R\\') c+=3;\\n        }\\n        cout << a << \\' \\' << b << \\' \\' << c << endl;\\n        if(c%4==0 && (a!=0 || b!=0)) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1596533,
                "title": "easy-to-understand-python-using-maps",
                "content": "This solution uses hashmaps to easily compute the next direction and move to take by including one array for the direction and what to add to x and y and then a left and right array to compute the next direction D based of inputs L and R. \\n\\nThe answer is a circle if we either end at the origin facing North or we end somewhere not facing north as after 4 cylces we will eventually reach the origin. \\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n\\t\\t# next coordinate to move on G to based on direction \\n        moves = {\\'N\\': (0, 1), \\'E\\': (1, 0), \\'S\\': (0, -1), \\'W\\': (-1, 0)}\\n\\t\\t# next left direction based on current direction \\n        left  = {\\'N\\': \\'W\\', \\'E\\': \\'N\\', \\'S\\': \\'E\\', \\'W\\': \\'S\\'}\\n\\t\\t# next right direction based on current direction \\n        right = {\\'N\\': \\'E\\', \\'E\\': \\'S\\', \\'S\\': \\'W\\', \\'W\\': \\'N\\'}\\n        \\n        origin = [0, 0]\\n        \\n        D = \\'N\\'\\n        \\n        for nxt in instructions: \\n            if nxt == \\'G\\':\\n                x, y = moves[D]\\n                \\n                origin[0] += x\\n                origin[1] += y\\n                \\n            if nxt == \"L\":\\n                D = left[D]\\n                \\n            if nxt == \\'R\\':\\n                D = right[D]\\n        \\n        if origin == [0, 0] or D != \\'N\\':\\n            return True\\n        \\n        return False\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n\\t\\t# next coordinate to move on G to based on direction \\n        moves = {\\'N\\': (0, 1), \\'E\\': (1, 0), \\'S\\': (0, -1), \\'W\\': (-1, 0)}\\n\\t\\t# next left direction based on current direction \\n        left  = {\\'N\\': \\'W\\', \\'E\\': \\'N\\', \\'S\\': \\'E\\', \\'W\\': \\'S\\'}\\n\\t\\t# next right direction based on current direction \\n        right = {\\'N\\': \\'E\\', \\'E\\': \\'S\\', \\'S\\': \\'W\\', \\'W\\': \\'N\\'}\\n        \\n        origin = [0, 0]\\n        \\n        D = \\'N\\'\\n        \\n        for nxt in instructions: \\n            if nxt == \\'G\\':\\n                x, y = moves[D]\\n                \\n                origin[0] += x\\n                origin[1] += y\\n                \\n            if nxt == \"L\":\\n                D = left[D]\\n                \\n            if nxt == \\'R\\':\\n                D = right[D]\\n        \\n        if origin == [0, 0] or D != \\'N\\':\\n            return True\\n        \\n        return False\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1574160,
                "title": "c-complex-number-o-n-clean-solution-0ms",
                "content": "Since multiplying a complex number by `i` rotates it by 90\\xB0 anti-clockwise around origin on the complex plane, the rest is just treating complex numbers as vectors.\\n\\n```C++\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        const std::complex<int> i(0, 1);\\n        const std::complex<int> initial_position(0, 0);\\n        const std::complex<int> initial_direction(0, 1);\\n        \\n        std::complex<int> position = initial_position;\\n        std::complex<int> direction = initial_direction;\\n        \\n        for (char instruction : instructions) {\\n            switch (instruction) {\\n            case \\'G\\':\\n                position += direction;\\n                break;\\n            case \\'L\\':\\n                direction *= i;\\n                break;\\n            case \\'R\\':\\n                direction *= -i;\\n                break;\\n            }\\n        }\\n        \\n        return direction != initial_direction || position == initial_position;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        const std::complex<int> i(0, 1);\\n        const std::complex<int> initial_position(0, 0);\\n        const std::complex<int> initial_direction(0, 1);\\n        \\n        std::complex<int> position = initial_position;\\n        std::complex<int> direction = initial_direction;\\n        \\n        for (char instruction : instructions) {\\n            switch (instruction) {\\n            case \\'G\\':\\n                position += direction;\\n                break;\\n            case \\'L\\':\\n                direction *= i;\\n                break;\\n            case \\'R\\':\\n                direction *= -i;\\n                break;\\n            }\\n        }\\n        \\n        return direction != initial_direction || position == initial_position;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472762,
                "title": "0-ms-easy-c-solution-faster-than-100-described-with-comments",
                "content": "Please Upvote my solution, if you like it.\\n\\n```class Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n       \\n\\t   // 4 directions [ 0- North, 1- West, 2-South, 3-East] \\n        vector<int> dir(4,0);\\n        \\n        int cur = 0;\\n        \\n\\t\\t// Looping over 4 times as total we have 4 directions\\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < ins.size(); j++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// If character is G, increment the value at current pointer\\n                if(ins[j] == \\'G\\')\\n                    dir[cur]++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// In case it is L, Just do (cur + 1) % 4\\n\\t\\t\\t\\t// As left means \"WEST\", so we are increasing it by 1 and\\n\\t\\t\\t\\t//It may go out of bound, so modulo 4.\\n\\t\\t\\t\\t\\n                else if(ins[j] == \\'L\\')\\n                    cur = (cur + 1) % 4;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// Similarly do it for \\'R\\' case. R means EAST so we have to do +3 instread of +1\\n\\t\\t\\t\\t\\n                else\\n                    cur = (cur + 3) % 4;\\n            }\\n        }\\n\\t\\t\\n        // At last if the movement of North and South is same\\n\\t\\t// and movement of East and West is also same. \\n\\t\\t//This means we are at starting position again\\n\\t\\t\\n        if(dir[0] == dir[2] && dir[1] == dir[3])\\n            return true;\\n        return false;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n       \\n\\t   // 4 directions [ 0- North, 1- West, 2-South, 3-East] \\n        vector<int> dir(4,0);\\n        \\n        int cur = 0;\\n        \\n\\t\\t// Looping over 4 times as total we have 4 directions\\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < ins.size(); j++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// If character is G, increment the value at current pointer\\n                if(ins[j] == \\'G\\')\\n                    dir[cur]++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// In case it is L, Just do (cur + 1) % 4\\n\\t\\t\\t\\t// As left means \"WEST\", so we are increasing it by 1 and\\n\\t\\t\\t\\t//It may go out of bound, so modulo 4.\\n\\t\\t\\t\\t\\n                else if(ins[j] == \\'L\\')\\n                    cur = (cur + 1) % 4;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// Similarly do it for \\'R\\' case. R means EAST so we have to do +3 instread of +1\\n\\t\\t\\t\\t\\n                else\\n                    cur = (cur + 3) % 4;\\n            }\\n        }\\n\\t\\t\\n        // At last if the movement of North and South is same\\n\\t\\t// and movement of East and West is also same. \\n\\t\\t//This means we are at starting position again\\n\\t\\t\\n        if(dir[0] == dir[2] && dir[1] == dir[3])\\n            return true;\\n        return false;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1472520,
                "title": "easy-to-understand-c-solution-faster-than-100",
                "content": "We start with north facing at the origin. After running through the input instructions, we check the ending orientation of the robot using the \\'d\\' variable and the ending coordinates using the \\'x\\' and \\'y\\' variables.\\n\\nIf the orientation is the different from the starting orientation or the ending coordinates are same as the starting coordinates (ie: origin), we say that the path can be bounded by a circle and return true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0, d=90;\\n        for(char ch:instructions){\\n            switch(ch){\\n                case \\'G\\': \\n                    if(d%360==0)\\n                        x++;\\n                    else if(d%360==90)\\n                        y++;\\n                    else if(d%360==180)\\n                        x--;\\n                    else if(d%360==270)\\n                        y--;\\n                    break;\\n                case \\'L\\':\\n                    d+=90;\\n                    break;\\n                case \\'R\\':\\n                    d-=90;\\n                    if(d<0)\\n                        d+=360;\\n                    break;\\n            } \\n        }\\n        \\n        return ((d%360!=90)||((x==0)&&(y==0)));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0, d=90;\\n        for(char ch:instructions){\\n            switch(ch){\\n                case \\'G\\': \\n                    if(d%360==0)\\n                        x++;\\n                    else if(d%360==90)\\n                        y++;\\n                    else if(d%360==180)\\n                        x--;\\n                    else if(d%360==270)\\n                        y--;\\n                    break;\\n                case \\'L\\':\\n                    d+=90;\\n                    break;\\n                case \\'R\\':\\n                    d-=90;\\n                    if(d<0)\\n                        d+=360;\\n                    break;\\n            } \\n        }\\n        \\n        return ((d%360!=90)||((x==0)&&(y==0)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450060,
                "title": "c-just-one-instruction-pass",
                "content": "If your final position is different from starting position after one instruction pass but orientation is same as before then it can\\'t be bounded. Here\\'s my simple c++ code:\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, -1, 0, 1};\\n    int dy[4] = {1, 0, -1, 0};\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, o = 0;\\n        // o -> 0, 1, 2, 3\\n        // if final pos after 1 instruction pass is diff but orientation is same then no circle, otherwise circle\\n        //         ^0\\n        //      1 < > 3\\n        //         v2\\n        \\n        for(int i = 0; i < instructions.size(); i++) {\\n            if(instructions[i] == \\'G\\') {\\n                x += dx[o];\\n                y += dy[o];\\n            } else if(instructions[i] == \\'L\\') {\\n                o = (o + 1) % 4;\\n            } else if(instructions[i] == \\'R\\') {\\n                o = (o - 1 + 4) % 4;\\n            }\\n        }\\n        if((x != 0 || y != 0) && o == 0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, -1, 0, 1};\\n    int dy[4] = {1, 0, -1, 0};\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, o = 0;\\n        // o -> 0, 1, 2, 3\\n        // if final pos after 1 instruction pass is diff but orientation is same then no circle, otherwise circle\\n        //         ^0\\n        //      1 < > 3\\n        //         v2\\n        \\n        for(int i = 0; i < instructions.size(); i++) {\\n            if(instructions[i] == \\'G\\') {\\n                x += dx[o];\\n                y += dy[o];\\n            } else if(instructions[i] == \\'L\\') {\\n                o = (o + 1) % 4;\\n            } else if(instructions[i] == \\'R\\') {\\n                o = (o - 1 + 4) % 4;\\n            }\\n        }\\n        if((x != 0 || y != 0) && o == 0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431450,
                "title": "python-robot-in-a-circle-good-question",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \"\"\"\\n        \\n        Here is the intuition of this problem:\\n        from @lee215: https://leetcode.com/problems/robot-bounded-in-circle/discuss/290856/JavaC%2B%2BPython-Let-Chopper-Help-Explain\\n        \\n        1. If after one iteration, the robot returns to 0,0 then we are good.\\n        2. If after one iteration, the robot does not return 0,0 but faces north, then we have merely shifted the starting point and it will keep shifting. So false.\\n        3. In all other cases, I just guessed it to be true. LOL.\\n        \\n        The important thing is to keep track of directions.\\n        \\n              1\\n              |\\n              |\\n        -1----+----1\\n              |\\n              |\\n              -1\\n\\n        if north, then dx = 0 (since no horizontal component), dy = 1\\n        if east,  then dx = 1, dy = 0 (since no vertical component)\\n        if turn left, the val of x-component goes to y and the negative of y goes to x. See with an example on the map above.\\n        Turning left is the opposite if turning right.\\n        \"\"\"\\n        x, y = 0, 0\\n        dx, dy = 0, 1\\n        for i in instructions:\\n            if i == \\'G\\': x, y = x + dx, y + dy\\n            if i == \\'L\\': dx, dy = -dy, dx\\n            if i == \\'R\\': dx, dy = dy, -dx\\n        \\n        return (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \"\"\"\\n        \\n        Here is the intuition of this problem:\\n        from @lee215: https://leetcode.com/problems/robot-bounded-in-circle/discuss/290856/JavaC%2B%2BPython-Let-Chopper-Help-Explain\\n        \\n        1. If after one iteration, the robot returns to 0,0 then we are good.\\n        2. If after one iteration, the robot does not return 0,0 but faces north, then we have merely shifted the starting point and it will keep shifting. So false.\\n        3. In all other cases, I just guessed it to be true. LOL.\\n        \\n        The important thing is to keep track of directions.\\n        \\n              1\\n              |\\n              |\\n        -1----+----1\\n              |\\n              |\\n              -1\\n\\n        if north, then dx = 0 (since no horizontal component), dy = 1\\n        if east,  then dx = 1, dy = 0 (since no vertical component)\\n        if turn left, the val of x-component goes to y and the negative of y goes to x. See with an example on the map above.\\n        Turning left is the opposite if turning right.\\n        \"\"\"\\n        x, y = 0, 0\\n        dx, dy = 0, 1\\n        for i in instructions:\\n            if i == \\'G\\': x, y = x + dx, y + dy\\n            if i == \\'L\\': dx, dy = -dy, dx\\n            if i == \\'R\\': dx, dy = dy, -dx\\n        \\n        return (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380227,
                "title": "java-0ms-faster-than-100-in-layman-s-terms-such-that-anyone-can-understand-with-clear-explanation",
                "content": "\\n        \\n        /* \\n            There were several other solutions following a similar approach. But, this solution is built around an idea where we don\\'t have to consider a particular direction of rotation or the start to be fixed as North. This works for all the directions of starts, regardless.\\n            I have tried understanding and explaining the problem in the most layman terms and have written the description such that you can start visualizing the moves in an easy way.\\n            Let\\'s consider the circle in terms of 4 quadrants 0/360, 90, 180, 270. I am not even following an order in typing the directions for a reason - to emphasize on the independence of metrics for this solution.\\n            \\n\\t\\t\\tEvery move either adds a 90 degrees or a -90(or 270) degrees or nothing.\\n            The resultant direction after the move must be the current degrees (cd+move)%360\\n            We would also have a map for coordinate updates, otherwise. But, here we wouldn\\'t need that. As in any direction to move straight we know that one of the coordinates remains contant. And, hence it becomes obvious that the other coordinate has to be either incremented or decremented by a value. Since, each move is equal to one unit of the coordinate system in this problem (we don\\'t allow movements of more than a unit. No x = x+2 or y = y+1) Basically x = x+ (0 or 1 or -1 when current direction being faced is North or South) and so is true to y as well when the staright movement is along the x direction (East or West)\\n            \\n\\t\\t\\tAnd, from any direction, the only time when we have to compute the next coordinate is when the move is straight.\\n\\t\\t\\tAssumption: 0 or 360 degrees would be facing North and along x-axis.\\n\\t\\t\\tTherefore, if facing \\n                0 North: To go straight -> y-constant, x++\\n                180 South: To go straight -> y-constant, x--;\\n                90 East: To go straight -> x-constant, y++\\n                270 West: To go straight -> x-constant, y--;\\n\\n\\t\\t\\tIn the end if the degrees is 0 or 360 it is a loop/circle.\\n            Or also if x=0 and y=0 then, it means that end is same as the start as we know that from the question (North is the start and the assumption is 0 is North in this solution with (x=0, y=0)).\\n            Moreover, other than a straight line everything else is a circle or a loop as it didn\\'t end at the same point where it started after completing the first iteration of the whole sequence of instruction. Therefore, it will definitely not end up in the same (current direction as well) in the next iteration for sure and the next one and the next one. And, has to come back to one of the previously visited coordinates at least once in the next 3 iterations max(as there are only 3 moves possible).\\n\\t\\t\\tTime Complexity: O(N) Have ot iterate through all the instructions at least once.\\n\\t\\t\\tSpace Complexity: O(1) Constant space. Our space consumption is not proprotional to the length of our input instruction sequence or just input length rather in general.\\n\\t\\t\\tThank you. I have not written a lot of solutions before; but have learnt a lot from the people who have written(and are writing) great ones. Please do upvote if you liked it. Helps reach more people.\\n        */\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic boolean isRobotBounded(String ins) {\\n\\t\\t\\t\\tint x = 0, y = 0;\\n\\t\\t\\t\\tint cd = 0; // Assuming North is zero and is the currentDirection\\n\\t\\t\\t\\tfor(int i=0; i<ins.length(); i++) {\\n\\t\\t\\t\\t\\tif(ins.charAt(i) == \\'R\\') {\\n\\t\\t\\t\\t\\t\\t// add -90 degrees or 270 degrees\\n\\t\\t\\t\\t\\t\\tcd  = (cd+270)%360;\\n\\t\\t\\t\\t\\t} else if(ins.charAt(i) == \\'L\\') {\\n\\t\\t\\t\\t\\t\\t// add 90 degrees\\n\\t\\t\\t\\t\\t\\tcd  = (cd+90)%360;\\n\\t\\t\\t\\t\\t} else { // G move\\n\\t\\t\\t\\t\\t\\tif(cd == 0){\\n\\t\\t\\t\\t\\t\\t\\tx++;\\n\\t\\t\\t\\t\\t\\t} else if(cd == 180) {\\n\\t\\t\\t\\t\\t\\t\\tx--;\\n\\t\\t\\t\\t\\t\\t} else if(cd == 90) {\\n\\t\\t\\t\\t\\t\\t\\ty++;\\n\\t\\t\\t\\t\\t\\t} else { // cd == 270\\n\\t\\t\\t\\t\\t\\t\\ty--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn (x == 0 && y == 0) || cd>0;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic boolean isRobotBounded(String ins) {\\n\\t\\t\\t\\tint x = 0, y = 0;\\n\\t\\t\\t\\tint cd = 0; // Assuming North is zero and is the currentDirection\\n\\t\\t\\t\\tfor(int i=0; i<ins.length(); i++) {\\n\\t\\t\\t\\t\\tif(ins.charAt(i) == \\'R\\') {\\n\\t\\t\\t\\t\\t\\t// add -90 degrees or 270 degrees\\n\\t\\t\\t\\t\\t\\tcd  = (cd+270)%360;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1253320,
                "title": "simple-java-faster-than-100-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n        int direction = 90; // North\\n        for (char inst : instructions.toCharArray()) {\\n            switch (inst) {\\n                case \\'G\\':\\n                    if (direction == 90) y = y + 1; // North\\n                    if (direction == 270) y = y -1; // South\\n                    if (direction == 180) x = x - 1; // West\\n                    if (direction == 0) x = x + 1; // East\\n                    break;\\n                case \\'L\\':\\n                    direction = Math.floorMod(direction - 90, 360);\\n                    break;\\n                case \\'R\\':\\n                    direction = Math.floorMod(direction + 90, 360);\\n                    break;\\n            }\\n        }\\n        return (x == 0 && y == 0) || direction != 90;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n        int direction = 90; // North\\n        for (char inst : instructions.toCharArray()) {\\n            switch (inst) {\\n                case \\'G\\':\\n                    if (direction == 90) y = y + 1; // North\\n                    if (direction == 270) y = y -1; // South\\n                    if (direction == 180) x = x - 1; // West\\n                    if (direction == 0) x = x + 1; // East\\n                    break;\\n                case \\'L\\':\\n                    direction = Math.floorMod(direction - 90, 360);\\n                    break;\\n                case \\'R\\':\\n                    direction = Math.floorMod(direction + 90, 360);\\n                    break;\\n            }\\n        }\\n        return (x == 0 && y == 0) || direction != 90;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252872,
                "title": "c-100-faster",
                "content": "**If you like it then please upvote!!**\\n```\\nbool isRobotBounded(string instructions) {\\n        int x = 0;\\n        int y = 0;\\n        char dirn = \\'N\\';\\n        \\n        for(char c: instructions){\\n            if(c==\\'G\\'){\\n                if(dirn==\\'E\\'){\\n                    x = x+1;\\n                }\\n                else if(dirn==\\'W\\'){\\n                    x = x-1;\\n                }\\n                else if(dirn==\\'N\\'){\\n                    y = y+1;\\n                }\\n                else if(dirn==\\'S\\'){\\n                    y = y-1;\\n                }\\n            }\\n            if(c==\\'L\\'){\\n                if(dirn ==\\'E\\'){\\n                    dirn = \\'N\\';\\n                }\\n                else if(dirn==\\'W\\'){\\n                    dirn = \\'S\\';\\n                }\\n                else if(dirn==\\'S\\'){\\n                    dirn = \\'E\\';\\n                }\\n                else if(dirn==\\'N\\'){\\n                    dirn = \\'W\\';\\n                }\\n            }\\n            if(c==\\'R\\'){\\n                if(dirn ==\\'E\\'){\\n                    dirn = \\'S\\';\\n                }\\n                else if(dirn==\\'W\\'){\\n                    dirn = \\'N\\';\\n                }\\n                else if(dirn==\\'S\\'){\\n                    dirn = \\'W\\';\\n                }\\n                else if(dirn==\\'N\\'){\\n                    dirn = \\'E\\';\\n                }\\n            }\\n        }\\n        if(x==0&&y==0){\\n            return true;\\n        }\\n        if(dirn==\\'N\\'){\\n            return false;\\n        }\\n       return true;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nbool isRobotBounded(string instructions) {\\n        int x = 0;\\n        int y = 0;\\n        char dirn = \\'N\\';\\n        \\n        for(char c: instructions){\\n            if(c==\\'G\\'){\\n                if(dirn==\\'E\\'){\\n                    x = x+1;\\n                }\\n                else if(dirn==\\'W\\'){\\n                    x = x-1;\\n                }\\n                else if(dirn==\\'N\\'){\\n                    y = y+1;\\n                }\\n                else if(dirn==\\'S\\'){\\n                    y = y-1;\\n                }\\n            }\\n            if(c==\\'L\\'){\\n                if(dirn ==\\'E\\'){\\n                    dirn = \\'N\\';\\n                }\\n                else if(dirn==\\'W\\'){\\n                    dirn = \\'S\\';\\n                }\\n                else if(dirn==\\'S\\'){\\n                    dirn = \\'E\\';\\n                }\\n                else if(dirn==\\'N\\'){\\n                    dirn = \\'W\\';\\n                }\\n            }\\n            if(c==\\'R\\'){\\n                if(dirn ==\\'E\\'){\\n                    dirn = \\'S\\';\\n                }\\n                else if(dirn==\\'W\\'){\\n                    dirn = \\'N\\';\\n                }\\n                else if(dirn==\\'S\\'){\\n                    dirn = \\'W\\';\\n                }\\n                else if(dirn==\\'N\\'){\\n                    dirn = \\'E\\';\\n                }\\n            }\\n        }\\n        if(x==0&&y==0){\\n            return true;\\n        }\\n        if(dirn==\\'N\\'){\\n            return false;\\n        }\\n       return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1237313,
                "title": "c-easy-2-solutions",
                "content": "```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        //**** Method 1: Without Modulo ****//\\n        //Visualizing Clock wise motion //\\n        \\n        int x = 0;\\n        int y = 0;\\n        int dx = 0;\\n        int dy = 1;\\n        \\n        foreach(var ch in instructions)\\n        {\\n            if(ch == \\'G\\')\\n            {\\n                x += dx;\\n                y += dy;\\n            }\\n            else if(ch == \\'R\\')\\n            {\\n                var temp = dx;\\n                dx = dy;\\n                dy = -temp;\\n            }\\n            else if(ch == \\'L\\')\\n            {\\n                var temp = dy;\\n                dy = dx;\\n                dx = -temp;\\n            }\\n        }\\n        return (x == 0 && y == 0 || dy != 1);\\n    }\\n}\\n```\\n```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        //**** Method 2: With Modulo ****//\\n        \\n        var dx = new int[] {0, 1, 0, -1};\\n        var dy = new int[] {1, 0, -1, 0}; \\n        int x = 0;\\n        int y = 0;\\n        int dir = 0; // UP(0), RIgHT(1), DOWN(2), LEFT(3)\\n        \\n        for(int i = 0; i < instructions.Length; i++)\\n        {\\n            if(instructions[i] == \\'G\\')\\n            {\\n                x += dx[dir];\\n                y += dy[dir];\\n            }\\n            else if(instructions[i] == \\'R\\')\\n            {\\n                dir = (dir + 1)%4;\\n            }\\n            else if(instructions[i] == \\'L\\')\\n            {\\n                dir = (dir + 3)%4;\\n            }\\n        }\\n        return (x == 0 && y == 0 || dir != 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        //**** Method 1: Without Modulo ****//\\n        //Visualizing Clock wise motion //\\n        \\n        int x = 0;\\n        int y = 0;\\n        int dx = 0;\\n        int dy = 1;\\n        \\n        foreach(var ch in instructions)\\n        {\\n            if(ch == \\'G\\')\\n            {\\n                x += dx;\\n                y += dy;\\n            }\\n            else if(ch == \\'R\\')\\n            {\\n                var temp = dx;\\n                dx = dy;\\n                dy = -temp;\\n            }\\n            else if(ch == \\'L\\')\\n            {\\n                var temp = dy;\\n                dy = dx;\\n                dx = -temp;\\n            }\\n        }\\n        return (x == 0 && y == 0 || dy != 1);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        //**** Method 2: With Modulo ****//\\n        \\n        var dx = new int[] {0, 1, 0, -1};\\n        var dy = new int[] {1, 0, -1, 0}; \\n        int x = 0;\\n        int y = 0;\\n        int dir = 0; // UP(0), RIgHT(1), DOWN(2), LEFT(3)\\n        \\n        for(int i = 0; i < instructions.Length; i++)\\n        {\\n            if(instructions[i] == \\'G\\')\\n            {\\n                x += dx[dir];\\n                y += dy[dir];\\n            }\\n            else if(instructions[i] == \\'R\\')\\n            {\\n                dir = (dir + 1)%4;\\n            }\\n            else if(instructions[i] == \\'L\\')\\n            {\\n                dir = (dir + 3)%4;\\n            }\\n        }\\n        return (x == 0 && y == 0 || dir != 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124690,
                "title": "simple-java-solution-with-explanation-beats-100-of-java-submissions",
                "content": "I am trying to make it super simple to understand . Please read my explanation and solution below:\\nSimple Explanation. If the robot reaches where it started after one sequence of commands it means it is bounded in a circle as it will be keep doing the same directions and keep reaching at the origin.\\n\\nOr if the robot reaches a direction other than north ,let say East , Think relatively, if it will follow the similar sequence of directions, it should reach south and third time it should reach west and then north respectively . Similarly it will keep moving in a circle .\\n\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        char[] ins=instructions.toCharArray();\\n        int x=0;\\n        int y=0;\\n        char dir=\\'N\\';\\n        \\n        for(char pos:ins){\\n            \\n            switch(pos){\\n                case \\'G\\':\\n                    if(dir==\\'E\\')\\n                        x++;\\n                    else if(dir==\\'W\\')\\n                        x--;\\n                    else if(dir==\\'N\\')\\n                        y++;\\n                    else if(dir==\\'S\\')\\n                        y--;\\n                    break;\\n                case \\'L\\':\\n                    if(dir==\\'E\\')\\n                        dir=\\'N\\';\\n                    else if(dir==\\'W\\')\\n                        dir=\\'S\\';\\n                    else if(dir==\\'N\\')\\n                        dir=\\'W\\';\\n                    else if(dir==\\'S\\')\\n                        dir=\\'E\\';\\n                    break;\\n                case \\'R\\':\\n                    if(dir==\\'E\\')\\n                        dir=\\'S\\';\\n                    else if(dir==\\'W\\')\\n                        dir=\\'N\\';\\n                    else if(dir==\\'N\\')\\n                        dir=\\'E\\';\\n                    else if(dir==\\'S\\')\\n                        dir=\\'W\\';\\n                    break;\\n            }\\n                        \\n        }\\n        \\n        \\n        if((x==0 && y==0) || dir!=\\'N\\'){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        char[] ins=instructions.toCharArray();\\n        int x=0;\\n        int y=0;\\n        char dir=\\'N\\';\\n        \\n        for(char pos:ins){\\n            \\n            switch(pos){\\n                case \\'G\\':\\n                    if(dir==\\'E\\')\\n                        x++;\\n                    else if(dir==\\'W\\')\\n                        x--;\\n                    else if(dir==\\'N\\')\\n                        y++;\\n                    else if(dir==\\'S\\')\\n                        y--;\\n                    break;\\n                case \\'L\\':\\n                    if(dir==\\'E\\')\\n                        dir=\\'N\\';\\n                    else if(dir==\\'W\\')\\n                        dir=\\'S\\';\\n                    else if(dir==\\'N\\')\\n                        dir=\\'W\\';\\n                    else if(dir==\\'S\\')\\n                        dir=\\'E\\';\\n                    break;\\n                case \\'R\\':\\n                    if(dir==\\'E\\')\\n                        dir=\\'S\\';\\n                    else if(dir==\\'W\\')\\n                        dir=\\'N\\';\\n                    else if(dir==\\'N\\')\\n                        dir=\\'E\\';\\n                    else if(dir==\\'S\\')\\n                        dir=\\'W\\';\\n                    break;\\n            }\\n                        \\n        }\\n        \\n        \\n        if((x==0 && y==0) || dir!=\\'N\\'){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038242,
                "title": "java-one-pass-explain-why-direction-1-4",
                "content": "```\\nclass Solution {\\n    /*\\n\\t\\n\\ti is the direction for north: 0; east:1, south:2; west:3\\n\\t\\n    Why (i + 1) in (i + 1) % 4 ?\\n\\n    see we face north: 0, turn right: 1 => (0+1)%4=1\\n    see we face east: 1, turn right: 2 => (1+1)%4=2\\n    See we face south: 2, turn right: 3 => (2+1)%4=3\\n    See we face west: 3, turn right: 0 => (3+1)%4=0\\n    \\n    Notice if we add 1 to the left and then modulo 4 we get the numbers on the right\\n    Hence i = (i + 1) % 4\\n    \\n    Why (i + 3) in (i + 3) % 4 ?\\n    see we face north: 0, turn left: 3 => (0+3)%4=3\\n    see we face east: 1, turn left: 0 => (1+3)%4=0\\n    See we face south: 2, turn left: 1 => (2+3)%4=1\\n    See we face west: 3, turn left: 2 => (3+3)%4=2\\n    \\n    Notice if we add 3 to the left and then modulo 4 we get the numbers on the right\\n    Hence i = (i + 3) % 4\\n    \\n    */\\n    public boolean isRobotBounded(String instructions) {\\n       \\n        int x = 0, y = 0, i = 0; // initially north\\n        int d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        \\n        for (int j = 0; j < instructions.length(); ++j)\\n            if (instructions.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (instructions.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; \\n                y += d[i][1];\\n            }\\n        // in the end as long as we return to the starting point or direction is not north\\n        // we have a true answer\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n\\t\\n\\ti is the direction for north: 0; east:1, south:2; west:3\\n\\t\\n    Why (i + 1) in (i + 1) % 4 ?\\n\\n    see we face north: 0, turn right: 1 => (0+1)%4=1\\n    see we face east: 1, turn right: 2 => (1+1)%4=2\\n    See we face south: 2, turn right: 3 => (2+1)%4=3\\n    See we face west: 3, turn right: 0 => (3+1)%4=0\\n    \\n    Notice if we add 1 to the left and then modulo 4 we get the numbers on the right\\n    Hence i = (i + 1) % 4\\n    \\n    Why (i + 3) in (i + 3) % 4 ?\\n    see we face north: 0, turn left: 3 => (0+3)%4=3\\n    see we face east: 1, turn left: 0 => (1+3)%4=0\\n    See we face south: 2, turn left: 1 => (2+3)%4=1\\n    See we face west: 3, turn left: 2 => (3+3)%4=2\\n    \\n    Notice if we add 3 to the left and then modulo 4 we get the numbers on the right\\n    Hence i = (i + 3) % 4\\n    \\n    */\\n    public boolean isRobotBounded(String instructions) {\\n       \\n        int x = 0, y = 0, i = 0; // initially north\\n        int d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        \\n        for (int j = 0; j < instructions.length(); ++j)\\n            if (instructions.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (instructions.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; \\n                y += d[i][1];\\n            }\\n        // in the end as long as we return to the starting point or direction is not north\\n        // we have a true answer\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024484,
                "title": "simple-python-solution-read-comments-you-will-understand-for-sure",
                "content": "```\\n# Solution 1: O(n) time complexity and o(1) space complexity\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        # initial poition\\n        x = y = 0\\n        # intially facing north\\n        direction = 0\\n        # 0 = north, 1 = east, 2 = south, 3 = west\\n        # With a move (G) in any direction, you will go 1 unit.\\n        # So you need to add 1 unit with x or y depending on\\n        # which direction you are going. For example,\\n        # if you go north from (x,y), then new position would be\\n        # (x, y+1) which is you get by x = x+0, y = y+1.\\n        # Now think about how you can get new position for other direction\\n        # So creating a dictionary with directions as keys and the\\n        # amount we need to add with x and y while we go for 1 unit\\n        # as value. \\n        possible_moves = {0: [0,1], 1: [1,0], 2: [0,-1], 3: [-1,0]}\\n        \\n        # Now the idea is if after executing the instructions, if you \\n        # get your final position at (0,0) or if you are not facing north\\n        # direction, that means you will be in circle. Not facing north\\n        # direction means, as you can repeat the instructions, if you are \\n        # not facing north after 1st execution of the instructions, just\\n        # repeat 3 more times of the same instructions, you will see \\n        # yourself at the origin. Think about with \\'GL\\' or \\'GR\\' \\n        # instructions as an example. With instruction \\'GLGR\\', you \\n        # can\\'t be back at origin, no matter how many times you repeat.\\n        for instruction in instructions:\\n            # turning left means, you will get the same direction \\n            # if you turn right 3 times. modulo beacuse we have \\n            # only 4 directions to consider. \\n            if instruction == \\'L\\':\\n                direction = (direction + 3)% 4\\n            elif instruction == \\'R\\':\\n                direction = (direction + 1)% 4\\n            # If we see \\'G\\' means we need to go 1 unit and\\n            # change x or y value according to the direction \\n            # we are going. By this we will get new position. \\n            else:\\n                x = x + possible_moves[direction][0]\\n                y = y + possible_moves[direction][1]\\n        # Finally, if you get your final position at (0,0) or if you \\n        # are not facing north direction, that means you will be \\n        # in circle.\\n        return (x==0 and y ==0) or direction !=0\\n                \\n        \\n        \\n```\\nMemory Usage: 14 MB, less than 98.82% of Python3 online submissions for Robot Bounded In Circle.",
                "solutionTags": [],
                "code": "```\\n# Solution 1: O(n) time complexity and o(1) space complexity\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        # initial poition\\n        x = y = 0\\n        # intially facing north\\n        direction = 0\\n        # 0 = north, 1 = east, 2 = south, 3 = west\\n        # With a move (G) in any direction, you will go 1 unit.\\n        # So you need to add 1 unit with x or y depending on\\n        # which direction you are going. For example,\\n        # if you go north from (x,y), then new position would be\\n        # (x, y+1) which is you get by x = x+0, y = y+1.\\n        # Now think about how you can get new position for other direction\\n        # So creating a dictionary with directions as keys and the\\n        # amount we need to add with x and y while we go for 1 unit\\n        # as value. \\n        possible_moves = {0: [0,1], 1: [1,0], 2: [0,-1], 3: [-1,0]}\\n        \\n        # Now the idea is if after executing the instructions, if you \\n        # get your final position at (0,0) or if you are not facing north\\n        # direction, that means you will be in circle. Not facing north\\n        # direction means, as you can repeat the instructions, if you are \\n        # not facing north after 1st execution of the instructions, just\\n        # repeat 3 more times of the same instructions, you will see \\n        # yourself at the origin. Think about with \\'GL\\' or \\'GR\\' \\n        # instructions as an example. With instruction \\'GLGR\\', you \\n        # can\\'t be back at origin, no matter how many times you repeat.\\n        for instruction in instructions:\\n            # turning left means, you will get the same direction \\n            # if you turn right 3 times. modulo beacuse we have \\n            # only 4 directions to consider. \\n            if instruction == \\'L\\':\\n                direction = (direction + 3)% 4\\n            elif instruction == \\'R\\':\\n                direction = (direction + 1)% 4\\n            # If we see \\'G\\' means we need to go 1 unit and\\n            # change x or y value according to the direction \\n            # we are going. By this we will get new position. \\n            else:\\n                x = x + possible_moves[direction][0]\\n                y = y + possible_moves[direction][1]\\n        # Finally, if you get your final position at (0,0) or if you \\n        # are not facing north direction, that means you will be \\n        # in circle.\\n        return (x==0 and y ==0) or direction !=0\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 902563,
                "title": "c-clean-code",
                "content": "Assuming the robot starts from origin(0,0), after repeating the command 4 times, the robot should come back to the origin in order for it to be contained within a finate space. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<int> dx{1, 0, -1, 0};  \\n        vector<int> dy{0, 1, 0, -1};\\n        int dir=1, x=0, y=0; \\n        \\n        for(int k=0; k<4; k++){\\n            for(auto ch:instructions){\\n                if(ch==\\'L\\'){\\n                    dir = (dir==3) ? 0 : dir+1;\\n                }else if(ch==\\'R\\'){\\n                    dir = (dir==0) ? 3 : dir-1;\\n                }else{\\n                    x += dx.at(dir); \\n                    y += dy.at(dir); \\n                }\\n            }\\n        }\\n        \\n        return x==0 && y==0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<int> dx{1, 0, -1, 0};  \\n        vector<int> dy{0, 1, 0, -1};\\n        int dir=1, x=0, y=0; \\n        \\n        for(int k=0; k<4; k++){\\n            for(auto ch:instructions){\\n                if(ch==\\'L\\'){\\n                    dir = (dir==3) ? 0 : dir+1;\\n                }else if(ch==\\'R\\'){\\n                    dir = (dir==0) ? 3 : dir-1;\\n                }else{\\n                    x += dx.at(dir); \\n                    y += dy.at(dir); \\n                }\\n            }\\n        }\\n        \\n        return x==0 && y==0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852664,
                "title": "java-100-faster-solution-than-you-can-imagine-using-array",
                "content": "```\\npublic boolean isRobotBounded(String instructions) {\\n        int pos[] = new int[4];\\n        int idx = 0;\\n        //N E S W\\n        //0 1 2 3\\n        for(int i=0;i<instructions.length();i++){\\n            char c = instructions.charAt(i);\\n            \\n            if( c == \\'G\\'){\\n                pos[idx]++;\\n            } else {\\n               int d = (c == \\'L\\') ? -1 : 1;\\n               idx = (4+idx+d)%4;\\n            }\\n        }\\n        int vertical = pos[0]-pos[2];\\n        int horizontal = pos[1]-pos[3];   \\n        int finalDirection = idx;\\n        \\n        //if it return back at same point\\n        if(vertical==0 && horizontal==0)\\n            return true;\\n        //if same direction,       \\n         \\n        return finalDirection!=0;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n        int pos[] = new int[4];\\n        int idx = 0;\\n        //N E S W\\n        //0 1 2 3\\n        for(int i=0;i<instructions.length();i++){\\n            char c = instructions.charAt(i);\\n            \\n            if( c == \\'G\\'){\\n                pos[idx]++;\\n            } else {\\n               int d = (c == \\'L\\') ? -1 : 1;\\n               idx = (4+idx+d)%4;\\n            }\\n        }\\n        int vertical = pos[0]-pos[2];\\n        int horizontal = pos[1]-pos[3];   \\n        int finalDirection = idx;\\n        \\n        //if it return back at same point\\n        if(vertical==0 && horizontal==0)\\n            return true;\\n        //if same direction,       \\n         \\n        return finalDirection!=0;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851545,
                "title": "c-faster-than-100-simple-solution-with-explanation",
                "content": "There are **two condition** robot will go in Circle loop.\\n1. instructions endpoint at (0,0)\\n2. instructions not equal to **N**(direction) and endpoint not equal to (0,0)\\n\\n**explanation**:\\n\\n![image](https://assets.leetcode.com/users/images/32a83430-2a50-4175-ad6b-59212e022485_1600393925.7353935.png)\\n\\n**code :**\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string str) {\\n        int x=0;\\n        int y=0;\\n        int d=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i] == \\'L\\'){\\n                d = d+1 > 3 ? 0 : d+1;\\n            }else if(str[i] == \\'R\\'){\\n                d = d-1 < 0 ? 3 : d-1;\\n            }else if(str[i] == \\'G\\'){\\n                switch(d){\\n                    case 0 : y+=1;\\n                        break;\\n                    case 1 : x+=1;\\n                        break;\\n                    case 2 : y-=1;\\n                        break;\\n                    case 3 : x-=1;\\n                        break;\\n                    default: break;\\n                }\\n            }\\n        }\\n        \\n        return (x==0 && y==0) ? true : d!=0 ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string str) {\\n        int x=0;\\n        int y=0;\\n        int d=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i] == \\'L\\'){\\n                d = d+1 > 3 ? 0 : d+1;\\n            }else if(str[i] == \\'R\\'){\\n                d = d-1 < 0 ? 3 : d-1;\\n            }else if(str[i] == \\'G\\'){\\n                switch(d){\\n                    case 0 : y+=1;\\n                        break;\\n                    case 1 : x+=1;\\n                        break;\\n                    case 2 : y-=1;\\n                        break;\\n                    case 3 : x-=1;\\n                        break;\\n                    default: break;\\n                }\\n            }\\n        }\\n        \\n        return (x==0 && y==0) ? true : d!=0 ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851012,
                "title": "javascript-simple-solution-w-explanation-97-96",
                "content": "First, we declare a variable to hold the current direction, and an array to keep track of the directional moves. Then, iterate through the commands, and if it\\'s a forward move, increment the appropriate move value. If the command is a turn, update the direction variable, using a +1 for one direction and +3 for the other to keep the mod 4 value positive.\\n\\nThe important thing is to recognize that a set of commands that ends up with the robot facing a side results in a circular route leading back to the origin after 4 moves. A set of commands that ends up with the robot facing backwards will result in immediately reversing the action and will return to the origin after 2 moves. And a set of commands that ends up with the robot facing forwards will result in a false unless the robot ends the turn exactly at the origin.\\n\\nSo if the direction at the end is anything othe than the starting value, 0, or if the robot is still at the origin (if all forward and backward moves cancel out and all left and right moves cancel out), the return true, otherwise false.\\n\\n```\\nvar isRobotBounded = function(ins) {\\n    let dir = 0, mov = [0,0,0,0]\\n    for (let i = 0; i < ins.length; i++)\\n        if (ins[i] === \"G\") mov[dir]++\\n        else dir = (dir + (ins[i] === \"L\" ?  1 : 3)) % 4\\n    return dir || (!(mov[0]-mov[2]) && !(mov[1]-mov[3])) ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isRobotBounded = function(ins) {\\n    let dir = 0, mov = [0,0,0,0]\\n    for (let i = 0; i < ins.length; i++)\\n        if (ins[i] === \"G\") mov[dir]++\\n        else dir = (dir + (ins[i] === \"L\" ?  1 : 3)) % 4\\n    return dir || (!(mov[0]-mov[2]) && !(mov[1]-mov[3])) ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850867,
                "title": "c-one-run-solution-with-idea-explanation",
                "content": "Thanks for the [idea](https://leetcode.com/problems/robot-bounded-in-circle/discuss/850540/Java-Simple-self-explanatory-solution-or-O(n)-or-beats-100) to @mihirkiran\\n\\nJust run through instructions and check conditions:\\nA cycle exists if\\n- robot in the initial position with inititial direction\\nor\\n- the robot looks in another direction\\n(means that repeating the same instructions sequency robot will return to initial point with initial direction)\\n```\\n        public bool IsRobotBounded(string instructions) {\\n            int x = 0,\\n                y = 0,\\n                direction = 0;\\n            foreach (var instruction in instructions) {\\n                switch (instruction) {\\n                    case \\'L\\': direction = (direction + 1) % 4; break;\\n                    case \\'R\\': direction = (direction + 3) % 4; break;\\n                    case \\'G\\':\\n                        switch (direction) {\\n                            case 0: y++; break;\\n                            case 1: x--; break;\\n                            case 2: y--; break;\\n                            case 3: x++; break;\\n                        } break;\\n                }\\n            }\\n            return direction != 0 || (x == 0 && y == 0);\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public bool IsRobotBounded(string instructions) {\\n            int x = 0,\\n                y = 0,\\n                direction = 0;\\n            foreach (var instruction in instructions) {\\n                switch (instruction) {\\n                    case \\'L\\': direction = (direction + 1) % 4; break;\\n                    case \\'R\\': direction = (direction + 3) % 4; break;\\n                    case \\'G\\':\\n                        switch (direction) {\\n                            case 0: y++; break;\\n                            case 1: x--; break;\\n                            case 2: y--; break;\\n                            case 3: x++; break;\\n                        } break;\\n                }\\n            }\\n            return direction != 0 || (x == 0 && y == 0);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850596,
                "title": "python-complex-numbers",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        pos, initialpos = complex(0, 0), complex(0, 0)\\n        way, initialway = complex(0, 1), complex(0, 1)\\n        for inst in instructions:\\n            if inst == \\'G\\':\\n                pos += way\\n            elif inst == \\'L\\':\\n                way *= complex(0, 1)\\n            elif inst == \\'R\\':\\n                way *= complex(0, -1)\\n        if pos == initialpos or way != initialway:\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        pos, initialpos = complex(0, 0), complex(0, 0)\\n        way, initialway = complex(0, 1), complex(0, 1)\\n        for inst in instructions:\\n            if inst == \\'G\\':\\n                pos += way\\n            elif inst == \\'L\\':\\n                way *= complex(0, 1)\\n            elif inst == \\'R\\':\\n                way *= complex(0, -1)\\n        if pos == initialpos or way != initialway:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850491,
                "title": "java-o-n-100-faster-simple-solution-commented",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int direction = 0; // 0: north, 1: west, 2: south, 3: east\\n        int pos[] = new int[]{0,0}; //initial position X and Y co-ordinate\\n        for(char instruction: instructions.toCharArray()){\\n            if(instruction == \\'L\\'){\\n                direction = ++direction%4; //direction always takes values in 0 to 3\\n            }else if(instruction == \\'R\\'){\\n                direction--;\\n                if(direction<0){\\n                    direction = 3;\\n                }\\n            }else{\\n                if(direction==0){\\n                    pos[1]++; //increase y co-ordinate\\n                }else if(direction==1){\\n                    pos[0]--; //decrease x co-ordinate\\n                }else if(direction==2){\\n                    pos[1]--; //decrease y co-ordinate\\n                }else{\\n                    pos[0]++;  //increase x co-ordinate\\n                }\\n            }\\n            \\n        }\\n    \\n        return (pos[0]==0 && pos[1]==0)?true:(direction!=0); //return true if initial postion = final position and if direction has changed\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int direction = 0; // 0: north, 1: west, 2: south, 3: east\\n        int pos[] = new int[]{0,0}; //initial position X and Y co-ordinate\\n        for(char instruction: instructions.toCharArray()){\\n            if(instruction == \\'L\\'){\\n                direction = ++direction%4; //direction always takes values in 0 to 3\\n            }else if(instruction == \\'R\\'){\\n                direction--;\\n                if(direction<0){\\n                    direction = 3;\\n                }\\n            }else{\\n                if(direction==0){\\n                    pos[1]++; //increase y co-ordinate\\n                }else if(direction==1){\\n                    pos[0]--; //decrease x co-ordinate\\n                }else if(direction==2){\\n                    pos[1]--; //decrease y co-ordinate\\n                }else{\\n                    pos[0]++;  //increase x co-ordinate\\n                }\\n            }\\n            \\n        }\\n    \\n        return (pos[0]==0 && pos[1]==0)?true:(direction!=0); //return true if initial postion = final position and if direction has changed\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850387,
                "title": "o-n-c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int p[2]={0,0};//coordinate of the position\\n        char ptr=\\'n\\';//facing direction\\n        for(int i=0;i<instructions.length();i++)\\n        {\\n            if(instructions[i]==\\'G\\')\\n            {\\n                if(ptr==\\'n\\')\\n                    p[1]+=1;//move north in y direction\\n                else if(ptr==\\'w\\')\\n                    p[0]-=1;//move west in x direction\\n                else if(ptr==\\'s\\')\\n                    p[1]-=1;//move south in y direction\\n                else\\n                    p[0]+=1;//move east in x direction\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                if(ptr==\\'n\\')\\n                    ptr=\\'w\\';//turn left(west from north)\\n                else if(ptr==\\'w\\')\\n                    ptr=\\'s\\';//turn left(south from west)\\n                else if(ptr==\\'s\\')\\n                    ptr=\\'e\\';//turn left(east from south)\\n                else\\n                    ptr=\\'n\\';//turn left(north from east)\\n            }\\n            else\\n            {\\n                if(ptr==\\'n\\')\\n                    ptr=\\'e\\';//turn right(east from north)\\n                else if(ptr==\\'w\\')\\n                    ptr=\\'n\\';//turn right(north fro west)\\n                else if(ptr==\\'s\\')\\n                    ptr=\\'w\\';//turn right(west from south)\\n                else\\n                    ptr=\\'s\\';//turn right(south from east)\\n            }\\n        }\\n        if(ptr!=\\'n\\'||(p[0]==0&&p[1]==0))\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int p[2]={0,0};//coordinate of the position\\n        char ptr=\\'n\\';//facing direction\\n        for(int i=0;i<instructions.length();i++)\\n        {\\n            if(instructions[i]==\\'G\\')\\n            {\\n                if(ptr==\\'n\\')\\n                    p[1]+=1;//move north in y direction\\n                else if(ptr==\\'w\\')\\n                    p[0]-=1;//move west in x direction\\n                else if(ptr==\\'s\\')\\n                    p[1]-=1;//move south in y direction\\n                else\\n                    p[0]+=1;//move east in x direction\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                if(ptr==\\'n\\')\\n                    ptr=\\'w\\';//turn left(west from north)\\n                else if(ptr==\\'w\\')\\n                    ptr=\\'s\\';//turn left(south from west)\\n                else if(ptr==\\'s\\')\\n                    ptr=\\'e\\';//turn left(east from south)\\n                else\\n                    ptr=\\'n\\';//turn left(north from east)\\n            }\\n            else\\n            {\\n                if(ptr==\\'n\\')\\n                    ptr=\\'e\\';//turn right(east from north)\\n                else if(ptr==\\'w\\')\\n                    ptr=\\'n\\';//turn right(north fro west)\\n                else if(ptr==\\'s\\')\\n                    ptr=\\'w\\';//turn right(west from south)\\n                else\\n                    ptr=\\'s\\';//turn right(south from east)\\n            }\\n        }\\n        if(ptr!=\\'n\\'||(p[0]==0&&p[1]==0))\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 608858,
                "title": "java-easy-time-100-and-space-100",
                "content": "```\\npublic boolean isRobotBounded(String instructions) {\\n        \\n        int[] currCor = new int[2];\\n        int[][] dir =  {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n        \\n        int ind = 0;\\n        \\n        for(int i = 0; i < instructions.length(); i++){\\n            \\n            if(instructions.charAt(i) == \\'L\\'){\\n                ind = (ind + 3) % 4;\\n                continue;\\n            }\\n            if(instructions.charAt(i) == \\'R\\'){\\n                ind = (ind + 1) % 4;\\n                continue;\\n            }\\n            \\n            currCor[0] += dir[ind][0];\\n            currCor[1] += dir[ind][1];\\n        }\\n        \\n        return (currCor[0] == 0 && currCor[1] == 0) || (ind > 0) ? true:false;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n        \\n        int[] currCor = new int[2];\\n        int[][] dir =  {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n        \\n        int ind = 0;\\n        \\n        for(int i = 0; i < instructions.length(); i++){\\n            \\n            if(instructions.charAt(i) == \\'L\\'){\\n                ind = (ind + 3) % 4;\\n                continue;\\n            }\\n            if(instructions.charAt(i) == \\'R\\'){\\n                ind = (ind + 1) % 4;\\n                continue;\\n            }\\n            \\n            currCor[0] += dir[ind][0];\\n            currCor[1] += dir[ind][1];\\n        }\\n        \\n        return (currCor[0] == 0 && currCor[1] == 0) || (ind > 0) ? true:false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 571377,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func isRobotBounded(_ instructions: String) -> Bool {\\n        var currentPosition: (x: Int, y: Int) = (0, 0)\\n        var currentDirection: Direction = .north\\n        \\n        guard !instructions.isEmpty else { return true }\\n        \\n        let instrutionsArray = instructions.map { String($0) }\\n        \\n        for instruction in instrutionsArray {\\n            switch instruction {\\n                case \"G\":\\n                    let coordinates = currentDirection.coordinates\\n                    currentPosition.x += coordinates.x\\n                    currentPosition.y += coordinates.y\\n                case \"L\", \"R\":\\n                    currentDirection = currentDirection.getNewDirection(instruction)\\n                default:\\n                    continue\\n            }\\n        }\\n        \\n        if (currentDirection != .north) || currentPosition == (0, 0) {\\n            return true\\n        }\\n        return false\\n    }\\n}\\n\\nenum Direction {\\n    case north\\n    case west\\n    case east\\n    case south\\n    \\n    var coordinates: (x: Int, y: Int) {\\n        switch self {\\n            case .north:\\n                return (x: 0, y: 1)\\n            case .west:\\n                return (x: 1, y: 0)\\n            case .east:\\n                return (x: -1, y: 0)\\n            case .south:\\n                return (x: 0, y: -1)\\n        }\\n    }\\n    \\n    func getNewDirection(_ movement: String) -> Direction {\\n        switch self {\\n            case .south:\\n                return (movement == \"L\") ? .east : .west\\n            case .north:\\n                return (movement == \"L\") ? .west : .east\\n            case .west:\\n                return (movement == \"L\") ? .south : .north\\n            case .east:\\n                return (movement == \"L\") ? .north : .south\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isRobotBounded(_ instructions: String) -> Bool {\\n        var currentPosition: (x: Int, y: Int) = (0, 0)\\n        var currentDirection: Direction = .north\\n        \\n        guard !instructions.isEmpty else { return true }\\n        \\n        let instrutionsArray = instructions.map { String($0) }\\n        \\n        for instruction in instrutionsArray {\\n            switch instruction {\\n                case \"G\":\\n                    let coordinates = currentDirection.coordinates\\n                    currentPosition.x += coordinates.x\\n                    currentPosition.y += coordinates.y\\n                case \"L\", \"R\":\\n                    currentDirection = currentDirection.getNewDirection(instruction)\\n                default:\\n                    continue\\n            }\\n        }\\n        \\n        if (currentDirection != .north) || currentPosition == (0, 0) {\\n            return true\\n        }\\n        return false\\n    }\\n}\\n\\nenum Direction {\\n    case north\\n    case west\\n    case east\\n    case south\\n    \\n    var coordinates: (x: Int, y: Int) {\\n        switch self {\\n            case .north:\\n                return (x: 0, y: 1)\\n            case .west:\\n                return (x: 1, y: 0)\\n            case .east:\\n                return (x: -1, y: 0)\\n            case .south:\\n                return (x: 0, y: -1)\\n        }\\n    }\\n    \\n    func getNewDirection(_ movement: String) -> Direction {\\n        switch self {\\n            case .south:\\n                return (movement == \"L\") ? .east : .west\\n            case .north:\\n                return (movement == \"L\") ? .west : .east\\n            case .west:\\n                return (movement == \"L\") ? .south : .north\\n            case .east:\\n                return (movement == \"L\") ? .north : .south\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560216,
                "title": "c-100-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int cr[2]={0,0};\\n    char dir=\\'N\\';\\n    bool isRobotBounded(string instructions) \\n    {  \\n      for(auto ch:instructions)\\n      {\\n        if(ch==\\'G\\')\\n          move();\\n        else\\n          turn(ch);\\n       }\\n      if(cr[0]==0&&cr[1]==0)\\n        return true;\\n      if(dir==\\'N\\')\\n        return false; \\n      return true;\\n    }\\n  void move()\\n  {\\n      if(dir==\\'N\\')\\n        cr[0]++;\\n      else if(dir==\\'S\\')\\n        cr[0]--;\\n      else if(dir==\\'L\\')\\n        cr[1]--;\\n      else if(dir==\\'R\\')\\n        cr[1]++;\\n    return;\\n  }\\n  void turn(char ch)\\n  {\\n    if(dir==\\'N\\')\\n      dir=ch;\\n    else if(dir==\\'S\\')\\n      dir=ch==\\'L\\'?\\'R\\':\\'L\\';\\n    else if(dir==\\'L\\')\\n      dir=ch==\\'L\\'?\\'S\\':\\'N\\';\\n    else\\n      dir=ch==\\'R\\'?\\'S\\':\\'N\\';\\n   return;   \\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int cr[2]={0,0};\\n    char dir=\\'N\\';\\n    bool isRobotBounded(string instructions) \\n    {  \\n      for(auto ch:instructions)\\n      {\\n        if(ch==\\'G\\')\\n          move();\\n        else\\n          turn(ch);\\n       }\\n      if(cr[0]==0&&cr[1]==0)\\n        return true;\\n      if(dir==\\'N\\')\\n        return false; \\n      return true;\\n    }\\n  void move()\\n  {\\n      if(dir==\\'N\\')\\n        cr[0]++;\\n      else if(dir==\\'S\\')\\n        cr[0]--;\\n      else if(dir==\\'L\\')\\n        cr[1]--;\\n      else if(dir==\\'R\\')\\n        cr[1]++;\\n    return;\\n  }\\n  void turn(char ch)\\n  {\\n    if(dir==\\'N\\')\\n      dir=ch;\\n    else if(dir==\\'S\\')\\n      dir=ch==\\'L\\'?\\'R\\':\\'L\\';\\n    else if(dir==\\'L\\')\\n      dir=ch==\\'L\\'?\\'S\\':\\'N\\';\\n    else\\n      dir=ch==\\'R\\'?\\'S\\':\\'N\\';\\n   return;   \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381045,
                "title": "o-n-simple-java-solution-beats-100",
                "content": "```class Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int ctL = 0;\\n        int ctR = 0;\\n        //North = 1, East = 2, South = 3, West = 4\\n        int dir = 1;\\n        int y = 0;\\n        int x = 0;\\n        for(int i = 0; i < instructions.length(); i++) {\\n            char c = instructions.charAt(i);\\n            if(c == \\'L\\') {\\n                if(dir == 1) dir = 4;\\n                else dir--;\\n            }\\n            \\n            else if(c == \\'R\\') {\\n                if(dir == 4) dir = 1;\\n                else dir++;\\n            }\\n            else {\\n                if(dir == 1) y++;\\n                else if(dir == 2) x++;\\n                else if(dir == 4) x--;\\n                else if(dir == 3) y--;\\n            }\\n        }\\n        if(dir == 1) {\\n            if(y == 0 && x == 0) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int ctL = 0;\\n        int ctR = 0;\\n        //North = 1, East = 2, South = 3, West = 4\\n        int dir = 1;\\n        int y = 0;\\n        int x = 0;\\n        for(int i = 0; i < instructions.length(); i++) {\\n            char c = instructions.charAt(i);\\n            if(c == \\'L\\') {\\n                if(dir == 1) dir = 4;\\n                else dir--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 338167,
                "title": "slow-but-very-easy-to-come-up-with-solution",
                "content": "Actually I solved it with simple simulations without thinking.\\nJust simulate a long enough sequence of moves and then check if the robot is near its starting position.\\n```\\n    bool isRobotBounded(string instructions) {\\n        int MOVE[][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int x = 0;\\n        int y = 0;\\n        int dir = 0;\\n        for (int i = 0; i < 1000000; ++i) {\\n           switch (instructions[i % instructions.size()]) {\\n              case \\'L\\': \\n                  dir = (dir + 1) % 4;\\n                  break;\\n              case \\'R\\':\\n                  dir = dir == 0 ? 3 : (dir - 1);\\n                  break;\\n              case \\'G\\':\\n                  x += MOVE[dir][0];\\n                  y += MOVE[dir][1];\\n           }\\n        }\\n        return x >= -10000 && x <= 10000 && y <= 10000 && y >= -10000;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isRobotBounded(string instructions) {\\n        int MOVE[][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int x = 0;\\n        int y = 0;\\n        int dir = 0;\\n        for (int i = 0; i < 1000000; ++i) {\\n           switch (instructions[i % instructions.size()]) {\\n              case \\'L\\': \\n                  dir = (dir + 1) % 4;\\n                  break;\\n              case \\'R\\':\\n                  dir = dir == 0 ? 3 : (dir - 1);\\n                  break;\\n              case \\'G\\':\\n                  x += MOVE[dir][0];\\n                  y += MOVE[dir][1];\\n           }\\n        }\\n        return x >= -10000 && x <= 10000 && y <= 10000 && y >= -10000;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304977,
                "title": "1041-c-solution-beats-100-runtime-and-100-memory-with-explanation",
                "content": "[**Proof** (Click for Submission Details)](https://leetcode.com/submissions/detail/233388735/)\\n![image](https://assets.leetcode.com/users/rafaelwi/image_1559587060.png)\\n\\n\\n**Code**\\n```c\\nbool isRobotBounded(char * instructions){\\n    int x = 0;\\n    int y = 0;\\n    int dx = 0;\\n    int dy = 1; // facing north\\n    int temp = 0;\\n    \\n    for (int i = 0; i < strlen(instructions); i++){\\n        switch(instructions[i]){\\n            case \\'R\\':\\n                temp = dx;\\n                dx = dy;\\n                dy = -temp;\\n                break;\\n            case \\'L\\':\\n                temp = dx;\\n                dx = -dy;\\n                dy = temp;\\n                break;\\n            case \\'G\\':\\n                x += dx;\\n                y += dy;\\n                break;\\n        } // end switch\\n    } // end for\\n    \\n    return (((x == 0) && (y == 0)) || ((dx != 0) || (dy != 1)));\\n} // end isRobotBounded\\n```\\n\\n**Explanation**\\nThe idea here is that if the robot returns to origin (0, 0) OR if the robot is not facing north (with north being dx = 0, dy = 1), then the robot is bounded within a circle. Otherwise, we are not bounded by a circle. \\n\\nThis is becuase if you are facing north at the end of a set of instructions, then you have either a) not done any L or R instructions or b) # of L instructions == # of R instructions. This means that with repeated runs of that set of instuctions, you will continue to face north at the end and continuously drift away from the center. However, if # of L instructions != # of R instructions, with enough runs of the instructions, in this case 4 times, as we only have four directions we can travel in (thank you @Achilles_NLP!), you will either return to (0, 0) or nearby.",
                "solutionTags": [],
                "code": "```c\\nbool isRobotBounded(char * instructions){\\n    int x = 0;\\n    int y = 0;\\n    int dx = 0;\\n    int dy = 1; // facing north\\n    int temp = 0;\\n    \\n    for (int i = 0; i < strlen(instructions); i++){\\n        switch(instructions[i]){\\n            case \\'R\\':\\n                temp = dx;\\n                dx = dy;\\n                dy = -temp;\\n                break;\\n            case \\'L\\':\\n                temp = dx;\\n                dx = -dy;\\n                dy = temp;\\n                break;\\n            case \\'G\\':\\n                x += dx;\\n                y += dy;\\n                break;\\n        } // end switch\\n    } // end for\\n    \\n    return (((x == 0) && (y == 0)) || ((dx != 0) || (dy != 1)));\\n} // end isRobotBounded\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295640,
                "title": "python-7-lines",
                "content": "**Explanation**\\nN\\n|\\nW-E\\n|\\nS\\nThe move \\u2018G\\u2019 changes either x or y according to following rules.\\na) If current direction is North, then \\u2018G\\u2019 increments y and doesn\\u2019t change x.\\nb) If current direction is East, then \\u2018G\\u2019 increments x and doesn\\u2019t change y.\\nc) If current direction is South, then \\u2018G\\u2019 decrements y and doesn\\u2019t change x.\\nd) If current direction is West, then \\u2018G\\u2019 decrements x and doesn\\u2019t change y.\\n\\nThe moves \\u2018L\\u2019 and \\u2018R\\u2019, do not change x and y coordinates, they only change direction according to following rule.\\na) If current direction is North, then \\u2018L\\u2019 changes direction to West and \\u2018R\\u2019 changes to East\\nb) If current direction is East, then \\u2018L\\u2019 changes direction to North and \\u2018R\\u2019 changes to South\\nc) If current direction is South, then \\u2018L\\u2019 changes direction to East and \\u2018R\\u2019 changes to West\\nd) If current direction is West, then \\u2018L\\u2019 changes direction to South and \\u2018R\\u2019 changes to North\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x,y,dirX,dirY = 0,0,0,1\\n        instructions *= 4\\n        \\n        for i in instructions:\\n            if i == \\'L\\': dirX,dirY = -dirY,dirX\\n            elif i == \\'R\\': dirX,dirY = dirY,-dirX\\n            else: x,y = x+dirX, y+dirY\\n        \\n        return x == 0 and y == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x,y,dirX,dirY = 0,0,0,1\\n        instructions *= 4\\n        \\n        for i in instructions:\\n            if i == \\'L\\': dirX,dirY = -dirY,dirX\\n            elif i == \\'R\\': dirX,dirY = dirY,-dirX\\n            else: x,y = x+dirX, y+dirY\\n        \\n        return x == 0 and y == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293120,
                "title": "python-o-n-6-line-solution-beats-100",
                "content": "Tricks:\\n- Complex number suits this question well.\\n- Combinations like \"LLLL\", \"RRRR\", \"RL\", \"LR\" does not have any effect, removing these combinations are considered very efficient in python, which will lead to a ~15% performance gain.\\n```\\nclass Solution:\\n    def isRobotBounded(self, ins: str) -> bool:\\n        ins = ins.replace(\\'LLLL\\', \\'\\').replace(\\'RRRR\\', \\'\\').replace(\\'RL\\', \\'\\').replace(\\'LR\\', \\'\\')\\n        d, p = 1, 0\\n        for c in ins:\\n            if c == \\'G\\': p += d\\n            else: d *= {\\'L\\':1j, \\'R\\':-1j}[c]\\n        return d.real == 0 or p == 0 or d.real < 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, ins: str) -> bool:\\n        ins = ins.replace(\\'LLLL\\', \\'\\').replace(\\'RRRR\\', \\'\\').replace(\\'RL\\', \\'\\').replace(\\'LR\\', \\'\\')\\n        d, p = 1, 0\\n        for c in ins:\\n            if c == \\'G\\': p += d\\n            else: d *= {\\'L\\':1j, \\'R\\':-1j}[c]\\n        return d.real == 0 or p == 0 or d.real < 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291566,
                "title": "sexy-java-solution-1-ms",
                "content": "```\\npublic boolean isRobotBounded(String instructions) {\\n        Direction dir = Direction.N;\\n        int north = 0, east = 0;\\n        char[] chars = instructions.toCharArray();\\n        for (int i = 0; i < 4; i++) {\\n            for (char c : chars) {\\n                switch (c) {\\n                    case \\'G\\':\\n                        switch (dir) {\\n                            case N:\\n                                north++;\\n                                break;\\n                            case S:\\n                                north--;\\n                                break;\\n                            case E:\\n                                east++;\\n                                break;\\n                            case W:\\n                                east--;\\n                                break;\\n                        }\\n                        break;\\n                    case \\'L\\':\\n                        dir = dir.left();\\n                        break;\\n                    case \\'R\\':\\n                        dir = dir.right();\\n                        break;\\n                }\\n            }\\n            if (north+east == 0) return true;\\n        }\\n        return north+east == 0;\\n    }\\n    enum Direction {\\n        N,S,E,W;\\n\\n        public Direction right() {\\n            switch (this) {\\n                case N:\\n                    return Direction.E;\\n                case S:\\n                    return Direction.W;\\n                case E:\\n                    return Direction.S;\\n                case W:\\n                    return Direction.N;\\n            }\\n            return this;\\n        }\\n        public Direction left() {\\n            return this.right().right().right();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n        Direction dir = Direction.N;\\n        int north = 0, east = 0;\\n        char[] chars = instructions.toCharArray();\\n        for (int i = 0; i < 4; i++) {\\n            for (char c : chars) {\\n                switch (c) {\\n                    case \\'G\\':\\n                        switch (dir) {\\n                            case N:\\n                                north++;\\n                                break;\\n                            case S:\\n                                north--;\\n                                break;\\n                            case E:\\n                                east++;\\n                                break;\\n                            case W:\\n                                east--;\\n                                break;\\n                        }\\n                        break;\\n                    case \\'L\\':\\n                        dir = dir.left();\\n                        break;\\n                    case \\'R\\':\\n                        dir = dir.right();\\n                        break;\\n                }\\n            }\\n            if (north+east == 0) return true;\\n        }\\n        return north+east == 0;\\n    }\\n    enum Direction {\\n        N,S,E,W;\\n\\n        public Direction right() {\\n            switch (this) {\\n                case N:\\n                    return Direction.E;\\n                case S:\\n                    return Direction.W;\\n                case E:\\n                    return Direction.S;\\n                case W:\\n                    return Direction.N;\\n            }\\n            return this;\\n        }\\n        public Direction left() {\\n            return this.right().right().right();\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290966,
                "title": "java-o-n-solution-explained-in-only-one-case-the-robot-is-not-bounded",
                "content": "**Explanation:**\\nOnly if the robot returns to a **different position with the same facing direction** as the start point after the instructions, it will go infinitly away from the start point.\\nIn all other cases, i.e.,\\n\\n1. same position, same direction;\\n2. same position, different direction;\\n2. different position, different direction,\\n\\nthe robot with be bounded in a circle.\\n```\\npublic boolean isRobotBounded(String instructions) {\\n    int x = 0, y = 0, direction = 0;\\n\\t// north: 0, east: 1, south: 2, west: 3;\\n    for (int i = 0; i < instructions.length(); i++) {\\n\\t    // update the direction\\n\\t\\tchar c = instructions.charAt(i);\\n\\t    if (c == \\'L\\') direction = Math.floorMod(--direction, 4);\\n        if (c == \\'R\\') direction = Math.floorMod(++direction, 4);\\n\\t\\tif (c == \\'G\\') {\\n\\t\\t    // move the robot according to its direction \\n\\t        if (direction == 0) y++;\\n            if (direction == 1) x++;\\n\\t\\t\\tif (direction == 2) y--;\\n            if (direction == 3) x--;\\n        }\\n    }\\n\\t// only if robot returns to a different position with the same facing direction\\n\\t// as the start point, return false\\n    if (direction == 0 && (x != 0 || y != 0)) return false;\\n\\treturn true;\\n}\\n```\\n**Complexity:**\\nTime: O(N)\\nSpace: O(1)",
                "solutionTags": [],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n    int x = 0, y = 0, direction = 0;\\n\\t// north: 0, east: 1, south: 2, west: 3;\\n    for (int i = 0; i < instructions.length(); i++) {\\n\\t    // update the direction\\n\\t\\tchar c = instructions.charAt(i);\\n\\t    if (c == \\'L\\') direction = Math.floorMod(--direction, 4);\\n        if (c == \\'R\\') direction = Math.floorMod(++direction, 4);\\n\\t\\tif (c == \\'G\\') {\\n\\t\\t    // move the robot according to its direction \\n\\t        if (direction == 0) y++;\\n            if (direction == 1) x++;\\n\\t\\t\\tif (direction == 2) y--;\\n            if (direction == 3) x--;\\n        }\\n    }\\n\\t// only if robot returns to a different position with the same facing direction\\n\\t// as the start point, return false\\n    if (direction == 0 && (x != 0 || y != 0)) return false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940290,
                "title": "beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a 2 size array defining x and y axis\\nUpdate that array according to directions\\nReturn true if final direction is not north\\nof It returns to origin\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O[n]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O[1]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n\\n        // Bascially Our x and y axis\\n        int[] ans = new int[2];\\n\\n        // To circulate between changing directions\\n        char[] directions =  {\\'n\\',\\'w\\',\\'s\\',\\'e\\'};\\n\\n        // index we used to circulate among directions\\n        int idx = 0;\\n        // It represents north direction\\n\\n        for (char k : instructions.toCharArray())\\n        {   \\n            // If character is L which means move towards right in Array\\n            if (k==\\'L\\') \\n            {\\n                idx++;\\n                // If index exceeds 3 index reset it to north i.e. zero\\n                if (idx==4) idx=0;\\n            }\\n\\n            // If character is R which means move towards left in array\\n            if (k==\\'R\\')\\n            {\\n                idx--;\\n                // If index get lower than 0 reset it to 3 i.e. East\\n                if (idx==-1) idx=3;\\n            }\\n\\n            if (k==\\'G\\')\\n            {\\n                // According to conditions given in question update ans array of x and y axis   \\n                // if direction is north means positive y direction\\n                if (directions[idx]==\\'n\\') ans[1]++; \\n\\n                // if direction is south means negetive y direction\\n                if (directions[idx]==\\'s\\') ans[1]--;\\n\\n                // if direction is east means positive x direction\\n                if (directions[idx]==\\'e\\') ans[0]++;\\n\\n                // if direction is west means negetive x direction\\n                if (directions[idx]==\\'w\\') ans[0]--;\\n            }\\n        }\\n\\n        // If it is facing some another direction then there will be a possiblity that it never leaves the circle\\n\\n        // And if it return to origin it is win win i.e. true\\n        if ((ans[0]==0 && ans[1]==0) || idx!=0) return true;\\n\\n        // Return false otherwise\\n        return false;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n\\n        // Bascially Our x and y axis\\n        int[] ans = new int[2];\\n\\n        // To circulate between changing directions\\n        char[] directions =  {\\'n\\',\\'w\\',\\'s\\',\\'e\\'};\\n\\n        // index we used to circulate among directions\\n        int idx = 0;\\n        // It represents north direction\\n\\n        for (char k : instructions.toCharArray())\\n        {   \\n            // If character is L which means move towards right in Array\\n            if (k==\\'L\\') \\n            {\\n                idx++;\\n                // If index exceeds 3 index reset it to north i.e. zero\\n                if (idx==4) idx=0;\\n            }\\n\\n            // If character is R which means move towards left in array\\n            if (k==\\'R\\')\\n            {\\n                idx--;\\n                // If index get lower than 0 reset it to 3 i.e. East\\n                if (idx==-1) idx=3;\\n            }\\n\\n            if (k==\\'G\\')\\n            {\\n                // According to conditions given in question update ans array of x and y axis   \\n                // if direction is north means positive y direction\\n                if (directions[idx]==\\'n\\') ans[1]++; \\n\\n                // if direction is south means negetive y direction\\n                if (directions[idx]==\\'s\\') ans[1]--;\\n\\n                // if direction is east means positive x direction\\n                if (directions[idx]==\\'e\\') ans[0]++;\\n\\n                // if direction is west means negetive x direction\\n                if (directions[idx]==\\'w\\') ans[0]--;\\n            }\\n        }\\n\\n        // If it is facing some another direction then there will be a possiblity that it never leaves the circle\\n\\n        // And if it return to origin it is win win i.e. true\\n        if ((ans[0]==0 && ans[1]==0) || idx!=0) return true;\\n\\n        // Return false otherwise\\n        return false;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895586,
                "title": "simple-kotlin-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun isRobotBounded(instructions: String): Boolean {\\n        val steps = listOf(1 to 0, 0 to 1, -1 to 0, 0 to -1)\\n        var step = 0\\n        var y = 0\\n        var x = 0\\n        for (c in instructions.repeat(4)) {\\n            when (c) {\\n                \\'R\\' -> step = (step + 1) % steps.size\\n                \\'L\\' -> step = (step - 1 + steps.size) % steps.size\\n                else -> steps[step].also { (dy, dx) -> y += dy; x += dx }\\n            }\\n        }\\n        return y == 0 && x == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isRobotBounded(instructions: String): Boolean {\\n        val steps = listOf(1 to 0, 0 to 1, -1 to 0, 0 to -1)\\n        var step = 0\\n        var y = 0\\n        var x = 0\\n        for (c in instructions.repeat(4)) {\\n            when (c) {\\n                \\'R\\' -> step = (step + 1) % steps.size\\n                \\'L\\' -> step = (step - 1 + steps.size) % steps.size\\n                else -> steps[step].also { (dy, dx) -> y += dy; x += dx }\\n            }\\n        }\\n        return y == 0 && x == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640714,
                "title": "intuitive-code",
                "content": "# Code\\n```\\nfunc isRobotBounded(instructions string) bool {\\n\\tfor i := 0; i < 2; i++ {\\n\\t\\tinstructions = instructions + instructions\\n\\t}\\n\\tdirections := []byte{\\'N\\', \\'W\\', \\'S\\', \\'E\\'}\\n\\tpoint_to_dir := 0\\n\\tcoords := [2]int{0, 0}\\n\\tfor _, instruction := range instructions {\\n\\t\\tswitch instruction {\\n\\t\\tcase \\'G\\':\\n\\t\\t\\tdirection := directions[point_to_dir]\\n\\t\\t\\tswitch direction {\\n\\t\\t\\tcase \\'N\\':\\n\\t\\t\\t\\tcoords[1] += 1\\n\\t\\t\\tcase \\'S\\':\\n\\t\\t\\t\\tcoords[1] -= 1\\n\\t\\t\\tcase \\'W\\':\\n\\t\\t\\t\\tcoords[0] -= 1\\n\\t\\t\\tcase \\'E\\':\\n\\t\\t\\t\\tcoords[0] += 1\\n\\t\\t\\t}\\n\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif point_to_dir != len(directions)-1 {\\n\\t\\t\\t\\tpoint_to_dir += 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpoint_to_dir = 0\\n\\t\\t\\t}\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif point_to_dir != 0 {\\n\\t\\t\\t\\tpoint_to_dir -= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpoint_to_dir = len(directions) - 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn coords[0] == 0 && coords[1] == 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isRobotBounded(instructions string) bool {\\n\\tfor i := 0; i < 2; i++ {\\n\\t\\tinstructions = instructions + instructions\\n\\t}\\n\\tdirections := []byte{\\'N\\', \\'W\\', \\'S\\', \\'E\\'}\\n\\tpoint_to_dir := 0\\n\\tcoords := [2]int{0, 0}\\n\\tfor _, instruction := range instructions {\\n\\t\\tswitch instruction {\\n\\t\\tcase \\'G\\':\\n\\t\\t\\tdirection := directions[point_to_dir]\\n\\t\\t\\tswitch direction {\\n\\t\\t\\tcase \\'N\\':\\n\\t\\t\\t\\tcoords[1] += 1\\n\\t\\t\\tcase \\'S\\':\\n\\t\\t\\t\\tcoords[1] -= 1\\n\\t\\t\\tcase \\'W\\':\\n\\t\\t\\t\\tcoords[0] -= 1\\n\\t\\t\\tcase \\'E\\':\\n\\t\\t\\t\\tcoords[0] += 1\\n\\t\\t\\t}\\n\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif point_to_dir != len(directions)-1 {\\n\\t\\t\\t\\tpoint_to_dir += 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpoint_to_dir = 0\\n\\t\\t\\t}\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif point_to_dir != 0 {\\n\\t\\t\\t\\tpoint_to_dir -= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpoint_to_dir = len(directions) - 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn coords[0] == 0 && coords[1] == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485375,
                "title": "python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x, y, dx, dy = 0, 0, 0, 1\\n        for ins in instructions:\\n            if ins == \\'G\\':\\n                x, y = x + dx, y + dy\\n            elif ins == \\'L\\':\\n                dx, dy = -dy, dx\\n            elif ins == \\'R\\':\\n                dx, dy = dy, -dx\\n        return (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x, y, dx, dy = 0, 0, 0, 1\\n        for ins in instructions:\\n            if ins == \\'G\\':\\n                x, y = x + dx, y + dy\\n            elif ins == \\'L\\':\\n                dx, dy = -dy, dx\\n            elif ins == \\'R\\':\\n                dx, dy = dy, -dx\\n        return (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447938,
                "title": "swift-solution-beats-100",
                "content": "\\n```\\nclass Solution {\\n    func isRobotBounded(_ instructions: String) -> Bool {\\n    \\n        let potentialMovements = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        var directionIndex = 0\\n        var currX = 0, currY = 0\\n        \\n        for instruction in instructions {\\n            switch instruction {\\n            case \"L\":\\n                directionIndex = (directionIndex + 3) % 4\\n            case \"R\":\\n                directionIndex = (directionIndex + 1) % 4\\n            default:\\n                currX += potentialMovements[directionIndex][0]\\n                currY += potentialMovements[directionIndex][1]\\n            }\\n        }\\n\\n        return directionIndex != 0 || (currX == 0 && currY == 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isRobotBounded(_ instructions: String) -> Bool {\\n    \\n        let potentialMovements = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        var directionIndex = 0\\n        var currX = 0, currY = 0\\n        \\n        for instruction in instructions {\\n            switch instruction {\\n            case \"L\":\\n                directionIndex = (directionIndex + 3) % 4\\n            case \"R\":\\n                directionIndex = (directionIndex + 1) % 4\\n            default:\\n                currX += potentialMovements[directionIndex][0]\\n                currY += potentialMovements[directionIndex][1]\\n            }\\n        }\\n\\n        return directionIndex != 0 || (currX == 0 && currY == 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207056,
                "title": "simple-c-solution-with-comments",
                "content": "Comment your doubts. Please **upvote** if you found this helpful :)\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        unordered_map<int,int>mp; //to store distance travelled in each direction\\n        \\n        int direc = 0; //inititally facing north direction\\n        \\n    //          north\\n    //            0 \\n    //    west 1     3 east\\n    //            2  \\n    //          south  \\n        \\n        for(auto it: instructions){\\n            if(it == \\'L\\') direc++;\\n            else if(it == \\'R\\') direc--;\\n            else{\\n                mp[direc]++; \\n            }\\n            if(direc < 0){\\n                direc = (4+direc)%4;\\n            }\\n            else{\\n                direc = direc%4;\\n            }\\n        }\\n        \\n        //0,2 distance travelled vertically. 1,3 distance travelled horizontally. \\n        if((mp[0]==mp[2] && mp[1]==mp[3]) || direc!=0) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        unordered_map<int,int>mp; //to store distance travelled in each direction\\n        \\n        int direc = 0; //inititally facing north direction\\n        \\n    //          north\\n    //            0 \\n    //    west 1     3 east\\n    //            2  \\n    //          south  \\n        \\n        for(auto it: instructions){\\n            if(it == \\'L\\') direc++;\\n            else if(it == \\'R\\') direc--;\\n            else{\\n                mp[direc]++; \\n            }\\n            if(direc < 0){\\n                direc = (4+direc)%4;\\n            }\\n            else{\\n                direc = direc%4;\\n            }\\n        }\\n        \\n        //0,2 distance travelled vertically. 1,3 distance travelled horizontally. \\n        if((mp[0]==mp[2] && mp[1]==mp[3]) || direc!=0) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051872,
                "title": "kotlin-repeat-4-times",
                "content": "# Intuition\\nJust execute 4 times and check if you at [0, 0] position again\\n\\n# Code\\n```\\nclass Solution {\\n    fun isRobotBounded(s: String): Boolean {\\n        var r = 0\\n        var c = 0\\n        var d = 0\\n        for (i in 0 until 4) {\\n            for (ch in s) {\\n                when (ch) {\\n                    \\'G\\' -> {\\n                        when (d) {\\n                            0 -> r++\\n                            1 -> c++\\n                            2 -> r--\\n                            else -> c--\\n                        }\\n                    }\\n                    \\'L\\' -> {\\n                        d--\\n                        if (d == -1) d = 3\\n                    }\\n                    else -> {\\n                        d++\\n                        if (d == 4) d = 0\\n                    }\\n                }\\n            }\\n        }\\n\\n        return r == 0 && c == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isRobotBounded(s: String): Boolean {\\n        var r = 0\\n        var c = 0\\n        var d = 0\\n        for (i in 0 until 4) {\\n            for (ch in s) {\\n                when (ch) {\\n                    \\'G\\' -> {\\n                        when (d) {\\n                            0 -> r++\\n                            1 -> c++\\n                            2 -> r--\\n                            else -> c--\\n                        }\\n                    }\\n                    \\'L\\' -> {\\n                        d--\\n                        if (d == -1) d = 3\\n                    }\\n                    else -> {\\n                        d++\\n                        if (d == 4) d = 0\\n                    }\\n                }\\n            }\\n        }\\n\\n        return r == 0 && c == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786332,
                "title": "simple-c-solution-using-switch",
                "content": "try to perform the operations, and after that see if we reach (0, 0) or not.\\nIf we reach the origin then problem is solved and we will give true.\\nBut if not, then we will see where robot is currently facing, if we face north this implies we will keep moving away from origin hence return false, otherwise return true.\\n```\\n#define f first\\n#define s second\\n\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<pair<pair<int,int>, char>> pos;\\n        pos.push_back({{0,0}, \\'N\\'});\\n        unordered_map<char,pair<int,int>> dirs={\\n            {\\'N\\', {0, 1}},\\n            {\\'S\\', {0, -1}},\\n            {\\'E\\', {1, 0}},\\n            {\\'W\\', {-1, 0}}\\n        };\\n        for(char c:instructions)\\n        {\\n            switch(c)\\n            {\\n                case \\'G\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    int nx = dirs[d].f+x;\\n                    int ny = dirs[d].s+y;\\n                    pos.push_back({{nx, ny}, d});\\n                    break;\\n                }\\n                case \\'L\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    if(d==\\'N\\') d = \\'W\\';\\n                    else if(d==\\'W\\') d = \\'S\\';\\n                    else if(d==\\'S\\') d = \\'E\\';\\n                    else if(d==\\'E\\') d = \\'N\\';\\n                    pos.push_back({{x, y}, d});\\n                    break;\\n                }  \\n                case \\'R\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    if(d==\\'N\\') d = \\'E\\';\\n                    else if(d==\\'E\\') d = \\'S\\';\\n                    else if(d==\\'S\\') d = \\'W\\';\\n                    else if(d==\\'W\\') d = \\'N\\';\\n                    pos.push_back({{x, y}, d});\\n                    break;\\n                }\\n            }\\n        }\\n        auto v = pos.back();\\n        int x = v.f.f;\\n        int y = v.f.s;\\n        char d = v.s;\\n        if(x==0&&y==0) return true;\\n        return d!=\\'N\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "Geometry",
                    "Simulation"
                ],
                "code": "```\\n#define f first\\n#define s second\\n\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<pair<pair<int,int>, char>> pos;\\n        pos.push_back({{0,0}, \\'N\\'});\\n        unordered_map<char,pair<int,int>> dirs={\\n            {\\'N\\', {0, 1}},\\n            {\\'S\\', {0, -1}},\\n            {\\'E\\', {1, 0}},\\n            {\\'W\\', {-1, 0}}\\n        };\\n        for(char c:instructions)\\n        {\\n            switch(c)\\n            {\\n                case \\'G\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    int nx = dirs[d].f+x;\\n                    int ny = dirs[d].s+y;\\n                    pos.push_back({{nx, ny}, d});\\n                    break;\\n                }\\n                case \\'L\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    if(d==\\'N\\') d = \\'W\\';\\n                    else if(d==\\'W\\') d = \\'S\\';\\n                    else if(d==\\'S\\') d = \\'E\\';\\n                    else if(d==\\'E\\') d = \\'N\\';\\n                    pos.push_back({{x, y}, d});\\n                    break;\\n                }  \\n                case \\'R\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    if(d==\\'N\\') d = \\'E\\';\\n                    else if(d==\\'E\\') d = \\'S\\';\\n                    else if(d==\\'S\\') d = \\'W\\';\\n                    else if(d==\\'W\\') d = \\'N\\';\\n                    pos.push_back({{x, y}, d});\\n                    break;\\n                }\\n            }\\n        }\\n        auto v = pos.back();\\n        int x = v.f.f;\\n        int y = v.f.s;\\n        char d = v.s;\\n        if(x==0&&y==0) return true;\\n        return d!=\\'N\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503217,
                "title": "c-logic-based-explained-intuititons",
                "content": "```\\n#define pp pair<int , int>\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> after having the full iteration once of given path \\n    \\n    // If directions remains same as original & it did not reached origin in between \\n    \\n    // Then its not going to be in the cycle \\n    \\n    bool isRobotBounded(string s) {\\n        \\n        // We will store the possible direction after rotation \\n        \\n        // Rotating North (\\'L\\' , \\'R\\') , West , South , East\\n        \\n        // We will also store the value of each directions \\'G\\' moving\\n        \\n        vector<pp> curr_path={{0 , 1} , {-1 , 0} , {0 , -1} , {1 , 0}};\\n        \\n                            // North , west     , south     , east\\n        \\n        vector<pp> rotation={ {1,3} , {2,0} , {3 , 1} , {0,2}};\\n          // First rotating north , west , south , east \\n        \\n          // after rotation pair of values , first represents \\'L\\' Rotation , second\\n          // \\'R\\' rotation of direction\\n        \\n        // Rotation stores the index of the dirns which is currently after rotations\\n         \\n        // pair of value , in which first represents for Rotating left , Rotating right\\n        int x=0 , y=0;\\n        int dirn=0;\\n        \\n        // dirn = 0 (North ) , 1 (west) , 2 (south) , 3 (east)\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'G\\')\\n            {\\n                x+=curr_path[dirn].first;\\n                y+=curr_path[dirn].second;\\n            }\\n            else\\n            {\\n                if(s[i]==\\'L\\')\\n                dirn=rotation[dirn].first;\\n                else\\n                    dirn=rotation[dirn].second;\\n            }\\n            \\n            // if here in betwwen origin comes , we will not guarantee\\n            \\n            // it will be moving in cycle as path changes differnetly\\n            \\n            // after it .\\n\\n        }\\n       \\n        if((x==0 && y==0) || dirn!=0) // finally dirn has changed\\n        {\\n            return true;\\n        }\\n        \\n        // after one full iteration , direction  changed or it is at origin\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define pp pair<int , int>\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> after having the full iteration once of given path \\n    \\n    // If directions remains same as original & it did not reached origin in between \\n    \\n    // Then its not going to be in the cycle \\n    \\n    bool isRobotBounded(string s) {\\n        \\n        // We will store the possible direction after rotation \\n        \\n        // Rotating North (\\'L\\' , \\'R\\') , West , South , East\\n        \\n        // We will also store the value of each directions \\'G\\' moving\\n        \\n        vector<pp> curr_path={{0 , 1} , {-1 , 0} , {0 , -1} , {1 , 0}};\\n        \\n                            // North , west     , south     , east\\n        \\n        vector<pp> rotation={ {1,3} , {2,0} , {3 , 1} , {0,2}};\\n          // First rotating north , west , south , east \\n        \\n          // after rotation pair of values , first represents \\'L\\' Rotation , second\\n          // \\'R\\' rotation of direction\\n        \\n        // Rotation stores the index of the dirns which is currently after rotations\\n         \\n        // pair of value , in which first represents for Rotating left , Rotating right\\n        int x=0 , y=0;\\n        int dirn=0;\\n        \\n        // dirn = 0 (North ) , 1 (west) , 2 (south) , 3 (east)\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'G\\')\\n            {\\n                x+=curr_path[dirn].first;\\n                y+=curr_path[dirn].second;\\n            }\\n            else\\n            {\\n                if(s[i]==\\'L\\')\\n                dirn=rotation[dirn].first;\\n                else\\n                    dirn=rotation[dirn].second;\\n            }\\n            \\n            // if here in betwwen origin comes , we will not guarantee\\n            \\n            // it will be moving in cycle as path changes differnetly\\n            \\n            // after it .\\n\\n        }\\n       \\n        if((x==0 && y==0) || dirn!=0) // finally dirn has changed\\n        {\\n            return true;\\n        }\\n        \\n        // after one full iteration , direction  changed or it is at origin\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423262,
                "title": "python-explained",
                "content": "The robot will be trapped in a circle if and only if after completing the instructions it did not finish at the point where it began, or it\\'s general orientation had changed from the orientation it had when it began (which is North).\\n\\nIt\\'s enough to check if the robot had finished taking any steps in North-South, or East-West (without tracking the position because it doesn\\'t matter where it ended), and also to check if the orientation had changed from North.\\n\\n\"\"\"\\t\\t\\n\\n        def isRobotBounded(self, instructions):\\n                direction_dict = {\\'R\\': 1, \\'L\\': -1}\\n                orientation = 0\\n                ns = 0  #represent movement on North-South axis\\n                ew = 0  #represent  movement on East-West axis\\n\\n                for inst in instructions:\\n                    if inst == \\'G\\':\\n                        if orientation == 0:  # if orientation is towards North\\n                            ns += 1\\n                        elif orientation == 1:  # East\\n                            ew += 1\\n                        elif orientation == 2:  # South\\n                            ns -= 1\\n                        elif orientation == 3:  # West\\n                            ew -= 1\\n                    else:  # otherwise, instructions are L or R, meaning orientation needs to be updated. North, East, South, West are cyclic (you get from West to North), so modulo 4 will always keep us within these four\\n                        orientation = (orientation + direction_dict[inst]) % 4\\n\\n                if ns == 0 and ew == 0:  # Robot had stayed/returned to beginning point\\n                    return True\\n                if orientation != 0:  # orientation isn\\'t pointed at North\\n                    return True\\n                return False\\n\"\"\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "The robot will be trapped in a circle if and only if after completing the instructions it did not finish at the point where it began, or it\\'s general orientation had changed from the orientation it had when it began (which is North).\\n\\nIt\\'s enough to check if the robot had finished taking any steps in North-South, or East-West (without tracking the position because it doesn\\'t matter where it ended), and also to check if the orientation had changed from North.\\n\\n\"\"\"\\t\\t\\n\\n        def isRobotBounded(self, instructions):\\n                direction_dict = {\\'R\\': 1, \\'L\\': -1}\\n                orientation = 0\\n                ns = 0  #represent movement on North-South axis\\n                ew = 0  #represent  movement on East-West axis\\n\\n                for inst in instructions:\\n                    if inst == \\'G\\':\\n                        if orientation == 0:  # if orientation is towards North\\n                            ns += 1\\n                        elif orientation == 1:  # East\\n                            ew += 1\\n                        elif orientation == 2:  # South\\n                            ns -= 1\\n                        elif orientation == 3:  # West\\n                            ew -= 1\\n                    else:  # otherwise, instructions are L or R, meaning orientation needs to be updated. North, East, South, West are cyclic (you get from West to North), so modulo 4 will always keep us within these four\\n                        orientation = (orientation + direction_dict[inst]) % 4\\n\\n                if ns == 0 and ew == 0:  # Robot had stayed/returned to beginning point\\n                    return True\\n                if orientation != 0:  # orientation isn\\'t pointed at North\\n                    return True\\n                return False\\n\"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 2370492,
                "title": "easy-c-solution-proper-variable-naming",
                "content": "````\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n       \\n        char direction=\\'N\\';\\n        int x=0,y=0;\\n        int n=instructions.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(instructions[i]==\\'G\\')\\n            {\\n                if(direction==\\'N\\')\\n                {\\n                    y++;\\n                }\\n                if(direction==\\'S\\')\\n                {\\n                    y--;\\n                }\\n                if(direction==\\'E\\')\\n                {\\n                    x++;\\n                }\\n                if(direction==\\'W\\')\\n                {\\n                    x--;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                if(direction==\\'N\\')\\n                {\\n                    direction=\\'W\\';\\n                }\\n                else if (direction==\\'W\\')\\n                {\\n                    direction=\\'S\\';\\n                }\\n                else if(direction==\\'S\\')\\n                {\\n                    direction=\\'E\\';\\n                }\\n                else if(direction==\\'E\\')\\n                {\\n                    direction=\\'N\\';\\n                }\\n                    \\n            }\\n            else if(instructions[i]==\\'R\\')\\n            {\\n                if(direction==\\'N\\')\\n                {\\n                    direction=\\'E\\';\\n                }\\n                else if (direction==\\'E\\')\\n                {\\n                    direction=\\'S\\';\\n                }\\n                else if(direction==\\'S\\')\\n                {\\n                    direction=\\'W\\';\\n                }\\n                else if(direction==\\'W\\')\\n                {\\n                    direction=\\'N\\';\\n                }\\n            }\\n        }\\n        \\n        if((x==0 && y==0) ||(direction!=\\'N\\')) return true;\\n        \\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n       \\n        char direction=\\'N\\';\\n        int x=0,y=0;\\n        int n=instructions.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(instructions[i]==\\'G\\')\\n            {\\n                if(direction==\\'N\\')\\n                {\\n                    y++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2336015,
                "title": "best-proof-of-correctness-you-will-ever-see-for-this-problem",
                "content": "Once we find the initial vector, v\\nWe can find all 4 direction of movement available to us\\n\\nTo be contained in a circle, our path should form a polygon.\\nTo form a polygon of degree N, you need to have at-least N directions of movement.\\n\\nSince the direction of movement available to us are 4, we can cannot form any polygon with degree > 4.\\nSo if a path doesn\\'t encounter 0,0 before 4 edges are formed. It will never become bounded.",
                "solutionTags": [
                    "Math"
                ],
                "code": "Once we find the initial vector, v\\nWe can find all 4 direction of movement available to us\\n\\nTo be contained in a circle, our path should form a polygon.\\nTo form a polygon of degree N, you need to have at-least N directions of movement.\\n\\nSince the direction of movement available to us are 4, we can cannot form any polygon with degree > 4.\\nSo if a path doesn\\'t encounter 0,0 before 4 edges are formed. It will never become bounded.",
                "codeTag": "Unknown"
            },
            {
                "id": 2199554,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n        def move(s,direction):\\n            if direction==\"N\":\\n                s[1]+=1\\n            elif direction==\"E\":\\n                s[0]+=1\\n            elif direction==\"W\":\\n                s[0]-=1\\n            else:\\n                s[1]-=1\\n                \\n        def get_directionl(curr_dir):\\n            if curr_dir==\"N\":\\n                return \"W\"\\n            elif curr_dir==\"E\":\\n                return \"N\"\\n            elif curr_dir==\"W\":\\n                return \"S\"\\n            else:\\n                return \"E\"\\n        \\n        def get_directionr(curr_dir):\\n            if curr_dir==\"N\":\\n                return \"E\"\\n            elif curr_dir==\"E\":\\n                return \"S\"\\n            elif curr_dir==\"W\":\\n                return \"N\"\\n            else:\\n                return \"W\"\\n        \\n        s = [0,0]\\n        d  = \"N\"\\n        for i in instructions:\\n            if i==\"G\":\\n                move(s,d)\\n                \\n            elif i==\"L\":\\n                d = get_directionl(d)\\n            \\n            else:\\n                d = get_directionr(d)\\n        \\n        return (s[0]==0 and s[1]==0) or d!=\"N\"\\n                \\n            \\n                \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n        def move(s,direction):\\n            if direction==\"N\":\\n                s[1]+=1\\n            elif direction==\"E\":\\n                s[0]+=1\\n            elif direction==\"W\":\\n                s[0]-=1\\n            else:\\n                s[1]-=1\\n                \\n        def get_directionl(curr_dir):\\n            if curr_dir==\"N\":\\n                return \"W\"\\n            elif curr_dir==\"E\":\\n                return \"N\"\\n            elif curr_dir==\"W\":\\n                return \"S\"\\n            else:\\n                return \"E\"\\n        \\n        def get_directionr(curr_dir):\\n            if curr_dir==\"N\":\\n                return \"E\"\\n            elif curr_dir==\"E\":\\n                return \"S\"\\n            elif curr_dir==\"W\":\\n                return \"N\"\\n            else:\\n                return \"W\"\\n        \\n        s = [0,0]\\n        d  = \"N\"\\n        for i in instructions:\\n            if i==\"G\":\\n                move(s,d)\\n                \\n            elif i==\"L\":\\n                d = get_directionl(d)\\n            \\n            else:\\n                d = get_directionr(d)\\n        \\n        return (s[0]==0 and s[1]==0) or d!=\"N\"\\n                \\n            \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 2166095,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        pair<int, int> end;\\n        end = {0, 0};\\n        char currDir = \\'N\\';\\n        \\n        for(auto each : instructions) {\\n            switch(each) {\\n                case \\'G\\':\\n                    switch(currDir) {\\n                        case \\'N\\':\\n                            end.second++;\\n                            break;\\n                        case \\'S\\':\\n                            end.second--;\\n                            break;\\n                        case \\'E\\':\\n                            end.first++;\\n                            break;\\n                        case \\'W\\':\\n                            end.first--;\\n                            break;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                  switch(currDir) {\\n                        case \\'N\\':\\n                            currDir = \\'W\\';\\n                            break;\\n                        case \\'S\\':\\n                            currDir = \\'E\\';\\n                            break;\\n                        case \\'E\\':\\n                            currDir = \\'N\\';\\n                            break;\\n                        case \\'W\\':\\n                            currDir = \\'S\\';\\n                            break;\\n                    }\\n                    break;  \\n                case \\'R\\':\\n                  switch(currDir) {\\n                        case \\'N\\':\\n                            currDir = \\'E\\';\\n                            break;\\n                        case \\'S\\':\\n                            currDir = \\'W\\';\\n                            break;\\n                        case \\'E\\':\\n                            currDir = \\'S\\';\\n                            break;\\n                        case \\'W\\':\\n                            currDir = \\'N\\';\\n                            break;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n        return ((end.first == 0 && end.second == 0) || currDir != \\'N\\') ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        pair<int, int> end;\\n        end = {0, 0};\\n        char currDir = \\'N\\';\\n        \\n        for(auto each : instructions) {\\n            switch(each) {\\n                case \\'G\\':\\n                    switch(currDir) {\\n                        case \\'N\\':\\n                            end.second++;\\n                            break;\\n                        case \\'S\\':\\n                            end.second--;\\n                            break;\\n                        case \\'E\\':\\n                            end.first++;\\n                            break;\\n                        case \\'W\\':\\n                            end.first--;\\n                            break;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                  switch(currDir) {\\n                        case \\'N\\':\\n                            currDir = \\'W\\';\\n                            break;\\n                        case \\'S\\':\\n                            currDir = \\'E\\';\\n                            break;\\n                        case \\'E\\':\\n                            currDir = \\'N\\';\\n                            break;\\n                        case \\'W\\':\\n                            currDir = \\'S\\';\\n                            break;\\n                    }\\n                    break;  \\n                case \\'R\\':\\n                  switch(currDir) {\\n                        case \\'N\\':\\n                            currDir = \\'E\\';\\n                            break;\\n                        case \\'S\\':\\n                            currDir = \\'W\\';\\n                            break;\\n                        case \\'E\\':\\n                            currDir = \\'S\\';\\n                            break;\\n                        case \\'W\\':\\n                            currDir = \\'N\\';\\n                            break;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n        return ((end.first == 0 && end.second == 0) || currDir != \\'N\\') ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565301,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1564601,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1568654,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1565157,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1566412,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1574383,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 2005470,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1574384,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1575488,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1570399,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1565301,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1564601,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1568654,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1565157,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1566412,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1574383,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 2005470,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1574384,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1575488,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1570399,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            }
        ]
    }
]