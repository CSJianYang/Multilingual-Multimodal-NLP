[
    {
        "title": "Find the Distinct Difference Array",
        "question_content": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: [-3,-1,1,3,5]\nExplanation: For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.\nFor index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.\nFor index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.\n\nExample 2:\n\nInput: nums = [3,2,3,4,2]\nOutput: [-2,-1,0,2,3]\nExplanation: For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\nFor index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= n == nums.length&nbsp;<= 50\n\t1 <= nums[i] <= 50",
        "solutions": [
            {
                "id": 3495134,
                "title": "explained-using-map-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\nTake two map, one to have the prefix indexed (mp) & second one is suffix indexed (rmp ).\\nFirst evaluate the suffix mapping of all element by traversing and indexing all elements\\nThen on second traverse start mapping the prefix index and removing the same from suffix mapping.\\n    - Need to erase the index if its occurance is zero.\\nTake diff of the size of the maps & store in to the ans array.\\n        \\n        \\n```\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp, rmp;\\n        for(auto n: nums){ rmp[n]++; }\\n        for(auto n: nums){\\n            mp[n]++;\\n            rmp[n]--;\\n            if(rmp[n] == 0) rmp.erase(n);\\n            ans.push_back(mp.size() - rmp.size());\\n        }\\n        return ans;\\n    }\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp, rmp;\\n        for(auto n: nums){ rmp[n]++; }\\n        for(auto n: nums){\\n            mp[n]++;\\n            rmp[n]--;\\n            if(rmp[n] == 0) rmp.erase(n);\\n            ans.push_back(mp.size() - rmp.size());\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495054,
                "title": "c-java-python-simple-hashmap-store-frequency-time-o-n",
                "content": "# Intuition\\nSince we want number of distinct elements in a window, we can use hash map to store the frequency of each number in current window.\\nFor an index `i`,\\n- `prefix` maintains frequency table of `nums[0...i]`\\n- `suffix` maintains frequency table of `nums[i + 1...n - 1]`\\n\\n# Approach\\n1. Initially, `prefix` is empty, and `suffix` contains frequency of complete array. \\n2. Now, for each index `i`, remove `nums[i]` from `suffix` and add to `prefix`. Calculate `size(prefix) - size(suffix)`.\\n3. While removing an element from `suffix`, frequency might become 0. To make sure this `{key, value} = {x, 0}` pair is not counted, remove it from the hashmap.\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int, int> prefix, suffix;\\n        vector<int> result;\\n        for (int& x: nums) {\\n            suffix[x]++;\\n        }\\n        for (int& x: nums) {\\n            prefix[x]++;\\n            if (--suffix[x] == 0) {\\n                suffix.erase(x);\\n            }\\n            result.push_back(prefix.size() - suffix.size());\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        HashMap<Integer, Integer> suffix = new HashMap<>();\\n        int[] result = new int[nums.length];\\n        for (int x: nums) {\\n            suffix.put(x, suffix.getOrDefault(x, 0) + 1);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            Integer x = nums[i];\\n            prefix.put(x, prefix.getOrDefault(x, 0) + 1);\\n            suffix.put(x, suffix.get(x) - 1);\\n            if (suffix.get(x) == 0) {\\n                suffix.remove(x);\\n            }\\n            result[i] = prefix.size() - suffix.size();\\n        }\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        # One liner\\n        # return [len(Counter(nums[:i + 1])) - len(Counter(nums[i + 1:])) for i in range(len(nums))]\\n        prefix = defaultdict(int)\\n        suffix = Counter(nums)\\n        result = []\\n        for x in nums:\\n            prefix[x] += 1\\n            suffix[x] -= 1\\n            if suffix[x] == 0:\\n                del suffix[x]\\n            result.append(len(prefix) - len(suffix))\\n        return result\\n```\\n\\n# Complexity\\n- Time complexity: $$\\\\Theta(n)$$\\n- Space complexity: $$\\\\Theta(n)$$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int, int> prefix, suffix;\\n        vector<int> result;\\n        for (int& x: nums) {\\n            suffix[x]++;\\n        }\\n        for (int& x: nums) {\\n            prefix[x]++;\\n            if (--suffix[x] == 0) {\\n                suffix.erase(x);\\n            }\\n            result.push_back(prefix.size() - suffix.size());\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        HashMap<Integer, Integer> suffix = new HashMap<>();\\n        int[] result = new int[nums.length];\\n        for (int x: nums) {\\n            suffix.put(x, suffix.getOrDefault(x, 0) + 1);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            Integer x = nums[i];\\n            prefix.put(x, prefix.getOrDefault(x, 0) + 1);\\n            suffix.put(x, suffix.get(x) - 1);\\n            if (suffix.get(x) == 0) {\\n                suffix.remove(x);\\n            }\\n            result[i] = prefix.size() - suffix.size();\\n        }\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        # One liner\\n        # return [len(Counter(nums[:i + 1])) - len(Counter(nums[i + 1:])) for i in range(len(nums))]\\n        prefix = defaultdict(int)\\n        suffix = Counter(nums)\\n        result = []\\n        for x in nums:\\n            prefix[x] += 1\\n            suffix[x] -= 1\\n            if suffix[x] == 0:\\n                del suffix[x]\\n            result.append(len(prefix) - len(suffix))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494932,
                "title": "l2r-r2l",
                "content": "**C++**\\n```cpp\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n    int cnt[51] = {}, dist = 0;\\n    vector<int> res;\\n    for (int n : nums)\\n        res.push_back((res.empty() ? 0 : res.back()) + (cnt[n]++ == 0));\\n    for (int i = nums.size() - 1; i >= 1; --i) {\\n        dist += exchange(cnt[nums[i]], 0) > 0;\\n        res[i - 1] -= dist;        \\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n    int cnt[51] = {}, dist = 0;\\n    vector<int> res;\\n    for (int n : nums)\\n        res.push_back((res.empty() ? 0 : res.back()) + (cnt[n]++ == 0));\\n    for (int i = nums.size() - 1; i >= 1; --i) {\\n        dist += exchange(cnt[nums[i]], 0) > 0;\\n        res[i - 1] -= dist;        \\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505217,
                "title": "set-prefix-and-suffix",
                "content": "\\nFirst thought - The length of input is small. To find the number of distinct numbers, we can use Set. Therefore, we can iterate each number, put `nums[:i + 1]` and `nums[i + 1:]` to Set,  count the lengths and calculate the difference.\\n\\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            res.append(len(set(nums[:i + 1])) - len(set(nums[i + 1:])))\\n        return res\\n```\\n\\nHere\\'s the one-liner of the above solution.\\n\\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]\\n```\\n\\nHowever, in above solution, it is not optimize as we slice the list for each index. To improve it, we can use prefix and suffix. The logic is similar. For each index, we add `nums[i]` in set and record the length. \\n\\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        pre, suf = [], []\\n        ps, ss = set(), set()\\n        n = len(nums)\\n        for i in range(n):\\n            ps.add(nums[i])\\n            pre.append(len(ps))\\n        for i in range(n - 1, -1, -1):\\n            suf.insert(0, len(ss))\\n            ss.add(nums[i])\\n        # pre: [1, 2, 3, 4, 5]\\n        # suf: [4, 3, 2, 1, 0]\\n        # ans: [-3, -1, 1, 3, 5]\\n        return [pre[i] - suf[i] for i in range(n)]\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            res.append(len(set(nums[:i + 1])) - len(set(nums[i + 1:])))\\n        return res\\n```\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]\\n```\n```py\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        pre, suf = [], []\\n        ps, ss = set(), set()\\n        n = len(nums)\\n        for i in range(n):\\n            ps.add(nums[i])\\n            pre.append(len(ps))\\n        for i in range(n - 1, -1, -1):\\n            suf.insert(0, len(ss))\\n            ss.add(nums[i])\\n        # pre: [1, 2, 3, 4, 5]\\n        # suf: [4, 3, 2, 1, 0]\\n        # ans: [-3, -1, 1, 3, 5]\\n        return [pre[i] - suf[i] for i in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497064,
                "title": "c-iterate-backward-and-forward-using-std-bitset-fast-39ms-100",
                "content": "**TODO(heder): Insert cute cat meme to ask for up-votes. ;)**\\n\\n# Approach 1: using std::bitset\\nSince the input range is so limited we can using a ```std::bitset``` to count unique elements instead of ```std::unordered_map```. With only 64bit wide the compiler can use ```popcount``` to count the number of set bits / unique elments.\\n\\n```cpp\\n    static vector<int> distinctDifferenceArray(const vector<int>& nums) {\\n        // scan backward\\n        bitset<64> bw;\\n        vector<int> cnt_bw(size(nums));\\n        for (int i = size(nums) - 1; i >= 0; --i) {\\n            cnt_bw[i] = bw.count();\\n            bw.set(nums[i]);\\n        }\\n        // scan forward\\n        bitset<64> fw;\\n        vector<int> ans;\\n        ans.reserve(size(nums));\\n        for (int i = 0; i < size(nums); ++i) {\\n            fw.set(nums[i]);\\n            ans.push_back(fw.count() - cnt_bw[i]);\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the lenght of the input then\\n  * Time complexity is $$O(n)$$ as we need to scan it forward and backward and\\n  * Space complexity is $$O(1)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```std::bitset```\n```std::unordered_map```\n```popcount```\n```cpp\\n    static vector<int> distinctDifferenceArray(const vector<int>& nums) {\\n        // scan backward\\n        bitset<64> bw;\\n        vector<int> cnt_bw(size(nums));\\n        for (int i = size(nums) - 1; i >= 0; --i) {\\n            cnt_bw[i] = bw.count();\\n            bw.set(nums[i]);\\n        }\\n        // scan forward\\n        bitset<64> fw;\\n        vector<int> ans;\\n        ans.reserve(size(nums));\\n        for (int i = 0; i < size(nums); ++i) {\\n            fw.set(nums[i]);\\n            ans.push_back(fw.count() - cnt_bw[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495901,
                "title": "javascript-2670-find-the-distinct-difference-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nconst distinctDifferenceArray = function (a) {\\n  const n = a.length\\n  const pre = new Array(n) // prefix counts\\n  const suf = new Array(n) // suffix counts\\n  let set\\n\\n  set = new Set()\\n  for (let i = 0; i < n; i++) {\\n    set.add(a[i])\\n    pre[i] = set.size\\n  }\\n\\n  set = new Set()\\n  for (let i = n - 1; i >= 0; i--) {\\n    suf[i] = set.size\\n    set.add(a[i])\\n  }\\n\\n  const an = new Array(n)\\n  for (let i = 0; i < n; i++) {\\n    an[i] = pre[i] - suf[i]\\n  }\\n  return an\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst distinctDifferenceArray = function (a) {\\n  const n = a.length\\n  const pre = new Array(n) // prefix counts\\n  const suf = new Array(n) // suffix counts\\n  let set\\n\\n  set = new Set()\\n  for (let i = 0; i < n; i++) {\\n    set.add(a[i])\\n    pre[i] = set.size\\n  }\\n\\n  set = new Set()\\n  for (let i = n - 1; i >= 0; i--) {\\n    suf[i] = set.size\\n    set.add(a[i])\\n  }\\n\\n  const an = new Array(n)\\n  for (let i = 0; i < n; i++) {\\n    an[i] = pre[i] - suf[i]\\n  }\\n  return an\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494987,
                "title": "c-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>mpsuffix,mpprefix;\\n        for(int i=0;i<nums.size();i++){\\n            mpsuffix[nums[i]]++;\\n        }\\n    vector<int>ans;\\n    \\n    for(int i=0;i<nums.size();i++){\\n        mpprefix[nums[i]]++;\\n        mpsuffix[nums[i]]--;\\n        \\n        if(mpsuffix[nums[i]]<=0) mpsuffix.erase(nums[i]);\\n        int bsz=mpprefix.size();\\n        int fsz=mpsuffix.size();\\n        \\n        ans.push_back(bsz-fsz);\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>mpsuffix,mpprefix;\\n        for(int i=0;i<nums.size();i++){\\n            mpsuffix[nums[i]]++;\\n        }\\n    vector<int>ans;\\n    \\n    for(int i=0;i<nums.size();i++){\\n        mpprefix[nums[i]]++;\\n        mpsuffix[nums[i]]--;\\n        \\n        if(mpsuffix[nums[i]]<=0) mpsuffix.erase(nums[i]);\\n        int bsz=mpprefix.size();\\n        int fsz=mpsuffix.size();\\n        \\n        ans.push_back(bsz-fsz);\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494949,
                "title": "easy-to-understand-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>ans(n, 0);\\n        //==========================================================\\n        set<int>suffixSet;\\n        vector<int>suffix(n, 0); \\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            suffixSet.insert(nums[i]);\\n            suffix[i] = suffixSet.size();\\n        }\\n        //=========================================================\\n        set<int>prefixSet;\\n        for (int i = 0; i < n; i++)\\n        {\\n            prefixSet.insert(nums[i]);\\n            int prefixDistinct  = prefixSet.size();\\n            int suffixDistinct = (i + 1 >= n)? 0 : suffix[i + 1];\\n            ans[i] = prefixDistinct - suffixDistinct;\\n        }\\n        //===========================================================\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>ans(n, 0);\\n        //==========================================================\\n        set<int>suffixSet;\\n        vector<int>suffix(n, 0); \\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            suffixSet.insert(nums[i]);\\n            suffix[i] = suffixSet.size();\\n        }\\n        //=========================================================\\n        set<int>prefixSet;\\n        for (int i = 0; i < n; i++)\\n        {\\n            prefixSet.insert(nums[i]);\\n            int prefixDistinct  = prefixSet.size();\\n            int suffixDistinct = (i + 1 >= n)? 0 : suffix[i + 1];\\n            ans[i] = prefixDistinct - suffixDistinct;\\n        }\\n        //===========================================================\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494946,
                "title": "day-402-beginner-friendly-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\nJUST AN IMPLEMENTATION PRBOLEM. \\nAlways try to explore more  \\n\\n# Intuition &  Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n##### \\u2022\\tInitialize an array answer of size n, where n is the length of the input array.\\n##### \\u2022\\tInitialize two arrays prefix and suffix of size n.\\n##### \\u2022\\tInitialize two hash sets prefixset and suffixSet.\\n##### \\u2022\\tIterate over the input array nums from left to right, and for each element nums[i], do the following:\\n##### \\u2022 a. If  prefixset does not contain nums[i], add nums[i] to prefixset and set prefix[i] to the size of prefixset.\\n##### \\u2022 b. If prefixset contains nums[i], set prefix[i] to the value of prefix[i-1].\\n##### \\u2022\\tIterate over the input arrayfrom right to left, and for each element, do the following:\\n##### \\u2022 a. If  suffixSet does not contain nums[i], add nums[i] to suffixSet and set suffix[i] to the size of suffixSet.\\n##### \\u2022 b. If suffixSet contains nums[i], set suffix[i] to the value of suffix[i+1].\\n##### \\u2022\\tIterate over the input array nums from left to right, and for each element, set answer[i] to prefix[i]-surffix[i+1]\\n##### \\u2022\\tSet answer[n-1] = prefix[n-1].\\n##### \\u2022\\tReturn the answer array.\\n\\n\\n\\n# Code\\n```java []\\npublic int[] distinctDifferenceArray(int[] nums) {\\n    int n = nums.length;\\n    int[] answer = new int[n];\\n    int[] prefix = new int[n];\\n    int[] suffix = new int[n];\\n    HashSet<Integer> prefixSet = new HashSet<>();\\n    HashSet<Integer> suffixSet = new HashSet<>();\\n\\n    // Step 1: Iterate over the input array from left to right to fill the prefix array\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (!prefixSet.contains(nums[i])) {\\n            prefixSet.add(nums[i]);\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n\\n    // Step 2: Iterate over the input array from right to left to fill the suffix array\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (!suffixSet.contains(nums[i])) {\\n            suffixSet.add(nums[i]);\\n            suffix[i] = j++;\\n        } else if (i > 0) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n\\n    // Step 3: Iterate over the input array to fill the answer array\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n\\n    return answer;\\n}\\n```\\n```c++ []\\nvector<int> distinctDifferenceArray(std::vector<int>& nums) {\\n    int n = nums.size();\\n    std::vector<int> answer(n);\\n    std::vector<int> prefix(n);\\n    std::vector<int> suffix(n);\\n    std::unordered_set<int> prefixSet;\\n    std::unordered_set<int> suffixSet;\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (prefixSet.find(nums[i]) == prefixSet.end()) {\\n            prefixSet.insert(nums[i]);\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (suffixSet.find(nums[i]) == suffixSet.end()) {\\n            suffixSet.insert(nums[i]);\\n            suffix[i] = j++;\\n        } else if (i < n-1) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n    return answer;\\n}\\n```\\n```python []\\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    answer = [0] * n\\n    prefix = [0] * n\\n    suffix = [0] * n\\n    prefixSet = set()\\n    suffixSet = set()\\n    for i in range(n):\\n        if nums[i] not in prefixSet:\\n            prefixSet.add(nums[i])\\n            prefix[i] = len(prefixSet)\\n        elif i > 0:\\n            prefix[i] = prefix[i-1]\\n    for i in range(n-1, -1, -1):\\n        if nums[i] not in suffixSet:\\n            suffixSet.add(nums[i])\\n            suffix[i] = len(suffixSet)\\n        elif i < n-1:\\n            suffix[i] = suffix[i+1]\\n    for i in range(n-1):\\n        answer[i] = prefix[i] - suffix[i+1]\\n    answer[n-1] = prefix[n-1]\\n    return answer\\n```\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# using premitives faster runtime 4ms [objects are Costlier  ]\\n![image.png](https://assets.leetcode.com/users/images/6640aa48-415a-4c65-b841-0450f5d3a5f1_1683443184.084796.png)\\n\\n```java []\\npublic int[] distinctDifferenceArray(int[] nums) {\\n    int n = nums.length;\\n    int[] answer = new int[n];\\n    int[] prefix = new int[n];\\n    int[] suffix = new int[n];\\n    boolean[] prefixSeen = new boolean[51];\\n    boolean[] suffixSeen = new boolean[51];\\n\\n    // Step 1: Iterate over the input array from left to right to fill the prefix array\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (!prefixSeen[nums[i]]) {\\n            prefixSeen[nums[i]] = true;\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n\\n    // Step 2: Iterate over the input array from right to left to fill the suffix array\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (!suffixSeen[nums[i]]) {\\n            suffixSeen[nums[i]] = true;\\n            suffix[i] = j++;\\n        } else if (i < n-1) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n\\n    // Step 3: Iterate over the input array to fill the answer array\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n\\n    return answer;\\n}\\n````\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Suffix Array"
                ],
                "code": "```java []\\npublic int[] distinctDifferenceArray(int[] nums) {\\n    int n = nums.length;\\n    int[] answer = new int[n];\\n    int[] prefix = new int[n];\\n    int[] suffix = new int[n];\\n    HashSet<Integer> prefixSet = new HashSet<>();\\n    HashSet<Integer> suffixSet = new HashSet<>();\\n\\n    // Step 1: Iterate over the input array from left to right to fill the prefix array\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (!prefixSet.contains(nums[i])) {\\n            prefixSet.add(nums[i]);\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n\\n    // Step 2: Iterate over the input array from right to left to fill the suffix array\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (!suffixSet.contains(nums[i])) {\\n            suffixSet.add(nums[i]);\\n            suffix[i] = j++;\\n        } else if (i > 0) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n\\n    // Step 3: Iterate over the input array to fill the answer array\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n\\n    return answer;\\n}\\n```\n```c++ []\\nvector<int> distinctDifferenceArray(std::vector<int>& nums) {\\n    int n = nums.size();\\n    std::vector<int> answer(n);\\n    std::vector<int> prefix(n);\\n    std::vector<int> suffix(n);\\n    std::unordered_set<int> prefixSet;\\n    std::unordered_set<int> suffixSet;\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (prefixSet.find(nums[i]) == prefixSet.end()) {\\n            prefixSet.insert(nums[i]);\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (suffixSet.find(nums[i]) == suffixSet.end()) {\\n            suffixSet.insert(nums[i]);\\n            suffix[i] = j++;\\n        } else if (i < n-1) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n    return answer;\\n}\\n```\n```python []\\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    answer = [0] * n\\n    prefix = [0] * n\\n    suffix = [0] * n\\n    prefixSet = set()\\n    suffixSet = set()\\n    for i in range(n):\\n        if nums[i] not in prefixSet:\\n            prefixSet.add(nums[i])\\n            prefix[i] = len(prefixSet)\\n        elif i > 0:\\n            prefix[i] = prefix[i-1]\\n    for i in range(n-1, -1, -1):\\n        if nums[i] not in suffixSet:\\n            suffixSet.add(nums[i])\\n            suffix[i] = len(suffixSet)\\n        elif i < n-1:\\n            suffix[i] = suffix[i+1]\\n    for i in range(n-1):\\n        answer[i] = prefix[i] - suffix[i+1]\\n    answer[n-1] = prefix[n-1]\\n    return answer\\n```\n```java []\\npublic int[] distinctDifferenceArray(int[] nums) {\\n    int n = nums.length;\\n    int[] answer = new int[n];\\n    int[] prefix = new int[n];\\n    int[] suffix = new int[n];\\n    boolean[] prefixSeen = new boolean[51];\\n    boolean[] suffixSeen = new boolean[51];\\n\\n    // Step 1: Iterate over the input array from left to right to fill the prefix array\\n    for (int i = 0, j = 1; i < n; i++) {\\n        if (!prefixSeen[nums[i]]) {\\n            prefixSeen[nums[i]] = true;\\n            prefix[i] = j++;\\n        } else if (i > 0) {\\n            prefix[i] = prefix[i-1];\\n        }\\n    }\\n\\n    // Step 2: Iterate over the input array from right to left to fill the suffix array\\n    for (int i = n-1, j = 1; i >= 0; i--) {\\n        if (!suffixSeen[nums[i]]) {\\n            suffixSeen[nums[i]] = true;\\n            suffix[i] = j++;\\n        } else if (i < n-1) {\\n            suffix[i] = suffix[i+1];\\n        }\\n    }\\n\\n    // Step 3: Iterate over the input array to fill the answer array\\n    for (int i = 0; i < n-1; i++) {\\n        answer[i] = prefix[i] - suffix[i+1];\\n    }\\n    answer[n-1] = prefix[n-1];\\n\\n    return answer;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3497314,
                "title": "python-3-7-lines-no-sets-w-example-t-m-122-ms-16-2-mb",
                "content": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:    #  Example:   nums = [3,2,3,4,2]\\n                                                                        #  \\n        pref, suff = defaultdict(int), Counter(nums)                    #   pref, suff = {}, {2:2, 3:2, 4:1}\\n\\n        cur = -len(suff)                                                #  cur = -3\\n\\n        for i, n in enumerate(nums):                                    #  n  cur  pref           suff           nums\\n            pref[n]+= 1                                                 # \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013       \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            suff[n]-= 1                                                 #      -3  {2:0,3:0,4:0}  {2:2,3:2,4:1}  [| 3, 2, 3, 4, 2]\\n            cur = nums[i] = cur + (pref[n] == 1) + (suff[n] == 0)       #  3   -2  {2:0,3:1,4:0}  {2:2,3:1,4:1}  [-2,| 2, 3, 4, 2]\\n                                                                        #  2   -1  {2:1,3:1,4:0}  {2:1,3:1,4:1}  [-2,-1,| 3, 4, 2]\\n        return  nums                                                    #  3    0  {2:1,3:2,4:0}  {2:1,3:0,4:1}  [-2,-1, 0,| 4, 2]\\n                                                                        #  4    2  {2:1,3:2,4:1}  {2:1,3:0,4:0}  [-2,-1, 0, 2,| 2]\\n                                                                        #  2    3  {2:2,3:2,4:1}  {2:0,3:0,4:0}  [-2,-1, 0, 2, 3|]\\n```\\n[https://leetcode.com/problems/find-the-distinct-difference-array/submissions/946122293/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:    #  Example:   nums = [3,2,3,4,2]\\n                                                                        #  \\n        pref, suff = defaultdict(int), Counter(nums)                    #   pref, suff = {}, {2:2, 3:2, 4:1}\\n\\n        cur = -len(suff)                                                #  cur = -3\\n\\n        for i, n in enumerate(nums):                                    #  n  cur  pref           suff           nums\\n            pref[n]+= 1                                                 # \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013       \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            suff[n]-= 1                                                 #      -3  {2:0,3:0,4:0}  {2:2,3:2,4:1}  [| 3, 2, 3, 4, 2]\\n            cur = nums[i] = cur + (pref[n] == 1) + (suff[n] == 0)       #  3   -2  {2:0,3:1,4:0}  {2:2,3:1,4:1}  [-2,| 2, 3, 4, 2]\\n                                                                        #  2   -1  {2:1,3:1,4:0}  {2:1,3:1,4:1}  [-2,-1,| 3, 4, 2]\\n        return  nums                                                    #  3    0  {2:1,3:2,4:0}  {2:1,3:0,4:1}  [-2,-1, 0,| 4, 2]\\n                                                                        #  4    2  {2:1,3:2,4:1}  {2:1,3:0,4:0}  [-2,-1, 0, 2,| 2]\\n                                                                        #  2    3  {2:2,3:2,4:1}  {2:0,3:0,4:0}  [-2,-1, 0, 2, 3|]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497091,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int a[]=new int[51];\\n        int len=nums.length;\\n        int res[]=new int[len];\\n        for(int i:nums)\\n        {\\n            a[i]++;\\n        }\\n        int b[]=new int[51];\\n        for(int i=0;i<len;i++)\\n        {\\n            b[nums[i]]++;\\n            a[nums[i]]--;\\n            int count=0,count1=0;\\n            for(int j=1;j<=50;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count++;\\n                }\\n            }\\n            for(int j=1;j<=50;j++)\\n            {\\n                if(b[j]>0)\\n                {\\n                    count1++;\\n                }\\n            }\\n            res[i]=count1-count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int a[]=new int[51];\\n        int len=nums.length;\\n        int res[]=new int[len];\\n        for(int i:nums)\\n        {\\n            a[i]++;\\n        }\\n        int b[]=new int[51];\\n        for(int i=0;i<len;i++)\\n        {\\n            b[nums[i]]++;\\n            a[nums[i]]--;\\n            int count=0,count1=0;\\n            for(int j=1;j<=50;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count++;\\n                }\\n            }\\n            for(int j=1;j<=50;j++)\\n            {\\n                if(b[j]>0)\\n                {\\n                    count1++;\\n                }\\n            }\\n            res[i]=count1-count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495596,
                "title": "c-map-100-faster",
                "content": "FIRST I STORE COUNT OF EACH ELEMENT IN AN UNORDERED_MAP(mp2) WORK AS SUFFIX DISTICNT NO.\\nUSE ANOTHER UNORDERED_MAP(mp1) MAINTAIN DISTINCT COUNT OF PREFIX ELEMENTS.\\nPUSH (prefix.distint_no - suffix.distint_no) into answer array\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> mp1,mp2;\\n        for(auto &i: nums)mp2[i]++;\\n        vector<int> ans;\\n        for(auto &i: nums){\\n            mp2[i]--;\\n            mp1[i]++;\\n            if(mp2[i]==0)mp2.erase(i);\\n            ans.push_back(mp1.size()-mp2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> mp1,mp2;\\n        for(auto &i: nums)mp2[i]++;\\n        vector<int> ans;\\n        for(auto &i: nums){\\n            mp2[i]--;\\n            mp1[i]++;\\n            if(mp2[i]==0)mp2.erase(i);\\n            ans.push_back(mp1.size()-mp2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510833,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        diff = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[:i+1]))\\n            surfix = len(set(nums[i+1:]))\\n            diff.append(prefix-surfix)\\n        return diff\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        diff = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[:i+1]))\\n            surfix = len(set(nums[i+1:]))\\n            diff.append(prefix-surfix)\\n        return diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495361,
                "title": "full-explanation-no-hashmap-simplest-approach",
                "content": "# Intuition\\n\\nNo hashmap Simple Iteration\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The problem asks to find the distinct difference array of a given array \"nums\". The distinct difference array is an array of the same length as \"nums\", where each element \"diff[i]\" is calculated by subtracting the number of distinct elements in the suffix of \"nums\" (i.e., elements from index i+1 to n-1) from the number of distinct elements in the prefix of \"nums\" (i.e., elements from index 0 to i).\\n 2. To solve the problem, the above code defines a class \"Solution\" with a public method \"distinctDifferenceArray\" that takes an integer array \"nums\" as input and returns an integer array \"diff\". \\n 3. The \"distinctDifferenceArray\" method loops through each index of the \"nums\" array and calculates the difference between the number of distinct elements in the prefix and the number of distinct elements in the suffix, and stores the result in the \"diff\" array. \\n 4. To count the number of distinct elements in a given subarray of \"nums\", the code defines a helper method \"countDistinctElements\" that takes an integer array \"nums\", a starting index \"start\", and an ending index \"end\" as input, and returns the count of distinct elements in the subarray from index \"start\" to index \"end\". \\n 5. The method uses a boolean array \"visited\" to keep track of the elements that have been visited before. Overall, the code solves the problem by calculating the distinct difference array for the given \"nums\" array, where each element in the array is calculated using the \"countDistinctElements\" helper method to count the number of distinct elements in the prefix and suffix of the current element.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      \\n        int n = nums.length;\\n        int[] diff = new int[n];\\n        \\n        // iterate through each index\\n        for (int i = 0; i < n; i++) {\\n            int countPrefix = countDistinctElements(nums, 0, i);\\n            int countSuffix = countDistinctElements(nums, i + 1, n - 1);\\n            diff[i] = countPrefix - countSuffix;\\n        }\\n        \\n        return diff;\\n    }\\n    \\n    private static int countDistinctElements(int[] nums, int start, int end) {\\n        boolean[] visited = new boolean[100001]; // assuming values are less than 100001\\n        int count = 0;\\n        for (int i = start; i <= end; i++) {\\n            if (!visited[nums[i]]) {\\n                visited[nums[i]] = true;\\n                count++;\\n            }\\n        }\\n        return count;\\n}}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/22b6e345-a194-4819-9449-bed0b0eb321b_1683435836.4436464.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      \\n        int n = nums.length;\\n        int[] diff = new int[n];\\n        \\n        // iterate through each index\\n        for (int i = 0; i < n; i++) {\\n            int countPrefix = countDistinctElements(nums, 0, i);\\n            int countSuffix = countDistinctElements(nums, i + 1, n - 1);\\n            diff[i] = countPrefix - countSuffix;\\n        }\\n        \\n        return diff;\\n    }\\n    \\n    private static int countDistinctElements(int[] nums, int start, int end) {\\n        boolean[] visited = new boolean[100001]; // assuming values are less than 100001\\n        int count = 0;\\n        for (int i = start; i <= end; i++) {\\n            if (!visited[nums[i]]) {\\n                visited[nums[i]] = true;\\n                count++;\\n            }\\n        }\\n        return count;\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788773,
                "title": "java-easy-solution-using-set",
                "content": "# Complexity\\n- Time complexity: O(N * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Set<Integer> prefix = new HashSet<>();\\n        for(int i = 0; i < n; i ++) {\\n            prefix.add(nums[i]);\\n\\n            Set<Integer> suffix = new HashSet<>();\\n            for(int j = i + 1; j < n; j ++)\\n               suffix.add(nums[j]);\\n\\n            ans[i] = prefix.size() - suffix.size();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Set<Integer> prefix = new HashSet<>();\\n        for(int i = 0; i < n; i ++) {\\n            prefix.add(nums[i]);\\n\\n            Set<Integer> suffix = new HashSet<>();\\n            for(int j = i + 1; j < n; j ++)\\n               suffix.add(nums[j]);\\n\\n            ans[i] = prefix.size() - suffix.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497052,
                "title": "100-fast-c-unordered-map-well-explained",
                "content": "# Intuition\\nWe need to find the difference between the number of distinct elements in the suffix of an element and the number of distinct elements in its prefix. We can achieve this by using two hash maps, one to keep track of the prefix and another to keep track of the suffix.\\n\\n- We can start by creating an empty hash map m1 to keep track of the prefix. We can iterate through the array and add each element to m1, incrementing its count.\\n\\n- We can then create another empty hash map m2 to keep track of the suffix. We can iterate through the array again, adding each element to m2, incrementing its count, and calculating the difference between the size of m2 and m1.\\n\\n- To get the difference in the number of distinct elements, we can subtract the size of m1 from the size of m2.\\n\\n- After calculating the difference, we can push it into a result vector v.\\n\\n- To update m1 for the next element, we can decrement the count of the current element in m1 and remove it from m1 if its count becomes zero.\\n\\n- Finally, we can return the result vector v.\\n\\nOverall, the approach involves using hash maps to keep track of the prefix and suffix and iterating through the array twice to calculate the difference between the number of distinct elements in the prefix and suffix of each element.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem asks to find the distinct difference array of the given array, which can be solved using two pointers approach and hash maps.\\n\\n1. We first create two hash maps, m1, and m2. Here m1 will be used to keep track of the elements in the suffix and m2 will be used to keep track of the elements in the prefix.\\n\\n2. Then we loop through the array from left to right and for each element, we add it to the m2 map and remove it from the m1 map.\\n\\n3. After adding the current element to the m2 map, we calculate the difference in the size of m2 and m1 maps. This gives us the number of distinct elements in the prefix and the number of distinct elements in the suffix.\\n\\n4. We store this difference value in the resultant array, which gives us the distinct difference array of the given array.\\n\\n5. We continue this process for each element of the array and return the resultant array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity**: As we are iterating through the array only once and performing constant time operations for each element.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity**: As we are using two hash maps to store the elements, the space required will be linear in terms of the size of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> m1;\\n        for(int i=0;i<nums.size();i++)\\n            m1[nums[i]]++;\\n        unordered_map<int,int> m2;\\n        vector<int> v;\\n        for(int i=0;i<nums.size();i++){\\n            m2[nums[i]]++;\\n            m1[nums[i]]--;\\n            if(m1[nums[i]]==0)\\n                m1.erase(nums[i]);\\n            int diff=m2.size()-m1.size();\\n            v.push_back(diff);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> m1;\\n        for(int i=0;i<nums.size();i++)\\n            m1[nums[i]]++;\\n        unordered_map<int,int> m2;\\n        vector<int> v;\\n        for(int i=0;i<nums.size();i++){\\n            m2[nums[i]]++;\\n            m1[nums[i]]--;\\n            if(m1[nums[i]]==0)\\n                m1.erase(nums[i]);\\n            int diff=m2.size()-m1.size();\\n            v.push_back(diff);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495320,
                "title": "c-best-solution-set-prefix-suffix-easy-to-understand",
                "content": ">\\n\\n# Complexity\\n- Time complexity: $$O(n logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(4n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        set<int> suffSet, prefSet;\\n        vector<int> suff(nums.size()), pref(nums.size()), ans(nums.size());\\n        \\n        for(int i=0; i<nums.size(); i++)   \\n            suffSet.insert(nums[i]), suff[i] = suffSet.size();\\n        \\n        for(int i=nums.size() - 1; i>=0; i--)   \\n            pref[i] = prefSet.size(), prefSet.insert(nums[i]);\\n        \\n        for(int i=0; i<nums.size(); i++)    ans[i] = suff[i] - pref[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Suffix Array",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        set<int> suffSet, prefSet;\\n        vector<int> suff(nums.size()), pref(nums.size()), ans(nums.size());\\n        \\n        for(int i=0; i<nums.size(); i++)   \\n            suffSet.insert(nums[i]), suff[i] = suffSet.size();\\n        \\n        for(int i=nums.size() - 1; i>=0; i--)   \\n            pref[i] = prefSet.size(), prefSet.insert(nums[i]);\\n        \\n        for(int i=0; i<nums.size(); i++)    ans[i] = suff[i] - pref[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495158,
                "title": "best-simple-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> map1 = new HashMap<>();\\n        HashMap<Integer,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            map2.put(nums[i],map2.getOrDefault(nums[i],0)+1);\\n        }\\n        int[] diff = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            map2.put(nums[i],map2.get(nums[i])-1);\\n            if(map2.get(nums[i])==0) map2.remove(nums[i]);\\n            map1.put(nums[i],map1.getOrDefault(nums[i],0)+1);\\n            diff[i] = map1.size()-map2.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> map1 = new HashMap<>();\\n        HashMap<Integer,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            map2.put(nums[i],map2.getOrDefault(nums[i],0)+1);\\n        }\\n        int[] diff = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            map2.put(nums[i],map2.get(nums[i])-1);\\n            if(map2.get(nums[i])==0) map2.remove(nums[i]);\\n            map1.put(nums[i],map1.getOrDefault(nums[i],0)+1);\\n            diff[i] = map1.size()-map2.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495101,
                "title": "c-hashset",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int[] DistinctDifferenceArray(int[] nums) \\n    {\\n        int n = nums.Length;\\n        int[] result = new int[n];\\n        HashSet<int> distinctElements = new HashSet<int>();\\n\\n        distinctElements.Add(nums[n-1]);\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            result[i] = -distinctElements.Count;\\n            distinctElements.Add(nums[i]);\\n        }\\n\\n        distinctElements.Clear();\\n\\n        for (int i = 0; i <= n - 1; i++)\\n        {\\n            distinctElements.Add(nums[i]);\\n            result[i] += distinctElements.Count;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int[] DistinctDifferenceArray(int[] nums) \\n    {\\n        int n = nums.Length;\\n        int[] result = new int[n];\\n        HashSet<int> distinctElements = new HashSet<int>();\\n\\n        distinctElements.Add(nums[n-1]);\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            result[i] = -distinctElements.Count;\\n            distinctElements.Add(nums[i]);\\n        }\\n\\n        distinctElements.Clear();\\n\\n        for (int i = 0; i <= n - 1; i++)\\n        {\\n            distinctElements.Add(nums[i]);\\n            result[i] += distinctElements.Count;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494977,
                "title": "brute-force-simple",
                "content": "\\n\\n# Approach\\nBrute Force using Sets \\nCheck size of pre stack and post stack for each index of nums.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        set<int>preSet;\\n        set<int>postSet;\\n        \\n        for(int i=0;i<n;i++){\\n            preSet.clear();\\n            postSet.clear();\\n            for(int j=0;j<=i;j++){\\n               preSet.insert(nums[j]);\\n            }\\n            for(int k=i+1;k<n;k++){\\n                postSet.insert(nums[k]);\\n            }\\n             ans[i]=preSet.size()-postSet.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease Upvote.",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        set<int>preSet;\\n        set<int>postSet;\\n        \\n        for(int i=0;i<n;i++){\\n            preSet.clear();\\n            postSet.clear();\\n            for(int j=0;j<=i;j++){\\n               preSet.insert(nums[j]);\\n            }\\n            for(int k=i+1;k<n;k++){\\n                postSet.insert(nums[k]);\\n            }\\n             ans[i]=preSet.size()-postSet.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494957,
                "title": "c-o-n-prefix-suffix-and-set",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> s1, s2;\\n        vector<int> pre, suf(nums.size());\\n        int count = 0;\\n        // prefix array\\n        for(auto i : nums) {\\n            if(s1.find(i) == s1.end()) count++;\\n            pre.push_back(count);\\n            s1.insert(i);\\n        }\\n        // suffix array\\n        count = 0;\\n        for(int i = nums.size()-1; i > 0; i--) {\\n            if(s2.find(nums[i]) == s2.end()) count++;\\n            suf[i - 1] = count;\\n            s2.insert(nums[i]);\\n        }\\n        // ans;\\n        for(int i = 0; i < nums.size(); i++) {\\n            pre[i] = pre[i] - suf[i];\\n        }\\n        return pre;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> s1, s2;\\n        vector<int> pre, suf(nums.size());\\n        int count = 0;\\n        // prefix array\\n        for(auto i : nums) {\\n            if(s1.find(i) == s1.end()) count++;\\n            pre.push_back(count);\\n            s1.insert(i);\\n        }\\n        // suffix array\\n        count = 0;\\n        for(int i = nums.size()-1; i > 0; i--) {\\n            if(s2.find(nums[i]) == s2.end()) count++;\\n            suf[i - 1] = count;\\n            s2.insert(nums[i]);\\n        }\\n        // ans;\\n        for(int i = 0; i < nums.size(); i++) {\\n            pre[i] = pre[i] - suf[i];\\n        }\\n        return pre;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494872,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        Set<Integer> pre = new HashSet();\\n        int res[] = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            pre.add(nums[i]);\\n            Set<Integer> suf = new HashSet();\\n            for(int j=i+1; j<nums.length; j++)  suf.add(nums[j]);\\n            res[i] = pre.size()-suf.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        Set<Integer> pre = new HashSet();\\n        int res[] = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            pre.add(nums[i]);\\n            Set<Integer> suf = new HashSet();\\n            for(int j=i+1; j<nums.length; j++)  suf.add(nums[j]);\\n            res[i] = pre.size()-suf.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537410,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            Set<Integer> prefixSet = new HashSet();\\n            Set<Integer> suffixSet = new HashSet();\\n            for(int j = 0; j < nums.length; j++) {\\n                if(j <= i) {\\n                    prefixSet.add(nums[j]);\\n                }\\n                if(j > i) {\\n                    suffixSet.add(nums[j]);\\n                }\\n            }\\n            diff[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            Set<Integer> prefixSet = new HashSet();\\n            Set<Integer> suffixSet = new HashSet();\\n            for(int j = 0; j < nums.length; j++) {\\n                if(j <= i) {\\n                    prefixSet.add(nums[j]);\\n                }\\n                if(j > i) {\\n                    suffixSet.add(nums[j]);\\n                }\\n            }\\n            diff[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496884,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        left=0\\n        right=n-1\\n        ans=[]\\n        while left<n:\\n            ans.append(len(set(nums[0:left+1]))-len(set(nums[left+1:right+1])))\\n            right+=1\\n            left+=1\\n\\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        left=0\\n        right=n-1\\n        ans=[]\\n        while left<n:\\n            ans.append(len(set(nums[0:left+1]))-len(set(nums[left+1:right+1])))\\n            right+=1\\n            left+=1\\n\\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495220,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    const n = nums.length;\\n    const diff = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; i++) {\\n            const prefix = new Set();\\n            const suffix = new Set();\\n        \\n            prefix.add(nums[0]);        \\n            for (let j = 1; j <= i; j++) {\\n             if (!prefix.has(nums[j])) prefix.add(nums[j]);\\n             }\\n        \\n            for (let j = i+1; j < n; j++) {\\n             if(!suffix.has(nums[j])) suffix.add(nums[j]);\\n             }\\n                \\n        const prefixSize = prefix.size;\\n        const suffixSize = suffix.size;\\n\\n        diff[i] = prefixSize - suffixSize;\\n    }\\n\\n    return diff;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    const n = nums.length;\\n    const diff = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; i++) {\\n            const prefix = new Set();\\n            const suffix = new Set();\\n        \\n            prefix.add(nums[0]);        \\n            for (let j = 1; j <= i; j++) {\\n             if (!prefix.has(nums[j])) prefix.add(nums[j]);\\n             }\\n        \\n            for (let j = i+1; j < n; j++) {\\n             if(!suffix.has(nums[j])) suffix.add(nums[j]);\\n             }\\n                \\n        const prefixSize = prefix.size;\\n        const suffixSize = suffix.size;\\n\\n        diff[i] = prefixSize - suffixSize;\\n    }\\n\\n    return diff;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495125,
                "title": "java-simple-approach-using-hashset-for-unique-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n.define array for storing value after find difference \\nint [] diff = new int[n];\\n. find prefix \\n.find suffix\\n.find prefix.size()-suffix.size();\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n                int n = nums.length;\\n        int[] diff = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> prefix = new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                prefix.add(nums[j]);\\n            }\\n\\n            Set<Integer> suffix = new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                suffix.add(nums[j]);\\n            }\\n\\n            diff[i] = prefix.size() - suffix.size();\\n        }\\n\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n                int n = nums.length;\\n        int[] diff = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> prefix = new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                prefix.add(nums[j]);\\n            }\\n\\n            Set<Integer> suffix = new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                suffix.add(nums[j]);\\n            }\\n\\n            diff[i] = prefix.size() - suffix.size();\\n        }\\n\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495022,
                "title": "easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt1(n,0),cnt2(n,0);\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> x,y;\\n        for(int i=0;i<n;i++){\\n            x[nums[i]]=1;\\n            y[nums[n-i-1]]=1;\\n            cnt1[i]=x.size();\\n            cnt2[n-i-1]=y.size();\\n        }\\n        for(int i=0;i<n-1;i++){\\n            ans[i]=cnt1[i]-cnt2[i+1];\\n        }\\n        ans[n-1]=cnt1[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt1(n,0),cnt2(n,0);\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> x,y;\\n        for(int i=0;i<n;i++){\\n            x[nums[i]]=1;\\n            y[nums[n-i-1]]=1;\\n            cnt1[i]=x.size();\\n            cnt2[n-i-1]=y.size();\\n        }\\n        for(int i=0;i<n-1;i++){\\n            ans[i]=cnt1[i]-cnt2[i+1];\\n        }\\n        ans[n-1]=cnt1[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494955,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>arr(nums.size());\\n        int index;\\n        set<int>set;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int left=0;\\n            int right =0;\\n            for(int j=0;j<=i;j++){\\n                set.insert(nums[j]);\\n        }\\n            left =set.size();\\n            set.clear();\\n            \\n            for(int k= i+1;k<nums.size();k++){\\n                set.insert(nums[k]);\\n        }\\n            right  =set.size();\\n            set.clear();\\n            arr[index++]= left -right;\\n    }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>arr(nums.size());\\n        int index;\\n        set<int>set;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int left=0;\\n            int right =0;\\n            for(int j=0;j<=i;j++){\\n                set.insert(nums[j]);\\n        }\\n            left =set.size();\\n            set.clear();\\n            \\n            for(int k= i+1;k<nums.size();k++){\\n                set.insert(nums[k]);\\n        }\\n            right  =set.size();\\n            set.clear();\\n            arr[index++]= left -right;\\n    }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494886,
                "title": "go-use-two-map",
                "content": "# Complexity\\n- Time complexity: $$O(2n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc distinctDifferenceArray(nums []int) []int {\\n\\tn := len(nums)\\n\\tres := make([]int, n)\\n\\tm1, m2 := make(map[int]int), make(map[int]int)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm2[nums[i]]++\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm1[nums[i]]++\\n\\t\\tm2[nums[i]]--\\n\\t\\tif m2[nums[i]] == 0 {\\n\\t\\t\\tdelete(m2, nums[i])\\n\\t\\t}\\n\\t\\tres[i] = len(m1) - len(m2)\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctDifferenceArray(nums []int) []int {\\n\\tn := len(nums)\\n\\tres := make([]int, n)\\n\\tm1, m2 := make(map[int]int), make(map[int]int)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm2[nums[i]]++\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm1[nums[i]]++\\n\\t\\tm2[nums[i]]--\\n\\t\\tif m2[nums[i]] == 0 {\\n\\t\\t\\tdelete(m2, nums[i])\\n\\t\\t}\\n\\t\\tres[i] = len(m1) - len(m2)\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049310,
                "title": "c-o-n-using-map-set-very-simple-easy",
                "content": "**Idea :** \\n1. To count distinct element from front, we are using a set data structure simply and inserting the elements into it during the traversal. In this case, st.size() is the required prefix value.\\n\\n2. To count distinct elements from back, we are using a map. In the map we have already stored the counts of the elements. We have taken a variable \"cnt\" which basically stores the count of distinct values in the array. \\n\\n3. During the traversal, we decrement the element\\'s frequency in the map and whenever this frequency of any element = 0, we can infer that a distinct element which used to exist earlier has now been gone i.e. it does not exist in the right -> so we decrement cnt (cnt--)\\n\\n4. So during each iteration, we get this st.size() and cnt to calculate the required difference as (st.size()-cnt).\\n\\n```\\n vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        \\n        int cnt = 0; // cnt distinct from back\\n        for(auto i : nums){\\n            mp[i]++;\\n        }\\n        \\n        for(auto it : mp){\\n            if(it.second>0){cnt++;}\\n        }\\n        \\n        unordered_set<int>st;  // cnt distinct from start\\n        \\n        for(auto i : nums){\\n            st.insert(i);\\n            mp[i]--;\\n            if(mp[i]==0){cnt--;}\\n            \\n            ans.push_back(st.size()-cnt);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nTime : O(N)\\nSpace : O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\n vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>mp;\\n        \\n        int cnt = 0; // cnt distinct from back\\n        for(auto i : nums){\\n            mp[i]++;\\n        }\\n        \\n        for(auto it : mp){\\n            if(it.second>0){cnt++;}\\n        }\\n        \\n        unordered_set<int>st;  // cnt distinct from start\\n        \\n        for(auto i : nums){\\n            st.insert(i);\\n            mp[i]--;\\n            if(mp[i]==0){cnt--;}\\n            \\n            ans.push_back(st.size()-cnt);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957510,
                "title": "prefix-sum-algorithm-without-unnecessary-actions-and-iterations",
                "content": "```\\nvar distinctDifferenceArray = function(nums) {\\n    const set = new Set()\\n    const res = []\\n    \\n    for (let num of nums) {\\n        set.add(num)\\n        res.push(set.size)\\n    }\\n    \\n    set.clear()\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        res[i] = res[i] - set.size\\n        set.add(nums[i])\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distinctDifferenceArray = function(nums) {\\n    const set = new Set()\\n    const res = []\\n    \\n    for (let num of nums) {\\n        set.add(num)\\n        res.push(set.size)\\n    }\\n    \\n    set.clear()\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        res[i] = res[i] - set.size\\n        set.add(nums[i])\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3674642,
                "title": "java-using-hashset-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nArrays using HashSet as we had a special property in HashSet that it won\\'t store any element twice.\\n\\n# Approach\\nCreate a 2 new arrays one to have prefix unique elements and another for suffiix and subract values as per repuirement \\nHere - prefix[i] - suffix[i+1]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        int i, len = nums.length;\\n        int[] prefix = new int[len];\\n        int[] suffix = new int[len];\\n        for(i=0;i<len;i++){\\n            hs.add(nums[i]);\\n            prefix[i] = hs.size();\\n        }\\n        hs.clear();\\n        for(i=len-1;i>=0;i--){\\n            hs.add(nums[i]);\\n            suffix[i] = hs.size();\\n        }\\n        for(i=0;i<len-1;i++){\\n            nums[i] = prefix[i] - suffix[i+1];\\n        }\\n        nums[len-1] =  prefix[len-1];\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        int i, len = nums.length;\\n        int[] prefix = new int[len];\\n        int[] suffix = new int[len];\\n        for(i=0;i<len;i++){\\n            hs.add(nums[i]);\\n            prefix[i] = hs.size();\\n        }\\n        hs.clear();\\n        for(i=len-1;i>=0;i--){\\n            hs.add(nums[i]);\\n            suffix[i] = hs.size();\\n        }\\n        for(i=0;i<len-1;i++){\\n            nums[i] = prefix[i] - suffix[i+1];\\n        }\\n        nums[len-1] =  prefix[len-1];\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661035,
                "title": "simple-set-solution-c-easy-to-understand-using-pre-count-and-post-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int> distinctDifferenceArray(vector<int>& nums) {\\n         int n = nums.size();\\n         int i = 0;  \\n         vector<int> ans;\\n\\n         while(i<n){\\n             int postcount = 0;\\n             int precount = 0;\\n             set<int> count;\\n             for(int j=i+1;j<n;j++){\\n                 count.insert(nums[j]);\\n             }\\n             postcount = count.size();\\n             count.clear();\\n            \\n             for(int j=0;j<=i;j++){\\n                 count.insert(nums[j]);\\n             }\\n             precount = count.size();\\n             count.clear();\\n\\n             ans.push_back((precount - postcount));\\n             i++;\\n\\n         }\\n\\n         return ans;\\n     }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> distinctDifferenceArray(vector<int>& nums) {\\n         int n = nums.size();\\n         int i = 0;  \\n         vector<int> ans;\\n\\n         while(i<n){\\n             int postcount = 0;\\n             int precount = 0;\\n             set<int> count;\\n             for(int j=i+1;j<n;j++){\\n                 count.insert(nums[j]);\\n             }\\n             postcount = count.size();\\n             count.clear();\\n            \\n             for(int j=0;j<=i;j++){\\n                 count.insert(nums[j]);\\n             }\\n             precount = count.size();\\n             count.clear();\\n\\n             ans.push_back((precount - postcount));\\n             i++;\\n\\n         }\\n\\n         return ans;\\n     }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640133,
                "title": "python-hash-map",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        pre={nums[0]:1}\\n        suf={}\\n        res=[]\\n        for j in range(1,len(nums)):\\n            if nums[j] in suf:\\n                suf[nums[j]]+=1\\n            else:\\n                suf[nums[j]]=1\\n        for i in range(len(nums)-1):\\n            res.append(len(pre)-len(suf))\\n            if nums[i+1] in pre:\\n                pre[nums[i+1]]+=1\\n            else:\\n                pre[nums[i+1]]=1\\n            suf[nums[i+1]]-=1\\n            if suf[nums[i+1]]==0:\\n                suf.pop(nums[i+1])\\n        res.append(len(pre)-len(suf))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        pre={nums[0]:1}\\n        suf={}\\n        res=[]\\n        for j in range(1,len(nums)):\\n            if nums[j] in suf:\\n                suf[nums[j]]+=1\\n            else:\\n                suf[nums[j]]=1\\n        for i in range(len(nums)-1):\\n            res.append(len(pre)-len(suf))\\n            if nums[i+1] in pre:\\n                pre[nums[i+1]]+=1\\n            else:\\n                pre[nums[i+1]]=1\\n            suf[nums[i+1]]-=1\\n            if suf[nums[i+1]]==0:\\n                suf.pop(nums[i+1])\\n        res.append(len(pre)-len(suf))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637902,
                "title": "short-c-code-single-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse unordered_set to know count of unique element in a running iteration.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nus1 will give unqiue element count for the prefix part and us2 will give unique element count for suffix part. Since, in answer we want prefix-suffix, prefix part\\'s count is added and suffix\\'s count is subtracted. The reason of subtracting before inserting to us2 is because suffix part starts from i+1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n =  nums.size();\\n        vector<int> ans(n,0);\\n        unordered_set<int> us1,us2;\\n        for(int i = 0; i < n; i++){\\n            us1.insert(nums[i]);\\n            ans[n-i-1] -= us2.size();\\n            us2.insert(nums[n-i-1]);\\n            ans[i] += us1.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n =  nums.size();\\n        vector<int> ans(n,0);\\n        unordered_set<int> us1,us2;\\n        for(int i = 0; i < n; i++){\\n            us1.insert(nums[i]);\\n            ans[n-i-1] -= us2.size();\\n            us2.insert(nums[n-i-1]);\\n            ans[i] += us1.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537385,
                "title": "simple-java-solution-for-beginners-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int[nums.length];\\n        Set<Integer> prefixSet = new HashSet();\\n        Set<Integer> suffixSet = new HashSet();\\n        for(int i = 0; i < nums.length; i++) {\\n            prefixSet.clear();\\n            suffixSet.clear();\\n            for(int j = 0; j < nums.length; j++) {\\n                if(j <= i) {\\n                    if(!prefixSet.contains(nums[j])) {\\n                        prefixSet.add(nums[j]);\\n                    }\\n                }\\n                if(j > i) {\\n                    if(!suffixSet.contains(nums[j])) {\\n                        suffixSet.add(nums[j]);\\n                    }\\n                }\\n            }\\n            diff[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int[nums.length];\\n        Set<Integer> prefixSet = new HashSet();\\n        Set<Integer> suffixSet = new HashSet();\\n        for(int i = 0; i < nums.length; i++) {\\n            prefixSet.clear();\\n            suffixSet.clear();\\n            for(int j = 0; j < nums.length; j++) {\\n                if(j <= i) {\\n                    if(!prefixSet.contains(nums[j])) {\\n                        prefixSet.add(nums[j]);\\n                    }\\n                }\\n                if(j > i) {\\n                    if(!suffixSet.contains(nums[j])) {\\n                        suffixSet.add(nums[j]);\\n                    }\\n                }\\n            }\\n            diff[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516323,
                "title": "easy-to-understand-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            ans.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            ans.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511746,
                "title": "find-the-distinct-difference-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res =[]\\n        for num in range(len(nums)):\\n            prefix_num = len(set(nums[:num+1]))\\n            suffix_num = len(set(nums[num+1:]))\\n            res.append(prefix_num - suffix_num)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res =[]\\n        for num in range(len(nums)):\\n            prefix_num = len(set(nums[:num+1]))\\n            suffix_num = len(set(nums[num+1:]))\\n            res.append(prefix_num - suffix_num)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509571,
                "title": "linear-time-complexity-simple-and-easy-approach-with-explanation",
                "content": "# Intuition\\nUsing map as suffix and set as prefix.\\n\\n# Approach\\nUsing the map as suffix and the set as prefix\\nwhile we are traversing we put the current element in the prefix and then we see if there are more than one instance of that element exists then we will leave it in the prefix as well as suffix (or in the map and the set) if there was only one copy of that element was in the array then we remove it from the map (or the suffix ) and add into the prefix (set) and push the difference of their size in the ans vector.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>mp; // first we stored all the elements in the map \\n\\n        for(auto it:nums){\\n             mp[it]++;\\n        }\\n        set<int>st; // we used a set to store the prefix values\\n        vector<int>ans;\\n        for(auto it:nums){\\n           st.insert(it); // we inserted it into the set\\n           mp[it]--; // decremented the count of that element from the map used as suffix\\n           if(mp[it]==0) mp.erase(it); // if there was only one element then we delete it from suffix and the return the size of diff of prefix-suffix that is set-map and if there was more than one value of that element was present then it will exist in both pre and suffix \\n           ans.push_back(st.size()-mp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>mp; // first we stored all the elements in the map \\n\\n        for(auto it:nums){\\n             mp[it]++;\\n        }\\n        set<int>st; // we used a set to store the prefix values\\n        vector<int>ans;\\n        for(auto it:nums){\\n           st.insert(it); // we inserted it into the set\\n           mp[it]--; // decremented the count of that element from the map used as suffix\\n           if(mp[it]==0) mp.erase(it); // if there was only one element then we delete it from suffix and the return the size of diff of prefix-suffix that is set-map and if there was more than one value of that element was present then it will exist in both pre and suffix \\n           ans.push_back(st.size()-mp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502007,
                "title": "we-can-just-use-unordered-set",
                "content": "```\\nvector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        unordered_set<int>st ;\\n        int n = nums.size() ;\\n        vector<int>pre(n+1 , 0) , diff(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int sz1 = st.size() ;\\n            st.insert(nums[i]) ;\\n            int sz2 = st.size() ;\\n            if(sz1 != sz2)\\n            {\\n                pre[i+1] = pre[i]+1;\\n            }\\n            else\\n            {\\n                pre[i+1] = pre[i];\\n            }\\n        }\\n        \\n        unordered_set<int>st2 ;\\n        vector<int> suf(n+1 , 0) ;\\n        for(int i = n-1 ; i >= 0 ; i--)\\n        {\\n            int sz1 = st2.size() ;\\n            st2.insert(nums[i]) ;\\n            int sz2 = st2.size() ;\\n            if(sz1 != sz2)\\n            {\\n                suf[i] = suf[i+1]+1;\\n            }\\n            else\\n            {\\n                suf[i] = suf[i+1];\\n            }\\n        }\\n        \\n        for(auto it : pre)\\n        {\\n            cout << it << \" \" ;\\n        }\\n        cout << endl;\\n        for(auto it : suf)\\n        {\\n            cout << it << \" \" ;\\n        }\\n        int tt = st.size() ;\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            diff[i-1] = pre[i] - suf[i] ;\\n        }\\n        \\n        return diff ;\\n        \\n        \\n    }\\n```\\n\\nwe can just make two vectors for prefix and suffix by checking if size of a set is changing or not .\\nOn subtracting prefix - suffix diffrence array will be created . \\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nvector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        unordered_set<int>st ;\\n        int n = nums.size() ;\\n        vector<int>pre(n+1 , 0) , diff(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int sz1 = st.size() ;\\n            st.insert(nums[i]) ;\\n            int sz2 = st.size() ;\\n            if(sz1 != sz2)\\n            {\\n                pre[i+1] = pre[i]+1;\\n            }\\n            else\\n            {\\n                pre[i+1] = pre[i];\\n            }\\n        }\\n        \\n        unordered_set<int>st2 ;\\n        vector<int> suf(n+1 , 0) ;\\n        for(int i = n-1 ; i >= 0 ; i--)\\n        {\\n            int sz1 = st2.size() ;\\n            st2.insert(nums[i]) ;\\n            int sz2 = st2.size() ;\\n            if(sz1 != sz2)\\n            {\\n                suf[i] = suf[i+1]+1;\\n            }\\n            else\\n            {\\n                suf[i] = suf[i+1];\\n            }\\n        }\\n        \\n        for(auto it : pre)\\n        {\\n            cout << it << \" \" ;\\n        }\\n        cout << endl;\\n        for(auto it : suf)\\n        {\\n            cout << it << \" \" ;\\n        }\\n        int tt = st.size() ;\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            diff[i-1] = pre[i] - suf[i] ;\\n        }\\n        \\n        return diff ;\\n        \\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3501138,
                "title": "rust-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing a hashset to iterate backward to calculate the negation part and to iterate forward to calculate positive part separately.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut s = HashSet::new();\\n        let n = nums.len();\\n        let mut ret = vec![0; n]; \\n\\n        for i in (1 .. n).rev() {\\n            s.insert(nums[i]);\\n            ret[i - 1] -= s.len() as i32;\\n        }\\n\\n        s.clear();\\n        for i in 0 .. n {\\n            s.insert(nums[i]);\\n            ret[i] += s.len() as i32;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut s = HashSet::new();\\n        let n = nums.len();\\n        let mut ret = vec![0; n]; \\n\\n        for i in (1 .. n).rev() {\\n            s.insert(nums[i]);\\n            ret[i - 1] -= s.len() as i32;\\n        }\\n\\n        s.clear();\\n        for i in 0 .. n {\\n            s.insert(nums[i]);\\n            ret[i] += s.len() as i32;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3499529,
                "title": "c-solution-using-unordered-maps-100-efficient",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> before,after;\\n        vector<int> ans;\\n        //first put every element in the after map..\\n        for(int i=0;i<nums.size();i++){\\n            after[nums[i]]++;\\n        }\\n        //now remove ith nums from the after map and add it in the before map then calculte the diff and put it in the vector named ans;\\n        for(int i=0;i<nums.size();i++){\\n            after[nums[i]]--;\\n            before[nums[i]]++;\\n            //if frequency of nums[i] in after map is 0 then remove it so we don\\'t count it in the calculation..\\n            if(after[nums[i]]==0)\\n               after.erase(nums[i]);\\n             ans.push_back(before.size()-after.size());  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int> before,after;\\n        vector<int> ans;\\n        //first put every element in the after map..\\n        for(int i=0;i<nums.size();i++){\\n            after[nums[i]]++;\\n        }\\n        //now remove ith nums from the after map and add it in the before map then calculte the diff and put it in the vector named ans;\\n        for(int i=0;i<nums.size();i++){\\n            after[nums[i]]--;\\n            before[nums[i]]++;\\n            //if frequency of nums[i] in after map is 0 then remove it so we don\\'t count it in the calculation..\\n            if(after[nums[i]]==0)\\n               after.erase(nums[i]);\\n             ans.push_back(before.size()-after.size());  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497699,
                "title": "find-the-distinct-difference-array-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to find the difference between the count of distinct numbers in the array before and after a certain index. One way to solve this problem is to iterate through the array and for each index, count the number of distinct elements in the subarray before that index and the number of distinct elements in the subarray after that index. Then, calculate the difference and store it in the answer array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use two sets, pre and suf, to keep track of the distinct elements in the subarray before and after the current index, respectively. We iterate through the array, and for each index i, we insert all elements from index 0 to i in the pre set and all elements from index i+1 to n-1 in the suf set. We then calculate the difference between the sizes of the two sets, which gives us the number of distinct elements before and after the current index. We store this difference in the answer array and clear the sets before moving on to the next index.set\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(n^2), where n is the size of the input array. This is because for each index, we insert all elements from index 0 to i in the pre set and all elements from index i+1 to n-1 in the suf set, which takes O(n) time. Since we do this for every index, the time complexity becomes O(n^2).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the size of the input array. This is because we are using two sets of size at most n to store the distinct elements before and after each index. The answer array also has size n.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        set<int>pre;\\n        vector<int>ans;\\n        set<int>suf;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++) pre.insert(nums[j]);\\n            for(int k=i+1;k<n;k++) suf.insert(nums[k]);\\n        int x=pre.size();\\n            int y=suf.size();\\n            ans.push_back(x-y);\\n              pre.clear();\\n            suf.clear();\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        set<int>pre;\\n        vector<int>ans;\\n        set<int>suf;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=i;j++) pre.insert(nums[j]);\\n            for(int k=i+1;k<n;k++) suf.insert(nums[k]);\\n        int x=pre.size();\\n            int y=suf.size();\\n            ans.push_back(x-y);\\n              pre.clear();\\n            suf.clear();\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497518,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            res.append(len(set(nums[:i+1])) - len(set(nums[i + 1:])))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            res.append(len(set(nums[:i+1])) - len(set(nums[i + 1:])))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496549,
                "title": "java-easy-solution-using-hashmap",
                "content": "# Intuition \\nThe brute fore method i have used but it can be optimised using hashset in a single loop.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> prefix = new HashMap<>();\\n        HashMap<Integer,Integer> suffix = new HashMap<>();\\n        int[] ans = new int[nums.length];\\n        int[] prearr = new int[nums.length];\\n        int[] suffarr = new int[nums.length];\\n\\n        int k =0;\\n        int x = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j =0; j<=i; j++){\\n                if(!prefix.containsKey(nums[j])){\\n                    prefix.put(nums[j],1);\\n                }\\n            }\\n            int pref_val = prefix.size();\\n            k++;\\n\\n            // System.out.println( prefix.size() + \" prefix\");\\n            \\n            int count = 0;\\n            for(int j = i+1; j<n; j++){\\n                \\n                if(!suffix.containsKey(nums[j])){\\n                    suffix.put(nums[j],1);\\n                }\\n                \\n            }\\n            int suff_val = suffix.size();\\n            suffix.clear();\\n\\n            ans[i] = pref_val - suff_val;\\n            \\n            System.out.println(suff_val);\\n        }\\n        \\n        \\n       \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> prefix = new HashMap<>();\\n        HashMap<Integer,Integer> suffix = new HashMap<>();\\n        int[] ans = new int[nums.length];\\n        int[] prearr = new int[nums.length];\\n        int[] suffarr = new int[nums.length];\\n\\n        int k =0;\\n        int x = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j =0; j<=i; j++){\\n                if(!prefix.containsKey(nums[j])){\\n                    prefix.put(nums[j],1);\\n                }\\n            }\\n            int pref_val = prefix.size();\\n            k++;\\n\\n            // System.out.println( prefix.size() + \" prefix\");\\n            \\n            int count = 0;\\n            for(int j = i+1; j<n; j++){\\n                \\n                if(!suffix.containsKey(nums[j])){\\n                    suffix.put(nums[j],1);\\n                }\\n                \\n            }\\n            int suff_val = suffix.size();\\n            suffix.clear();\\n\\n            ans[i] = pref_val - suff_val;\\n            \\n            System.out.println(suff_val);\\n        }\\n        \\n        \\n       \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495879,
                "title": "hashset-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            Set<Integer>set1=new HashSet<>();\\n            Set<Integer>set2=new HashSet<>();\\n            \\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<n;j++){\\n                set2.add(nums[j]);\\n            }\\n            \\n            ans[i]= set1.size() - set2.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            Set<Integer>set1=new HashSet<>();\\n            Set<Integer>set2=new HashSet<>();\\n            \\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<n;j++){\\n                set2.add(nums[j]);\\n            }\\n            \\n            ans[i]= set1.size() - set2.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495856,
                "title": "python3-one-line",
                "content": "First of all, I remembered this problem [Find the Prefix Common Array of Two Arrays](https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/) and the approach used to solve it ([[Python3] One line](https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/discuss/3467605/python3-one-line)), but instead of crossing, you need to take the difference between the left and right parts.\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495389,
                "title": "c-hashing",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int,int> pref,suff;\\n        int n= nums.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++)suff[nums[i]]++;\\n        for (int i=0; i<n; i++){\\n            suff[nums[i]]--;\\n            pref[nums[i]]++;\\n            if (suff[nums[i]]==0)suff.erase(nums[i]);\\n            ans.push_back(pref.size()-suff.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int,int> pref,suff;\\n        int n= nums.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++)suff[nums[i]]++;\\n        for (int i=0; i<n; i++){\\n            suff[nums[i]]--;\\n            pref[nums[i]]++;\\n            if (suff[nums[i]]==0)suff.erase(nums[i]);\\n            ans.push_back(pref.size()-suff.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495292,
                "title": "java-easy-to-understand-for-beginners",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> hs = new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                hs.add(nums[j]);\\n            }\\n            HashSet<Integer> js = new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                js.add(nums[j]);\\n            }\\n            res[i] = hs.size()-js.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> hs = new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                hs.add(nums[j]);\\n            }\\n            HashSet<Integer> js = new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                js.add(nums[j]);\\n            }\\n            res[i] = hs.size()-js.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495223,
                "title": "easy-to-understand-typescript-solution",
                "content": "# Code\\n```\\nfunction distinctDifferenceArray(nums: number[]): number[] {\\n    let diffs = new Array(nums.length);\\n\\n    for(let i=0; i<nums.length; i++){\\n        for(let i=0; i<nums.length; i++){\\n        let prefix = new Set( nums.slice(0, i + 1));\\n        let suffix = new Set( nums.slice(i+1, nums.length+1));\\n        diffs[i] = prefix.size - suffix.size;\\n    }\\n\\n    return diffs;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction distinctDifferenceArray(nums: number[]): number[] {\\n    let diffs = new Array(nums.length);\\n\\n    for(let i=0; i<nums.length; i++){\\n        for(let i=0; i<nums.length; i++){\\n        let prefix = new Set( nums.slice(0, i + 1));\\n        let suffix = new Set( nums.slice(i+1, nums.length+1));\\n        diffs[i] = prefix.size - suffix.size;\\n    }\\n\\n    return diffs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495221,
                "title": "brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintaing the prefix and suffix count\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> diff(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        unordered_set<int> prefix, suffix;\\n        int prefix_size = 0, suffix_size = 0;\\n\\n        // Compute the size of the prefix set\\n        for (int j = 0; j <= i; j++) {\\n            if (!prefix.count(nums[j])) {\\n                prefix.insert(nums[j]);\\n                prefix_size++;\\n            }\\n        }\\n\\n        // Compute the size of the suffix set\\n        for (int j = i + 1; j < n; j++) {\\n            if (!suffix.count(nums[j])) {\\n                suffix.insert(nums[j]);\\n                suffix_size++;\\n            }\\n        }\\n        diff[i] = prefix_size - suffix_size;\\n\\n    }\\n\\n     return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> diff(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        unordered_set<int> prefix, suffix;\\n        int prefix_size = 0, suffix_size = 0;\\n\\n        // Compute the size of the prefix set\\n        for (int j = 0; j <= i; j++) {\\n            if (!prefix.count(nums[j])) {\\n                prefix.insert(nums[j]);\\n                prefix_size++;\\n            }\\n        }\\n\\n        // Compute the size of the suffix set\\n        for (int j = i + 1; j < n; j++) {\\n            if (!suffix.count(nums[j])) {\\n                suffix.insert(nums[j]);\\n                suffix_size++;\\n            }\\n        }\\n        diff[i] = prefix_size - suffix_size;\\n\\n    }\\n\\n     return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495120,
                "title": "beats-100-simple-solution-c",
                "content": "![image.png](https://assets.leetcode.com/users/images/05ae6c6d-aa6e-40cb-b02e-e45724468ee0_1683433085.243885.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhere we use the technique of the hashmap \\n-whether the elements are unique or not \\n-by putting them into hashmap \\nand counting the distinct elements\\n# Complexity\\n- Time complexity:$O(n^2)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr,int pos)\\n    {\\n        int hash1[51]={0};\\n        int hash2[51]={0};\\n        int first=pos;\\n        int leftdistinct=0,rightdistinct=0;\\n        int last=pos+1;\\n        while(first>=0)\\n        {\\n            if(hash1[arr[first]]==0)\\n            {hash1[arr[first]]=arr[first];\\n                leftdistinct++;\\n            }\\n            first--;\\n        }\\n        while(last<arr.size())\\n        {\\n            if(hash2[arr[last]]==0)\\n            {hash2[arr[last]]=arr[last];\\n                rightdistinct++;\\n            }\\n            last++;\\n        }\\n        return leftdistinct-rightdistinct;\\n    }\\n    vector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(check(nums,i));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![e5cc6438-63d7-47fb-84d1-e4e36cf43c6e_1683003574.1370602.png](https://assets.leetcode.com/users/images/ec82e2cc-b1ea-4e5b-889c-8e6d692fab9d_1683433036.901454.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr,int pos)\\n    {\\n        int hash1[51]={0};\\n        int hash2[51]={0};\\n        int first=pos;\\n        int leftdistinct=0,rightdistinct=0;\\n        int last=pos+1;\\n        while(first>=0)\\n        {\\n            if(hash1[arr[first]]==0)\\n            {hash1[arr[first]]=arr[first];\\n                leftdistinct++;\\n            }\\n            first--;\\n        }\\n        while(last<arr.size())\\n        {\\n            if(hash2[arr[last]]==0)\\n            {hash2[arr[last]]=arr[last];\\n                rightdistinct++;\\n            }\\n            last++;\\n        }\\n        return leftdistinct-rightdistinct;\\n    }\\n    vector<int> distinctDifferenceArray(vector<int>& nums) \\n    {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(check(nums,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495051,
                "title": "easy-brute-force-and-optimized-solution-map-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force is pretty staright forward, Optimal solution can be solved using variation of sliding Window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is the implementation of the function `distinctDifferenceArray`, which takes a vector of integers `v` as input and returns another vector `ans`. The purpose of this function is to calculate the distinct difference array of the input vector.\\n\\nThe distinct difference array of a vector `v` is another vector `ans` such that `ans[i]` is the number of distinct values in the subvector `v[0:i]` of `v` after taking the differences of adjacent elements.\\n\\nThe function first initializes two maps `m1` and `m2` to keep track of the frequency of each element in the subvector `v[0:i]` and `v[i+1:n-1]` respectively. It then loops through the input vector `v` and updates the maps `m1` and `m2` accordingly.\\n\\nFor each element `v[i]`, the function increments the frequency of `v[i]` in `m1` and removes it from `m2` if its frequency becomes zero. It then calculates the difference in size between `m1` and `m2`, which represents the number of distinct values in the subvector `v[0:i]` after taking the differences of adjacent elements. This value is appended to the `ans` vector.\\n\\nFinally, the function returns the `ans` vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Brute Force Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int>s1,s2;\\n            for(int j=0;j<=i;j++)\\n                s1.insert(v[j]);\\n            for(int j=i+1;j<n;j++)\\n                s2.insert(v[j]);\\n            ans.push_back(s1.size()-s2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n#Optimal Code using MAP\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& v) {\\n        int n=v.size();\\n        map<int,int>m1,m2;\\n        for(auto i:v)\\n            m2[i]++;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            m2[v[i]]--;\\n            if(m2[v[i]]==0)\\n                m2.erase(v[i]);\\n            m1[v[i]]++;\\n            ans.push_back(m1.size()-m2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int>s1,s2;\\n            for(int j=0;j<=i;j++)\\n                s1.insert(v[j]);\\n            for(int j=i+1;j<n;j++)\\n                s2.insert(v[j]);\\n            ans.push_back(s1.size()-s2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& v) {\\n        int n=v.size();\\n        map<int,int>m1,m2;\\n        for(auto i:v)\\n            m2[i]++;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            m2[v[i]]--;\\n            if(m2[v[i]]==0)\\n                m2.erase(v[i]);\\n            m1[v[i]]++;\\n            ans.push_back(m1.size()-m2.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494978,
                "title": "c-maps-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++){m1[nums[i]]++;}\\n        for(int i=0; i<nums.size(); i++){\\n            m2[nums[i]]++;\\n            m1[nums[i]]--;\\n            if(m1[nums[i]]==0){\\n                m1.erase(nums[i]);\\n            }\\n            ans.push_back(m2.size()-m1.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++){m1[nums[i]]++;}\\n        for(int i=0; i<nums.size(); i++){\\n            m2[nums[i]]++;\\n            m1[nums[i]]--;\\n            if(m1[nums[i]]==0){\\n                m1.erase(nums[i]);\\n            }\\n            ans.push_back(m2.size()-m1.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494958,
                "title": "c-solution-100-beat-using-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        set<int>left;\\n        vector<int>prefix(n);\\n        for(int i=0;i<n;i++){\\n            left.insert(nums[i]);\\n            prefix[i]=left.size();\\n        }\\n        set<int>right;\\n        vector<int>sufix(n);\\n        for(int i=n-1;i>=0;i--){\\n            sufix[i]=right.size();\\n            right.insert(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=prefix[i]-sufix[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        set<int>left;\\n        vector<int>prefix(n);\\n        for(int i=0;i<n;i++){\\n            left.insert(nums[i]);\\n            prefix[i]=left.size();\\n        }\\n        set<int>right;\\n        vector<int>sufix(n);\\n        for(int i=n-1;i>=0;i--){\\n            sufix[i]=right.size();\\n            right.insert(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=prefix[i]-sufix[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494918,
                "title": "easy-java-solution-using-hashset-but-18-ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int[] d=new int[n];\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> pre=new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                pre.add(nums[j]);\\n            }\\n            Set<Integer> suf=new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                suf.add(nums[j]);\\n            }\\n            d[i]=pre.size()-suf.size();\\n        }\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int[] d=new int[n];\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> pre=new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                pre.add(nums[j]);\\n            }\\n            Set<Integer> suf=new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                suf.add(nums[j]);\\n            }\\n            d[i]=pre.size()-suf.size();\\n        }\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494903,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int index = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int left = 0;\\n            int right = 0;\\n            for(int j = 0; j <= i; j++) {\\n                set.add(nums[j]);\\n            }\\n            left = set.size();\\n            set.clear();\\n            \\n            for(int k = i+1; k < nums.length; k++) {\\n                set.add(nums[k]);\\n            }\\n            right = set.size();\\n            set.clear();\\n            arr[index++] = left - right; \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int index = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int left = 0;\\n            int right = 0;\\n            for(int j = 0; j <= i; j++) {\\n                set.add(nums[j]);\\n            }\\n            left = set.size();\\n            set.clear();\\n            \\n            for(int k = i+1; k < nums.length; k++) {\\n                set.add(nums[k]);\\n            }\\n            right = set.size();\\n            set.clear();\\n            arr[index++] = left - right; \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494901,
                "title": "easiest-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<int> diff(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        int prefixDistinct = 0;\\n        int suffixDistinct = 0;\\n\\n        vector<bool> prefixSeen(n, false);\\n        vector<bool> suffixSeen(n, false);\\n\\n        for (int j = 0; j <= i; j++) {\\n            if (!prefixSeen[nums[j]]) {\\n                prefixDistinct++;\\n                prefixSeen[nums[j]] = true;\\n            }\\n        }\\n\\n        for (int j = n - 1; j > i; j--) {\\n            if (!suffixSeen[nums[j]]) {\\n                suffixDistinct++;\\n                suffixSeen[nums[j]] = true;\\n            }\\n        }\\n\\n        diff[i] = prefixDistinct - suffixDistinct;\\n    }\\n\\n    return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n    vector<int> diff(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        int prefixDistinct = 0;\\n        int suffixDistinct = 0;\\n\\n        vector<bool> prefixSeen(n, false);\\n        vector<bool> suffixSeen(n, false);\\n\\n        for (int j = 0; j <= i; j++) {\\n            if (!prefixSeen[nums[j]]) {\\n                prefixDistinct++;\\n                prefixSeen[nums[j]] = true;\\n            }\\n        }\\n\\n        for (int j = n - 1; j > i; j--) {\\n            if (!suffixSeen[nums[j]]) {\\n                suffixDistinct++;\\n                suffixSeen[nums[j]] = true;\\n            }\\n        }\\n\\n        diff[i] = prefixDistinct - suffixDistinct;\\n    }\\n\\n    return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494882,
                "title": "c-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> st;\\n        vector<int> pre;\\n        for(auto i : nums){\\n            st.insert(i);\\n            pre.push_back(st.size());\\n        }\\n        st.clear();\\n        vector<int> suff;\\n        suff.push_back(0);\\n        for(int i=nums.size()-1;i>=0;i--){\\n            st.insert(nums[i]);\\n            suff.push_back(st.size());\\n        }\\n        reverse(suff.begin(),suff.end());\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suff[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> st;\\n        vector<int> pre;\\n        for(auto i : nums){\\n            st.insert(i);\\n            pre.push_back(st.size());\\n        }\\n        st.clear();\\n        vector<int> suff;\\n        suff.push_back(0);\\n        for(int i=nums.size()-1;i>=0;i--){\\n            st.insert(nums[i]);\\n            suff.push_back(st.size());\\n        }\\n        reverse(suff.begin(),suff.end());\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suff[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494850,
                "title": "c-solution-with-linq",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int[] DistinctDifferenceArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n];\\n        \\n        for (var i = 0; i < n; i++)\\n            result[i] = nums[..(i + 1)].Distinct().Count() - nums[(i + 1)..].Distinct().Count();\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] DistinctDifferenceArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n];\\n        \\n        for (var i = 0; i < n; i++)\\n            result[i] = nums[..(i + 1)].Distinct().Count() - nums[(i + 1)..].Distinct().Count();\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095752,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n,0);\\n        set<int> st;\\n\\n        \\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n            v[i]=st.size();\\n        }\\n        st.clear();\\n        for(int i=n-2;i>=0;i--){\\n            st.insert(nums[i+1]);\\n            v[i]=v[i]-st.size();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n,0);\\n        set<int> st;\\n\\n        \\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n            v[i]=st.size();\\n        }\\n        st.clear();\\n        for(int i=n-2;i>=0;i--){\\n            st.insert(nums[i+1]);\\n            v[i]=v[i]-st.size();\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095164,
                "title": "simple-c-solution",
                "content": "# Intuition\\nThe code aims to calculate the difference in the count of distinct elements between the left and right subarrays for each position in the input array `nums`. This difference is then stored in the `answer` vector.\\n\\n# Approach\\nThe approach involves iterating through the input array `nums` and, for each position `i`, calculating the count of distinct elements in the left subarray (from index 0 to i) and the count of distinct elements in the right subarray (from index i+1 to the end). The difference in these counts is then appended to the `answer` vector.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, where n is the length of the input array `nums`. This is because, for each element in `nums`, we calculate the difference in distinct elements between the left and right subarrays, which involves traversing these subarrays.\\n  \\n- Space complexity: $$O(n)$$, where n is the length of the input array `nums`. We use two unordered sets, `left` and `right`, to store distinct elements in the left and right subarrays, respectively.\\n\\n# Code Explanation\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> answer;  // Initialize a vector to store the differences in distinct elements\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            // Create an unordered set for distinct elements in the left subarray (from 0 to i)\\n            unordered_set<int> left(nums.begin(), nums.begin() + i + 1);\\n            \\n            // Create an unordered set for distinct elements in the right subarray (from i+1 to end)\\n            unordered_set<int> right(nums.begin() + i + 1, nums.end());\\n            \\n            // Calculate the difference in the counts of distinct elements between left and right subarrays\\n            answer.push_back(left.size() - right.size());\\n        }\\n        \\n        return answer;  // Return the vector containing differences in distinct elements\\n    }\\n};\\n```\\n\\nThe code defines a `Solution` class with a method `distinctDifferenceArray` that takes a vector `nums` as input. The function iterates over the elements of the input array, calculating the difference in distinct elements between the left and right subarrays for each position. The differences are stored in a vector, which is then returned.",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> answer;  // Initialize a vector to store the differences in distinct elements\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            // Create an unordered set for distinct elements in the left subarray (from 0 to i)\\n            unordered_set<int> left(nums.begin(), nums.begin() + i + 1);\\n            \\n            // Create an unordered set for distinct elements in the right subarray (from i+1 to end)\\n            unordered_set<int> right(nums.begin() + i + 1, nums.end());\\n            \\n            // Calculate the difference in the counts of distinct elements between left and right subarrays\\n            answer.push_back(left.size() - right.size());\\n        }\\n        \\n        return answer;  // Return the vector containing differences in distinct elements\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094872,
                "title": "one-line-solution-using-list-comprehensions-and-sets",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1])) - len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1])) - len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066857,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n[]=new int[nums.length];\\n        int p=0;\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> s=new HashSet();\\n            for(int j=i+1;j<nums.length;j++){\\n               s.add(nums[j]);\\n            }\\n            Set<Integer> s1=new HashSet<>();\\n            for(int k=0;k<=i;k++){\\n                s1.add(nums[k]);\\n            }\\n            n[p++]=s1.size()-s.size();\\n            s.clear();\\n            s1.clear();\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n[]=new int[nums.length];\\n        int p=0;\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> s=new HashSet();\\n            for(int j=i+1;j<nums.length;j++){\\n               s.add(nums[j]);\\n            }\\n            Set<Integer> s1=new HashSet<>();\\n            for(int k=0;k<=i;k++){\\n                s1.add(nums[k]);\\n            }\\n            n[p++]=s1.size()-s.size();\\n            s.clear();\\n            s1.clear();\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056390,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n\\n        l = 0\\n\\n        while l < len(nums):\\n            pre = len(set(nums[:l+1]))\\n            post = len(set(nums[l+1:]))\\n            res.append(pre-post)\\n            l += 1\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res = []\\n\\n        l = 0\\n\\n        while l < len(nums):\\n            pre = len(set(nums[:l+1]))\\n            post = len(set(nums[l+1:]))\\n            res.append(pre-post)\\n            l += 1\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054783,
                "title": "optimized-code-using-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Firstly, an unordered set called  st  is declared to store distinct elements from the input vector. \\n2.  A vector called  left  is created with the same size as the input vector, initialized with zeros. This vector will store the result. \\n3. The code then iterates through the input vector from left to right using a for loop. In each iteration, it performs the following steps: \\n   - Inserts the current element  nums[i]  into the unordered set  st . \\n   - Updates the corresponding element in the  left  vector with the current size of the set  st  using the  size()  function. \\n4. The unordered set  st  is cleared to prepare for the next iteration. \\n5. The code then enters another for loop that iterates through the input vector from right to left, starting from the second-to-last element. In each iteration, it performs the following steps: \\n   - Inserts the next element  nums[i + 1]  into the unordered set  st . \\n   - Updates the corresponding element in the  left  vector by subtracting the current size of the set  st  from the previous value in the  left  vector. \\n6. Finally, the  left  vector, which now contains the desired result, is returned from the function. \\n![image_2023-09-17_130516022.png](https://assets.leetcode.com/users/images/745f3f78-eb7c-49b9-9315-41b28f2606b3_1694936121.7739694.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> st;\\n        int n = nums.size();\\n        vector<int> left(n, 0);\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            st.insert(nums[i]);\\n            left[i] = st.size();\\n        }\\n\\n        st.clear();\\n\\n        for (int i = n - 2; i >= 0; --i)\\n        {\\n            st.insert(nums[i + 1]);\\n            left[i] = left[i] - st.size();\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_set<int> st;\\n        int n = nums.size();\\n        vector<int> left(n, 0);\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            st.insert(nums[i]);\\n            left[i] = st.size();\\n        }\\n\\n        st.clear();\\n\\n        for (int i = n - 2; i >= 0; --i)\\n        {\\n            st.insert(nums[i + 1]);\\n            left[i] = left[i] - st.size();\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046903,
                "title": "easy-python-solution-python",
                "content": "# EASY PYTHON SOLUTION || PYTHON || \\u270C\\u270C\\n\\n# Runtime\\n- 102ms\\n- Beats 75.00%of users with Python3\\n# Memory\\n- 16.24MB\\n- Beats 77.50%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        \\n        res = []\\n        for i in range(0,len(nums)):\\n            lset = set(nums[0:i+1])\\n            rset = set(nums[i+1:])\\n            #print(\"left\",len(lset),\\'right\\',len(rset))\\n            res.append(len(lset)-len(rset))\\n        \\n        return (res)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        \\n        res = []\\n        for i in range(0,len(nums)):\\n            lset = set(nums[0:i+1])\\n            rset = set(nums[i+1:])\\n            #print(\"left\",len(lset),\\'right\\',len(rset))\\n            res.append(len(lset)-len(rset))\\n        \\n        return (res)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039599,
                "title": "java-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            Set prefixSet = new HashSet();\\n            for (int j = 0; j <= i; j++) {\\n                prefixSet.add(nums[j]);\\n            }\\n            Set suffixSet = new HashSet();\\n            for (int j = nums.length - 1; j > i; j--) {\\n                suffixSet.add(nums[j]);\\n            }\\n            res[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            Set prefixSet = new HashSet();\\n            for (int j = 0; j <= i; j++) {\\n                prefixSet.add(nums[j]);\\n            }\\n            Set suffixSet = new HashSet();\\n            for (int j = nums.length - 1; j > i; j--) {\\n                suffixSet.add(nums[j]);\\n            }\\n            res[i] = prefixSet.size() - suffixSet.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032011,
                "title": "java-solve-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer>set1 = new HashSet();\\n            Set<Integer>set2 = new HashSet();\\n\\n            for(int j=0; j<=i; j++){\\n                set1.add(nums[j]);\\n            }\\n\\n            for(int j=i+1; j<nums.length; j++){\\n                set2.add(nums[j]);\\n            }\\n            ans[i] = set1.size()-set2.size();\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int ans[] = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer>set1 = new HashSet();\\n            Set<Integer>set2 = new HashSet();\\n\\n            for(int j=0; j<=i; j++){\\n                set1.add(nums[j]);\\n            }\\n\\n            for(int j=i+1; j<nums.length; j++){\\n                set2.add(nums[j]);\\n            }\\n            ans[i] = set1.size()-set2.size();\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024655,
                "title": "java-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n\\n        for(int i = 0; i<nums.length; i++){\\n        HashSet<Integer> lset = new HashSet<>();\\n        HashSet<Integer> rset = new HashSet<>();\\n            for(int j = 0; j<nums.length; j++){\\n                if(j <= i){\\n                    lset.add(nums[j]);\\n                }else{\\n                    rset.add(nums[j]);\\n                }\\n                \\n            }\\n            res[i] = lset.size() - rset.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n\\n        for(int i = 0; i<nums.length; i++){\\n        HashSet<Integer> lset = new HashSet<>();\\n        HashSet<Integer> rset = new HashSet<>();\\n            for(int j = 0; j<nums.length; j++){\\n                if(j <= i){\\n                    lset.add(nums[j]);\\n                }else{\\n                    rset.add(nums[j]);\\n                }\\n                \\n            }\\n            res[i] = lset.size() - rset.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009569,
                "title": "java-solution-array-manipulation-using-boolean-flag-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n\\n        int prefix = 0;\\n        int result[] = new int[nums.length];\\n\\n        boolean flag[] = new boolean[51];\\n        for(int i = 0; i < nums.length; i++){\\n\\n            prefix = 0;\\n\\n            for(int j = 0; j <= i; j++){\\n                if(!flag[nums[j]]){\\n                    prefix++;\\n                    flag[nums[j]] = true;\\n                }\\n            }\\n\\n            Arrays.fill(flag, false);\\n\\n            for(int j = i + 1; j < nums.length; j++){\\n                if(!flag[nums[j]]){\\n                    prefix--;\\n                    flag[nums[j]] = true;\\n                }\\n            }\\n\\n            Arrays.fill(flag, false);\\n\\n            result[i] = prefix;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n\\n        int prefix = 0;\\n        int result[] = new int[nums.length];\\n\\n        boolean flag[] = new boolean[51];\\n        for(int i = 0; i < nums.length; i++){\\n\\n            prefix = 0;\\n\\n            for(int j = 0; j <= i; j++){\\n                if(!flag[nums[j]]){\\n                    prefix++;\\n                    flag[nums[j]] = true;\\n                }\\n            }\\n\\n            Arrays.fill(flag, false);\\n\\n            for(int j = i + 1; j < nums.length; j++){\\n                if(!flag[nums[j]]){\\n                    prefix--;\\n                    flag[nums[j]] = true;\\n                }\\n            }\\n\\n            Arrays.fill(flag, false);\\n\\n            result[i] = prefix;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998616,
                "title": "96-beats-solution-using-set-in-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        Set temp = new HashSet<>();\\n        int[] suffix = new int[n];\\n        for(int i = 0; i<nums.length; i++){\\n            temp.add(nums[i]);\\n            prefix[i] = temp.size();\\n        }\\n\\n        temp = new HashSet<>();\\n        temp.add(nums[n-1]);\\n        for(int i = n-2; i>=0; i--){\\n            suffix[i] = temp.size();\\n            temp.add(nums[i]);\\n        }\\n\\n\\n\\n        for(int i = 0; i<nums.length; i++){\\n            prefix[i]-=suffix[i];\\n        }\\n\\n        return prefix;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        Set temp = new HashSet<>();\\n        int[] suffix = new int[n];\\n        for(int i = 0; i<nums.length; i++){\\n            temp.add(nums[i]);\\n            prefix[i] = temp.size();\\n        }\\n\\n        temp = new HashSet<>();\\n        temp.add(nums[n-1]);\\n        for(int i = n-2; i>=0; i--){\\n            suffix[i] = temp.size();\\n            temp.add(nums[i]);\\n        }\\n\\n\\n\\n        for(int i = 0; i<nums.length; i++){\\n            prefix[i]-=suffix[i];\\n        }\\n\\n        return prefix;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994949,
                "title": "elixir-using-set-map",
                "content": "```\\ndefmodule Solution do\\n  @spec distinct_difference_array(nums :: [integer]) :: [integer]\\n  def distinct_difference_array(nums) do\\n    mp = nums |> Enum.reduce(%{}, fn n, acc -> Map.update(acc, n, 1, &(&1 + 1)) end)\\n\\n    nums\\n    |> Enum.reduce({[], %MapSet{}, mp}, fn n, {acc, st, mp} ->\\n      mp = delete(mp, n)\\n      st = MapSet.put(st, n)\\n      acc = [MapSet.size(st) - map_size(mp) | acc]\\n      {acc, st, mp}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\n\\n  defp delete(mp, k) do\\n    mp = Map.update!(mp, k, &(&1 -1))\\n\\n    if mp[k] == 0 do\\n      Map.delete(mp, k)\\n    else\\n      mp\\n    end\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec distinct_difference_array(nums :: [integer]) :: [integer]\\n  def distinct_difference_array(nums) do\\n    mp = nums |> Enum.reduce(%{}, fn n, acc -> Map.update(acc, n, 1, &(&1 + 1)) end)\\n\\n    nums\\n    |> Enum.reduce({[], %MapSet{}, mp}, fn n, {acc, st, mp} ->\\n      mp = delete(mp, n)\\n      st = MapSet.put(st, n)\\n      acc = [MapSet.size(st) - map_size(mp) | acc]\\n      {acc, st, mp}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\n\\n  defp delete(mp, k) do\\n    mp = Map.update!(mp, k, &(&1 -1))\\n\\n    if mp[k] == 0 do\\n      Map.delete(mp, k)\\n    else\\n      mp\\n    end\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3993750,
                "title": "98-beat-c-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n      unordered_map<int,int>l;\\n      unordered_map<int,int>f;\\n      for(int h=0; h<nums.size(); h++){\\n          l[nums[h]]++;\\n      }\\n      vector<int>d;\\n      for(int h=0; h<nums.size(); h++){\\n          f[nums[h]]++;\\n          l[nums[h]]--;\\n          if (l[nums[h]]==0)l.erase(nums[h]);\\n          d.push_back(f.size()-l.size());\\n          \\n      }\\n      return d;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n      unordered_map<int,int>l;\\n      unordered_map<int,int>f;\\n      for(int h=0; h<nums.size(); h++){\\n          l[nums[h]]++;\\n      }\\n      vector<int>d;\\n      for(int h=0; h<nums.size(); h++){\\n          f[nums[h]]++;\\n          l[nums[h]]--;\\n          if (l[nums[h]]==0)l.erase(nums[h]);\\n          d.push_back(f.size()-l.size());\\n          \\n      }\\n      return d;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988009,
                "title": "simple-java",
                "content": "Please Upvote\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            HashSet<Integer> set=new HashSet<>();\\n            HashSet<Integer> set1=new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n               set.add(nums[j]);\\n            }\\n            for(int k=i+1;k<nums.length;k++){\\n               set1.add(nums[k]);\\n            }\\n            diff[i]=set.size()-set1.size();\\n        }\\n    return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            HashSet<Integer> set=new HashSet<>();\\n            HashSet<Integer> set1=new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n               set.add(nums[j]);\\n            }\\n            for(int k=i+1;k<nums.length;k++){\\n               set1.add(nums[k]);\\n            }\\n            diff[i]=set.size()-set1.size();\\n        }\\n    return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984941,
                "title": "very-simple-elixir-solution-beats-100-of-no-doubt-numerous-elixir-programmers-out-there",
                "content": "```\\ndefmodule Solution do\\n  @spec distinct_difference_array(nums :: [integer]) :: [integer]\\n  def distinct_difference_array(nums) do\\n\\n    len = length(nums)\\n\\n    for i <- 0..(len - 1) do\\n      # Extract the suffix and prefix\\n      prefix = Enum.slice(nums, 0, i + 1)\\n      suffix = Enum.slice(nums, i + 1, len - i)\\n      # Determine a count of the distinct items in the prefix and suffix\\n      distinct_prefix_len = MapSet.new(prefix) |> MapSet.size()\\n      distinct_suffix_len = MapSet.new(suffix) |> MapSet.size()\\n      # The final line of an Elixir loop is a bit like a yield in Python\\n      # appending the result to some sort of internally generated\\n      # list which is finally returned to the caller.\\n      distinct_prefix_len - distinct_suffix_len\\n\\t  end\\n\\tend\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndefmodule Solution do\\n  @spec distinct_difference_array(nums :: [integer]) :: [integer]\\n  def distinct_difference_array(nums) do\\n\\n    len = length(nums)\\n\\n    for i <- 0..(len - 1) do\\n      # Extract the suffix and prefix\\n      prefix = Enum.slice(nums, 0, i + 1)\\n      suffix = Enum.slice(nums, i + 1, len - i)\\n      # Determine a count of the distinct items in the prefix and suffix\\n      distinct_prefix_len = MapSet.new(prefix) |> MapSet.size()\\n      distinct_suffix_len = MapSet.new(suffix) |> MapSet.size()\\n      # The final line of an Elixir loop is a bit like a yield in Python\\n      # appending the result to some sort of internally generated\\n      # list which is finally returned to the caller.\\n      distinct_prefix_len - distinct_suffix_len\\n\\t  end\\n\\tend\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3984535,
                "title": "simple-solution-for-begineer-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing hashset\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int[] res= new int[nums.length] ;\\n\\n      for(int i=0; i<nums.length ; i++){\\n           HashSet<Integer> h1 = new HashSet<>();\\n            HashSet<Integer> h2 = new HashSet<>();\\n\\n        for(int k=0; k<=i ; k++)\\n         h1.add(nums[k]) ;\\n       \\n      for(int j=i+1 ; j<nums.length && i < nums.length ;j++)\\n         h2.add(nums[j]) ;\\n\\n       res[i] = h1.size()  - h2.size() ;   \\n\\n       } \\n\\n      \\n\\n      return  res ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int[] res= new int[nums.length] ;\\n\\n      for(int i=0; i<nums.length ; i++){\\n           HashSet<Integer> h1 = new HashSet<>();\\n            HashSet<Integer> h2 = new HashSet<>();\\n\\n        for(int k=0; k<=i ; k++)\\n         h1.add(nums[k]) ;\\n       \\n      for(int j=i+1 ; j<nums.length && i < nums.length ;j++)\\n         h2.add(nums[j]) ;\\n\\n       res[i] = h1.size()  - h2.size() ;   \\n\\n       } \\n\\n      \\n\\n      return  res ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966250,
                "title": "using-arraylist-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[]=new int[nums.length];\\n        List<Integer> prefix=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!prefix.contains(nums[i]))\\n            {\\n                prefix.add(nums[i]);\\n            }\\n           if(i!=nums.length-1)\\n           {\\n           List<Integer> suffix=new ArrayList<>();\\n           for(int j=i+1;j<nums.length;j++)\\n           {\\n               if(!suffix.contains(nums[j]))\\n               {\\n                   suffix.add(nums[j]);\\n               }\\n           }\\n           diff[i]=prefix.size()-suffix.size();\\n           }\\n           else{\\n               diff[i]=prefix.size();\\n           }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[]=new int[nums.length];\\n        List<Integer> prefix=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!prefix.contains(nums[i]))\\n            {\\n                prefix.add(nums[i]);\\n            }\\n           if(i!=nums.length-1)\\n           {\\n           List<Integer> suffix=new ArrayList<>();\\n           for(int j=i+1;j<nums.length;j++)\\n           {\\n               if(!suffix.contains(nums[j]))\\n               {\\n                   suffix.add(nums[j]);\\n               }\\n           }\\n           diff[i]=prefix.size()-suffix.size();\\n           }\\n           else{\\n               diff[i]=prefix.size();\\n           }\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961892,
                "title": "amazing-six-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n\\n        for i in range(len(nums)-1):\\n            len_prefix = len(set(nums[:i+1]))\\n            len_suffix = len(set(nums[i+1:]))\\n            ans.append(len_prefix-len_suffix)\\n\\n        ans.append(len(set(nums)))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n\\n        for i in range(len(nums)-1):\\n            len_prefix = len(set(nums[:i+1]))\\n            len_suffix = len(set(nums[i+1:]))\\n            ans.append(len_prefix-len_suffix)\\n\\n        ans.append(len(set(nums)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960382,
                "title": "find-the-distinct-difference-array",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result = []\\n        for i in range(len(nums)):\\n            result.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result = []\\n        for i in range(len(nums)):\\n            result.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942108,
                "title": "python-easy-for-beginners-beats-98-second-set-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        prefix = set()\\n        output = []\\n        for i, num in enumerate(nums):\\n            prefix.add(num)\\n            output.append(len(prefix) - len(set(nums[i+1:]))) \\n        return output\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        prefix = set()\\n        output = []\\n        for i, num in enumerate(nums):\\n            prefix.add(num)\\n            output.append(len(prefix) - len(set(nums[i+1:]))) \\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941732,
                "title": "with-basics-of-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result=[]\\n        for i in range(0,len(nums)-1):\\n\\n            result.append((len(set(nums[:i+1])))-(len(set(nums[i+1:]))))\\n        result.append(len(set(nums[:len(nums)])))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result=[]\\n        for i in range(0,len(nums)-1):\\n\\n            result.append((len(set(nums[:i+1])))-(len(set(nums[i+1:]))))\\n        result.append(len(set(nums[:len(nums)])))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939732,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            set<int>prefix;\\n            set<int>suffix;\\n            for(int j=0;j<=i;j++){\\n                prefix.insert(nums[j]);\\n            }\\n            for(int k=i+1;k<nums.size();k++){\\n                suffix.insert(nums[k]);\\n            }\\n        ans.push_back((prefix.size()-suffix.size()));\\n  }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            set<int>prefix;\\n            set<int>suffix;\\n            for(int j=0;j<=i;j++){\\n                prefix.insert(nums[j]);\\n            }\\n            for(int k=i+1;k<nums.size();k++){\\n                suffix.insert(nums[k]);\\n            }\\n        ans.push_back((prefix.size()-suffix.size()));\\n  }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939438,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>pre(n);\\n        vector<int>suf(n);\\n        set<int>s1;\\n        set<int>s2;\\n        for(int i=0;i<n;i++)\\n        {\\n            s1.insert(nums[i]);\\n            pre[i]=s1.size();\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suf[i]=s2.size();\\n            s2.insert(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=pre[i]-suf[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>pre(n);\\n        vector<int>suf(n);\\n        set<int>s1;\\n        set<int>s2;\\n        for(int i=0;i<n;i++)\\n        {\\n            s1.insert(nums[i]);\\n            pre[i]=s1.size();\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suf[i]=s2.size();\\n            s2.insert(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i]=pre[i]-suf[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939138,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> distinctDifferenceArray(List<int> nums) {\\n      final List<int> ans = [];\\n      for (int i = 0; i < nums.length; i++) {\\n          ans.add(distinctDifference(nums.sublist(0, i + 1), nums.sublist(i + 1)));\\n      }\\n\\n      return ans;\\n  }\\n\\n  int distinctDifference(List<int> prefix, List<int> suffix) {\\n      return prefix.toSet().length - suffix.toSet().length;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> distinctDifferenceArray(List<int> nums) {\\n      final List<int> ans = [];\\n      for (int i = 0; i < nums.length; i++) {\\n          ans.add(distinctDifference(nums.sublist(0, i + 1), nums.sublist(i + 1)));\\n      }\\n\\n      return ans;\\n  }\\n\\n  int distinctDifference(List<int> prefix, List<int> suffix) {\\n      return prefix.toSet().length - suffix.toSet().length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935905,
                "title": "find-the-distinct-difference-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int count = 0;  \\n       int count1 = 0;  \\n       int len = nums.length;\\n       \\n       int [] result = new int[len];\\n      \\n      HashSet<Integer> set = new HashSet<>();\\n\\n      for( int i = 0 ; i < len ; i++){\\n          set.add(nums[i]);\\n         \\n         HashSet<Integer> set1 = new HashSet<>();\\n\\n         for( int j = i + 1 ; j < len ; j++)\\n             set1.add(nums[j]);\\n\\n          result[i] = set.size() - set1.size();\\n      }\\n\\n      return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int count = 0;  \\n       int count1 = 0;  \\n       int len = nums.length;\\n       \\n       int [] result = new int[len];\\n      \\n      HashSet<Integer> set = new HashSet<>();\\n\\n      for( int i = 0 ; i < len ; i++){\\n          set.add(nums[i]);\\n         \\n         HashSet<Integer> set1 = new HashSet<>();\\n\\n         for( int j = i + 1 ; j < len ; j++)\\n             set1.add(nums[j]);\\n\\n          result[i] = set.size() - set1.size();\\n      }\\n\\n      return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935165,
                "title": "using-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc distinctDifferenceArray(nums []int) []int {\\n\\n    answerArray := make([]int,len(nums))\\n    start := 0\\n\\n    for i:=0 ; i<len(nums) ; i++ {\\n\\n        diff := 0\\n\\n        //prefix map creation\\n        prefixMap := make(map[int]bool)\\n        for j:=start ; j<= i ; j++ {\\n            if _ , ok := prefixMap[nums[j]] ; !ok{\\n                prefixMap[nums[j]] = true\\n            }\\n        }\\n\\n        //suffix map creation\\n        suffixMap := make(map[int]bool)\\n        if i != len(nums)-1 {\\n            for k:=i+1 ; k<len(nums) ; k++ {\\n                if _ , ok := suffixMap[nums[k]] ; !ok{\\n                    suffixMap[nums[k]] = true\\n                }\\n            }\\n            diff = len(prefixMap) - len(suffixMap)\\n        }else{\\n            diff = len(prefixMap) - len(suffixMap)\\n        }\\n        //append the difference into the answer array\\n        answerArray[i] = diff\\n    }\\n    return answerArray\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctDifferenceArray(nums []int) []int {\\n\\n    answerArray := make([]int,len(nums))\\n    start := 0\\n\\n    for i:=0 ; i<len(nums) ; i++ {\\n\\n        diff := 0\\n\\n        //prefix map creation\\n        prefixMap := make(map[int]bool)\\n        for j:=start ; j<= i ; j++ {\\n            if _ , ok := prefixMap[nums[j]] ; !ok{\\n                prefixMap[nums[j]] = true\\n            }\\n        }\\n\\n        //suffix map creation\\n        suffixMap := make(map[int]bool)\\n        if i != len(nums)-1 {\\n            for k:=i+1 ; k<len(nums) ; k++ {\\n                if _ , ok := suffixMap[nums[k]] ; !ok{\\n                    suffixMap[nums[k]] = true\\n                }\\n            }\\n            diff = len(prefixMap) - len(suffixMap)\\n        }else{\\n            diff = len(prefixMap) - len(suffixMap)\\n        }\\n        //append the difference into the answer array\\n        answerArray[i] = diff\\n    }\\n    return answerArray\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932889,
                "title": "without-php-magic-methods",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[]\\n     */\\n function distinctDifferenceArray($nums) {\\n        $res = [];\\n        for($i=0; $i<count($nums); $i++){\\n            $suffix = $this->countSuffix($i, $nums);\\n            $prefix = $this->countPrefix($i, $nums);\\n            $res[] = $prefix - $suffix;\\n        }\\n\\n        return $res;\\n    }\\n    \\n    function countSuffix($tar, $array){\\n      $res = [];\\n        for($i = $tar+1; $i<count($array); $i++){\\n          $el = $array[$i];\\n          if(!in_array($el, $res)){\\n            $res[] = $el;\\n          }\\n        }\\n        return count($res);\\n    }\\n    \\n       function countPrefix($tar, $array){\\n      $res = [];\\n        for($i = 0; $i<=$tar; $i++){\\n          $el = $array[$i];\\n          if(!in_array($el, $res)){\\n            $res[] = $el;\\n          }\\n        }\\n        return count($res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[]\\n     */\\n function distinctDifferenceArray($nums) {\\n        $res = [];\\n        for($i=0; $i<count($nums); $i++){\\n            $suffix = $this->countSuffix($i, $nums);\\n            $prefix = $this->countPrefix($i, $nums);\\n            $res[] = $prefix - $suffix;\\n        }\\n\\n        return $res;\\n    }\\n    \\n    function countSuffix($tar, $array){\\n      $res = [];\\n        for($i = $tar+1; $i<count($array); $i++){\\n          $el = $array[$i];\\n          if(!in_array($el, $res)){\\n            $res[] = $el;\\n          }\\n        }\\n        return count($res);\\n    }\\n    \\n       function countPrefix($tar, $array){\\n      $res = [];\\n        for($i = 0; $i<=$tar; $i++){\\n          $el = $array[$i];\\n          if(!in_array($el, $res)){\\n            $res[] = $el;\\n          }\\n        }\\n        return count($res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924371,
                "title": "easy-to-understand-pthon-soluton-two-ways",
                "content": "# Intuition\\nThe intuition here is simple, we will create two sets, prefi and suffix, and keep adding numbers accordingly and then finding the difference between there lengths.\\nWe will see two approaches, one which is very basic and then the other how can we leverage python\\n\\n# Approach\\nWe will create an *ans* list and a prefix list since we will kepp adding the distinct numbers in prefix as we go ahead in array.\\n\\nWe will have two loops in the first approach, for each outer loop we will create an suffix list, in the inner list we will traverse the array for all elements to the right of index i for which we are calculating the and and keep adding distinct numbers in suffix list.\\n\\nDO upvote if you like the solution!\\n \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        prefix=set()\\n        for i in range(len(nums)):\\n            prefix.add(nums[i])\\n            suffix=set()\\n            for j in range(i+1,len(nums)):\\n                suffix.add(nums[j])\\n\\n            l=len(prefix)-len(suffix)\\n            ans.append(l)\\n\\n        \\n        return ans\\n                \\n        \\n```\\n\\n# The second approach\\nHere too we are essentially doing the same thing just we are leveraging the use of python\\n\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n\\n        for i in range(len(nums)):\\n            ans.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        prefix=set()\\n        for i in range(len(nums)):\\n            prefix.add(nums[i])\\n            suffix=set()\\n            for j in range(i+1,len(nums)):\\n                suffix.add(nums[j])\\n\\n            l=len(prefix)-len(suffix)\\n            ans.append(l)\\n\\n        \\n        return ans\\n                \\n        \\n```\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n\\n        for i in range(len(nums)):\\n            ans.append(len(set(nums[:i+1]))-len(set(nums[i+1:])))\\n\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923262,
                "title": "easy-java-solution-without-set-3ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int len = nums.length;\\n        int[] ld = new int[len];\\n        boolean[] ldMap = new boolean[51];\\n        int[] rd = new int[len];\\n        boolean[] rdMap = new boolean[51];\\n        \\n        int distincts = 0;\\n        for(int i = 0; i<len; i++) {\\n            if(!ldMap[nums[i]]) {\\n                distincts += 1;\\n                ldMap[nums[i]] = true;\\n            }\\n            ld[i] = distincts;\\n        }\\n\\n        distincts = 0;\\n        for(int i = len-1; i>=0; i--) {\\n            rd[i] = distincts;\\n            if(!rdMap[nums[i]]) {\\n                distincts += 1;\\n                rdMap[nums[i]] = true;\\n            }\\n        }\\n\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++ ) {\\n            res[i] = ld[i] - rd[i] ;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int len = nums.length;\\n        int[] ld = new int[len];\\n        boolean[] ldMap = new boolean[51];\\n        int[] rd = new int[len];\\n        boolean[] rdMap = new boolean[51];\\n        \\n        int distincts = 0;\\n        for(int i = 0; i<len; i++) {\\n            if(!ldMap[nums[i]]) {\\n                distincts += 1;\\n                ldMap[nums[i]] = true;\\n            }\\n            ld[i] = distincts;\\n        }\\n\\n        distincts = 0;\\n        for(int i = len-1; i>=0; i--) {\\n            rd[i] = distincts;\\n            if(!rdMap[nums[i]]) {\\n                distincts += 1;\\n                rdMap[nums[i]] = true;\\n            }\\n        }\\n\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++ ) {\\n            res[i] = ld[i] - rd[i] ;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921559,
                "title": "c-solution-using-function-and-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            int c1=cal_count(nums,0,i);\\n            int c2=cal_count(nums,i+1,nums.size()-1);\\n            v.push_back(c1-c2);\\n        }\\n        return v;\\n    }\\n\\n    int cal_count(vector<int>& nums, int start,int end){\\n        int n;\\n        map<int,int>m;\\n        for(int i=start;i<=end;i++){\\n         if(m.count(nums[i])!=1){\\n             n++;\\n         }\\n         m[nums[i]]=1;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            int c1=cal_count(nums,0,i);\\n            int c2=cal_count(nums,i+1,nums.size()-1);\\n            v.push_back(c1-c2);\\n        }\\n        return v;\\n    }\\n\\n    int cal_count(vector<int>& nums, int start,int end){\\n        int n;\\n        map<int,int>m;\\n        for(int i=start;i<=end;i++){\\n         if(m.count(nums[i])!=1){\\n             n++;\\n         }\\n         m[nums[i]]=1;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919056,
                "title": "python-beats-100-in-runtime-86-in-memory",
                "content": "![image](https://assets.leetcode.com/users/images/bc974491-0c21-44c2-8b63-1da1fb98c870_1692206350.833026.jpeg)\\n![image](https://assets.leetcode.com/users/images/0d03b75b-58ee-4f1d-94ed-7028703bb67d_1692206351.17603.jpeg)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/bc974491-0c21-44c2-8b63-1da1fb98c870_1692206350.833026.jpeg)\\n![image](https://assets.leetcode.com/users/images/0d03b75b-58ee-4f1d-94ed-7028703bb67d_1692206351.17603.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3918580,
                "title": "python-easy-solution-using-slicing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def distinctDifferenceArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[i+1:]))\\n            suffix = len(set(nums[:i+1]))\\n\\n            res.append(suffix-prefix)\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctDifferenceArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[i+1:]))\\n            suffix = len(set(nums[:i+1]))\\n\\n            res.append(suffix-prefix)\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917159,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef distinct_difference_array(nums)\\n  (0...nums.size).map{|i| nums[0..i].uniq.size - nums[i + 1...].uniq.size}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef distinct_difference_array(nums)\\n  (0...nums.size).map{|i| nums[0..i].uniq.size - nums[i + 1...].uniq.size}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3911828,
                "title": "python-solution-using-slices",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result: List[int] = []\\n        for index in range(len(nums)):\\n            diff = len(set(nums[0:index + 1])) - len(set(nums[index + 1:]))\\n            result.append(diff)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result: List[int] = []\\n        for index in range(len(nums)):\\n            diff = len(set(nums[0:index + 1])) - len(set(nums[index + 1:]))\\n            result.append(diff)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911719,
                "title": "rust-solution-using-hashsets",
                "content": "# Functional Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\\n        (0..nums.len())\\n            .map(|index| {\\n                let prefix = nums\\n                    .iter()\\n                    .enumerate()\\n                    .filter(|(i, _v)| *i <= index)\\n                    .map(|(_, &v)| v)\\n                    .collect::<HashSet<i32>>()\\n                    .len() as i32;\\n                let suffix = nums\\n                    .iter()\\n                    .skip(index + 1)\\n                    .map(|&v| v)\\n                    .collect::<HashSet<i32>>()\\n                    .len() as i32;\\n                prefix - suffix\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```\\n\\n# Code using For Loops\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array_1(nums: Vec<i32>) -> Vec<i32> {\\n        let mut result = vec![];\\n        for index in 0..nums.len() {\\n            let (mut prefix, mut suffix) = (HashSet::new(), HashSet::new());\\n            for (i, num) in nums.iter().enumerate() {\\n                if i <= index {\\n                    prefix.insert(num);\\n                    continue;\\n                }\\n                suffix.insert(num);\\n            }\\n            let diff = prefix.len() as i32 - suffix.len() as i32;\\n            result.push(diff);\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\\n        (0..nums.len())\\n            .map(|index| {\\n                let prefix = nums\\n                    .iter()\\n                    .enumerate()\\n                    .filter(|(i, _v)| *i <= index)\\n                    .map(|(_, &v)| v)\\n                    .collect::<HashSet<i32>>()\\n                    .len() as i32;\\n                let suffix = nums\\n                    .iter()\\n                    .skip(index + 1)\\n                    .map(|&v| v)\\n                    .collect::<HashSet<i32>>()\\n                    .len() as i32;\\n                prefix - suffix\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_difference_array_1(nums: Vec<i32>) -> Vec<i32> {\\n        let mut result = vec![];\\n        for index in 0..nums.len() {\\n            let (mut prefix, mut suffix) = (HashSet::new(), HashSet::new());\\n            for (i, num) in nums.iter().enumerate() {\\n                if i <= index {\\n                    prefix.insert(num);\\n                    continue;\\n                }\\n                suffix.insert(num);\\n            }\\n            let diff = prefix.len() as i32 - suffix.len() as i32;\\n            result.push(diff);\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911089,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distinctDifferenceArray(int* nums, int N, int* returnSize){\\n    int *fre = (int*)calloc(51, sizeof(int));\\n    int *prefix = (int*)calloc(51, sizeof(int));\\n    int *ans = (int*)malloc(N * sizeof(int));\\n\\n    *returnSize = N;\\n    int count = 0;\\n    int pre = 0;\\n    \\n    for(int i = 0; i < N; i++){\\n        if(fre[nums[i]] == 0){\\n        count++;\\n        }\\n        fre[nums[i]]++;\\n    }\\n    \\n    for(int i = 0; i < N; i++){\\n\\n        if(prefix[nums[i]] == 0){\\n            pre++;\\n            prefix[nums[i]]++;\\n        }\\n        if(fre[nums[i]] - 1 == 0){\\n            count--;\\n        }        \\n        fre[nums[i]]--;\\n\\n        ans[i] = pre - count;\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distinctDifferenceArray(int* nums, int N, int* returnSize){\\n    int *fre = (int*)calloc(51, sizeof(int));\\n    int *prefix = (int*)calloc(51, sizeof(int));\\n    int *ans = (int*)malloc(N * sizeof(int));\\n\\n    *returnSize = N;\\n    int count = 0;\\n    int pre = 0;\\n    \\n    for(int i = 0; i < N; i++){\\n        if(fre[nums[i]] == 0){\\n        count++;\\n        }\\n        fre[nums[i]]++;\\n    }\\n    \\n    for(int i = 0; i < N; i++){\\n\\n        if(prefix[nums[i]] == 0){\\n            pre++;\\n            prefix[nums[i]]++;\\n        }\\n        if(fre[nums[i]] - 1 == 0){\\n            count--;\\n        }        \\n        fre[nums[i]]--;\\n\\n        ans[i] = pre - count;\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908561,
                "title": "how-can-i-optimize-this-further",
                "content": "\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int res[]=new int[nums.length];\\n       Set<Integer> set1=new HashSet<>();\\n       Set<Integer> set2=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int p=0;p<=i;p++){\\n                set1.add(nums[p]);\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                \\n                set2.add(nums[j]);\\n                // System.out.println(set);\\n\\n            }\\n            // int s=set.size();\\n            // System.out.println(s);\\n            res[i]=set1.size()-set2.size();\\n            // System.out.println(res[i]);\\n            set1.clear();set2.clear();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int res[]=new int[nums.length];\\n       Set<Integer> set1=new HashSet<>();\\n       Set<Integer> set2=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int p=0;p<=i;p++){\\n                set1.add(nums[p]);\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                \\n                set2.add(nums[j]);\\n                // System.out.println(set);\\n\\n            }\\n            // int s=set.size();\\n            // System.out.println(s);\\n            res[i]=set1.size()-set2.size();\\n            // System.out.println(res[i]);\\n            set1.clear();set2.clear();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905519,
                "title": "easy-solution-beats-90-hashmap-explained",
                "content": "\\n## Approach Explanation\\n\\nFirst traverse through the entire array and store the frequency in the suffix map and on Second traversal increase the count in the prefix map and also decrease the count in suffix map.If frequency of that element becomes zero in suffix map ,then remove it and take difference of the two maps size and store it in the answer array! \\n\\n## Code \\n\\n```java\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        HashMap<Integer, Integer> suffix = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            suffix.put(nums[i], suffix.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            prefix.put(nums[i], prefix.getOrDefault(nums[i], 0) + 1);\\n            suffix.put(nums[i], suffix.getOrDefault(nums[i], 0) - 1);\\n            if (suffix.get(nums[i]) == 0) {\\n                suffix.remove(nums[i]);\\n            }\\n            ans[i] = prefix.size() - suffix.size();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        HashMap<Integer, Integer> suffix = new HashMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            suffix.put(nums[i], suffix.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            prefix.put(nums[i], prefix.getOrDefault(nums[i], 0) + 1);\\n            suffix.put(nums[i], suffix.getOrDefault(nums[i], 0) - 1);\\n            if (suffix.get(nums[i]) == 0) {\\n                suffix.remove(nums[i]);\\n            }\\n            ans[i] = prefix.size() - suffix.size();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903189,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashSet<Integer>h1= new HashSet();\\n        HashSet<Integer>h2= new HashSet();\\n        int n=nums.length;\\n        int[] p=new int[n];\\n        int[] s=new int[n];\\n        int[] ans=new int[n];\\n        for(int i=0;i<n;i++){\\n            if(!h1.contains(nums[i])){\\n                h1.add(nums[i]);\\n            }\\n            p[i]=h1.size();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(!h2.contains(nums[i])){\\n                h2.add(nums[i]);\\n            }\\n            s[i]=h2.size();\\n        }\\n        for(int i=0;i<n-1;i++){\\n            \\n            ans[i]=p[i]-s[i+1];\\n        }\\n        ans[n-1]=p[n-1];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashSet<Integer>h1= new HashSet();\\n        HashSet<Integer>h2= new HashSet();\\n        int n=nums.length;\\n        int[] p=new int[n];\\n        int[] s=new int[n];\\n        int[] ans=new int[n];\\n        for(int i=0;i<n;i++){\\n            if(!h1.contains(nums[i])){\\n                h1.add(nums[i]);\\n            }\\n            p[i]=h1.size();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(!h2.contains(nums[i])){\\n                h2.add(nums[i]);\\n            }\\n            s[i]=h2.size();\\n        }\\n        for(int i=0;i<n-1;i++){\\n            \\n            ans[i]=p[i]-s[i+1];\\n        }\\n        ans[n-1]=p[n-1];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889070,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int n = nums.length;\\n       int[] res = new int[n];\\n       for(int i=0;i<n;i++)\\n       {\\n           HashSet<Integer> hs = new HashSet<>();\\n           for(int j=0;j<=i;j++)\\n           {\\n               hs.add(nums[j]);\\n           }\\n           HashSet<Integer> js = new HashSet<>();\\n           for(int j=i+1;j<n;j++)\\n           {\\n               js.add(nums[j]);\\n           }\\n           res[i] = hs.size()-js.size();\\n       }\\n       return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       int n = nums.length;\\n       int[] res = new int[n];\\n       for(int i=0;i<n;i++)\\n       {\\n           HashSet<Integer> hs = new HashSet<>();\\n           for(int j=0;j<=i;j++)\\n           {\\n               hs.add(nums[j]);\\n           }\\n           HashSet<Integer> js = new HashSet<>();\\n           for(int j=i+1;j<n;j++)\\n           {\\n               js.add(nums[j]);\\n           }\\n           res[i] = hs.size()-js.size();\\n       }\\n       return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886135,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        int n=nums.length-1;\\n        for(int i=0;i<=n;i++){\\n            int prefix=count(0,nums,i);\\n            int suffix=count(i+1,nums,n);\\n            ans[i]=prefix-suffix;\\n        }\\n        return ans;\\n    }\\n    public int count(int start,int[] nums,int end){\\n        int count=0;\\n         boolean[] num=new boolean[1000001];\\n         for(int i=start;i<=end;i++){\\n             if(!num[nums[i]]){\\n                 num[nums[i]]=true;\\n                 count++;\\n             }\\n         }\\n         return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        int n=nums.length-1;\\n        for(int i=0;i<=n;i++){\\n            int prefix=count(0,nums,i);\\n            int suffix=count(i+1,nums,n);\\n            ans[i]=prefix-suffix;\\n        }\\n        return ans;\\n    }\\n    public int count(int start,int[] nums,int end){\\n        int count=0;\\n         boolean[] num=new boolean[1000001];\\n         for(int i=start;i<=end;i++){\\n             if(!num[nums[i]]){\\n                 num[nums[i]]=true;\\n                 count++;\\n             }\\n         }\\n         return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884358,
                "title": "python-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSet can helps to get distinct elements\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n\\n        return [len(set(nums[:i+1]))-len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n\\n        return [len(set(nums[:i+1]))-len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884089,
                "title": "python-simple-solution-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        out = []\\n        for i in range(len(nums)):\\n            out.append(len(set(nums[:i+1])) - len(set(nums[i+1:])))\\n\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        out = []\\n        for i in range(len(nums)):\\n            out.append(len(set(nums[:i+1])) - len(set(nums[i+1:])))\\n\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879566,
                "title": "prefix-suffix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n\\n        ans=[]\\n\\n        for i in range (0,len(nums)):\\n\\n            a = set(nums[:i+1])\\n            b = set(nums[i+1:])\\n\\n            c = len(a) - len(b)\\n\\n            ans.append(c)\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n\\n        ans=[]\\n\\n        for i in range (0,len(nums)):\\n\\n            a = set(nums[:i+1])\\n            b = set(nums[i+1:])\\n\\n            c = len(a) - len(b)\\n\\n            ans.append(c)\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876833,
                "title": "find-the-distinct-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        diff=[]\\n        for i in range(len(nums)):\\n            diff.append(len(set([nums[j] for j in range(i+1)]))-len(set([nums[j] for j in range(i+1,len(nums))])))\\n        return diff\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        diff=[]\\n        for i in range(len(nums)):\\n            diff.append(len(set([nums[j] for j in range(i+1)]))-len(set([nums[j] for j in range(i+1,len(nums))])))\\n        return diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876176,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>suff,puff;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            suff[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            suff[nums[i]]--;\\n            puff[nums[i]]++;\\n            if(suff[nums[i]]==0)\\n            {\\n                suff.erase(nums[i]);\\n            }\\n            ans.push_back(puff.size()-suff.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        unordered_map<int,int>suff,puff;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            suff[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            suff[nums[i]]--;\\n            puff[nums[i]]++;\\n            if(suff[nums[i]]==0)\\n            {\\n                suff.erase(nums[i]);\\n            }\\n            ans.push_back(puff.size()-suff.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875509,
                "title": "java-simple-but-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      int leftCount = 0, \\n          rightCount = 0, \\n          n = nums.length;\\n          \\n      int[] table = new int[51], \\n            table2 = new int[51],\\n            result = new int[n];\\n\\n      for(int i = 0; i < n; i++){\\n          table[nums[i]]++;\\n          if(table[nums[i]] == 1) rightCount++;\\n      }\\n\\n      for(int i = 0; i < n; i++){\\n          table[nums[i]]--;\\n          table2[nums[i]]++;\\n          if(table[nums[i]] == 0) rightCount--;\\n          if(table2[nums[i]] == 1) leftCount++;\\n\\n          result[i] = leftCount - rightCount;\\n      }\\n\\n      return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      int leftCount = 0, \\n          rightCount = 0, \\n          n = nums.length;\\n          \\n      int[] table = new int[51], \\n            table2 = new int[51],\\n            result = new int[n];\\n\\n      for(int i = 0; i < n; i++){\\n          table[nums[i]]++;\\n          if(table[nums[i]] == 1) rightCount++;\\n      }\\n\\n      for(int i = 0; i < n; i++){\\n          table[nums[i]]--;\\n          table2[nums[i]]++;\\n          if(table[nums[i]] == 0) rightCount--;\\n          if(table2[nums[i]] == 1) leftCount++;\\n\\n          result[i] = leftCount - rightCount;\\n      }\\n\\n      return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873486,
                "title": "python-o-n-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def distinctDifferenceArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        lfreq, rfreq = {nums[0]: 1}, {}\\n        ldist, rdist = 1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] in rfreq:\\n                rfreq[nums[i]] += 1\\n            else:\\n                rfreq[nums[i]] = 1\\n                rdist += 1\\n        r = [ldist-rdist]\\n\\n        for i in range(1, len(nums)):\\n            if rfreq[nums[i]] == 1:\\n                rfreq[nums[i]] -= 1\\n                rdist -= 1\\n            if rfreq[nums[i]] > 1:\\n                rfreq[nums[i]] -= 1\\n\\n            if nums[i] in lfreq:\\n                lfreq[nums[i]] += 1\\n            else:\\n                lfreq[nums[i]] = 1\\n                ldist += 1\\n            r.append(ldist - rdist)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def distinctDifferenceArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        lfreq, rfreq = {nums[0]: 1}, {}\\n        ldist, rdist = 1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] in rfreq:\\n                rfreq[nums[i]] += 1\\n            else:\\n                rfreq[nums[i]] = 1\\n                rdist += 1\\n        r = [ldist-rdist]\\n\\n        for i in range(1, len(nums)):\\n            if rfreq[nums[i]] == 1:\\n                rfreq[nums[i]] -= 1\\n                rdist -= 1\\n            if rfreq[nums[i]] > 1:\\n                rfreq[nums[i]] -= 1\\n\\n            if nums[i] in lfreq:\\n                lfreq[nums[i]] += 1\\n            else:\\n                lfreq[nums[i]] = 1\\n                ldist += 1\\n            r.append(ldist - rdist)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870681,
                "title": "kotlin-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun distinctDifferenceArray(nums: IntArray): IntArray {\\n        var setLeft = mutableSetOf<Int>()\\n        var setRight = mutableSetOf<Int>()\\n        var arrLeft = IntArray(nums.size){0}\\n        var arrRight = IntArray(nums.size){0}\\n        var countLeft = 1\\n        var countRight = 0\\n        setLeft.add(nums[0])\\n        arrLeft[0] = countLeft\\n\\n        for (i in 1 until nums.size) {\\n            if (!setLeft.contains(nums[i])) {\\n                setLeft.add(nums[i])\\n                countLeft++\\n            }\\n            arrLeft[i] = countLeft\\n\\n            if (!setRight.contains(nums[nums.size - i])) {\\n                setRight.add(nums[nums.size - i])\\n                countRight++\\n            }\\n            arrRight[nums.size - i - 1] = countRight\\n        }\\n\\n        for (i in 0 until nums.size) {\\n            nums[i] = arrLeft[i] - arrRight[i]\\n        }\\n\\n        return nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun distinctDifferenceArray(nums: IntArray): IntArray {\\n        var setLeft = mutableSetOf<Int>()\\n        var setRight = mutableSetOf<Int>()\\n        var arrLeft = IntArray(nums.size){0}\\n        var arrRight = IntArray(nums.size){0}\\n        var countLeft = 1\\n        var countRight = 0\\n        setLeft.add(nums[0])\\n        arrLeft[0] = countLeft\\n\\n        for (i in 1 until nums.size) {\\n            if (!setLeft.contains(nums[i])) {\\n                setLeft.add(nums[i])\\n                countLeft++\\n            }\\n            arrLeft[i] = countLeft\\n\\n            if (!setRight.contains(nums[nums.size - i])) {\\n                setRight.add(nums[nums.size - i])\\n                countRight++\\n            }\\n            arrRight[nums.size - i - 1] = countRight\\n        }\\n\\n        for (i in 0 until nums.size) {\\n            nums[i] = arrLeft[i] - arrRight[i]\\n        }\\n\\n        return nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868352,
                "title": "python3-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[:i+1]))\\n            suffix = len(set(nums[i+1:]))\\n\\n            ans.append(prefix - suffix)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            prefix = len(set(nums[:i+1]))\\n            suffix = len(set(nums[i+1:]))\\n\\n            ans.append(prefix - suffix)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866483,
                "title": "easy-to-understand-using-hash-set-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.io.*;\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] n) {\\n         int b[]=new int[n.length];\\n\\t      HashSet<Integer> pre= new HashSet<Integer>();\\n\\t      HashSet<Integer> suf= new HashSet<Integer>();\\n\\t    for(int i=0;i<n.length;i++)\\n\\t    {\\n\\t         for(int j=0;j<=i;j++)\\n\\t         {\\n\\t             pre.add(n[j]);\\n\\t         }\\n\\t         for(int k=i+1;k<n.length;k++)\\n\\t         {\\n\\t             suf.add(n[k]);\\n\\t         }\\n\\t        b[i]=pre.size()-suf.size();\\n\\t         pre.clear();\\n\\t         suf.clear();\\n\\t    }\\n        return b;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.io.*;\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] n) {\\n         int b[]=new int[n.length];\\n\\t      HashSet<Integer> pre= new HashSet<Integer>();\\n\\t      HashSet<Integer> suf= new HashSet<Integer>();\\n\\t    for(int i=0;i<n.length;i++)\\n\\t    {\\n\\t         for(int j=0;j<=i;j++)\\n\\t         {\\n\\t             pre.add(n[j]);\\n\\t         }\\n\\t         for(int k=i+1;k<n.length;k++)\\n\\t         {\\n\\t             suf.add(n[k]);\\n\\t         }\\n\\t        b[i]=pre.size()-suf.size();\\n\\t         pre.clear();\\n\\t         suf.clear();\\n\\t    }\\n        return b;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865767,
                "title": "c-99-faster-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(|hashTable|)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tvector<int> distinctDifferenceArray(vector<int>& nums) {\\n\\n\\t\\tint inputSize = nums.size();\\n\\n\\t\\tif(inputSize == 1){\\n\\t\\t\\treturn {1};\\n\\t\\t}\\n\\n\\t\\tbool hash[51] = {false};\\n\\n\\t\\tvector<int> ans(inputSize,0);\\n\\n\\t\\tans[0] = 1;\\n\\t\\thash[nums[0]] = true;\\n\\n\\n\\t\\tfor (int i = 1; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif(hash[nums[i]]){\\n\\t\\t\\t\\tans[i] = ans[i-1];\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans[i] = ans[i-1] + 1;\\n\\t\\t\\t\\thash[nums[i]] = true;\\n\\t\\t\\t}\\t\\n\\t\\t} \\n\\n\\t\\tint loopVar = 1;\\n\\n\\t\\tfor (int i = 0; i < 51; ++i)\\n\\t\\t{\\n\\t\\t\\thash[i] = false;\\n\\t\\t}\\n\\n\\t\\thash[nums[inputSize-1]] = true;\\n\\n\\t\\tfor (int i = inputSize-2; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tans[i] -= loopVar;\\n\\t\\t\\tif(!hash[nums[i]]){\\n\\t\\t\\t\\tloopVar++;\\n\\t\\t\\t\\thash[nums[i]] = true;\\n\\t\\t\\t}\\t\\n\\t\\t} \\n\\n\\t\\treturn ans;\\n\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> distinctDifferenceArray(vector<int>& nums) {\\n\\n\\t\\tint inputSize = nums.size();\\n\\n\\t\\tif(inputSize == 1){\\n\\t\\t\\treturn {1};\\n\\t\\t}\\n\\n\\t\\tbool hash[51] = {false};\\n\\n\\t\\tvector<int> ans(inputSize,0);\\n\\n\\t\\tans[0] = 1;\\n\\t\\thash[nums[0]] = true;\\n\\n\\n\\t\\tfor (int i = 1; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif(hash[nums[i]]){\\n\\t\\t\\t\\tans[i] = ans[i-1];\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans[i] = ans[i-1] + 1;\\n\\t\\t\\t\\thash[nums[i]] = true;\\n\\t\\t\\t}\\t\\n\\t\\t} \\n\\n\\t\\tint loopVar = 1;\\n\\n\\t\\tfor (int i = 0; i < 51; ++i)\\n\\t\\t{\\n\\t\\t\\thash[i] = false;\\n\\t\\t}\\n\\n\\t\\thash[nums[inputSize-1]] = true;\\n\\n\\t\\tfor (int i = inputSize-2; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tans[i] -= loopVar;\\n\\t\\t\\tif(!hash[nums[i]]){\\n\\t\\t\\t\\tloopVar++;\\n\\t\\t\\t\\thash[nums[i]] = true;\\n\\t\\t\\t}\\t\\n\\t\\t} \\n\\n\\t\\treturn ans;\\n\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862771,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] DistinctDifferenceArray(int[] nums) {\\n        int n= nums.Length;\\n        int [] arr= new int[nums.Length];\\n        for(int i =0;i<n ;i++)\\n        {\\n            int count1 = Helper(nums,0,i);\\n            int count2 = Helper(nums,i+1,n-1);\\n            arr[i]= count1-count2;\\n        }\\n\\n        return arr;\\n    }\\n    public int Helper(int[] nums,int start, int end)\\n    {\\n        HashSet<int> hs = new HashSet<int>();\\n        for(int i =start ;i<=end ;i++)\\n        {\\n            hs.Add(nums[i]);\\n        }\\n\\n        return hs.Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] DistinctDifferenceArray(int[] nums) {\\n        int n= nums.Length;\\n        int [] arr= new int[nums.Length];\\n        for(int i =0;i<n ;i++)\\n        {\\n            int count1 = Helper(nums,0,i);\\n            int count2 = Helper(nums,i+1,n-1);\\n            arr[i]= count1-count2;\\n        }\\n\\n        return arr;\\n    }\\n    public int Helper(int[] nums,int start, int end)\\n    {\\n        HashSet<int> hs = new HashSet<int>();\\n        for(int i =start ;i<=end ;i++)\\n        {\\n            hs.Add(nums[i]);\\n        }\\n\\n        return hs.Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861488,
                "title": "pythonsimplecode3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        for i in range(1,len(nums)+1):\\n            x=len(set(nums[:i]))-len(set(nums[i:]))\\n            l.append(x)\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        for i in range(1,len(nums)+1):\\n            x=len(set(nums[:i]))-len(set(nums[i:]))\\n            l.append(x)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858660,
                "title": "java-solution-2-solution-0-n-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        Set<Integer> left = new HashSet<>();\\n        Set<Integer> right = new HashSet<>();\\n        int len = nums.length;\\n        int rightEle[] = new int[len];\\n        int[] ans = new int[len];\\n\\n        rightEle[len-1] = 0;\\n        for(int i=len-2; i>=0; i--){\\n            right.add(nums[i+1]);\\n            rightEle[i] = right.size();\\n        }\\n        for(int i=0; i<len; i++){\\n            left.add(nums[i]);\\n            ans[i] = left.size() - rightEle[i];\\n        }\\n       return ans;\\n    }\\n}\\n\\n// \\n\\n\\n    //     int ans[] = new int[nums.length];\\n    //     Set<Integer> set = new HashSet<>();\\n    //     int count = 0;\\n    //     for(int i=0; i<nums.length; i++){\\n    //         set.add(nums[i]);\\n    //         count = rightNums(nums,i);\\n    //         ans[i] = set.size() - count;\\n    //     }\\n    //     return ans;\\n    // }\\n    //     public int rightNums(int[] nums, int j){\\n    //     Set<Integer> right = new HashSet<>();\\n    //     right.clear();\\n    //     for(int i=j+1; i<nums.length; i++){\\n    //         right.add(nums[i]);\\n    //     }\\n    //     return right.size();\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        Set<Integer> left = new HashSet<>();\\n        Set<Integer> right = new HashSet<>();\\n        int len = nums.length;\\n        int rightEle[] = new int[len];\\n        int[] ans = new int[len];\\n\\n        rightEle[len-1] = 0;\\n        for(int i=len-2; i>=0; i--){\\n            right.add(nums[i+1]);\\n            rightEle[i] = right.size();\\n        }\\n        for(int i=0; i<len; i++){\\n            left.add(nums[i]);\\n            ans[i] = left.size() - rightEle[i];\\n        }\\n       return ans;\\n    }\\n}\\n\\n// \\n\\n\\n    //     int ans[] = new int[nums.length];\\n    //     Set<Integer> set = new HashSet<>();\\n    //     int count = 0;\\n    //     for(int i=0; i<nums.length; i++){\\n    //         set.add(nums[i]);\\n    //         count = rightNums(nums,i);\\n    //         ans[i] = set.size() - count;\\n    //     }\\n    //     return ans;\\n    // }\\n    //     public int rightNums(int[] nums, int j){\\n    //     Set<Integer> right = new HashSet<>();\\n    //     right.clear();\\n    //     for(int i=j+1; i<nums.length; i++){\\n    //         right.add(nums[i]);\\n    //     }\\n    //     return right.size();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850607,
                "title": "better-understandable-solution-that-beats-96-of-the-solutions",
                "content": "# Intuition\\nHere we need to obtain a resultant list which contains the values that it should be the count of the unique elements from the left side getting subtracted from the count of unique element from the right side.\\n\\n# Approach\\nDeclared a list with the length same as the length of the given list then iterate over the list and for each iteration we have the value of x as the element from beginning of the given list to the current index+1 because then only we will get the value beginning to the index after that y contains the values from index+1 to the end of the given list.These x and y should be a set to neglect the duplicate values from it.Finally append the difference between the length of x ad y.After the whole iteration return the rersultant list.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result=[]*len(nums)\\n        for i in range(len(nums)):\\n            x=set(nums[:i+1])\\n            y=set(nums[i+1:len(nums)])\\n            result.append(len(x)-len(y))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        result=[]*len(nums)\\n        for i in range(len(nums)):\\n            x=set(nums[:i+1])\\n            y=set(nums[i+1:len(nums)])\\n            result.append(len(x)-len(y))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848966,
                "title": "beats-100-of-users-for-both-memory-and-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func distinctDifferenceArray(_ nums: [Int]) -> [Int] {\\n            \\n\\n        var distinctDiff = [Int]()\\n\\n        for (i, num1) in nums.enumerated(){\\n            var numsPrefix = [Int]()\\n            var numsSuffix = [Int]()\\n            for(j, num2) in nums.enumerated(){\\n                if(j <= i && !numsPrefix.contains(num2)){\\n                    numsPrefix.append(num2)\\n                } else if(j > i && !numsSuffix.contains(num2)){\\n                    numsSuffix.append(num2)\\n                }\\n            }\\n            var diff = numsPrefix.count - numsSuffix.count\\n            distinctDiff.append(diff)\\n        }\\n        return distinctDiff\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distinctDifferenceArray(_ nums: [Int]) -> [Int] {\\n            \\n\\n        var distinctDiff = [Int]()\\n\\n        for (i, num1) in nums.enumerated(){\\n            var numsPrefix = [Int]()\\n            var numsSuffix = [Int]()\\n            for(j, num2) in nums.enumerated(){\\n                if(j <= i && !numsPrefix.contains(num2)){\\n                    numsPrefix.append(num2)\\n                } else if(j > i && !numsSuffix.contains(num2)){\\n                    numsSuffix.append(num2)\\n                }\\n            }\\n            var diff = numsPrefix.count - numsSuffix.count\\n            distinctDiff.append(diff)\\n        }\\n        return distinctDiff\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848421,
                "title": "simple-java-solution-using-map-and-set-without-nested-loops-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] diff = new int[nums.length];\\n\\n        Set<Integer> leftDistinctNumbers = new HashSet<>();\\n        Map<Integer, Integer> rightOccurencesByNumber = new HashMap<>();\\n        for (int num : nums){\\n            rightOccurencesByNumber.compute(num, (k,v) -> (v == null) ? 1 : v+1);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            leftDistinctNumbers.add(nums[i]);\\n            rightOccurencesByNumber.compute(nums[i], (k,v) -> v-1);\\n            rightOccurencesByNumber.remove(nums[i], 0);\\n            diff[i] = leftDistinctNumbers.size()-rightOccurencesByNumber.size();\\n        }\\n\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] diff = new int[nums.length];\\n\\n        Set<Integer> leftDistinctNumbers = new HashSet<>();\\n        Map<Integer, Integer> rightOccurencesByNumber = new HashMap<>();\\n        for (int num : nums){\\n            rightOccurencesByNumber.compute(num, (k,v) -> (v == null) ? 1 : v+1);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++){\\n            leftDistinctNumbers.add(nums[i]);\\n            rightOccurencesByNumber.compute(nums[i], (k,v) -> v-1);\\n            rightOccurencesByNumber.remove(nums[i], 0);\\n            diff[i] = leftDistinctNumbers.size()-rightOccurencesByNumber.size();\\n        }\\n\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847274,
                "title": "easy-and-understandable-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int ,int>suffix ,prefix ;\\n        vector<int> ans;\\n\\n        for(auto it:nums){\\n            suffix[it]++;\\n        }\\n        for(auto it:nums){\\n            prefix[it]++;\\n            suffix[it]--;\\n            if(suffix[it]==0){\\n                suffix.erase(it);\\n             }\\n         ans.push_back(prefix.size()-suffix.size());\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        map<int ,int>suffix ,prefix ;\\n        vector<int> ans;\\n\\n        for(auto it:nums){\\n            suffix[it]++;\\n        }\\n        for(auto it:nums){\\n            prefix[it]++;\\n            suffix[it]--;\\n            if(suffix[it]==0){\\n                suffix.erase(it);\\n             }\\n         ans.push_back(prefix.size()-suffix.size());\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845978,
                "title": "solution-using-sets-and-arrays-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      int arr1[]=new int[nums.length];\\n      int arr2[]=new int[nums.length];\\n      for(int i=0;i<nums.length;i++){\\n          Set<Integer>set=new HashSet<>();\\n          for(int j=i+1;j<nums.length;j++){\\n              set.add(nums[j]);\\n          }\\n          arr1[i]=set.size();\\n      }\\n      for(int i=0;i<nums.length;i++){\\n          Set<Integer>set=new HashSet<>();\\n          for(int j=0;j<=i;j++){\\n              set.add(nums[j]);\\n          }\\n          arr2[i]=set.size();\\n      }\\n      for(int i=0;i<arr1.length;i++){\\n          nums[i]=arr2[i]-arr1[i];\\n      }\\n      return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n      int arr1[]=new int[nums.length];\\n      int arr2[]=new int[nums.length];\\n      for(int i=0;i<nums.length;i++){\\n          Set<Integer>set=new HashSet<>();\\n          for(int j=i+1;j<nums.length;j++){\\n              set.add(nums[j]);\\n          }\\n          arr1[i]=set.size();\\n      }\\n      for(int i=0;i<nums.length;i++){\\n          Set<Integer>set=new HashSet<>();\\n          for(int j=0;j<=i;j++){\\n              set.add(nums[j]);\\n          }\\n          arr2[i]=set.size();\\n      }\\n      for(int i=0;i<arr1.length;i++){\\n          nums[i]=arr2[i]-arr1[i];\\n      }\\n      return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840978,
                "title": "java-3ms-beats-100",
                "content": "# Intuition\\nCount distinct (not unique!) elements from left and right sides. Compute the `diff` array.\\n\\n# Approach\\nUse arrays to track distinct elements. Use a `for` loop.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int[] distinctElementsPrefix = new int[n + 1];\\n        int[] prefixCounts = new int[51];\\n        int curNumDistinctElementsPrefix = 0;\\n\\n        int[] distinctElementsSuffix = new int[n + 1];\\n        int[] suffixCounts = new int[51];\\n        int curNumDistinctElementsSuffix = 0;\\n\\n        for (int i = 0, j = nums.length - 1; i < nums.length; ++i, --j) {\\n            ++prefixCounts[nums[i]];\\n            if (prefixCounts[nums[i]] == 1) {\\n                ++curNumDistinctElementsPrefix;\\n            }\\n            distinctElementsPrefix[i] = curNumDistinctElementsPrefix;\\n\\n            ++suffixCounts[nums[j]];\\n            if (suffixCounts[nums[j]] == 1) {\\n                ++curNumDistinctElementsSuffix;\\n            }\\n            distinctElementsSuffix[j] = curNumDistinctElementsSuffix;\\n        }\\n\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            diff[i] = distinctElementsPrefix[i] - distinctElementsSuffix[i + 1];\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int[] distinctElementsPrefix = new int[n + 1];\\n        int[] prefixCounts = new int[51];\\n        int curNumDistinctElementsPrefix = 0;\\n\\n        int[] distinctElementsSuffix = new int[n + 1];\\n        int[] suffixCounts = new int[51];\\n        int curNumDistinctElementsSuffix = 0;\\n\\n        for (int i = 0, j = nums.length - 1; i < nums.length; ++i, --j) {\\n            ++prefixCounts[nums[i]];\\n            if (prefixCounts[nums[i]] == 1) {\\n                ++curNumDistinctElementsPrefix;\\n            }\\n            distinctElementsPrefix[i] = curNumDistinctElementsPrefix;\\n\\n            ++suffixCounts[nums[j]];\\n            if (suffixCounts[nums[j]] == 1) {\\n                ++curNumDistinctElementsSuffix;\\n            }\\n            distinctElementsSuffix[j] = curNumDistinctElementsSuffix;\\n        }\\n\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            diff[i] = distinctElementsPrefix[i] - distinctElementsSuffix[i + 1];\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839030,
                "title": "simple-set-solution-js-ts",
                "content": "# Intuition\\nI have seen all the solutions in which they are creating new set everytime inside loop. But we will only need to create new set everytime for right side but for the left we can just add.\\n\\n# Code\\n```\\nfunction distinctDifferenceArray(nums: number[]): number[] {\\n    let leftSet = new Set<number>();\\n\\n    return nums.map((num,index)=>{\\n        leftSet.add(num);\\n        let rightSet = new Set<number>(nums.slice(index+1));\\n        return leftSet.size-rightSet.size;\\n    })\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction distinctDifferenceArray(nums: number[]): number[] {\\n    let leftSet = new Set<number>();\\n\\n    return nums.map((num,index)=>{\\n        leftSet.add(num);\\n        let rightSet = new Set<number>(nums.slice(index+1));\\n        return leftSet.size-rightSet.size;\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835380,
                "title": "php",
                "content": "![Screen Shot 2023-07-29 at 3.48.08 PM.png](https://assets.leetcode.com/users/images/b699e709-52f7-4786-b01d-b9f99bc8a313_1690660113.0529652.png)\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\n  /**\\n   * @param Integer[] $nums\\n   * @return Integer[]\\n   */\\n  public function distinctDifferenceArray($nums)\\n  {\\n    $diff = [];\\n    for ($i = 1; $i <= count($nums); $i++) {\\n      $prefix = array_slice($nums, 0, $i);\\n      $sufix = array_slice($nums, $i);\\n\\n      $diff[] = count(array_unique($prefix)) - count(array_unique($sufix));\\n    }\\n    return $diff;\\n  }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n  /**\\n   * @param Integer[] $nums\\n   * @return Integer[]\\n   */\\n  public function distinctDifferenceArray($nums)\\n  {\\n    $diff = [];\\n    for ($i = 1; $i <= count($nums); $i++) {\\n      $prefix = array_slice($nums, 0, $i);\\n      $sufix = array_slice($nums, $i);\\n\\n      $diff[] = count(array_unique($prefix)) - count(array_unique($sufix));\\n    }\\n    return $diff;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834921,
                "title": "with-explanation-comments-time-xx-ms-98-97-space-xx-mb-89-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        int n=nums.size();\\n\\n        for(int i=0;i<nums.size();i++){\\n           set<int> pre, aft;\\n        \\n            for(int j=0;j<=i;j++)\\n                pre.insert(nums[j]);\\n\\n            for(int k=i+1;k<n;k++)\\n                aft.insert(nums[k]);\\n\\n            ans.push_back(pre.size()-aft.size());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        \\n        vector<int> ans;\\n        int n=nums.size();\\n\\n        for(int i=0;i<nums.size();i++){\\n           set<int> pre, aft;\\n        \\n            for(int j=0;j<=i;j++)\\n                pre.insert(nums[j]);\\n\\n            for(int k=i+1;k<n;k++)\\n                aft.insert(nums[k]);\\n\\n            ans.push_back(pre.size()-aft.size());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825110,
                "title": "beats-90-single-for-loop-solution-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intitution here is to slice nums array into prefix (0...k) and suffix (k+1...n-1). Convert the prefix and suffix array into a set to remove duplicate elements. The difference of size between prefix and suffix sets can be pushed into a new array. Repea the above mentioned solution from 0 to length-1 of the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    let res = [];\\n    var num_len = nums.length;\\n    for(let k=0; k<num_len; k++){\\n        res.push(\\n            new Set(nums.slice(0,k+1)).size - new Set(nums.slice(k+1)).size\\n        )\\n    }\\n    return res\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    let res = [];\\n    var num_len = nums.length;\\n    for(let k=0; k<num_len; k++){\\n        res.push(\\n            new Set(nums.slice(0,k+1)).size - new Set(nums.slice(k+1)).size\\n        )\\n    }\\n    return res\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813907,
                "title": "java-solution-easy-method",
                "content": "# Intuition\\nNeed to search distinct number\\n# Approach\\nUsed HashSet here and transversed...\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> set1 = new HashSet<>();\\n            Set<Integer> set2 = new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                set2.add(nums[j]);\\n            }\\n            arr[i]=set1.size()-set2.size();\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> set1 = new HashSet<>();\\n            Set<Integer> set2 = new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                set2.add(nums[j]);\\n            }\\n            arr[i]=set1.size()-set2.size();\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811715,
                "title": "my-c-with-two-heap-heap-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){\\n    int* temp = malloc(sizeof(int)*51);\\n    int* pre_temp = malloc(sizeof(int)*51);\\n    int* ret = malloc(sizeof(int)*numsSize);\\n    *returnSize = numsSize;\\n    int i;\\n    for(i=0;i<51;i++){\\n        temp[i] = 0;\\n        pre_temp[i] = 0;\\n    }\\n    int suffix = 0;\\n    for(i=0;i<numsSize;i++){\\n        if(!temp[nums[i]])\\n            suffix++;\\n        temp[nums[i]]++;\\n    }\\n\\n    int prefix = 0;\\n    for(i=0;i<numsSize;i++){\\n        if(!pre_temp[nums[i]])\\n            prefix++;\\n        pre_temp[nums[i]]++;\\n        temp[nums[i]]--;\\n        if(!temp[nums[i]])\\n            suffix--;\\n        ret[i] = prefix - suffix;\\n    }\\n\\n    free(temp);\\n    free(pre_temp);\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distinctDifferenceArray(int* nums, int numsSize, int* returnSize){\\n    int* temp = malloc(sizeof(int)*51);\\n    int* pre_temp = malloc(sizeof(int)*51);\\n    int* ret = malloc(sizeof(int)*numsSize);\\n    *returnSize = numsSize;\\n    int i;\\n    for(i=0;i<51;i++){\\n        temp[i] = 0;\\n        pre_temp[i] = 0;\\n    }\\n    int suffix = 0;\\n    for(i=0;i<numsSize;i++){\\n        if(!temp[nums[i]])\\n            suffix++;\\n        temp[nums[i]]++;\\n    }\\n\\n    int prefix = 0;\\n    for(i=0;i<numsSize;i++){\\n        if(!pre_temp[nums[i]])\\n            prefix++;\\n        pre_temp[nums[i]]++;\\n        temp[nums[i]]--;\\n        if(!temp[nums[i]])\\n            suffix--;\\n        ret[i] = prefix - suffix;\\n    }\\n\\n    free(temp);\\n    free(pre_temp);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810203,
                "title": "simple-o-n-java-solution-using-2-hashmaps",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[]res = new int[n];\\n\\n        Map<Integer,Integer>pre = new HashMap<>();\\n        Map<Integer,Integer>suff = new HashMap<>();\\n\\n        for(int a: nums){\\n            pre.put(a,pre.getOrDefault(a,0)+1);\\n        }\\n        \\n        int i =0;\\n        for(int a: nums){\\n            suff.put(a,suff.getOrDefault(a,0)+1);\\n            int val = pre.get(a);\\n            if(val -1 == 0)\\n                pre.remove(a);\\n            else\\n                pre.put(a,val-1);\\n            \\n            res[i++] = suff.size()-pre.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[]res = new int[n];\\n\\n        Map<Integer,Integer>pre = new HashMap<>();\\n        Map<Integer,Integer>suff = new HashMap<>();\\n\\n        for(int a: nums){\\n            pre.put(a,pre.getOrDefault(a,0)+1);\\n        }\\n        \\n        int i =0;\\n        for(int a: nums){\\n            suff.put(a,suff.getOrDefault(a,0)+1);\\n            int val = pre.get(a);\\n            if(val -1 == 0)\\n                pre.remove(a);\\n            else\\n                pre.put(a,val-1);\\n            \\n            res[i++] = suff.size()-pre.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807449,
                "title": "bit-optimised-naive-solution-90-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        pre, suf = [], nums[::-1]\\n        for i, n in enumerate(nums):\\n            pre.append(n)\\n            suf.pop()\\n            ans[i] = len(set(pre))-len(set(suf))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        ans = [0] * len(nums)\\n        pre, suf = [], nums[::-1]\\n        for i, n in enumerate(nums):\\n            pre.append(n)\\n            suf.pop()\\n            ans[i] = len(set(pre))-len(set(suf))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806374,
                "title": "one-liner-beats-92-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1]))-len(set(nums[i+1:])) for i in range(len(nums))]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1]))-len(set(nums[i+1:])) for i in range(len(nums))]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799222,
                "title": "solution-using-two-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans(n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n            unordered_set<int>s1(nums.begin(),nums.begin()+i+1);\\n            unordered_set<int>s2(nums.begin()+i+1,nums.end());\\n            ans[i]=s1.size()-s2.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans(n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n            unordered_set<int>s1(nums.begin(),nums.begin()+i+1);\\n            unordered_set<int>s2(nums.begin()+i+1,nums.end());\\n            ans[i]=s1.size()-s2.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798405,
                "title": "js-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    const res = [];\\n    for(let i=0;i<nums.length;i++) {\\n        const lSet = new Set(); // count of distinct left items\\n        const rSet = new Set(); // count of distinct right items\\n\\n        for(let j=i;j>-1;j--) {\\n            lSet.add(nums[j]); // counting left items\\n        }\\n\\n        for(let k=i+1;k<nums.length;k++) {\\n            rSet.add(nums[k]); // counting right items\\n        }\\n\\n        res[i] = lSet.size - rSet.size; // calculating difference\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    const res = [];\\n    for(let i=0;i<nums.length;i++) {\\n        const lSet = new Set(); // count of distinct left items\\n        const rSet = new Set(); // count of distinct right items\\n\\n        for(let j=i;j>-1;j--) {\\n            lSet.add(nums[j]); // counting left items\\n        }\\n\\n        for(let k=i+1;k<nums.length;k++) {\\n            rSet.add(nums[k]); // counting right items\\n        }\\n\\n        res[i] = lSet.size - rSet.size; // calculating difference\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797302,
                "title": "kotlin-solution-with-map",
                "content": "# Code\\n```\\nclass Solution {\\n    fun distinctDifferenceArray(nums: IntArray): IntArray {\\n        val prefixMap = mutableMapOf<Int,Int>()\\n        val suffixMap = mutableMapOf<Int,Int>()\\n        val result = IntArray(nums.size)\\n\\n        nums.forEach {\\n            suffixMap[it] = suffixMap.getOrDefault(it, 0) + 1\\n        }\\n\\n        nums.forEachIndexed { i, num ->\\n            prefixMap[num] = prefixMap.getOrDefault(num, 0) + 1\\n            suffixMap[num] = suffixMap.getOrDefault(num, 0) - 1\\n\\n            if (suffixMap[num] == 0)\\n                suffixMap.remove(num)\\n\\n            result[i] = prefixMap.size - suffixMap.size\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    fun distinctDifferenceArray(nums: IntArray): IntArray {\\n        val prefixMap = mutableMapOf<Int,Int>()\\n        val suffixMap = mutableMapOf<Int,Int>()\\n        val result = IntArray(nums.size)\\n\\n        nums.forEach {\\n            suffixMap[it] = suffixMap.getOrDefault(it, 0) + 1\\n        }\\n\\n        nums.forEachIndexed { i, num ->\\n            prefixMap[num] = prefixMap.getOrDefault(num, 0) + 1\\n            suffixMap[num] = suffixMap.getOrDefault(num, 0) - 1\\n\\n            if (suffixMap[num] == 0)\\n                suffixMap.remove(num)\\n\\n            result[i] = prefixMap.size - suffixMap.size\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797052,
                "title": "best-solution-to-clear-your-concepts-from-basic",
                "content": "# Intuition\\nDivide the array in two parts(prefix and postfix)\\n\\n# Approach\\nTo find distinct elements use set() function and use len() to find length of distinct elements array\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        lst=[]\\n        for i in range(len(nums)):\\n            pre = len(set(nums[0:i+1]))\\n            post = len(set(nums[i+1::]))\\n            lst.append(pre-post)\\n        return lst\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        lst=[]\\n        for i in range(len(nums)):\\n            pre = len(set(nums[0:i+1]))\\n            post = len(set(nums[i+1::]))\\n            lst.append(pre-post)\\n        return lst\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796359,
                "title": "find-the-distinct-difference-array-by-hashsets",
                "content": "# Intuition\\nmaking two seperate function of prefix and suffix and couting the distict occurence. \\n \\n\\n# Approach\\n making two seperate function of prefix and suffix .\\n\\n# Complexity\\n- Time complexity:\\n  O(N^2)\\n\\n- Space complexity:\\n-  O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] distinctDifferenceArray(int[] nums) {\\n        int[] numbersArray = new int[nums.length];\\n\\n        for(int i=0 ;i<nums.length;i++){\\n            int sum1 = prefix(nums,i);\\n            int sum2 = suffix(nums,i);\\n            int ans = sum1-sum2;\\n            numbersArray[i]=ans;\\n        }\\n        return numbersArray ;\\n              \\n    }\\n\\n    public static int prefix(int[] nums,int mid){\\n\\n        HashSet<Integer> numbers = new HashSet<>();\\n        int count =0;\\n        for(int i=mid;i>=0;i--){\\n            if(!numbers.contains(nums[i])){\\n\\n                numbers.add(nums[i]);  \\n                count++;   \\n            }\\n        }       \\n        return count;    \\n\\n    }\\n    public static int suffix(int[] nums,int mid){\\n\\n        HashSet<Integer> numbers2 = new HashSet<>();\\n        \\n        int count =0;\\n        for(int i=mid+1;i<nums.length;i++){\\n\\n            if(!numbers2.contains(nums[i])){\\n\\n                numbers2.add(nums[i]);\\n                count++;\\n\\n            }          \\n        }\\n                \\n        return count;\\n\\n}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] distinctDifferenceArray(int[] nums) {\\n        int[] numbersArray = new int[nums.length];\\n\\n        for(int i=0 ;i<nums.length;i++){\\n            int sum1 = prefix(nums,i);\\n            int sum2 = suffix(nums,i);\\n            int ans = sum1-sum2;\\n            numbersArray[i]=ans;\\n        }\\n        return numbersArray ;\\n              \\n    }\\n\\n    public static int prefix(int[] nums,int mid){\\n\\n        HashSet<Integer> numbers = new HashSet<>();\\n        int count =0;\\n        for(int i=mid;i>=0;i--){\\n            if(!numbers.contains(nums[i])){\\n\\n                numbers.add(nums[i]);  \\n                count++;   \\n            }\\n        }       \\n        return count;    \\n\\n    }\\n    public static int suffix(int[] nums,int mid){\\n\\n        HashSet<Integer> numbers2 = new HashSet<>();\\n        \\n        int count =0;\\n        for(int i=mid+1;i<nums.length;i++){\\n\\n            if(!numbers2.contains(nums[i])){\\n\\n                numbers2.add(nums[i]);\\n                count++;\\n\\n            }          \\n        }\\n                \\n        return count;\\n\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796225,
                "title": "two-dictionaries-80-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/0f2778b5-beff-4c57-bf3d-10f0bc6eb620_1689931288.902618.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        left = defaultdict(int)\\n        right = Counter(nums)\\n        ans = [0] * len(nums)\\n        for i, n in enumerate(nums):\\n            left[n] += 1\\n            right[n] -= 1\\n            if right[n] == 0:\\n                right.pop(n)\\n            ans[i] = len(left) - len(right)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        left = defaultdict(int)\\n        right = Counter(nums)\\n        ans = [0] * len(nums)\\n        for i, n in enumerate(nums):\\n            left[n] += 1\\n            right[n] -= 1\\n            if right[n] == 0:\\n                right.pop(n)\\n            ans[i] = len(left) - len(right)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794001,
                "title": "simple-c-solution-unordered-set-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPush previous elements in a previous_set and leading elements in another set and push their difference of size in a vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPush nums\\' elemets from 0 to i(inclusive) in prev (unordered_set) and the other i+1 till nums.size()(exclusive) in ah (another unordered_set). Then push the prev.size()-ah.size() in sol.\\nReturn sol\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> sol;\\n        for(int u=0; u<nums.size(); u++){\\n            int i=u, j=u;\\n            unordered_set<int> prev;\\n            unordered_set<int> ah;\\n            for(int k=0; k<=i; k++){\\n                prev.insert(nums[k]);\\n            }for(int k=j+1; k<nums.size(); k++){\\n                ah.insert(nums[k]);\\n            }sol.push_back(prev.size()-ah.size());\\n        }\\n\\n        return sol;\\n    }\\n};\\n```\\n`\\nif(like) upvote++ ;p\\n`",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int> sol;\\n        for(int u=0; u<nums.size(); u++){\\n            int i=u, j=u;\\n            unordered_set<int> prev;\\n            unordered_set<int> ah;\\n            for(int k=0; k<=i; k++){\\n                prev.insert(nums[k]);\\n            }for(int k=j+1; k<nums.size(); k++){\\n                ah.insert(nums[k]);\\n            }sol.push_back(prev.size()-ah.size());\\n        }\\n\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789724,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {        \\n        Set<Integer> uniqueSet =new HashSet<>();\\n        int n = nums.length -1;\\n        int suffix[] =new int [nums.length];\\n        for(int i = n ; i > 0 ; i--)\\n        {\\n            uniqueSet.add(nums[i]);\\n            suffix[i] = uniqueSet.size();           \\n        }\\n\\n        uniqueSet.clear();\\n        int [] ans = new int [nums.length];\\n        for( int i = 0; i < n ; i++)\\n        {\\n            uniqueSet.add(nums[i]);\\n            ans[i] = uniqueSet.size() - suffix[i + 1];\\n        }\\n        uniqueSet.add(nums[n]);\\n        ans[n] = uniqueSet.size();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {        \\n        Set<Integer> uniqueSet =new HashSet<>();\\n        int n = nums.length -1;\\n        int suffix[] =new int [nums.length];\\n        for(int i = n ; i > 0 ; i--)\\n        {\\n            uniqueSet.add(nums[i]);\\n            suffix[i] = uniqueSet.size();           \\n        }\\n\\n        uniqueSet.clear();\\n        int [] ans = new int [nums.length];\\n        for( int i = 0; i < n ; i++)\\n        {\\n            uniqueSet.add(nums[i]);\\n            ans[i] = uniqueSet.size() - suffix[i + 1];\\n        }\\n        uniqueSet.add(nums[n]);\\n        ans[n] = uniqueSet.size();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782151,
                "title": "simple-java-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] arr) {\\n        Set s1= new HashSet();\\n\\tSet s2= new HashSet();\\n        int[] arr1= new int[arr.length];\\n        int count=0;\\n        int s=0;\\n        while(s<arr.length) {\\n        \\ts1.clear();\\n        \\ts2.clear();\\n        \\tfor(int i=0;i<=s;i++) {\\n        \\t\\ts1.add(arr[i]);\\n        \\t}\\n        \\tfor(int i=s+1;i<arr.length;i++) {\\n        \\t\\ts2.add(arr[i]);\\n        \\t}\\n        \\tarr1[s]= s1.size()-s2.size();\\n        \\ts++;\\n        }\\n        \\n        return arr1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] arr) {\\n        Set s1= new HashSet();\\n\\tSet s2= new HashSet();\\n        int[] arr1= new int[arr.length];\\n        int count=0;\\n        int s=0;\\n        while(s<arr.length) {\\n        \\ts1.clear();\\n        \\ts2.clear();\\n        \\tfor(int i=0;i<=s;i++) {\\n        \\t\\ts1.add(arr[i]);\\n        \\t}\\n        \\tfor(int i=s+1;i<arr.length;i++) {\\n        \\t\\ts2.add(arr[i]);\\n        \\t}\\n        \\tarr1[s]= s1.size()-s2.size();\\n        \\ts++;\\n        }\\n        \\n        return arr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781755,
                "title": "find-the-distinct-difference-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int cpre = 0;\\n        int spre = 0;\\n        int[]  arr = new int[nums.length];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            cpre = distinct(0,i-1,nums);\\n            spre = distinct(i,nums.length-1,nums);\\n            arr[i-1] = cpre-spre;\\n        }\\n        cpre = distinct(0,nums.length-1,nums);\\n        arr[nums.length-1]= cpre-0;\\n        return arr;\\n    }\\n    public int distinct(int i,int j,int[] nums)\\n    {\\n        HashSet<Integer> hm = new HashSet<Integer>();\\n        for(int l=i;l<=j;l++)\\n        {\\n            hm.add(nums[l]);\\n        }\\n        return hm.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int cpre = 0;\\n        int spre = 0;\\n        int[]  arr = new int[nums.length];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            cpre = distinct(0,i-1,nums);\\n            spre = distinct(i,nums.length-1,nums);\\n            arr[i-1] = cpre-spre;\\n        }\\n        cpre = distinct(0,nums.length-1,nums);\\n        arr[nums.length-1]= cpre-0;\\n        return arr;\\n    }\\n    public int distinct(int i,int j,int[] nums)\\n    {\\n        HashSet<Integer> hm = new HashSet<Integer>();\\n        for(int l=i;l<=j;l++)\\n        {\\n            hm.add(nums[l]);\\n        }\\n        return hm.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775287,
                "title": "java-easy-solution-using-set-referenced-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI got the reference of this code from him.\\n[https://leetcode.com/VIJAY626404/]()\\nThanks.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int [nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> prefix=new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n                prefix.add(nums[j]);\\n            }\\n\\n            Set<Integer> suffix=new HashSet<>();\\n            for(int j=i+1;j<nums.length;j++){\\n                suffix.add(nums[j]);\\n            }\\n\\n            diff[i]=prefix.size()-suffix.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int diff[] = new int [nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            Set<Integer> prefix=new HashSet<>();\\n            for(int j=0;j<=i;j++){\\n                prefix.add(nums[j]);\\n            }\\n\\n            Set<Integer> suffix=new HashSet<>();\\n            for(int j=i+1;j<nums.length;j++){\\n                suffix.add(nums[j]);\\n            }\\n\\n            diff[i]=prefix.size()-suffix.size();\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775038,
                "title": "python-one-liner-list-comprehension-slicing",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1])) - len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        return [len(set(nums[:i+1])) - len(set(nums[i+1:])) for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774143,
                "title": "simple-solution-using-hashset",
                "content": "# Intuition\\nSince we want to have a difference of left and right entities of an ith element, it is advisable to maintain two separate arrays one to the left of ith (here ith element is included in left side) and other to the right of ith element to make things simpler and easy to operate on.\\n\\n# Approach\\nSince we want count of unique elements it is intuitive to use a hashset, so use a hashset first from left end and keep storing the result in your leftDis array, similarly do it from right end.\\nAnd finally take the differences in a separate array( you can use either of leftDis or rightDis array also to store final result, you can skip using third array).\\n\\n# Complexity\\n- Time complexity:\\nSince every element is visited twice at max.\\nTC is 2*n which is O(N).\\n\\n- Space complexity:\\nWe have used 2 or 3 arrays of N size.\\nSo space complexity also becomes O(N).\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       HashSet<Integer> hs = new HashSet<>();\\n       int[] leftDis = new int[nums.length];\\n       int[] rightDis = new int[nums.length];\\n\\n       for(int i=0; i<nums.length; i++){\\n           hs.add(nums[i]);\\n           leftDis[i]=hs.size();\\n        }\\n\\n        //refresh the same array as a new one for rightside.\\n        hs = new HashSet<Integer>();\\n\\n        hs.add(nums[nums.length-1]);\\n\\n        for(int i=nums.length-2; i>=0; i--){\\n            rightDis[i]=hs.size();\\n            hs.add(nums[i]);            \\n        }\\n\\n        int[] ans = new int[nums.length];\\n\\n        for(int i=0; i<nums.length; i++){\\n            ans[i]=leftDis[i]-rightDis[i];\\n        }\\n\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n       HashSet<Integer> hs = new HashSet<>();\\n       int[] leftDis = new int[nums.length];\\n       int[] rightDis = new int[nums.length];\\n\\n       for(int i=0; i<nums.length; i++){\\n           hs.add(nums[i]);\\n           leftDis[i]=hs.size();\\n        }\\n\\n        //refresh the same array as a new one for rightside.\\n        hs = new HashSet<Integer>();\\n\\n        hs.add(nums[nums.length-1]);\\n\\n        for(int i=nums.length-2; i>=0; i--){\\n            rightDis[i]=hs.size();\\n            hs.add(nums[i]);            \\n        }\\n\\n        int[] ans = new int[nums.length];\\n\\n        for(int i=0; i<nums.length; i++){\\n            ans[i]=leftDis[i]-rightDis[i];\\n        }\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773527,
                "title": "simple-and-easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        difference=0\\n        for i in range(len(nums)):\\n            difference = len(set(nums[:i + 1]))-len(set(nums[i + 1:]))\\n            res.append(difference)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        difference=0\\n        for i in range(len(nums)):\\n            difference = len(set(nums[:i + 1]))-len(set(nums[i + 1:]))\\n            res.append(difference)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770766,
                "title": "c-clean-and-easy-solution",
                "content": "We use 2 arrasy to record the prefix disctinct and suffix distinct for each.\\nTo do that, we simply use 2 maps to do that.\\n\\n\\'\\'\\'\\n\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n), pre(n), suff(n);\\n        map<int, int> p, s;\\n        // build the prefix array first;\\n        for (int i=0; i<nums.size(); ++i) {\\n            p[nums[i]]++;\\n            pre[i] = p.size();\\n        }\\n        // build the suffix array first;\\n        for (int i=nums.size()-1; i>=0; --i) {\\n            suff[i] = s.size();\\n            s[nums[i]]++;\\n        }\\n        // now, build the result;\\n        for (int i=0; i<nums.size(); ++i) {\\n            res[i] = pre[i] - suff[i];\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "We use 2 arrasy to record the prefix disctinct and suffix distinct for each.\\nTo do that, we simply use 2 maps to do that.\\n\\n\\'\\'\\'\\n\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n), pre(n), suff(n);\\n        map<int, int> p, s;\\n        // build the prefix array first;\\n        for (int i=0; i<nums.size(); ++i) {\\n            p[nums[i]]++;\\n            pre[i] = p.size();\\n        }\\n        // build the suffix array first;\\n        for (int i=nums.size()-1; i>=0; --i) {\\n            suff[i] = s.size();\\n            s[nums[i]]++;\\n        }\\n        // now, build the result;\\n        for (int i=0; i<nums.size(); ++i) {\\n            res[i] = pre[i] - suff[i];\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 3766523,
                "title": "simple-javascript-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    let result = []\\n    for (let i = 0; i < nums.length; i++) {\\n      const leading = nums.slice(0, i + 1)\\n      const trailing = nums.slice(i + 1)\\n      result.push(new Set(leading).size - new Set(trailing).size)\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distinctDifferenceArray = function(nums) {\\n    let result = []\\n    for (let i = 0; i < nums.length; i++) {\\n      const leading = nums.slice(0, i + 1)\\n      const trailing = nums.slice(i + 1)\\n      result.push(new Set(leading).size - new Set(trailing).size)\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761735,
                "title": "java-o-n-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n        if(map.containsKey(nums[i])){\\n            map.put(nums[i], map.get(nums[i])+1);\\n        }else{\\n            map.put(nums[i], 1);\\n        }\\n        }\\n        int[] ans = new int[nums.length];\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            //adding current element to prefix\\n            if(prefix.containsKey(nums[i])){\\n                prefix.put(nums[i], prefix.get(nums[i])+1);\\n            }else{\\n                prefix.put(nums[i], 1);\\n            }\\n            // removing current element from suffix\\n            if(map.get(nums[i]) == 1){\\n                map.remove(nums[i]);\\n            }else{\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n            }\\n            // take difference\\n            ans[i] = prefix.size()-map.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n        if(map.containsKey(nums[i])){\\n            map.put(nums[i], map.get(nums[i])+1);\\n        }else{\\n            map.put(nums[i], 1);\\n        }\\n        }\\n        int[] ans = new int[nums.length];\\n        HashMap<Integer, Integer> prefix = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            //adding current element to prefix\\n            if(prefix.containsKey(nums[i])){\\n                prefix.put(nums[i], prefix.get(nums[i])+1);\\n            }else{\\n                prefix.put(nums[i], 1);\\n            }\\n            // removing current element from suffix\\n            if(map.get(nums[i]) == 1){\\n                map.remove(nums[i]);\\n            }else{\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n            }\\n            // take difference\\n            ans[i] = prefix.size()-map.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757255,
                "title": "very-very-easy-jebasraja",
                "content": "# Intuition:\\u2764\\uFE0FKARUNYA UNIVERSITY::ACCENTURE\\u2764\\uFE0F\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] distinctDifferenceArray(int[] nums) \\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\n\\t \\n\\t \\n\\t int numberofdistinct=0;\\n\\t \\n\\t int[] prefix=new int[nums.length];\\n\\t int[] suffix=new int[nums.length];\\n\\t //prefix\\n\\t for (int i=0;i<nums.length;i++ ) \\n\\t  {\\n\\t    for (int j=0;j<=i;j++)\\n\\t    {\\n\\t           if (set.contains(nums[j])==true)\\n\\t           {\\n\\t               \\n\\t           }\\n\\t           else\\n\\t           {\\n\\t              numberofdistinct++;\\n\\t              set.add(nums[j]);\\n\\t           }\\n\\t           \\n\\t    }\\n\\t    prefix[i]=numberofdistinct;\\n\\t    numberofdistinct=0;\\n\\t    set.clear();\\n\\t  }\\n\\t  numberofdistinct=0;\\n\\t  set.clear();\\n\\t  \\n\\t  \\n\\t  //SUFFIX\\n\\t  for (int i=0;i<nums.length;i++)\\n\\t  {\\n\\t      for (int j=i+1;j<nums.length;j++)\\n\\t      {\\n\\t          if (set.contains(nums[j])==true)\\n\\t           {\\n\\t               \\n\\t           }\\n\\t           else\\n\\t           {\\n\\t               numberofdistinct++;\\n\\t               set.add(nums[j]);\\n\\t           }\\n\\t      }\\n\\t     suffix[i]=numberofdistinct; \\n\\t    numberofdistinct=0;\\n\\t    set.clear();   \\n\\t  }\\n\\t  \\n\\t  \\n\\t  \\n\\t// System.out.println(\"_______prefix output__________\");\\n\\t  for (int k=0;k<prefix.length;k++)\\n\\t  {\\n\\t     // System.out.println(\"prefix \"+prefix[k]+\"suffix \"+suffix[k]);\\n\\t  \\n\\t     nums[k]= prefix[k]-suffix[k];\\n\\t  }\\n\\t\\n   return nums;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] distinctDifferenceArray(int[] nums) \\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\n\\t \\n\\t \\n\\t int numberofdistinct=0;\\n\\t \\n\\t int[] prefix=new int[nums.length];\\n\\t int[] suffix=new int[nums.length];\\n\\t //prefix\\n\\t for (int i=0;i<nums.length;i++ ) \\n\\t  {\\n\\t    for (int j=0;j<=i;j++)\\n\\t    {\\n\\t           if (set.contains(nums[j])==true)\\n\\t           {\\n\\t               \\n\\t           }\\n\\t           else\\n\\t           {\\n\\t              numberofdistinct++;\\n\\t              set.add(nums[j]);\\n\\t           }\\n\\t           \\n\\t    }\\n\\t    prefix[i]=numberofdistinct;\\n\\t    numberofdistinct=0;\\n\\t    set.clear();\\n\\t  }\\n\\t  numberofdistinct=0;\\n\\t  set.clear();\\n\\t  \\n\\t  \\n\\t  //SUFFIX\\n\\t  for (int i=0;i<nums.length;i++)\\n\\t  {\\n\\t      for (int j=i+1;j<nums.length;j++)\\n\\t      {\\n\\t          if (set.contains(nums[j])==true)\\n\\t           {\\n\\t               \\n\\t           }\\n\\t           else\\n\\t           {\\n\\t               numberofdistinct++;\\n\\t               set.add(nums[j]);\\n\\t           }\\n\\t      }\\n\\t     suffix[i]=numberofdistinct; \\n\\t    numberofdistinct=0;\\n\\t    set.clear();   \\n\\t  }\\n\\t  \\n\\t  \\n\\t  \\n\\t// System.out.println(\"_______prefix output__________\");\\n\\t  for (int k=0;k<prefix.length;k++)\\n\\t  {\\n\\t     // System.out.println(\"prefix \"+prefix[k]+\"suffix \"+suffix[k]);\\n\\t  \\n\\t     nums[k]= prefix[k]-suffix[k];\\n\\t  }\\n\\t\\n   return nums;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753131,
                "title": "easiest-code-using-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(n);\\n\\n        set<int> s;\\n        for(int i=0; i<nums.size(); i++){\\n            s.insert(nums[i]);\\n\\n            set<int> s2;\\n            for(int j=n-1; j>i; j--){\\n                s2.insert(nums[j]);\\n            }\\n\\n            ans[i] = s.size() - s2.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(n);\\n\\n        set<int> s;\\n        for(int i=0; i<nums.size(); i++){\\n            s.insert(nums[i]);\\n\\n            set<int> s2;\\n            for(int j=n-1; j>i; j--){\\n                s2.insert(nums[j]);\\n            }\\n\\n            ans[i] = s.size() - s2.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1889359,
                "content": [
                    {
                        "username": "assassinyogesh",
                        "content": "i dont know is example 2 is wrong here  "
                    },
                    {
                        "username": "LukeGirvan",
                        "content": "its distinct elements so you must use a set to eliminate duplicates otherwise all answers for arrays of length 5 would have to be [-3,-1,1,3,5]. "
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "In the input\\n\\nnums = [3,2,3,4,2]\\n\\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\\n\\nhow for i = 3 there are 3 distinct elements before i = 3 there is [3,2,3] so distinct element should be 2 right \\n\\nor am i missing something here?\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "i is inclusive here... so 3,2,3 & 4 will also be considered."
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, You are right."
                    },
                    {
                        "username": "mohitdbst",
                        "content": "bro , here if you notice the test cases clearly you can observe  that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that\\'s y it\\'s happening like this. \\nyou can refer my sol. below:\\n\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>pre;\\n        unordered_map<int,int>mp;\\n        for(auto e:nums){\\n            mp[e]++;\\n            pre.push_back(mp.size());\\n        }\\n        mp.clear();\\n        vector<int>suf(nums.size());\\n        for(int i = nums.size()-1;i>=0;i--){\\n            int e = nums[i];\\n            suf[i] = mp.size();\\n            mp[e]++;\\n        }\\n\\n        vector<int>ans;\\n        for(int i = 0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suf[i]);\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "amitjha00",
                        "content": " as mentioned in the question we have to count distinct element for prefix from 0 index to i index not i-1 index so the distinct element for index 3 in prefix are [3 2 4].\n\nAnd for suffix we have to count distinct element from i+1 index (means 4th index) to last index so the suffix are [2] for index 3.\n\nso 3-1 = 2. "
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@Shubham Kumar](/walkytalkyshubham) In prefix we count all the elements preceeding as well as the element itself but in suffix only the suceeding elements. So, for index 3 in [3,2,3,4,2], we have only 3 elements in prefix [3,2,3,4] and only 1 in suffix [2]. So diff is 3 - 1 = 2. Hope it helps!"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I did a for loop and i used Len function inside it ..to get the length of the set in the left and righ ..so the complexity is o(n^2) typically but i get a very high time effiency approx to 100% in time ... so my question can i solve it in only one path o(n) ?"
                    },
                    {
                        "username": "mohitdbst",
                        "content": " here if you notice the test cases clearly you can observe that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that's y it's happening like this.\nyou can refer my sol. below:\n\n `    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        vector<int>pre;\n        unordered_map<int,int>mp;\n        for(auto e:nums){\n            mp[e]++;\n            pre.push_back(mp.size());\n        }\n        mp.clear();\n        vector<int>suf(nums.size());\n        for(int i = nums.size()-1;i>=0;i--){\n            int e = nums[i];\n            suf[i] = mp.size();\n            mp[e]++;\n        }\n        vector<int>ans;\n        for(int i = 0;i<nums.size();i++){\n            ans.push_back(pre[i]-suf[i]);\n        }\n        return ans;\n    }`\n\nJust add a new line after every semicolon"
                    }
                ]
            },
            {
                "id": 1886840,
                "content": [
                    {
                        "username": "assassinyogesh",
                        "content": "i dont know is example 2 is wrong here  "
                    },
                    {
                        "username": "LukeGirvan",
                        "content": "its distinct elements so you must use a set to eliminate duplicates otherwise all answers for arrays of length 5 would have to be [-3,-1,1,3,5]. "
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "In the input\\n\\nnums = [3,2,3,4,2]\\n\\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\\n\\nhow for i = 3 there are 3 distinct elements before i = 3 there is [3,2,3] so distinct element should be 2 right \\n\\nor am i missing something here?\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "i is inclusive here... so 3,2,3 & 4 will also be considered."
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, You are right."
                    },
                    {
                        "username": "mohitdbst",
                        "content": "bro , here if you notice the test cases clearly you can observe  that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that\\'s y it\\'s happening like this. \\nyou can refer my sol. below:\\n\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>pre;\\n        unordered_map<int,int>mp;\\n        for(auto e:nums){\\n            mp[e]++;\\n            pre.push_back(mp.size());\\n        }\\n        mp.clear();\\n        vector<int>suf(nums.size());\\n        for(int i = nums.size()-1;i>=0;i--){\\n            int e = nums[i];\\n            suf[i] = mp.size();\\n            mp[e]++;\\n        }\\n\\n        vector<int>ans;\\n        for(int i = 0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suf[i]);\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "amitjha00",
                        "content": " as mentioned in the question we have to count distinct element for prefix from 0 index to i index not i-1 index so the distinct element for index 3 in prefix are [3 2 4].\n\nAnd for suffix we have to count distinct element from i+1 index (means 4th index) to last index so the suffix are [2] for index 3.\n\nso 3-1 = 2. "
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@Shubham Kumar](/walkytalkyshubham) In prefix we count all the elements preceeding as well as the element itself but in suffix only the suceeding elements. So, for index 3 in [3,2,3,4,2], we have only 3 elements in prefix [3,2,3,4] and only 1 in suffix [2]. So diff is 3 - 1 = 2. Hope it helps!"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I did a for loop and i used Len function inside it ..to get the length of the set in the left and righ ..so the complexity is o(n^2) typically but i get a very high time effiency approx to 100% in time ... so my question can i solve it in only one path o(n) ?"
                    },
                    {
                        "username": "mohitdbst",
                        "content": " here if you notice the test cases clearly you can observe that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that's y it's happening like this.\nyou can refer my sol. below:\n\n `    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        vector<int>pre;\n        unordered_map<int,int>mp;\n        for(auto e:nums){\n            mp[e]++;\n            pre.push_back(mp.size());\n        }\n        mp.clear();\n        vector<int>suf(nums.size());\n        for(int i = nums.size()-1;i>=0;i--){\n            int e = nums[i];\n            suf[i] = mp.size();\n            mp[e]++;\n        }\n        vector<int>ans;\n        for(int i = 0;i<nums.size();i++){\n            ans.push_back(pre[i]-suf[i]);\n        }\n        return ans;\n    }`\n\nJust add a new line after every semicolon"
                    }
                ]
            },
            {
                "id": 2056019,
                "content": [
                    {
                        "username": "assassinyogesh",
                        "content": "i dont know is example 2 is wrong here  "
                    },
                    {
                        "username": "LukeGirvan",
                        "content": "its distinct elements so you must use a set to eliminate duplicates otherwise all answers for arrays of length 5 would have to be [-3,-1,1,3,5]. "
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "In the input\\n\\nnums = [3,2,3,4,2]\\n\\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\\n\\nhow for i = 3 there are 3 distinct elements before i = 3 there is [3,2,3] so distinct element should be 2 right \\n\\nor am i missing something here?\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "i is inclusive here... so 3,2,3 & 4 will also be considered."
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, You are right."
                    },
                    {
                        "username": "mohitdbst",
                        "content": "bro , here if you notice the test cases clearly you can observe  that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that\\'s y it\\'s happening like this. \\nyou can refer my sol. below:\\n\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>pre;\\n        unordered_map<int,int>mp;\\n        for(auto e:nums){\\n            mp[e]++;\\n            pre.push_back(mp.size());\\n        }\\n        mp.clear();\\n        vector<int>suf(nums.size());\\n        for(int i = nums.size()-1;i>=0;i--){\\n            int e = nums[i];\\n            suf[i] = mp.size();\\n            mp[e]++;\\n        }\\n\\n        vector<int>ans;\\n        for(int i = 0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suf[i]);\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "amitjha00",
                        "content": " as mentioned in the question we have to count distinct element for prefix from 0 index to i index not i-1 index so the distinct element for index 3 in prefix are [3 2 4].\n\nAnd for suffix we have to count distinct element from i+1 index (means 4th index) to last index so the suffix are [2] for index 3.\n\nso 3-1 = 2. "
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@Shubham Kumar](/walkytalkyshubham) In prefix we count all the elements preceeding as well as the element itself but in suffix only the suceeding elements. So, for index 3 in [3,2,3,4,2], we have only 3 elements in prefix [3,2,3,4] and only 1 in suffix [2]. So diff is 3 - 1 = 2. Hope it helps!"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I did a for loop and i used Len function inside it ..to get the length of the set in the left and righ ..so the complexity is o(n^2) typically but i get a very high time effiency approx to 100% in time ... so my question can i solve it in only one path o(n) ?"
                    },
                    {
                        "username": "mohitdbst",
                        "content": " here if you notice the test cases clearly you can observe that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that's y it's happening like this.\nyou can refer my sol. below:\n\n `    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        vector<int>pre;\n        unordered_map<int,int>mp;\n        for(auto e:nums){\n            mp[e]++;\n            pre.push_back(mp.size());\n        }\n        mp.clear();\n        vector<int>suf(nums.size());\n        for(int i = nums.size()-1;i>=0;i--){\n            int e = nums[i];\n            suf[i] = mp.size();\n            mp[e]++;\n        }\n        vector<int>ans;\n        for(int i = 0;i<nums.size();i++){\n            ans.push_back(pre[i]-suf[i]);\n        }\n        return ans;\n    }`\n\nJust add a new line after every semicolon"
                    }
                ]
            },
            {
                "id": 1889757,
                "content": [
                    {
                        "username": "assassinyogesh",
                        "content": "i dont know is example 2 is wrong here  "
                    },
                    {
                        "username": "LukeGirvan",
                        "content": "its distinct elements so you must use a set to eliminate duplicates otherwise all answers for arrays of length 5 would have to be [-3,-1,1,3,5]. "
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "In the input\\n\\nnums = [3,2,3,4,2]\\n\\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\\n\\nhow for i = 3 there are 3 distinct elements before i = 3 there is [3,2,3] so distinct element should be 2 right \\n\\nor am i missing something here?\\n"
                    },
                    {
                        "username": "daujo3036",
                        "content": "i is inclusive here... so 3,2,3 & 4 will also be considered."
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, You are right."
                    },
                    {
                        "username": "mohitdbst",
                        "content": "bro , here if you notice the test cases clearly you can observe  that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that\\'s y it\\'s happening like this. \\nyou can refer my sol. below:\\n\\nvector<int> distinctDifferenceArray(vector<int>& nums) {\\n        vector<int>pre;\\n        unordered_map<int,int>mp;\\n        for(auto e:nums){\\n            mp[e]++;\\n            pre.push_back(mp.size());\\n        }\\n        mp.clear();\\n        vector<int>suf(nums.size());\\n        for(int i = nums.size()-1;i>=0;i--){\\n            int e = nums[i];\\n            suf[i] = mp.size();\\n            mp[e]++;\\n        }\\n\\n        vector<int>ans;\\n        for(int i = 0;i<nums.size();i++){\\n            ans.push_back(pre[i]-suf[i]);\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "amitjha00",
                        "content": " as mentioned in the question we have to count distinct element for prefix from 0 index to i index not i-1 index so the distinct element for index 3 in prefix are [3 2 4].\n\nAnd for suffix we have to count distinct element from i+1 index (means 4th index) to last index so the suffix are [2] for index 3.\n\nso 3-1 = 2. "
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@Shubham Kumar](/walkytalkyshubham) In prefix we count all the elements preceeding as well as the element itself but in suffix only the suceeding elements. So, for index 3 in [3,2,3,4,2], we have only 3 elements in prefix [3,2,3,4] and only 1 in suffix [2]. So diff is 3 - 1 = 2. Hope it helps!"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I did a for loop and i used Len function inside it ..to get the length of the set in the left and righ ..so the complexity is o(n^2) typically but i get a very high time effiency approx to 100% in time ... so my question can i solve it in only one path o(n) ?"
                    },
                    {
                        "username": "mohitdbst",
                        "content": " here if you notice the test cases clearly you can observe that when we are counting or making array of distinct for prefix we are counting the element first and then adding that in the prefix array, where as when we are doing the same activity for suffix we are adding the count of distinct elements so far first and then considering the element on the current index. that's y it's happening like this.\nyou can refer my sol. below:\n\n `    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        vector<int>pre;\n        unordered_map<int,int>mp;\n        for(auto e:nums){\n            mp[e]++;\n            pre.push_back(mp.size());\n        }\n        mp.clear();\n        vector<int>suf(nums.size());\n        for(int i = nums.size()-1;i>=0;i--){\n            int e = nums[i];\n            suf[i] = mp.size();\n            mp[e]++;\n        }\n        vector<int>ans;\n        for(int i = 0;i<nums.size();i++){\n            ans.push_back(pre[i]-suf[i]);\n        }\n        return ans;\n    }`\n\nJust add a new line after every semicolon"
                    }
                ]
            }
        ]
    }
]