[
    {
        "title": "All Ancestors of a Node in a Directed Acyclic Graph",
        "question_content": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.\n&nbsp;\nExample 1:\n\nInput: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.\n\nExample 2:\n\nInput: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000\n\t0 <= edges.length <= min(2000, n * (n - 1) / 2)\n\tedges[i].length == 2\n\t0 <= fromi, toi <= n - 1\n\tfromi != toi\n\tThere are no duplicate edges.\n\tThe graph is directed and acyclic.",
        "solutions": [
            {
                "id": 1821935,
                "title": "python3-java-c-simple-dfs-o-n-2",
                "content": "**Explanation**:\\n* DFS on each node `x`\\n* For every node `ch` that is found after node `x` in dfs, add `x` as parent of `ch`\\n\\n**Steps**:\\n* Record the direct children of each node in a graph. Can be implemented using nested vectors or hashmap of lists.\\n* Run DFS for each node in graph\\n* For every subsequent node that is found after dfs starting from x, add x as parent of subsequent node in ans\\n\\n*If dfs from x is like:*\\n\\n```\\n                       x\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t\\t\\t 3    5\\n\\t\\t\\t\\t\\t |    | \\\\\\n\\t\\t\\t\\t\\t 1    8  0 \\n\\t\\t\\t\\t\\t\\n```\\n*x is added as parent for 3, 5, 1, 8, 0*\\n\\n<iframe src=\"https://leetcode.com/playground/JQFvFjdu/shared\" frameBorder=\"0\" width=\"750\" height=\"400\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n                       x\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t\\t\\t 3    5\\n\\t\\t\\t\\t\\t |    | \\\\\\n\\t\\t\\t\\t\\t 1    8  0 \\n\\t\\t\\t\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822108,
                "title": "c-solution-plain-dfs-short-and-clean-code",
                "content": "Simple DFS\\nIdea is simple if you start from any node then the node that you will be visiting will have start node as an ancestor.\\nLet us understand with an example.\\nLet\\'s say i start from node 0 and i have visited node 1 node 3 and node 4 \\nso node 0 will be ancestor of all node 1,3 and 4\\n\\n* Ancestor Meaning: \" A node u is an ancestor of another node v if u can reach v via a set of edges\"\\n\\n* Node 0 is ancestor of which all nodes?\\n=> Start a DFS(/BFS) from node 0 as src, and all the reachable nodes will\\nalways have node 0 as an ancestor [from definition]\\n\\n* Node 1 is ancestor of which all nodes?\\n=> Start a DFS(/BFS) from node 1 as src, and all the reachable nodes will\\nalways have node 1 as an ancestor [from definition of ancestor]\\n\\n* Node 2 is .....?\\n=> Start a DFS(/BFS) from node 2, ....\\n\\n...\\n\\n* Node n is ancestor of which all nodes?\\n=> Start a DFS(/BFS) from node n as src , and all the reachable nodes will\\nalways have node n as an ancestor [from definition of ancestor]\\n\\n* Hence, you see that we will automatically have all the ancestors in\\nincreasing order.\\n\\n* TC:O(N*N) Since for each src node (i) we do a DFS(/BFS) of entire graph form (i) and check which nodes are reachable\\n\\n* SC:O(N) for DFS(/BFS) + O(N^N) for returning answer\\n\\nThank you @[tbne1905](https://leetcode.com/tbne1905/) for such a nice explanation.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int i,int j,vector<vector<int>> &ans,vector<bool> &vis){\\n        vis[j]=true;\\n        for(auto &x:graph[j]){\\n            if(!vis[x]){\\n                ans[x].push_back(i);\\n                dfs(graph,i,x,ans,vis);\\n            }\\n            \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<bool> vis(n);\\n            dfs(graph,i,i,ans,vis);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nNow the `vis` array that we are using is an overhead to our code. So lets try to remove this.\\nYou wonder how we will remove it? right?\\nLets understand What\\'s happening .\\nIf we will not use `vis` array then the element for which we arleady added `starting node` as an ancestor we will be adding again and again if we keep visiting that node from some other path. Lets understand this with example.\\nif we start from 0 and visited 2 ,3 ,4.\\nso we have 0 as an ancestor for 2,3 and 4\\nnow lets assume we have a directed edge from 3 to 2 \\nso when we will go deeper in dfs then we will again visit 2 and we will put 0 as an ancestor of 2 again so we will be end up getting `[0,0]` so by using `vis` array we are removing this only so this can be removed by simple if logic\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int i,int j,vector<vector<int>> &ans){\\n        for(auto &x:graph[j]){\\n            if(ans[x].empty() || ans[x].back()!=i){\\n                ans[x].push_back(i);\\n                dfs(graph,i,x,ans);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(graph,i,i,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you have any doubt ask in comment section ..I\\'ll be happy to help**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int i,int j,vector<vector<int>> &ans,vector<bool> &vis){\\n        vis[j]=true;\\n        for(auto &x:graph[j]){\\n            if(!vis[x]){\\n                ans[x].push_back(i);\\n                dfs(graph,i,x,ans,vis);\\n            }\\n            \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<bool> vis(n);\\n            dfs(graph,i,i,ans,vis);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int i,int j,vector<vector<int>> &ans){\\n        for(auto &x:graph[j]){\\n            if(ans[x].empty() || ans[x].back()!=i){\\n                ans[x].push_back(i);\\n                dfs(graph,i,x,ans);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(graph,i,i,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821991,
                "title": "java-python-3-2-codes-topological-sort-dfs-w-brief-explanation-and-comments",
                "content": "**Topological Sort**\\n\\n1. Build graph from parent to kids, and compute in-degree for each node;\\n2. Use topological to get direct parent and all ancestors of the direct parent of each node;\\n\\n```java\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        // Build graph, and compute in degree.\\n        int[] inDegree = new int[n];\\n        Map<Integer, List<Integer>> parentToKids = new HashMap<>();\\n        for (int[] e : edges) {\\n            parentToKids.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n            ++inDegree[e[1]];\\n        }\\n        \\n        // 1. Use a list of sets to save ancestors \\n        // and to avoid duplicates.\\n        // 2. Use a Queue to save 0-in-degree nodes as\\n        // the starting nodes for topological sort.\\n        List<Set<Integer>> sets = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; ++i) {\\n            sets.add(new HashSet<>());\\n            if (inDegree[i] == 0)\\n                q.offer(i);\\n        }\\n        \\n        // BFS to their neighbors and decrease \\n        // the in degrees, when reaching 0, add\\n        // it into queue;\\n        // During this procedure, get direct parent, add \\n        // all ancestors of direct parents\\' of each kid.\\n        while (!q.isEmpty()) {\\n            int parent = q.poll();\\n            for (int kid : parentToKids.getOrDefault(parent, Arrays.asList())) {\\n                sets.get(kid).add(parent);\\n                sets.get(kid).addAll(sets.get(parent));\\n                if (--inDegree[kid] == 0)\\n                    q.offer(kid);\\n            }\\n        }\\n        \\n        // Sort ancestors and put into return list. \\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (Set<Integer> set : sets)\\n            ans.add(new ArrayList<>(new TreeSet<>(set)));\\n        return ans;\\n    }\\n```\\n```python\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n         \\n        # Build graph, compute in degree and\\n        # get direct parent for each node.   \\n        ans = [set() for _ in range(n)]\\n        in_degree = [0] * n\\n        parent_to_kids = defaultdict(set)\\n        for parent, kid in edges:\\n            ans[kid].add(parent)\\n            parent_to_kids[parent].add(kid)\\n            in_degree[kid] += 1\\n            \\n        # Use Topological sort to get direct parent\\'s all ancestors    \\n        dq = deque([u for u, degree in enumerate(in_degree) if degree == 0])\\n        while dq:\\n            parent = dq.popleft()\\n            for kid in parent_to_kids[parent]:\\n                ans[kid].update(ans[parent])\\n                in_degree[kid] -= 1\\n                if in_degree[kid] == 0:\\n                    dq.append(kid)\\n        return [sorted(s) for s in  ans]    \\n```\\n\\n----\\n\\n**DFS**\\n\\n**Q & A**\\n*Q1*: In the DFS approach how are we sorting the sublists?\\n*A1*: \\n1) The recursion sequence of the dfs method \\nand \\n2) the traversal sequence in the last for loop in the `getAncestors` method \\n\\nguarantee that the ancestor list is sorted during adding process.\\n\\nYou can print out the methods names and nodes number to verify it.\\n\\n----\\n\\n\\n1. Build graph from parent to kids, and save `n` empty list into return List `ans`; \\n2. Traverse all nodes; for each node, recurse to the lowest offspring; During recursion, add the ancestor into the corresponding ancestors list for each offspring;\\n3. The recursion terminates once the the ancestor list ends with current ancestor.\\n\\n```java\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> parentToKids = new HashMap<>();\\n        for (int[] e : edges) {\\n            parentToKids.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            ans.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            dfs(i, i, ans, parentToKids);\\n        }\\n        return ans;\\n    }\\n    private void dfs(int ancestor, int kid, List<List<Integer>> ans, Map<Integer, List<Integer>> parentToKids) {\\n        List<Integer> ancestors = ans.get(kid);\\n        if (ancestors.isEmpty() || ancestors.get(ancestors.size() - 1) != ancestor) {\\n            if (ancestor != kid) {\\n                ancestors.add(ancestor);\\n            }\\n            for (int grandKid : parentToKids.getOrDefault(kid, Arrays.asList())) {\\n                dfs(ancestor, grandKid, ans, parentToKids);\\n            }\\n        }\\n    }\\n```\\n```python\\n   def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        def dfs(ancestor: int, kid: int) -> None:\\n            if not (ans[kid] and ans[kid][-1] == ancestor):\\n                if kid != ancestor:\\n                    ans[kid].append(ancestor)\\n                for grand_child in parent_to_kids[kid]:\\n                    dfs(ancestor, grand_child)\\n\\n        parent_to_kids = defaultdict(list)\\n        for parent, kid in edges:\\n            parent_to_kids[parent].append(kid)\\n        ans = [[] for _ in range(n)]\\n        for i in range(n):\\n            dfs(i, i)\\n        return ans\\n```\\n\\n**Analysis for both methods:**\\n\\nTime & space: `O(n ^ 2 + E)`, where `E = # of edges`.\\n\\n----\\n\\nPlease free feel to ask if you have any questions, and **Upovte** if it is helpful. Thanks.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        // Build graph, and compute in degree.\\n        int[] inDegree = new int[n];\\n        Map<Integer, List<Integer>> parentToKids = new HashMap<>();\\n        for (int[] e : edges) {\\n            parentToKids.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n            ++inDegree[e[1]];\\n        }\\n        \\n        // 1. Use a list of sets to save ancestors \\n        // and to avoid duplicates.\\n        // 2. Use a Queue to save 0-in-degree nodes as\\n        // the starting nodes for topological sort.\\n        List<Set<Integer>> sets = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; ++i) {\\n            sets.add(new HashSet<>());\\n            if (inDegree[i] == 0)\\n                q.offer(i);\\n        }\\n        \\n        // BFS to their neighbors and decrease \\n        // the in degrees, when reaching 0, add\\n        // it into queue;\\n        // During this procedure, get direct parent, add \\n        // all ancestors of direct parents\\' of each kid.\\n        while (!q.isEmpty()) {\\n            int parent = q.poll();\\n            for (int kid : parentToKids.getOrDefault(parent, Arrays.asList())) {\\n                sets.get(kid).add(parent);\\n                sets.get(kid).addAll(sets.get(parent));\\n                if (--inDegree[kid] == 0)\\n                    q.offer(kid);\\n            }\\n        }\\n        \\n        // Sort ancestors and put into return list. \\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (Set<Integer> set : sets)\\n            ans.add(new ArrayList<>(new TreeSet<>(set)));\\n        return ans;\\n    }\\n```\n```python\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n         \\n        # Build graph, compute in degree and\\n        # get direct parent for each node.   \\n        ans = [set() for _ in range(n)]\\n        in_degree = [0] * n\\n        parent_to_kids = defaultdict(set)\\n        for parent, kid in edges:\\n            ans[kid].add(parent)\\n            parent_to_kids[parent].add(kid)\\n            in_degree[kid] += 1\\n            \\n        # Use Topological sort to get direct parent\\'s all ancestors    \\n        dq = deque([u for u, degree in enumerate(in_degree) if degree == 0])\\n        while dq:\\n            parent = dq.popleft()\\n            for kid in parent_to_kids[parent]:\\n                ans[kid].update(ans[parent])\\n                in_degree[kid] -= 1\\n                if in_degree[kid] == 0:\\n                    dq.append(kid)\\n        return [sorted(s) for s in  ans]    \\n```\n```java\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> parentToKids = new HashMap<>();\\n        for (int[] e : edges) {\\n            parentToKids.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            ans.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            dfs(i, i, ans, parentToKids);\\n        }\\n        return ans;\\n    }\\n    private void dfs(int ancestor, int kid, List<List<Integer>> ans, Map<Integer, List<Integer>> parentToKids) {\\n        List<Integer> ancestors = ans.get(kid);\\n        if (ancestors.isEmpty() || ancestors.get(ancestors.size() - 1) != ancestor) {\\n            if (ancestor != kid) {\\n                ancestors.add(ancestor);\\n            }\\n            for (int grandKid : parentToKids.getOrDefault(kid, Arrays.asList())) {\\n                dfs(ancestor, grandKid, ans, parentToKids);\\n            }\\n        }\\n    }\\n```\n```python\\n   def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        def dfs(ancestor: int, kid: int) -> None:\\n            if not (ans[kid] and ans[kid][-1] == ancestor):\\n                if kid != ancestor:\\n                    ans[kid].append(ancestor)\\n                for grand_child in parent_to_kids[kid]:\\n                    dfs(ancestor, grand_child)\\n\\n        parent_to_kids = defaultdict(list)\\n        for parent, kid in edges:\\n            parent_to_kids[parent].append(kid)\\n        ans = [[] for _ in range(n)]\\n        for i in range(n):\\n            dfs(i, i)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823075,
                "title": "c-bfs-kahn-s-algorithm-explained-with-image-and-dry-run-topological-sort",
                "content": "\\n![image](https://assets.leetcode.com/users/images/2a09ff9f-1953-4502-aca9-db7e2b285cdc_1646514461.6325643.png)\\n\\n**n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]**\\n\\nNow **adjancecy list** will be:\\n0 -> 1,2,3,4\\n1 -> 2,3,4\\n2 -> 3,4\\n3 -> 4\\n4 ->\\n\\n**Indegree vector:**\\n0 -> 0\\n1 -> 1\\n2 -> 2\\n3 -> 3\\n4 -> 4\\n\\nSo queue will have just 0 while starting\\n**cur=0**\\n\\nso **\\'it\\'** will have the value **1,2,3,4** one by one\\nand st[it].insert(cur) will make the set look like\\n**0 -> \\n1 -> 0\\n2 -> 0\\n3 -> 0\\n4 -> 0**\\n\\nAfter **indegree[it]--**\\n**indegree array** will look like\\n0 -> 0\\n1 -> 0\\n2 -> 1\\n3 -> 2\\n4 -> 3\\n\\ntherefore 1 willl be pushed into the queue\\n\\nnow for next iteration **cur=1**\\n\\nso \\'it\\' will have the value 2,3,4 one by one\\nand **st[it].insert(cur)** will make the set look like\\n0 -> \\n1 -> 0\\n2 -> 0,1\\n3 -> 0,1\\n4 -> 0,1\\n\\nnow \\nfor(auto it2:st[cur])\\n     st[it].insert(it2);\\n\\t \\nThis will add parent of 1(ancestors of \\'it\\') in all the childnode of cur i.e 1\\nAlthough in this case, 0 is the direct parent of 2,3,4 so 0 is already present.\\n\\n**BUT\\nin a scenario where  ADJ LIST is\\n0 -> 1\\n1 -> 2,3,4\\n2 -> 3,4\\n3 -> 4\\n4 ->\\nthen \\nfor 2,3,4  0 would have also been added as an ancestor by the above 2 lines of code.**\\n\\nMoving on\\nAfter indegree[it]--\\nindegree array will look like\\n0 -> 0\\n1 -> 0\\n2 -> 0\\n3 -> 1\\n4 -> 2\\n\\n**therefore 2 willl be pushed into the queue\\nand iteration continues**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        //stores vector of adjacency list with each node having a vector of nodes to which it points \\n        vector<int> adj_list[n];   \\n        \\n        //stores indegree of each node\\n        vector<int> indegree(n);\\n        \\n        //creating adjacency list and updating indegrees\\n        for(int i=0;i<edges.size();++i)\\n        {\\n            adj_list[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        \\n        //queue for BFS Traversal\\n        queue<int> q; \\n        \\n        //adding all the nodes with indegree==0 as they act as the source node\\n        for(int i=0;i<n;++i)\\n        {\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        set<int> st[n]; //to avoid repetition of parent nodes \\n        while(!q.empty())\\n        {\\n            \\n            int cur=q.front(); \\n            q.pop();\\n            \\n            for(auto it:adj_list[cur])\\n            {\\n                //inserting immediate parent node to each child of current node\\n                st[it].insert(cur); \\n                \\n                //adds all the ancestors of the current node\\n                for(auto it2:st[cur])\\n                    st[it].insert(it2);\\n                 \\n                //adding to queue if indegree ==0\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                q.push(it);\\n            }\\n        }\\n        \\n        //to store ans\\n        vector<vector<int>> ans(n,vector<int>());\\n        \\n        //adding ancestors of each node to final ans vector\\n        for(int i=0;i<n;++i)\\n            ans[i]=vector<int>(st[i].begin(),st[i].end());\\n        \\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        //stores vector of adjacency list with each node having a vector of nodes to which it points \\n        vector<int> adj_list[n];   \\n        \\n        //stores indegree of each node\\n        vector<int> indegree(n);\\n        \\n        //creating adjacency list and updating indegrees\\n        for(int i=0;i<edges.size();++i)\\n        {\\n            adj_list[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        \\n        //queue for BFS Traversal\\n        queue<int> q; \\n        \\n        //adding all the nodes with indegree==0 as they act as the source node\\n        for(int i=0;i<n;++i)\\n        {\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        set<int> st[n]; //to avoid repetition of parent nodes \\n        while(!q.empty())\\n        {\\n            \\n            int cur=q.front(); \\n            q.pop();\\n            \\n            for(auto it:adj_list[cur])\\n            {\\n                //inserting immediate parent node to each child of current node\\n                st[it].insert(cur); \\n                \\n                //adds all the ancestors of the current node\\n                for(auto it2:st[cur])\\n                    st[it].insert(it2);\\n                 \\n                //adding to queue if indegree ==0\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                q.push(it);\\n            }\\n        }\\n        \\n        //to store ans\\n        vector<vector<int>> ans(n,vector<int>());\\n        \\n        //adding ancestors of each node to final ans vector\\n        for(int i=0;i<n;++i)\\n            ans[i]=vector<int>(st[i].begin(),st[i].end());\\n        \\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822414,
                "title": "dfs",
                "content": "It could be hard to find an efficient solution here. I tried DFS and got TLE, then tried BFS and it got AC. Later, I realized that we can make DFS efficient, and it is much simpler.\\n\\nWe first build the adjacency list `al`. Then, we start from each ancestor node ( `anc`), and traverse all children. For each child, we add `anc` to the list of ancestors.\\n\\nThat way, the list of ancestors will be naturally sorted.\\n\\n> Note: for each child, we can check if it\\'s visited by inspecting it\\'s last ancestor. We will get TLE if we do not check if the child has been visited and deduping list of ancestors later.\\n\\n**C++**\\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> res(n), al(n);\\n    function<void(int, int)> dfs = [&](int i, int anc){\\n        for (auto j : al[i])\\n            if (res[j].empty() || res[j].back() != anc) {\\n                res[j].push_back(anc);\\n                dfs(j, anc);    \\n            }\\n    };\\n    for (auto &e: edges)\\n        al[e[0]].push_back(e[1]);\\n    for (int i = 0; i < n; ++i)\\n        dfs(i, i);\\n    return res;    \\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n ^ 2). Traversing DAG from a node is O(n), and we do it for n nodes.\\n- Memory:  O(n ^ 2). We can have up to `n ^ 2` edges to store. Also, we need up to `n ^ 2` to store the result.",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> res(n), al(n);\\n    function<void(int, int)> dfs = [&](int i, int anc){\\n        for (auto j : al[i])\\n            if (res[j].empty() || res[j].back() != anc) {\\n                res[j].push_back(anc);\\n                dfs(j, anc);    \\n            }\\n    };\\n    for (auto &e: edges)\\n        al[e[0]].push_back(e[1]);\\n    for (int i = 0; i < n; ++i)\\n        dfs(i, i);\\n    return res;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821981,
                "title": "topological-sort-cpp-solution",
                "content": "The idea is simple we can use topological sort .\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n\\t\\t\\n        vector<int>in(n,0);\\n        //we will create geraph first\\n\\t\\tfor(auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            in[it[1]]++;      //count of incoming edges\\n        }\\n\\t\\n        queue<int>q;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n\\t\\t\\t//We will push the edges ifirst which has zero incoming edges\\n            if(in[i] == 0)\\n                q.push(i);\\n        }\\n\\t\\t//there may be repeatation of node so we will use the set for unique value\\n\\t\\t\\n        vector<set<int>>ans(n);\\n        while(!q.empty()){\\n            int si = q.size();\\n            while(si--)\\n            {\\n                int top = q.front();\\n                for(int i : adj[top])\\n                {\\n\\t\\t\\t\\t//when we visit the node we will decrease the incoming egde count\\n                    in[i]--;\\n                     ans[i].insert(top);\\n\\t\\t\\t\\t\\t \\n                       if(in[i] == 0)\\n                           q.push(i);\\n                        for(auto j : ans[top])\\n                        {\\n                            ans[i].insert(j);\\n                        }\\n                    \\n                }\\n                q.pop();\\n            }\\n        }\\n        vector<vector<int>>res(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto j : ans[i])\\n            {\\n                res[i].push_back(j);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n\\t\\t\\n        vector<int>in(n,0);\\n        //we will create geraph first\\n\\t\\tfor(auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            in[it[1]]++;      //count of incoming edges\\n        }\\n\\t\\n        queue<int>q;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n\\t\\t\\t//We will push the edges ifirst which has zero incoming edges\\n            if(in[i] == 0)\\n                q.push(i);\\n        }\\n\\t\\t//there may be repeatation of node so we will use the set for unique value\\n\\t\\t\\n        vector<set<int>>ans(n);\\n        while(!q.empty()){\\n            int si = q.size();\\n            while(si--)\\n            {\\n                int top = q.front();\\n                for(int i : adj[top])\\n                {\\n\\t\\t\\t\\t//when we visit the node we will decrease the incoming egde count\\n                    in[i]--;\\n                     ans[i].insert(top);\\n\\t\\t\\t\\t\\t \\n                       if(in[i] == 0)\\n                           q.push(i);\\n                        for(auto j : ans[top])\\n                        {\\n                            ans[i].insert(j);\\n                        }\\n                    \\n                }\\n                q.pop();\\n            }\\n        }\\n        vector<vector<int>>res(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto j : ans[i])\\n            {\\n                res[i].push_back(j);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821952,
                "title": "c-brute-force-dfs",
                "content": "The core idea is just reverse the edges in the graph and then simply do dfs from every node and check how many  nodes that current node visits.\\n```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int,vector<int>> &gr,vector<bool> &vis,int src){\\n        vis[src] = true;\\n        \\n        for(auto v:gr[src]){\\n            if(!vis[v]){\\n                dfs(gr,vis,v);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>mp;\\n        \\n        for(auto i:edges){\\n            mp[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            vector<bool>vis(n,false);\\n            vector<int>tmp;\\n            \\n            dfs(mp,vis,i);\\n            for(int j=0;j<n;j++){\\n                if(vis[j] && i!=j){\\n                    tmp.push_back(j);\\n                }\\n            }\\n            \\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int,vector<int>> &gr,vector<bool> &vis,int src){\\n        vis[src] = true;\\n        \\n        for(auto v:gr[src]){\\n            if(!vis[v]){\\n                dfs(gr,vis,v);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>mp;\\n        \\n        for(auto i:edges){\\n            mp[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            vector<bool>vis(n,false);\\n            vector<int>tmp;\\n            \\n            dfs(mp,vis,i);\\n            for(int j=0;j<n;j++){\\n                if(vis[j] && i!=j){\\n                    tmp.push_back(j);\\n                }\\n            }\\n            \\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268897,
                "title": "c-brute-force-dfs-with-a-easy-trick",
                "content": "# Trick: \\n* While building the adjacency list built the graph in reverse order. i.e `from -> to` \\u274C but `to -> from` \\u2705\\n* So now the children\\'s become the ancestors.\\n* Now simply do DFS and get all the child nodes of each parent node.\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>> &adj, vector<int> &curr, vector<bool> &vis)\\n    {\\n        vis[node] = true;\\n        \\n        for(int nbr : adj[node])\\n        {\\n            if(!vis[nbr])\\n            {\\n                curr.push_back(nbr);\\n                \\n                dfs(nbr, adj, curr, vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(vector<int> &edge: edges)\\n        {\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<vector<int>> answer(n);\\n        \\n        for(int i=0; i<n; ++i)\\n        {\\n            vector<bool> vis(n, false);\\n            \\n            vector<int> curr;\\n            \\n            dfs(i, adj, curr, vis);\\n            \\n            sort(curr.begin(), curr.end());\\n            \\n            answer[i] = curr;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>> &adj, vector<int> &curr, vector<bool> &vis)\\n    {\\n        vis[node] = true;\\n        \\n        for(int nbr : adj[node])\\n        {\\n            if(!vis[nbr])\\n            {\\n                curr.push_back(nbr);\\n                \\n                dfs(nbr, adj, curr, vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(vector<int> &edge: edges)\\n        {\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<vector<int>> answer(n);\\n        \\n        for(int i=0; i<n; ++i)\\n        {\\n            vector<bool> vis(n, false);\\n            \\n            vector<int> curr;\\n            \\n            dfs(i, adj, curr, vis);\\n            \\n            sort(curr.begin(), curr.end());\\n            \\n            answer[i] = curr;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821948,
                "title": "java-topological-sort",
                "content": "```\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        \\n        List<TreeSet<Integer>> ancestorList = new ArrayList();\\n        List<List<Integer>> list = new ArrayList();\\n\\n        Queue<Integer> queue = new LinkedList();\\n        \\n        int degree[] = new int[n];\\n        ArrayList<Integer>[] connections = new ArrayList[n];\\n        \\n        for(int i = 0;i<n;i++){\\n            connections[i] = new ArrayList<Integer>();\\n            ancestorList.add(new TreeSet<Integer>());\\n        }\\n        \\n        for(int edge[]: edges){\\n           connections[edge[0]].add(edge[1]);\\n           degree[edge[1]]++;\\n        }\\n    \\n        for(int i = 0;i<n;i++){\\n            if(degree[i] == 0){\\n                queue.add(i);\\n            }\\n        }\\n        \\n     \\n        while(!queue.isEmpty()){\\n            \\n            int currNode = queue.poll();\\n            for(int node : connections[currNode]){\\n                ancestorList.get(node).addAll(new TreeSet(ancestorList.get(currNode)));\\n                ancestorList.get(node).add(currNode);\\n                \\n                degree[node]--;\\n                if(degree[node] == 0){\\n                    queue.add(node);\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        for(TreeSet<Integer> set : ancestorList){\\n            list.add(new ArrayList<Integer>(set));\\n        }\\n        \\n        return list;\\n        \\n        \\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        \\n        List<TreeSet<Integer>> ancestorList = new ArrayList();\\n        List<List<Integer>> list = new ArrayList();\\n\\n        Queue<Integer> queue = new LinkedList();\\n        \\n        int degree[] = new int[n];\\n        ArrayList<Integer>[] connections = new ArrayList[n];\\n        \\n        for(int i = 0;i<n;i++){\\n            connections[i] = new ArrayList<Integer>();\\n            ancestorList.add(new TreeSet<Integer>());\\n        }\\n        \\n        for(int edge[]: edges){\\n           connections[edge[0]].add(edge[1]);\\n           degree[edge[1]]++;\\n        }\\n    \\n        for(int i = 0;i<n;i++){\\n            if(degree[i] == 0){\\n                queue.add(i);\\n            }\\n        }\\n        \\n     \\n        while(!queue.isEmpty()){\\n            \\n            int currNode = queue.poll();\\n            for(int node : connections[currNode]){\\n                ancestorList.get(node).addAll(new TreeSet(ancestorList.get(currNode)));\\n                ancestorList.get(node).add(currNode);\\n                \\n                degree[node]--;\\n                if(degree[node] == 0){\\n                    queue.add(node);\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        for(TreeSet<Integer> set : ancestorList){\\n            list.add(new ArrayList<Integer>(set));\\n        }\\n        \\n        return list;\\n        \\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1822955,
                "title": "bfs-java-solution-with-explanation",
                "content": "**Explanation**\\n1. Using bfs, We start with the nodes that have an indegree of zero.\\n2. Once we process all the nodes with in degree of zero at the current level, we move to the next level.\\n3. We repeat the above process untill all the nodes are processed.\\n\\n**Algorithm**\\n1. Create an indegree counter array and adjacency map.\\n2. Add each node with indegree count of zero the the queue.\\n3. Pop the parent node that needs to be processed.\\n4. For the current parent, get all the children.\\n5. For each child, add all the ancestors of parent to the child list.\\n6. Add the current parent to the child list.\\n7. Decrement the indegree count of the child node since we processed the current *parent -> child* edge.\\n8. If the in degree count of child becomes zero, then no parents are left. we add it to the queue.\\n\\n**Example**\\nInput: [Image](https://assets.leetcode.com/users/images/ca8a3cdd-061d-4dd3-af5a-1884655fe7c3_1646510728.9197474.png)\\nMatrix representation: {0:[3,1],1:[3],2:[3,5,1],3:[],4:[3,5,2,0],5:[0,3,1]}\\nOutput: [[2,4,5],[0,2,4,5],[4],[0,1,2,4,5],[],[2,4]]\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Set<Integer>> list = new ArrayList<>();\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int[] in = new int[n];\\n        \\n        // Initializing the path list & adjacency map.\\n        for(int i = 0; i < n; i++){\\n            list.add(new HashSet<>());\\n            map.put(i, new ArrayList<>());\\n        }\\n        \\n        // Processing all the edges. \\n        // For each edge add the child to adjacency matrix and incrment it\\'s indegree count.\\n        for(int[] edge: edges){\\n            int u = edge[0], v = edge[1];\\n            map.get(u).add(v);\\n            in[v]++;\\n        }\\n        \\n        // Intializing queue & add adding all nodes to with indegree count as zero to queue.\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++){\\n            if(in[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        // perform bfs traversal.\\n        // we add new node to the queue when its in degree becomes zero.\\n        while(!q.isEmpty()){\\n            int node = q.poll();\\n            for(int child: map.get(node)){\\n                list.get(child).addAll(list.get(node));\\n                list.get(child).add(node);\\n                in[child]--;\\n                if(in[child] == 0){\\n                    q.add(child);\\n                }\\n            }\\n        }\\n        \\n        // Convert the list into required format.\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(Set<Integer> s : list){\\n            result.add(new ArrayList<>(s));\\n            Collections.sort(result.get(result.size()-1));\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nplease upvote if this is simple & easy to understand/implement. Thanks :)",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Set<Integer>> list = new ArrayList<>();\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int[] in = new int[n];\\n        \\n        // Initializing the path list & adjacency map.\\n        for(int i = 0; i < n; i++){\\n            list.add(new HashSet<>());\\n            map.put(i, new ArrayList<>());\\n        }\\n        \\n        // Processing all the edges. \\n        // For each edge add the child to adjacency matrix and incrment it\\'s indegree count.\\n        for(int[] edge: edges){\\n            int u = edge[0], v = edge[1];\\n            map.get(u).add(v);\\n            in[v]++;\\n        }\\n        \\n        // Intializing queue & add adding all nodes to with indegree count as zero to queue.\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++){\\n            if(in[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        // perform bfs traversal.\\n        // we add new node to the queue when its in degree becomes zero.\\n        while(!q.isEmpty()){\\n            int node = q.poll();\\n            for(int child: map.get(node)){\\n                list.get(child).addAll(list.get(node));\\n                list.get(child).add(node);\\n                in[child]--;\\n                if(in[child] == 0){\\n                    q.add(child);\\n                }\\n            }\\n        }\\n        \\n        // Convert the list into required format.\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(Set<Integer> s : list){\\n            result.add(new ArrayList<>(s));\\n            Collections.sort(result.get(result.size()-1));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822053,
                "title": "reverse-all-edges-and-dfs-from-every-node",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = {}\\n        for a, b in edges:\\n            graph[b] = graph.get(b, []) + [a]\\n        op = [[] for i in range(n)]\\n        for a in graph:\\n            visited = set()\\n            paths = [a]\\n            while len(paths) > 0:\\n                curr = paths.pop()\\n                for b in graph.get(curr, []):\\n                    if b not in visited:\\n                        visited.add(b)\\n                        paths.append(b)\\n            op[a] = sorted(visited)\\n        return op\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = {}\\n        for a, b in edges:\\n            graph[b] = graph.get(b, []) + [a]\\n        op = [[] for i in range(n)]\\n        for a in graph:\\n            visited = set()\\n            paths = [a]\\n            while len(paths) > 0:\\n                curr = paths.pop()\\n                for b in graph.get(curr, []):\\n                    if b not in visited:\\n                        visited.add(b)\\n                        paths.append(b)\\n            op[a] = sorted(visited)\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822035,
                "title": "c-dfs-with-comments-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &graph, vector<vector<int>> &res, vector<bool> &vis, int start, int store) {\\n\\t\\t// mark the current node as visited to not reach it again\\n        vis[start] = true;\\n\\t\\t\\n\\t\\t// iterate over all the neighbours of start node\\n\\t\\t// and if it is not visited, add it to the result list\\n\\t\\t// make a recursive call making the current node as start \\n        for (int node : graph[start]) {\\n            if (!vis[node]) {\\n                res[node].push_back(store);\\n                dfs(graph, res, vis, node, store);\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // converting the edge list into an adjacency list\\n        vector<vector<int>> graph(n);\\n        for (auto &i : edges) {\\n            graph[i[0]].push_back(i[1]);\\n        }\\n        \\n        // here we iterate over all the nodes and check upto which nodes we can reach from the current node\\n        // for example, start from 0 and check upto which nodes we can reach from 0\\n        // when you reach a new node looping through the neighbours, add 0 to the result list at the index of the reached node\\n        // so as to mention that we can reach this node from 0\\n        vector<vector<int>> res(n);\\n        for (int i = 0; i < n; ++i) {\\n            vector<bool> visited(n);\\n\\t\\t\\t// mark the current node as visited to not reach it again\\n            visited[i] = true;\\n            dfs(graph, res, visited, i, i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &graph, vector<vector<int>> &res, vector<bool> &vis, int start, int store) {\\n\\t\\t// mark the current node as visited to not reach it again\\n        vis[start] = true;\\n\\t\\t\\n\\t\\t// iterate over all the neighbours of start node\\n\\t\\t// and if it is not visited, add it to the result list\\n\\t\\t// make a recursive call making the current node as start \\n        for (int node : graph[start]) {\\n            if (!vis[node]) {\\n                res[node].push_back(store);\\n                dfs(graph, res, vis, node, store);\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // converting the edge list into an adjacency list\\n        vector<vector<int>> graph(n);\\n        for (auto &i : edges) {\\n            graph[i[0]].push_back(i[1]);\\n        }\\n        \\n        // here we iterate over all the nodes and check upto which nodes we can reach from the current node\\n        // for example, start from 0 and check upto which nodes we can reach from 0\\n        // when you reach a new node looping through the neighbours, add 0 to the result list at the index of the reached node\\n        // so as to mention that we can reach this node from 0\\n        vector<vector<int>> res(n);\\n        for (int i = 0; i < n; ++i) {\\n            vector<bool> visited(n);\\n\\t\\t\\t// mark the current node as visited to not reach it again\\n            visited[i] = true;\\n            dfs(graph, res, visited, i, i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821957,
                "title": "ancestors-easy-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int s,vector<bool>& viz){\\n        viz[s]=true;\\n        for(auto x:adj[s]){\\n            if(!viz[x]){\\n                dfs(adj,x,viz);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n        }\\n        \\n        vector<vector<int>> rez(n);\\n        for(int i=0;i<n;i++){\\n            vector<bool>viz(n,false);\\n            dfs(adj,i,viz);\\n            \\n            for(int j=0;j<n;j++){\\n                if(viz[j] && i!=j){\\n                    rez[j].push_back(i);\\n                }\\n            }\\n        }\\n        return rez;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int s,vector<bool>& viz){\\n        viz[s]=true;\\n        for(auto x:adj[s]){\\n            if(!viz[x]){\\n                dfs(adj,x,viz);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n        }\\n        \\n        vector<vector<int>> rez(n);\\n        for(int i=0;i<n;i++){\\n            vector<bool>viz(n,false);\\n            dfs(adj,i,viz);\\n            \\n            for(int j=0;j<n;j++){\\n                if(viz[j] && i!=j){\\n                    rez[j].push_back(i);\\n                }\\n            }\\n        }\\n        return rez;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333862,
                "title": "python3-solved-using-topo-sort-kahn-algo-with-queue-bfs",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1824328,
                "title": "simple-bfs-solution",
                "content": "**Idea?**\\n* Consider every node as the source point and start breadth first search from that node.\\n* Whatever, the node that will be visited during the path have the ancestors as source node.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N^2)\\n    // Space Complexity:- O(N^2)\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> ans(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<bool> vis(n);\\n            queue<int> q;\\n            \\n            q.push(i);\\n            vis[i] = true;\\n            \\n            while(!q.empty()){\\n                int v = q.front();\\n                q.pop();\\n                \\n                for(auto& u:adj[v]){\\n                    if(!vis[u]){\\n                        q.push(u);\\n                        vis[u] = true;\\n                        ans[u].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N^2)\\n    // Space Complexity:- O(N^2)\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> ans(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<bool> vis(n);\\n            queue<int> q;\\n            \\n            q.push(i);\\n            vis[i] = true;\\n            \\n            while(!q.empty()){\\n                int v = q.front();\\n                q.pop();\\n                \\n                for(auto& u:adj[v]){\\n                    if(!vis[u]){\\n                        q.push(u);\\n                        vis[u] = true;\\n                        ans[u].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822374,
                "title": "java-dfs-parent-graph-treeset-easy-to-understand",
                "content": "**Solution:**\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Integer>[] parents = new ArrayList[n];\\n        TreeSet<Integer>[] ancestors = new TreeSet[n];\\n        for (int i = 0; i < n; ++ i) {\\n            parents[i] = new ArrayList<>();\\n        }\\n        \\n        for (int[] edge: edges) {\\n            parents[edge[1]].add(edge[0]);\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < n; ++ i) {\\n            if (ancestors[i] == null) {\\n                dfs(i, parents, ancestors);\\n            }\\n            \\n            result.add(new ArrayList<>(ancestors[i]));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public void dfs(int node, List<Integer>[] parents, TreeSet<Integer>[] ancestors) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int parent: parents[node]) {\\n            set.add(parent);\\n            if (ancestors[parent] == null) {\\n                dfs(parent, parents, ancestors);\\n            }\\n            set.addAll(ancestors[parent]);\\n        }\\n        \\n        ancestors[node] = set;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Integer>[] parents = new ArrayList[n];\\n        TreeSet<Integer>[] ancestors = new TreeSet[n];\\n        for (int i = 0; i < n; ++ i) {\\n            parents[i] = new ArrayList<>();\\n        }\\n        \\n        for (int[] edge: edges) {\\n            parents[edge[1]].add(edge[0]);\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < n; ++ i) {\\n            if (ancestors[i] == null) {\\n                dfs(i, parents, ancestors);\\n            }\\n            \\n            result.add(new ArrayList<>(ancestors[i]));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public void dfs(int node, List<Integer>[] parents, TreeSet<Integer>[] ancestors) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int parent: parents[node]) {\\n            set.add(parent);\\n            if (ancestors[parent] == null) {\\n                dfs(parent, parents, ancestors);\\n            }\\n            set.addAll(ancestors[parent]);\\n        }\\n        \\n        ancestors[node] = set;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822012,
                "title": "idea-explained-and-optimization-dfs-based-approach-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is to store nodes in adjacency list by **reversing edges.** \\n\\n\\t* i.e if we have **[ u -> v ],** then we store this in adjacency list as  **[ v -> u ]**\\n* In simple terms instead of connecting **parent -> child**, connect **child -> parent**\\n* So, in this way we can easily get all the ancestors of a node by simply doing **DFS**.\\n* Then perform simple DFS for each node from 0 to n-1.\\n* And in DFS call we store the nodes that are reachable from source node.\\n* In the end we sort all reachable nodes as mentioned in problem.\\n\\n# Code :\\n\\n```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<int>>& adj, vector<vector<int>>& res, vector<bool>& vis, int node, int source) {\\n        vis[node] = true;\\n\\t\\t// If current node is not source then \\n\\t\\t// add current node to list of ancestor of source node\\n        if(node != source) \\n            res[source].push_back(node);\\n\\t\\t\\n\\t\\t// Iterate over adjacent nodes and perform dfs \\n\\t\\t// to include ancestors \\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                dfs(adj, res, vis, adjnode, source);\\n            }\\n        }\\n    }\\n\\t\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n); // adjacency list\\n        vector<vector<int>> res(n); // List to store all ancestors of each node\\n        \\n        for(auto& edge : edges) {\\n\\t\\t\\t// Connect child -> parent\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n\\t\\t// Iterate over all node to get their ancestors\\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            dfs(adj, res, vis, i, i);\\n        }\\n        \\n\\t\\t// In the end, sort list of ancestors of each node\\n        for(int i=0; i<n; i++) {\\n            sort(begin(res[i]), end(res[i]));\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N * N + N * (k log k))` , \\n\\t* N -> number of nodes\\n\\t* k -> average number of ancestors of each node \\n\\n* Space : `~ O(N * N)`\\n\\n-------------------------------\\n\\nNote : We can optimize this certainly by skipping sorting step. And store ancestors of each node in such a way that it remains in sorted order.\\n\\n------------------------------------\\n\\n**Optimization :**\\n\\n* Idea here is to build adjacency list such that we connect **parent -> child**.\\n\\n* Then iterate over all nodes, considering it as a **parent node**, and perform DFS.\\n* Now, in DFS call, we pass **parent node**, and it would also be ancestor of all its adjacent nodes.\\n\\t* that we can reach from **parent node.**\\n* In this way we can get ancestors in sorted order, since we start from 0 to n.\\n\\n# Code : \\n\\n```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<int>>& adj, vector<vector<int>>& res, vector<bool>& vis, int node, int parent) {\\n        vis[node] = true;\\n\\t\\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                res[adjnode].push_back(parent);\\n                dfs(adj, res, vis, adjnode, parent);\\n            }\\n        }\\n    }\\n\\t\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n); // adjacency list\\n        vector<vector<int>> res(n); // List to store all ancestors of each node\\n        \\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            dfs(adj, res, vis, i, i);\\n        }      \\n\\t\\treturn res;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N * N)` , \\n\\t* N -> number of nodes\\n\\n* Space : `~ O(N * N)`\\n\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<int>>& adj, vector<vector<int>>& res, vector<bool>& vis, int node, int source) {\\n        vis[node] = true;\\n\\t\\t// If current node is not source then \\n\\t\\t// add current node to list of ancestor of source node\\n        if(node != source) \\n            res[source].push_back(node);\\n\\t\\t\\n\\t\\t// Iterate over adjacent nodes and perform dfs \\n\\t\\t// to include ancestors \\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                dfs(adj, res, vis, adjnode, source);\\n            }\\n        }\\n    }\\n\\t\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n); // adjacency list\\n        vector<vector<int>> res(n); // List to store all ancestors of each node\\n        \\n        for(auto& edge : edges) {\\n\\t\\t\\t// Connect child -> parent\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n\\t\\t// Iterate over all node to get their ancestors\\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            dfs(adj, res, vis, i, i);\\n        }\\n        \\n\\t\\t// In the end, sort list of ancestors of each node\\n        for(int i=0; i<n; i++) {\\n            sort(begin(res[i]), end(res[i]));\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<int>>& adj, vector<vector<int>>& res, vector<bool>& vis, int node, int parent) {\\n        vis[node] = true;\\n\\t\\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                res[adjnode].push_back(parent);\\n                dfs(adj, res, vis, adjnode, parent);\\n            }\\n        }\\n    }\\n\\t\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n); // adjacency list\\n        vector<vector<int>> res(n); // List to store all ancestors of each node\\n        \\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            dfs(adj, res, vis, i, i);\\n        }      \\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821934,
                "title": "python-3-topological-sort-o-v-e",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        in_degree = defaultdict(int)\\n        graph = defaultdict(set)\\n        \\n        for A, B in edges:\\n            graph[A].add(B)\\n            in_degree[B] += 1\\n        \\n        q = deque()\\n        \\n        for i in range(n):\\n            if i not in in_degree:\\n                q.append(i)\\n            \\n        ans = [set() for i in range(n)] \\n\\n        while q:\\n            node = q.popleft()\\n            \\n            for nei in graph[node]:\\n\\n                ans[nei].update(ans[node])  # my ancestors are your ancestors\\n                ans[nei].add(node)          # i\\'m your ancestor now, boy\\n                \\n                in_degree[nei] -= 1\\n                if in_degree[nei] == 0:\\n                    q.append(nei)\\n        for i in range(len(ans)):\\n            ans[i] = sorted(list(ans[i]))\\n        return ans    \\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        in_degree = defaultdict(int)\\n        graph = defaultdict(set)\\n        \\n        for A, B in edges:\\n            graph[A].add(B)\\n            in_degree[B] += 1\\n        \\n        q = deque()\\n        \\n        for i in range(n):\\n            if i not in in_degree:\\n                q.append(i)\\n            \\n        ans = [set() for i in range(n)] \\n\\n        while q:\\n            node = q.popleft()\\n            \\n            for nei in graph[node]:\\n\\n                ans[nei].update(ans[node])  # my ancestors are your ancestors\\n                ans[nei].add(node)          # i\\'m your ancestor now, boy\\n                \\n                in_degree[nei] -= 1\\n                if in_degree[nei] == 0:\\n                    q.append(nei)\\n        for i in range(len(ans)):\\n            ans[i] = sorted(list(ans[i]))\\n        return ans    \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2054706,
                "title": "c-easy-toposort-solution-clean-code-explained-with-comments",
                "content": "***The main intuition behind the approach is that, we can find the ancestor of a node only if we know the parents of the current node. We start from the node having no parent so that the ancestor of the node is also empty, then the children of that node will have their parent and the parent of parent and this will go so on***\\n\\n***This gives the clue that, we need to first analyse the parent of the node and then we need to analyse the node, so we thought of using toposort, the toposort works in such a manner that, the parent of current node will have occured before the current node. Means while finding the ancestor of the current node, we must have found the ancestor of its parent node, hence we will put the parent into the ancestor of current node and the ancestor array of its parents in the current node answer***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //here we are finding the toposort \\n    void findtoposort(int node, vector<int>&vis, unordered_map<int,vector<int>>&adj, stack<int>&stk){\\n        vis[node] = 1;\\n        \\n        for(int x: adj[node]){\\n            if(!vis[x]){\\n                findtoposort(x, vis, adj,stk);\\n            }\\n        }\\n        \\n        stk.push(node);\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        //this is the ancestor ans which we need to return \\n        vector<vector<int>>ans(n);\\n        //here is the visited array for finding the toposort\\n        vector<int>vis(n,0);\\n        //here is the stack for containing the elements of the DAG in topological sort manner\\n        stack<int>stk;\\n        \\n        //here we have created adjancency list in the mapped form as the node and then its children\\n        unordered_map<int, vector<int>>adj;\\n        //inserting children into the adjencency list\\n        for(int i = 0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        //here we are finding the toposort of the elements of the graph\\n        for(int i = 0; i<n; i++){\\n            if(!vis[i]){\\n                findtoposort(i, vis, adj, stk);\\n            }\\n        }\\n        \\n        //here is the map to store the parents of a node\\n        //first is the node and second is the set containing all the parents of the current node\\n        unordered_map<int, set<int>>mp;\\n        //inserting parents into the node\\n        for(int i = 0; i<edges.size(); i++){\\n            mp[edges[i][1]].insert(edges[i][0]);\\n        }\\n        \\n        //here we are traversing the stack in topological sort manner so that answer can be evaluated\\n        while(stk.empty()==false){\\n            int currnode = stk.top();\\n            stk.pop();\\n            set<int>s;\\n            \\n            for(int x: mp[currnode]){\\n                s.insert(x);\\n                s.insert(ans[x].begin(), ans[x].end());\\n            }\\n            \\n            vector<int>currvec(s.begin(), s.end());\\n            ans[currnode] = currvec;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //here we are finding the toposort \\n    void findtoposort(int node, vector<int>&vis, unordered_map<int,vector<int>>&adj, stack<int>&stk){\\n        vis[node] = 1;\\n        \\n        for(int x: adj[node]){\\n            if(!vis[x]){\\n                findtoposort(x, vis, adj,stk);\\n            }\\n        }\\n        \\n        stk.push(node);\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        //this is the ancestor ans which we need to return \\n        vector<vector<int>>ans(n);\\n        //here is the visited array for finding the toposort\\n        vector<int>vis(n,0);\\n        //here is the stack for containing the elements of the DAG in topological sort manner\\n        stack<int>stk;\\n        \\n        //here we have created adjancency list in the mapped form as the node and then its children\\n        unordered_map<int, vector<int>>adj;\\n        //inserting children into the adjencency list\\n        for(int i = 0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        //here we are finding the toposort of the elements of the graph\\n        for(int i = 0; i<n; i++){\\n            if(!vis[i]){\\n                findtoposort(i, vis, adj, stk);\\n            }\\n        }\\n        \\n        //here is the map to store the parents of a node\\n        //first is the node and second is the set containing all the parents of the current node\\n        unordered_map<int, set<int>>mp;\\n        //inserting parents into the node\\n        for(int i = 0; i<edges.size(); i++){\\n            mp[edges[i][1]].insert(edges[i][0]);\\n        }\\n        \\n        //here we are traversing the stack in topological sort manner so that answer can be evaluated\\n        while(stk.empty()==false){\\n            int currnode = stk.top();\\n            stk.pop();\\n            set<int>s;\\n            \\n            for(int x: mp[currnode]){\\n                s.insert(x);\\n                s.insert(ans[x].begin(), ans[x].end());\\n            }\\n            \\n            vector<int>currvec(s.begin(), s.end());\\n            ans[currnode] = currvec;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854153,
                "title": "c-easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>> &adj_list, vector<vector<bool>> &visited, int v)\\n    {\\n        queue<int> q;\\n        q.push(v);\\n        \\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            \\n            for(auto j : adj_list[temp]){\\n                if(visited[v][j] == false){\\n                    visited[v][j] = true;\\n                    q.push(j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj_list(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj_list[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(n,false));\\n        \\n        for(int i=0;i<n;i++){\\n            bfs(adj_list, visited, i);\\n        }\\n        \\n        vector<vector<int>> ans(n);\\n        \\n        for(int i=0;i<visited.size();i++){\\n            for(int j=0;j<visited[i].size();j++){\\n                if(visited[i][j] == true){\\n                    ans[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>> &adj_list, vector<vector<bool>> &visited, int v)\\n    {\\n        queue<int> q;\\n        q.push(v);\\n        \\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            \\n            for(auto j : adj_list[temp]){\\n                if(visited[v][j] == false){\\n                    visited[v][j] = true;\\n                    q.push(j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj_list(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj_list[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(n,false));\\n        \\n        for(int i=0;i<n;i++){\\n            bfs(adj_list, visited, i);\\n        }\\n        \\n        vector<vector<int>> ans(n);\\n        \\n        for(int i=0;i<visited.size();i++){\\n            for(int j=0;j<visited[i].size();j++){\\n                if(visited[i][j] == true){\\n                    ans[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832477,
                "title": "javascript-easy-to-understand-3-solutions-detailed-explanation",
                "content": "## Base Information\\n\\nIt\\'s a DAG, and we have all the edges, which means we also have these information:\\n- the indegree for each node, let\\'s call them array `indegrees`\\n- the outdegree for each node, let\\'s call them array `outdegrees`\\n- all the nodes that link to current node, let\\'s call them array `inEdges`\\n- all the nodes that current node linked to, let\\'s call them array `outEdges`\\n\\nBased on these information, let\\'s move into the 3 solutions.\\n\\n## BFS\\n\\nLet\\'s see what is a node with 0 indegree.\\n\\n![image](https://assets.leetcode.com/users/images/f91f9cd8-58c0-4b5b-8064-fc8ac072c803_1646791992.766624.png)\\n\\nWith this test case, it\\'s the nodes `0`, `1` and `2` at first. And since there\\'s no extra income edges, which means we\\'ve get the final result for these nodes already. Let\\'s call them the level 0.\\n\\nThen, for all the out edges from level 0, which are `3`, `4` and `7`, let\\'s update their indegree. Take the node `3` as an example:\\n- the first income edge is `[0, 3]`, so we could add all the income edges of `0` into the income edges of `3`, which is merging `inEdges[0]` into `inEdges[3]`. After this, we\\'ve handled this edge fine, so we could do the `--indegree[3]` to assume there\\'s no such edge.\\n- then, we do the same things to the second edge `[1, 3]`.\\n- finally, the node `3` is a new node with 0 indegree.\\n\\nLet\\'s finish all the things for the edges `3`, `4` and `7`. And then, we could get a new batch of nodes with 0 indegree, which are `3` and `4`. Let\\'s call them the level 1.\\n\\nThen, for all the out edges from level 1, we continue to do the same things above. We can get the level 2, level 3 and so on. Until there\\'s no node for the next level, which means we get all the results we want.\\n\\nFinally, let\\'s look back the whole strategy, it\\'s just like we get deeper level by level from the start. So, it\\'s a classic BFS strategy.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\n// BFS\\nconst getAncestors = (n, edges) => {\\n  const indegrees = new Uint16Array(n);\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outEdges = Array.from({ length: n }, () => []);\\n  let curLevel = [];\\n  // init information\\n  for (const [from, to] of edges) {\\n    ++indegrees[to];\\n    inEdges[to].add(from);\\n    outEdges[from].push(to);\\n  }\\n  // init level 0\\n  for (let i = 0; i < n; ++i) {\\n    indegrees[i] === 0 && curLevel.push(i);\\n  }\\n  // geting deeper level by level\\n  while (curLevel.length) {\\n    const next = [];\\n    for (const i of curLevel) {\\n      for (const out of outEdges[i]) {\\n        --indegrees[out] === 0 && next.push(out);\\n        for (const edge of inEdges[i]) {\\n          inEdges[out].add(edge);\\n        }\\n      }\\n    }\\n    curLevel = next;\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```\\n\\n## DFS - bottom top\\n\\nLet\\'s see how to get the final result for one node.\\n\\n![image](https://assets.leetcode.com/users/images/f91f9cd8-58c0-4b5b-8064-fc8ac072c803_1646791992.766624.png)\\n\\nWith this test case again, let\\'s take node `5` as an example:\\n- what\\'s the final result for node `5`\\n\\t- it comes from node `3` and the final result of node `3`\\n\\t- what\\'s the final result for node `3`\\n\\t\\t- it comes from node `0`, the final result of node `0`, node `1`, and the final result of node `1`\\n\\t\\t\\t- what\\'s the final result for node `0`\\n\\t\\t\\t\\t- empty\\n\\t\\t\\t- what\\'s the final result for node `1`\\n\\t\\t\\t\\t- empty\\n\\nWe could find out that we are dealing with the same kind of problem for different node again and again, until meets the end condition. That\\'s a classic recursive strategy.\\n\\nSo, for the whole problem, we just need to deal with all the leaf nodes as the start of recursion, then we could get the final answer.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\n// DFS - bottom top\\nconst dfs = (inEdges, idx, finished) => {\\n  if (finished[idx]) return; // avoid repeat calculation\\n  if (inEdges[idx].size === 0) return; // end condition\\n  for (const edge of inEdges[idx]) {\\n    dfs(inEdges, edge, finished); // move up\\n    inEdges[idx] = new Set([...inEdges[idx], ...inEdges[edge]]); // merge\\n  }\\n  finished[idx] = 1;\\n};\\nconst getAncestors = (n, edges) => {\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outdegrees = new Uint16Array(n);\\n  const finished = new Uint8Array(n);\\n  // init information\\n  for (const [from, to] of edges) {\\n    inEdges[to].add(from);\\n    ++outdegrees[from];\\n  }\\n  for (let i = 0; i < n; ++i) {\\n\\t// start dfs from every leaf node\\n    outdegrees[i] == 0 && dfs(inEdges, i, finished);\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```\\n\\n## DFS - top bottom\\n\\nLet\\'s see how we can handle all the effects of a node on the final result.\\n\\n![image](https://assets.leetcode.com/users/images/f91f9cd8-58c0-4b5b-8064-fc8ac072c803_1646791992.766624.png)\\n\\nWith this test case again again, haha, let\\'s take node `0` as an example. In the final result, the nodes `3`, `4`, `5`, `6` and `7` will be effected by node `0`. Let\\'s look at these nodes individually, actually it\\'s just a tree with the root node `0`. So we could traverse the tree by DFS easily to add the `0` to the result of each node.\\n\\nThen we do the same things for each node, so we could get the final result.\\n\\nHere\\'s a sameple code from me:\\n\\n```js\\n// DFS - top bottom\\nconst dfs = (inEdges, outEdges, originValue, curValue, finished) => {\\n  if (finished[curValue]) return; // avoid repeat calculation\\n  finished[curValue] = 1;\\n  for (const out of outEdges[curValue]) {\\n    inEdges[out].add(originValue);\\n    dfs(inEdges, outEdges, originValue, out, finished); // traverse tree\\n  }\\n};\\nconst getAncestors = (n, edges) => {\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outEdges = Array.from({ length: n }, () => []);\\n  // init information\\n  for (const [from, to] of edges) {\\n    inEdges[to].add(from);\\n    outEdges[from].push(to);\\n  }\\n  for (let i = 0; i < n; ++i) {\\n\\t// start dfs from each node as the root\\n    dfs(inEdges, outEdges, i, i, new Uint8Array(n));\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n// BFS\\nconst getAncestors = (n, edges) => {\\n  const indegrees = new Uint16Array(n);\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outEdges = Array.from({ length: n }, () => []);\\n  let curLevel = [];\\n  // init information\\n  for (const [from, to] of edges) {\\n    ++indegrees[to];\\n    inEdges[to].add(from);\\n    outEdges[from].push(to);\\n  }\\n  // init level 0\\n  for (let i = 0; i < n; ++i) {\\n    indegrees[i] === 0 && curLevel.push(i);\\n  }\\n  // geting deeper level by level\\n  while (curLevel.length) {\\n    const next = [];\\n    for (const i of curLevel) {\\n      for (const out of outEdges[i]) {\\n        --indegrees[out] === 0 && next.push(out);\\n        for (const edge of inEdges[i]) {\\n          inEdges[out].add(edge);\\n        }\\n      }\\n    }\\n    curLevel = next;\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```\n```js\\n// DFS - bottom top\\nconst dfs = (inEdges, idx, finished) => {\\n  if (finished[idx]) return; // avoid repeat calculation\\n  if (inEdges[idx].size === 0) return; // end condition\\n  for (const edge of inEdges[idx]) {\\n    dfs(inEdges, edge, finished); // move up\\n    inEdges[idx] = new Set([...inEdges[idx], ...inEdges[edge]]); // merge\\n  }\\n  finished[idx] = 1;\\n};\\nconst getAncestors = (n, edges) => {\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outdegrees = new Uint16Array(n);\\n  const finished = new Uint8Array(n);\\n  // init information\\n  for (const [from, to] of edges) {\\n    inEdges[to].add(from);\\n    ++outdegrees[from];\\n  }\\n  for (let i = 0; i < n; ++i) {\\n\\t// start dfs from every leaf node\\n    outdegrees[i] == 0 && dfs(inEdges, i, finished);\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```\n```js\\n// DFS - top bottom\\nconst dfs = (inEdges, outEdges, originValue, curValue, finished) => {\\n  if (finished[curValue]) return; // avoid repeat calculation\\n  finished[curValue] = 1;\\n  for (const out of outEdges[curValue]) {\\n    inEdges[out].add(originValue);\\n    dfs(inEdges, outEdges, originValue, out, finished); // traverse tree\\n  }\\n};\\nconst getAncestors = (n, edges) => {\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outEdges = Array.from({ length: n }, () => []);\\n  // init information\\n  for (const [from, to] of edges) {\\n    inEdges[to].add(from);\\n    outEdges[from].push(to);\\n  }\\n  for (let i = 0; i < n; ++i) {\\n\\t// start dfs from each node as the root\\n    dfs(inEdges, outEdges, i, i, new Uint8Array(n));\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824992,
                "title": "c-topological-sort-brief-explanation-similar-to-course-schedule-problem",
                "content": "**Intuition**\\n1. Since the graph is DAG and we need to find all the ancestors of a node. (Its kinda similar to Course Schedule Problem where we need to satisfy all prerequisite courses to do a particular course)\\n2. Topological sort came to my mind.\\n3. The concept is exactly same but we have to do some little tweaks. \\n4. For the current node all the neighbours we can reach will contain the current node as ancestor and all the ancestor of the current node will also be the ancestors of neighbours we can reach from current node. \\n5. So we will just iterate thru current node\\'s ancestor and push it inside neighbour\\'s ancestor vector and also push the current node because this would be an immediate and original predecessor.\\n6. also maintain a set for each node for storing ancestors because we can visit or add same node multiple times for a neighbour.\\n7. DONE!!!!!\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        int sz = edges.size();\\n        vector<vector<int>> l(n);\\n        vector<int> indegree(n,0);   \\n        \\n        vector<set<int>> ans(n);\\n\\n        for(int i = 0;i<sz;i++){\\n            l[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;   \\n        }\\n        \\n        queue<int> topological_order;\\n        \\n        for(int i = 0;i<n;i++){\\n            if(indegree[i] == 0){  \\n                topological_order.push(i);\\n                ans[i] = {};   \\n            }\\n        }\\n        \\n            \\n        while(!topological_order.empty()){\\n            int node = topological_order.front();\\n\\n            topological_order.pop();\\n            for(auto nbr : l[node]){\\n                    indegree[nbr]--;\\n                if(indegree[nbr] == 0){\\n                    topological_order.push(nbr);\\n                }\\n\\n                    for(auto x : ans[node]){\\n                        ans[nbr].insert(x);\\n                    }\\n                    ans[nbr].insert(node);\\n\\n                }\\n            }\\n            \\n        vector<vector<int>> res(n);\\n        \\n        for(int i = 0;i<ans.size();i++){\\n            for(auto x : ans[i]){\\n                res[i].push_back(x);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        int sz = edges.size();\\n        vector<vector<int>> l(n);\\n        vector<int> indegree(n,0);   \\n        \\n        vector<set<int>> ans(n);\\n\\n        for(int i = 0;i<sz;i++){\\n            l[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;   \\n        }\\n        \\n        queue<int> topological_order;\\n        \\n        for(int i = 0;i<n;i++){\\n            if(indegree[i] == 0){  \\n                topological_order.push(i);\\n                ans[i] = {};   \\n            }\\n        }\\n        \\n            \\n        while(!topological_order.empty()){\\n            int node = topological_order.front();\\n\\n            topological_order.pop();\\n            for(auto nbr : l[node]){\\n                    indegree[nbr]--;\\n                if(indegree[nbr] == 0){\\n                    topological_order.push(nbr);\\n                }\\n\\n                    for(auto x : ans[node]){\\n                        ans[nbr].insert(x);\\n                    }\\n                    ans[nbr].insert(node);\\n\\n                }\\n            }\\n            \\n        vector<vector<int>> res(n);\\n        \\n        for(int i = 0;i<ans.size();i++){\\n            for(auto x : ans[i]){\\n                res[i].push_back(x);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823406,
                "title": "c-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>ans(n);\\n        int m=edges.size();\\n        vector<vector<int>>adj(n);\\n        vector<int>indegree(n,0);\\n        for(int i=0; i<m; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            auto it=q.front();\\n            q.pop();\\n            \\n            for(auto i:adj[it])\\n            {\\n                indegree[i]--;\\n                \\n                set<int>s=ans[it];\\n                s.insert(it);\\n                \\n                for (auto itr = s.begin(); itr != s.end(); itr++)\\n                {\\n                    ans[i].insert(*itr);\\n                }\\n                \\n                if(indegree[i]==0)\\n                {\\n                    q.push(i);\\n                }\\n            }\\n        }\\n        vector<vector<int>>res;\\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int>v;\\n            set<int>s=ans[i];\\n            for(auto itr = s.begin(); itr != s.end(); itr++)\\n            {\\n                v.push_back(*itr);\\n            }\\n            res.push_back(v);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>ans(n);\\n        int m=edges.size();\\n        vector<vector<int>>adj(n);\\n        vector<int>indegree(n,0);\\n        for(int i=0; i<m; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1822118,
                "title": "python-3-reverse-direction-and-find-all-children",
                "content": "Reverse the direction for each edge and find all children of each node instead.\\nUse dynamic programming to save the paths of the previous nodes.\\nDo **UPVOTE** if you found it helpful.\\n\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        ans = [[] for _ in range(n)]\\n        \\n        graph = defaultdict(list)\\n        for f, t in edges:\\n            graph[t].append(f)\\n        \\n        memo = defaultdict(list)\\n        def dfs(src):\\n            if src in memo:\\n                return memo[src]\\n            \\n            for nei in graph[src]:\\n                memo[src] += [nei]+dfs(nei)\\n            \\n            memo[src] = list(set(memo[src]))\\n            return memo[src]\\n        \\n        for i in range(n):\\n            dfs(i)\\n        return [sorted(memo[i]) for i in range(n)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        ans = [[] for _ in range(n)]\\n        \\n        graph = defaultdict(list)\\n        for f, t in edges:\\n            graph[t].append(f)\\n        \\n        memo = defaultdict(list)\\n        def dfs(src):\\n            if src in memo:\\n                return memo[src]\\n            \\n            for nei in graph[src]:\\n                memo[src] += [nei]+dfs(nei)\\n            \\n            memo[src] = list(set(memo[src]))\\n            return memo[src]\\n        \\n        for i in range(n):\\n            dfs(i)\\n        return [sorted(memo[i]) for i in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821949,
                "title": "java-easy-to-understand-topological-sort",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer,Integer> dependencyCountMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> nextNodeMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> prevNodeMap = new HashMap<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int []edge: edges){\\n            dependencyCountMap.put(edge[1],dependencyCountMap.getOrDefault(edge[1],0)+1);\\n            Set<Integer> set = nextNodeMap.getOrDefault(edge[0],new HashSet<>());\\n            set.add(edge[1]);\\n            nextNodeMap.put(edge[0], set);\\n            \\n            set = prevNodeMap.getOrDefault(edge[1],new HashSet<>());\\n            set.add(edge[0]);\\n            prevNodeMap.put(edge[1], set);\\n        }\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n                if(dependencyCountMap.getOrDefault(i,0)==0){//if there are no unresolved dependencies\\n                    queue.offer(i);\\n                }\\n        }\\n        while(queue.size()>0){\\n            int current = queue.poll();\\n            for(int next: nextNodeMap.getOrDefault(current,new HashSet<>())){\\n                int nextCount = dependencyCountMap.getOrDefault(next,0);\\n                dependencyCountMap.put(next, nextCount - 1);\\n                if(nextCount -1 == 0)\\n                    queue.offer(next);\\n            }\\n            \\n            for(int prev: prevNodeMap.getOrDefault(current,new HashSet<>())){//pick resolved dependecies and add to result\\n                        map.putIfAbsent(current,new HashSet<>());\\n                        map.get(current).add(prev);//add 3,4 for 6\\n                        map.get(current).addAll(map.getOrDefault(prev, new HashSet<>()));\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t List<Integer> list =   new ArrayList<>(map.getOrDefault(i, new HashSet<>()));\\n             Collections.sort(list);\\n\\t\\t\\tresult.add(list);\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer,Integer> dependencyCountMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> nextNodeMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> prevNodeMap = new HashMap<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int []edge: edges){\\n            dependencyCountMap.put(edge[1],dependencyCountMap.getOrDefault(edge[1],0)+1);\\n            Set<Integer> set = nextNodeMap.getOrDefault(edge[0],new HashSet<>());\\n            set.add(edge[1]);\\n            nextNodeMap.put(edge[0], set);\\n            \\n            set = prevNodeMap.getOrDefault(edge[1],new HashSet<>());\\n            set.add(edge[0]);\\n            prevNodeMap.put(edge[1], set);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3941125,
                "title": "dfs-from-child-to-parent",
                "content": "# approach:\\njust take transpose of the graph and call dfs for each node.\\nAs graph edges are reversed and we are calling dfs, its like calling dfs from leaf to parent, and just keep appending the vertices which are not in ans[node]..... \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        ans = [[] for _ in range(n)]\\n\\n        g = defaultdict(list)\\n\\n        for u, v in edges:\\n            g[v].append(u)\\n        \\n        def dfs(node, curr):\\n            for v in g[curr]:\\n                if v not in ans[node]:\\n                    dfs(node, v)\\n                    ans[node].append(v)  \\n        \\n        for i in range(n):\\n            dfs(i,i)\\n\\n        for k in ans:\\n            k.sort()\\n            \\n        return ans \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        ans = [[] for _ in range(n)]\\n\\n        g = defaultdict(list)\\n\\n        for u, v in edges:\\n            g[v].append(u)\\n        \\n        def dfs(node, curr):\\n            for v in g[curr]:\\n                if v not in ans[node]:\\n                    dfs(node, v)\\n                    ans[node].append(v)  \\n        \\n        for i in range(n):\\n            dfs(i,i)\\n\\n        for k in ans:\\n            k.sort()\\n            \\n        return ans \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293704,
                "title": "python-elegant-short-reverse-edges",
                "content": "```\\nfrom collections import defaultdict\\nfrom typing import Iterable, List\\n\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> Iterable[List[int]]:\\n        def dfs(u: int) -> set:\\n            if not ancestors[u]:\\n                for v in graph[u]:\\n                    if v not in ancestors[u]:\\n                        ancestors[u].update({v} | dfs(v))\\n            return ancestors[u]\\n\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[v].add(u)\\n\\n        ancestors = [set() for _ in range(n)]\\n        for u in range(n):\\n            if not ancestors[u]:\\n                dfs(u)\\n\\n        return map(sorted, ancestors)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import Iterable, List\\n\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> Iterable[List[int]]:\\n        def dfs(u: int) -> set:\\n            if not ancestors[u]:\\n                for v in graph[u]:\\n                    if v not in ancestors[u]:\\n                        ancestors[u].update({v} | dfs(v))\\n            return ancestors[u]\\n\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[v].add(u)\\n\\n        ancestors = [set() for _ in range(n)]\\n        for u in range(n):\\n            if not ancestors[u]:\\n                dfs(u)\\n\\n        return map(sorted, ancestors)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775961,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> ans(n), directChild(n);\\n    for(auto& e: edges) \\n        directChild[e[0]].push_back(e[1]);\\n    for(int i = 0; i < n; i++)\\n        dfs(i, i, ans, directChild);\\n    return ans;\\n}\\nvoid dfs(int x, int curr, vector<vector<int>>& ans, vector<vector<int>>& directChild) {\\n    for (auto& ch: directChild[curr]) \\n        if(ans[ch].size() == 0 || ans[ch].back() != x) {\\n            ans[ch].push_back(x);\\n            dfs(x, ch, ans, directChild);\\n        }\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> ans(n), directChild(n);\\n    for(auto& e: edges) \\n        directChild[e[0]].push_back(e[1]);\\n    for(int i = 0; i < n; i++)\\n        dfs(i, i, ans, directChild);\\n    return ans;\\n}\\nvoid dfs(int x, int curr, vector<vector<int>>& ans, vector<vector<int>>& directChild) {\\n    for (auto& ch: directChild[curr]) \\n        if(ans[ch].size() == 0 || ans[ch].back() != x) {\\n            ans[ch].push_back(x);\\n            dfs(x, ch, ans, directChild);\\n        }\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725360,
                "title": "python-cached-dfs",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        v_edges = [set() for i in range(n)]\\n        for u, v in edges:\\n            v_edges[v].add(u)\\n        \\n        @cache\\n        def dfs(v):\\n            children = set()\\n            for v2 in v_edges[v]:\\n                children.add(v2)\\n                children |= dfs(v2)\\n            return children\\n        \\n        ans = [dfs(v) for v in range(n)]\\n        return [sorted(list(i)) for i in ans]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        v_edges = [set() for i in range(n)]\\n        for u, v in edges:\\n            v_edges[v].add(u)\\n        \\n        @cache\\n        def dfs(v):\\n            children = set()\\n            for v2 in v_edges[v]:\\n                children.add(v2)\\n                children |= dfs(v2)\\n            return children\\n        \\n        ans = [dfs(v) for v in range(n)]\\n        return [sorted(list(i)) for i in ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702965,
                "title": "brute-force-to-optimal-c",
                "content": "# O(n log n) \\n```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<set<int>> &ancs) {\\n        vis[node] = 1;\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, ancs);\\n            ancs[node].insert(ancs[ad].begin(), ancs[ad].end()), ancs[node].insert(ad);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[1]].push_back(e[0]);\\n\\n        vector<set<int>> ancs(n, set<int>());\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) dfs(i, adj, vis, ancs);\\n        }\\n        vector<vector<int>> ans;\\n        for(auto s : ancs) {\\n            vector<int> v(s.begin(), s.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# O(n ^ 2)\\n```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<vector<int>> &ans, int &sp) {\\n        for(int ad : adj[node]) {\\n            if(!ans[ad].size() || ans[ad].back() != sp) ans[ad].push_back(sp);\\n            dfs(ad, adj, ans, sp);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[0]].push_back(e[1]);\\n\\n        vector<vector<int>> ans(n, vector<int>());\\n        for(int i=0; i<n; i++) dfs(i, adj, ans, i);\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<set<int>> &ancs) {\\n        vis[node] = 1;\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, ancs);\\n            ancs[node].insert(ancs[ad].begin(), ancs[ad].end()), ancs[node].insert(ad);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[1]].push_back(e[0]);\\n\\n        vector<set<int>> ancs(n, set<int>());\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) dfs(i, adj, vis, ancs);\\n        }\\n        vector<vector<int>> ans;\\n        for(auto s : ancs) {\\n            vector<int> v(s.begin(), s.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<vector<int>> &ans, int &sp) {\\n        for(int ad : adj[node]) {\\n            if(!ans[ad].size() || ans[ad].back() != sp) ans[ad].push_back(sp);\\n            dfs(ad, adj, ans, sp);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[0]].push_back(e[1]);\\n\\n        vector<vector<int>> ans(n, vector<int>());\\n        for(int i=0; i<n; i++) dfs(i, adj, ans, i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680291,
                "title": "python-topological-sort",
                "content": "\\tclass Solution:\\n\\t\\tdef getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tin_degree = [0]*n\\n\\t\\t\\tres = [set() for _ in range(n)]\\n\\t\\t\\t\\n\\t\\t\\t# build the graph and count the in degree for each node\\n\\t\\t\\tfor i in edges:\\n\\t\\t\\t\\tgraph[i[0]].append(i[1])\\n\\t\\t\\t\\tin_degree[i[1]] += 1\\n\\t\\t\\t\\n\\t\\t\\tque = deque()\\n\\t\\t\\t# nodes with an in degree of 0 are added in the que \\n\\t\\t\\tfor i in range(len(in_degree)):\\n\\t\\t\\t\\tif not in_degree[i]:\\n\\t\\t\\t\\t\\tque.append(i)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tnode = que.popleft()\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor i in graph[node]:\\n\\t\\t\\t\\t\\t# since this node is already visited, we can decrease the in degree of it\\'s children by 1 \\n\\t\\t\\t\\t\\tin_degree[i] -= 1\\n\\t\\t\\t\\t\\tres[i].add(node)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# for the children nodes, we need to add the path of their ancestor \\n\\t\\t\\t\\t\\tfor j in res[node]:\\n\\t\\t\\t\\t\\t\\tres[i].add(j)\\n\\t\\t\\t\\t\\tif not in_degree[i]:\\n\\t\\t\\t\\t\\t\\tque.append(i)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tfor i in range(len(res)):\\n\\t\\t\\t\\tres[i] = sorted(res[i])\\n\\t\\t\\t   \\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tin_degree = [0]*n\\n\\t\\t\\tres = [set() for _ in range(n)]\\n\\t\\t\\t\\n\\t\\t\\t# build the graph and count the in degree for each node\\n\\t\\t\\tfor i in edges:\\n\\t\\t\\t\\tgraph[i[0]].append(i[1])\\n\\t\\t\\t\\tin_degree[i[1]] += 1\\n\\t\\t\\t\\n\\t\\t\\tque = deque()\\n\\t\\t\\t# nodes with an in degree of 0 are added in the que \\n\\t\\t\\tfor i in range(len(in_degree)):\\n\\t\\t\\t\\tif not in_degree[i]:\\n\\t\\t\\t\\t\\tque.append(i)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tnode = que.popleft()\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor i in graph[node]:\\n\\t\\t\\t\\t\\t# since this node is already visited, we can decrease the in degree of it\\'s children by 1 \\n\\t\\t\\t\\t\\tin_degree[i] -= 1\\n\\t\\t\\t\\t\\tres[i].add(node)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# for the children nodes, we need to add the path of their ancestor \\n\\t\\t\\t\\t\\tfor j in res[node]:\\n\\t\\t\\t\\t\\t\\tres[i].add(j)\\n\\t\\t\\t\\t\\tif not in_degree[i]:\\n\\t\\t\\t\\t\\t\\tque.append(i)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tfor i in range(len(res)):\\n\\t\\t\\t\\tres[i] = sorted(res[i])\\n\\t\\t\\t   \\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2542818,
                "title": "cpp-brute-force-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){\\n             \\n        vis[i]=1;\\n        \\n        for(auto t:ans[i]){\\n            if(!vis[t]){\\n                dfs(t,ansc,ans,vis,res);\\n            }\\n        }\\n       \\n        if(i!=ansc)\\n            res[i].push_back(ansc);\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>ans(n),result(n);\\n        \\n        for(auto a:edges){\\n            ans[a[0]].push_back(a[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int>visited(n);\\n            dfs(i,i,ans,visited,result);\\n        }\\n      \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){\\n             \\n        vis[i]=1;\\n        \\n        for(auto t:ans[i]){\\n            if(!vis[t]){\\n                dfs(t,ansc,ans,vis,res);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2091939,
                "title": "java-solution-using-dfs",
                "content": "Java Solution Using DFS :\\n\\nSteps :\\n\\n1. Create adjList as a directed graph from input matrix .\\n2. Do DFS for each node from 0 --> n\\n3. Here we are considering each node as root/Parent and using DFS we will add this root/Parent into resultList of each nodes where we can reach from this root ( its children and their children ).\\n4. We will use visited[] to identify if any of the child or their children are already visited for that particular root/parent, so to avoid duplicity and call reduction .\\n\\n\\n\\n```\\n\\nclass Solution {\\n    \\n    List<List<Integer>> adjList ;\\n    List<List<Integer>> result ;\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        this.adjList = new ArrayList<>() ;\\n        this.result = new ArrayList<>() ;\\n\\n        for(int i=0 ; i<n ; i++){\\n            adjList.add(new ArrayList<>()) ;\\n            result.add(new ArrayList<>()) ;\\n        }\\n        \\n        for(int i=0 ; i<edges.length ; i++){\\n            int start = edges[i][0] ;\\n            int end = edges[i][1] ;\\n            adjList.get(start).add(end) ;\\n        }\\n        \\n        //  DFS for each node from 0 --> n , and add that node as root/parent into each reachable node and their child\\n        //  Use visited[] to identify if any of the child or their childs are already visited for that perticular root/parent, \\n        //  so will not add the root to avoid duplicacy and call reduction .\\n        \\n        for(int i=0 ; i<n ; i++){            \\n            boolean visited[] = new boolean[n] ;\\n            List<Integer> childList = adjList.get(i);\\n            for(Integer child : childList){\\n                if(!visited[child]){\\n                    dfs( i , child , visited);\\n                }                \\n            }            \\n        }\\n        \\n        return result ;\\n    }\\n    \\n    public void dfs(int root , int node , boolean[] visited){\\n        if(visited[node]){\\n            return ;\\n        }\\n        visited[node] = true ;\\n        result.get(node).add(root) ;\\n        List<Integer> childList = adjList.get(node) ;\\n        for(Integer child : childList){\\n            if(!visited[child]){\\n                dfs( root , child , visited);\\n            }                \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    List<List<Integer>> adjList ;\\n    List<List<Integer>> result ;\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        this.adjList = new ArrayList<>() ;\\n        this.result = new ArrayList<>() ;\\n\\n        for(int i=0 ; i<n ; i++){\\n            adjList.add(new ArrayList<>()) ;\\n            result.add(new ArrayList<>()) ;\\n        }\\n        \\n        for(int i=0 ; i<edges.length ; i++){\\n            int start = edges[i][0] ;\\n            int end = edges[i][1] ;\\n            adjList.get(start).add(end) ;\\n        }\\n        \\n        //  DFS for each node from 0 --> n , and add that node as root/parent into each reachable node and their child\\n        //  Use visited[] to identify if any of the child or their childs are already visited for that perticular root/parent, \\n        //  so will not add the root to avoid duplicacy and call reduction .\\n        \\n        for(int i=0 ; i<n ; i++){            \\n            boolean visited[] = new boolean[n] ;\\n            List<Integer> childList = adjList.get(i);\\n            for(Integer child : childList){\\n                if(!visited[child]){\\n                    dfs( i , child , visited);\\n                }                \\n            }            \\n        }\\n        \\n        return result ;\\n    }\\n    \\n    public void dfs(int root , int node , boolean[] visited){\\n        if(visited[node]){\\n            return ;\\n        }\\n        visited[node] = true ;\\n        result.get(node).add(root) ;\\n        List<Integer> childList = adjList.get(node) ;\\n        for(Integer child : childList){\\n            if(!visited[child]){\\n                dfs( root , child , visited);\\n            }                \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049836,
                "title": "took-me-few-days-to-think-but-never-came-up-with-an-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(unordered_map<int,vector<int>> &mp,vector<bool> &visited, int ancestor){\\n\\t\\t\\tif(visited[ancestor] == true)   return;\\n\\t\\t\\tvisited[ancestor] = true;\\n\\t\\t\\tfor(int i = 0; i<mp[ancestor].size(); i++){\\n\\t\\t\\t\\tif(visited[mp[ancestor][i]] == false){\\n\\t\\t\\t\\t\\tdfs(mp,visited,mp[ancestor][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\t\\t\\tunordered_map<int,vector<int>> mp;\\n\\t\\t\\tfor(int i = 0; i<edges.size(); i++)  mp[edges[i][1]].push_back(edges[i][0]);\\n\\t\\t\\tvector<vector<int>> answer;\\n\\t\\t\\tfor(int i = 0; i<n; i++){\\n\\t\\t\\t\\tvector<bool> visited(n,false);\\n\\t\\t\\t\\tvector<int> temp;\\n\\t\\t\\t\\tdfs(mp,visited,i);\\n\\t\\t\\t\\tfor(int j = 0; j<n; j++){\\n\\t\\t\\t\\t\\tif(visited[j] == true && i!=j)  temp.push_back(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tanswer.push_back(temp);\\n\\t\\t\\t}\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(unordered_map<int,vector<int>> &mp,vector<bool> &visited, int ancestor){\\n\\t\\t\\tif(visited[ancestor] == true)   return;\\n\\t\\t\\tvisited[ancestor] = true;\\n\\t\\t\\tfor(int i = 0; i<mp[ancestor].size(); i++){\\n\\t\\t\\t\\tif(visited[mp[ancestor][i]] == false){\\n\\t\\t\\t\\t\\tdfs(mp,visited,mp[ancestor][i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2008263,
                "title": "c-dfs-simple-easy-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> g(n);\\n        vector<vector<int>>ans(n);\\n        \\n        for(auto &i:edges)\\n        {\\n             g[i[0]].push_back(i[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(g,ans,i, i);\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>> &g,vector<vector<int>> &ans,int src, int anc)\\n    {\\n        for(auto &it : g[src])\\n        {\\n            if(ans[it].size()==0 || ans[it].back()!=anc)\\n            {\\n                ans[it].push_back(anc);\\n                dfs(g,ans,it,anc);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> g(n);\\n        vector<vector<int>>ans(n);\\n        \\n        for(auto &i:edges)\\n        {\\n             g[i[0]].push_back(i[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(g,ans,i, i);\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>> &g,vector<vector<int>> &ans,int src, int anc)\\n    {\\n        for(auto &it : g[src])\\n        {\\n            if(ans[it].size()==0 || ans[it].back()!=anc)\\n            {\\n                ans[it].push_back(anc);\\n                dfs(g,ans,it,anc);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004370,
                "title": "python-topological-traversal-approach-with-notes",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    we can use a bfs based approach to get the required ancestors for each node nodes\\n    nodes with indegree of 0 will have empty ancestors list\\n    then we will put all nodes with no incoming edges in queue\\n    until the queue is empty:\\n        pop the node\\n        for all neighbors of node:\\n            add the ancestor set of node along with the node in the ancestor set of neighbor\\n    \"\"\"\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = {node: set() for node in range(n)}\\n        indegree = {node: 0 for node in range(n)}\\n        ans = [set() for _ in range(n)]\\n        for edge in edges:\\n            graph[edge[0]].add(edge[1])\\n            indegree[edge[1]]+=1\\n        nodes_with_no_incoming_edges = []\\n        for node, indeg in indegree.items():\\n            if indeg == 0:\\n                nodes_with_no_incoming_edges.append(node)\\n        while len(nodes_with_no_incoming_edges):\\n            node = nodes_with_no_incoming_edges.pop()\\n            for neighbor in graph[node]:\\n                ans[neighbor].add(node)\\n                ans[neighbor] = ans[neighbor].union(ans[node])\\n                indegree[neighbor]-=1\\n                if indegree[neighbor] == 0:\\n                    nodes_with_no_incoming_edges.append(neighbor)\\n                    \\n        sorted_ans = []           \\n        for ancestor in ans:\\n            temp = sorted(list(ancestor))\\n            sorted_ans.append(temp)\\n        return sorted_ans\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    we can use a bfs based approach to get the required ancestors for each node nodes\\n    nodes with indegree of 0 will have empty ancestors list\\n    then we will put all nodes with no incoming edges in queue\\n    until the queue is empty:\\n        pop the node\\n        for all neighbors of node:\\n            add the ancestor set of node along with the node in the ancestor set of neighbor\\n    \"\"\"\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = {node: set() for node in range(n)}\\n        indegree = {node: 0 for node in range(n)}\\n        ans = [set() for _ in range(n)]\\n        for edge in edges:\\n            graph[edge[0]].add(edge[1])\\n            indegree[edge[1]]+=1\\n        nodes_with_no_incoming_edges = []\\n        for node, indeg in indegree.items():\\n            if indeg == 0:\\n                nodes_with_no_incoming_edges.append(node)\\n        while len(nodes_with_no_incoming_edges):\\n            node = nodes_with_no_incoming_edges.pop()\\n            for neighbor in graph[node]:\\n                ans[neighbor].add(node)\\n                ans[neighbor] = ans[neighbor].union(ans[node])\\n                indegree[neighbor]-=1\\n                if indegree[neighbor] == 0:\\n                    nodes_with_no_incoming_edges.append(neighbor)\\n                    \\n        sorted_ans = []           \\n        for ancestor in ans:\\n            temp = sorted(list(ancestor))\\n            sorted_ans.append(temp)\\n        return sorted_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995245,
                "title": "java-simple-dfs-w-brief-explanation-beat-100",
                "content": "```\\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n\\t\\t// Build directed graph\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int[] e : edges) {\\n            if (graph[e[0]] == null) \\n                graph[e[0]] = new ArrayList<>();\\n            graph[e[0]].add(e[1]);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) \\n            res.add(new ArrayList<>());\\n        \\n\\t\\t// Since the list of ancestors should be sorted in ascending order, we iterator from node 0 to node n - 1\\n\\t\\t// Use DFS to find the nodes that node i can reach\\n        for (int i = 0; i < n; i++) {\\n            if (graph[i] == null) continue;\\n\\t\\t\\t// We need to check whether we visited the node before\\n\\t\\t\\t// Example: 0 -> 3 -> 6, 0 -> 4 -> 6, if we DFS from node 0, we may visite node 6 twice\\n            boolean[] visited = new boolean[n];\\n\\t\\t\\t// We do one step of DFS here since node i is not the ancestor of itself.\\n\\t\\t\\t// Then in the following steps of DFS, we add node i to the node next\\'s ancestor\\n            for (int next : graph[i]) {\\n                if (visited[next]) continue;\\n                visited[next] = true;\\n                dfs(i, next, graph, res, visited);\\n            }\\n        }\\n        return res;\\n    }\\n    private void dfs(int ancestor, int node, List<Integer>[] graph, List<List<Integer>> res, boolean[] visited) {\\n        res.get(node).add(ancestor);\\n        if (graph[node] == null) return;\\n        for (int next : graph[node]) {\\n            if (visited[next]) continue;\\n            visited[next] = true;\\n            dfs(ancestor, next, graph, res, visited);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n\\t\\t// Build directed graph\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int[] e : edges) {\\n            if (graph[e[0]] == null) \\n                graph[e[0]] = new ArrayList<>();\\n            graph[e[0]].add(e[1]);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) \\n            res.add(new ArrayList<>());\\n        \\n\\t\\t// Since the list of ancestors should be sorted in ascending order, we iterator from node 0 to node n - 1\\n\\t\\t// Use DFS to find the nodes that node i can reach\\n        for (int i = 0; i < n; i++) {\\n            if (graph[i] == null) continue;\\n\\t\\t\\t// We need to check whether we visited the node before\\n\\t\\t\\t// Example: 0 -> 3 -> 6, 0 -> 4 -> 6, if we DFS from node 0, we may visite node 6 twice\\n            boolean[] visited = new boolean[n];\\n\\t\\t\\t// We do one step of DFS here since node i is not the ancestor of itself.\\n\\t\\t\\t// Then in the following steps of DFS, we add node i to the node next\\'s ancestor\\n            for (int next : graph[i]) {\\n                if (visited[next]) continue;\\n                visited[next] = true;\\n                dfs(i, next, graph, res, visited);\\n            }\\n        }\\n        return res;\\n    }\\n    private void dfs(int ancestor, int node, List<Integer>[] graph, List<List<Integer>> res, boolean[] visited) {\\n        res.get(node).add(ancestor);\\n        if (graph[node] == null) return;\\n        for (int next : graph[node]) {\\n            if (visited[next]) continue;\\n            visited[next] = true;\\n            dfs(ancestor, next, graph, res, visited);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1880771,
                "title": "topological-dfs-easy-and-commented-with-dry-run-explanation",
                "content": "## Approach:\\n\\t1. \\tIn this apprach,we will not update answer list while doing DFS at each node (this approach was taking more time and hence threw TLE).\\n\\t2. \\tIn this approach, we will instead iterate over all nodes. In each iteration, we will update that node as ancestor to all of the nodes it is connected directly or indirectly (via DFS).\\n\\t3. \\tSee below dry-run to understand the approach more easily.  \\n\\n## Dry Run\\n\\tIt was bit hard to draw everything in the limited space, but did my best. Let me know if anything is unclear or need any explanation. \\n\\tJust follow the steps from a) to y) \\n![image](https://assets.leetcode.com/users/images/c7fc01e3-5893-49de-83aa-672e4bce707e_1648155240.6652746.png)\\n![image](https://assets.leetcode.com/users/images/acc5bf7a-065c-491a-b775-a6fab62fe86b_1648155335.1324124.png)\\n\\n**Zoomed bottom portion**\\n![image](https://assets.leetcode.com/users/images/8626bd6f-1337-4ee6-aa46-34a1d5f40c2e_1648155407.7836995.png)\\n\\n\\n\\n\\n\\n\\tBelow is how the answer will keep getting updated in each iteration:\\n\\t--------------------\\n\\ti: 0 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0]\\n\\t4, [0]\\n\\t5, [0]\\n\\t6, [0]\\n\\t7, [0]\\n\\t--------------------\\n\\ti: 1 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0]\\n\\t5, [0, 1]\\n\\t6, [0, 1]\\n\\t7, [0, 1]\\n\\t--------------------\\n\\ti: 2 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1]\\n\\t6, [0, 1, 2]\\n\\t7, [0, 1, 2]\\n\\t--------------------\\n\\ti: 3 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3]\\n\\t7, [0, 1, 2, 3]\\n\\t--------------------\\n\\ti: 4 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3, 4]\\n\\t7, [0, 1, 2, 3]\\n\\t--------------------\\n\\ti: 5 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3, 4]\\n\\t7, [0, 1, 2, 3]\\n\\t--------------------\\n\\ti: 6 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3, 4]\\n\\t7, [0, 1, 2, 3]\\n\\t--------------------\\n\\ti: 7 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3, 4]\\n\\t7, [0, 1, 2, 3]\\n\\n\\n\\n## Code\\n\\n\\tclass Solution {\\n\\t\\tpublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n\\t\\t\\tList<List<Integer>> adjList = new ArrayList<>();                                  \\n\\t\\t\\tList<List<Integer>> answer  = new ArrayList<>();                                   \\n\\n\\t\\t\\tinitialize(answer, adjList, n);                                                    // initialize answer and adjList lists with empty list. \\n\\t\\t\\tfillAdjList(adjList, edges, n);                                                    // fill adjacency list\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tint ancestor = i;\\n\\t\\t\\t\\tdfs(ancestor, i, adjList, answer);                                            // call DFS\\n\\t\\t\\t}\\n\\t\\t\\treturn answer;\\n\\t\\t}    \\n\\n\\t\\tpublic void dfs(int ancestor, int src, List<List<Integer>> adjList, List<List<Integer>> answer){                // DFS method\\n\\t\\t\\tList<Integer> ancestorList = answer.get(src);\\n\\t\\t\\tif(ancestorList.isEmpty() || ancestorList.get( ancestorList.size() -1 ) != ancestor){         \\n\\t\\t\\t\\tif(ancestor != src){ ancestorList.add(ancestor); }                           // add ancestor to ancestor list, if only ancestor list is either empty, or does not already contain ancestor node.\\n\\t\\t\\t\\tfor(int dest : adjList.get(src)){\\n\\t\\t\\t\\t\\tdfs(ancestor, dest, adjList, answer);                                    // for each connected edge, do DFS recursion\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void initialize(List<List<Integer>> answer, List<List<Integer>> adjList, int n){\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tanswer.add(new ArrayList<>());\\n\\t\\t\\t\\tadjList.add(new ArrayList<>());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void fillAdjList(List<List<Integer>> adjList, int[][] edges, int n){\\n\\t\\t\\tfor(int[] edge : edges){\\n\\t\\t\\t\\tadjList.get(edge[0]).add(edge[1]);    \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n\\t\\t\\tList<List<Integer>> adjList = new ArrayList<>();                                  \\n\\t\\t\\tList<List<Integer>> answer  = new ArrayList<>();                                   \\n\\n\\t\\t\\tinitialize(answer, adjList, n);                                                    // initialize answer and adjList lists with empty list. \\n\\t\\t\\tfillAdjList(adjList, edges, n);                                                    // fill adjacency list\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tint ancestor = i;\\n\\t\\t\\t\\tdfs(ancestor, i, adjList, answer);                                            // call DFS\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1833569,
                "title": "python-short-easy-dfs",
                "content": "First create the mapping between each node and its direct parent.\\nThen for each node do depth first to gather all of its parents (removing duplicates with set)\\n```\\nclass Solution:\\n    def getAncestors(self, n, edges):\\n        ancestors = defaultdict(list)\\n        for a, b in edges:\\n            ancestors[b].append(a)\\n        \\n        @lru_cache(None)\\n        def dfs(i):\\n            res = set(ancestors[i])\\n            for x in ancestors[i]:\\n                res |= dfs(x)\\n            return res\\n        return [sorted(dfs(i)) for i in range(n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n, edges):\\n        ancestors = defaultdict(list)\\n        for a, b in edges:\\n            ancestors[b].append(a)\\n        \\n        @lru_cache(None)\\n        def dfs(i):\\n            res = set(ancestors[i])\\n            for x in ancestors[i]:\\n                res |= dfs(x)\\n            return res\\n        return [sorted(dfs(i)) for i in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828049,
                "title": "c-easy-topological-sorting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int,set<int>>mp;\\n        vector<int>adj[n+1];\\n        vector<int>indeg(n+1,0);\\n        for(auto xt : edges)\\n        {\\n            adj[xt[0]].push_back(xt[1]);\\n            indeg[xt[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int parent = q.front();q.pop();\\n            for(auto child : adj[parent])\\n            {\\n                mp[child].insert(parent);\\n                \\n                for(auto xt : mp[parent])\\n                {\\n                    mp[child].insert(xt);\\n                }\\n                if(--indeg[child]==0)\\n                {\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            {\\n                ans.push_back({});\\n            }\\n            else\\n            {\\n                vector<int> nodes(mp[i].begin(),mp[i].end());\\n                ans.push_back(nodes);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int,set<int>>mp;\\n        vector<int>adj[n+1];\\n        vector<int>indeg(n+1,0);\\n        for(auto xt : edges)\\n        {\\n            adj[xt[0]].push_back(xt[1]);\\n            indeg[xt[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int parent = q.front();q.pop();\\n            for(auto child : adj[parent])\\n            {\\n                mp[child].insert(parent);\\n                \\n                for(auto xt : mp[parent])\\n                {\\n                    mp[child].insert(xt);\\n                }\\n                if(--indeg[child]==0)\\n                {\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            {\\n                ans.push_back({});\\n            }\\n            else\\n            {\\n                vector<int> nodes(mp[i].begin(),mp[i].end());\\n                ans.push_back(nodes);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822646,
                "title": "javascript-bfs-dfs-topogical-sort",
                "content": "bfs: 588ms (recommend)\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); } };\\n\\nconst getAncestors = (n, edges) => {\\n    let g = initializeGraph(n), res = initializeGraph(n);\\n    packDG(g, edges);\\n    for (let i = 0; i < n; i++) { // start from i parent\\n        let q = [i], visit = new Set([i]);\\n        while (q.length) {\\n            let cur = q.shift();\\n            if (cur != i) res[cur].push(i); // each time set ancestor for current node, ignore parent itself\\n            for (const child of g[cur]) {\\n                if (visit.has(child)) continue;\\n                visit.add(child);\\n                q.push(child);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```\\ntopogical sort 706ms  (recommend)\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGInDegree = (g, edges, indegree) => { for (const [u, v] of edges) { g[u].push(v); indegree[v]++; } };\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet res;\\nconst getAncestors = (n, edges) => {\\n    let g = initializeGraph(n), indegree = Array(n).fill(0); // record depth of nodes\\n    res = initializeGraphSet(n);\\n    packDGInDegree(g, edges, indegree);\\n    topologicalSort(g, indegree);\\n    return res.map(se => [...se].sort((x, y) => x - y)); // convert inside set to sorted array\\n};\\n\\nconst topologicalSort = (g, indegree) => {\\n    let q = [], n = g.length;\\n    for (let i = 0; i < n; i++) {\\n        if (indegree[i] == 0) q.push(i); // set starting node/top parent/root of depth 0\\n    }\\n    while (q.length) {\\n        let cur = q.shift();\\n        for (const child of g[cur]) { // cur -> child\\n            if (--indegree[child] == 0) q.push(child);\\n            res[child].add(cur); // cur is parent, set ancestor for each child\\n            for (const ancestor of res[cur]) res[child].add(ancestor); // remember to add parent\\'s parents to child\\n        }\\n    }\\n};\\n```\\ndfs: 468ms\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGParent = (g, edges) => { for (const [u, v] of edges) { g[v].push(u); } };\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet g;\\nconst getAncestors = (n, edges) => {\\n    g = initializeGraph(n);\\n    packDGParent(g, edges);\\n    let res = initializeGraphSet(n), visit = Array(n).fill(false);\\n    for (let i = 0; i < n; i++) {\\n        if (!visit[i]) dfs(i, visit, res);\\n    }\\n    return res.map(se => [...se].sort((x, y) => x - y));\\n};\\n\\nconst dfs = (cur, visit, res) => {\\n    visit[cur] = true;\\n    for (const child of g[cur]) {\\n        if (!visit[child]) dfs(child, visit, res);\\n        res[cur].add(child);\\n        for (const ancestor of res[child]) res[cur].add(ancestor);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); } };\\n\\nconst getAncestors = (n, edges) => {\\n    let g = initializeGraph(n), res = initializeGraph(n);\\n    packDG(g, edges);\\n    for (let i = 0; i < n; i++) { // start from i parent\\n        let q = [i], visit = new Set([i]);\\n        while (q.length) {\\n            let cur = q.shift();\\n            if (cur != i) res[cur].push(i); // each time set ancestor for current node, ignore parent itself\\n            for (const child of g[cur]) {\\n                if (visit.has(child)) continue;\\n                visit.add(child);\\n                q.push(child);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGInDegree = (g, edges, indegree) => { for (const [u, v] of edges) { g[u].push(v); indegree[v]++; } };\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet res;\\nconst getAncestors = (n, edges) => {\\n    let g = initializeGraph(n), indegree = Array(n).fill(0); // record depth of nodes\\n    res = initializeGraphSet(n);\\n    packDGInDegree(g, edges, indegree);\\n    topologicalSort(g, indegree);\\n    return res.map(se => [...se].sort((x, y) => x - y)); // convert inside set to sorted array\\n};\\n\\nconst topologicalSort = (g, indegree) => {\\n    let q = [], n = g.length;\\n    for (let i = 0; i < n; i++) {\\n        if (indegree[i] == 0) q.push(i); // set starting node/top parent/root of depth 0\\n    }\\n    while (q.length) {\\n        let cur = q.shift();\\n        for (const child of g[cur]) { // cur -> child\\n            if (--indegree[child] == 0) q.push(child);\\n            res[child].add(cur); // cur is parent, set ancestor for each child\\n            for (const ancestor of res[cur]) res[child].add(ancestor); // remember to add parent\\'s parents to child\\n        }\\n    }\\n};\\n```\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGParent = (g, edges) => { for (const [u, v] of edges) { g[v].push(u); } };\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet g;\\nconst getAncestors = (n, edges) => {\\n    g = initializeGraph(n);\\n    packDGParent(g, edges);\\n    let res = initializeGraphSet(n), visit = Array(n).fill(false);\\n    for (let i = 0; i < n; i++) {\\n        if (!visit[i]) dfs(i, visit, res);\\n    }\\n    return res.map(se => [...se].sort((x, y) => x - y));\\n};\\n\\nconst dfs = (cur, visit, res) => {\\n    visit[cur] = true;\\n    for (const child of g[cur]) {\\n        if (!visit[child]) dfs(child, visit, res);\\n        res[cur].add(child);\\n        for (const ancestor of res[child]) res[cur].add(ancestor);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822601,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    const arr = Array(n).fill(1).map(el => new Set());\\n    const seen = new Set();\\n    const egs = [];\\n    \\n    for(const [from, to] of edges)\\xA0{\\n        if(egs[from]) egs[from].push(to)\\n        else egs[from] = [to]\\n    }\\n\\n    const dfs = (curr, by) => {\\n        if(curr != by) {\\n            arr[curr].add(by);\\n        }\\n        if(seen.has(curr)) return;\\n        if(!egs[curr]) return;\\n        seen.add(curr)\\n        for(const dest of egs[curr]) {\\n            dfs(dest, by);\\n        }\\n    }\\n    for(let i = 0; i < n; i++) {\\n        dfs(i, i);\\n        seen.clear();\\n    }\\n    \\n    return arr.map(set => {\\n        return Array.from(set);\\n    })\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    const arr = Array(n).fill(1).map(el => new Set());\\n    const seen = new Set();\\n    const egs = [];\\n    \\n    for(const [from, to] of edges)\\xA0{\\n        if(egs[from]) egs[from].push(to)\\n        else egs[from] = [to]\\n    }\\n\\n    const dfs = (curr, by) => {\\n        if(curr != by) {\\n            arr[curr].add(by);\\n        }\\n        if(seen.has(curr)) return;\\n        if(!egs[curr]) return;\\n        seen.add(curr)\\n        for(const dest of egs[curr]) {\\n            dfs(dest, by);\\n        }\\n    }\\n    for(let i = 0; i < n; i++) {\\n        dfs(i, i);\\n        seen.clear();\\n    }\\n    \\n    return arr.map(set => {\\n        return Array.from(set);\\n    })\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822562,
                "title": "java-dfs-simple-explanation",
                "content": "```\\n/*\\n\\n    First parameter of the dfs is going to fill itself as the ansester of all the \\n    nodes it can traverse in one dfs call\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        ArrayList<Integer>[] graph = new ArrayList[n], res = new ArrayList[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            res[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            boolean[] visited = new boolean[n];\\n            dfs(i, i, graph, visited, res);\\n        }\\n        List<List<Integer>> answer = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            answer.add(res[i]);\\n        }\\n        return answer;\\n    }\\n    \\n    //          originalSource, neighbour, graph, visited\\n    public void dfs(int osrc, int next, ArrayList<Integer>[] graph, boolean[] visited,\\n                   ArrayList<Integer>[] res) {\\n        visited[next] = true;\\n        for (int nbr : graph[next]) {\\n            if (!visited[nbr]) {\\n                res[nbr].add(osrc);\\n                dfs(osrc, nbr, graph, visited, res);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        ArrayList<Integer>[] graph = new ArrayList[n], res = new ArrayList[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1822415,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void dfs(vector<int>g[], vector<bool>& vis, int node){\\n        if(vis[node]==true) return;\\n        vis[node] = true;\\n        for(auto x:g[node]){\\n            if(vis[x]==false){\\n                dfs(g, vis, x);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>g[n];\\n        for(auto x:edges){\\n            g[x[1]].push_back(x[0]);\\n        }\\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n, false);\\n            dfs(g, vis, i);\\n            vector<int>v;\\n            for(int j=0;j<n;j++){\\n                if(vis[j]==true and j!=i){\\n                    v.push_back(j);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(vector<int>g[], vector<bool>& vis, int node){\\n        if(vis[node]==true) return;\\n        vis[node] = true;\\n        for(auto x:g[node]){\\n            if(vis[x]==false){\\n                dfs(g, vis, x);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1822330,
                "title": "python3-dfs-on-transposed-graph-help-from-hint-medium",
                "content": "* First tried Kahn\\'s (twice queue traversal) but failed to implement. \\n* Took help from the given hint and coded. Hope It is good.\\n* Please suggest if any improvements/advise. (PS : Started giving contest now to improve my time management)\\n\\n\\n\\t\\t\\tg = defaultdict(list)\\n\\t\\t\\tfor u, v in edges:\\n\\t\\t\\t\\tg[v].append(u)               #reversing the edges in adjacency list\\n\\n\\t\\t\\tdef dfs(node, root):\\n\\t\\t\\t\\tvis[node] = 1\\n\\t\\t\\t\\tfor k in g[node]:\\n\\t\\t\\t\\t\\tif vis[k]==0:\\n\\t\\t\\t\\t\\t\\tans[root].add(k)\\n\\t\\t\\t\\t\\t\\tdfs(k, root)\\n\\n\\t\\t\\tans = [set() for _ in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tvis=[0]*n\\n\\t\\t\\t\\tdfs(i, i)\\n\\t\\t\\treturn [sorted(row) for row in ans]",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "* First tried Kahn\\'s (twice queue traversal) but failed to implement. \\n* Took help from the given hint and coded. Hope It is good.\\n* Please suggest if any improvements/advise. (PS : Started giving contest now to improve my time management)\\n\\n\\n\\t\\t\\tg = defaultdict(list)\\n\\t\\t\\tfor u, v in edges:\\n\\t\\t\\t\\tg[v].append(u)               #reversing the edges in adjacency list\\n\\n\\t\\t\\tdef dfs(node, root):\\n\\t\\t\\t\\tvis[node] = 1\\n\\t\\t\\t\\tfor k in g[node]:\\n\\t\\t\\t\\t\\tif vis[k]==0:\\n\\t\\t\\t\\t\\t\\tans[root].add(k)\\n\\t\\t\\t\\t\\t\\tdfs(k, root)\\n\\n\\t\\t\\tans = [set() for _ in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tvis=[0]*n\\n\\t\\t\\t\\tdfs(i, i)\\n\\t\\t\\treturn [sorted(row) for row in ans]",
                "codeTag": "Python3"
            },
            {
                "id": 1822186,
                "title": "java-reverse-the-graph",
                "content": "**Explanation**\\n\\nIn this approach, we reverse the graph where direction between two node pairs are reversed. Originally if 3 was directing towards 4 then we build a graph where 4 will be directing towards 3. And the same goes for each and every node pair. Now all our ancestors turn into descendants who can be easily recovered using simple Depth First Search.\\n\\n**Time complexity :**   O(n^2 log n)\\n\\n```\\nclass Solution {\\n    \\n    List<List<Integer>> output = new ArrayList<>();\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<Integer> [] graph = new ArrayList[n];\\n        \\n        for(int i=0;i<n;++i) {\\n            \\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        for(int [] edge : edges) {\\n        \\n            graph[edge[1]].add(edge[0]);\\n        }\\n        \\n        for(int i=0;i<n;++i) {\\n            \\n            List<Integer> ans = new ArrayList<>();\\n            \\n            dfs(graph,i,new boolean[n],ans);\\n            \\n            Collections.sort(ans);  \\n            output.add(ans);\\n        }\\n        \\n        return output;\\n    }\\n       \\n    public void dfs(List<Integer> [] graph, int vertex, boolean [] visit, List<Integer> ans) {\\n        \\n        for(int curr : graph[vertex]) {\\n            \\n            if(visit[curr]) continue;\\n            \\n            ans.add(curr);\\n            visit[curr] = true;\\n            dfs(graph,curr,visit,ans);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<List<Integer>> output = new ArrayList<>();\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<Integer> [] graph = new ArrayList[n];\\n        \\n        for(int i=0;i<n;++i) {\\n            \\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        for(int [] edge : edges) {\\n        \\n            graph[edge[1]].add(edge[0]);\\n        }\\n        \\n        for(int i=0;i<n;++i) {\\n            \\n            List<Integer> ans = new ArrayList<>();\\n            \\n            dfs(graph,i,new boolean[n],ans);\\n            \\n            Collections.sort(ans);  \\n            output.add(ans);\\n        }\\n        \\n        return output;\\n    }\\n       \\n    public void dfs(List<Integer> [] graph, int vertex, boolean [] visit, List<Integer> ans) {\\n        \\n        for(int curr : graph[vertex]) {\\n            \\n            if(visit[curr]) continue;\\n            \\n            ans.add(curr);\\n            visit[curr] = true;\\n            dfs(graph,curr,visit,ans);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822164,
                "title": "swift-topological-sort",
                "content": "This is a classical Topolical sort problem. \\n* Build `graph` from `edges`\\n* Start with all nodes `u` which don\\'t have any incoming edges\\n* Visit all children of node `u`, for each child `v`, insert `u` as well as `ancestors[u]` as ancestors of `v`. We need to use `Set` to avoid any duplication\\n* Repeat until we\\'ve already processed all nodes \\n* Go over each node and sort the list of ancestors as per the problem statement\\n\\n**Swift**\\n```swift\\nclass Solution {\\n  func getAncestors(_ n: Int, _ edges: [[Int]]) -> [[Int]] {\\n    var graph = [Int: [Int]]()\\n    var inDegree = Array(repeating: 0, count: n)\\n    for edge in edges {\\n      let (u, v) = (edge[0], edge[1])\\n      graph[u, default: []].append(v)\\n      inDegree[v] += 1\\n    }\\n    \\n    var ancestors = Array(repeating: Set<Int>(), count: n)\\n    var stack = [Int]()\\n    for u in 0..<n where inDegree[u] == 0 {\\n      stack.append(u)\\n    }\\n    \\n    while !stack.isEmpty {\\n      let u = stack.removeLast()\\n      for v in graph[u, default: []] {\\n        inDegree[v] -= 1 \\n        if inDegree[v] == 0 {\\n          stack.append(v)\\n        }\\n          \\n        ancestors[v].insert(u)\\n        ancestors[v].formUnion(ancestors[u])\\n      }\\n    }\\n    \\n    var res = [[Int]]()\\n    for u in 0..<n {\\n      res.append(ancestors[u].sorted())\\n    }\\n    \\n    return res\\n  }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```swift\\nclass Solution {\\n  func getAncestors(_ n: Int, _ edges: [[Int]]) -> [[Int]] {\\n    var graph = [Int: [Int]]()\\n    var inDegree = Array(repeating: 0, count: n)\\n    for edge in edges {\\n      let (u, v) = (edge[0], edge[1])\\n      graph[u, default: []].append(v)\\n      inDegree[v] += 1\\n    }\\n    \\n    var ancestors = Array(repeating: Set<Int>(), count: n)\\n    var stack = [Int]()\\n    for u in 0..<n where inDegree[u] == 0 {\\n      stack.append(u)\\n    }\\n    \\n    while !stack.isEmpty {\\n      let u = stack.removeLast()\\n      for v in graph[u, default: []] {\\n        inDegree[v] -= 1 \\n        if inDegree[v] == 0 {\\n          stack.append(v)\\n        }\\n          \\n        ancestors[v].insert(u)\\n        ancestors[v].formUnion(ancestors[u])\\n      }\\n    }\\n    \\n    var res = [[Int]]()\\n    for u in 0..<n {\\n      res.append(ancestors[u].sorted())\\n    }\\n    \\n    return res\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822134,
                "title": "all-ancestors-of-a-node-in-dag-c-bfs-topological-sorting-simple-clean-code",
                "content": "```\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<int> indegree(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto u : adj[i])\\n            {\\n                indegree[u]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        vector<unordered_set<int>> ump(n);\\n        \\n        while(!q.empty())\\n        {\\n            int  i = q.front();\\n            \\n            for(auto u : adj[i])\\n            {\\n                ump[u].insert(i);\\n                \\n                for(auto v : ump[i])\\n                {\\n                    ump[u].insert(v);\\n                }\\n                \\n                \\n                \\n                indegree[u]--;\\n                \\n                if(indegree[u] == 0)\\n                {\\n                    q.push(u);\\n                }\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        vector<vector<int>> res;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            \\n            for(auto v : ump[i])\\n            {\\n                temp.push_back(v);\\n            }\\n            \\n            sort(temp.begin(), temp.end());\\n            \\n            res.push_back(temp);\\n        }\\n        \\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Ordered Set"
                ],
                "code": "```\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<int> indegree(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto u : adj[i])\\n            {\\n                indegree[u]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        vector<unordered_set<int>> ump(n);\\n        \\n        while(!q.empty())\\n        {\\n            int  i = q.front();\\n            \\n            for(auto u : adj[i])\\n            {\\n                ump[u].insert(i);\\n                \\n                for(auto v : ump[i])\\n                {\\n                    ump[u].insert(v);\\n                }\\n                \\n                \\n                \\n                indegree[u]--;\\n                \\n                if(indegree[u] == 0)\\n                {\\n                    q.push(u);\\n                }\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        vector<vector<int>> res;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            \\n            for(auto v : ump[i])\\n            {\\n                temp.push_back(v);\\n            }\\n            \\n            sort(temp.begin(), temp.end());\\n            \\n            res.push_back(temp);\\n        }\\n        \\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822020,
                "title": "dfs-memorization-c-complexity-analysis",
                "content": "## Solution\\n\\n#### Logic\\n\\nParent -> Child (TLE)\\nChild -> Parent (Accepted)\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, set<int>> me;\\n    set<int> dfs(map<int, vector<int>> &graph, int start) {\\n        if (me.find(start) != me.end()) {\\n            return me[start];\\n        }\\n        set<int> parents;\\n        for (int i = 0; i < graph[start].size(); i++) {\\n            set<int> temp;\\n            parents.insert(graph[start][i]);\\n            temp = dfs(graph, graph[start][i]);\\n            for (auto x : temp) {\\n                parents.insert(x);\\n            }\\n        }\\n        me[start] = parents;\\n        return parents;\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int, vector<int>> graph;\\n        vector<vector<int>> sol;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            set<int> temp = dfs(graph, i);\\n            sol.push_back({temp.begin(), temp.end()});\\n        }\\n        \\n        \\n        return sol;\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n __Time Complexity__: O(total_edges * total_edges), because we are using Depth first search. Actully it will be less as we are also using memorization.\\n \\n __Space Complexity__: O(total_edges * total_edges), becuase we are storing solution to return them also we are making graph in inverted manner so that will also add O(total_edges * total_edges). So 2 * O(total_edges * total_edges) = O(total_edges * total_edges)\\n\\n<br>\\n<br>\\n<br>\\n\\n<p>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n</p>\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, set<int>> me;\\n    set<int> dfs(map<int, vector<int>> &graph, int start) {\\n        if (me.find(start) != me.end()) {\\n            return me[start];\\n        }\\n        set<int> parents;\\n        for (int i = 0; i < graph[start].size(); i++) {\\n            set<int> temp;\\n            parents.insert(graph[start][i]);\\n            temp = dfs(graph, graph[start][i]);\\n            for (auto x : temp) {\\n                parents.insert(x);\\n            }\\n        }\\n        me[start] = parents;\\n        return parents;\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int, vector<int>> graph;\\n        vector<vector<int>> sol;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            set<int> temp = dfs(graph, i);\\n            sol.push_back({temp.begin(), temp.end()});\\n        }\\n        \\n        \\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989518,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- O(N*N)\\n\\n- Space complexity:\\n- O(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>mp;\\n    void fill(vector<vector<int>>& edges){\\n        for(auto i:edges){\\n            int u=i[0],v=i[1];\\n            mp[v].push_back(u);\\n        }\\n        return;\\n    }\\n    void dfs(int node,vector<bool>&vis,set<int>&ans){\\n        int kk=node;\\n        if(mp.find(node)==mp.end()){\\n            ans.insert(node);\\n            return;\\n        }\\n        vis[node]=true;\\n        ans.insert(node);\\n\\n        for(auto i:mp[node]){\\n            if(!vis[i]) dfs(i,vis,ans);\\n        }\\n        return;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        mp.clear();\\n        fill(edges);\\n        \\n        vector<vector<int>>ans;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp.find(i)==mp.end()){\\n                ans.push_back({});\\n                continue;\\n            }\\n            vector<bool>vis(n+1,false);\\n            set<int>res;\\n\\n            dfs(i,vis,res);\\n\\n            if(res.find(i)!=res.end()) res.erase(i);\\n\\n            vector<int>temp(res.begin(),res.end());\\n            \\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>mp;\\n    void fill(vector<vector<int>>& edges){\\n        for(auto i:edges){\\n            int u=i[0],v=i[1];\\n            mp[v].push_back(u);\\n        }\\n        return;\\n    }\\n    void dfs(int node,vector<bool>&vis,set<int>&ans){\\n        int kk=node;\\n        if(mp.find(node)==mp.end()){\\n            ans.insert(node);\\n            return;\\n        }\\n        vis[node]=true;\\n        ans.insert(node);\\n\\n        for(auto i:mp[node]){\\n            if(!vis[i]) dfs(i,vis,ans);\\n        }\\n        return;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        mp.clear();\\n        fill(edges);\\n        \\n        vector<vector<int>>ans;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp.find(i)==mp.end()){\\n                ans.push_back({});\\n                continue;\\n            }\\n            vector<bool>vis(n+1,false);\\n            set<int>res;\\n\\n            dfs(i,vis,res);\\n\\n            if(res.find(i)!=res.end()) res.erase(i);\\n\\n            vector<int>temp(res.begin(),res.end());\\n            \\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775408,
                "title": "python-simple-bfs-solution-with-explanation-o-v-e",
                "content": "# Intuition\\nThis is a topoligical sort problem. Here we use the famous Kahn\\'s algo. \\n\\n# Approach\\n1) Like most of the graphs problem first we create and adjacency map and in_degree dictionary.\\n2) Then we create a queue and add the nodes with no parent (in_degree[node]==0 or node not in_degree), we add that to the queue.\\n3) We create a list of sets, which set_i contains the ancestors for node i\\n4) we run a BFS to reduce the in_degree of each node we visit and once the the degree is zero we add that to the queue. Also, at each step, we update the set_i. \\n\\n# Complexity\\n- Time complexity: O(V+E)\\n\\n- Space complexity: O(V+E) not including the space we need for the output. \\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj_map = defaultdict(defaultdict)\\n        in_degree = defaultdict(int)\\n        for beg, end in edges:\\n            adj_map[beg][end]=None\\n            in_degree[end]+=1\\n\\n        q = deque()\\n        for node in range(n):\\n            if node not in in_degree:\\n                q.append(node)\\n\\n        ans = [set() for _ in range(n)]\\n        while q:\\n            node = q.popleft()\\n            for child in adj_map[node]:\\n                in_degree[child]-=1\\n                if in_degree[child]==0:\\n                    q.append(child)\\n                ans[child].update(ans[node] | {node})\\n        return [sorted(list(i)) for i in ans]\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj_map = defaultdict(defaultdict)\\n        in_degree = defaultdict(int)\\n        for beg, end in edges:\\n            adj_map[beg][end]=None\\n            in_degree[end]+=1\\n\\n        q = deque()\\n        for node in range(n):\\n            if node not in in_degree:\\n                q.append(node)\\n\\n        ans = [set() for _ in range(n)]\\n        while q:\\n            node = q.popleft()\\n            for child in adj_map[node]:\\n                in_degree[child]-=1\\n                if in_degree[child]==0:\\n                    q.append(child)\\n                ans[child].update(ans[node] | {node})\\n        return [sorted(list(i)) for i in ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736211,
                "title": "dfs-using-hashset-and-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDepth First Search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReverse the graph and check its adjacency list. If it\\'s not visited apply recursion on that (adjnode) and append it the set of the current call. If it is visited find its corresponding set in the map and append it to the set of the current call.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(V+E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(V+E)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,set<int>> m ;\\n\\n    set<int> dfs(int node,vector<vector<int>> &adj,vector<int>&visited){\\n        \\n        set<int> s;\\n        visited[node]=1;\\n       \\n        s.insert(node);\\n\\n        for(auto adjnode : adj[node]){\\n            if (!visited[adjnode]){\\n                set<int> back = dfs(adjnode,adj,visited);\\n                s.insert(back.begin(),back.end());\\n            }\\n            else{\\n                set<int> vis = m[adjnode];\\n                s.insert(vis.begin(),vis.end());\\n            }\\n        }\\n        m[node]=s;\\n        return s;\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n         vector<vector<int>> adj(n);\\n\\n         for (auto i : edges){\\n             adj[i[1]].push_back(i[0]);\\n         }\\n\\n         vector<vector<int>> ans;\\n\\n         vector<int>visited(n,0);\\n\\n        for(int i  = 0 ;  i <n ; i++){\\n            if (!visited[i]){\\n                dfs(i,adj,visited);\\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i++){\\n            vector<int> temp;\\n            for(int k : m[i]){\\n               if ( k!=i) \\n                temp.push_back(k);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,set<int>> m ;\\n\\n    set<int> dfs(int node,vector<vector<int>> &adj,vector<int>&visited){\\n        \\n        set<int> s;\\n        visited[node]=1;\\n       \\n        s.insert(node);\\n\\n        for(auto adjnode : adj[node]){\\n            if (!visited[adjnode]){\\n                set<int> back = dfs(adjnode,adj,visited);\\n                s.insert(back.begin(),back.end());\\n            }\\n            else{\\n                set<int> vis = m[adjnode];\\n                s.insert(vis.begin(),vis.end());\\n            }\\n        }\\n        m[node]=s;\\n        return s;\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n         vector<vector<int>> adj(n);\\n\\n         for (auto i : edges){\\n             adj[i[1]].push_back(i[0]);\\n         }\\n\\n         vector<vector<int>> ans;\\n\\n         vector<int>visited(n,0);\\n\\n        for(int i  = 0 ;  i <n ; i++){\\n            if (!visited[i]){\\n                dfs(i,adj,visited);\\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i++){\\n            vector<int> temp;\\n            for(int k : m[i]){\\n               if ( k!=i) \\n                temp.push_back(k);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669965,
                "title": "javascript-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n...\\nvariable names\\n...\\n**p = parent\\nps = parent set\\naps = array of parent set\\ngp = grand parent**\\n\\n...\\nalgorithm\\n...\\n**1 create parents\\n2 add grand parents to parents\\n3 sort & return\\n...**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar getAncestors = function (n, ed) {\\n  let aps = Array(n).fill().map(() => new Set())\\n  for (let [u, v] of ed) {\\n    aps[v].add(u)\\n  }\\n  for (let ps of aps) {\\n    for (let p of ps) {\\n      for (let gp of aps[p]) {\\n        ps.add(gp)\\n      }\\n    }\\n  }\\n  return aps.map(ps => [...ps].sort((a, b) => a - b))\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getAncestors = function (n, ed) {\\n  let aps = Array(n).fill().map(() => new Set())\\n  for (let [u, v] of ed) {\\n    aps[v].add(u)\\n  }\\n  for (let ps of aps) {\\n    for (let p of ps) {\\n      for (let gp of aps[p]) {\\n        ps.add(gp)\\n      }\\n    }\\n  }\\n  return aps.map(ps => [...ps].sort((a, b) => a - b))\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552179,
                "title": "brute-force-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n void dfs(int i,vector<int>&vis,unordered_map<int,vector<int>>&adj,vector<vector<int>>&ans)\\n {\\n     vis[i]=1;\\n     unordered_map<int,int>h;\\n     for(auto e:adj[i])\\n     {\\n         if(vis[e]==0)\\n         dfs(e,vis,adj,ans);\\n          if(h.count(e)==0)\\n              ans[i].push_back(e);\\n              h[e]++;\\n\\n        for(auto f:ans[e])\\n          {\\n              if(h.count(f)==0)\\n              {\\n                  ans[i].push_back(f);\\n                  h[f]++;\\n              }\\n          }\\n\\n     }\\n }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>adj;\\n        for(auto e:edges)\\n        {\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int>vis(n,0);\\n        vector<vector<int>>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n             dfs(i,vis,adj,ans);\\n\\n        }\\n        for(auto &e:ans)\\n         sort(e.begin(),e.end());\\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n void dfs(int i,vector<int>&vis,unordered_map<int,vector<int>>&adj,vector<vector<int>>&ans)\\n {\\n     vis[i]=1;\\n     unordered_map<int,int>h;\\n     for(auto e:adj[i])\\n     {\\n         if(vis[e]==0)\\n         dfs(e,vis,adj,ans);\\n          if(h.count(e)==0)\\n              ans[i].push_back(e);\\n              h[e]++;\\n\\n        for(auto f:ans[e])\\n          {\\n              if(h.count(f)==0)\\n              {\\n                  ans[i].push_back(f);\\n                  h[f]++;\\n              }\\n          }\\n\\n     }\\n }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>adj;\\n        for(auto e:edges)\\n        {\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int>vis(n,0);\\n        vector<vector<int>>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n             dfs(i,vis,adj,ans);\\n\\n        }\\n        for(auto &e:ans)\\n         sort(e.begin(),e.end());\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443750,
                "title": "java-dfs-beats-94-o-n-2",
                "content": "#### Time Complexity : O(n^2 + n*log(n))\\n#### Space Complexity : O(n^2)\\n\\n\\n``` java []\\nclass Solution {\\n    boolean[] vis;\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>(n);\\n        \\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<>();\\n            res.add(new ArrayList<>());\\n        }\\n        for(int[] x:edges){\\n            a[x[1]].add(x[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            boolean[] vis = new boolean[n];\\n            vis[i] = true;\\n            dfs(a,i,res.get(i),vis);\\n            Collections.sort(res.get(i));\\n        }\\n        return res;\\n    }\\n\\n\\n    private void dfs(ArrayList<Integer>[] a,int curr, List<Integer> temp,boolean[] vis){\\n        for(int x:a[curr]){\\n            if(!vis[x]){\\n                vis[x] = true;\\n                temp.add(x);\\n                dfs(a,x,temp,vis);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    boolean[] vis;\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>(n);\\n        \\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<>();\\n            res.add(new ArrayList<>());\\n        }\\n        for(int[] x:edges){\\n            a[x[1]].add(x[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            boolean[] vis = new boolean[n];\\n            vis[i] = true;\\n            dfs(a,i,res.get(i),vis);\\n            Collections.sort(res.get(i));\\n        }\\n        return res;\\n    }\\n\\n\\n    private void dfs(ArrayList<Integer>[] a,int curr, List<Integer> temp,boolean[] vis){\\n        for(int x:a[curr]){\\n            if(!vis[x]){\\n                vis[x] = true;\\n                temp.add(x);\\n                dfs(a,x,temp,vis);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357409,
                "title": "c-4-approaches-comparison-analysis-of-dfs-bfs-w-w-o-visited-array",
                "content": "## Approach1 - DFS w/ visit array\\nThe main idea is to traverse from one ancestor and reach out to all its descendants.\\n1. Iterating through`edges`and store the directly linked child of each ancestor node. \\n2. Traversing from an ancestor`src`to reach every descendants; While in one search,`visit`array is used to record the descendants that had been visited.\\n3. Iterating through the`visit`descendants array and push the ancestor`src`to each descendant array, and since the iterator`src` start with`0`and end with`n-1`, the anscestor array in`ans`would be in order of smallest to largest.\\n### Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visit, int src) {\\n        visit[src] = 1;\\n        for (auto n : adj[src])\\n            if (!visit[n])\\n                dfs(adj, visit, n);\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the descendants\\n        for (auto e : edges)\\n            adj[e[0]].push_back(e[1]);\\n        for (int src = 0; src < n; src++) {\\n            vector<bool> visit (n, 0);//visited descendants in this dfs search path\\n            dfs(adj, visit, src);//traverse the path from ancestor_src\\n            visit[src] = 0;//excluding ancestor itself\\n            for (int child = 0; child < n; child++)\\n                if (visit[child])\\n                    ans[child].push_back(src);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$, in worst case, every node is pointed by all the other nodes except its parent, which implies (n - 1) + (n - 2) + ... + 1\\n## Approach2 - DFS w/o visit array\\nIn approach1, a`visit`array is used to remember the descendants that had been visited within one DFS traversal path. Since the ancestor is fixed in each DFS traversal, only the descendant may be repeatedly vistied. That is, the`visit`array wouldn\\'t be necessary as long as the ancestor array of each descendants is being tracked, which is recorded in`ans`.\\nThis can be done by checking the last ancestor of each descendant array. For example, if the ancestor already exists in`ans[descendant_i]`, skip recording this ancestor and stop traversing the descendants of`descendant_i`since it had been visited within this DFS traversal. And the ancestor of DFS traversal iterates from`0`to`n-1`, the ancestor array in`ans`would also be in order.\\n### Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<vector<int>> &ans, int src, const int &ancestor) {\\n        for (auto i : adj[src])\\n            if (ans[i].empty() || ans[i].back() != ancestor) {//check the last ancestor in one dfs traversal to avoid duplicates\\n                ans[i].push_back(ancestor);\\n                dfs(adj, ans, i, ancestor);\\n            }\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(n), adj(n);//adj store the descendants\\n        for (auto e : edges)\\n            adj[e[0]].push_back(e[1]);\\n        for (int src = 0; src < n; src++)\\n            dfs(adj, ans, src, src);//traverse the path from ancestor_src\\n        return ans;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n## Approach3 - BFS w/ visit array\\nThe main idea is just like the hint suggested, reverse the direction of`edges`and store the directly linked ancestors of each node. Starting a traversal from a descendant node to collect all its ancestors, this can be done by`queue`.\\n1. Iterating through`edges`and store the directly linked ancestor of each descendant node.\\n2. Using a queue`bfs`to perform BFS for each descendant and collecting the visited ancestors by using a`visit`array within one traversal.\\n3. If the ancestor was not yet visited, push it into the queue`bfs`.\\n4. Checking whether the queue empty or not, if not empty, keep traversing unitl there is no ancestor waiting to be traversed.\\n5. For each descendant, check the`visit`array from index`0`to`n-1`to see if the ancestor had been visited within this BFS traversal and record it in`ans`.\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the ancestors\\n        for (auto e : edges)\\n            adj[e[1]].push_back(e[0]);\\n        for (int dec = 0; dec < n; dec++) {\\n            vector<bool> visit (n, 0);//visited ancestor in this bfs search path\\n            queue<int> bfs;\\n            bfs.push(dec);\\n            while (!bfs.empty()) {\\n                if (!visit[bfs.front()]) {\\n                    visit[bfs.front()] = 1;\\n                    for (auto n : adj[bfs.front()])//find grand parents\\n                        if (!visit[n])\\n                            bfs.push(n);\\n                }\\n                bfs.pop();\\n            }\\n            visit[dec] = 0;//excluding descendant itself\\n            for (int anc = 0; anc < n; anc++)\\n                if (visit[anc])\\n                    ans[dec].push_back(anc);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n## Approach4 - BFS w/o visit array\\nThe BFS can also be done without a visit array. Since storing only direct ancestor of each node in`adj`, there are some operations to do for checking whether the ancestor had been repeatedly visited or not. Also, the ancestor might be in any order during the ancestor collecting process, the ancestor index shall be sorted after collection.\\n### Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the ancestors\\n        for (auto e : edges)\\n            adj[e[1]].push_back(e[0]);\\n        for (int dec = 0; dec < n; dec++) {\\n            queue<int> bfs;\\n            bfs.push(dec);\\n            while (!bfs.empty()) {\\n                for (auto anc : adj[bfs.front()]) {//find grand parents\\n                    if (find(ans[dec].begin(), ans[dec].end(), anc) == ans[dec].end()) {//avoid the same ancestor\\n                        ans[dec].push_back(anc);\\n                        bfs.push(anc);\\n                    }\\n                }\\n                bfs.pop();\\n            }\\n            sort(ans[dec].begin(), ans[dec].end());\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n##  Summary\\n- Runtime: A2 < A1 < A3 << A4\\n- Memory usage: A2 < A1 < A4 < A3\\n\\nThe overall runtime of using queue to do BFS is longer than recursively doing DFS; And the runtime of BFS without a visit array is explicitly much longer than BFS with a visit array, this is due to the result of doing find() of every ancestor for checking duplicates and sort() to sort the index of ancestor for each descendant.\\n\\nIf there\\'s any mistake or suggestion, please comment. And if you think my post really helps, please upvote, thanks!",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visit, int src) {\\n        visit[src] = 1;\\n        for (auto n : adj[src])\\n            if (!visit[n])\\n                dfs(adj, visit, n);\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the descendants\\n        for (auto e : edges)\\n            adj[e[0]].push_back(e[1]);\\n        for (int src = 0; src < n; src++) {\\n            vector<bool> visit (n, 0);//visited descendants in this dfs search path\\n            dfs(adj, visit, src);//traverse the path from ancestor_src\\n            visit[src] = 0;//excluding ancestor itself\\n            for (int child = 0; child < n; child++)\\n                if (visit[child])\\n                    ans[child].push_back(src);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<vector<int>> &ans, int src, const int &ancestor) {\\n        for (auto i : adj[src])\\n            if (ans[i].empty() || ans[i].back() != ancestor) {//check the last ancestor in one dfs traversal to avoid duplicates\\n                ans[i].push_back(ancestor);\\n                dfs(adj, ans, i, ancestor);\\n            }\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(n), adj(n);//adj store the descendants\\n        for (auto e : edges)\\n            adj[e[0]].push_back(e[1]);\\n        for (int src = 0; src < n; src++)\\n            dfs(adj, ans, src, src);//traverse the path from ancestor_src\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the ancestors\\n        for (auto e : edges)\\n            adj[e[1]].push_back(e[0]);\\n        for (int dec = 0; dec < n; dec++) {\\n            vector<bool> visit (n, 0);//visited ancestor in this bfs search path\\n            queue<int> bfs;\\n            bfs.push(dec);\\n            while (!bfs.empty()) {\\n                if (!visit[bfs.front()]) {\\n                    visit[bfs.front()] = 1;\\n                    for (auto n : adj[bfs.front()])//find grand parents\\n                        if (!visit[n])\\n                            bfs.push(n);\\n                }\\n                bfs.pop();\\n            }\\n            visit[dec] = 0;//excluding descendant itself\\n            for (int anc = 0; anc < n; anc++)\\n                if (visit[anc])\\n                    ans[dec].push_back(anc);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the ancestors\\n        for (auto e : edges)\\n            adj[e[1]].push_back(e[0]);\\n        for (int dec = 0; dec < n; dec++) {\\n            queue<int> bfs;\\n            bfs.push(dec);\\n            while (!bfs.empty()) {\\n                for (auto anc : adj[bfs.front()]) {//find grand parents\\n                    if (find(ans[dec].begin(), ans[dec].end(), anc) == ans[dec].end()) {//avoid the same ancestor\\n                        ans[dec].push_back(anc);\\n                        bfs.push(anc);\\n                    }\\n                }\\n                bfs.pop();\\n            }\\n            sort(ans[dec].begin(), ans[dec].end());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331671,
                "title": "easy-peasy-93-beats-beginner-using-dfs",
                "content": "\\nWhat we are doing here ?\\n\\nSuppose we have tree :-\\n\\n0           2      1       7 \\n        3             6\\n    4      5\\n\\n\\nso 2 is connected to 3 ans 4, 1 is connected to 4 and 6, 3 is connected to 4 and 5. 7 is isolated.\\n\\nwe have to traverse dfs on every node.\\n\\n2 -> 3\\n3 -> 4,5\\n\\nwe have make result = {}, and push parent node to its adjacent nodes.\\n\\nand make every nodes in result with empty array, \\nfor each i in [0...n]\\nresult[i] = []\\n\\nIteration: 1, (0 is isolated),\\nresult[0] = []\\n\\n\\nIteration: 2, (1)\\n1 -> 6,\\nresult[6] = 1\\n\\nIteration: 3, (2)\\n2 -> 3\\nresult[3] = [2]\\n\\n3 is connected with 4 and 5\\nresult[4] = [2]\\nresult[5] = [2]\\n\\nIteration: 4, (3)\\n3 -> 4,5\\nresult[4] = [2, 3]\\nresult[5] = [2, 3]\\n\\nIteration: 5, (4)\\n4 is not connected with any child nodes\\nresult[4] = [2, 3]\\n\\nIteration: 6, (5)\\nresult[5] = [2, 3]\\n\\nIteration: 7, (6)\\n6 is not connected to any child nodes\\nresult[6] = [1]\\n\\nIteration: 8, (7)\\n7 is isolated so,\\nresult[7] = []\\n\\n\\nso at the end we have resultant result =\\n{0: [], 1: [], 2: [], 3: [], 4: [2, 3], 5: [2, 3], 6: [1], 7: []};\\n\\n\\n# Please do upvote if you like the solution. please consider effort also.\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    let adjList = {}, result = {};\\n\\n    for(let [s, d] of edges) {\\n        if(!adjList[s]) adjList[s] = [];\\n        adjList[s].push(d);\\n    }\\n\\n    for(let i = 0; i < n; i++) {\\n        result[i] = [];\\n    }\\n\\n\\n    var dfs = function(s, p) {\\n        let count = [];\\n        for(let d of adjList[s] || []) {\\n            if(!visited[d]) {\\n                visited[d] = true\\n                result[d].push(p);\\n                dfs(d, p);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    for(let i = 0; i < n; i++) {\\n        visited = {[i]: true};\\n        dfs(i, i)\\n    }\\n\\n    return Object.values(result);\\n};```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    let adjList = {}, result = {};\\n\\n    for(let [s, d] of edges) {\\n        if(!adjList[s]) adjList[s] = [];\\n        adjList[s].push(d);\\n    }\\n\\n    for(let i = 0; i < n; i++) {\\n        result[i] = [];\\n    }\\n\\n\\n    var dfs = function(s, p) {\\n        let count = [];\\n        for(let d of adjList[s] || []) {\\n            if(!visited[d]) {\\n                visited[d] = true\\n                result[d].push(p);\\n                dfs(d, p);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    for(let i = 0; i < n; i++) {\\n        visited = {[i]: true};\\n        dfs(i, i)\\n    }\\n\\n    return Object.values(result);\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 3173952,
                "title": "python-dfs-memoization-w-o-lru-cache",
                "content": "- solution w/o @lru_cache\\n```\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adjacents = collections.defaultdict(list)\\n        for u, v in edges:\\n            adjacents[v].append(u)\\n\\n        memo = {}\\n        def dfs(node):\\n            if node in memo:\\n                return memo[node]\\n\\n            ancestors = set()\\n            for neighbor in adjacents[node]:\\n                ancestors.add(neighbor)\\n                for n in dfs(neighbor):\\n                    ancestors.add(n)\\n            \\n            memo[node] = ancestors\\n            return ancestors\\n\\n        res = []\\n        for i in range(n):\\n            ancestors = dfs(i)\\n            res.append(sorted(list(ancestors)))\\n\\n        return res\\n```\\n\\n\\n- solution w/ @lru_cache\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adjacents = collections.defaultdict(list)\\n        for u, v in edges:\\n            adjacents[v].append(u)\\n\\n        @lru_cache(None)\\n        def dfs(node):\\n            ancestors = set()\\n            for neighbor in adjacents[node]:\\n                ancestors.add(neighbor)\\n                temp = dfs(neighbor)\\n                for n in temp:\\n                    ancestors.add(n)\\n\\n            return ancestors\\n\\n        res = []\\n        for i in range(n):\\n            ancestors = dfs(i)\\n            res.append(sorted(list(ancestors)))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adjacents = collections.defaultdict(list)\\n        for u, v in edges:\\n            adjacents[v].append(u)\\n\\n        memo = {}\\n        def dfs(node):\\n            if node in memo:\\n                return memo[node]\\n\\n            ancestors = set()\\n            for neighbor in adjacents[node]:\\n                ancestors.add(neighbor)\\n                for n in dfs(neighbor):\\n                    ancestors.add(n)\\n            \\n            memo[node] = ancestors\\n            return ancestors\\n\\n        res = []\\n        for i in range(n):\\n            ancestors = dfs(i)\\n            res.append(sorted(list(ancestors)))\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adjacents = collections.defaultdict(list)\\n        for u, v in edges:\\n            adjacents[v].append(u)\\n\\n        @lru_cache(None)\\n        def dfs(node):\\n            ancestors = set()\\n            for neighbor in adjacents[node]:\\n                ancestors.add(neighbor)\\n                temp = dfs(neighbor)\\n                for n in temp:\\n                    ancestors.add(n)\\n\\n            return ancestors\\n\\n        res = []\\n        for i in range(n):\\n            ancestors = dfs(i)\\n            res.append(sorted(list(ancestors)))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883534,
                "title": "bfs-n-2-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we sort the result array at the end, it will result in a (n^2)*log(n) time complexity. \\nWe want to reach a n^2 time complexity, and for that we need the BFS to build a sorted result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo build the sorted result using iterative BFS, we set a list of starting_points containing all the nodes. For each of those starting points, we will conduct the BFS, look through all their descendant and add the starting point as ancestor for them.\\n\\n-> We begin with starting_point = 0, adding 0 as ancestor for each of its descendant\\n-> We continue with starting_point = 1, adding 1 as ancestor for each of its descendant\\n->... until starting_point = n.\\nIt results in getting all ancestors array sorted.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\nFor each node, we are going through all their descendants.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\nWe have \\'starting_points\\' containing each node, we maintain \\'level\\' in the starting_points loop and maintain \\'new_level\\' in level loop.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def getAncestors(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        ancestors = [[] for _ in range(n)]\\n        \\n        adjacency_list = defaultdict(list)\\n        for source, destination in edges:\\n            adjacency_list[source].append(destination)\\n            \\n        starting_points = [(node, node) for node in reversed(range(n))]\\n        visited = set()\\n        while starting_points:\\n            level = [starting_points.pop()]\\n            while level:\\n                new_level = []\\n                for node, ancestor in level:\\n                    if (node, ancestor) not in visited:\\n                        visited.add((node, ancestor))\\n                        if node != ancestor:\\n                            ancestors[node].append(ancestor)\\n                        for destination in adjacency_list[node]:\\n                            new_level.append((destination, ancestor))\\n                level = new_level\\n            \\n        return ancestors\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def getAncestors(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        ancestors = [[] for _ in range(n)]\\n        \\n        adjacency_list = defaultdict(list)\\n        for source, destination in edges:\\n            adjacency_list[source].append(destination)\\n            \\n        starting_points = [(node, node) for node in reversed(range(n))]\\n        visited = set()\\n        while starting_points:\\n            level = [starting_points.pop()]\\n            while level:\\n                new_level = []\\n                for node, ancestor in level:\\n                    if (node, ancestor) not in visited:\\n                        visited.add((node, ancestor))\\n                        if node != ancestor:\\n                            ancestors[node].append(ancestor)\\n                        for destination in adjacency_list[node]:\\n                            new_level.append((destination, ancestor))\\n                level = new_level\\n            \\n        return ancestors\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685576,
                "title": "python-92-reverse-direction-memoize",
                "content": "Idea:\\n\\n- Reverse alldirection of the DAG, so we can start from each vertex and go back to all of the ancestors\\n- To save answer for each node, we can use a hashmap, where each key is the vertex and the value is the set of all the ancestors\\n\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        graph      = collections.defaultdict(list)\\n        ancestors  = collections.defaultdict(set)\\n        \\n        for u, v in edges: graph[v].append(u) #Add in reverse direction\\n            \\n        res = {}\\n        \\n        def dfs(u):\\n            if u in ancestors: return ancestors[u]\\n            \\n            for v in graph[u]:\\n                ancestors[u].update([v, *ancestors[u], *dfs(v)]) #Add sub results\\n            \\n            return ancestors[u]\\n        \\n        for i in range(n): dfs(i)\\n        \\n        return [sorted(ancestors[i]) for i in range(n)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        graph      = collections.defaultdict(list)\\n        ancestors  = collections.defaultdict(set)\\n        \\n        for u, v in edges: graph[v].append(u) #Add in reverse direction\\n            \\n        res = {}",
                "codeTag": "Java"
            },
            {
                "id": 2521731,
                "title": "javascript-topological-sort-w-comments",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    // create in-degree tracker (array)\\n    const inDegrees = Array(n).fill(0);\\n    \\n    // maintain the results in a hash for each node\\n    const res = {}\\n    for (let i = 0; i < n; i++) {\\n        res[i] = new Set();\\n    }\\n    \\n    // create the graph + increment in-degrees\\n    const graph = {};\\n    for (const [from, to] of edges) {\\n        inDegrees[to]++;\\n        \\n        if (!graph[from]) {\\n            graph[from] = [];\\n        }\\n        graph[from].push(to);\\n    }\\n    \\n    // build queue for top sort where in-degree === 0\\n    const q = [];\\n    for (let i = 0; i < n; i++) {\\n        if (inDegrees[i] === 0) {\\n            q.push(i);\\n        }\\n    }\\n    \\n    // perform top sort w/ motifications\\n    while (q.length) {\\n        const node = q.shift();\\n        const neighbors = graph[node] || [];\\n\\n        for (const neighbor of neighbors) {\\n            // add this node to its child\\'s ancestor set\\n            res[neighbor].add(node);\\n            // add each of this node\\'s ancestors to its child\\'s ancestor set\\n            for (const v of res[node]) {\\n                res[neighbor].add(v)\\n            }\\n            \\n            // decrease the in-degree for this node\\'s child + check if should be added to top sort\\n            inDegrees[neighbor]--\\n            if (inDegrees[neighbor] === 0) {\\n                q.push(neighbor);\\n            }\\n        }\\n    }\\n    \\n    // turn the sets into arrays + sort them\\n    const result = [];\\n    for (const set of Object.values(res)) {\\n        const arr = Array.from(set);\\n        arr.sort((a,b) => a-b);\\n        result.push(arr)\\n    }\\n    return result\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    // create in-degree tracker (array)\\n    const inDegrees = Array(n).fill(0);\\n    \\n    // maintain the results in a hash for each node\\n    const res = {}\\n    for (let i = 0; i < n; i++) {\\n        res[i] = new Set();\\n    }\\n    \\n    // create the graph + increment in-degrees\\n    const graph = {};\\n    for (const [from, to] of edges) {\\n        inDegrees[to]++;\\n        \\n        if (!graph[from]) {\\n            graph[from] = [];\\n        }\\n        graph[from].push(to);\\n    }\\n    \\n    // build queue for top sort where in-degree === 0\\n    const q = [];\\n    for (let i = 0; i < n; i++) {\\n        if (inDegrees[i] === 0) {\\n            q.push(i);\\n        }\\n    }\\n    \\n    // perform top sort w/ motifications\\n    while (q.length) {\\n        const node = q.shift();\\n        const neighbors = graph[node] || [];\\n\\n        for (const neighbor of neighbors) {\\n            // add this node to its child\\'s ancestor set\\n            res[neighbor].add(node);\\n            // add each of this node\\'s ancestors to its child\\'s ancestor set\\n            for (const v of res[node]) {\\n                res[neighbor].add(v)\\n            }\\n            \\n            // decrease the in-degree for this node\\'s child + check if should be added to top sort\\n            inDegrees[neighbor]--\\n            if (inDegrees[neighbor] === 0) {\\n                q.push(neighbor);\\n            }\\n        }\\n    }\\n    \\n    // turn the sets into arrays + sort them\\n    const result = [];\\n    for (const set of Object.values(res)) {\\n        const arr = Array.from(set);\\n        arr.sort((a,b) => a-b);\\n        result.push(arr)\\n    }\\n    return result\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512648,
                "title": "java-reverse-all-edges-then-just-iterate-over-neighbours-dfs-bfs-0ms",
                "content": "**DFS**\\n\\n```\\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] edge : edges){\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            boolean vis[] = new boolean[n];\\n            \\n            dfs(adj,vis,i);\\n            \\n            List<Integer> resMini = new ArrayList<>();\\n            \\n            for(int j=0;j<n;j++){\\n                if(i!=j&&vis[j]){\\n                    resMini.add(j);\\n                }\\n            }\\n            \\n            res.add(resMini);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(List<List<Integer>> adj, boolean[] vis,int num){\\n      \\n        vis[num]=true;\\n        \\n        for(int neigh : adj.get(num)){\\n            if(!vis[neigh]){\\n                dfs(adj,vis,neigh);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] edge : edges){\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            boolean vis[] = new boolean[n];\\n            \\n            dfs(adj,vis,i);\\n            \\n            List<Integer> resMini = new ArrayList<>();\\n            \\n            for(int j=0;j<n;j++){\\n                if(i!=j&&vis[j]){\\n                    resMini.add(j);\\n                }\\n            }\\n            \\n            res.add(resMini);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(List<List<Integer>> adj, boolean[] vis,int num){\\n      \\n        vis[num]=true;\\n        \\n        for(int neigh : adj.get(num)){\\n            if(!vis[neigh]){\\n                dfs(adj,vis,neigh);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497951,
                "title": "java-khan-s-algo-topo-sort-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> adjacencyList = new HashMap();\\n        int m = edges.length;\\n        int[] indegrees = new int[n];\\n        for(int i=0; i<m; i++){\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            adjacencyList.putIfAbsent(from, new LinkedList());\\n            adjacencyList.get(from).add(to);\\n            indegrees[to]++;\\n        }\\n        LinkedList<Integer> q = new LinkedList();\\n        TreeSet<Integer>[] resArr = new TreeSet[n];\\n        for(int i = 0; i<n; i++){\\n            if(indegrees[i]==0){\\n                q.offer(i);\\n                resArr[i] = new TreeSet();\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int nd = q.poll();\\n            if(adjacencyList.containsKey(nd)){\\n                List<Integer> nexts = adjacencyList.get(nd);\\n                for(int next : nexts){\\n                    indegrees[next]--;\\n                    if(resArr[next] == null)\\n                        resArr[next] = new TreeSet(resArr[nd]);\\n                    else\\n                        resArr[next].addAll(resArr[nd]);\\n                    resArr[next].add(nd);\\n                    if(indegrees[next] == 0){\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n        }\\n        List<List<Integer>> resList = new LinkedList();\\n        for(TreeSet<Integer> ts : resArr)\\n            resList.add(new LinkedList(ts));\\n        return resList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> adjacencyList = new HashMap();\\n        int m = edges.length;\\n        int[] indegrees = new int[n];\\n        for(int i=0; i<m; i++){\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            adjacencyList.putIfAbsent(from, new LinkedList());\\n            adjacencyList.get(from).add(to);\\n            indegrees[to]++;\\n        }\\n        LinkedList<Integer> q = new LinkedList();\\n        TreeSet<Integer>[] resArr = new TreeSet[n];\\n        for(int i = 0; i<n; i++){\\n            if(indegrees[i]==0){\\n                q.offer(i);\\n                resArr[i] = new TreeSet();\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int nd = q.poll();\\n            if(adjacencyList.containsKey(nd)){\\n                List<Integer> nexts = adjacencyList.get(nd);\\n                for(int next : nexts){\\n                    indegrees[next]--;\\n                    if(resArr[next] == null)\\n                        resArr[next] = new TreeSet(resArr[nd]);\\n                    else\\n                        resArr[next].addAll(resArr[nd]);\\n                    resArr[next].add(nd);\\n                    if(indegrees[next] == 0){\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n        }\\n        List<List<Integer>> resList = new LinkedList();\\n        for(TreeSet<Integer> ts : resArr)\\n            resList.add(new LinkedList(ts));\\n        return resList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480444,
                "title": "c-dfs-easy-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int node,vector<int> &vis,vector<int> adj[]){\\n\\t\\t\\tvis[node]=1;\\n\\n\\t\\t\\tfor(auto x:adj[node]){\\n\\t\\t\\t\\tif(!vis[x])\\n\\t\\t\\t\\t\\tdfs(x,vis,adj);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\n\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\tvector<vector<int>> ans(n);\\n\\n\\t\\t\\tfor(auto i:edges)\\n\\t\\t\\t\\tadj[i[0]].push_back(i[1]);\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\t\\tvector<int> vis(n,0);\\n\\t\\t\\t\\tdfs(i,vis,adj);\\n\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tif(i!=j and vis[j])\\n\\t\\t\\t\\t\\t\\tans[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int node,vector<int> &vis,vector<int> adj[]){\\n\\t\\t\\tvis[node]=1;\\n\\n\\t\\t\\tfor(auto x:adj[node]){\\n\\t\\t\\t\\tif(!vis[x])\\n\\t\\t\\t\\t\\tdfs(x,vis,adj);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2427139,
                "title": "faster-solution-practise-bfs",
                "content": "This is done by bfs approach .Apply the bfs from each node . and add all the ancestors to the answer vector . The good problem to practise bfs algorithm  if you have any kind of doubts . This problem will help a lot . \\n```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>>&adj , queue<int>q , int i , vector<vector<int>>&ans)\\n    {\\n        q.push(i);\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it : adj[node])\\n            {\\n                if(ans[it].empty() or ans[it].back()!=i){\\n                ans[it].push_back(i);\\n                q.push(it);\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>adj(n+1);\\n        for( auto x : edges)\\n        {\\n            int u = x[0];\\n            int v = x[1];\\n            adj[u].push_back(v);\\n        }\\n        queue<int>q;\\n        vector<vector<int>>ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            bfs(adj , q , i , ans);\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>>&adj , queue<int>q , int i , vector<vector<int>>&ans)\\n    {\\n        q.push(i);\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it : adj[node])\\n            {\\n                if(ans[it].empty() or ans[it].back()!=i){\\n                ans[it].push_back(i);\\n                q.push(it);\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>adj(n+1);\\n        for( auto x : edges)\\n        {\\n            int u = x[0];\\n            int v = x[1];\\n            adj[u].push_back(v);\\n        }\\n        queue<int>q;\\n        vector<vector<int>>ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            bfs(adj , q , i , ans);\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382973,
                "title": "c-simple-dfs-without-toposort",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>>&adj,vector<int>&temp,vector<bool>&vis)\\n    {   vis[node]=true;\\n        for(auto child:adj[node])\\n        {  \\n          if(vis[child]==false)\\n          {\\n            temp.push_back(child);\\n            \\n            dfs(child,adj,temp,vis);\\n           }\\n            \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& a) {\\n       vector<vector<int>>adj(n);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            adj[a[i][1]].push_back(a[i][0]);\\n        }\\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {    vector<bool>vis(n,false);\\n            vector<int>temp;\\n            dfs(i,adj,temp,vis);\\n            sort(temp.begin(),temp.end());\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>>&adj,vector<int>&temp,vector<bool>&vis)\\n    {   vis[node]=true;\\n        for(auto child:adj[node])\\n        {  \\n          if(vis[child]==false)\\n          {\\n            temp.push_back(child);\\n            \\n            dfs(child,adj,temp,vis);\\n           }\\n            \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& a) {\\n       vector<vector<int>>adj(n);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            adj[a[i][1]].push_back(a[i][0]);\\n        }\\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {    vector<bool>vis(n,false);\\n            vector<int>temp;\\n            dfs(i,adj,temp,vis);\\n            sort(temp.begin(),temp.end());\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317053,
                "title": "c-dfs-beginner-level",
                "content": "**RUN THE COMMENTS AS WELL TO SEE THE FLOW OF DATA.**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>adj;\\n    vector<vector<int>>ans;\\n    \\n    void helper(int node,int temp, vector<bool>& visited)\\n    {\\n        visited[temp]=true;        \\n        for(auto it: adj[temp])\\n            {\\n            //cout<<temp<<\"->\";\\n                if(!visited[it])\\n                {   \\n                    //cout<<it<<\\' \\';\\n                    ans[node].push_back(it);\\n                    helper(node,it,visited);\\n                }                \\n            }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {        \\n        adj.resize(n);\\n        ans.resize(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n                vector<bool> visited;\\n                visited.resize(n,false);\\n                //cout<<endl;\\n                helper(i,i,visited);\\n                sort(ans[i].begin(),ans[i].end());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>adj;\\n    vector<vector<int>>ans;\\n    \\n    void helper(int node,int temp, vector<bool>& visited)\\n    {\\n        visited[temp]=true;        \\n        for(auto it: adj[temp])\\n            {\\n            //cout<<temp<<\"->\";\\n                if(!visited[it])\\n                {   \\n                    //cout<<it<<\\' \\';\\n                    ans[node].push_back(it);\\n                    helper(node,it,visited);\\n                }                \\n            }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {        \\n        adj.resize(n);\\n        ans.resize(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n                vector<bool> visited;\\n                visited.resize(n,false);\\n                //cout<<endl;\\n                helper(i,i,visited);\\n                sort(ans[i].begin(),ans[i].end());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2272095,
                "title": "python-topological-sort",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = collections.defaultdict(list)\\n        parents = [set() for i in range(n)]\\n        ranks = [0] * n\\n        for a, b in edges:\\n            graph[a].append(b)\\n            ranks[b] += 1\\n        deque = collections.deque()\\n        for i in range(n):\\n            if not ranks[i]:\\n                deque.append(i)\\n        while deque:\\n            node = deque.popleft()\\n            for child in graph[node]:\\n                parents[child] |= parents[node]\\n                parents[child].add(node)\\n                ranks[child] -= 1\\n                if not ranks[child]:\\n                    deque.append(child)\\n        return [sorted(list(s)) for s in parents]\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = collections.defaultdict(list)\\n        parents = [set() for i in range(n)]\\n        ranks = [0] * n\\n        for a, b in edges:\\n            graph[a].append(b)\\n            ranks[b] += 1\\n        deque = collections.deque()\\n        for i in range(n):\\n            if not ranks[i]:\\n                deque.append(i)\\n        while deque:\\n            node = deque.popleft()\\n            for child in graph[node]:\\n                parents[child] |= parents[node]\\n                parents[child].add(node)\\n                ranks[child] -= 1\\n                if not ranks[child]:\\n                    deque.append(child)\\n        return [sorted(list(s)) for s in parents]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037910,
                "title": "python3-topological-sort-kahn-s-algorithm",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        for a, b in edges:\\n            graph[a].append(b)\\n            indegrees[b] += 1\\n            \\n        todo = deque()\\n        for node, degree in enumerate(indegrees):\\n            if degree == 0:\\n                todo.append(node)\\n        \\n        result = [[] for _ in range(n)]\\n        ancestors = defaultdict(set)\\n        while todo:\\n            cur = todo.popleft()\\n            for neigh in graph[cur]:\\n                \\n                ancestors[neigh].add(cur)\\n                for ancestor in ancestors[cur]:\\n                    ancestors[neigh].add(ancestor)\\n                    \\n                indegrees[neigh] -= 1\\n                if indegrees[neigh] == 0:\\n                    todo.append(neigh)\\n        \\n        for key in ancestors:\\n            for ancestor in ancestors[key]:\\n                result[key].append(ancestor)\\n                result[key].sort()\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        for a, b in edges:\\n            graph[a].append(b)\\n            indegrees[b] += 1\\n            \\n        todo = deque()\\n        for node, degree in enumerate(indegrees):\\n            if degree == 0:\\n                todo.append(node)\\n        \\n        result = [[] for _ in range(n)]\\n        ancestors = defaultdict(set)\\n        while todo:\\n            cur = todo.popleft()\\n            for neigh in graph[cur]:\\n                \\n                ancestors[neigh].add(cur)\\n                for ancestor in ancestors[cur]:\\n                    ancestors[neigh].add(ancestor)\\n                    \\n                indegrees[neigh] -= 1\\n                if indegrees[neigh] == 0:\\n                    todo.append(neigh)\\n        \\n        for key in ancestors:\\n            for ancestor in ancestors[key]:\\n                result[key].append(ancestor)\\n                result[key].sort()\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024131,
                "title": "python3-reverse-edge-direction-problem-becomes-dfs-finding-all-children",
                "content": "This problem asks to find all parents nodes of a given node. If we inverse the edge direction, the problem becomes finding all children nodes, which is a basic dfs problem.\\ndfs(node) returns all children nodes, in our case since the edges are reversed, it means all parents nodes.\\nAlso need to cache the result of dfs(node) because this is not a tree, there might exists multiple parent nodes targeting same child node, in which case child node result can be reused.\\n\\n**Python3**\\n```python\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges_reverse = [[] for _ in range(n)]\\n        for a,b in edges:\\n            edges_reverse[b].append(a)\\n        @cache\\n        def dfs(node):\\n            res = set()\\n            for nxt in edges_reverse[node]:\\n                res.add(nxt)\\n                res |= dfs(nxt)\\n            return res\\n        return [sorted(dfs(i)) for i in range(n)]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges_reverse = [[] for _ in range(n)]\\n        for a,b in edges:\\n            edges_reverse[b].append(a)\\n        @cache\\n        def dfs(node):\\n            res = set()\\n            for nxt in edges_reverse[node]:\\n                res.add(nxt)\\n                res |= dfs(nxt)\\n            return res\\n        return [sorted(dfs(i)) for i in range(n)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2012720,
                "title": "only-dfs-c-without-topological-sort-faster-than-84",
                "content": "```\\n//Just reverse the edges direction, as a result now child is pointing to its parent.\\n// and now just make dfs call on each node and store the parents.\\n\\nclass Solution\\n{\\npublic:\\n    void dfs(int i, vector<bool> &vis, vector<int> adj[], vector<int> &temp)\\n    {\\n        vis[i] = true;\\n        temp.push_back(i);\\n        for (auto it : adj[i])\\n            if (vis[it] == false)\\n                dfs(it, vis, adj, temp);\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>> &edges)\\n    {\\n        vector<int> adj[n];\\n        for (auto it : edges)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<bool> vis(n, false);\\n            temp.clear();\\n            for (auto it : adj[i])\\n                if(vis[it]==false)\\n                    dfs(it, vis, adj, temp);\\n            sort(temp.begin(), temp.end());\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//Just reverse the edges direction, as a result now child is pointing to its parent.\\n// and now just make dfs call on each node and store the parents.\\n\\nclass Solution\\n{\\npublic:\\n    void dfs(int i, vector<bool> &vis, vector<int> adj[], vector<int> &temp)\\n    {\\n        vis[i] = true;\\n        temp.push_back(i);\\n        for (auto it : adj[i])\\n            if (vis[it] == false)\\n                dfs(it, vis, adj, temp);\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>> &edges)\\n    {\\n        vector<int> adj[n];\\n        for (auto it : edges)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<bool> vis(n, false);\\n            temp.clear();\\n            for (auto it : adj[i])\\n                if(vis[it]==false)\\n                    dfs(it, vis, adj, temp);\\n            sort(temp.begin(), temp.end());\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983399,
                "title": "c-learn-3-solutions-topo-reverse-edge-simple-dfs",
                "content": "\\n#### 1. Topological Sort ~829ms\\n- First thing to come up in your mind would be, Yes find parent `inorder[i] == 0` and start.\\n- Traverse below, add all grand parents as its parents.\\n- Overall complexity, along with sorting - O(NMLogM)\\n\\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    vector<int> indegree(n);\\n\\n    for(auto& edge: edges){\\n        graph[edge[0]].push_back(edge[1]);\\n        indegree[edge[1]]++;\\n    }\\n\\n    //not dependednt nodes - grand parents - topo sort\\n    queue<int> q;\\n    for(int i=0; i<n; i++)\\n        if(indegree[i] == 0)\\n            q.push(i);\\n\\n    //start bfs from least edge\\n    while(!q.empty()){\\n        int node = q.front(); q.pop();\\n\\n        for(int child: graph[node]){\\n            res[child].insert(node);\\n            for(int c: res[node])\\n                res[child].insert(c);\\n\\n            if(--indegree[child] == 0)\\n                q.push(child);\\n        }\\n    }\\n\\n    //sort\\n    vector<vector<int>> ans(n);\\n    for(int i=0; i<n; i++)\\n        ans[i] = vector<int>(res[i].begin(), res[i].end());\\n\\n    return ans;\\n}\\n```\\n\\n#### 2. Reverse Edges ~744ms\\n- Wait thats right, you can reverse the edges and move from child -> parent\\n- A simple DFS/BFS will help you go over to grand parents and keep adding them to your result.\\n- Time Complexity: O(NMLogM)\\n\\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    for(auto& edge: edges)\\n        graph[edge[1]].push_back(edge[0]); // reverse the edge direction\\n\\n    for(int i=0; i<n; i++){\\n        queue<int> q; \\n\\t\\tq.push(i);\\n\\n        set<int> visited;\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            for(int parent: graph[node])\\n                if(!visited.count(parent)){\\n                    q.push(parent);\\n                    visited.insert(parent);\\n                }\\n        }\\n        res[i] = vector<int>(visited.begin(), visited.end());\\n    }\\n    return res;\\n}\\n```\\n\\n#### 3. Simple DFS ~211 ms\\n- A DFS  from source node (0 -> N-1) to all the reachable nodes will always have that visiting nodes as an ancestors.\\n- Sorting is already looked after - just think input as - `[[0,2],[0,1],[0,3]....` - Edge order doesn\\'t matter - By our DFS visits in inc order - First ancessor is `0` which would visit childs first, and append parent `0` to the `res` list, so already getting sorted.\\n- Time Complexity: O(N*M)\\n```cpp\\nvoid dfs(vector<vector<int>>& graph, vector<vector<int>>& res, vector<int>& visited, int prev, int node){\\n    visited[node] = 1;\\n    \\n\\tfor(int& child: graph[node]){\\n        if(visited[child]) continue;\\n        if(res[child].size() == 0 || res[child].back() != prev){\\n            res[child].push_back(prev);\\n            dfs(graph, res, visited, prev, child);\\n        }\\n    }\\n}\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    for(auto& edge: edges)\\n        graph[edge[0]].push_back(edge[1]);\\n\\n    for(int i=0; i<n; i++){\\n        vector<int> visited(n);\\n        dfs(graph, res, visited, i, i);\\n    }\\n\\n    return res;\\n}\\n```\\n\\n**Upvote and let other leetcoders  too learn.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    vector<int> indegree(n);\\n\\n    for(auto& edge: edges){\\n        graph[edge[0]].push_back(edge[1]);\\n        indegree[edge[1]]++;\\n    }\\n\\n    //not dependednt nodes - grand parents - topo sort\\n    queue<int> q;\\n    for(int i=0; i<n; i++)\\n        if(indegree[i] == 0)\\n            q.push(i);\\n\\n    //start bfs from least edge\\n    while(!q.empty()){\\n        int node = q.front(); q.pop();\\n\\n        for(int child: graph[node]){\\n            res[child].insert(node);\\n            for(int c: res[node])\\n                res[child].insert(c);\\n\\n            if(--indegree[child] == 0)\\n                q.push(child);\\n        }\\n    }\\n\\n    //sort\\n    vector<vector<int>> ans(n);\\n    for(int i=0; i<n; i++)\\n        ans[i] = vector<int>(res[i].begin(), res[i].end());\\n\\n    return ans;\\n}\\n```\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    for(auto& edge: edges)\\n        graph[edge[1]].push_back(edge[0]); // reverse the edge direction\\n\\n    for(int i=0; i<n; i++){\\n        queue<int> q; \\n\\t\\tq.push(i);\\n\\n        set<int> visited;\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            for(int parent: graph[node])\\n                if(!visited.count(parent)){\\n                    q.push(parent);\\n                    visited.insert(parent);\\n                }\\n        }\\n        res[i] = vector<int>(visited.begin(), visited.end());\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvoid dfs(vector<vector<int>>& graph, vector<vector<int>>& res, vector<int>& visited, int prev, int node){\\n    visited[node] = 1;\\n    \\n\\tfor(int& child: graph[node]){\\n        if(visited[child]) continue;\\n        if(res[child].size() == 0 || res[child].back() != prev){\\n            res[child].push_back(prev);\\n            dfs(graph, res, visited, prev, child);\\n        }\\n    }\\n}\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    for(auto& edge: edges)\\n        graph[edge[0]].push_back(edge[1]);\\n\\n    for(int i=0; i<n; i++){\\n        vector<int> visited(n);\\n        dfs(graph, res, visited, i, i);\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939950,
                "title": "c-topological-sort-queue-easily-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        map<int, vector<int>> g;\\n        int inDegree[n];\\n        memset(inDegree, 0, sizeof(inDegree));\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            inDegree[e[1]]++;\\n        }\\n        queue<int> Q;\\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) {\\n                Q.push(i);\\n            }\\n        }\\n        \\n        bool visited[n][n];\\n        memset(visited, false, sizeof(visited));\\n        \\n        while(!Q.empty()) {\\n            int parent = Q.front();\\n            Q.pop();\\n            for(int child : g[parent]) {\\n                inDegree[child]--;\\n                if(inDegree[child] == 0) {\\n                    Q.push(child);\\n                }\\n                for(int anc : ans[parent]) {\\n                    if(visited[child][anc]) continue;\\n                    ans[child].push_back(anc);\\n                    visited[child][anc] = true;\\n                }\\n                if(visited[child][parent]) continue;\\n                ans[child].push_back(parent);\\n                visited[child][parent] = true;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            sort(ans[i].begin(), ans[i].end());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        map<int, vector<int>> g;\\n        int inDegree[n];\\n        memset(inDegree, 0, sizeof(inDegree));\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            inDegree[e[1]]++;\\n        }\\n        queue<int> Q;\\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) {\\n                Q.push(i);\\n            }\\n        }\\n        \\n        bool visited[n][n];\\n        memset(visited, false, sizeof(visited));\\n        \\n        while(!Q.empty()) {\\n            int parent = Q.front();\\n            Q.pop();\\n            for(int child : g[parent]) {\\n                inDegree[child]--;\\n                if(inDegree[child] == 0) {\\n                    Q.push(child);\\n                }\\n                for(int anc : ans[parent]) {\\n                    if(visited[child][anc]) continue;\\n                    ans[child].push_back(anc);\\n                    visited[child][anc] = true;\\n                }\\n                if(visited[child][parent]) continue;\\n                ans[child].push_back(parent);\\n                visited[child][parent] = true;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            sort(ans[i].begin(), ans[i].end());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898595,
                "title": "topological-sort-bitset",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> getAncestors(int n, vector<vector<int>> &edges)\\n\\t{\\n\\t\\tvector<int> in(n);\\n\\t\\tvector<vector<int>> g(n), rg(n);\\n\\t\\tfor (auto &i : edges)\\n\\t\\t{\\n\\t\\t\\tg[i[0]].push_back(i[1]);\\n\\t\\t\\trg[i[1]].push_back(i[0]);\\n\\t\\t\\tin[i[1]]++;\\n\\t\\t}\\n\\t\\tvector<bitset<1001>> ancestor(n);\\n\\t\\trep(i, 0, n) ancestor[i].set(i);\\n\\t\\tqueue<int> q;\\n\\t\\trep(i, 0, n) if (in[i] == 0) q.push(i);\\n\\n\\t\\twhile (q.size())\\n\\t\\t{\\n\\t\\t\\tint curr = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int i : rg[curr])\\n\\t\\t\\t\\tancestor[curr] |= ancestor[i];\\n\\t\\t\\tfor (int i : g[curr])\\n\\t\\t\\t{\\n\\t\\t\\t\\tin[i]--;\\n\\t\\t\\t\\tif (in[i] == 0)\\n\\t\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> ans(n, vector<int>());\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (ancestor[i].test(j))\\n\\t\\t\\t\\t\\tans[i].push_back(j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> getAncestors(int n, vector<vector<int>> &edges)\\n\\t{\\n\\t\\tvector<int> in(n);\\n\\t\\tvector<vector<int>> g(n), rg(n);\\n\\t\\tfor (auto &i : edges)\\n\\t\\t{\\n\\t\\t\\tg[i[0]].push_back(i[1]);\\n\\t\\t\\trg[i[1]].push_back(i[0]);\\n\\t\\t\\tin[i[1]]++;\\n\\t\\t}\\n\\t\\tvector<bitset<1001>> ancestor(n);\\n\\t\\trep(i, 0, n) ancestor[i].set(i);\\n\\t\\tqueue<int> q;\\n\\t\\trep(i, 0, n) if (in[i] == 0) q.push(i);\\n\\n\\t\\twhile (q.size())\\n\\t\\t{\\n\\t\\t\\tint curr = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int i : rg[curr])\\n\\t\\t\\t\\tancestor[curr] |= ancestor[i];\\n\\t\\t\\tfor (int i : g[curr])\\n\\t\\t\\t{\\n\\t\\t\\t\\tin[i]--;\\n\\t\\t\\t\\tif (in[i] == 0)\\n\\t\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> ans(n, vector<int>());\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (ancestor[i].test(j))\\n\\t\\t\\t\\t\\tans[i].push_back(j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856808,
                "title": "java-dfs-o-n-2",
                "content": "```\\nclass Solution {\\n    class Node {\\n        int value;\\n        List<Node> children;\\n        public Node(int value) {\\n            this.value = value;\\n            this.children = new ArrayList<>();\\n        }\\n    }\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, Node> graph = new HashMap<>();\\n        List<List<Integer>> ancestors = new ArrayList<>();\\n        buildGraph(n, edges, graph);\\n        for (int node = 0; node < n; node += 1) {\\n            ancestors.add(new ArrayList<>());\\n        }\\n        for (int node = 0; node < n; node += 1) {\\n            boolean[] visited = new boolean[n];\\n            dfs(graph.get(node), graph, ancestors, node, visited);\\n        }\\n        return ancestors;\\n    }\\n    \\n    private void buildGraph(int n, int[][] edges, Map<Integer, Node> graph) {\\n        for (int node = 0; node < n; node += 1) {\\n            graph.put(node, new Node(node));\\n        }\\n        for (int[] edge: edges) {\\n            graph.get(edge[0]).children.add(graph.get(edge[1]));\\n        }\\n    }\\n    \\n    private void dfs(Node currentNode, Map<Integer, Node> graph, List<List<Integer>> ancestors, int ancestor, boolean[] visited) {\\n        for(Node node: currentNode.children) {\\n            int value = node.value;\\n            if (!visited[value]) {\\n                ancestors.get(value).add(ancestor);\\n                visited[value] = true;\\n                dfs(node, graph, ancestors, ancestor, visited);   \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Node {\\n        int value;\\n        List<Node> children;\\n        public Node(int value) {\\n            this.value = value;\\n            this.children = new ArrayList<>();\\n        }\\n    }\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, Node> graph = new HashMap<>();\\n        List<List<Integer>> ancestors = new ArrayList<>();\\n        buildGraph(n, edges, graph);\\n        for (int node = 0; node < n; node += 1) {\\n            ancestors.add(new ArrayList<>());\\n        }\\n        for (int node = 0; node < n; node += 1) {\\n            boolean[] visited = new boolean[n];\\n            dfs(graph.get(node), graph, ancestors, node, visited);\\n        }\\n        return ancestors;\\n    }\\n    \\n    private void buildGraph(int n, int[][] edges, Map<Integer, Node> graph) {\\n        for (int node = 0; node < n; node += 1) {\\n            graph.put(node, new Node(node));\\n        }\\n        for (int[] edge: edges) {\\n            graph.get(edge[0]).children.add(graph.get(edge[1]));\\n        }\\n    }\\n    \\n    private void dfs(Node currentNode, Map<Integer, Node> graph, List<List<Integer>> ancestors, int ancestor, boolean[] visited) {\\n        for(Node node: currentNode.children) {\\n            int value = node.value;\\n            if (!visited[value]) {\\n                ancestors.get(value).add(ancestor);\\n                visited[value] = true;\\n                dfs(node, graph, ancestors, ancestor, visited);   \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856251,
                "title": "c-recursion-memoization-99-9-faster-better-stronger",
                "content": "**Remarks:**\\n- Other solutions look simpler and I have not tested them but this one seems efficent. \\n- The idea I followed is to reuse the list of ancestors of other nodes if already calculated, else compute them, after that, resort them and remove the duplicates.\\n- The \"faster, better, stronger\" in the title is just for having a click bait title, definitely not sure this solution is fastor or better than others :-)\\n\\n![image](https://assets.leetcode.com/users/images/5b8164f7-33d9-4514-be44-fcc53b05b817_1647470459.3264768.png)\\n\\n**Note:** I had to run it multiple times as there is some jitter in leetcode benchmarks (min 80%, max 99.95%)\\n\\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\tvector<vector<int>> ancestors(n);\\n\\tfor(const auto& e: edges)\\n\\t\\tancestors[e[1]].push_back(e[0]);\\n\\tvector<int> visited(n);   \\n\\tfor(int i = 0; i < n; ++i) \\n\\t\\tget_ancestors(visited, ancestors, i);\\n\\treturn ancestors;\\n}\\n\\nvoid get_ancestors(vector<int>& visited, \\n\\t\\t\\t\\t   vector<vector<int>>& ancestors, \\n\\t\\t\\t\\t   int node) {\\n\\tif(!visited[node]) {\\n\\t\\tvisited[node] = 1;\\n\\t\\tauto & v = ancestors[node];\\n\\t\\tfor(int i=0, size=v.size(); i <size; ++i) {\\n\\t\\t\\tget_ancestors(visited, ancestors, v[i]);\\n\\t\\t\\tv.insert(v.end(), ancestors[v[i]].begin(), ancestors[v[i]].end());\\n\\t\\t}\\n\\t\\tsort(v.begin(), v.end());\\n\\t\\tv.erase(unique(v.begin(), v.end()), v.end());\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\tvector<vector<int>> ancestors(n);\\n\\tfor(const auto& e: edges)\\n\\t\\tancestors[e[1]].push_back(e[0]);\\n\\tvector<int> visited(n);   \\n\\tfor(int i = 0; i < n; ++i) \\n\\t\\tget_ancestors(visited, ancestors, i);\\n\\treturn ancestors;\\n}\\n\\nvoid get_ancestors(vector<int>& visited, \\n\\t\\t\\t\\t   vector<vector<int>>& ancestors, \\n\\t\\t\\t\\t   int node) {\\n\\tif(!visited[node]) {\\n\\t\\tvisited[node] = 1;\\n\\t\\tauto & v = ancestors[node];\\n\\t\\tfor(int i=0, size=v.size(); i <size; ++i) {\\n\\t\\t\\tget_ancestors(visited, ancestors, v[i]);\\n\\t\\t\\tv.insert(v.end(), ancestors[v[i]].begin(), ancestors[v[i]].end());\\n\\t\\t}\\n\\t\\tsort(v.begin(), v.end());\\n\\t\\tv.erase(unique(v.begin(), v.end()), v.end());\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1843207,
                "title": "python-o-n-2",
                "content": "```\\ndef getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(set)\\n        \\n        for i,j in edges:\\n            d[i].add(j)\\n            \\n        res = [[] for i in range(n)]\\n        \\n        for i in range(n):\\n            q = [i]\\n            while q:\\n                node = q.pop(0)\\n                for nei in d[node]:\\n                    if i not in res[nei]:\\n                        res[nei].append(i)\\n                        q.append(nei)\\n        return res\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ndef getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(set)\\n        \\n        for i,j in edges:\\n            d[i].add(j)\\n            \\n        res = [[] for i in range(n)]\\n        \\n        for i in range(n):\\n            q = [i]\\n            while q:\\n                node = q.pop(0)\\n                for nei in d[node]:\\n                    if i not in res[nei]:\\n                        res[nei].append(i)\\n                        q.append(nei)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1842817,
                "title": "dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[1005];\\n    bool vis[1005];\\n    \\n    void dfs(int node, vector<int>&v,int start)\\n    {\\n        vis[node]=true;\\n        if(node!=start)v.push_back(node);\\n        \\n        for(auto it:adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,v,start);\\n            }\\n        }\\n        \\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            dfs(i,ans[i],i);\\n            sort(ans[i].begin(),ans[i].end());\\n            for(int i=0;i<1005;i++)\\n            {\\n                vis[i]=false;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[1005];\\n    bool vis[1005];\\n    \\n    void dfs(int node, vector<int>&v,int start)\\n    {\\n        vis[node]=true;\\n        if(node!=start)v.push_back(node);\\n        \\n        for(auto it:adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,v,start);\\n            }\\n        }\\n        \\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            dfs(i,ans[i],i);\\n            sort(ans[i].begin(),ans[i].end());\\n            for(int i=0;i<1005;i++)\\n            {\\n                vis[i]=false;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840055,
                "title": "very-simple-reversing-the-edges-and-then-using-set-properties-of-java",
                "content": "```\\nclass Solution {\\n    ArrayList<Integer>[] adj;\\n    List<List<Integer>> res ;\\n    boolean[] visited;\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n         adj = new ArrayList[n ];\\n        for (int i = 0; i < n; i++ ) adj[i] = new ArrayList<Integer>(); \\n        int len = edges.length;\\n        for (int i = 0; i < len; i++){adj[edges[i][1]].add(edges[i][0]);}\\n       res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) res.add(new ArrayList<Integer>());\\n        visited = new boolean[n ];\\n        for (int i = 0; i < n; i++){\\n            if (!visited[i]) dfs(i);\\n        }\\n        \\n        return res;        \\n    }\\n    public void dfs(int i){\\n        visited[i] = true; \\n        for (int k: adj[i]){\\n            if (!visited[k]){\\n                dfs(k);\\n            }\\n            for (int j: res.get(k)){\\n                res.get(i).add(j);\\n            }\\n            res.get(i).add(k);\\n        }\\n         res.set(i, res.get(i).stream().distinct().collect(Collectors.toList()));\\n        Collections.sort(res.get(i));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    ArrayList<Integer>[] adj;\\n    List<List<Integer>> res ;\\n    boolean[] visited;\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n         adj = new ArrayList[n ];\\n        for (int i = 0; i < n; i++ ) adj[i] = new ArrayList<Integer>(); \\n        int len = edges.length;\\n        for (int i = 0; i < len; i++){adj[edges[i][1]].add(edges[i][0]);}\\n       res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) res.add(new ArrayList<Integer>());\\n        visited = new boolean[n ];\\n        for (int i = 0; i < n; i++){\\n            if (!visited[i]) dfs(i);\\n        }\\n        \\n        return res;        \\n    }\\n    public void dfs(int i){\\n        visited[i] = true; \\n        for (int k: adj[i]){\\n            if (!visited[k]){\\n                dfs(k);\\n            }\\n            for (int j: res.get(k)){\\n                res.get(i).add(j);\\n            }\\n            res.get(i).add(k);\\n        }\\n         res.set(i, res.get(i).stream().distinct().collect(Collectors.toList()));\\n        Collections.sort(res.get(i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833895,
                "title": "c-topological-sort",
                "content": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i,bool vis[],vector<int>adj[],int element,vector<vector<int>>&res){\\n        if(vis[i])\\n            return;\\n        vis[i] = 1;\\n        if(i!=element)\\n            res[i].push_back(element);\\n        for(auto it : adj[i]){\\n            dfs(it,vis,adj,element,res);\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>res(n);\\n        vector<int>adj[n+1];\\n        int deg[10001]{0};\\n        \\n        for(auto it :edges){\\n            adj[it[0]].pb(it[1]);\\n            deg[it[1]]++;\\n        }\\n        \\n        queue<int>Q;\\n        bool vis[1001]{0};\\n        for(int i=0;i<n;++i){\\n            if(deg[i]==0)\\n                Q.push(i),vis[i]=1;\\n        }\\n        \\n        while(!Q.empty()){\\n            auto front = Q.front();\\n            Q.pop();\\n            bool locvis[1001]{0};\\n            dfs(front,locvis,adj,front,res);\\n            for(auto it : adj[front]){\\n                deg[it]--;\\n                if(!deg[it]){\\n                    Q.push(it);\\n                    vis[it] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            sort(res[i].begin(),res[i].end());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i,bool vis[],vector<int>adj[],int element,vector<vector<int>>&res){\\n        if(vis[i])\\n            return;\\n        vis[i] = 1;\\n        if(i!=element)\\n            res[i].push_back(element);\\n        for(auto it : adj[i]){\\n            dfs(it,vis,adj,element,res);\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>res(n);\\n        vector<int>adj[n+1];\\n        int deg[10001]{0};\\n        \\n        for(auto it :edges){\\n            adj[it[0]].pb(it[1]);\\n            deg[it[1]]++;\\n        }\\n        \\n        queue<int>Q;\\n        bool vis[1001]{0};\\n        for(int i=0;i<n;++i){\\n            if(deg[i]==0)\\n                Q.push(i),vis[i]=1;\\n        }\\n        \\n        while(!Q.empty()){\\n            auto front = Q.front();\\n            Q.pop();\\n            bool locvis[1001]{0};\\n            dfs(front,locvis,adj,front,res);\\n            for(auto it : adj[front]){\\n                deg[it]--;\\n                if(!deg[it]){\\n                    Q.push(it);\\n                    vis[it] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            sort(res[i].begin(),res[i].end());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830139,
                "title": "c-runtime-124-ms-faster-than-99-84-memory-48-7-mb-less-than-99-10",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvoid dfs(int i, int anc, vector<vector<int>> &al, vector<vector<int>> &res) {\\n\\t\\tif (res[i].empty() || res[i].back() != anc)  {\\n\\t\\t\\tif (i != anc)\\n\\t\\t\\t\\tres[i].push_back(anc);\\n\\t\\t\\tfor (auto j : al[i])\\n\\t\\t\\t\\tdfs(j, anc, al, res);\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\t\\tvector<vector<int>> res(n), al(n);\\n\\t\\tfor (auto &e: edges)\\n\\t\\t\\tal[e[0]].push_back(e[1]);\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\tdfs(i, i, al, res);\\n\\t\\treturn res;    \\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvoid dfs(int i, int anc, vector<vector<int>> &al, vector<vector<int>> &res) {\\n\\t\\tif (res[i].empty() || res[i].back() != anc)  {\\n\\t\\t\\tif (i != anc)\\n\\t\\t\\t\\tres[i].push_back(anc);\\n\\t\\t\\tfor (auto j : al[i])\\n\\t\\t\\t\\tdfs(j, anc, al, res);\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\t\\tvector<vector<int>> res(n), al(n);\\n\\t\\tfor (auto &e: edges)\\n\\t\\t\\tal[e[0]].push_back(e[1]);\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\tdfs(i, i, al, res);\\n\\t\\treturn res;    \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825201,
                "title": "simple-dfs-apply-on-all-paprent-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>adj[],int st,int papa,vector<vector<int>>&vec,vector<int>&vis){\\n        vis[st]=1;\\n        for(auto it:adj[st]){\\n            if(!vis[it]){\\n                vec[it].push_back(papa);\\n                dfs(adj,it,papa,vec,vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        vector<vector<int>>vec(n);\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n                vector<int>vis(n,0);\\n                dfs(adj,i,i,vec,vis);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>adj[],int st,int papa,vector<vector<int>>&vec,vector<int>&vis){\\n        vis[st]=1;\\n        for(auto it:adj[st]){\\n            if(!vis[it]){\\n                vec[it].push_back(papa);\\n                dfs(adj,it,papa,vec,vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        vector<vector<int>>vec(n);\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n                vector<int>vis(n,0);\\n                dfs(adj,i,i,vec,vis);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824987,
                "title": "c-simple-dfs-zero-flex",
                "content": "\\n- Ancestor Meaning: \" A node u is an ancestor of another node v if u can reach v via a set of edges\"\\n\\n- Node 0 is ancestor of which all nodes?\\n    => Start a DFS(/BFS) from node 0 as src, and all the reachable nodes will \\n    always have node 0 as an ancestor [from definition]\\n    \\n- Node 1 is ancestor of which all nodes?\\n    => Start a DFS(/BFS) from node 1 as src, and all the reachable nodes will \\n    always have node 1 as an ancestor [from definition of ancestor]\\n    \\n- Node 2 is .....?\\n    => Start a DFS(/BFS) from node 2, ....\\n\\n- ...\\n\\n- Node n is ancestor of which all nodes?\\n    => Start a DFS(/BFS) from node n as src , and all the reachable nodes will \\n    always  have node n as an ancestor [from definition of ancestor]\\n    \\n- Hence, you see that we will automatically have all the ancestors in \\nincreasing order.\\n\\n- TC:O(N*N) Since for each src node (i) we do a DFS(/BFS) of entire graph form (i) and check which nodes are reachable\\n\\n- SC:O(N) for DFS(/BFS) + O(N^N) for returning answer\\n\\n```\\nvector<vector<int>> solution(int n, vector<vector<int>>& edges){\\n\\n\\tvector<int> adj[n];\\n\\n\\tfor(auto& e : edges){\\n\\t\\tint u = e[0], v = e[1];\\n\\t\\tadj[u].push_back(v);\\n\\t}\\n\\n\\tvector<vector<int>> ancestors(n);\\n\\n\\tfor(int src = 0; src < n; src++){\\n\\n\\t\\tvector<int> visited(n, 0);\\n\\t\\tdfs(src, src, visited, adj, ancestors);\\n\\n\\t}\\n\\n\\treturn ancestors;\\n}\\nvoid dfs(int currNode, int src, vector<int>& visited, vector<int> adj[], vector<vector<int>>& ancestors){\\n\\n\\tvisited[currNode] = +1;\\n\\n\\tif(currNode != src) \\n\\t\\tancestors[currNode].push_back(src);\\n\\n\\tfor(auto& adjNode : adj[currNode]){\\n\\t\\tif(visited[adjNode]) continue;\\n\\n\\t\\tdfs(adjNode, src, visited, adj, ancestors);\\n\\t}\\n\\n\\treturn;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> solution(int n, vector<vector<int>>& edges){\\n\\n\\tvector<int> adj[n];\\n\\n\\tfor(auto& e : edges){\\n\\t\\tint u = e[0], v = e[1];\\n\\t\\tadj[u].push_back(v);\\n\\t}\\n\\n\\tvector<vector<int>> ancestors(n);\\n\\n\\tfor(int src = 0; src < n; src++){\\n\\n\\t\\tvector<int> visited(n, 0);\\n\\t\\tdfs(src, src, visited, adj, ancestors);\\n\\n\\t}\\n\\n\\treturn ancestors;\\n}\\nvoid dfs(int currNode, int src, vector<int>& visited, vector<int> adj[], vector<vector<int>>& ancestors){\\n\\n\\tvisited[currNode] = +1;\\n\\n\\tif(currNode != src) \\n\\t\\tancestors[currNode].push_back(src);\\n\\n\\tfor(auto& adjNode : adj[currNode]){\\n\\t\\tif(visited[adjNode]) continue;\\n\\n\\t\\tdfs(adjNode, src, visited, adj, ancestors);\\n\\t}\\n\\n\\treturn;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824375,
                "title": "simple-solution-in-java-two-approaches-1-topological-sort-2-dfs-with-memo",
                "content": "**Topological Sort**\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        // Topological Sort\\n        \\n        \\n        // Create Graph and the inorder array\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        int[] inorder = new int[n];\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0], k -> new ArrayList<>()).add(e[1]);\\n            inorder[e[1]]++;\\n        }\\n        \\n        \\n        List<TreeSet<Integer>> ancestor = new ArrayList<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0; i<n; i++){\\n            ancestor.add(new TreeSet<>());\\n            if(inorder[i] == 0) queue.offer(i);\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            \\n            if(graph.containsKey(node)){\\n                for(int child : graph.get(node)){\\n                    ancestor.get(child).add(node);\\n                    ancestor.get(child).addAll(new TreeSet<>(ancestor.get(node)));\\n                        \\n                    if(--inorder[child] == 0) queue.offer(child);\\n                }\\n            }\\n        }\\n        \\n        // Create the result list\\n        List<List<Integer>> res = new ArrayList<>();\\n        for(TreeSet<Integer> li : ancestor){\\n            res.add(new ArrayList<>(li));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n**DFS**\\n```\\nclass Solution {\\n    private HashMap<Integer, List<Integer>> graph;\\n    private HashMap<Integer, List<Integer>> memo;\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        this.graph = new HashMap<>();\\n        this.memo = new HashMap<>();\\n            \\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[1], k -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            res.add(find(i));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private List<Integer> find(int node){\\n        if(memo.containsKey(node)) return memo.get(node);\\n        \\n        TreeSet<Integer> ancestors = new TreeSet<>();\\n        if(graph.containsKey(node)){\\n            for(int tp : graph.get(node)){\\n                ancestors.add(tp);\\n                ancestors.addAll(find(tp));\\n            }\\n        }\\n        \\n        memo.put(node, new ArrayList<Integer>(ancestors));\\n        return memo.get(node);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        // Topological Sort\\n        \\n        \\n        // Create Graph and the inorder array\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        int[] inorder = new int[n];\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0], k -> new ArrayList<>()).add(e[1]);\\n            inorder[e[1]]++;\\n        }\\n        \\n        \\n        List<TreeSet<Integer>> ancestor = new ArrayList<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0; i<n; i++){\\n            ancestor.add(new TreeSet<>());\\n            if(inorder[i] == 0) queue.offer(i);\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            \\n            if(graph.containsKey(node)){\\n                for(int child : graph.get(node)){\\n                    ancestor.get(child).add(node);\\n                    ancestor.get(child).addAll(new TreeSet<>(ancestor.get(node)));\\n                        \\n                    if(--inorder[child] == 0) queue.offer(child);\\n                }\\n            }\\n        }\\n        \\n        // Create the result list\\n        List<List<Integer>> res = new ArrayList<>();\\n        for(TreeSet<Integer> li : ancestor){\\n            res.add(new ArrayList<>(li));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private HashMap<Integer, List<Integer>> graph;\\n    private HashMap<Integer, List<Integer>> memo;\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        this.graph = new HashMap<>();\\n        this.memo = new HashMap<>();\\n            \\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[1], k -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            res.add(find(i));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private List<Integer> find(int node){\\n        if(memo.containsKey(node)) return memo.get(node);\\n        \\n        TreeSet<Integer> ancestors = new TreeSet<>();\\n        if(graph.containsKey(node)){\\n            for(int tp : graph.get(node)){\\n                ancestors.add(tp);\\n                ancestors.addAll(find(tp));\\n            }\\n        }\\n        \\n        memo.put(node, new ArrayList<Integer>(ancestors));\\n        return memo.get(node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823394,
                "title": "java-topological-sorting-easy-understanding",
                "content": "When I first got this question, I saw 1,000 data volumes, another graph topic. I used breadth-first search first, but it certainly didn\\'t work (at least the breadth I wrote won\\'t work). Then it came to mind as if and [210.Course schedule II](https://leetcode-cn.com/problems/course-schedule-ii/ ) Almost, so I have the next thoughts:\\n\\n1. Build two linear tables, one as a return value and the other using `TreeSet`, to sort elements while removing duplicate elements\\n2. Construct an adjacency matrix (the adjacency table would be better) and an array of degrees\\n3. Traverse `edges`to construct the relationship between edges in the graph and the degree of entry of each node\\n4. Queue the zero-penetration nodes in the graph and \"populate\" the two linear tables we originally built\\n5. Traverse through the entire penetration array separately. If the penetration is 0, join the queue, and add the parent node and all its parent nodes to the linear table\\n6. Put the final answer together in the return value`ans`\\n\\n\\nThe idea is too simple, only for AC, more advanced method also please see another problem solving\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Set<Integer>> demo = new ArrayList<>();\\n\\n        int[] system = new int[n];\\n        int[][] grid = new int[n][n];\\n\\n        for (int[] edge : edges) {\\n            system[edge[1]]++;\\n            grid[edge[0]][edge[1]] = 1;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (system[i] == 0) {\\n                queue.offer(i);\\n                system[i]--;\\n            }\\n            ans.add(new ArrayList<>());\\n            demo.add(new TreeSet<>());\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            while (size-- > 0) {\\n                int idx = queue.poll();\\n                for (int i = 0; i < n; i++) {\\n                    if (grid[idx][i] == 1) {\\n                        system[i]--;\\n                        demo.get(i).add(idx);\\n                        demo.get(i).addAll(demo.get(idx));\\n                    }\\n                    if (system[i] == 0) {\\n                        queue.offer(i);\\n                        system[i]--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            ans.get(i).addAll(demo.get(i));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Set<Integer>> demo = new ArrayList<>();\\n\\n        int[] system = new int[n];\\n        int[][] grid = new int[n][n];\\n\\n        for (int[] edge : edges) {\\n            system[edge[1]]++;\\n            grid[edge[0]][edge[1]] = 1;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (system[i] == 0) {\\n                queue.offer(i);\\n                system[i]--;\\n            }\\n            ans.add(new ArrayList<>());\\n            demo.add(new TreeSet<>());\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            while (size-- > 0) {\\n                int idx = queue.poll();\\n                for (int i = 0; i < n; i++) {\\n                    if (grid[idx][i] == 1) {\\n                        system[i]--;\\n                        demo.get(i).add(idx);\\n                        demo.get(i).addAll(demo.get(idx));\\n                    }\\n                    if (system[i] == 0) {\\n                        queue.offer(i);\\n                        system[i]--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            ans.get(i).addAll(demo.get(i));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823284,
                "title": "python-3-topological-sort-via-bfs",
                "content": "Similar to LC 207 ([Course Schedule](https://leetcode.com/problems/course-schedule/)), LC 210 ([Course Schedule II](https://leetcode.com/problems/course-schedule-II/)), first we build the graph as an adjacency list and use an array `inDegree` to count the number of incoming edges of a given node. Then, we use a BFS algorithm implemented via a queue to get the topological order of all nodes in the graph. The topological order allows us to find all ancestors of a given node sequentially.\\nPlease upvote if you find this solution helpful.\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # Topological sort with BFS (Kahn\\'s algorithm)\\n        # Similar to LC 207 (Course Schedule), LC 210 (Course Schedule II)\\n        graph = [[] for _ in range(n)]\\n        inDegree = [0] * n\\n        for edge in edges:\\n            start, end = edge[0], edge[1]\\n            graph[start].append(end)\\n            inDegree[end] += 1\\n        output = [set() for _ in range(n)]        \\n        queue = deque()\\n        for i in range(n):\\n            if inDegree[i] == 0:\\n                queue.append(i)\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                for desc in graph[node]:\\n                    output[desc].add(node)\\n                    for anc in output[node]:\\n                        output[desc].add(anc)\\n                    inDegree[desc] -= 1\\n                    if inDegree[desc] == 0:\\n                        queue.append(desc)\\n        for i in range(n):\\n            output[i] = sorted(list(output[i]))\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # Topological sort with BFS (Kahn\\'s algorithm)\\n        # Similar to LC 207 (Course Schedule), LC 210 (Course Schedule II)\\n        graph = [[] for _ in range(n)]\\n        inDegree = [0] * n\\n        for edge in edges:\\n            start, end = edge[0], edge[1]\\n            graph[start].append(end)\\n            inDegree[end] += 1\\n        output = [set() for _ in range(n)]        \\n        queue = deque()\\n        for i in range(n):\\n            if inDegree[i] == 0:\\n                queue.append(i)\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                for desc in graph[node]:\\n                    output[desc].add(node)\\n                    for anc in output[node]:\\n                        output[desc].add(anc)\\n                    inDegree[desc] -= 1\\n                    if inDegree[desc] == 0:\\n                        queue.append(desc)\\n        for i in range(n):\\n            output[i] = sorted(list(output[i]))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823141,
                "title": "java-solution",
                "content": "\\tpublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] e : edges){\\n            map.putIfAbsent(e[1], new HashSet<>());\\n            map.get(e[1]).add(e[0]);\\n        }\\n        Map<Integer, Set<Integer>> dp = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            res.add(new ArrayList<>(dfs(map, dp, i)));\\n        }\\n        return res;\\n    }\\n    \\n    Set<Integer> dfs(Map<Integer, Set<Integer>> map, Map<Integer, Set<Integer>> dp, int cur){\\n        if(dp.containsKey(cur))\\n            return dp.get(cur);\\n        Set<Integer> set = new TreeSet<>();\\n        for(int nei: map.getOrDefault(cur, new HashSet<>())){\\n            set.add(nei);\\n            set.addAll(dfs(map, dp, nei));\\n        }\\n        dp.put(cur, set);\\n        return set;\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "\\tpublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] e : edges){\\n            map.putIfAbsent(e[1], new HashSet<>());\\n            map.get(e[1]).add(e[0]);\\n        }\\n        Map<Integer, Set<Integer>> dp = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            res.add(new ArrayList<>(dfs(map, dp, i)));\\n        }\\n        return res;\\n    }\\n    \\n    Set<Integer> dfs(Map<Integer, Set<Integer>> map, Map<Integer, Set<Integer>> dp, int cur){\\n        if(dp.containsKey(cur))\\n            return dp.get(cur);\\n        Set<Integer> set = new TreeSet<>();\\n        for(int nei: map.getOrDefault(cur, new HashSet<>())){\\n            set.add(nei);\\n            set.addAll(dfs(map, dp, nei));\\n        }\\n        dp.put(cur, set);\\n        return set;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1822994,
                "title": "dfs-solution-with-explanation-faster-than-100-in-time-and-memory-c",
                "content": "public class Solution {\\n    public IList<IList<int>> GetAncestors(int n, int[][] edges) {\\n    \\n    // store all pareent child into this. (parent wil be the index of the key)    \\n    List<IList<int>> children = new List<IList<int>>();    \\n        \\n    // This will hold output values from the above list.    \\n    List<IList<int>> output = new List<IList<int>>();    \\n        \\n    // initialize both the lists so later we don\\'t have to take care of initialing again and again.    \\n    for(int i=0;i<n;i++)\\n    {\\n        children.Add(new List<int>());\\n        output.Add(new List<int>());\\n    }\\n    \\n    // Since edges are in parent-child fashion, edge[0] will be parent and edge[1] will be child\\n    foreach(var edge in edges)\\n    {\\n        children[edge[0]].Add(edge[1]);\\n    }\\n        \\n    // call dfs for all the nodes and fill parent value into all grandchildren\\n    // we are starting from node 0, so all it\\'s children and grandchildren will get 0 filled    \\n    for(int i=0;i<n;i++)\\n    {\\n        bool[] visited = new bool[n];\\n        DFS(i,i,visited,children,output);\\n    }\\n    \\n    return output;\\n    }\\n    \\n    \\n    public void DFS(int parent, int current, bool[] visited, List<IList<int>>children, List<IList<int>> output)\\n    {\\n\\t\\t// every loop in the parent function we are recreating this visited array.\\n\\t\\t// so we have this array only in the recursive scope to skip checking for previsously checked item.\\n        visited[current] = true;\\n        // fill current\\'s father into current\\'s children\\n        \\n        foreach(var child in children[current])\\n        {\\n            if(!visited[child])\\n            {\\n                output[child].Add(parent);\\n                DFS(parent,child,visited,children, output);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public IList<IList<int>> GetAncestors(int n, int[][] edges) {\\n    \\n    // store all pareent child into this. (parent wil be the index of the key)    \\n    List<IList<int>> children = new List<IList<int>>();    \\n        \\n    // This will hold output values from the above list.    \\n    List<IList<int>> output = new List<IList<int>>();    \\n        \\n    // initialize both the lists so later we don\\'t have to take care of initialing again and again.    \\n    for(int i=0;i<n;i++)\\n    {\\n        children.Add(new List<int>());\\n        output.Add(new List<int>());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1822772,
                "title": "python3-very-direct-and-simple-bfs",
                "content": "Brute force BFS\\n\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # contruct a graph from children to parent\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[b].append(a)\\n        \\n        ans = []\\n        for i in range(n):\\n            queue = deque([i])\\n            visited = set()\\n            while queue:\\n                node = queue.popleft()\\n                for nei in graph[node]:\\n                    if nei not in visited:\\n                        queue.append(nei)\\n                        visited.add(nei)\\n            ans.append(sorted(list(visited)))\\n        return ans\\n                    \\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "Brute force BFS\\n\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # contruct a graph from children to parent\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[b].append(a)\\n        \\n        ans = []\\n        for i in range(n):\\n            queue = deque([i])\\n            visited = set()\\n            while queue:\\n                node = queue.popleft()\\n                for nei in graph[node]:\\n                    if nei not in visited:\\n                        queue.append(nei)\\n                        visited.add(nei)\\n            ans.append(sorted(list(visited)))\\n        return ans\\n                    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1822721,
                "title": "c-very-simple-solution-dfs-beats-95-o-n-2",
                "content": "**Please UPVOTE if you like the solution.**\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int u, vector<int> &vec, vector<bool> &vis){\\n        \\n        vis[u] = true;\\n        \\n        for(auto v: adj[u]){\\n            if(vis[v] == false){\\n                vec.push_back(v);\\n                dfs(adj, v, vec, vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> ans;\\n        vector<int> adj[n];\\n        \\n        for(auto it: edges)\\n            adj[it[1]].push_back(it[0]);\\n        \\n        for(int i=0 ; i<n ; i++){\\n            vector<bool> vis(n, false);\\n            vector<int> v;\\n            \\n            dfs(adj, i, v, vis);\\n            sort(v.begin(), v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int u, vector<int> &vec, vector<bool> &vis){\\n        \\n        vis[u] = true;\\n        \\n        for(auto v: adj[u]){\\n            if(vis[v] == false){\\n                vec.push_back(v);\\n                dfs(adj, v, vec, vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> ans;\\n        vector<int> adj[n];\\n        \\n        for(auto it: edges)\\n            adj[it[1]].push_back(it[0]);\\n        \\n        for(int i=0 ; i<n ; i++){\\n            vector<bool> vis(n, false);\\n            vector<int> v;\\n            \\n            dfs(adj, i, v, vis);\\n            sort(v.begin(), v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822571,
                "title": "java-easy-bfs",
                "content": "Can also be done using dfs\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        List<List<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int i=0;i<n;i++)\\n            list.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++)\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n        for(int i=0;i<n;i++){\\n            Queue<Integer> q=new ArrayDeque<>();\\n            boolean[] vis=new boolean[n];\\n            q.add(i);\\n            vis[i]=true;\\n            while(!q.isEmpty()){\\n                int node=q.remove();\\n                \\n                if(node!=i)\\n                    list.get(node).add(i);\\n                for(int ele:adj.get(node)){\\n                    if(!vis[ele]){\\n                        vis[ele]=true;\\n                        q.add(ele);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n            Collections.sort(list.get(i));\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        List<List<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int i=0;i<n;i++)\\n            list.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++)\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n        for(int i=0;i<n;i++){\\n            Queue<Integer> q=new ArrayDeque<>();\\n            boolean[] vis=new boolean[n];\\n            q.add(i);\\n            vis[i]=true;\\n            while(!q.isEmpty()){\\n                int node=q.remove();\\n                \\n                if(node!=i)\\n                    list.get(node).add(i);\\n                for(int ele:adj.get(node)){\\n                    if(!vis[ele]){\\n                        vis[ele]=true;\\n                        q.add(ele);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n            Collections.sort(list.get(i));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822543,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n     HashMap<Integer,TreeSet<Integer>> amap=new HashMap<>();\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n         HashMap<Integer,List<Integer>> map=new HashMap<>();\\n         int[] in=new int[n];\\n         for(int i=0;i<n;i++)\\n         {\\n             map.put(i,new ArrayList<>());\\n            amap.put(i,new TreeSet<>());\\n        }\\n        for(int[] a:edges)\\n        {\\n            map.get(a[0]).add(a[1]);\\n            in[a[1]]++;\\n        }\\n        Queue<Integer> queue=new LinkedList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n               // System.out.println(i);\\n                queue.add(i);\\n                //dfs(i,map,new ArrayList<>());\\n            }\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            int value=queue.poll();\\n            if(map.get(value).size()>0)\\n            {\\n                for(int a:map.get(value))\\n                {\\n                    amap.get(a).add(value);\\n                    amap.get(a).addAll(amap.get(value));\\n                    in[a]--;\\n                    if(in[a]==0)\\n                    {\\n                        queue.add(a);\\n                    }\\n                }\\n            }\\n        }\\n         List<List<Integer>> result=new ArrayList<>();\\n        for(int a:amap.keySet())\\n        {\\n            TreeSet<Integer> set=amap.get(a);\\n            List<Integer> templist=new ArrayList<>();\\n            for(int val:set)\\n            {\\n                templist.add(val);\\n            }\\n            result.add(templist);\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     HashMap<Integer,TreeSet<Integer>> amap=new HashMap<>();\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n         HashMap<Integer,List<Integer>> map=new HashMap<>();\\n         int[] in=new int[n];\\n         for(int i=0;i<n;i++)\\n         {\\n             map.put(i,new ArrayList<>());\\n            amap.put(i,new TreeSet<>());\\n        }\\n        for(int[] a:edges)\\n        {\\n            map.get(a[0]).add(a[1]);\\n            in[a[1]]++;\\n        }\\n        Queue<Integer> queue=new LinkedList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n               // System.out.println(i);\\n                queue.add(i);\\n                //dfs(i,map,new ArrayList<>());\\n            }\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            int value=queue.poll();\\n            if(map.get(value).size()>0)\\n            {\\n                for(int a:map.get(value))\\n                {\\n                    amap.get(a).add(value);\\n                    amap.get(a).addAll(amap.get(value));\\n                    in[a]--;\\n                    if(in[a]==0)\\n                    {\\n                        queue.add(a);\\n                    }\\n                }\\n            }\\n        }\\n         List<List<Integer>> result=new ArrayList<>();\\n        for(int a:amap.keySet())\\n        {\\n            TreeSet<Integer> set=amap.get(a);\\n            List<Integer> templist=new ArrayList<>();\\n            for(int val:set)\\n            {\\n                templist.add(val);\\n            }\\n            result.add(templist);\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822456,
                "title": "javascript-dfs-with-set",
                "content": "```\\nvar getAncestors = function(n, edges) {\\n    const nodes = new Array(n);\\n    for (let i = 0; i < edges.length; ++i) {\\n        if (!nodes[edges[i][1]]) nodes[edges[i][1]] = [];\\n        nodes[edges[i][1]].push(edges[i][0]);\\n    }\\n    \\n    const set = new Set();\\n    const result = new Array(n);\\n    \\n    const dfs = (node) => {\\n        set.add(node);\\n        if (nodes[node]) {\\n            for (let i = 0; i < nodes[node].length; ++i) {\\n                if (set.has(nodes[node][i]) === false) {\\n                    dfs(nodes[node][i]);\\n                }\\n            }\\n        }\\n    };\\n    \\n    for (let i = 0; i < n; ++i) {\\n        set.clear();\\n        \\n        if (nodes[i]) {\\n            for (const node of nodes[i]) {\\n                dfs(node);\\n            }\\n        }\\n        \\n        result[i] = Array.from(set);\\n        result[i].sort((a, b) => a - b);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getAncestors = function(n, edges) {\\n    const nodes = new Array(n);\\n    for (let i = 0; i < edges.length; ++i) {\\n        if (!nodes[edges[i][1]]) nodes[edges[i][1]] = [];\\n        nodes[edges[i][1]].push(edges[i][0]);\\n    }\\n    \\n    const set = new Set();\\n    const result = new Array(n);\\n    \\n    const dfs = (node) => {\\n        set.add(node);\\n        if (nodes[node]) {\\n            for (let i = 0; i < nodes[node].length; ++i) {\\n                if (set.has(nodes[node][i]) === false) {\\n                    dfs(nodes[node][i]);\\n                }\\n            }\\n        }\\n    };\\n    \\n    for (let i = 0; i < n; ++i) {\\n        set.clear();\\n        \\n        if (nodes[i]) {\\n            for (const node of nodes[i]) {\\n                dfs(node);\\n            }\\n        }\\n        \\n        result[i] = Array.from(set);\\n        result[i].sort((a, b) => a - b);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822373,
                "title": "c-dfs-easy-and-consise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void dfs(int node,unordered_map<int,vector<int>>&graph, vector<int>&res,vector<bool>&vis){\\n        vis[node]=1;\\n        for(auto x:graph[node]){\\n            if(!vis[x]){\\n                res.push_back(x);\\n                dfs(x,graph,res,vis);\\n            }     \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>graph;\\n        for(auto e:edges){\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>res;\\n            vector<bool>vis(n,false);\\n            dfs(i,graph,res,vis);\\n            sort(res.begin(),res.end());\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void dfs(int node,unordered_map<int,vector<int>>&graph, vector<int>&res,vector<bool>&vis){\\n        vis[node]=1;\\n        for(auto x:graph[node]){\\n            if(!vis[x]){\\n                res.push_back(x);\\n                dfs(x,graph,res,vis);\\n            }     \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>graph;\\n        for(auto e:edges){\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>res;\\n            vector<bool>vis(n,false);\\n            dfs(i,graph,res,vis);\\n            sort(res.begin(),res.end());\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822339,
                "title": "c-solution-bfs",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n];\\n        int arr[n];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto it: edges){\\n            arr[it[1]]+=1;\\n            graph[it[0]].push_back(it[1]);\\n        }\\n        \\n        queue<int> q;\\n        vector<int> res;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[i]==0)\\n            {\\n                q.push(i);\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front();\\n            q.pop();\\n            for(auto it : graph[f]){\\n                arr[it]-=1;\\n                if(arr[it]==0)\\n                {\\n                    q.push(it);\\n                    res.push_back(it);\\n                }\\n            }\\n        }\\n        vector<unordered_set<int>> ans(n);\\n        vector<vector<int>> fans;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            int val = res[i];\\n            for(auto it : graph[val]){\\n                ans[it].insert(val);\\n                for(auto it2: ans[val]) ans[it].insert(it2);\\n            }\\n        }\\n        \\n        for(auto it: ans){\\n            vector<int> temp;\\n            for(auto it2: it) temp.push_back(it2);\\n            sort(temp.begin(),temp.end());\\n            fans.push_back(temp);\\n        }\\n        \\n        return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n];\\n        int arr[n];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto it: edges){\\n            arr[it[1]]+=1;\\n            graph[it[0]].push_back(it[1]);\\n        }\\n        \\n        queue<int> q;\\n        vector<int> res;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[i]==0)\\n            {\\n                q.push(i);\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front();\\n            q.pop();\\n            for(auto it : graph[f]){\\n                arr[it]-=1;\\n                if(arr[it]==0)\\n                {\\n                    q.push(it);\\n                    res.push_back(it);\\n                }\\n            }\\n        }\\n        vector<unordered_set<int>> ans(n);\\n        vector<vector<int>> fans;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            int val = res[i];\\n            for(auto it : graph[val]){\\n                ans[it].insert(val);\\n                for(auto it2: ans[val]) ans[it].insert(it2);\\n            }\\n        }\\n        \\n        for(auto it: ans){\\n            vector<int> temp;\\n            for(auto it2: it) temp.push_back(it2);\\n            sort(temp.begin(),temp.end());\\n            fans.push_back(temp);\\n        }\\n        \\n        return fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822260,
                "title": "cpp-easisest-solution-dfs",
                "content": "**APPROACH**\\n\\n*OPTIONAL If you like the approach, make an upvote*\\n*Can comment your approach and maximum optimisation possible.*\\n\\n\\n* The question can be think just as \\n* Take a node run the dfs from it so that each and every child get covered\\n* Keep track the child by pushing in the array/set and then store it.\\n* Make sure that dont run the dfs for itself;\\n\\n*Implementation -1*\\n```\\n  vector<vector<int>> ans;\\n    void dfs(int src,vector<int> graph[],int par,vector<int> &vis,vector<int> &temp){\\n        if(src!=par) temp.push_back(src);\\n\\t\\t// only consider the child when it is not parent.\\n\\t\\t\\n        vis[src]=1;\\n\\t\\t\\n        for(int c:graph[src]) if(!vis[c]) dfs(c,graph,par,vis,temp);\\n\\t\\t// run dfs for the further childs.\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> graph[n+1];\\n        for(auto i:edges) graph[i[1]].push_back(i[0]);\\n        for(int i=0;i<n;i++){\\n            vector<int> vis(n+1,0);\\n\\t\\t\\t// for keeping track of visited\\n\\t\\t\\t\\n            vector<int> temp;\\n\\t\\t\\t// storing the child;\\n\\t\\t\\t\\n            dfs(i,graph,i,vis,temp);\\n\\t\\t\\t// passing the value i,twice and in dfs to only push child when node is not parent.\\n\\t\\t\\t\\n            sort(begin(temp),end(temp));\\n\\t\\t\\t// sorting the child received.\\n\\t\\t\\t\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n```\\n*Implementation-2*\\n```\\n vector<vector<int>> ans;\\n    void dfs(int src,vector<int> graph[],int par,set<int> &s,vector<int> &vis){\\n\\t    if(vis[src]) return;\\n\\t\\tvis[src]=1;\\n        if(src!=par) s.insert(src);\\n        for(int c:graph[src]) if(!vis[c]) dfs(c,graph,par,s,vis);\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> graph[n+1];\\n        for(auto i:edges) graph[i[1]].push_back(i[0]);\\n        for(int i=0;i<n;i++){\\n\\t\\t    set<int> s;\\n\\t\\t\\tvector<int> vis(n+1,0);\\n            dfs(i,graph,i,s,vis);\\n\\t\\t\\tvector<int> temp(begin(s),end(s));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n  vector<vector<int>> ans;\\n    void dfs(int src,vector<int> graph[],int par,vector<int> &vis,vector<int> &temp){\\n        if(src!=par) temp.push_back(src);\\n\\t\\t// only consider the child when it is not parent.\\n\\t\\t\\n        vis[src]=1;\\n\\t\\t\\n        for(int c:graph[src]) if(!vis[c]) dfs(c,graph,par,vis,temp);\\n\\t\\t// run dfs for the further childs.\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> graph[n+1];\\n        for(auto i:edges) graph[i[1]].push_back(i[0]);\\n        for(int i=0;i<n;i++){\\n            vector<int> vis(n+1,0);\\n\\t\\t\\t// for keeping track of visited\\n\\t\\t\\t\\n            vector<int> temp;\\n\\t\\t\\t// storing the child;\\n\\t\\t\\t\\n            dfs(i,graph,i,vis,temp);\\n\\t\\t\\t// passing the value i,twice and in dfs to only push child when node is not parent.\\n\\t\\t\\t\\n            sort(begin(temp),end(temp));\\n\\t\\t\\t// sorting the child received.\\n\\t\\t\\t\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n```\n```\\n vector<vector<int>> ans;\\n    void dfs(int src,vector<int> graph[],int par,set<int> &s,vector<int> &vis){\\n\\t    if(vis[src]) return;\\n\\t\\tvis[src]=1;\\n        if(src!=par) s.insert(src);\\n        for(int c:graph[src]) if(!vis[c]) dfs(c,graph,par,s,vis);\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> graph[n+1];\\n        for(auto i:edges) graph[i[1]].push_back(i[0]);\\n        for(int i=0;i<n;i++){\\n\\t\\t    set<int> s;\\n\\t\\t\\tvector<int> vis(n+1,0);\\n            dfs(i,graph,i,s,vis);\\n\\t\\t\\tvector<int> temp(begin(s),end(s));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822255,
                "title": "java-dfs-approach-explained",
                "content": "**Approach followed:**\\n1. Create a map for each `fromNode` and add its all `direct ancestors by iteraring over edges.`\\n2. Now for all the nodes, dfs for all its ancestors to add their ancestors (grand ancestors).\\n3. Sort the ancestors list and return the result.\\n\\n**Avoiding TLE**\\nKeep a visited[] when calling dfs for node\\'s ancestors. Once all ancestors are found, mark visited[node] = true.\\nIf node is already visited, it means all its ancestors are already in place. Can add them simply.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, Set<Integer>> ancestors = new HashMap<>();\\n        calculateAncestors(n, edges, ancestors);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            List l = new ArrayList<>();\\n            res.add(l);\\n            Set<Integer> set = ancestors.get(i);\\n            if (set != null) {\\n                l.addAll(set);\\n                Collections.sort(l);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void calculateAncestors(int n, int[][] edges, Map<Integer, Set<Integer>> ancestors) {\\n        for (int[] edge: edges) {\\n            Set<Integer> set = ancestors.get(edge[1]);\\n            if (set == null) {\\n                set = new HashSet<>();\\n                ancestors.put(edge[1], set);\\n            }\\n            set.add(edge[0]);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        for (int i = 0; i < n; ++i) {\\n            helper(ancestors, i, visited);\\n        }\\n    }\\n    \\n    private void helper(Map<Integer, Set<Integer>> ancestors, int to , boolean[] visited) {\\n        Set<Integer> toSet = ancestors.get(to);\\n        if (toSet == null || visited[to]) {\\n            return;\\n        }\\n        Set<Integer> latest = new HashSet<>();\\n        for (int v: toSet) {\\n            if (!visited[v]) {\\n                helper(ancestors, v, visited);\\n            }\\n                \\n            Set<Integer> set = ancestors.get(v);\\n            if (set != null) {\\n                latest.addAll(set);\\n            }\\n        }\\n        toSet.addAll(latest);\\n        visited[to] = true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, Set<Integer>> ancestors = new HashMap<>();\\n        calculateAncestors(n, edges, ancestors);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            List l = new ArrayList<>();\\n            res.add(l);\\n            Set<Integer> set = ancestors.get(i);\\n            if (set != null) {\\n                l.addAll(set);\\n                Collections.sort(l);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void calculateAncestors(int n, int[][] edges, Map<Integer, Set<Integer>> ancestors) {\\n        for (int[] edge: edges) {\\n            Set<Integer> set = ancestors.get(edge[1]);\\n            if (set == null) {\\n                set = new HashSet<>();\\n                ancestors.put(edge[1], set);\\n            }\\n            set.add(edge[0]);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        for (int i = 0; i < n; ++i) {\\n            helper(ancestors, i, visited);\\n        }\\n    }\\n    \\n    private void helper(Map<Integer, Set<Integer>> ancestors, int to , boolean[] visited) {\\n        Set<Integer> toSet = ancestors.get(to);\\n        if (toSet == null || visited[to]) {\\n            return;\\n        }\\n        Set<Integer> latest = new HashSet<>();\\n        for (int v: toSet) {\\n            if (!visited[v]) {\\n                helper(ancestors, v, visited);\\n            }\\n                \\n            Set<Integer> set = ancestors.get(v);\\n            if (set != null) {\\n                latest.addAll(set);\\n            }\\n        }\\n        toSet.addAll(latest);\\n        visited[to] = true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822170,
                "title": "c-solution-set-and-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> getAll(int node , vector<int> adj[])\\n    {\\n        \\n        vector<int> ans;\\n        \\n        set<int> s;\\n        queue<int> q;\\n        q.push(node);\\n        \\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            \\n            for(auto &it:adj[x])\\n            {\\n                if(s.find(it)==s.end())\\n                {\\n                    s.insert(it);\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        for(auto &it:s)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        \\n       \\n         vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int from=edges[i][0];\\n            int to=edges[i][1];\\n            \\n            adj[to].push_back(from);  // transpose\\n            \\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> temp=getAll(i,adj);\\n            \\n            ans.push_back(temp);\\n        }\\n        \\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> getAll(int node , vector<int> adj[])\\n    {\\n        \\n        vector<int> ans;\\n        \\n        set<int> s;\\n        queue<int> q;\\n        q.push(node);\\n        \\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            \\n            for(auto &it:adj[x])\\n            {\\n                if(s.find(it)==s.end())\\n                {\\n                    s.insert(it);\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        for(auto &it:s)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        \\n       \\n         vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int from=edges[i][0];\\n            int to=edges[i][1];\\n            \\n            adj[to].push_back(from);  // transpose\\n            \\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> temp=getAll(i,adj);\\n            \\n            ans.push_back(temp);\\n        }\\n        \\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822149,
                "title": "well-explained-graph-bfs-cpp-solution",
                "content": "```\\n// BFS\\n\\n// simply stored the edges in the opposite order (like if there is an edge from 1->2, I stored 1 in adj[2]: 2->1).  Basically i reversed the graph\\n\\n// and for each val (0->n-1) i did bfs and stored the parents in a vector and returned it\\n// Then i sorted the vector v and pushed it into ans vector\\n\\n// I hope it helps you. Please do upvote if you like my solution\\n\\nclass Solution {\\npublic:\\n    #define ll int\\n    vector<ll> fun(vector<ll>adj[],vector<ll>&vis,ll n,ll i){\\n        queue<ll>q;vector<ll>v;\\n        q.push(i);\\n        while(!q.empty()){\\n            ll i=q.front();\\n            q.pop();\\n            for(auto x:adj[i]){\\n                if(!vis[x]){\\n                    vis[x]=1;\\n                    v.push_back(x);\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<ll>adj[n];vector<vector<ll>>ans;\\n        for(ll i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(ll i=0;i<n;i++){\\n            vector<ll>vis(n,0);\\n            vis[i]=1;\\n            vector<ll>v=fun(adj,vis,n,i);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n// BFS\\n\\n// simply stored the edges in the opposite order (like if there is an edge from 1->2, I stored 1 in adj[2]: 2->1).  Basically i reversed the graph\\n\\n// and for each val (0->n-1) i did bfs and stored the parents in a vector and returned it\\n// Then i sorted the vector v and pushed it into ans vector\\n\\n// I hope it helps you. Please do upvote if you like my solution\\n\\nclass Solution {\\npublic:\\n    #define ll int\\n    vector<ll> fun(vector<ll>adj[],vector<ll>&vis,ll n,ll i){\\n        queue<ll>q;vector<ll>v;\\n        q.push(i);\\n        while(!q.empty()){\\n            ll i=q.front();\\n            q.pop();\\n            for(auto x:adj[i]){\\n                if(!vis[x]){\\n                    vis[x]=1;\\n                    v.push_back(x);\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<ll>adj[n];vector<vector<ll>>ans;\\n        for(ll i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(ll i=0;i<n;i++){\\n            vector<ll>vis(n,0);\\n            vis[i]=1;\\n            vector<ll>v=fun(adj,vis,n,i);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822136,
                "title": "java-topological-sorting",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<TreeSet<Integer>> ans = new ArrayList<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            ans.add(new TreeSet<>());\\n        }\\n        \\n        int []indegree = new int[n];\\n        \\n        for(int []edge : edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer>qu = new LinkedList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                qu.add(i);\\n            }\\n        }\\n        \\n        while(!qu.isEmpty()){\\n\\n            int top = qu.poll();\\n            \\n            for(int u:adj.get(top)){\\n                \\n                ans.get(u).add(top);\\n                ans.get(u).addAll(ans.get(top));                    \\n                indegree[u]--;\\n                    \\n                if(indegree[u]==0)\\n                qu.add(u);\\n            }\\n        }\\n        \\n        List<List<Integer>> Ancestors = new ArrayList<>();\\n        \\n        for(var x:ans)\\n            Ancestors.add(new ArrayList<>(x));\\n       \\n        \\n        return Ancestors;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<TreeSet<Integer>> ans = new ArrayList<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            ans.add(new TreeSet<>());\\n        }\\n        \\n        int []indegree = new int[n];\\n        \\n        for(int []edge : edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer>qu = new LinkedList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                qu.add(i);\\n            }\\n        }\\n        \\n        while(!qu.isEmpty()){\\n\\n            int top = qu.poll();\\n            \\n            for(int u:adj.get(top)){\\n                \\n                ans.get(u).add(top);\\n                ans.get(u).addAll(ans.get(top));                    \\n                indegree[u]--;\\n                    \\n                if(indegree[u]==0)\\n                qu.add(u);\\n            }\\n        }\\n        \\n        List<List<Integer>> Ancestors = new ArrayList<>();\\n        \\n        for(var x:ans)\\n            Ancestors.add(new ArrayList<>(x));\\n       \\n        \\n        return Ancestors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822124,
                "title": "java-solution-hashmap-set-stack",
                "content": "~~~\\n public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        Map<Integer, List<Integer>> edgesList = new HashMap<>();\\n        \\n        for(int i = 0; i < edges.length; i++) {\\n            \\n            if(!edgesList.containsKey(edges[i][1])) {\\n                edgesList.put(edges[i][1], new ArrayList<Integer>());\\n            }\\n            edgesList.get(edges[i][1]).add(edges[i][0]);\\n            \\n        }\\n                \\n        for(int i = 0; i < n; i++) {\\n            \\n            Set<Integer> set = new HashSet<>();\\n            \\n            if(edgesList.containsKey(i)) {\\n                \\n                Stack<Integer> stack = new Stack<>();\\n                stack.addAll(edgesList.get(i));\\n                \\n                while(!stack.isEmpty()) {\\n                    int current_val = stack.pop();\\n                    \\n                    if(!set.contains(current_val)) {\\n                        set.add(current_val);\\n                        if(edgesList.containsKey(current_val)) {\\n                            stack.addAll(edgesList.get(current_val));\\n                        }\\n                    }\\n                }                \\n            }\\n            \\n            List<Integer> current_list = set.stream().collect(Collectors.toList());\\n            Collections.sort(current_list);\\n            result.add(current_list);\\n        }\\n        \\n        return result;   \\n    }\\n\\n~~~",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Ordered Set"
                ],
                "code": "~~~\\n public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        Map<Integer, List<Integer>> edgesList = new HashMap<>();\\n        \\n        for(int i = 0; i < edges.length; i++) {\\n            \\n            if(!edgesList.containsKey(edges[i][1])) {\\n                edgesList.put(edges[i][1], new ArrayList<Integer>());\\n            }\\n            edgesList.get(edges[i][1]).add(edges[i][0]);\\n            \\n        }\\n                \\n        for(int i = 0; i < n; i++) {\\n            \\n            Set<Integer> set = new HashSet<>();\\n            \\n            if(edgesList.containsKey(i)) {\\n                \\n                Stack<Integer> stack = new Stack<>();\\n                stack.addAll(edgesList.get(i));\\n                \\n                while(!stack.isEmpty()) {\\n                    int current_val = stack.pop();\\n                    \\n                    if(!set.contains(current_val)) {\\n                        set.add(current_val);\\n                        if(edgesList.containsKey(current_val)) {\\n                            stack.addAll(edgesList.get(current_val));\\n                        }\\n                    }\\n                }                \\n            }\\n            \\n            List<Integer> current_list = set.stream().collect(Collectors.toList());\\n            Collections.sort(current_list);\\n            result.add(current_list);\\n        }\\n        \\n        return result;   \\n    }\\n\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 1822088,
                "title": "c-o-n-2-simple-bfs-clear-explanation",
                "content": "Using simple BFS, we find every descendant of node `i` (Say `x`). `i` will be an ancestor of `x`.\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> res;\\npublic:\\n    void bfs(vector<vector<int>>& graph, int i) {\\n        queue<int> q;\\n        vector<bool> vis(graph.size(), false);\\n        \\n        q.push(i);\\n        vis[i] = true;\\n        \\n        while(!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            for(auto &x : graph[curr]) {\\n                if(!vis[x]) {\\n                    res[x].push_back(i); // i is the ancestor of x\\n                    q.push(x);\\n                    vis[x] = true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        res = vector<vector<int>>(n);\\n        for(auto &x : edges) {\\n            graph[x[0]].push_back(x[1]);\\n        }\\n        \\n        for(int i = 0; i<n; i++) {\\n            bfs(graph, i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(n^2)\\n\\n**Liked the solution? Kindly UPVOTE!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> res;\\npublic:\\n    void bfs(vector<vector<int>>& graph, int i) {\\n        queue<int> q;\\n        vector<bool> vis(graph.size(), false);\\n        \\n        q.push(i);\\n        vis[i] = true;\\n        \\n        while(!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            for(auto &x : graph[curr]) {\\n                if(!vis[x]) {\\n                    res[x].push_back(i); // i is the ancestor of x\\n                    q.push(x);\\n                    vis[x] = true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        res = vector<vector<int>>(n);\\n        for(auto &x : edges) {\\n            graph[x[0]].push_back(x[1]);\\n        }\\n        \\n        for(int i = 0; i<n; i++) {\\n            bfs(graph, i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822064,
                "title": "c-easy-to-understand-bfs-with-detailed-comments",
                "content": "The basic idea is to do BFS in reverse, that is from child to ancestor.\\n\\nWe start at the given node and move backwards and each time we encounter a new node we add it to the BFS queue and the ancestor list\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans; //This vector will be returned in the end\\n        map<int,vector<int>> mp; //Maps the edges in reverse order so that we can efficiently traverse backwards\\n        for(auto i: edges) mp[i[1]].push_back(i[0]);\\n            \\n        for(int i = 0; i < n; ++i){  // We perform BFS for each node starting from 0\\n            vector<int> temp;  // Stores the current node\\'s ancestors\\n            set<int> st;       // To ensure we dont visit/store the same node multiple times\\n            queue<int> curr;   // Standard BFS code, stores the current set of nodes to visit\\n            queue<int> next;   // Standard BFS code, stores the nodes that will be visited in the next iteration\\n            curr.push(i);      // First node to be visited is the current node\\n              \\n            while(!curr.empty() || !next.empty()){ //Start of BFS code \\n                \\n                while(!curr.empty()){\\n\\n                    for(auto j: mp[curr.front()]){ // We iterate through the list of direct ancestors of current node\\n                        if(st.find(j) == st.end()){ // Check that the current ancestor hasnt been already traversed\\n                            next.push(j);\\n                            temp.push_back(j);\\n                            st.insert(j);\\n                        }\\n                    }\\n                    curr.pop();\\n                }\\n                while(!next.empty()){ // Move nodes from next to current queue\\n                    curr.push(next.front());\\n                    next.pop();\\n                }\\n                \\n            } // End of BFS code\\n            \\n            sort(temp.begin(), temp.end()); // Sort just in case\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans; //This vector will be returned in the end\\n        map<int,vector<int>> mp; //Maps the edges in reverse order so that we can efficiently traverse backwards\\n        for(auto i: edges) mp[i[1]].push_back(i[0]);\\n            \\n        for(int i = 0; i < n; ++i){  // We perform BFS for each node starting from 0\\n            vector<int> temp;  // Stores the current node\\'s ancestors\\n            set<int> st;       // To ensure we dont visit/store the same node multiple times\\n            queue<int> curr;   // Standard BFS code, stores the current set of nodes to visit\\n            queue<int> next;   // Standard BFS code, stores the nodes that will be visited in the next iteration\\n            curr.push(i);      // First node to be visited is the current node\\n              \\n            while(!curr.empty() || !next.empty()){ //Start of BFS code \\n                \\n                while(!curr.empty()){\\n\\n                    for(auto j: mp[curr.front()]){ // We iterate through the list of direct ancestors of current node\\n                        if(st.find(j) == st.end()){ // Check that the current ancestor hasnt been already traversed\\n                            next.push(j);\\n                            temp.push_back(j);\\n                            st.insert(j);\\n                        }\\n                    }\\n                    curr.pop();\\n                }\\n                while(!next.empty()){ // Move nodes from next to current queue\\n                    curr.push(next.front());\\n                    next.pop();\\n                }\\n                \\n            } // End of BFS code\\n            \\n            sort(temp.begin(), temp.end()); // Sort just in case\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1822054,
                "title": "python-easy-dfs-solution",
                "content": "Here instead of taking an edge from parent to child, I assume an edge from child to parent and the problem becomes easy i.e. children of a node.\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        adj = [[] for i in range(n)]\\n        for i in range(len(edges)):\\n            adj[edges[i][1]].append(edges[i][0])\\n        \\n        ans = [set() for i in range(n)]\\n        visited = [True]*n\\n            \\n        def dfs(v):\\n            visited[v] = False\\n            for i in adj[v]:\\n                ans[v].add(i)\\n                if visited[i]:\\n                    dfs(i)\\n                ans[v] = ans[v].union(ans[i])\\n        \\n        for i in range(n):\\n            if visited[i]:\\n                dfs(i)\\n                \\n        for i in range(n):\\n            ans[i] = sorted(list(ans[i]))\\n        return ans \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        adj = [[] for i in range(n)]\\n        for i in range(len(edges)):\\n            adj[edges[i][1]].append(edges[i][0])\\n        \\n        ans = [set() for i in range(n)]\\n        visited = [True]*n\\n            \\n        def dfs(v):\\n            visited[v] = False\\n            for i in adj[v]:\\n                ans[v].add(i)\\n                if visited[i]:\\n                    dfs(i)\\n                ans[v] = ans[v].union(ans[i])\\n        \\n        for i in range(n):\\n            if visited[i]:\\n                dfs(i)\\n                \\n        for i in range(n):\\n            ans[i] = sorted(list(ans[i]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821983,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n+1);\\n        for (auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<vector<int>> v;\\n        \\n        for (int i =0; i<n; i++){\\n            vector<int> temp;\\n            queue<int> q;\\n            q.push(i);\\n            set<int> vis;\\n            vis.insert(i);\\n            while(q.empty()==0){\\n                int x = q.front();\\n                q.pop();\\n                for (auto it:adj[x]){\\n                    if (vis.find(it)==vis.end()){\\n                        vis.insert(it);\\n                        temp.push_back(it);\\n                        q.push(it);\\n                    }\\n                }\\n                \\n            }\\n            sort(temp.begin(),temp.end());\\n            v.push_back(temp);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n+1);\\n        for (auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<vector<int>> v;\\n        \\n        for (int i =0; i<n; i++){\\n            vector<int> temp;\\n            queue<int> q;\\n            q.push(i);\\n            set<int> vis;\\n            vis.insert(i);\\n            while(q.empty()==0){\\n                int x = q.front();\\n                q.pop();\\n                for (auto it:adj[x]){\\n                    if (vis.find(it)==vis.end()){\\n                        vis.insert(it);\\n                        temp.push_back(it);\\n                        q.push(it);\\n                    }\\n                }\\n                \\n            }\\n            sort(temp.begin(),temp.end());\\n            v.push_back(temp);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821976,
                "title": "brute-force-solution-in-c",
                "content": "```\\nclass Solution {\\nprivate:    \\n    void dfs(int currNode,int parent,vector<int> adjList[],vector<bool>& visited,unordered_map<int,vector<int>>& ans)\\n    {\\n        if(visited[currNode])\\n            return;\\n     \\n        if(currNode != parent)\\n            ans[currNode].push_back(parent);\\n            \\n        visited[currNode]=true;\\n        \\n        for(auto& adjNode : adjList[currNode])\\n        {\\n            if(visited[adjNode] == false)\\n            {\\n                dfs(adjNode,parent,adjList,visited,ans);\\n            }\\n        }\\n    }    \\npublic:\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adjList[n];\\n        \\n        for(auto& edg : edges)\\n        {\\n            adjList[edg[0]].push_back(edg[1]);\\n        }\\n        \\n        unordered_map<int,vector<int>> ans;        \\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<bool> visited(n,false);\\n            dfs(i,i,adjList,visited,ans);\\n        }  \\n        \\n        vector<vector<int>> res;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(ans.find(i) == ans.end())\\n                res.push_back({});\\n            else\\n                res.push_back(ans[i]);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\nprivate:    \\n    void dfs(int currNode,int parent,vector<int> adjList[],vector<bool>& visited,unordered_map<int,vector<int>>& ans)\\n    {\\n        if(visited[currNode])\\n            return;\\n     \\n        if(currNode != parent)\\n            ans[currNode].push_back(parent);\\n            \\n        visited[currNode]=true;\\n        \\n        for(auto& adjNode : adjList[currNode])\\n        {\\n            if(visited[adjNode] == false)\\n            {\\n                dfs(adjNode,parent,adjList,visited,ans);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1821972,
                "title": "topological-sort-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> g[10005];\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\n        int ind[1001];\\n        memset(ind,0,sizeof ind);\\n\\n        for(auto it:edges)\\n        {\\n            int s = it[0];\\n            int d = it[1];\\n            g[s].push_back(d);\\n            ind[d]++;\\n\\n        }\\n\\n        set<int> s[n];\\n\\n        vector<vector<int>> ans(n);\\n\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i] == 0)q.push(i);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int now = q.front();\\n            q.pop();\\n\\n            for(auto v:g[now])\\n            {\\n                s[v].insert(now);\\n                for(int x: s[now])s[v].insert(x);\\n                ind[v]--;\\n                if(ind[v] == 0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int x:s[i])\\n            {\\n                ans[i].push_back(x);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> g[10005];\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\n        int ind[1001];\\n        memset(ind,0,sizeof ind);\\n\\n        for(auto it:edges)\\n        {\\n            int s = it[0];\\n            int d = it[1];\\n            g[s].push_back(d);\\n            ind[d]++;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1821951,
                "title": "c-kahn-s-algorithm-topo-sort-dfs",
                "content": "\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvoid dfs(int x,vector<vector<int>>&parents,set<int>&s){\\n\\t\\t\\t\\t\\ts.insert(x);\\n\\t\\t\\t\\t\\tfor(auto y:parents[x]){\\n\\t\\t\\t\\t\\t\\tif(s.count(y)){\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tdfs(y,parents,s);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\t\\t\\t\\t\\tvector<int>adj[n];\\n\\t\\t\\t\\t\\t// calculate Indegree of each vertex\\n\\t\\t\\t\\t\\tint in[n];\\n\\t\\t\\t\\t\\tmemset(in,0,sizeof(in));\\n\\t\\t\\t\\t\\tfor(auto x:edges)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tadj[x[0]].push_back(x[1]);\\n\\t\\t\\t\\t\\t\\tin[x[1]]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Use kahn\\'s Algorithms to traverse DAG(Directed acyclic graph).\\n\\t\\t\\t\\t\\tqueue<int>q;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0;i<n;i++){\\n\\t\\t\\t\\t\\t\\tif(in[i]==0){\\n\\t\\t\\t\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvector<vector<int>>parents(n);\\n\\t\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\t\\tauto cur = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tfor(auto x:adj[cur]){\\n\\t\\t\\t\\t\\t\\t\\tparents[x].push_back(cur);\\n\\t\\t\\t\\t\\t\\t\\tif(--in[x]==0){\\n\\t\\t\\t\\t\\t\\t\\t\\tq.push(x);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvector<vector<int>>res;\\n\\t\\t\\t\\t\\tfor(auto x:parents){\\n\\t\\t\\t\\t\\t\\t// use set data structure to store data in ascending order\\n\\t\\t\\t\\t\\t\\tset<int>s;\\n\\t\\t\\t\\t\\t\\t// Do DFS for store all parents of parents\\n\\t\\t\\t\\t\\t\\tfor(auto y:x){\\n\\t\\t\\t\\t\\t\\t\\tdfs(y,parents,s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tvector<int>temp(s.begin(),s.end());\\n\\t\\t\\t\\t\\t\\tres.push_back(temp);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvoid dfs(int x,vector<vector<int>>&parents,set<int>&s){\\n\\t\\t\\t\\t\\ts.insert(x);\\n\\t\\t\\t\\t\\tfor(auto y:parents[x]){\\n\\t\\t\\t\\t\\t\\tif(s.count(y)){\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4064410,
                "title": "java-solution-using-topological-sort-and-treeset",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        List<TreeSet<Integer>> tset = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            tset.add(new TreeSet<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n        }\\n        int[] indegree = new int[n];\\n        int[] topSort = new int[n];\\n        for(int i=0;i<adj.size();i++){\\n            for(int it : adj.get(i)){\\n                indegree[it]++;\\n            }\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                q.add(i);\\n            }\\n        }\\n        int idx=0;\\n        while(!q.isEmpty()){\\n            int curr = q.remove();\\n            topSort[idx]=curr;\\n            idx++;\\n            for(int it:adj.get(curr)){\\n                tset.get(it).addAll(new TreeSet(tset.get(curr)));\\n                tset.get(it).add(curr);\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.add(it);\\n                }\\n            }\\n        }\\n   \\n        List<List<Integer>> ancestors = new ArrayList<>();\\n        for(TreeSet<Integer> set : tset){\\n            ancestors.add(new ArrayList<>(set));\\n        }\\n       \\n        return ancestors;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        List<TreeSet<Integer>> tset = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            tset.add(new TreeSet<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n        }\\n        int[] indegree = new int[n];\\n        int[] topSort = new int[n];\\n        for(int i=0;i<adj.size();i++){\\n            for(int it : adj.get(i)){\\n                indegree[it]++;\\n            }\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                q.add(i);\\n            }\\n        }\\n        int idx=0;\\n        while(!q.isEmpty()){\\n            int curr = q.remove();\\n            topSort[idx]=curr;\\n            idx++;\\n            for(int it:adj.get(curr)){\\n                tset.get(it).addAll(new TreeSet(tset.get(curr)));\\n                tset.get(it).add(curr);\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.add(it);\\n                }\\n            }\\n        }\\n   \\n        List<List<Integer>> ancestors = new ArrayList<>();\\n        for(TreeSet<Integer> set : tset){\\n            ancestors.add(new ArrayList<>(set));\\n        }\\n       \\n        return ancestors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064220,
                "title": "cpp-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void findone(vector<vector<int>>&edges,int i,int p,vector<vector<int>>&ans,vector<bool>&vis){\\n        vis[p]=1;\\n        for(auto &x:edges[p]){\\n            if(!vis[x]){\\n                ans[x].push_back(i);\\n                findone(edges,i,x,ans,vis);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n);\\n            findone(graph,i,i,ans,vis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void findone(vector<vector<int>>&edges,int i,int p,vector<vector<int>>&ans,vector<bool>&vis){\\n        vis[p]=1;\\n        for(auto &x:edges[p]){\\n            if(!vis[x]){\\n                ans[x].push_back(i);\\n                findone(edges,i,x,ans,vis);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n);\\n            findone(graph,i,i,ans,vis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058620,
                "title": "dfs-traversal-from-child-to-parent",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst we have to adjacency list which stores all my incoming edges to that node.And then for every node We will traverse from child to parent and push back into the vector  \\n\\n# Complexity\\n- Time complexity: O(N+E) +O(N)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void dfs(int node,vector<int>&vis,map<int,vector<int>>&outedge,vector<int>&v){\\n        for(auto it:outedge[node]){\\n            if(!vis[it]){\\n                v.push_back(it);\\n                vis[it]=1;\\n                dfs(it,vis,outedge,v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int,vector<int>>outedge;\\n        vector<vector<int>>ans;\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            outedge[v].push_back(u);\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            vector<int>vis(n,0);\\n            dfs(i,vis,outedge,v);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n            v.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    void dfs(int node,vector<int>&vis,map<int,vector<int>>&outedge,vector<int>&v){\\n        for(auto it:outedge[node]){\\n            if(!vis[it]){\\n                v.push_back(it);\\n                vis[it]=1;\\n                dfs(it,vis,outedge,v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int,vector<int>>outedge;\\n        vector<vector<int>>ans;\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            outedge[v].push_back(u);\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            vector<int>vis(n,0);\\n            dfs(i,vis,outedge,v);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n            v.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058473,
                "title": "c-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int s,vector<int> &temp,vector<int> &vis,unordered_map<int,vector<int>> &mp){\\n    vis[s]=1;\\n    if(mp.count(s)){\\n        for(auto it: mp[s]){\\n            if(!vis[it]){\\n                temp.push_back(it);\\n                dfs(it,temp,vis,mp);\\n            }\\n        }\\n    }\\n}\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> mp;\\n        //storing child and their parents\\n        sort(edges.begin(),edges.end());\\n        for(auto it: edges){\\n            mp[it[1]].push_back(it[0]);\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            // set<int> st;\\n            vector<int> vis(n,0);\\n            vector<int> temp;\\n            if(!mp.count(i)){\\n                ans.push_back(temp);\\n            }\\n            else{\\n                dfs(i,temp,vis,mp);\\n                sort(temp.begin(),temp.end());\\n                ans.push_back(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int s,vector<int> &temp,vector<int> &vis,unordered_map<int,vector<int>> &mp){\\n    vis[s]=1;\\n    if(mp.count(s)){\\n        for(auto it: mp[s]){\\n            if(!vis[it]){\\n                temp.push_back(it);\\n                dfs(it,temp,vis,mp);\\n            }\\n        }\\n    }\\n}\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> mp;\\n        //storing child and their parents\\n        sort(edges.begin(),edges.end());\\n        for(auto it: edges){\\n            mp[it[1]].push_back(it[0]);\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            // set<int> st;\\n            vector<int> vis(n,0);\\n            vector<int> temp;\\n            if(!mp.count(i)){\\n                ans.push_back(temp);\\n            }\\n            else{\\n                dfs(i,temp,vis,mp);\\n                sort(temp.begin(),temp.end());\\n                ans.push_back(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055327,
                "title": "c-reversing-the-edges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2logn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int> adj[], int s, vector<int> &curr, vector<bool> &visited){\\n        visited[s] = true;\\n        for(int x: adj[s]){\\n            if(visited[x] == false){\\n                curr.push_back(x);\\n                dfs(adj, x, curr,visited);\\n            }\\n        }\\n        // visited[s] = false;\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        vector<int> adj[n];\\n        for(auto x: edges){\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            vector<int> curr;\\n            vector<bool> visited(n, false);\\n            dfs(adj, i, curr, visited);\\n            sort(curr.begin(), curr.end());\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int> adj[], int s, vector<int> &curr, vector<bool> &visited){\\n        visited[s] = true;\\n        for(int x: adj[s]){\\n            if(visited[x] == false){\\n                curr.push_back(x);\\n                dfs(adj, x, curr,visited);\\n            }\\n        }\\n        // visited[s] = false;\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        vector<int> adj[n];\\n        for(auto x: edges){\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            vector<int> curr;\\n            vector<bool> visited(n, false);\\n            dfs(adj, i, curr, visited);\\n            sort(curr.begin(), curr.end());\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048124,
                "title": "reversing-the-edges-c-dfs-easy-approach",
                "content": "```\\nvoid dfs(int node , vector<int>& ancestors , vector<int>& vis , vector<int> adj[]){\\n        \\n        vis[node] = 1;\\n        ancestors.push_back(node);\\n        \\n        for(auto it : adj[node]){\\n            \\n            if(!vis[it])\\n                dfs(it , ancestors , vis , adj);\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n        vector<vector<int>> allAncestors;\\n        \\n        for(auto it : edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i=0 ; i<n ; i++){\\n            \\n            vector<int> vis(n , 0);\\n            vector<int> ancestors;\\n            dfs(i , ancestors , vis , adj);\\n            \\n            ancestors.erase(ancestors.begin());\\n            sort(ancestors.begin() , ancestors.end());\\n            allAncestors.push_back(ancestors);\\n        }\\n        \\n        return allAncestors;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid dfs(int node , vector<int>& ancestors , vector<int>& vis , vector<int> adj[]){\\n        \\n        vis[node] = 1;\\n        ancestors.push_back(node);\\n        \\n        for(auto it : adj[node]){\\n            \\n            if(!vis[it])\\n                dfs(it , ancestors , vis , adj);\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n        vector<vector<int>> allAncestors;\\n        \\n        for(auto it : edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i=0 ; i<n ; i++){\\n            \\n            vector<int> vis(n , 0);\\n            vector<int> ancestors;\\n            dfs(i , ancestors , vis , adj);\\n            \\n            ancestors.erase(ancestors.begin());\\n            sort(ancestors.begin() , ancestors.end());\\n            allAncestors.push_back(ancestors);\\n        }\\n        \\n        return allAncestors;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034320,
                "title": "simple-dfs-beginner-s-friendly",
                "content": "# Intuition\\nSimply First reverse the Graph Edges.\\nand do dfs fromt each vertices having distinct values by taking a visited.\\nand sort the temp vector and simply pushback in the ans vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int s, vector<int>*adj,vector<int>&v,vector<bool>&visited){\\n    visited[s]=true;\\n    for(int x:adj[s]){\\n        if(!visited[x])\\n        dfs(x,adj,v,visited);\\n    }\\n    v.push_back(s);\\n}\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>t;\\n            vector<bool>visited(n,false);\\n            dfs(i,adj,t,visited);\\n            \\n            if(t.size()>0)\\n            t.pop_back();\\n            sort(t.begin(),t.end());\\n            ans[i]=t;\\n            t.clear();\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int s, vector<int>*adj,vector<int>&v,vector<bool>&visited){\\n    visited[s]=true;\\n    for(int x:adj[s]){\\n        if(!visited[x])\\n        dfs(x,adj,v,visited);\\n    }\\n    v.push_back(s);\\n}\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>t;\\n            vector<bool>visited(n,false);\\n            dfs(i,adj,t,visited);\\n            \\n            if(t.size()>0)\\n            t.pop_back();\\n            sort(t.begin(),t.end());\\n            ans[i]=t;\\n            t.clear();\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033150,
                "title": "clean-c-17-style-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndfs\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // dfs the nodes as the question denotes DAG and n <= 1000\\n        \\n        // set to save intermediate value\\n        // slow but easy to work with\\n        // can be optimized away\\n        vector<set<int>> res(n);\\n        vector<vector<int>> r;\\n        \\n        // construct graph with edges\\n        unordered_map<int, vector<int>> m;\\n        for (auto &e : edges) {\\n            auto from = e[0], to = e[1];\\n            m[from].push_back(to);            \\n        }\\n\\n        // dfs function\\n        function<void(int,int)> dfs = [&](int i, int root) -> void {\\n            // skip if visited (TLE otherwise)\\n            if (res[i].count(root)) return;\\n            \\n            // insert if node is not root\\n            if (i != root) {\\n                res[i].insert(root);\\n            }\\n\\n            // visit all children\\n            for (auto &node : m[i]) {\\n                dfs(node, root);\\n            }\\n        };\\n\\n\\n        for (int i = 0; i < n; i++) {\\n            dfs(i, i);\\n        }\\n\\n        // tranform into vector<vector<>>\\n        for (auto &s : res) {\\n            r.push_back(vector<int>(s.begin(), s.end()));\\n        } \\n\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // dfs the nodes as the question denotes DAG and n <= 1000\\n        \\n        // set to save intermediate value\\n        // slow but easy to work with\\n        // can be optimized away\\n        vector<set<int>> res(n);\\n        vector<vector<int>> r;\\n        \\n        // construct graph with edges\\n        unordered_map<int, vector<int>> m;\\n        for (auto &e : edges) {\\n            auto from = e[0], to = e[1];\\n            m[from].push_back(to);            \\n        }\\n\\n        // dfs function\\n        function<void(int,int)> dfs = [&](int i, int root) -> void {\\n            // skip if visited (TLE otherwise)\\n            if (res[i].count(root)) return;\\n            \\n            // insert if node is not root\\n            if (i != root) {\\n                res[i].insert(root);\\n            }\\n\\n            // visit all children\\n            for (auto &node : m[i]) {\\n                dfs(node, root);\\n            }\\n        };\\n\\n\\n        for (int i = 0; i < n; i++) {\\n            dfs(i, i);\\n        }\\n\\n        // tranform into vector<vector<>>\\n        for (auto &s : res) {\\n            r.push_back(vector<int>(s.begin(), s.end()));\\n        } \\n\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008602,
                "title": "easy-solution-in-python-dfs",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        adj_list=defaultdict(list)\\n        \\n        for i,j in edges:\\n            adj_list[j].append(i)\\n        \\n        arr=[[] for i in range(n)]\\n        \\n        def helper(node):            \\n            visited[node]=1\\n            for i in adj_list[node]:\\n                if visited[i]==0:\\n                    helper(i)\\n                \\n        \\n        for i in range(n):\\n            visited=[0]*n\\n            helper(i)\\n            values=[]\\n            \\n            for j in range(n):\\n                if visited[j]==1:\\n                    if i!=j:\\n                        arr[i].append(j)\\n        \\n        return arr\\n   \\n```\\n\\n![image](https://assets.leetcode.com/users/images/582e756b-bd32-49c1-bb36-b3116f96614e_1693982629.2326968.jpeg)\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        adj_list=defaultdict(list)\\n        \\n        for i,j in edges:\\n            adj_list[j].append(i)\\n        \\n        arr=[[] for i in range(n)]\\n        \\n        def helper(node):            \\n            visited[node]=1\\n            for i in adj_list[node]:\\n                if visited[i]==0:\\n                    helper(i)\\n                \\n        \\n        for i in range(n):\\n            visited=[0]*n\\n            helper(i)\\n            values=[]\\n            \\n            for j in range(n):\\n                if visited[j]==1:\\n                    if i!=j:\\n                        arr[i].append(j)\\n        \\n        return arr\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007704,
                "title": "easy-cpp-solution-brute-force-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> ans(n);\\n        unordered_map<int, int> vis;\\n\\n        map<int, vector<int>> adj;\\n        map<int, int> in;\\n        int sz = edges.size();\\n        for(int i=0; i<sz; i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            in[edges[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(in[i] == 0){\\n                vis[i] = 1;\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int ind = q.front();\\n            q.pop();\\n            vis[ind] = 1;\\n            for(auto i : adj[ind]){\\n                in[i]--;\\n                if(in[i] == 0) q.push(i);\\n                ans[i].insert(ind);\\n                for(auto j : ans[ind]){\\n                    ans[i].insert(j);\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> fans;\\n        for(auto i : ans){\\n            fans.push_back(vector<int>(i.begin(), i.end()));\\n        }\\n        return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> ans(n);\\n        unordered_map<int, int> vis;\\n\\n        map<int, vector<int>> adj;\\n        map<int, int> in;\\n        int sz = edges.size();\\n        for(int i=0; i<sz; i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            in[edges[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(in[i] == 0){\\n                vis[i] = 1;\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int ind = q.front();\\n            q.pop();\\n            vis[ind] = 1;\\n            for(auto i : adj[ind]){\\n                in[i]--;\\n                if(in[i] == 0) q.push(i);\\n                ans[i].insert(ind);\\n                for(auto j : ans[ind]){\\n                    ans[i].insert(j);\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> fans;\\n        for(auto i : ans){\\n            fans.push_back(vector<int>(i.begin(), i.end()));\\n        }\\n        return fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002170,
                "title": "easy-c-topo-sort-type",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg (n,0);\\n\\n        for(auto i:edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            indeg[i[1]]++;\\n        }\\n\\n        queue<int> qu;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            qu.push(i);\\n        }\\n        vector<set<int>> ans(n);\\n        while(!qu.empty())\\n        {\\n            int root = qu.front();qu.pop();\\n            for(int i=0;i<adj[root].size();i++)\\n            {\\n                ans[adj[root][i]].insert(root);\\n                for(auto j:ans[root])\\n                {\\n                    ans[adj[root][i]].insert(j);\\n                }\\n                indeg[adj[root][i]]--;\\n                if(indeg[adj[root][i]]==0)\\n                {\\n                    qu.push(adj[root][i]);\\n                }\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int> st = ans[i];\\n            vector<int> v;\\n            for(auto i:st){\\n                v.push_back(i);\\n            }\\n            res.push_back(v);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg (n,0);\\n\\n        for(auto i:edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            indeg[i[1]]++;\\n        }\\n\\n        queue<int> qu;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            qu.push(i);\\n        }\\n        vector<set<int>> ans(n);\\n        while(!qu.empty())\\n        {\\n            int root = qu.front();qu.pop();\\n            for(int i=0;i<adj[root].size();i++)\\n            {\\n                ans[adj[root][i]].insert(root);\\n                for(auto j:ans[root])\\n                {\\n                    ans[adj[root][i]].insert(j);\\n                }\\n                indeg[adj[root][i]]--;\\n                if(indeg[adj[root][i]]==0)\\n                {\\n                    qu.push(adj[root][i]);\\n                }\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int> st = ans[i];\\n            vector<int> v;\\n            for(auto i:st){\\n                v.push_back(i);\\n            }\\n            res.push_back(v);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996319,
                "title": "2192-java-100-45ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst throught is that in given graph we have to sort it down because ecah node is dpenedent on other for finding all the ancestors.\\n\\nSo I sorted it down using topological sort. Then after we have the order of the nodes stored in stack we need to just simply iterate over it and keep inserting the currentNode\\'s values and currentNode\\'s ancestors into the neighbor node\\'s list.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor topological sort to get the order of nodes:\\n```\\nvoid topologicalVisit(Map < Integer, List < Integer >> map, int i, Stack < Integer > stack, boolean[] visited) {\\n      if (map.containsKey(i)) {\\n        for (int neighbor: map.get(i)) {\\n          if (!visited[neighbor]) {\\n            topologicalVisit(map, neighbor, stack, visited);\\n          }\\n        }\\n      }\\n      visited[i] = true;\\n      stack.push(i);\\n    }\\n\\n    public Stack < Integer > topologicalSort(Map < Integer, List < Integer >> map, int n, boolean[] visited) {\\n      Stack < Integer > stack = new Stack < > ();\\n      for (int i = 0; i < n; i++) {\\n        if (!visited[i]) {\\n          topologicalVisit(map, i, stack, visited);\\n        }\\n      }\\n\\n      return stack;\\n    }\\n```\\n\\nFor insertion of currentNode\\'s value and it\\'s ancestor into neighbor\\'s list.\\nI have used Binary Search insertion for inserting currentNode\\'s value :\\n```\\nvoid binarySearchInsert (List<Integer> list, int val) {\\n        int n = list.size();\\n            if(list.size()==0 || list.get(n-1) < val)\\n                list.add(val);\\n            else{\\n                int k=0;\\n                int l=n;\\n                while(k<l){\\n                    int mid = (k+l)/2;\\n                    if(list.get(mid) == val)\\n                    return;\\n                    if(list.get(mid)<val)\\n                        k=mid+1;\\n                    else\\n                        l=mid;\\n                }\\n                list.add(k, val);\\n            }\\n\\n    }\\n```\\n\\n\\n & merging the currentNode\\'s ancestors I have used mergeSortedLists() similar to used in merge sort: \\n```\\npublic static void mergeSortedLists(List<Integer> list1, List<Integer> list2) {\\n        int i = 0, j = 0;\\n\\n        while (i < list1.size() && j < list2.size()) {\\n            int num1 = list1.get(i);\\n            int num2 = list2.get(j);\\n\\n            if(num1 == num2) {\\n               i++;\\n               j++;\\n            }else if (num1 < num2) {\\n                list2.add(j, num1);\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        while (i < list1.size()) {\\n            list2.add(list1.get(i));\\n            i++;\\n        }\\n    }\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List < List < Integer >> getAncestors(int n, int[][] edges) {\\n      Map < Integer, List < Integer >> map = new HashMap < > ();\\n      for (int[] edge: edges) {\\n        map.computeIfAbsent(edge[0], value -> new ArrayList < Integer > ()).add(edge[1]);\\n      }\\n\\n      boolean[] visited = new boolean[n];\\n      Stack < Integer > stack = topologicalSort(map, n, visited);\\n\\n      List < List < Integer >> list = new ArrayList < > (n);\\n      for (int i = 0; i < n; i++) {\\n             list.add(new ArrayList<>());\\n        }\\n      while (!stack.isEmpty()) {\\n        int node = stack.pop();\\n        //System.out.print(node + \" \");\\n        if (map.containsKey(node)) {\\n          for (int neighbor: map.get(node)) {\\n             binarySearchInsert(list.get(neighbor), node); \\n\\n            if (list.get(node).size()>0) \\n                mergeSortedLists(list.get(node), list.get(neighbor));\\n          }\\n        }\\n      }\\n\\n      return list;\\n    }\\n\\n    void topologicalVisit(Map < Integer, List < Integer >> map, int i, Stack < Integer > stack, boolean[] visited) {\\n      if (map.containsKey(i)) {\\n        for (int neighbor: map.get(i)) {\\n          if (!visited[neighbor]) {\\n            topologicalVisit(map, neighbor, stack, visited);\\n          }\\n        }\\n      }\\n      visited[i] = true;\\n      stack.push(i);\\n    }\\n\\n    public Stack < Integer > topologicalSort(Map < Integer, List < Integer >> map, int n, boolean[] visited) {\\n      Stack < Integer > stack = new Stack < > ();\\n      for (int i = 0; i < n; i++) {\\n        if (!visited[i]) {\\n          topologicalVisit(map, i, stack, visited);\\n        }\\n      }\\n\\n      return stack;\\n    }\\n\\n    void binarySearchInsert (List<Integer> list, int val) {\\n        int n = list.size();\\n            if(list.size()==0 || list.get(n-1) < val)\\n                list.add(val);\\n            else{\\n                int k=0;\\n                int l=n;\\n                while(k<l){\\n                    int mid = (k+l)/2;\\n                    if(list.get(mid) == val)\\n                    return;\\n                    if(list.get(mid)<val)\\n                        k=mid+1;\\n                    else\\n                        l=mid;\\n                }\\n                list.add(k, val);\\n            }\\n\\n    }\\n\\n    public static void mergeSortedLists(List<Integer> list1, List<Integer> list2) {\\n        int i = 0, j = 0;\\n\\n        while (i < list1.size() && j < list2.size()) {\\n            int num1 = list1.get(i);\\n            int num2 = list2.get(j);\\n\\n            if(num1 == num2) {\\n               i++;\\n               j++;\\n            }else if (num1 < num2) {\\n                list2.add(j, num1);\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        while (i < list1.size()) {\\n            list2.add(list1.get(i));\\n            i++;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Graph",
                    "Topological Sort",
                    "Merge Sort"
                ],
                "code": "```\\nvoid topologicalVisit(Map < Integer, List < Integer >> map, int i, Stack < Integer > stack, boolean[] visited) {\\n      if (map.containsKey(i)) {\\n        for (int neighbor: map.get(i)) {\\n          if (!visited[neighbor]) {\\n            topologicalVisit(map, neighbor, stack, visited);\\n          }\\n        }\\n      }\\n      visited[i] = true;\\n      stack.push(i);\\n    }\\n\\n    public Stack < Integer > topologicalSort(Map < Integer, List < Integer >> map, int n, boolean[] visited) {\\n      Stack < Integer > stack = new Stack < > ();\\n      for (int i = 0; i < n; i++) {\\n        if (!visited[i]) {\\n          topologicalVisit(map, i, stack, visited);\\n        }\\n      }\\n\\n      return stack;\\n    }\\n```\n```\\nvoid binarySearchInsert (List<Integer> list, int val) {\\n        int n = list.size();\\n            if(list.size()==0 || list.get(n-1) < val)\\n                list.add(val);\\n            else{\\n                int k=0;\\n                int l=n;\\n                while(k<l){\\n                    int mid = (k+l)/2;\\n                    if(list.get(mid) == val)\\n                    return;\\n                    if(list.get(mid)<val)\\n                        k=mid+1;\\n                    else\\n                        l=mid;\\n                }\\n                list.add(k, val);\\n            }\\n\\n    }\\n```\n```\\npublic static void mergeSortedLists(List<Integer> list1, List<Integer> list2) {\\n        int i = 0, j = 0;\\n\\n        while (i < list1.size() && j < list2.size()) {\\n            int num1 = list1.get(i);\\n            int num2 = list2.get(j);\\n\\n            if(num1 == num2) {\\n               i++;\\n               j++;\\n            }else if (num1 < num2) {\\n                list2.add(j, num1);\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        while (i < list1.size()) {\\n            list2.add(list1.get(i));\\n            i++;\\n        }\\n    }\\n```\n```\\nclass Solution {\\n    public List < List < Integer >> getAncestors(int n, int[][] edges) {\\n      Map < Integer, List < Integer >> map = new HashMap < > ();\\n      for (int[] edge: edges) {\\n        map.computeIfAbsent(edge[0], value -> new ArrayList < Integer > ()).add(edge[1]);\\n      }\\n\\n      boolean[] visited = new boolean[n];\\n      Stack < Integer > stack = topologicalSort(map, n, visited);\\n\\n      List < List < Integer >> list = new ArrayList < > (n);\\n      for (int i = 0; i < n; i++) {\\n             list.add(new ArrayList<>());\\n        }\\n      while (!stack.isEmpty()) {\\n        int node = stack.pop();\\n        //System.out.print(node + \" \");\\n        if (map.containsKey(node)) {\\n          for (int neighbor: map.get(node)) {\\n             binarySearchInsert(list.get(neighbor), node); \\n\\n            if (list.get(node).size()>0) \\n                mergeSortedLists(list.get(node), list.get(neighbor));\\n          }\\n        }\\n      }\\n\\n      return list;\\n    }\\n\\n    void topologicalVisit(Map < Integer, List < Integer >> map, int i, Stack < Integer > stack, boolean[] visited) {\\n      if (map.containsKey(i)) {\\n        for (int neighbor: map.get(i)) {\\n          if (!visited[neighbor]) {\\n            topologicalVisit(map, neighbor, stack, visited);\\n          }\\n        }\\n      }\\n      visited[i] = true;\\n      stack.push(i);\\n    }\\n\\n    public Stack < Integer > topologicalSort(Map < Integer, List < Integer >> map, int n, boolean[] visited) {\\n      Stack < Integer > stack = new Stack < > ();\\n      for (int i = 0; i < n; i++) {\\n        if (!visited[i]) {\\n          topologicalVisit(map, i, stack, visited);\\n        }\\n      }\\n\\n      return stack;\\n    }\\n\\n    void binarySearchInsert (List<Integer> list, int val) {\\n        int n = list.size();\\n            if(list.size()==0 || list.get(n-1) < val)\\n                list.add(val);\\n            else{\\n                int k=0;\\n                int l=n;\\n                while(k<l){\\n                    int mid = (k+l)/2;\\n                    if(list.get(mid) == val)\\n                    return;\\n                    if(list.get(mid)<val)\\n                        k=mid+1;\\n                    else\\n                        l=mid;\\n                }\\n                list.add(k, val);\\n            }\\n\\n    }\\n\\n    public static void mergeSortedLists(List<Integer> list1, List<Integer> list2) {\\n        int i = 0, j = 0;\\n\\n        while (i < list1.size() && j < list2.size()) {\\n            int num1 = list1.get(i);\\n            int num2 = list2.get(j);\\n\\n            if(num1 == num2) {\\n               i++;\\n               j++;\\n            }else if (num1 < num2) {\\n                list2.add(j, num1);\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        while (i < list1.size()) {\\n            list2.add(list1.get(i));\\n            i++;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995225,
                "title": "easy-topological-sorting-java-c-python",
                "content": "# Approach\\nUsing topological sorting to process the nodes. You can look into an explanation in the linked video: \\n\\n# Complexity\\n- Time complexity: O(n^2logn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n\\n```java []\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        int [] indegrees = new int[n];\\n        List<List<Integer>> result = new ArrayList();\\n\\n        //build our adjacency list\\n        for(int k = 0; k < n; k++){\\n            adj[k] = new ArrayList();\\n            result.add(new ArrayList());\\n        }\\n        for(int [] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            indegrees[v]++;\\n            adj[u].add(v);\\n        }\\n\\n        Queue<Integer> q = new LinkedList();\\n        for(int k = 0; k < n; k++){\\n            if(indegrees[k] == 0){\\n                q.add(k);\\n            }\\n        }\\n\\n        while(!q.isEmpty()){\\n            int current = q.poll();\\n            for(int neighbor : adj[current]){\\n                Set<Integer> set = new HashSet(result.get(current)); //all the ancestors of the current\\n                set.add(current); //add current as an ancestor\\n                set.addAll(result.get(neighbor)); //ancestors of our neighbor\\n                indegrees[neighbor]--;\\n                if(indegrees[neighbor] == 0){\\n                    q.add(neighbor);\\n                }\\n                List<Integer> list = new ArrayList(set);\\n                Collections.sort(list);\\n                result.set(neighbor, list);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj = defaultdict(list)\\n        indegrees = [0] * n\\n        result = [[] for _ in range(n)]\\n        \\n        # build adjacency list\\n        for u, v in edges:\\n            indegrees[v] += 1\\n            adj[u].append(v)\\n\\n        q = deque([i for i in range(n) if indegrees[i] == 0])\\n\\n        while q:\\n            current = q.popleft()\\n            for neighbor in adj[current]:\\n                ancestor_set = set(result[current])\\n                ancestor_set.add(current)\\n                ancestor_set.update(result[neighbor])\\n                \\n                indegrees[neighbor] -= 1\\n                if indegrees[neighbor] == 0:\\n                    q.append(neighbor)\\n                \\n                result[neighbor] = sorted(list(ancestor_set))\\n\\n        return result\\n\\n```\\n```C++ []\\n#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <unordered_set>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, const vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indegrees(n, 0);\\n        vector<vector<int>> result(n);\\n\\n        // Build adjacency list\\n        for(auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            indegrees[v]++;\\n            adj[u].push_back(v);\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0; i < n; i++) {\\n            if(indegrees[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()) {\\n            int current = q.front();\\n            q.pop();\\n            for(int neighbor : adj[current]) {\\n                unordered_set<int> ancestor_set(result[current].begin(), result[current].end());\\n                ancestor_set.insert(current);\\n                ancestor_set.insert(result[neighbor].begin(), result[neighbor].end());\\n\\n                indegrees[neighbor]--;\\n                if(indegrees[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n\\n                result[neighbor].assign(ancestor_set.begin(), ancestor_set.end());\\n                sort(result[neighbor].begin(), result[neighbor].end());\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```java []\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        int [] indegrees = new int[n];\\n        List<List<Integer>> result = new ArrayList();\\n\\n        //build our adjacency list\\n        for(int k = 0; k < n; k++){\\n            adj[k] = new ArrayList();\\n            result.add(new ArrayList());\\n        }\\n        for(int [] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            indegrees[v]++;\\n            adj[u].add(v);\\n        }\\n\\n        Queue<Integer> q = new LinkedList();\\n        for(int k = 0; k < n; k++){\\n            if(indegrees[k] == 0){\\n                q.add(k);\\n            }\\n        }\\n\\n        while(!q.isEmpty()){\\n            int current = q.poll();\\n            for(int neighbor : adj[current]){\\n                Set<Integer> set = new HashSet(result.get(current)); //all the ancestors of the current\\n                set.add(current); //add current as an ancestor\\n                set.addAll(result.get(neighbor)); //ancestors of our neighbor\\n                indegrees[neighbor]--;\\n                if(indegrees[neighbor] == 0){\\n                    q.add(neighbor);\\n                }\\n                List<Integer> list = new ArrayList(set);\\n                Collections.sort(list);\\n                result.set(neighbor, list);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj = defaultdict(list)\\n        indegrees = [0] * n\\n        result = [[] for _ in range(n)]\\n        \\n        # build adjacency list\\n        for u, v in edges:\\n            indegrees[v] += 1\\n            adj[u].append(v)\\n\\n        q = deque([i for i in range(n) if indegrees[i] == 0])\\n\\n        while q:\\n            current = q.popleft()\\n            for neighbor in adj[current]:\\n                ancestor_set = set(result[current])\\n                ancestor_set.add(current)\\n                ancestor_set.update(result[neighbor])\\n                \\n                indegrees[neighbor] -= 1\\n                if indegrees[neighbor] == 0:\\n                    q.append(neighbor)\\n                \\n                result[neighbor] = sorted(list(ancestor_set))\\n\\n        return result\\n\\n```\n```C++ []\\n#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <unordered_set>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, const vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indegrees(n, 0);\\n        vector<vector<int>> result(n);\\n\\n        // Build adjacency list\\n        for(auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            indegrees[v]++;\\n            adj[u].push_back(v);\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0; i < n; i++) {\\n            if(indegrees[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()) {\\n            int current = q.front();\\n            q.pop();\\n            for(int neighbor : adj[current]) {\\n                unordered_set<int> ancestor_set(result[current].begin(), result[current].end());\\n                ancestor_set.insert(current);\\n                ancestor_set.insert(result[neighbor].begin(), result[neighbor].end());\\n\\n                indegrees[neighbor]--;\\n                if(indegrees[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n\\n                result[neighbor].assign(ancestor_set.begin(), ancestor_set.end());\\n                sort(result[neighbor].begin(), result[neighbor].end());\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3979160,
                "title": "cpp-solution-kahn-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        vector<set<int>> st(n);\\n        vector<int> inDegree(n);\\n        queue<int> store;\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            inDegree[edge[1]]++;\\n        }\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(inDegree[i] == 0)\\n            {\\n                store.push(i);\\n            }\\n        }\\n        while(!store.empty())\\n        {\\n            int node = store.front();\\n            store.pop();\\n            for(auto i : adj[node])\\n            {\\n                for(auto j : st[node])\\n                {\\n                    st[i].insert(j);\\n                }\\n                st[i].insert(node);\\n                inDegree[i]--;\\n                 if(inDegree[i] == 0)\\n                 {\\n                    store.push(i);\\n                 }\\n            }\\n        }\\n        vector<vector<int>> answer(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(auto j : st[i])\\n            {\\n                answer[i].push_back(j);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        vector<set<int>> st(n);\\n        vector<int> inDegree(n);\\n        queue<int> store;\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            inDegree[edge[1]]++;\\n        }\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(inDegree[i] == 0)\\n            {\\n                store.push(i);\\n            }\\n        }\\n        while(!store.empty())\\n        {\\n            int node = store.front();\\n            store.pop();\\n            for(auto i : adj[node])\\n            {\\n                for(auto j : st[node])\\n                {\\n                    st[i].insert(j);\\n                }\\n                st[i].insert(node);\\n                inDegree[i]--;\\n                 if(inDegree[i] == 0)\\n                 {\\n                    store.push(i);\\n                 }\\n            }\\n        }\\n        vector<vector<int>> answer(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(auto j : st[i])\\n            {\\n                answer[i].push_back(j);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977961,
                "title": "reverse-traversal-from-child-to-parent-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    void dfs(int i, vector<int>&p, vector<int> &v)\\n    {\\n        v[i]=1;\\n        cout<<i<<\" \";\\n        for(auto t: g[i])\\n        {\\n            if(!v[t])\\n            {\\n                p.push_back(t);\\n                dfs(t,p,v);\\n            }\\n        }\\n        \\n       \\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        g.resize(n);\\n        for(auto i: edges)\\n        {\\n            g[i[1]].push_back(i[0]);  // child to parent easy  to trace parents other wise it touch to traverse back all \\n            // now all possible paths nodes from childs gives parents node \\n            \\n        }\\n        vector<vector<int>> ans(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> v(n,0);\\n            vector<int> p;\\n            dfs(i,p,v);\\n            sort(p.begin(),p.end());\\n            ans[i]=p;\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    void dfs(int i, vector<int>&p, vector<int> &v)\\n    {\\n        v[i]=1;\\n        cout<<i<<\" \";\\n        for(auto t: g[i])\\n        {\\n            if(!v[t])\\n            {\\n                p.push_back(t);\\n                dfs(t,p,v);\\n            }\\n        }\\n        \\n       \\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        g.resize(n);\\n        for(auto i: edges)\\n        {\\n            g[i[1]].push_back(i[0]);  // child to parent easy  to trace parents other wise it touch to traverse back all \\n            // now all possible paths nodes from childs gives parents node \\n            \\n        }\\n        vector<vector<int>> ans(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> v(n,0);\\n            vector<int> p;\\n            dfs(i,p,v);\\n            sort(p.begin(),p.end());\\n            ans[i]=p;\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3963213,
                "title": "c-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,vector<int>&v){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            \\n            if(!vis[it]){\\n                v.push_back(it);\\n                dfs(it,vis,adj,v);\\n\\n            }\\n\\n\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        vector<vector<int>>ans(n);\\n        for(auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>v;\\n            vector<int>vis(n,0);\\n             if(!vis[i])\\n            dfs(i,vis,adj,v);\\n            sort(v.begin(),v.end());\\n            ans[i]=v;\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,vector<int>&v){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            \\n            if(!vis[it]){\\n                v.push_back(it);\\n                dfs(it,vis,adj,v);\\n\\n            }\\n\\n\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        vector<vector<int>>ans(n);\\n        for(auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>v;\\n            vector<int>vis(n,0);\\n             if(!vis[i])\\n            dfs(i,vis,adj,v);\\n            sort(v.begin(),v.end());\\n            ans[i]=v;\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953193,
                "title": "dfs",
                "content": "# Intuition\\nReverse the directions of given graph and appending the path from the DFS traversal of that node\\n\\n# Approach\\nCreate an adj list contains opposite directions and do DFS for all the nodes \\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj=defaultdict(list)\\n        for s,d in edges:\\n            adj[d].append(s)\\n        ans=[]\\n        for i in range(n):\\n            temp=set()\\n            stack=[i]\\n            visited=[False]*n\\n            while stack:\\n                node=stack.pop()\\n                visited[node]=True\\n                for nei in adj[node]:\\n                    if not visited[nei]:\\n                        stack.append(nei)\\n                        temp.add(nei)\\n            temp=list(temp)\\n            temp.sort()       \\n            ans.append(temp)\\n        return ans\\n\\n            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj=defaultdict(list)\\n        for s,d in edges:\\n            adj[d].append(s)\\n        ans=[]\\n        for i in range(n):\\n            temp=set()\\n            stack=[i]\\n            visited=[False]*n\\n            while stack:\\n                node=stack.pop()\\n                visited[node]=True\\n                for nei in adj[node]:\\n                    if not visited[nei]:\\n                        stack.append(nei)\\n                        temp.add(nei)\\n            temp=list(temp)\\n            temp.sort()       \\n            ans.append(temp)\\n        return ans\\n\\n            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953006,
                "title": "java-solution-dfs",
                "content": "class Solution {\\n    Map<Integer, Set<Integer>> ancestors_set;\\n    Map<Integer, Set<Integer>> graph;\\n    boolean visited[];\\n    \\n    private void dfs(int node) {\\n        visited[node]=true;\\n        if (graph.containsKey(node))\\n        {\\n            for(Integer neighbor:graph.get(node)) \\n            {\\n                if(visited[neighbor]==false)\\n                    dfs(neighbor);\\n                \\n                Set<Integer> current_set=new HashSet<>();\\n                \\n                if(ancestors_set.containsKey(neighbor))\\n                    current_set.addAll(ancestors_set.get(neighbor));\\n                current_set.add(neighbor);\\n                ancestors_set.putIfAbsent(node, new HashSet<>());\\n                ancestors_set.get(node).addAll(current_set);\\n            }\\n        }\\n    }\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ancestors_list=new ArrayList<List<Integer>>();\\n        \\n        ancestors_set=new HashMap<>();\\n        graph=new HashMap<>();\\n        visited=new boolean[n];\\n        \\n        for(int i=0; i<edges.length; i++)\\n        {//building reverse graph\\n            int u=edges[i][1], v=edges[i][0];\\n            \\n            graph.putIfAbsent(u, new HashSet<>());\\n            graph.get(u).add(v);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {            \\n            if(visited[i]==false)\\n                dfs(i);\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            ancestors_list.add(new ArrayList<>());\\n            if(ancestors_set.containsKey(i))\\n            {\\n                for(Integer ancestor:ancestors_set.get(i))\\n                {\\n                    ancestors_list.get(i).add(ancestor);\\n                    Collections.sort(ancestors_list.get(i));\\n                }\\n            }\\n        }\\n        \\n        return ancestors_list;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    Map<Integer, Set<Integer>> ancestors_set;\\n    Map<Integer, Set<Integer>> graph;\\n    boolean visited[];\\n    \\n    private void dfs(int node) {\\n        visited[node]=true;\\n        if (graph.containsKey(node))\\n        {\\n            for(Integer neighbor:graph.get(node)) \\n            {\\n                if(visited[neighbor]==false)\\n                    dfs(neighbor);\\n                \\n                Set<Integer> current_set=new HashSet<>();\\n                \\n                if(ancestors_set.containsKey(neighbor))\\n                    current_set.addAll(ancestors_set.get(neighbor));\\n                current_set.add(neighbor);\\n                ancestors_set.putIfAbsent(node, new HashSet<>());\\n                ancestors_set.get(node).addAll(current_set);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3943120,
                "title": "java-clean-and-simple-dynamic-programming",
                "content": "```\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.IntStream;\\n\\nimport static java.util.Arrays.stream;\\nimport static java.util.Collections.emptyList;\\nimport static java.util.stream.Collectors.groupingBy;\\nimport static java.util.stream.Collectors.mapping;\\nimport static java.util.stream.Collectors.toList;\\nimport static java.util.stream.Stream.concat;\\n\\n\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private List<Integer>[] dp;\\n\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        this.dp = new List[n];\\n        this.graph = stream(edges).collect(groupingBy(x -> x[1], mapping(x -> x[0], toList())));\\n\\n        return IntStream.range(0, n).mapToObj(this::ancestors).toList();\\n    }\\n\\n    private List<Integer> ancestors(int u) {\\n        if (dp[u] == null) {\\n            var neighbors = graph.getOrDefault(u, emptyList());\\n\\n            var a = neighbors.stream();\\n            var b = neighbors.stream().map(this::ancestors).flatMap(List::stream);\\n\\n            dp[u] = concat(a, b).distinct().sorted().toList();\\n        }\\n        \\n        return dp[u];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.IntStream;\\n\\nimport static java.util.Arrays.stream;\\nimport static java.util.Collections.emptyList;\\nimport static java.util.stream.Collectors.groupingBy;\\nimport static java.util.stream.Collectors.mapping;\\nimport static java.util.stream.Collectors.toList;\\nimport static java.util.stream.Stream.concat;\\n\\n\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private List<Integer>[] dp;\\n\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        this.dp = new List[n];\\n        this.graph = stream(edges).collect(groupingBy(x -> x[1], mapping(x -> x[0], toList())));\\n\\n        return IntStream.range(0, n).mapToObj(this::ancestors).toList();\\n    }\\n\\n    private List<Integer> ancestors(int u) {\\n        if (dp[u] == null) {\\n            var neighbors = graph.getOrDefault(u, emptyList());\\n\\n            var a = neighbors.stream();\\n            var b = neighbors.stream().map(this::ancestors).flatMap(List::stream);\\n\\n            dp[u] = concat(a, b).distinct().sorted().toList();\\n        }\\n        \\n        return dp[u];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942152,
                "title": "python-clean-dfs-dynamic-programming-solution",
                "content": "```\\nfrom collections import defaultdict\\nfrom functools import cache, reduce\\n\\n\\nclass Solution:\\n\\n    def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\\n        g = self.create_graph(edges)\\n\\n        @cache\\n        def ancestors(u: int) -> set[int]:\\n            return reduce(set.union, map(ancestors, g[u]), set(g[u]))\\n\\n        return [ancestors(i) for i in range(n)]\\n\\n    @staticmethod\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for u, v in edges:\\n            g[v].append(u)\\n\\n        return g\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import cache, reduce\\n\\n\\nclass Solution:\\n\\n    def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\\n        g = self.create_graph(edges)\\n\\n        @cache\\n        def ancestors(u: int) -> set[int]:\\n            return reduce(set.union, map(ancestors, g[u]), set(g[u]))\\n\\n        return [ancestors(i) for i in range(n)]\\n\\n    @staticmethod\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for u, v in edges:\\n            g[v].append(u)\\n\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939557,
                "title": "c-simple-dfs-with-slight-optimization",
                "content": "# Intuition\\nSee the problem in slightly different manner if possible, like a node to be an ancestor how does the node qualify?\\nLet us have an example if there is `node 0` which is connected to `node 4 and node 5`, `node 0` becomes the ancestor and also node 5 can be connected to more nodes, which means that must also have `node 0` as an ancestor.\\n\\nSo for each node go through it\\'s adjacency list and perform a DFS to put that node which can be an ancestor for all the nodes, this way assures that we are keeping the sortedness of the ancestor also!\\n\\n# Approach\\nCreate a adjacency list and for each node starting from 0 do a simple DFS with slightly optimized manner, (`we can use a visited array, but since we know which element we are starting DFS from, we can simply avoid visited and rather check if we have already pushed the element into the ancestor of the current node that we are visiting`).\\n\\n# Complexity\\n- Time complexity:\\nO(N*N) - In worst case we end up doing DFS for all n-1 node (So n*(n-1) ~ n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N) + O(N*N) - recursion Stack space + Adjacency list we have created\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<vector<int>> &ans, int start, int curr) {\\n        for(auto &node:adj[curr]) {\\n            if(ans[node].empty() || ans[node].back() != start) {\\n                ans[node].push_back(start);\\n                dfs(adj, ans, start, node);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto &it:edges) {\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        vector<vector<int>> ans(n);\\n        for(int i=0;i<n;i++) {\\n            dfs(adj, ans, i, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<vector<int>> &ans, int start, int curr) {\\n        for(auto &node:adj[curr]) {\\n            if(ans[node].empty() || ans[node].back() != start) {\\n                ans[node].push_back(start);\\n                dfs(adj, ans, start, node);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto &it:edges) {\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        vector<vector<int>> ans(n);\\n        for(int i=0;i<n;i++) {\\n            dfs(adj, ans, i, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937602,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) { \\n        vector<vector<int>> ans(n), g(n);\\n        \\n        for (const auto& edge : edges) {\\n            g[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            vector<bool> vis(n);\\n            dfs(g, i, i, ans, vis);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(const vector<vector<int>>& g, int i, int j, vector<vector<int>>& ans, vector<bool>& vis) {\\n        vis[j] = true;\\n        \\n        for (int x : g[j]) {\\n            if (!vis[x]) {\\n                ans[x].push_back(i);\\n                dfs(g, i, x, ans, vis);\\n            }\\n        }\\n    } \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) { \\n        vector<vector<int>> ans(n), g(n);\\n        \\n        for (const auto& edge : edges) {\\n            g[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            vector<bool> vis(n);\\n            dfs(g, i, i, ans, vis);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(const vector<vector<int>>& g, int i, int j, vector<vector<int>>& ans, vector<bool>& vis) {\\n        vis[j] = true;\\n        \\n        for (int x : g[j]) {\\n            if (!vis[x]) {\\n                ans[x].push_back(i);\\n                dfs(g, i, x, ans, vis);\\n            }\\n        }\\n    } \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934273,
                "title": "2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph",
                "content": "```\\nclass Solution:\\n  def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    ans = [[] for _ in range(n)]\\n    graph = [[] for _ in range(n)]\\n\\n    for u, v in edges:\\n      graph[u].append(v)\\n\\n    def dfs(u: int, ancestor: int, seen: Set[int]) -> None:\\n      seen.add(u)\\n      for v in graph[u]:\\n        if v in seen:\\n          continue\\n        ans[v].append(ancestor)\\n        dfs(v, ancestor, seen)\\n\\n    for i in range(n):\\n      dfs(i, i, set())\\n\\n    return ans",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n  def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    ans = [[] for _ in range(n)]\\n    graph = [[] for _ in range(n)]\\n\\n    for u, v in edges:\\n      graph[u].append(v)\\n\\n    def dfs(u: int, ancestor: int, seen: Set[int]) -> None:\\n      seen.add(u)\\n      for v in graph[u]:\\n        if v in seen:\\n          continue\\n        ans[v].append(ancestor)\\n        dfs(v, ancestor, seen)\\n\\n    for i in range(n):\\n      dfs(i, i, set())\\n\\n    return ans",
                "codeTag": "Java"
            },
            {
                "id": 3911278,
                "title": "fast-af-python-solution-91-89",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def getAncestors(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        tree = defaultdict(list)\\n        for src, dest in edges:\\n            tree[dest].append(src)\\n\\n        cache = {}\\n        \\n        def getAllAncestors(currNode):\\n            if currNode in cache:\\n                return cache[currNode]\\n            if not tree[currNode]:\\n                return set([currNode])\\n\\n            newList = set()\\n            for parent in tree[currNode]:\\n                newList.add(parent)\\n                newList.update(getAllAncestors(parent))\\n\\n            cache[currNode] = newList\\n            return newList\\n\\n        ret = []\\n        for i in range(0, n):\\n            if not tree[i]:\\n                ret.append([])\\n                continue\\n            temp = getAllAncestors(i)\\n            ret.append(temp)\\n\\n        return map(sorted, ret)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getAncestors(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        tree = defaultdict(list)\\n        for src, dest in edges:\\n            tree[dest].append(src)\\n\\n        cache = {}\\n        \\n        def getAllAncestors(currNode):\\n            if currNode in cache:\\n                return cache[currNode]\\n            if not tree[currNode]:\\n                return set([currNode])\\n\\n            newList = set()\\n            for parent in tree[currNode]:\\n                newList.add(parent)\\n                newList.update(getAllAncestors(parent))\\n\\n            cache[currNode] = newList\\n            return newList\\n\\n        ret = []\\n        for i in range(0, n):\\n            if not tree[i]:\\n                ret.append([])\\n                continue\\n            temp = getAllAncestors(i)\\n            ret.append(temp)\\n\\n        return map(sorted, ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905332,
                "title": "java-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private void dfs(List<List<Integer>> adj, boolean[] vis, List<Integer> temp,int node){\\n        vis[node] = true;\\n        for(int it : adj.get(node)){\\n            if(vis[it]==false){\\n                temp.add(it);\\n                dfs(adj,vis,temp,it);\\n            }\\n        }\\n    }\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < edges.length; i++){\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            boolean[] vis = new boolean[n];\\n            List<Integer> temp = new ArrayList<>();\\n            dfs(adj,vis,temp,i);\\n            Collections.sort(temp);\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private void dfs(List<List<Integer>> adj, boolean[] vis, List<Integer> temp,int node){\\n        vis[node] = true;\\n        for(int it : adj.get(node)){\\n            if(vis[it]==false){\\n                temp.add(it);\\n                dfs(adj,vis,temp,it);\\n            }\\n        }\\n    }\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < edges.length; i++){\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            boolean[] vis = new boolean[n];\\n            List<Integer> temp = new ArrayList<>();\\n            dfs(adj,vis,temp,i);\\n            Collections.sort(temp);\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886419,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& ed) {\\n        vector<vector<int>> ans(n);\\n        vector<int> adj[n];\\n\\n        for (auto& e: ed) {\\n            adj[e[0]].push_back(e[1]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            queue<int> q {{ i }};\\n            vector<bool> visited(n, false);\\n\\n            while(!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n\\n                for (auto& nei: adj[node]) {\\n                    if (visited[nei]) continue;\\n                    visited[nei] = true;\\n                    ans[nei].push_back(i);\\n                    q.push(nei);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& ed) {\\n        vector<vector<int>> ans(n);\\n        vector<int> adj[n];\\n\\n        for (auto& e: ed) {\\n            adj[e[0]].push_back(e[1]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            queue<int> q {{ i }};\\n            vector<bool> visited(n, false);\\n\\n            while(!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n\\n                for (auto& nei: adj[node]) {\\n                    if (visited[nei]) continue;\\n                    visited[nei] = true;\\n                    ans[nei].push_back(i);\\n                    q.push(nei);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878403,
                "title": "reversing-graph-easy-cpp-implemenatation",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> bfs(vector<vector<int>> adj,int i, vector<bool> visit){\\n        vector<int>temp={};\\n        queue<int>q;\\n        q.push(i);\\n        while(!q.empty()){\\n            int n=q.front();\\n            q.pop();\\n            if(n!=i)temp.push_back(n);\\n            for(auto e: adj[n]){\\n                if(!visit[e]){\\n                    visit[e]=true;\\n                    q.push(e);\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for( auto &e: edges){\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<vector<int>> ans;\\n        vector<bool> visitd(n,false);\\n        for(int i=0;i<n;i++){\\n            vector<int> v=bfs(adj,i,visitd);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bfs(vector<vector<int>> adj,int i, vector<bool> visit){\\n        vector<int>temp={};\\n        queue<int>q;\\n        q.push(i);\\n        while(!q.empty()){\\n            int n=q.front();\\n            q.pop();\\n            if(n!=i)temp.push_back(n);\\n            for(auto e: adj[n]){\\n                if(!visit[e]){\\n                    visit[e]=true;\\n                    q.push(e);\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for( auto &e: edges){\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<vector<int>> ans;\\n        vector<bool> visitd(n,false);\\n        for(int i=0;i<n;i++){\\n            vector<int> v=bfs(adj,i,visitd);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858037,
                "title": "by-reversing-the-direction-of-edges-dfs-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(int node,vector<vector<int>> &adj,vector<int> &temp,vector<int> &visited){\\n        visited[node]=true;\\n        for(auto it:adj[node]){\\n            if (!visited[it]){\\n                temp.push_back(it);\\n                dfs(it,adj,temp,visited);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n\\n        for (auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        ans.resize(n);\\n        vector<vector<int>> dp(n);\\n        for (int i=0;i<n;i++){\\n                vector<int> temp;\\n                vector<int> visited(n,0);\\n                dfs(i,adj,temp,visited);\\n                sort(temp.begin(),temp.end());\\n                ans[i]=temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(int node,vector<vector<int>> &adj,vector<int> &temp,vector<int> &visited){\\n        visited[node]=true;\\n        for(auto it:adj[node]){\\n            if (!visited[it]){\\n                temp.push_back(it);\\n                dfs(it,adj,temp,visited);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n\\n        for (auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        ans.resize(n);\\n        vector<vector<int>> dp(n);\\n        for (int i=0;i<n;i++){\\n                vector<int> temp;\\n                vector<int> visited(n,0);\\n                dfs(i,adj,temp,visited);\\n                sort(temp.begin(),temp.end());\\n                ans[i]=temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850258,
                "title": "easiest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe probelem is nothing but applying **BFS** on the reverse graph.\\nhere we will make a reverse adjacency list and apply BFS over it and thats all.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> helper(vector<vector<int>>& rev_adj,int i){\\n        queue<int> q;\\n        q.push(i);\\n        vector<int> ans;\\n        vector<bool> vis(rev_adj.size(),false);\\n\\n        while(!q.empty()){\\n            int curr= q.front();\\n            q.pop();\\n\\n            if(i!=curr)ans.push_back(curr);\\n\\n            for(auto it:rev_adj[curr]){\\n                if(!vis[it])q.push(it),vis[it]=true;\\n            }\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n\\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // the question is nothing but applying reverse bfs and thats all\\n        // we will first make a rev_adj list\\n        vector<vector<int>> rev_adj(n);\\n        for(auto it:edges){\\n            rev_adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<vector<int>> ans(n);\\n\\n        for(int i=0;i<n;i++){\\n            ans[i]=helper(rev_adj,i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> helper(vector<vector<int>>& rev_adj,int i){\\n        queue<int> q;\\n        q.push(i);\\n        vector<int> ans;\\n        vector<bool> vis(rev_adj.size(),false);\\n\\n        while(!q.empty()){\\n            int curr= q.front();\\n            q.pop();\\n\\n            if(i!=curr)ans.push_back(curr);\\n\\n            for(auto it:rev_adj[curr]){\\n                if(!vis[it])q.push(it),vis[it]=true;\\n            }\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n\\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // the question is nothing but applying reverse bfs and thats all\\n        // we will first make a rev_adj list\\n        vector<vector<int>> rev_adj(n);\\n        for(auto it:edges){\\n            rev_adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<vector<int>> ans(n);\\n\\n        for(int i=0;i<n;i++){\\n            ans[i]=helper(rev_adj,i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850074,
                "title": "using-dfs-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int s, vector<int>& vis, vector<int> adj[], vector<vector<int>>& ans,int i) {\\n        vis[s] = 1;\\n\\n        for (auto x : adj[s]) {\\n            if (vis[x] == 0) {\\n               ans[x].push_back(i);\\n                dfs(x, vis, adj, ans,i);\\n                  \\n            } \\n        }\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n\\n        vector<vector<int>> ans(n);\\n        vector<int> vis(n, 0);\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            vector<int> vis(n, 0);\\n           \\n                dfs(i, vis, adj, ans,i);\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int s, vector<int>& vis, vector<int> adj[], vector<vector<int>>& ans,int i) {\\n        vis[s] = 1;\\n\\n        for (auto x : adj[s]) {\\n            if (vis[x] == 0) {\\n               ans[x].push_back(i);\\n                dfs(x, vis, adj, ans,i);\\n                  \\n            } \\n        }\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n\\n        vector<vector<int>> ans(n);\\n        vector<int> vis(n, 0);\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            vector<int> vis(n, 0);\\n           \\n                dfs(i, vis, adj, ans,i);\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843624,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need to get ancestors node\\nSo reverse the edge in adjacency list to get a node\\'s parents.\\nEach node is numbered from `0` to `n-1`\\nSo use a `for loop` to iterate\\nThis is to avoid disconnected graphs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create adjacency list\\n2. Reverse the edges to get each node\\'s parents\\n3. DFS each node to get all ancestors\\n> Remember to keep track of visited ancestors for each node\\nIn Python, a list can be access within each iteration of a `for loop` (`visited` can be accessed in `dfs()`)\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ where at nodes are connected\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + E)$$ to store adjacency list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        res = [[] for _ in range(n)]\\n        parent_list = defaultdict(list)\\n        for a,b in edges:\\n            parent_list[b].append(a)\\n        def dfs(a, cur):\\n            visited[a] = 1\\n            for p in parent_list[a]:\\n                if visited[p] == 0:\\n                    res[cur].append(p)\\n                    dfs(p, cur)\\n        for i in range(n):\\n            visited = [0] * n\\n            dfs(i, i)\\n            res[i].sort()\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        res = [[] for _ in range(n)]\\n        parent_list = defaultdict(list)\\n        for a,b in edges:\\n            parent_list[b].append(a)\\n        def dfs(a, cur):\\n            visited[a] = 1\\n            for p in parent_list[a]:\\n                if visited[p] == 0:\\n                    res[cur].append(p)\\n                    dfs(p, cur)\\n        for i in range(n):\\n            visited = [0] * n\\n            dfs(i, i)\\n            res[i].sort()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836762,
                "title": "dfs-c-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int> graph[],vector<int>& nodes,int src,vector<bool>& vis)\\n{ if(vis[src])\\n   return;\\n   vis[src]=true;\\n        for(int i=0;i<graph[src].size();i++)\\n           { int m=graph[src][i];\\n                  if(!vis[m])\\n             {nodes.push_back(m);\\n                 dfs(graph,nodes,m,vis);\\n             }\\n           }\\n\\n}\\n\\n\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n];\\n        for(int i=0;i<edges.size();i++)\\n       {int a=edges[i][0];\\n        int b=edges[i][1];\\n          graph[b].push_back(a);\\n\\n       }\\n       vector<vector<int>> res;\\n        for(int i=0;i<n;i++)\\n       {vector<int> nodes;\\n       vector<bool> vis(n,false);\\n             dfs(graph,nodes,i,vis);\\n           res.push_back(nodes);     \\n\\n\\n       }\\n       for(auto& x:res)\\n  {sort(x.begin(),x.end());\\n  }\\n\\n    return res;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int> graph[],vector<int>& nodes,int src,vector<bool>& vis)\\n{ if(vis[src])\\n   return;\\n   vis[src]=true;\\n        for(int i=0;i<graph[src].size();i++)\\n           { int m=graph[src][i];\\n                  if(!vis[m])\\n             {nodes.push_back(m);\\n                 dfs(graph,nodes,m,vis);\\n             }\\n           }\\n\\n}\\n\\n\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n];\\n        for(int i=0;i<edges.size();i++)\\n       {int a=edges[i][0];\\n        int b=edges[i][1];\\n          graph[b].push_back(a);\\n\\n       }\\n       vector<vector<int>> res;\\n        for(int i=0;i<n;i++)\\n       {vector<int> nodes;\\n       vector<bool> vis(n,false);\\n             dfs(graph,nodes,i,vis);\\n           res.push_back(nodes);     \\n\\n\\n       }\\n       for(auto& x:res)\\n  {sort(x.begin(),x.end());\\n  }\\n\\n    return res;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830181,
                "title": "c-dfs-easy-to-understand-beast-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n   private readonly Dictionary<int, List<int>> _dictionary = new Dictionary<int, List<int>>();\\n    \\n    public IList<IList<int>> GetAncestors(int n, int[][] edges)\\n    {\\n        var result = new List<IList<int>>();\\n\\n        Initialize(n);\\n        Fill(edges);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            result.Add(Transform(TraversePath(i)));\\n        }\\n        \\n        return result;\\n    }\\n\\n    void Initialize(int size)\\n    {\\n        for (int i = 0; i < size; i++)\\n        {\\n            _dictionary[i] = new List<int>();\\n        }\\n    }\\n\\n    void Fill(int[][] edges)\\n    {\\n        foreach (var edge in edges)\\n        {\\n            _dictionary[edge[1]].Add(edge[0]);\\n        }\\n    }\\n\\n    Stack<int> TraversePath(int vertix)\\n    {\\n        var path = new Stack<int>();\\n        var queue = new Queue<int>();\\n        var visited = new HashSet<int>();\\n        \\n        queue.Enqueue(vertix);\\n        visited.Add(vertix);\\n\\n        while (queue.Count != 0)\\n        {\\n            var current = queue.Dequeue();\\n            if (current != vertix)\\n            {\\n                path.Push(current);\\n            }\\n\\n            for (int i = _dictionary[current].Count - 1; i >= 0; i--)\\n            {\\n                var nextVertix = _dictionary[current][i];\\n                if (!visited.Contains(nextVertix))\\n                {\\n                    visited.Add(nextVertix);\\n                    queue.Enqueue(nextVertix);\\n                }\\n            }\\n        }\\n\\n        return path;\\n    }\\n\\n    List<int> Transform(Stack<int> values)\\n    {\\n        var result = new List<int>(values.Count);\\n        \\n        while (values.Count != 0)\\n        {\\n            result.Add(values.Pop());\\n        }\\n\\n        result.Sort();\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n   private readonly Dictionary<int, List<int>> _dictionary = new Dictionary<int, List<int>>();\\n    \\n    public IList<IList<int>> GetAncestors(int n, int[][] edges)\\n    {\\n        var result = new List<IList<int>>();\\n\\n        Initialize(n);\\n        Fill(edges);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            result.Add(Transform(TraversePath(i)));\\n        }\\n        \\n        return result;\\n    }\\n\\n    void Initialize(int size)\\n    {\\n        for (int i = 0; i < size; i++)\\n        {\\n            _dictionary[i] = new List<int>();\\n        }\\n    }\\n\\n    void Fill(int[][] edges)\\n    {\\n        foreach (var edge in edges)\\n        {\\n            _dictionary[edge[1]].Add(edge[0]);\\n        }\\n    }\\n\\n    Stack<int> TraversePath(int vertix)\\n    {\\n        var path = new Stack<int>();\\n        var queue = new Queue<int>();\\n        var visited = new HashSet<int>();\\n        \\n        queue.Enqueue(vertix);\\n        visited.Add(vertix);\\n\\n        while (queue.Count != 0)\\n        {\\n            var current = queue.Dequeue();\\n            if (current != vertix)\\n            {\\n                path.Push(current);\\n            }\\n\\n            for (int i = _dictionary[current].Count - 1; i >= 0; i--)\\n            {\\n                var nextVertix = _dictionary[current][i];\\n                if (!visited.Contains(nextVertix))\\n                {\\n                    visited.Add(nextVertix);\\n                    queue.Enqueue(nextVertix);\\n                }\\n            }\\n        }\\n\\n        return path;\\n    }\\n\\n    List<int> Transform(Stack<int> values)\\n    {\\n        var result = new List<int>(values.Count);\\n        \\n        while (values.Count != 0)\\n        {\\n            result.Add(values.Pop());\\n        }\\n\\n        result.Sort();\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823912,
                "title": "beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&res,vector<int>adj[],vector<bool>&visited, int u, int &v)\\n    {\\n        visited[u] = true;\\n        if(u != v)\\n            res[u].push_back(v);\\n        for(int &x:adj[u])\\n        {\\n            if(!visited[x])\\n            {\\n                dfs(res,adj,visited,x,v);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(vector<int>&tmp:edges)\\n        {\\n            adj[tmp[0]].push_back(tmp[1]);\\n        }\\n        \\n        vector<vector<int>>res(n);\\n        for(int i=0;i<n;++i)\\n        {\\n            vector<bool>visited(n,false);\\n            dfs(res,adj,visited,i,i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&res,vector<int>adj[],vector<bool>&visited, int u, int &v)\\n    {\\n        visited[u] = true;\\n        if(u != v)\\n            res[u].push_back(v);\\n        for(int &x:adj[u])\\n        {\\n            if(!visited[x])\\n            {\\n                dfs(res,adj,visited,x,v);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(vector<int>&tmp:edges)\\n        {\\n            adj[tmp[0]].push_back(tmp[1]);\\n        }\\n        \\n        vector<vector<int>>res(n);\\n        for(int i=0;i<n;++i)\\n        {\\n            vector<bool>visited(n,false);\\n            dfs(res,adj,visited,i,i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807676,
                "title": "dfs",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    // TC: O(V*E)\\n    // SC: O(V+E)\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            ans.add(new ArrayList<>());\\n        }\\n\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            boolean[] isVisited = new boolean[n];\\n            dfs(adj,ans,i,i,isVisited);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void dfs(List<List<Integer>> adj,List<List<Integer>> ans,int parent,int curr,boolean[] isVisited){\\n        isVisited[curr]=true;\\n        for(int a:adj.get(curr)){\\n            if(!isVisited[a]){\\n                ans.get(a).add(parent);\\n                dfs(adj,ans,parent,a,isVisited);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // TC: O(V*E)\\n    // SC: O(V+E)\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            ans.add(new ArrayList<>());\\n        }\\n\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            boolean[] isVisited = new boolean[n];\\n            dfs(adj,ans,i,i,isVisited);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void dfs(List<List<Integer>> adj,List<List<Integer>> ans,int parent,int curr,boolean[] isVisited){\\n        isVisited[curr]=true;\\n        for(int a:adj.get(curr)){\\n            if(!isVisited[a]){\\n                ans.get(a).add(parent);\\n                dfs(adj,ans,parent,a,isVisited);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802446,
                "title": "easy-peasy-java-solution",
                "content": "# Intuition\\njust reverse the edge direction and do dfs \\n\\n# Approach\\n   dfs + traspose graph\\n\\n# Complexity\\n- Time complexity:\\n            \\n\\n\\n        O(v*(v+e))\\n\\n- Space complexity:\\n\\n\\n\\n\\n        O(v+e)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> graph=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n          graph.add(new ArrayList<>());\\n        }\\n\\n        for(int [] edge:edges){\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n\\n\\n        List<List<Integer>> res=new ArrayList<>();\\n\\n\\n        for(int i=0;i<n;i++){\\n            List<Integer> al =new ArrayList<>();\\n            boolean[] vis=new boolean[n];\\n            dfs(i,graph,vis);\\n            for(int j=0;j<n;j++){\\n                if(vis[j])\\n                    al.add(j);\\n            }\\n            al.remove(Integer.valueOf(i));\\n            res.add(al);\\n        }     \\n        return res;\\n        \\n    }\\n\\n    public void dfs(int i,List<List<Integer>> g,boolean[] vis){\\n        vis[i]=true;\\n         for(int adj:g.get(i)){\\n             if(!vis[adj]){\\n                 dfs(adj,g,vis);\\n             }\\n         }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> graph=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n          graph.add(new ArrayList<>());\\n        }\\n\\n        for(int [] edge:edges){\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n\\n\\n        List<List<Integer>> res=new ArrayList<>();\\n\\n\\n        for(int i=0;i<n;i++){\\n            List<Integer> al =new ArrayList<>();\\n            boolean[] vis=new boolean[n];\\n            dfs(i,graph,vis);\\n            for(int j=0;j<n;j++){\\n                if(vis[j])\\n                    al.add(j);\\n            }\\n            al.remove(Integer.valueOf(i));\\n            res.add(al);\\n        }     \\n        return res;\\n        \\n    }\\n\\n    public void dfs(int i,List<List<Integer>> g,boolean[] vis){\\n        vis[i]=true;\\n         for(int adj:g.get(i)){\\n             if(!vis[adj]){\\n                 dfs(adj,g,vis);\\n             }\\n         }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789001,
                "title": "easy-dfs-c-all-the-path-from-root",
                "content": "# Intuition\\nIntuition is quite simple. Reverse the [a(from) -> b(to)] and then find all the path from b(current from ) to a (current to).\\n\\n# Approach\\nJust Run a dfs and apply the logic of store the path from root\\n\\n# Complexity\\n- Time complexity:\\n$$O(N^2 * log(n))$$\\n\\n``` Do upvote if it helped you. Thankyou, Happy Coding :)```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void f(int root, vector<int> adj[], vector<int> &visit, set<int> &ans){\\n        visit[root] = 1;\\n        \\n        for(auto i:adj[root]){\\n            if(visit[i]) continue;\\n            ans.insert(i);\\n            f(i,adj,visit,ans);\\n        }\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<n;i+=1){\\n            vector<int> visit(n+1,0);\\n            set<int> st;\\n            f(i,adj,visit,st);\\n            vector<int> temp(st.begin(), st.end());\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "``` Do upvote if it helped you. Thankyou, Happy Coding :)```\n```\\nclass Solution {\\npublic:\\n\\n    void f(int root, vector<int> adj[], vector<int> &visit, set<int> &ans){\\n        visit[root] = 1;\\n        \\n        for(auto i:adj[root]){\\n            if(visit[i]) continue;\\n            ans.insert(i);\\n            f(i,adj,visit,ans);\\n        }\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<n;i+=1){\\n            vector<int> visit(n+1,0);\\n            set<int> st;\\n            f(i,adj,visit,st);\\n            vector<int> temp(st.begin(), st.end());\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785991,
                "title": "bfs-topological-sort-graph-tc-sc-optimized-with-intuition-brute-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.moving to other nodes with connected components and dependent to other edges\\n2. **dirrected edges without any cycles- topological sort**  \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. if bfs / dfs gives O(n*N) time complexcity , **think  about topological sort with bfs** \\n\\n# Complexity\\n- Time complexity:O(N*N) - moving to each edges and along with that moving to each nodes ,its indegree count \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: queue+ indegree ->= 2*O(n)\\n- set matrix + res matrix -> = O(n*n) \\n- **overall SPACE COMPLEXICITY = o(N*N)** \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>indG(n,0),adj[n];\\n        queue<int>q;\\n        vector<set<int>>temp(n);\\n        vector<vector<int>> res(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            indG[it[1]]++;\\n\\n        }\\n        for(int i=0;i<n;++i)\\n        {\\n            if(indG[i]==0)\\n            {\\n                q.push(i);\\n               \\n            }\\n        }\\n        while(!q.empty())\\n        {\\n           \\n                int cur=q.front();\\n                q.pop();\\n                for(auto it:adj[cur])\\n                {\\n                    indG[it]--;\\n                  for(auto y:temp[cur])\\n                  temp[it].insert(y);\\n\\n                    temp[it].insert(cur);\\n                   \\n                    if(indG[it]==0)\\n                    {\\n                        q.push(it);\\n                        \\n                    }\\n\\n                }\\n\\n            \\n        }\\n\\n    for(int i=0;i<n;++i)\\n    { \\n        res[i]=vector<int>(temp[i].begin(),temp[i].end()); \\n    }\\n\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>indG(n,0),adj[n];\\n        queue<int>q;\\n        vector<set<int>>temp(n);\\n        vector<vector<int>> res(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            indG[it[1]]++;\\n\\n        }\\n        for(int i=0;i<n;++i)\\n        {\\n            if(indG[i]==0)\\n            {\\n                q.push(i);\\n               \\n            }\\n        }\\n        while(!q.empty())\\n        {\\n           \\n                int cur=q.front();\\n                q.pop();\\n                for(auto it:adj[cur])\\n                {\\n                    indG[it]--;\\n                  for(auto y:temp[cur])\\n                  temp[it].insert(y);\\n\\n                    temp[it].insert(cur);\\n                   \\n                    if(indG[it]==0)\\n                    {\\n                        q.push(it);\\n                        \\n                    }\\n\\n                }\\n\\n            \\n        }\\n\\n    for(int i=0;i<n;++i)\\n    { \\n        res[i]=vector<int>(temp[i].begin(),temp[i].end()); \\n    }\\n\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785843,
                "title": "most-easiest-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,  vector<vector<int>> &v,  vector<int> &vis ){\\n\\n        vis[node]=1;\\n\\n        for(auto x:v[node]){\\n            if(!vis[x]){\\n                dfs(x,v,vis);\\n            }\\n        }\\n\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n         vector<vector<int>> v(n);\\n\\n           for(auto x:edges){\\n\\n               int a=x[0];\\n               int b=x[1];\\n\\n               v[a].push_back(b);\\n           }\\n\\n           vector<vector<int>> ans(n);\\n\\n\\n          \\n\\n           for(int i=0; i<n; i++){\\n          vector<int> vis(n,0);\\n               dfs(i,v,vis);\\n                  for(int j=0; j<vis.size(); j++){\\n                         \\n                      if(vis[j]&&i!=j){\\n                            ans[j].push_back(i);\\n                      }\\n\\n\\n                  }\\n\\n            \\n\\n           }\\n\\n           return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,  vector<vector<int>> &v,  vector<int> &vis ){\\n\\n        vis[node]=1;\\n\\n        for(auto x:v[node]){\\n            if(!vis[x]){\\n                dfs(x,v,vis);\\n            }\\n        }\\n\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n         vector<vector<int>> v(n);\\n\\n           for(auto x:edges){\\n\\n               int a=x[0];\\n               int b=x[1];\\n\\n               v[a].push_back(b);\\n           }\\n\\n           vector<vector<int>> ans(n);\\n\\n\\n          \\n\\n           for(int i=0; i<n; i++){\\n          vector<int> vis(n,0);\\n               dfs(i,v,vis);\\n                  for(int j=0; j<vis.size(); j++){\\n                         \\n                      if(vis[j]&&i!=j){\\n                            ans[j].push_back(i);\\n                      }\\n\\n\\n                  }\\n\\n            \\n\\n           }\\n\\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763510,
                "title": "reverse-edges-then-dfs-from-every-node-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>> &adjList,vector<int>&temp,vector<int>&vis){\\n        vis[node]=1;\\n        temp.push_back(node);\\n        for(auto it: adjList[node]){\\n            if(!vis[it]){\\n                dfs(it,adjList,temp,vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n        vector<vector<int>> ans(n);\\n        for(auto it: edges){\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int> temp;\\n            vector<int> vis(n,0);\\n            dfs(i,adjList,temp,vis);\\n            auto it = temp.begin();\\n            temp.erase(it);\\n            sort(temp.begin(),temp.end());\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>> &adjList,vector<int>&temp,vector<int>&vis){\\n        vis[node]=1;\\n        temp.push_back(node);\\n        for(auto it: adjList[node]){\\n            if(!vis[it]){\\n                dfs(it,adjList,temp,vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n        vector<vector<int>> ans(n);\\n        for(auto it: edges){\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int> temp;\\n            vector<int> vis(n,0);\\n            dfs(i,adjList,temp,vis);\\n            auto it = temp.begin();\\n            temp.erase(it);\\n            sort(temp.begin(),temp.end());\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761296,
                "title": "python-bfs",
                "content": "# Approach\\nKahn\\'s Algorithm + BFS\\n\\n    1. Initialization:\\n        Create a dictionary called indegree to store the indegree count of each node (number of incoming edges).\\n        Create a dictionary called adj to store the adjacency list for each node.\\n        Create a list called ans to store the ancestors of each node.\\n\\n    2. Process the edges:\\n        Iterate over each edge (a, b) in the input edges.\\n        Increment the indegree count of node b since it has an incoming edge.\\n        Add node b to the adjacency list of node a.\\n\\n    3. Find nodes with no incoming edges:\\n        Create a queue called queue to store nodes that have no incoming edges.\\n        Iterate over all nodes (0 to n-1).\\n        If a node has an indegree count of 0 (no incoming edges), add it to the queue.\\n\\n    4. Perform BFS:\\n        While the queue is not empty, do the following:\\n            Remove the first node (p) from the queue.\\n            Iterate over each child node of p (obtained from the adjacency list).\\n                Update the ancestors of the child node by adding the ancestors of p along with p itself.\\n                Decrement the indegree count of the child node.\\n                If the indegree count of the child node becomes 0, add it to the queue.\\n\\n    5. Prepare the output:\\n        Convert the ancestor sets in the ans list into sorted lists.\\n        Return the resulting list of sorted ancestor lists.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(|V| + |E|) = O(n ^ 2)\\nDAG can have the maximum number of n * (n - 1) /2 edges where n is the number of vertices. Therefore, we have O(n ^ 2). \\n\\n- Space complexity:\\nO(|V| + |E|) = O(n ^ 2)\\n\\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        indegree = defaultdict(int)\\n        adj = defaultdict(set)\\n        ans = [set() for _ in range(n)]\\n        for a, b in edges:\\n            indegree[b] += 1\\n            adj[a].add(b)\\n\\n        queue = deque([])\\n        for a in range(n):\\n            if a not in indegree:\\n                queue.append(a)\\n        \\n        while queue:\\n            p = queue.popleft()\\n            for child in adj[p]:\\n                ans[child].update(ans[p], [p])\\n                indegree[child] -= 1\\n                if indegree[child] == 0:\\n                    queue.append(child)\\n        return [sorted(list(s)) for s in ans]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        indegree = defaultdict(int)\\n        adj = defaultdict(set)\\n        ans = [set() for _ in range(n)]\\n        for a, b in edges:\\n            indegree[b] += 1\\n            adj[a].add(b)\\n\\n        queue = deque([])\\n        for a in range(n):\\n            if a not in indegree:\\n                queue.append(a)\\n        \\n        while queue:\\n            p = queue.popleft()\\n            for child in adj[p]:\\n                ans[child].update(ans[p], [p])\\n                indegree[child] -= 1\\n                if indegree[child] == 0:\\n                    queue.append(child)\\n        return [sorted(list(s)) for s in ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718494,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) { \\n          vector<vector<int>>ans(n),g(n);\\n          for(auto &v: edges)\\n          {\\n              g[v[0]].push_back(v[1]);\\n          }\\n          for(int i=0;i<n;i++)\\n          {\\n              vector<bool> vis(n);\\n              dfs(g,i,i,ans,vis);\\n          }\\n          return ans;\\n    }\\n    void dfs(vector<vector<int>> &g,int i,int j,vector<vector<int>>&ans,vector<bool> &vis)\\n     {\\n         vis[j]=true;\\n         for(auto x:g[j])\\n         {\\n             if(!vis[x])\\n             {\\n             ans[x].push_back(i);\\n             dfs(g,i,x,ans,vis);\\n             }\\n         }\\n     } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) { \\n          vector<vector<int>>ans(n),g(n);\\n          for(auto &v: edges)\\n          {\\n              g[v[0]].push_back(v[1]);\\n          }\\n          for(int i=0;i<n;i++)\\n          {\\n              vector<bool> vis(n);\\n              dfs(g,i,i,ans,vis);\\n          }\\n          return ans;\\n    }\\n    void dfs(vector<vector<int>> &g,int i,int j,vector<vector<int>>&ans,vector<bool> &vis)\\n     {\\n         vis[j]=true;\\n         for(auto x:g[j])\\n         {\\n             if(!vis[x])\\n             {\\n             ans[x].push_back(i);\\n             dfs(g,i,x,ans,vis);\\n             }\\n         }\\n     } \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576568,
                "content": [
                    {
                        "username": "seafmch",
                        "content": "Because you have to copy over the array of the previous result, which is an O(N) operation. \\n\\nThis problem is O(N^2), no getting around it."
                    },
                    {
                        "username": "rewill11",
                        "content": "so ig performing a dfs from every node would suffice?"
                    },
                    {
                        "username": "juraj24",
                        "content": "Two important things to realize:\\n- Start traversal from every node, starting from node 0. This is to ensure the sorted order of ancestors in the output.\\n- A given node can be reached from an ancestor by different paths. Thus, the first time you reach a node, mark it as seen, record the ancestor, and continue the traversal. The first path to reach a given node \"wins\". Subequent paths that reach the node should neither record the ancestor (that would lead to duplicates), nor continue the traversal (you will run out of memory)."
                    },
                    {
                        "username": "R_aghav",
                        "content": "Is anyhow it\\'s possible to optimized this code ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> vv(n);\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            queue<int> q;\\n            q.push(i);\\n            if(adj[i].size()==0) {continue; }\\n            set<int> st;\\n            while(!q.empty()){\\n                int node=q.front();\\n                q.pop();\\n                st.insert(node);\\n                for(auto i:adj[node]){\\n                    q.push(i);\\n                }\\n            }\\n          vv[i]=(vector<int> (st.begin(),st.end()));\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vv[i].size()==0) continue;\\n            vv[i].erase(remove(vv[i].begin(),vv[i].end(),i));\\n        }\\n        return vv;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "what you are truly having trouble with is after creating a adj list is that how will you make a visited array, the simple answer is taking a new vis array for every dfs traversal refer to following for more\\nhttps://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/3905332/java-dfs-solution "
                    }
                ]
            },
            {
                "id": 1897936,
                "content": [
                    {
                        "username": "seafmch",
                        "content": "Because you have to copy over the array of the previous result, which is an O(N) operation. \\n\\nThis problem is O(N^2), no getting around it."
                    },
                    {
                        "username": "rewill11",
                        "content": "so ig performing a dfs from every node would suffice?"
                    },
                    {
                        "username": "juraj24",
                        "content": "Two important things to realize:\\n- Start traversal from every node, starting from node 0. This is to ensure the sorted order of ancestors in the output.\\n- A given node can be reached from an ancestor by different paths. Thus, the first time you reach a node, mark it as seen, record the ancestor, and continue the traversal. The first path to reach a given node \"wins\". Subequent paths that reach the node should neither record the ancestor (that would lead to duplicates), nor continue the traversal (you will run out of memory)."
                    },
                    {
                        "username": "R_aghav",
                        "content": "Is anyhow it\\'s possible to optimized this code ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> vv(n);\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            queue<int> q;\\n            q.push(i);\\n            if(adj[i].size()==0) {continue; }\\n            set<int> st;\\n            while(!q.empty()){\\n                int node=q.front();\\n                q.pop();\\n                st.insert(node);\\n                for(auto i:adj[node]){\\n                    q.push(i);\\n                }\\n            }\\n          vv[i]=(vector<int> (st.begin(),st.end()));\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vv[i].size()==0) continue;\\n            vv[i].erase(remove(vv[i].begin(),vv[i].end(),i));\\n        }\\n        return vv;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "what you are truly having trouble with is after creating a adj list is that how will you make a visited array, the simple answer is taking a new vis array for every dfs traversal refer to following for more\\nhttps://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/3905332/java-dfs-solution "
                    }
                ]
            },
            {
                "id": 1843396,
                "content": [
                    {
                        "username": "seafmch",
                        "content": "Because you have to copy over the array of the previous result, which is an O(N) operation. \\n\\nThis problem is O(N^2), no getting around it."
                    },
                    {
                        "username": "rewill11",
                        "content": "so ig performing a dfs from every node would suffice?"
                    },
                    {
                        "username": "juraj24",
                        "content": "Two important things to realize:\\n- Start traversal from every node, starting from node 0. This is to ensure the sorted order of ancestors in the output.\\n- A given node can be reached from an ancestor by different paths. Thus, the first time you reach a node, mark it as seen, record the ancestor, and continue the traversal. The first path to reach a given node \"wins\". Subequent paths that reach the node should neither record the ancestor (that would lead to duplicates), nor continue the traversal (you will run out of memory)."
                    },
                    {
                        "username": "R_aghav",
                        "content": "Is anyhow it\\'s possible to optimized this code ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> vv(n);\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            queue<int> q;\\n            q.push(i);\\n            if(adj[i].size()==0) {continue; }\\n            set<int> st;\\n            while(!q.empty()){\\n                int node=q.front();\\n                q.pop();\\n                st.insert(node);\\n                for(auto i:adj[node]){\\n                    q.push(i);\\n                }\\n            }\\n          vv[i]=(vector<int> (st.begin(),st.end()));\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vv[i].size()==0) continue;\\n            vv[i].erase(remove(vv[i].begin(),vv[i].end(),i));\\n        }\\n        return vv;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "what you are truly having trouble with is after creating a adj list is that how will you make a visited array, the simple answer is taking a new vis array for every dfs traversal refer to following for more\\nhttps://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/3905332/java-dfs-solution "
                    }
                ]
            },
            {
                "id": 2012944,
                "content": [
                    {
                        "username": "seafmch",
                        "content": "Because you have to copy over the array of the previous result, which is an O(N) operation. \\n\\nThis problem is O(N^2), no getting around it."
                    },
                    {
                        "username": "rewill11",
                        "content": "so ig performing a dfs from every node would suffice?"
                    },
                    {
                        "username": "juraj24",
                        "content": "Two important things to realize:\\n- Start traversal from every node, starting from node 0. This is to ensure the sorted order of ancestors in the output.\\n- A given node can be reached from an ancestor by different paths. Thus, the first time you reach a node, mark it as seen, record the ancestor, and continue the traversal. The first path to reach a given node \"wins\". Subequent paths that reach the node should neither record the ancestor (that would lead to duplicates), nor continue the traversal (you will run out of memory)."
                    },
                    {
                        "username": "R_aghav",
                        "content": "Is anyhow it\\'s possible to optimized this code ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> vv(n);\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            queue<int> q;\\n            q.push(i);\\n            if(adj[i].size()==0) {continue; }\\n            set<int> st;\\n            while(!q.empty()){\\n                int node=q.front();\\n                q.pop();\\n                st.insert(node);\\n                for(auto i:adj[node]){\\n                    q.push(i);\\n                }\\n            }\\n          vv[i]=(vector<int> (st.begin(),st.end()));\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vv[i].size()==0) continue;\\n            vv[i].erase(remove(vv[i].begin(),vv[i].end(),i));\\n        }\\n        return vv;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "what you are truly having trouble with is after creating a adj list is that how will you make a visited array, the simple answer is taking a new vis array for every dfs traversal refer to following for more\\nhttps://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/3905332/java-dfs-solution "
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximize the Topmost Element After K Moves",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> representing the contents of a <b>pile</b>, where <code>nums[0]</code> is the topmost element of the pile.</p>\n\n<p>In one move, you can perform <strong>either</strong> of the following:</p>\n\n<ul>\n\t<li>If the pile is not empty, <strong>remove</strong> the topmost element of the pile.</li>\n\t<li>If there are one or more removed elements, <strong>add</strong> any one of them back onto the pile. This element becomes the new topmost element.</li>\n</ul>\n\n<p>You are also given an integer <code>k</code>, which denotes the total number of moves to be made.</p>\n\n<p>Return <em>the <strong>maximum value</strong> of the topmost element of the pile possible after <strong>exactly</strong></em> <code>k</code> <em>moves</em>. In case it is not possible to obtain a non-empty pile after <code>k</code> moves, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,2,2,4,0,6], k = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nOne of the ways we can end with 5 at the top of the pile after 4 moves is as follows:\n- Step 1: Remove the topmost element = 5. The pile becomes [2,2,4,0,6].\n- Step 2: Remove the topmost element = 2. The pile becomes [2,4,0,6].\n- Step 3: Remove the topmost element = 2. The pile becomes [4,0,6].\n- Step 4: Add 5 back onto the pile. The pile becomes [5,4,0,6].\nNote that this is not the only way to end with 5 at the top of the pile. It can be shown that 5 is the largest answer possible after 4 moves.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2], k = 1\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> \nIn the first move, our only option is to pop the topmost element of the pile.\nSince it is not possible to obtain a non-empty pile after one move, we return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1844102,
                "title": "c-discuss-case-by-case",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1.\\n\\nSee comments in the code.\\n\\nA note on the removing `min(k - 1, N)` elements case:\\n\\nWhat if `k > N + 1` -- there are still steps left after removing `N` elements and putting back the greatest one? We can always waste these steps by putting another element in and out. Since `N >= 2` in this case, it\\'s guaranteed to have another element to waste steps.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/\\n// Author: github.com/lzl124631x\\n// Time: O(min(N, K))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& A, int k) {\\n        int N = A.size();\\n        if (k == 0) return N >= 1 ? A[0] : -1; // if no moves allowed, return the topmost element if any\\n        if (k == 1) return N == 1 ? -1 : A[1]; // if only one move is allowed, we can only remove the topmost element\\n        if (N == 1) return k % 2 == 0 ? A[0] : -1; // if `N == 1`, we can return the topmost element if `k` is a even number (keep removing the topmost element and adding it back).\\n        int mx = *max_element(begin(A), begin(A) + min(k - 1, N)); // we can take `min(k-1, N)` elements and put back the largest one on the top\\n        if (k < N) mx = max(mx, A[k]); // If `k < N`, we can take all the topmost `k` elements and return the one left at the top\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/\\n// Author: github.com/lzl124631x\\n// Time: O(min(N, K))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& A, int k) {\\n        int N = A.size();\\n        if (k == 0) return N >= 1 ? A[0] : -1; // if no moves allowed, return the topmost element if any\\n        if (k == 1) return N == 1 ? -1 : A[1]; // if only one move is allowed, we can only remove the topmost element\\n        if (N == 1) return k % 2 == 0 ? A[0] : -1; // if `N == 1`, we can return the topmost element if `k` is a even number (keep removing the topmost element and adding it back).\\n        int mx = *max_element(begin(A), begin(A) + min(k - 1, N)); // we can take `min(k-1, N)` elements and put back the largest one on the top\\n        if (k < N) mx = max(mx, A[k]); // If `k < N`, we can take all the topmost `k` elements and return the one left at the top\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844179,
                "title": "python-o-n-t-o-1-s-explanation",
                "content": "We dont need to remove any element from the array, we can just keep track of the maximum element.\\n\\n**Steps:**\\nWe initialize variable (maxi) which keeps track of the maximum topmost element.\\nIf k > len(array), then we can traverse the entire array once and find the maximum element of the array. \\n  Example: arr = [5,2,2,4,0,6], k = 40 ==> ans = 6\\n  \\nIf k == len(array), then we need to traverse upto the k-1<sup>th</sup> element and find the maximum element. We use only k-1 steps as the last step would be required to add the maximum element back at the top.\\n  Example: arr = [5,2,2,4,0,6], k = 6 ==> ans = 5\\n  \\nIf k < len(array), then we can traverse upto the k-1<sup>th</sup> element of the array and find the maximum element. In this case there is also a possibility that the k<sup>th</sup> element will be greater than the maximum element that we have found, so we do a check to see which is greater (We will be removing first k elements from the array if the k<sup>th</sup> element is greater).\\nExample: arr = [5,2,2,4,0,6], k = 5 ==> ans = 6\\n\\nIf the len(array) is 1 and k is odd, then we will not be able to find an answer.\\n\\n```\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if (len(nums) == 1) and (k & 1): return -1\\n        \\n        maxi = -1\\n        for i in range(min(len(nums), k-1)):\\n            maxi = max(maxi, nums[i])\\n        \\n        if k < len(nums):\\n            maxi = max(maxi, nums[k])\\n            \\n        return maxi\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if (len(nums) == 1) and (k & 1): return -1\\n        \\n        maxi = -1\\n        for i in range(min(len(nums), k-1)):\\n            maxi = max(maxi, nums[i])\\n        \\n        if k < len(nums):\\n            maxi = max(maxi, nums[k])\\n            \\n        return maxi\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1844089,
                "title": "simple-java-solution-removing-top-k-1-element-and-comparing-with-kth-elemt",
                "content": "\\n    public static int maximumTop(int[] nums, int k) {\\n        if (nums.length == 1 && k % 2 == 1) return -1; // if size is 1 and k odd stack will be empty\\n        int max = 0;\\n        for (int i = 0; i < Math.min(k - 1 ,nums.length); i++) //finding the max element from first k-1 elelment or len -1 if len is less than k\\n            max = Math.max(max, nums[i]);\\n        if (k < nums.length)  // check for scenario where we dont have to put back Max out of k-1 element\\n            max = Math.max(max, nums[k]);\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "\\n    public static int maximumTop(int[] nums, int k) {\\n        if (nums.length == 1 && k % 2 == 1) return -1; // if size is 1 and k odd stack will be empty\\n        int max = 0;\\n        for (int i = 0; i < Math.min(k - 1 ,nums.length); i++) //finding the max element from first k-1 elelment or len -1 if len is less than k\\n            max = Math.max(max, nums[i]);\\n        if (k < nums.length)  // check for scenario where we dont have to put back Max out of k-1 element\\n            max = Math.max(max, nums[k]);\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1844303,
                "title": "simple-understanding-c-code-with-explanation",
                "content": "We can infer from the question that in the first operation we have to remove first element and for remaining k-1 choices we can convert the question into following 4 cases:\\n\\n3 4 5 ,k=2     output will be 5\\nprocess:\\nk=1 - 3 will be reomved\\nk=2 - 4 will be reomved \\nnow 5 will be answer\\n\\n3 5 4 2 1 k=3 output will be 5\\nprocess:\\nk=1 - 3 will be removes \\nk=2 - 5 will be removed \\nnow we have 2 choices either to add 5 or remove 4( then 2 will be on top ) out of which best would be to add 5 so we add 5\\n5 4 2 1\\n\\n\\nWe can split the question into 4 cases.\\n\\n1st case :\\nIf the size of the vector is 1\\nFor 1st operation : We will remove the element from the vector.\\nFor 2nd operation : We will add the element to the vector.\\nFor 3rd operation : We will remove the element from the vector.\\nFor 4th operation : We will add the element to the vector.\\nFor 5th operation : We will remove the element from the vector.\\nFor 6th operation : We will add the element to the vector.\\n..\\n..\\nWe can generalize that if the number of operations is odd, the vector will be empty and so we will return -1.\\nIf the number of operations is even then we will return the element.\\n\\n2nd case :\\nIf the number of operations is greater than the vector size, then we can remove all the elements from the vector and add the highest elements.\\nBy generalizing this case, we can return the maximum element of the vector.\\n\\n3rd case :\\nIf the number of operations is equal to the vector size, then we will remove the first (k-1) elements from the vector and add the maximum element from the removed elements to vector.\\nSo we will return the maximum element from the first (k-1) elements.\\n\\n4th case :\\nIf the number of operations is less than vector size, then we will remove the first (k-1) elements from the vector and we have a option of removing the kth element from the vector or adding the maximum of removed (k-1) elements.\\nBy generalizing, the answer will be maximum element from the maximum element of  first (k-1) elements and the (k+1)th element.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& v, int k) {\\n        int n=v.size();\\n        if(n==1 && k%2==1){\\n            return -1;\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0;i<n && i<k-1;i++){\\n            mx=max(mx,v[i]);\\n        }\\n        if(k<n){\\n            mx=max(mx,v[k]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& v, int k) {\\n        int n=v.size();\\n        if(n==1 && k%2==1){\\n            return -1;\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0;i<n && i<k-1;i++){\\n            mx=max(mx,v[i]);\\n        }\\n        if(k<n){\\n            mx=max(mx,v[k]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877511,
                "title": "tricky-edge-cases",
                "content": "Easy intuition (return the largest of `k - 1` elements), but tricky edge cases:\\n\\n1. One element - pile is empty if `k` is odd.\\n2. `k < 2` - return `nums[k]`.\\n3. `k >= n` - return the maximum element from the array.\\n\\t- Edge case when `k == n` - we have to keep last element in the pile to avoid empty pile.\\n4. `k < n` \\n\\t- Remove `k - 1` elements and return the largest one among those.\\n\\t- Or remove `k` elements and return `nums[k]`.\\n\\n**C++**\\n```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n    if (nums.size() == 1 && k % 2)\\n        return -1;\\n    if (k < 2)\\n        return nums[k];\\n    if (k >= nums.size())\\n        return *max_element(begin(nums), end(nums) - (k == nums.size()));\\n    return max(nums[k], *max_element(begin(nums), begin(nums) + k - 1));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n    if (nums.size() == 1 && k % 2)\\n        return -1;\\n    if (k < 2)\\n        return nums[k];\\n    if (k >= nums.size())\\n        return *max_element(begin(nums), end(nums) - (k == nums.size()));\\n    return max(nums[k], *max_element(begin(nums), begin(nums) + k - 1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844141,
                "title": "c-greedy-cases-discussed-with-examples",
                "content": "Three main cases to be noticed:\\n\\n1) Remove k elements (k+1th is maxm) \\n**Example:**\\n``k = 7``\\n`` A = [1,2,3,4,5,6,7,8]``\\noptimal solution = remove top 7 elements then top will be 8\\n\\n2) Remove k-1 elements then insert maxm element (maxm element lies in [0,k-1])\\n**Example:**\\n``k = 7 ``\\n`` A = [1,2,3,4,5,8,7,6]``\\nOptimal solution = remove top 6 elements and then insert 8\\n\\n\\n\\n3) When **k>n (n>=2)**\\nWe can remove all elements and insert top two or top 1 element\\nFor Example: ``A = [1,2,3,4,5]``\\n``k=6``\\nBest solution: Remove all elements (5 moves) and insert max element (i.e 5) ( total moves = 6)\\n``k=7``\\nBest solution: Remove all elements (5 moves) insert 4 and then insert max element (i.e 5) (total moves = 7)\\n``k=8``\\nBest solution: Remove all elements (5 moves) insert max, remove max and then insert max again (total moves = 8)\\nSimilarly we can do for any value of k, k>n\\n\\nCode Referred From [Sushant Mishra](https://leetcode.com/sushantk_04/)\\n\\nTime Complexity : **O(min(k,n))**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n   \\n        //if no moves given first element is max element\\n        if(k == 0) return nums[0];\\n        \\n        //if size is one we can remove one element and insert one element only when k is even\\n        if(k %2 != 0 && nums.size()==1) return -1;\\n        \\n        int n = nums.size();\\n        int i=0, maxm = 0;\\n        \\n        // Remove top k-1 elements and find maxm out of them\\n        while(i < n && i < k-1){\\n            maxm = max(maxm, nums[i]);\\n            i++;\\n        }\\n        \\n        int ans = 0;\\n        \\n        //We choose best from two options \\n        //either remove k elements (k+1th is maxm) or remove k-1 elements then insert maxm element (maxm element lies in [0,k-1])\\n        if(k < n) ans = nums[k];\\n        return max(maxm, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n   \\n        //if no moves given first element is max element\\n        if(k == 0) return nums[0];\\n        \\n        //if size is one we can remove one element and insert one element only when k is even\\n        if(k %2 != 0 && nums.size()==1) return -1;\\n        \\n        int n = nums.size();\\n        int i=0, maxm = 0;\\n        \\n        // Remove top k-1 elements and find maxm out of them\\n        while(i < n && i < k-1){\\n            maxm = max(maxm, nums[i]);\\n            i++;\\n        }\\n        \\n        int ans = 0;\\n        \\n        //We choose best from two options \\n        //either remove k elements (k+1th is maxm) or remove k-1 elements then insert maxm element (maxm element lies in [0,k-1])\\n        if(k < n) ans = nums[k];\\n        return max(maxm, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844186,
                "title": "python-3-find-maximum-of-first-k-1-elements-or-k-1-th-element-beats-100",
                "content": "The num after the kth element do not matter as they can\\'t be accessed.\\nSo, handling some corner cases like:\\n1. If len(num) == 1.\\n2. if k == 0\\n3. Comparing k and len(nums)\\n\\n**DO UPVOTE if you found it useful.**\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            if k%2 != 0:\\n                return -1\\n            return nums[0]\\n        \\n        if k == 0:\\n            return nums[0]\\n        if k == len(nums):\\n            return max(nums[:-1])\\n        if k > len(nums):\\n            return max(nums)\\n        if k == 1:\\n            return nums[1]\\n        m = max(nums[:k-1])\\n        m = max(m, nums[k])\\n        return m\\n```\\nTime Complexity: O(n) - finding max\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            if k%2 != 0:\\n                return -1\\n            return nums[0]\\n        \\n        if k == 0:\\n            return nums[0]\\n        if k == len(nums):\\n            return max(nums[:-1])\\n        if k > len(nums):\\n            return max(nums)\\n        if k == 1:\\n            return nums[1]\\n        m = max(nums[:k-1])\\n        m = max(m, nums[k])\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844710,
                "title": "java-discuss-case-by-case-beat-100",
                "content": "The idea is quite simple and straitforward based on observation:\\n1)when n==1\\n2)when n > 1\\n        1. when k > n\\n        2. when k == n\\n        3. when k < n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length, max = -1;\\n\\t\\t\\n        if(n==1){\\n            if(k%2==1)  return -1;\\n            else    return nums[0];\\n        }\\n\\t\\t\\n        if(k<n) max = nums[k];\\n        else if(k>n)    k = n+1;\\n\\t\\t\\n        for (int i = 0; i < k-1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length, max = -1;\\n\\t\\t\\n        if(n==1){\\n            if(k%2==1)  return -1;\\n            else    return nums[0];\\n        }\\n\\t\\t\\n        if(k<n) max = nums[k];\\n        else if(k>n)    k = n+1;\\n\\t\\t\\n        for (int i = 0; i < k-1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845405,
                "title": "c-85-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            if(k&1) return -1;\\n            else   return nums[0];\\n        }\\n        if(k<n) {\\n                    if(k==1) return nums[1];\\n            return max(*(max_element(nums.begin(),nums.begin() + k-1)) , nums[k]);\\n        }\\n        if(k==n){\\n            return *(max_element(nums.begin(),nums.begin() + k-1));\\n        }\\n        return *(max_element(nums.begin(),nums.begin()+n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            if(k&1) return -1;\\n            else   return nums[0];\\n        }\\n        if(k<n) {\\n                    if(k==1) return nums[1];\\n            return max(*(max_element(nums.begin(),nums.begin() + k-1)) , nums[k]);\\n        }\\n        if(k==n){\\n            return *(max_element(nums.begin(),nums.begin() + k-1));\\n        }\\n        return *(max_element(nums.begin(),nums.begin()+n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844205,
                "title": "java-detailed-explanation-small-code",
                "content": "If the array has only one element, then we can just add/remove a single element. Hence, in case \\'k\\' is even, we return the only element else we return -1 because it is not possible to perform \\'k\\' steps and finish with a non empty pile.\\n\\nFor generic cases, we traverse the array and for every element calculate the steps required to make that element as the top most element. Finally we find the max number which can be made as the topmost element.\\n\\n**Number of steps to make an element as the topmost element of the pile:**\\nFor ith index, first we need i steps (steps consumed) to remove the elements before it. Then, if we still have steps left (k>steps consumed), then we will be able to make it the top most element only if remaining steps is greater than 0 and not equal to 1.\\n\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1){\\n            if(k%2!=0){\\n                return -1;\\n            }\\n            return nums[0];\\n        }\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            int stepsConsumed = i;\\n            stepsConsumed = k-stepsConsumed;\\n            if(stepsConsumed>=0 && stepsConsumed!=1){\\n                ans = Math.max(ans, nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this helpful ! :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1){\\n            if(k%2!=0){\\n                return -1;\\n            }\\n            return nums[0];\\n        }\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            int stepsConsumed = i;\\n            stepsConsumed = k-stepsConsumed;\\n            if(stepsConsumed>=0 && stepsConsumed!=1){\\n                ans = Math.max(ans, nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012753,
                "title": "c-greedy-and-observation-based-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        // If size of nums is one and k is odd then we will not have any element in the pile.\\n        // Therefore will return -1.\\n        if(nums.size() == 1 and k % 2 != 0) {\\n            return -1;\\n        }\\n        \\n        // If k is greater than nums.size() then the answer would be then maximum element of nums array.\\n        if(nums.size() < k) {\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        \\n        // This below condition will apply only when k is less than nums.size()\\n        // The answer would be be either the maximum from nums[0], nums[1], .... nums[k - 2] or nums[k].\\n        // We can never have nums[k - 1] as answer.\\n        int ans = 0;\\n        for(int i = 0; i < k - 1; i++) {\\n            ans = max(ans, nums[i]);\\n        }\\n        if(k < nums.size()) {\\n            ans = max(ans, nums[k]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        // If size of nums is one and k is odd then we will not have any element in the pile.\\n        // Therefore will return -1.\\n        if(nums.size() == 1 and k % 2 != 0) {\\n            return -1;\\n        }\\n        \\n        // If k is greater than nums.size() then the answer would be then maximum element of nums array.\\n        if(nums.size() < k) {\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        \\n        // This below condition will apply only when k is less than nums.size()\\n        // The answer would be be either the maximum from nums[0], nums[1], .... nums[k - 2] or nums[k].\\n        // We can never have nums[k - 1] as answer.\\n        int ans = 0;\\n        for(int i = 0; i < k - 1; i++) {\\n            ans = max(ans, nums[i]);\\n        }\\n        if(k < nums.size()) {\\n            ans = max(ans, nums[k]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844149,
                "title": "c-commented-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        if(k==0)return nums[0];  //can\\'t do anything in such a case\\n        \\n        if(nums.size()==1){  \\n            if(k%2!=0)return -1;   // will always end up with empty array after k operations.\\n            return nums[0];\\n        }\\n        \\n        int maxm=0, n=nums.size();\\n        for(auto i: nums)maxm=max(maxm,i);\\n        if(k>n)return maxm;   // can have any value from the array at the top in case k>n, hence, maximum element will be the result.\\n        \\n        int res=0;\\n        for(int i=0;i<k-1;i++)res=max(res,nums[i]);  //k>(k-1), hence, assume k-1 to be new n,so we can have any val from 0th to (k-2)th idx\\n                                                     //at the top, if we would want it to be at the top.\\n        \\n        if(k<n)res=max(res,nums[k]);                 //additional case, as we can remove elements from 0th to (k-1)th idx in k moves and if \\n                                                     //kth idx exists in the array then it can be a probable candidate for the answer too.\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        if(k==0)return nums[0];  //can\\'t do anything in such a case\\n        \\n        if(nums.size()==1){  \\n            if(k%2!=0)return -1;   // will always end up with empty array after k operations.\\n            return nums[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1845153,
                "title": "c-intutive-approach-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        stack<int>st;\\n        \\n        int n = nums.size();\\n        for(int i = nums.size()-1;i>=0;i--)\\n            st.push(nums[i]);\\n        \\n        if(k%2 != 0 && nums.size() == 1)\\n            return -1;\\n        \\n        if(k > n ){\\n            int maxi = *max_element(nums.begin(),nums.end());\\n            pq.push(maxi);\\n            k = k-1;\\n        }\\n        \\n        if(k!=n)\\n        k = k%nums.size();\\n        \\n        int steps = k-1;\\n        if(steps == 0){\\n            while(k--){\\n                st.pop();\\n            }\\n            if(st.empty())\\n            return -1;\\n        }\\n        \\n        while(steps > 0){\\n            pq.push(st.top());\\n            st.pop();\\n            steps--;\\n        }\\n        \\n        if(pq.size()>0){\\n        st.pop();\\n        if(st.empty())\\n            st.push(pq.top());\\n        else if(pq.top() > st.top())\\n        st.push(pq.top());\\n        }\\n        \\n        return st.top();\\n    }\\n};",
                "solutionTags": [
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        stack<int>st;\\n        \\n        int n = nums.size();\\n        for(int i = nums.size()-1;i>=0;i--)\\n            st.push(nums[i]);\\n        \\n        if(k%2 != 0 && nums.size() == 1)\\n            return -1;\\n        \\n        if(k > n ){\\n            int maxi = *max_element(nums.begin(),nums.end());\\n            pq.push(maxi);\\n            k = k-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844424,
                "title": "c-solution-explanation-short-code",
                "content": "**If n is 1 and k is odd**, then array will always be empty. In this case answer will be -1.\\n\\n**Example:** \\nnums=[23], k=3 , \\n\\nHere after first operation,\\nnums=[]\\n\\nAfter second operation,\\nnums=[23]\\n\\nAfter third operation,\\nnums=[]\\n\\n\\n**In rest of the situations, you have two options:**\\n1)  You can remove first k-1 elements, consuming k-1 operations.\\n\\t Among removed k-1 elements, choose the maximum element and place it on the top.\\n2)  Remove all k elements. Considering 0-based indexing, in this case, nums[k] will be topmost element.\\n\\nSince k can be upto 10^9,  we have to be careful.\\n\\nIn code, (k&1) is an alternative to k%2. \\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1&&(k&1)){\\n            return -1;\\n        }\\n        int mxm=-1;\\n        for(int i=0;i<n&&i<k-1;i++){\\n            mxm=max(mxm,nums[i]);\\n        }\\n        if(k<n){\\n            mxm=max(mxm,nums[k]);\\n        }\\n        return mxm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1&&(k&1)){\\n            return -1;\\n        }\\n        int mxm=-1;\\n        for(int i=0;i<n&&i<k-1;i++){\\n            mxm=max(mxm,nums[i]);\\n        }\\n        if(k<n){\\n            mxm=max(mxm,nums[k]);\\n        }\\n        return mxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844252,
                "title": "java-o-n-greedy",
                "content": "With k steps, other than the nums[k - 1] element, we can put any one form nums[0] to nums[k - 2] to the top;\\n we also need to compare the top one after remove k element if there is one;\\nTime: O(min(n,k))\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int ans = -1;\\n        if (nums.length == 1 && k % 2 == 1)\\n            return ans;\\n        //\\n        for (int i = 0; i < k - 1 && i < nums.length; i++) {\\n            ans = Math.max(ans, nums[i]);\\n        }\\n        if (k < nums.length)\\n            ans = Math.max(ans, nums[k]);\\n        return  ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int ans = -1;\\n        if (nums.length == 1 && k % 2 == 1)\\n            return ans;\\n        //\\n        for (int i = 0; i < k - 1 && i < nums.length; i++) {\\n            ans = Math.max(ans, nums[i]);\\n        }\\n        if (k < nums.length)\\n            ans = Math.max(ans, nums[k]);\\n        return  ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563379,
                "title": "4-line-java-code-beat-100",
                "content": "Please upvote if this helps\\n```\\npublic int maximumTop(int[] nums, int k) {\\n        int max = -1;\\n        if(nums.length==1) return k%2==1? max : nums[0];\\n        for(int i =0; i<nums.length && i<k-1; i++) max = Math.max(max,nums[i]);  \\n        return (k<nums.length && nums[k]>max)? nums[k]: max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumTop(int[] nums, int k) {\\n        int max = -1;\\n        if(nums.length==1) return k%2==1? max : nums[0];\\n        for(int i =0; i<nums.length && i<k-1; i++) max = Math.max(max,nums[i]);  \\n        return (k<nums.length && nums[k]>max)? nums[k]: max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2450648,
                "title": "c-easy-clean-code",
                "content": "class Solution {\\npublic\\n\\n    //source:bro coders\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1&&k%2)return -1;//k is odd\\n        if(k==1)return nums[1];//nums.size() wala edge case ho chuka \\n        int ans=0,n=nums.size();\\n        if(k>n){\\n            for(auto i:nums) ans=max(ans,i);\\n            return ans;\\n        }\\n        if(k==n){\\n            for(int i=0;i<k-1;i++) ans=max(ans,nums[i]);\\n            return ans;\\n        }\\n        else {\\n            for(int i=0;i<k-1;i++)ans=max(ans,nums[i]);     \\n            return max(ans,nums[k]);\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic\\n\\n    //source:bro coders\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1&&k%2)return -1;//k is odd\\n        if(k==1)return nums[1];//nums.size() wala edge case ho chuka \\n        int ans=0,n=nums.size();\\n        if(k>n){\\n            for(auto i:nums) ans=max(ans,i);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2449115,
                "title": "97-faster-c-easy-o-n",
                "content": "//**UPVOTE IF IT HELPS**\\n\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k==0)\\n            return nums[0];\\n        \\n        if(n==1)\\n        {   if(k%2!=0)\\n            return -1;\\n         else\\n             return nums[0];\\n        \\n        }\\n        int maxi =INT_MIN;\\n        if(k > n )\\n        {\\n         for(int i=0;i<nums.size();i++)\\n         {\\n            maxi = max(maxi,nums[i]);\\n         }\\n           return maxi; \\n        }\\n        else{\\n            int j=0;\\n            for(j=0;j<k-1;j++)\\n            {\\n                maxi=max(maxi,nums[j]);\\n            }\\n            if(nums[j+1] > maxi)\\n            {\\n                return nums[j+1];\\n            }\\n            else return maxi;\\n        }\\n        \\n        return -1;\\n    }\\n        \\n};",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k==0)\\n            return nums[0];\\n        \\n        if(n==1)\\n        {   if(k%2!=0)\\n            return -1;\\n         else\\n             return nums[0];\\n        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2297657,
                "title": "easy-soution-self-explanatory",
                "content": "```\\nclass Solution {\\n\\tpublic static int maximumTop(int[] arr, int k) {\\n\\t\\tif (arr.length == 1 && k % 2 == 1) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tint max = -1;\\n\\t\\tint len = Math.min(arr.length, k-1);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tmax = Math.max(arr[i], max);\\n\\t\\t}\\n\\t\\tif (k < arr.length) {\\n\\t\\t\\treturn Math.max(arr[k], max);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int maximumTop(int[] arr, int k) {\\n\\t\\tif (arr.length == 1 && k % 2 == 1) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tint max = -1;\\n\\t\\tint len = Math.min(arr.length, k-1);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tmax = Math.max(arr[i], max);\\n\\t\\t}\\n\\t\\tif (k < arr.length) {\\n\\t\\t\\treturn Math.max(arr[k], max);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948854,
                "title": "why-this-6-lines-code-works-java-o-1-space-o-n-time",
                "content": "```\\nRuntime: 1 ms, faster than 98.78% of Java online submissions for Maximize the Topmost Element After K Moves.\\nMemory Usage: 57.7 MB, less than 86.04% of Java online submissions for Maximize the Topmost Element After K Moves.\\n```\\n**Solution Code**\\n```\\nclass Solution {\\n    public int maximumTop(int[] ar, int k) {\\n        int n=ar.length;\\n        if(n==1 && k%2!=0)return -1; //base case\\n        int max = -1;\\n        for (int i = 0; i < Math.min(n , k + 1); i++) \\n            if (i != k - 1) max = Math.max(max, ar[i]);\\n        return max;\\n    }\\n    \\n}\\n\\n```\\n\\nTime `O(N)`\\nSpace `O(1)`\\n\\n**Why this solution works?**\\n- The base case is very clear. If we have odd operations to perform and length of given array is 1, then we\\'ll always be left with an empty array after the operations which is not valid.\\n- Now, we see we have `k` operations to perform. What can be the topmost element of the array? Let\\'s think over it. \\n\\t- The topmost element either can be the element peeked after popping `k` elements from array (considering `n >k`)\\n\\t- Or pop out `k-1` elements and for the kth move,push the max element we have popped so far. Read it again.\\n\\nWhat do we conclude?\\nTopmost element can be either kth index element (after removing k elements i.e 0,1,2,3...k-1 indices) or can be the max element we have got in removing k-1 elements  i.e 0,1,2,3...k-2 indices because 1 move will  be required to push the max element.\\nThis logic is what coded in the above solution.\\n\\nOR\\n\\nYou can visualize this as:\\n`(k-1)th` index can never be the topmost element, because if `(k-1)th` element is on the top that means \\n- either we have done only (k-1)moves so either push a value from popped elements or pop one more tocomplete k moves.\\n- or we have taken k+1 moves, k moves to pop upto `(k-1)th` index elements & one move again to push the  `(k-1)th` index element.\\n\\nHope you get the solution. Please upvote if you do.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nRuntime: 1 ms, faster than 98.78% of Java online submissions for Maximize the Topmost Element After K Moves.\\nMemory Usage: 57.7 MB, less than 86.04% of Java online submissions for Maximize the Topmost Element After K Moves.\\n```\n```\\nclass Solution {\\n    public int maximumTop(int[] ar, int k) {\\n        int n=ar.length;\\n        if(n==1 && k%2!=0)return -1; //base case\\n        int max = -1;\\n        for (int i = 0; i < Math.min(n , k + 1); i++) \\n            if (i != k - 1) max = Math.max(max, ar[i]);\\n        return max;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844584,
                "title": "c-priority-queue-simple-greedy",
                "content": "Consider the test case [5,6,7,8,10,18,14,6,7,8] and k = 6 output is 14.\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        if(k %2 != 0 and nums.size()==1)// if nums.size()==1 then if k is odd then it becomes empty \\n            return -1;\\n        if(k==1 and nums.size()>=2)return nums[1];\\n        priority_queue<int> pq;\\n       if( k > nums.size())\\n           return *max_element(nums.begin(), nums.end());\\n        else if(k==nums.size())\\n        {\\n             for(int i=0;i<k-1;i++)\\n            {\\n              pq.push(nums[i]);\\n            }\\n            return pq.top();\\n        }\\n        else\\n        {   //idea is simple boss:\\n            //remove k-1 elemets store the max and compare it with the nums[k] so either pq.top() wins or nums[k]\\n            for(int i=0;i<k-1;i++)\\n            {\\n              pq.push(nums[i]);\\n            }\\n            \\n            int ans = pq.top()>nums[k]?pq.top():nums[k];\\n          \\n            return ans;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        if(k %2 != 0 and nums.size()==1)// if nums.size()==1 then if k is odd then it becomes empty \\n            return -1;\\n        if(k==1 and nums.size()>=2)return nums[1];\\n        priority_queue<int> pq;\\n       if( k > nums.size())\\n           return *max_element(nums.begin(), nums.end());\\n        else if(k==nums.size())\\n        {\\n             for(int i=0;i<k-1;i++)\\n            {\\n              pq.push(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1844231,
                "title": "c-easy-detailed-explanation",
                "content": "- Either remove all k elements in the vector\\n- Either keep track of maximum in k - 1 elements and last operation is to put the element back in the element.\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size(), ans = -1;\\n        if(n == 1 && (k & 1))\\n            return ans;\\n        if(n > k)\\n            ans = max(ans, nums[k]);\\n        for(int i = 0; i < n && i < k - 1; ++i)\\n            ans = max(ans, nums[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size(), ans = -1;\\n        if(n == 1 && (k & 1))\\n            return ans;\\n        if(n > k)\\n            ans = max(ans, nums[k]);\\n        for(int i = 0; i < n && i < k - 1; ++i)\\n            ans = max(ans, nums[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844225,
                "title": "python-solution-by-analyzing-all-cases",
                "content": "**Basically we want to remove as many values as possible to maximize the value of number that we can add, yet have atleast one/more operations in hand to add these values back into nums as out topmost element. Otherwise we would have had the largest value but we won\\'t be able to add it.**\\n1. **Case 1 `k == 0`:** Since no removal is possible, just return the top of nums.\\n2. **Case 2 `k == 1`:** One removal allowed but the size of array might be 1 in which case we have and empty list thus return -1. If len(nums) > 1 then return 1st value since 0th index value was removed\\n3. **Case 3 `n == 1`:** Since size of nums is 1. If even number of operations are allowed then we will have a non empty list and empty is k is odd.\\n4. **Case 4 IMPORTANT CASE `k-n-1 >= 0`:** It means that k is sufficiently large enough that we can remove all the elements from the array, reserve one operation to add the largest of all the values removed so far, and still be left with 0 or more operations. Since we already reserved one operation for adding the largest value removed into the array as its top most element. This simply return the maximum value from nums.\\n5. **Case 5 `n == k`:** We cannot remove all values since then we will be left with no operation to do and an empty array which is not the best approach. We remove k-1 numbers and add the maximum from those.\\n6. **Case 6 `n > k`:** We can either remove k-1 numbers and then add the largest values from those or we can remove all k numbers and then let the top most remaining value in nums be the top most value of nums.\\n\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if k == 0:\\n            return nums[0]\\n        if k == 1:\\n            if n == 1:\\n                return -1\\n            else:\\n                return nums[1]\\n        if n == 1:\\n            if k % 2 != 0:\\n                return -1\\n            else:\\n                return nums[0]\\n        if k - n - 1 >= 0:\\n            return max(nums)\\n        if n == k:\\n            return max(nums[0:k - 1])\\n        if n > k:\\n            return max(max(nums[0:k - 1]), nums[k])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if k == 0:\\n            return nums[0]\\n        if k == 1:\\n            if n == 1:\\n                return -1\\n            else:\\n                return nums[1]\\n        if n == 1:\\n            if k % 2 != 0:\\n                return -1\\n            else:\\n                return nums[0]\\n        if k - n - 1 >= 0:\\n            return max(nums)\\n        if n == k:\\n            return max(nums[0:k - 1])\\n        if n > k:\\n            return max(max(nums[0:k - 1]), nums[k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844203,
                "title": "very-esy-to-understand-c-o-n-solution-using-stack",
                "content": "\\n\\n         int x=k;\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        bool temp=true;\\n        if(k>n){\\n            x=n+1;\\n            temp=false;\\n        }\\n       stack<int>st;\\n        for(int i=0;i<x-1;i++){\\n            maxi=max(maxi,nums[i]);\\n            st.push(nums[i]);\\n        }\\n        if(n==1 and k%2==1){\\n            maxi=-1;\\n        }\\n        else if(x<n){\\n            maxi=max(nums[x],maxi);\\n        }\\n        return maxi;",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "\\n\\n         int x=k;\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        bool temp=true;\\n        if(k>n){\\n            x=n+1;\\n            temp=false;\\n        }\\n       stack<int>st;\\n        for(int i=0;i<x-1;i++){\\n            maxi=max(maxi,nums[i]);\\n            st.push(nums[i]);\\n        }\\n        if(n==1 and k%2==1){\\n            maxi=-1;\\n        }\\n        else if(x<n){\\n            maxi=max(nums[x],maxi);\\n        }\\n        return maxi;",
                "codeTag": "Unknown"
            },
            {
                "id": 3101410,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\nThere can be three cases when \\n1)k>arr.length\\n2)k==arr.length\\n3)k<arr.length\\n\\n\\n# Approach\\n1)When k>len\\nThere can be two possibilities in this:\\n\\n1.When the array has only 1 element then if k is even return max element else when k is odd the only element is removed and array left is empty return -1\\n\\n2.When more than one element is there then we can simply return the max of the array element\\n\\n2)When k==len then we need to find the max from arr[k-1]\\n\\n3)When k<len then we need to find max of max(arr[k-1]) and arr[k]\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k-1)\\n\\n# Code\\n```\\n/*There can be three cases when \\n1)k>arr.length\\n2)k==arr.length\\n3)k<arr.length\\n*/\\nclass Solution {\\n    //defining a function to return the max from the array\\n    public int max(int[] arr)\\n    {\\n        int m=Integer.MIN_VALUE;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if (arr[i]>m)\\n            m=arr[i];\\n        }\\n        return m;\\n    }\\n    public int maximumTop(int[] nums, int k) {\\n        int len=nums.length;\\n        /*1)When k>len\\n        there can be two possibilities in this\\n        1.When the array has only 1 element then if k is even return max element else when k is odd the only element is removed and array left is empty return -1\\n        2.When more than one element is there then we can simply return the max of the array element*/\\n        if (k>len)\\n        {\\n            if(len==1)\\n            {\\n                if(k%2!=0)\\n                return -1;\\n            }\\n            return max(nums);\\n        }\\n        /*When k==len then we need to find the max from arr[k-1]*/\\n        else if(k==len)\\n        {\\n            int temp[]=new int[k-1];\\n            for(int i=0;i<k-1;i++)\\n            temp[i]=nums[i];\\n            if (temp.length!=0)\\n            return max(temp);\\n        }\\n        /*When k<len then we need to find max of max(arr[k-1]) and arr[k]*/\\n        else\\n        {\\n            if (k==0)\\n            return nums[0];\\n            else\\n            {\\n            int temp[]=new int[k-1];\\n            for(int i=0;i<k-1;i++)\\n            temp[i]=nums[i];\\n            int m=max(temp);\\n            return Math.max(m,nums[k]);\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*There can be three cases when \\n1)k>arr.length\\n2)k==arr.length\\n3)k<arr.length\\n*/\\nclass Solution {\\n    //defining a function to return the max from the array\\n    public int max(int[] arr)\\n    {\\n        int m=Integer.MIN_VALUE;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if (arr[i]>m)\\n            m=arr[i];\\n        }\\n        return m;\\n    }\\n    public int maximumTop(int[] nums, int k) {\\n        int len=nums.length;\\n        /*1)When k>len\\n        there can be two possibilities in this\\n        1.When the array has only 1 element then if k is even return max element else when k is odd the only element is removed and array left is empty return -1\\n        2.When more than one element is there then we can simply return the max of the array element*/\\n        if (k>len)\\n        {\\n            if(len==1)\\n            {\\n                if(k%2!=0)\\n                return -1;\\n            }\\n            return max(nums);\\n        }\\n        /*When k==len then we need to find the max from arr[k-1]*/\\n        else if(k==len)\\n        {\\n            int temp[]=new int[k-1];\\n            for(int i=0;i<k-1;i++)\\n            temp[i]=nums[i];\\n            if (temp.length!=0)\\n            return max(temp);\\n        }\\n        /*When k<len then we need to find max of max(arr[k-1]) and arr[k]*/\\n        else\\n        {\\n            if (k==0)\\n            return nums[0];\\n            else\\n            {\\n            int temp[]=new int[k-1];\\n            for(int i=0;i<k-1;i++)\\n            temp[i]=nums[i];\\n            int m=max(temp);\\n            return Math.max(m,nums[k]);\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011593,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind maximum of from first k-1 elements(save 1 last step for placing back the maximum element)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind maximum of from first k-1 elements(save 1 last step for placing back the maximum element).\\nIf(steps are greater than nums size) return maximum element;\\nElse{\\n      we now have a maximum element till index k-1 and 1 step with remaining array\\n      we want maximum element, we can either place the maximum found element back on pile in last step or remove element from last step(if stack does not get empty after removing another element) as the maximum we are holding might be less than element we get at top of pile after removing one more element from remaining pile\\n      \\n     Evaluate both scenarios and return maximum element \\n \\n}\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2!=0) return -1;\\n        else if(nums.size()==1 && k%2==0) return nums[0];  \\n        if(k==0) return nums[0];\\n        if(k==1) return nums[1];\\n        \\n        int maximum=0;\\n        int i=0;\\n        for(;i<k-1;i++){\\n            if(i==nums.size()){\\n                break;\\n            }\\n            maximum=max(maximum,nums[i]);\\n        }\\n        if(i<nums.size()-1){\\n            i++;\\n            if(nums[i]>maximum) return nums[i];\\n        }\\n        return maximum;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2!=0) return -1;\\n        else if(nums.size()==1 && k%2==0) return nums[0];  \\n        if(k==0) return nums[0];\\n        if(k==1) return nums[1];\\n        \\n        int maximum=0;\\n        int i=0;\\n        for(;i<k-1;i++){\\n            if(i==nums.size()){\\n                break;\\n            }\\n            maximum=max(maximum,nums[i]);\\n        }\\n        if(i<nums.size()-1){\\n            i++;\\n            if(nums[i]>maximum) return nums[i];\\n        }\\n        return maximum;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543792,
                "title": "java-100-faster-with-explanation",
                "content": "*Please upvote if you find this solution useful.*\\n\\n**Intuition:**\\n1. This looked like a greedy problem for me because we are looking for the maximum value after a sequence of operations\\n2. So I tried to figure out all the possible patterns. The different patterns I could see were,\\n\\ti. No moves possible case.\\n\\tii. k > nums.length\\n\\tiii. k <= nums.length\\n3. The simplest pattern is \"No moves possible\". \\n\\ti. If nums.length is more than 1, we can take and put back the same number any number of times. So we will definitely have a solution. \\n\\tii. When k is even also, we can take and put back the same item, resulting in some value.\\n\\tiii. So, the only case where we will return -1 is when there is only 1 number in the array and the k value is odd.\\n4. When k > nums.length, we can return the maximum value as we can cycle and bring the maximum value to the top.\\n5. When k <= nums.length is very similar to the previous case except we can\\'t bring the kth element to the top. \\n\\ti. This is because we need `k - 1` moves to reach the kth element and in the last move, we either have to pick the element or keep another element on top. \\n\\tii. So, we find the maximum value in the first `k + 1` elements.\\n6. Time complexity: `O(n)` and space complexity: `O(1)`.\\n\\t\\n**Code**\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(k % 2 == 1 && nums.length == 1) return -1;\\n        int ans = -1;\\n        if(k > nums.length){\\n            for(int num : nums) ans = Math.max(ans, num);\\n        }\\n        else{\\n            for(int i = 0; i < k - 1; i++){\\n                ans = Math.max(ans, nums[i]);\\n            }\\n            if(k < nums.length) ans = Math.max(ans, nums[k]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nNote: We can remove the if-else conditions and make the code shorter but I wanted to upload a version that is similar to my explanation and is easy to understand.",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(k % 2 == 1 && nums.length == 1) return -1;\\n        int ans = -1;\\n        if(k > nums.length){\\n            for(int num : nums) ans = Math.max(ans, num);\\n        }\\n        else{\\n            for(int i = 0; i < k - 1; i++){\\n                ans = Math.max(ans, nums[i]);\\n            }\\n            if(k < nums.length) ans = Math.max(ans, nums[k]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445878,
                "title": "java-return-max-or-next",
                "content": "\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        \\n        int mx = -1;\\n        int n = nums.length;\\n        int next = -1;\\n        \\n        if(k < n) next = nums[k];\\n        if(n == 1 && k % 2 == 1) return mx;\\n        \\n        int s = Math.min(k - 1, n);\\n        for(int i = 0; i < s; i++){\\n            mx = Math.max(nums[i], mx);\\n        }\\n        return Math.max(mx, next);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        \\n        int mx = -1;\\n        int n = nums.length;\\n        int next = -1;\\n        \\n        if(k < n) next = nums[k];\\n        if(n == 1 && k % 2 == 1) return mx;\\n        \\n        int s = Math.min(k - 1, n);\\n        for(int i = 0; i < s; i++){\\n            mx = Math.max(nums[i], mx);\\n        }\\n        return Math.max(mx, next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884610,
                "title": "checking-top-k-elements",
                "content": "**Approach**\\nCheck for all the elements in ``arr`` if it is possible to make it the top-most element in the array in exactly ``k`` number of steps i.e. moves. And then find the maximum of all the possible candidates.\\n \\n**How to check if it is possible to make an element the top-most element? (Also a Proof)**\\nLet\\'s see how can we use the given ``k`` moves to make an element ``arr[i]`` the top most element.\\n\\n> To reach any element ``arr[i]`` in the ``arr``, we have to first use ``i`` moves because we have to remove the first ``i`` number of elements from the array and if ``i`` is greater than ``k`` then we cannot reach it.\\n\\nThis leaves us with ``k - i`` moves remaining.\\n\\nIf we have reached the element ``arr[i]`` then the following cases arise.\\n\\n**Case 1** - ``k - i == 0``. No moves are available. The element ``arr[i]`` is already at the top and hence a candidate. \\n\\n**Case 2** - ``k - i == 1``. We cannot make ``arr[i]`` the top-most element since a ``pop`` operation will remove ``arr[i]`` from the stack and a ``push from pile`` operation will change the top-most element.\\n\\n**Case 3** - ``k - i`` is even. \\n> In this case, for the element ``arr[i]`` we can follow the sequence ``[(pop, push), (pop, push), ..., (pop, push)]`` and in each atomic operation ``(pop, push)`` we end up with the current element on top.\\n> This way we exhaust all our ``k - i``moves and make the element ``arr[i]`` the top-most element in exactly ``k`` steps and hence we can include it in our candidates.\\n\\n**Case 4** - ``k - i`` is odd. \\n> In this case, if we follow the ``(pop, push)`` sequence the last operation will always be a ``pop`` operation which will fail our objective.\\n> \\n> *So, what to do in this case?* \\n> Now, the operation ``If there are one or more removed elements, add any one of them back onto the pile. This element becomes the new topmost element`` given in the problem comes in handy.\\n>\\n> Let\\'s first use the extra moves by following the sequence ``[(pop, push), (pop, push), ..., (pop, push)]`` for the current element ``arr[i]`` till there are ``3`` moves remaining.\\n> \\n> And hence the following sub-cases arise:-\\n> **Case 4.a** - If we already have some elements in the pile i.e. the elements we removed before to reach this element.\\n> > Then follow the sequence``\"pop arr[i]\", \"push from pile\"`` and then ``\"push arr[i]\"``. The current element ``arr[i]`` will end up being on the top.\\n> > **Note** - The operation \"Push from pile\" pushes any element ``arr[j]`` where ``i != j``.\\n> \\n> **Case 4.b** - What if there are no elements in the pile and ``arr[i]`` is not the last element?\\n> > Then follow the sequence``\"pop arr[i]\", \"pop arr[i + 1]\"`` and then ``\"push arr[i]\"``. The current element ``arr[i]`` will end up being on the top.\\n>  \\n> In any other case, we cannot make the current element ``arr[i]`` the top-most and hence it will be exculded from the candidature.\\n\\nNow, compute the maximum from all the candidates.\\n\\n**Code**\\n```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\t\\n\\tint res = -1, curr, moves;\\n\\tfor(int i = 0; i < n && k - i >= 0; i++) {\\n\\t\\tmoves = k - i;\\n\\t\\tcurr = nums[i];\\n            \\n\\t\\tif(moves > 0) {\\n\\t\\t\\t// Even Case\\n\\t\\t\\tif(moves%2 == 0(\\n\\t\\t\\t\\tmoves = 0;\\n\\t\\t\\t// Odd Case\\n\\t\\t\\telse if(moves != 1 && (n - i - 1 >= 1 || i))\\n\\t\\t\\t\\tmoves = 0;\\n\\t\\t\\t// All Other Cases\\n\\t\\t\\telse\\n\\t\\t\\t\\tmoves = -1;\\n\\t\\t}\\n            \\n\\t\\tif(moves == 0)\\n\\t\\t\\tres = max<int>(res, curr);\\n\\t}\\n        \\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\t\\n\\tint res = -1, curr, moves;\\n\\tfor(int i = 0; i < n && k - i >= 0; i++) {\\n\\t\\tmoves = k - i;\\n\\t\\tcurr = nums[i];\\n            \\n\\t\\tif(moves > 0) {\\n\\t\\t\\t// Even Case\\n\\t\\t\\tif(moves%2 == 0(\\n\\t\\t\\t\\tmoves = 0;\\n\\t\\t\\t// Odd Case\\n\\t\\t\\telse if(moves != 1 && (n - i - 1 >= 1 || i))\\n\\t\\t\\t\\tmoves = 0;\\n\\t\\t\\t// All Other Cases\\n\\t\\t\\telse\\n\\t\\t\\t\\tmoves = -1;\\n\\t\\t}\\n            \\n\\t\\tif(moves == 0)\\n\\t\\t\\tres = max<int>(res, curr);\\n\\t}\\n        \\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1849230,
                "title": "explained-greedy-approach-with-comments-linear-time-complexity-c-clean-code",
                "content": "\\n*Note : Logic is explained in detail along with code using comments.*\\n# Code : \\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Case : If we cannot remove element then return first one\\n        if(k == 0) return nums[0];\\n\\t\\t\\n\\t\\t// Case : If only one element is present\\n        if(n == 1) {\\n\\t\\t\\t// Case : If we have to remove just one element, \\n\\t\\t\\t// then array would be empty and hence return -1\\n            if(k == 1) return -1;\\n\\t\\t\\t\\n\\t\\t\\t// In order to get top element by performing 2 operation, \\n\\t\\t\\t// we need even number of steps. \\n\\t\\t\\t// Else if we have odd number of moves available, return -1\\n            if(k > n) {\\n                if(k&1) return -1;\\n                else return nums[0];\\n            }\\n        }\\n        \\n\\t\\t// maxVal : stores maximum value that we encounter till some index\\n\\t\\t// lastIndex : stores the last index till we run out of moves\\n        int maxVal = -1, lastIndex = -1;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// Break when we have one move available\\n\\t\\t\\t// This is due to the fact that, using this last move\\n\\t\\t\\t// we can again put maximum element as topmost element.\\n            if(k-1 == 0) {\\n                lastIndex = i;\\n                break;\\n            }\\n\\t\\t\\t// Update maximum value and decrement number of moves available.\\n            maxVal = max(maxVal, nums[i]);\\n            k--;\\n        }\\n        \\n\\t\\t// If next element that is after lastIndex is greater than maxVal,\\n\\t\\t// then we can remove element at lastIndex. And get maximum topmost element\\n\\t\\t// Or else we put element with maxVal again as topmost element\\n\\t\\t// using our last move available.\\n        if(index >= 0) maxVal = max(maxVal, nums[lastIndex+1]);\\n        \\n        return maxVal;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N)`\\n* Space : `O(1)`\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Case : If we cannot remove element then return first one\\n        if(k == 0) return nums[0];\\n\\t\\t\\n\\t\\t// Case : If only one element is present\\n        if(n == 1) {\\n\\t\\t\\t// Case : If we have to remove just one element, \\n\\t\\t\\t// then array would be empty and hence return -1\\n            if(k == 1) return -1;\\n\\t\\t\\t\\n\\t\\t\\t// In order to get top element by performing 2 operation, \\n\\t\\t\\t// we need even number of steps. \\n\\t\\t\\t// Else if we have odd number of moves available, return -1\\n            if(k > n) {\\n                if(k&1) return -1;\\n                else return nums[0];\\n            }\\n        }\\n        \\n\\t\\t// maxVal : stores maximum value that we encounter till some index\\n\\t\\t// lastIndex : stores the last index till we run out of moves\\n        int maxVal = -1, lastIndex = -1;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// Break when we have one move available\\n\\t\\t\\t// This is due to the fact that, using this last move\\n\\t\\t\\t// we can again put maximum element as topmost element.\\n            if(k-1 == 0) {\\n                lastIndex = i;\\n                break;\\n            }\\n\\t\\t\\t// Update maximum value and decrement number of moves available.\\n            maxVal = max(maxVal, nums[i]);\\n            k--;\\n        }\\n        \\n\\t\\t// If next element that is after lastIndex is greater than maxVal,\\n\\t\\t// then we can remove element at lastIndex. And get maximum topmost element\\n\\t\\t// Or else we put element with maxVal again as topmost element\\n\\t\\t// using our last move available.\\n        if(index >= 0) maxVal = max(maxVal, nums[lastIndex+1]);\\n        \\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846662,
                "title": "c-no-stack-no-queue-85-faster",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int maximumTop(vector<int>& nums, int k)\\n    {\\n        if(nums.size() == 1 && k%2 == 1) return -1;\\n        else if(nums.size() == 1 && k%2 == 0) return nums[0];\\n        if(k==0) return nums[0];\\n        if(k > nums.size())\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                maxi = max(maxi,nums[i]);\\n            }\\n            return maxi;\\n        }\\n        else if(k == nums.size())\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0;i<nums.size()-1;i++)\\n            {\\n                maxi = max(maxi,nums[i]);\\n            }\\n            return maxi;\\n        }\\n        else\\n        {\\n            int maxi = INT_MIN;\\n            int m=0;\\n            while(m < k-1)\\n            {\\n                maxi = max(maxi,nums[m++]);\\n            }\\n            return max(maxi,nums[k]);\\n        }\\n        return -1;\\n         \\n    }\\n};\\n\\n#IF THIS CODE IS HELPUL FOR U THEN PLEASE UPVOTE !!!\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int maximumTop(vector<int>& nums, int k)\\n    {\\n        if(nums.size() == 1 && k%2 == 1) return -1;\\n        else if(nums.size() == 1 && k%2 == 0) return nums[0];\\n        if(k==0) return nums[0];\\n        if(k > nums.size())\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                maxi = max(maxi,nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1845511,
                "title": "c-short-crisp-code-greedy-approach-linear-time-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k%2!=0 && nums.size()==1) return -1;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k-1 && i<nums.size();i++) maxi=max(maxi,nums[i]);\\n        if(k<nums.size()) maxi=max(maxi,nums[k]);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k%2!=0 && nums.size()==1) return -1;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k-1 && i<nums.size();i++) maxi=max(maxi,nums[i]);\\n        if(k<nums.size()) maxi=max(maxi,nums[k]);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844751,
                "title": "c-time-o-1-explained",
                "content": "1. Base cases and k>=n\\n\\ta. If nums size is 1 and operations are odd then after operations nums will be empty so return -1.\\n\\tb. If no.s of operations are 0 or 1 then return 0th or 1st element only as no push back will be done from popped elements. \\n\\tc. If no.s of operations are equal to size of nums then max element in nums.size() -1  will be the result as we will pop k-1 elements and push max in last operation.\\n2. If k<n\\n\\ta. Result will be in first k+1 elements only i.e. max(nums[k],max(nums[0] to nums[k-1])) since if kth element is max then we will do k deletions only or if any other element is max then we do deletion till max let say m deletions and then k-m-1 push/pop alternate operation of any number and lastly push max on top. \\n\\t\\nAssuming time to find max using *max_element is constant. TC: O(1)\\n\\nPlease consider upvote if you like the solution \\n```\\nint maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if((n==1) && (k%2!=0))\\n            return -1;\\n        else if(k==0 || k==1)\\n            return nums[k];\\n        else if(k==n)\\n            return *max_element(nums.begin(),nums.begin()+n-1);\\n        else if(k>n)\\n            return *max_element(nums.begin(),nums.begin()+n);\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if((n==1) && (k%2!=0))\\n            return -1;\\n        else if(k==0 || k==1)\\n            return nums[k];\\n        else if(k==n)\\n            return *max_element(nums.begin(),nums.begin()+n-1);\\n        else if(k>n)\\n            return *max_element(nums.begin(),nums.begin()+n);\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844390,
                "title": "c-simple-solution-with-comments-easy-to-understand",
                "content": "The below code is explained with approach and mindset behind the approach.\\nPlease go through the comments. Fell free to ping me if any queries .\\nThis was weekly contest 284 question.\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k%2!=0&&nums.size()==1)//coner case where u will end up with empty array.\\n            return -1;\\n        if(k==1&&nums.size()>1)//case where k=1 so kth element is largest as all u can do is remove element i=0.\\n            return nums[1];\\n        if(k==0)                //if no moves given then u just return the 0th index.\\n            return nums[0];\\n        int max=INT_MIN;\\n        if(k>nums.size())       //condition when moves greater then the size of nums u just find the largetest element and return that.\\n        {\\n           max= *max_element (nums.begin(),nums.end());\\n        }\\n        else\\n        { max= *max_element (nums.begin(),nums.begin()+k-1); // when moves<= nums size\\n                                                            //then we have to find max form (0 to k-2)th index both included.                                                                           //as one move will be required to put the max back at top. \\n            if(nums[k]>max)    //check if the kth element is greater then your current max\\n                max=nums[k];   //Then make nums[k]= max as then u would remove all the elements till k-1 index.\\n        }\\n        return max;\\n    }\\n};\\n```\\nIf you like the solution a upvote is appreciated.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k%2!=0&&nums.size()==1)//coner case where u will end up with empty array.\\n            return -1;\\n        if(k==1&&nums.size()>1)//case where k=1 so kth element is largest as all u can do is remove element i=0.\\n            return nums[1];\\n        if(k==0)                //if no moves given then u just return the 0th index.\\n            return nums[0];\\n        int max=INT_MIN;\\n        if(k>nums.size())       //condition when moves greater then the size of nums u just find the largetest element and return that.\\n        {\\n           max= *max_element (nums.begin(),nums.end());\\n        }\\n        else\\n        { max= *max_element (nums.begin(),nums.begin()+k-1); // when moves<= nums size\\n                                                            //then we have to find max form (0 to k-2)th index both included.                                                                           //as one move will be required to put the max back at top. \\n            if(nums[k]>max)    //check if the kth element is greater then your current max\\n                max=nums[k];   //Then make nums[k]= max as then u would remove all the elements till k-1 index.\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844385,
                "title": "python-9-lines",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 == 1 else nums[0]\\n        if k <= 1:\\n            return nums[k]\\n        if k < len(nums):\\n            return max(max(nums[:k-1]), nums[k])\\n        if k < len(nums) + 2: \\n            return max(nums[:k-1])\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 == 1 else nums[0]\\n        if k <= 1:\\n            return nums[k]\\n        if k < len(nums):\\n            return max(max(nums[:k-1]), nums[k])\\n        if k < len(nums) + 2: \\n            return max(nums[:k-1])\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844277,
                "title": "c-greedy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& arr, int k) {\\n        \\n        if(arr.size()==1 and k==0){\\n            return arr[0];\\n        }\\n        \\n        if(arr.size()==1 and k%2){\\n            return -1;\\n        }\\n        \\n        if(k==0){\\n            return arr[0];\\n        }\\n        \\n        int res=0;\\n        \\n        if(arr.size()<k){\\n            for(auto &x:arr){\\n                res=max(x,res);\\n            }\\n            return res;\\n        }\\n        \\n        reverse(arr.begin(),arr.end());\\n        \\n        while(k-1){\\n            res=max(res,arr.back());\\n            arr.pop_back();\\n            k--;\\n        }\\n        arr.pop_back();\\n        \\n        if(arr.size()==0){\\n            return res;\\n        }\\n        \\n        res=max(res,arr.back());\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& arr, int k) {\\n        \\n        if(arr.size()==1 and k==0){\\n            return arr[0];\\n        }\\n        \\n        if(arr.size()==1 and k%2){\\n            return -1;\\n        }\\n        \\n        if(k==0){\\n            return arr[0];\\n        }\\n        \\n        int res=0;\\n        \\n        if(arr.size()<k){\\n            for(auto &x:arr){\\n                res=max(x,res);\\n            }\\n            return res;\\n        }\\n        \\n        reverse(arr.begin(),arr.end());\\n        \\n        while(k-1){\\n            res=max(res,arr.back());\\n            arr.pop_back();\\n            k--;\\n        }\\n        arr.pop_back();\\n        \\n        if(arr.size()==0){\\n            return res;\\n        }\\n        \\n        res=max(res,arr.back());\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844250,
                "title": "c-all-cases-handled",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            if(k&1) return -1;\\n            else   return nums[0];\\n        }\\n        if(k<n) {\\n            if(k==1) return nums[1];\\n            if(k==2) return max(nums[0],nums[2]);\\n            return max(*(max_element(nums.begin(),nums.begin() + k-1)) , nums[k]);\\n        }\\n        if(k==n){\\n            return *(max_element(nums.begin(),nums.begin() + k-1));\\n        }\\n        return *(max_element(nums.begin(),nums.begin()+n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            if(k&1) return -1;\\n            else   return nums[0];\\n        }\\n        if(k<n) {\\n            if(k==1) return nums[1];\\n            if(k==2) return max(nums[0],nums[2]);\\n            return max(*(max_element(nums.begin(),nums.begin() + k-1)) , nums[k]);\\n        }\\n        if(k==n){\\n            return *(max_element(nums.begin(),nums.begin() + k-1));\\n        }\\n        return *(max_element(nums.begin(),nums.begin()+n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844222,
                "title": "2202-easy-to-understand-edge-case-soln-maximize-the-topmost-element-after-k-moves",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& A, int k) {\\n        int N = A.size();\\n        if (k == 0) return N >= 1 ? A[0] : -1; // if no moves allowed, return the topmost element if any\\n        if (k == 1) return N == 1 ? -1 : A[1]; // if only one move is allowed, we can only remove the topmost element\\n        if (N == 1) return k % 2 == 0 ? A[0] : -1; // if `N == 1`, we can return the topmost element if `k` is a even number (keep removing the topmost element and adding it back).\\n        int mx = *max_element(begin(A), begin(A) + min(k - 1, N)); // we can take `k-1` elements and put back the largest one on the top\\n        if (k < N) mx = max(mx, A[k]); // If `k < N`, we can take all the topmost `k` elements and return the one left at the top\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& A, int k) {\\n        int N = A.size();\\n        if (k == 0) return N >= 1 ? A[0] : -1; // if no moves allowed, return the topmost element if any\\n        if (k == 1) return N == 1 ? -1 : A[1]; // if only one move is allowed, we can only remove the topmost element\\n        if (N == 1) return k % 2 == 0 ? A[0] : -1; // if `N == 1`, we can return the topmost element if `k` is a even number (keep removing the topmost element and adding it back).\\n        int mx = *max_element(begin(A), begin(A) + min(k - 1, N)); // we can take `k-1` elements and put back the largest one on the top\\n        if (k < N) mx = max(mx, A[k]); // If `k < N`, we can take all the topmost `k` elements and return the one left at the top\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844136,
                "title": "o-min-n-k-solution-c-multiple-cases-explanation",
                "content": "There are two possible ways to use the K operations. Consider 0-indexing for the array.\\n\\n1. you can remove the top (K-1) elements and use one operation to add back the max element of removed (K-1) elements.\\n2. you can remove the first K elements(0 to K-1) from the array and the maximum element can be a[K].\\n\\nBase Case: \\nk==0 -> first element is the anwer.\\nn==1 and k is odd -> array is always empty.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        // array size is atleast 1. (k==0)-> no element is removed.\\n        if(k==0)\\n            return nums[0];\\n        \\n        int n=nums.size();\\n        \\n        // if n==1 and k is odd then the array will always be empty.\\n        if(n==1 and k%2==1)\\n            return -1;\\n        \\n        \\n        int ans=-1;\\n        \\n        // assume the first k elements are removed. answer can be nums[k]. \\n        if(k<n)\\n            ans=nums[k];\\n\\n        k--;\\n        \\n        // find the maximum of the first (K-1) elements.\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k and i<n;i++)\\n            maxi=max(maxi,nums[i]);\\n        \\n        // maximum of (K-1) elements can be the answer.\\n        if(maxi!=INT_MIN)\\n            ans=max(ans,maxi);\\n        \\n        return ans;\\n        \\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        // array size is atleast 1. (k==0)-> no element is removed.\\n        if(k==0)\\n            return nums[0];\\n        \\n        int n=nums.size();\\n        \\n        // if n==1 and k is odd then the array will always be empty.\\n        if(n==1 and k%2==1)\\n            return -1;\\n        \\n        \\n        int ans=-1;\\n        \\n        // assume the first k elements are removed. answer can be nums[k]. \\n        if(k<n)\\n            ans=nums[k];\\n\\n        k--;\\n        \\n        // find the maximum of the first (K-1) elements.\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k and i<n;i++)\\n            maxi=max(maxi,nums[i]);\\n        \\n        // maximum of (K-1) elements can be the answer.\\n        if(maxi!=INT_MIN)\\n            ans=max(ans,maxi);\\n        \\n        return ans;\\n        \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3645657,
                "title": "o-n-prefix-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(!k) return nums[0];\\n\\n        int n = nums.size();\\n        int mx = 0;\\n        vector<int> prefix;\\n        for(int i : nums) {\\n            mx = max(mx, i);\\n            prefix.push_back(mx);\\n        }\\n        \\n        if(k > n) {\\n            if(n == 1) return k % 2 ? -1 : mx;\\n            return mx;\\n        }\\n        if(k == 1) return n == 1 ? -1 : nums[1];\\n        if(k == n) return prefix[n - 2];\\n        return max(prefix[k - 2], nums[k]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(!k) return nums[0];\\n\\n        int n = nums.size();\\n        int mx = 0;\\n        vector<int> prefix;\\n        for(int i : nums) {\\n            mx = max(mx, i);\\n            prefix.push_back(mx);\\n        }\\n        \\n        if(k > n) {\\n            if(n == 1) return k % 2 ? -1 : mx;\\n            return mx;\\n        }\\n        if(k == 1) return n == 1 ? -1 : nums[1];\\n        if(k == n) return prefix[n - 2];\\n        return max(prefix[k - 2], nums[k]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135303,
                "title": "bruh",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximum_top(nums: Vec<i32>, k: i32) -> i32 {\\n        if k == 0 { return nums[0];}\\n        let k = k as usize;\\n        /* Edge Cases */\\n        match (nums.len(),k%2) {\\n            (1,0) => {return nums[0];},\\n            (1,1) => {return -1;},\\n            _ => ()\\n        };\\n        if k == 1 { return nums[1]; }\\n        /*           */\\n        *match k.cmp(&nums.len()) {\\n            std::cmp::Ordering::Equal => nums[..k-1].iter().max().unwrap(),\\n            std::cmp::Ordering::Greater => nums.iter().max().unwrap(),\\n            _ => if k == 2 { return nums[0].max(nums[2]); } else { nums[..k-1].iter().max().unwrap().max(&nums[k]) }            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_top(nums: Vec<i32>, k: i32) -> i32 {\\n        if k == 0 { return nums[0];}\\n        let k = k as usize;\\n        /* Edge Cases */\\n        match (nums.len(),k%2) {\\n            (1,0) => {return nums[0];},\\n            (1,1) => {return -1;},\\n            _ => ()\\n        };\\n        if k == 1 { return nums[1]; }\\n        /*           */\\n        *match k.cmp(&nums.len()) {\\n            std::cmp::Ordering::Equal => nums[..k-1].iter().max().unwrap(),\\n            std::cmp::Ordering::Greater => nums.iter().max().unwrap(),\\n            _ => if k == 2 { return nums[0].max(nums[2]); } else { nums[..k-1].iter().max().unwrap().max(&nums[k]) }            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012617,
                "title": "easy-cpp-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        int ans=-1;\\n        if(k==1&&nums.size()==1)return -1;\\n        if(nums.size()==1 && k%2==1)return -1;\\n        if(k==1 && nums.size()>1)return nums[1];\\n        if(k>nums.size())\\n        {\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        else\\n        {\\n            queue<int>q;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                q.push(nums[i]);\\n            }\\n        \\n                int t=k-1;\\n                while(t>0)\\n                {\\n                    \\n                    ans=max(ans,q.front());\\n                    q.pop();\\n                    t--;\\n                    \\n                }\\n               if(q.size()>1)\\n               {\\n                   q.pop();\\n                    if(ans<q.front())\\n                    {\\n                        return q.front();\\n                    }\\n               }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        int ans=-1;\\n        if(k==1&&nums.size()==1)return -1;\\n        if(nums.size()==1 && k%2==1)return -1;\\n        if(k==1 && nums.size()>1)return nums[1];\\n        if(k>nums.size())\\n        {\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        else\\n        {\\n            queue<int>q;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                q.push(nums[i]);\\n            }\\n        \\n                int t=k-1;\\n                while(t>0)\\n                {\\n                    \\n                    ans=max(ans,q.front());\\n                    q.pop();\\n                    t--;\\n                    \\n                }\\n               if(q.size()>1)\\n               {\\n                   q.pop();\\n                    if(ans<q.front())\\n                    {\\n                        return q.front();\\n                    }\\n               }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012104,
                "title": "c-greedy-easy-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int maximumTop(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        if(k==0)\\n            return nums[0];\\n        if(n==1) \\n        {\\n            if(k%2)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        if(k>n)\\n        {\\n            int maxele=0;\\n            for(auto num:nums)\\n                maxele=max(maxele,num);\\n            return maxele;\\n        }\\n        int ans=0;\\n        for(int i=0;i<k-1;i++)\\n            ans=max(ans,nums[i]);\\n        return max(ans,nums[k]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int maximumTop(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        if(k==0)\\n            return nums[0];\\n        if(n==1) \\n        {\\n            if(k%2)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        if(k>n)\\n        {\\n            int maxele=0;\\n            for(auto num:nums)\\n                maxele=max(maxele,num);\\n            return maxele;\\n        }\\n        int ans=0;\\n        for(int i=0;i<k-1;i++)\\n            ans=max(ans,nums[i]);\\n        return max(ans,nums[k]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011417,
                "title": "runtime-72-ms-beats-100",
                "content": "\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nvar maximumTop = function (nums, k) {\\n    if (nums.length === 1 && k == 0) return nums;\\n    if (nums.length === 1 && k % 2 !== 0) return -1;\\n    let max = Math.max(...nums.slice(0, Math.abs(k - 1)));\\n    return max > nums[k] || nums[k] === undefined ? max : nums[k];\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/d273de51-9378-40a2-a2e0-928a6653b541_1673061803.0500512.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTop = function (nums, k) {\\n    if (nums.length === 1 && k == 0) return nums;\\n    if (nums.length === 1 && k % 2 !== 0) return -1;\\n    let max = Math.max(...nums.slice(0, Math.abs(k - 1)));\\n    return max > nums[k] || nums[k] === undefined ? max : nums[k];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2638986,
                "title": "c-o-n-time-solution",
                "content": "**Note: Handling edge cases is tricky . You have to observe carefully.**\\n**C++ Code:**\\n\\n```\\n  int maximumTop(vector<int>& nums, int k) {\\n    int maxi = 0;\\n    int n = nums.size();\\n    if(k==1){\\n        if(n==1) return -1;\\n        return nums[1];\\n    }\\n    // edge case eg:- [18],k=3\\n    if(n==1 && k%2!=0) return -1;\\n        \\n    for(int i=0;i<=min(k-2,n-1);i++){\\n     maxi = max(maxi,nums[i]);   \\n    }\\n   // edge cases for example (k-1)th index element is the maximum till now \\n    if(k<n && maxi<nums[k])\\n     maxi = nums[k];\\n    return maxi;   \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int maximumTop(vector<int>& nums, int k) {\\n    int maxi = 0;\\n    int n = nums.size();\\n    if(k==1){\\n        if(n==1) return -1;\\n        return nums[1];\\n    }\\n    // edge case eg:- [18],k=3\\n    if(n==1 && k%2!=0) return -1;\\n        \\n    for(int i=0;i<=min(k-2,n-1);i++){\\n     maxi = max(maxi,nums[i]);   \\n    }\\n   // edge cases for example (k-1)th index element is the maximum till now \\n    if(k<n && maxi<nums[k])\\n     maxi = nums[k];\\n    return maxi;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2428865,
                "title": "c-easy-to-understand-short-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int i, m=-1;\\n        for(i=0; i<nums.size()-1; i++)\\n        {\\n            if(k==0)\\n                break;\\n            if(k==1)\\n            {\\n                m=max(m, nums[i+1]);\\n                break;\\n            }\\n            m = max(m, nums[i]);\\n            k--;\\n        }\\n        if(k>1 && m!=-1)\\n            m=max(m, nums[i]);\\n        else if(m==-1 && k%2==0)\\n            m = nums[0];\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int i, m=-1;\\n        for(i=0; i<nums.size()-1; i++)\\n        {\\n            if(k==0)\\n                break;\\n            if(k==1)\\n            {\\n                m=max(m, nums[i+1]);\\n                break;\\n            }\\n            m = max(m, nums[i]);\\n            k--;\\n        }\\n        if(k>1 && m!=-1)\\n            m=max(m, nums[i]);\\n        else if(m==-1 && k%2==0)\\n            m = nums[0];\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415548,
                "title": "very-easy-and-simple-java-solution-with-explanation",
                "content": "```\\n//First I checked if there is a single element in array. If that was true, in one move we will remove it, in second move we add it. So, if we have odd number of moves, we get empty array.\\n\\n//Then, we can do 2 things, either remove k-1 elements and add the maximum of them ( (K-1) + 1 moves ), or we can simply remove k elements, and element at kth index will be the top element. So, I found the maximum among all these elements.\\n\\n//But if k is more than n, we will remove all elements and add elements in remaining moves such that top element is maximum.\\n\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) \\n    {\\n        if(nums.length==1 && k%2==1) return -1;\\n        int max=0;\\n        for(int i=0;i<Math.min(k-1,nums.length);i++)\\n        {\\n            max=Math.max(max,nums[i]);\\n        }\\n        if(k<nums.length)\\n        {\\n            max=Math.max(max,nums[k]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//First I checked if there is a single element in array. If that was true, in one move we will remove it, in second move we add it. So, if we have odd number of moves, we get empty array.\\n\\n//Then, we can do 2 things, either remove k-1 elements and add the maximum of them ( (K-1) + 1 moves ), or we can simply remove k elements, and element at kth index will be the top element. So, I found the maximum among all these elements.\\n\\n//But if k is more than n, we will remove all elements and add elements in remaining moves such that top element is maximum.\\n\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) \\n    {\\n        if(nums.length==1 && k%2==1) return -1;\\n        int max=0;\\n        for(int i=0;i<Math.min(k-1,nums.length);i++)\\n        {\\n            max=Math.max(max,nums[i]);\\n        }\\n        if(k<nums.length)\\n        {\\n            max=Math.max(max,nums[k]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347020,
                "title": "c-5-lines-code-simple-code-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       if(k==0) return nums[0];\\n        if(nums.size()==1 and k%2!=0) return -1;\\n        if(k==1) return nums[1];\\n        if(k>nums.size()) return *max_element(nums.begin(),nums.end());\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       if(k==0) return nums[0];\\n        if(nums.size()==1 and k%2!=0) return -1;\\n        if(k==1) return nums[1];\\n        if(k>nums.size()) return *max_element(nums.begin(),nums.end());\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306317,
                "title": "python-one-pass-simple-solution",
                "content": "```py\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1 and k % 2 == 1:\\n            return -1\\n        res = -1\\n        for i, d in enumerate(nums):\\n            if i < k - 1 or i == k:\\n                res = max(res, d)\\n        return res\\n```\\n\\nWhen `len(nums) == 1`, we don\\'t have much flexibility, we have to keep moving the same element in and out.  This part is easy to comprehend.\\n\\nWith `k` moves, we can make any elements in `nums[:k-1]` on top.  We just move everything in `nums[:k-1]` out in `k-1` moves, then 1 more move to make the largest one in.\\nWe can also make `nums[k]` on top. We just move `nums[:k]` out in `k` moves. Then element `nums[k]` will be on top.\\nSo the answer will be `max(max(nums[:k-1]), nums[k])`.\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1 and k % 2 == 1:\\n            return -1\\n        res = -1\\n        for i, d in enumerate(nums):\\n            if i < k - 1 or i == k:\\n                res = max(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212816,
                "title": "maximize-the-topmost-element-after-k-moves-java-easy-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n=nums.length;\\n        if(n==1 && k%2!=0){\\n            return -1;\\n        }\\n        \\n        if(k==1){\\n            return nums[k];\\n        }\\n        \\n        if(k<=n){\\n           \\n            int max=nums[0];\\n            \\n            for(int i=1;i<k-1;i++){\\n               max=Math.max(max,nums[i]); \\n            }\\n            \\n            if(n>k){\\n                max=Math.max(max,nums[k]);\\n            }\\n            \\n            return max;\\n        }else{\\n            \\n            int max=nums[0];\\n            \\n            for(int i=1;i<n;i++){\\n                max=Math.max(max,nums[i]);\\n            }\\n            \\n            return max;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n=nums.length;\\n        if(n==1 && k%2!=0){\\n            return -1;\\n        }\\n        \\n        if(k==1){\\n            return nums[k];\\n        }\\n        \\n        if(k<=n){\\n           \\n            int max=nums[0];\\n            \\n            for(int i=1;i<k-1;i++){\\n               max=Math.max(max,nums[i]); \\n            }\\n            \\n            if(n>k){\\n                max=Math.max(max,nums[k]);\\n            }\\n            \\n            return max;\\n        }else{\\n            \\n            int max=nums[0];\\n            \\n            for(int i=1;i<n;i++){\\n                max=Math.max(max,nums[i]);\\n            }\\n            \\n            return max;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114804,
                "title": "javascript-solution-greedy",
                "content": "I am not sure what to call this. Like the categories suggest, therer is some greedy aspect to it, but I think its more about taking care of different edge case scenarios we can have with nums.length and k.\\n\\n```\\nvar maximumTop = function(nums, k) {\\n    const MIN = Number.MIN_SAFE_INTEGER;\\n    const n = nums.length;\\n    \\n    if (k === 0) return nums[0];\\n    if (n === 1 && k % 2 == 1) return -1; // if there is only 1 item and k is odd, then the last move always will be removing the item\\n    if (k === 1) return nums[1];\\n    if (k > n) return Math.max(...nums);\\n    \\n    let max = MIN;\\n    \\n    for (let i = 1; i <= k - 1; ++i) {\\n        const num = nums[i - 1];\\n        max = Math.max(max, num);\\n    }\\n   \\n    if (k < n) return Math.max(max, nums[k]); // If there is 1 or more item than k in the array, then the two choices we have is to remove\\n                                              // k elements which will make the nums[k] be the topmost element or removing k - 1 elements\\n                                              // and putting the largest number from there back onto the pile.\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTop = function(nums, k) {\\n    const MIN = Number.MIN_SAFE_INTEGER;\\n    const n = nums.length;\\n    \\n    if (k === 0) return nums[0];\\n    if (n === 1 && k % 2 == 1) return -1; // if there is only 1 item and k is odd, then the last move always will be removing the item\\n    if (k === 1) return nums[1];\\n    if (k > n) return Math.max(...nums);\\n    \\n    let max = MIN;\\n    \\n    for (let i = 1; i <= k - 1; ++i) {\\n        const num = nums[i - 1];\\n        max = Math.max(max, num);\\n    }\\n   \\n    if (k < n) return Math.max(max, nums[k]); // If there is 1 or more item than k in the array, then the two choices we have is to remove\\n                                              // k elements which will make the nums[k] be the topmost element or removing k - 1 elements\\n                                              // and putting the largest number from there back onto the pile.\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018841,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length==1)\\n        {\\n            if(k%2==0)\\n                return nums[0];\\n\\t\\t\\telse\\n                return -1;\\n        }\\n        if(k==1)\\n            return nums[1];\\n        int max=nums[0];\\n        for(int i=0;i<Math.min(k-1,nums.length);i++)\\n        {\\n            if(nums[i]>max)\\n                max=nums[i];\\n        }\\n        if(k<=nums.length-1&&nums[k]>max)\\n            return nums[k];\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length==1)\\n        {\\n            if(k%2==0)\\n                return nums[0];\\n\\t\\t\\telse\\n                return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1978816,
                "title": "python3-easy-solution-o-n-time-4-lines-of-code",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums)==1 and k%2==1: return -1\\n        if k>len(nums): return max(nums)\\n        if k<len(nums): return max(nums[0:max(k-1,0)]+[nums[k]])\\n        return max(nums[0:max(k-1,0)])\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums)==1 and k%2==1: return -1\\n        if k>len(nums): return max(nums)\\n        if k<len(nums): return max(nums[0:max(k-1,0)]+[nums[k]])\\n        return max(nums[0:max(k-1,0)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884614,
                "title": "c-clean-code-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        if(nums.size() == 1){\\n            \\n            if(k % 2 == 0)\\n                return nums[0];\\n            \\n            return -1;\\n        }\\n        \\n        if(k == 0){\\n            return nums[0];\\n        }\\n        \\n        if(k == 1){\\n            return nums[1]; \\n        }\\n        \\n        if(k > nums.size()){\\n            return *max_element(begin(nums), end(nums));\\n        }\\n        \\n        // now in this case we can maintain every element at top from 0 to k except element at k - 1\\n        // so we take maximum of every element till k - 1\\n        // and then we take maximum of ans with element at k\\n        //so in the end element at k - 1 is excluded\\n        \\n        int ans = *max_element(begin(nums), begin(nums) + k - 1);\\n        \\n        ans = max(ans, nums[k]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        if(nums.size() == 1){\\n            \\n            if(k % 2 == 0)\\n                return nums[0];\\n            \\n            return -1;\\n        }\\n        \\n        if(k == 0){\\n            return nums[0];\\n        }\\n        \\n        if(k == 1){\\n            return nums[1]; \\n        }\\n        \\n        if(k > nums.size()){\\n            return *max_element(begin(nums), end(nums));\\n        }\\n        \\n        // now in this case we can maintain every element at top from 0 to k except element at k - 1\\n        // so we take maximum of every element till k - 1\\n        // and then we take maximum of ans with element at k\\n        //so in the end element at k - 1 is excluded\\n        \\n        int ans = *max_element(begin(nums), begin(nums) + k - 1);\\n        \\n        ans = max(ans, nums[k]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880870,
                "title": "very-simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def maximumTop(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1 and k % 2 == 1: return -1\\n        if k ==0: return nums[0]\\n        if k== 1: return nums[1]\\n        \\n        if k > len(nums): return max(nums)\\n        if k == len(nums): return max(nums[0:len(nums)-1])\\n        # k < len(nums)\\n        a = max(nums[0:k-1])\\n        if (a > nums[k]): \\n            return a\\n        else: \\n            return nums[k]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumTop(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1 and k % 2 == 1: return -1\\n        if k ==0: return nums[0]\\n        if k== 1: return nums[1]\\n        \\n        if k > len(nums): return max(nums)\\n        if k == len(nums): return max(nums[0:len(nums)-1])\\n        # k < len(nums)\\n        a = max(nums[0:k-1])\\n        if (a > nums[k]): \\n            return a\\n        else: \\n            return nums[k]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879277,
                "title": "c-beats-92-time-easy-solution-single-loop-explained-for-understanding",
                "content": "**Intuition**:\\n1. If `nums` contains only one element, odd number of steps cannot keep pile non-empty, so return `-1`.\\n2. Otherwise, do `k-1` pops. And note the max value = `m` among those values poped.\\n3. In the last step, either push the max value `m` or pop the `top` element of the pile, so that the resulting pile has greatest at the `top`.\\n\\n**Code**: \\n\\n```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n\\tint m = -1;\\n\\n\\t// If there is only one element, odd number of steps cannot keep pile non-empty\\n\\tif(k % 2 && nums.size() == 1)\\n\\t\\treturn m;\\n\\n\\t// do a maximum of `k - 1` pops and choose max among them = `m`\\n\\tint top = 0;\\n\\twhile(k > 1 && top < nums.size())\\n\\t\\tm = max(nums[top++], m), --k;\\n\\n\\t// last step can be pop or push `m`\\n\\tif (k)\\n\\t\\tif(nums.size() - top > 1 && nums[top + 1] > m)\\n\\t\\t\\t++top; // pop, so max value is `nums[top]`\\n\\t\\telse\\n\\t\\t\\t--top; // push, implicitly, so max value is `m`\\n\\n\\t// Remaining steps, i.e. if k > 1 here are ignored as they can always be used to build the pile\\n\\t// with max element at top, regardless of whether k is even or odd. Only exception being if nums\\n\\t// contains one element which handled above.\\n\\n\\treturn max(nums[top], m);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n\\tint m = -1;\\n\\n\\t// If there is only one element, odd number of steps cannot keep pile non-empty\\n\\tif(k % 2 && nums.size() == 1)\\n\\t\\treturn m;\\n\\n\\t// do a maximum of `k - 1` pops and choose max among them = `m`\\n\\tint top = 0;\\n\\twhile(k > 1 && top < nums.size())\\n\\t\\tm = max(nums[top++], m), --k;\\n\\n\\t// last step can be pop or push `m`\\n\\tif (k)\\n\\t\\tif(nums.size() - top > 1 && nums[top + 1] > m)\\n\\t\\t\\t++top; // pop, so max value is `nums[top]`\\n\\t\\telse\\n\\t\\t\\t--top; // push, implicitly, so max value is `m`\\n\\n\\t// Remaining steps, i.e. if k > 1 here are ignored as they can always be used to build the pile\\n\\t// with max element at top, regardless of whether k is even or odd. Only exception being if nums\\n\\t// contains one element which handled above.\\n\\n\\treturn max(nums[top], m);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868695,
                "title": "golang-o-n-time-o-1-mem-detail-explanation",
                "content": "Suppose that k < n (number of ints):\\n- You are never able to touch nums[k-1]\\n- Because: \\n  - Firstly, you have to remove [0..k-2] which is `k - 1` steps.\\n  - Then you have no choice in last step: must remove nums[k - 1]\\n- In this way, you only able to touch: \\n  - nums[k] (remove first k ints: [0..k-1]) \\n  - nums[0..k-2]\\n\\nFor k == n, you are never able to touch nums[n-1], same reason as above. In this case, you only able to touch nums[0..n-2]\\n\\nFor k > n, you can touch all ints.\\n\\nLets say `i` is the index of maximum ints that you can touch.\\n\\n- if `i == 0`:\\n\\t- if k is odd, then steps: remove nums[0] -> remove nums[1] -> add nums[0] -> remove nums[0] .. -> add nums[0]\\n\\t- if k is even, then steps: remove nums[0] -> add nums[0]\\n\\t- So, no matter what, we can have `nums[i]`\\n- i > 0 now. First you remove 0..i-1 ints, which is `i` steps:\\n\\t- Remaining steps is: `remain = k - i`\\n\\t- if `remain` is odd, then steps: remove nums[i] -> add nums[i-1] -> add nums[i] -> remove nums[i] -> .. -> add nums[i]\\n\\t- `remain` is even, then steps: remove nums[i] -> add nums[i] -> .. -> add nums[i]\\n\\nSo, no matter what, we are able to get max int among all ints that we can touch.\\n\\n```go\\nfunc maximumTop(nums []int, k int) int {\\n    n := len(nums)\\n    lastBit := k & 1\\n    \\n    if n == 1 {\\n        if lastBit == 1 { // k is odd\\n            return -1\\n        }\\n        return nums[0]\\n    }\\n    \\n    max := -1\\n    if k < n {\\n        max = nums[k]\\n        k--\\n    } else if k == n {\\n        k = n - 1\\n    } else {\\n        k = n\\n    }\\n    \\n    for i := 0; i < k; i++ {\\n        if nums[i] > max {\\n            max = nums[i]\\n        }\\n    }\\n    \\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maximumTop(nums []int, k int) int {\\n    n := len(nums)\\n    lastBit := k & 1\\n    \\n    if n == 1 {\\n        if lastBit == 1 { // k is odd\\n            return -1\\n        }\\n        return nums[0]\\n    }\\n    \\n    max := -1\\n    if k < n {\\n        max = nums[k]\\n        k--\\n    } else if k == n {\\n        k = n - 1\\n    } else {\\n        k = n\\n    }\\n    \\n    for i := 0; i < k; i++ {\\n        if nums[i] > max {\\n            max = nums[i]\\n        }\\n    }\\n    \\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857172,
                "title": "c-check-3-cases",
                "content": "class Solution {\\npublic:\\n   ``` int maximumTop(vector<int>& nums, int k) {```\\n        \\n        int n = nums.size();\\n        \\n        // k is odd, cannot get a non empty pile \\n        \\n        if(n==1 and (k&1)) return -1;\\n        \\n        if(n > k){\\n            int mx=0;\\n            \\n            // answer is max(k\\'th element in pile , max(first k-1 elements))\\n            \\n            for(int i=0; i<k-1; i++) mx = max(mx, nums[i]);\\n            \\n            return max(mx, nums[k]);\\n        }\\n        else if(k > n){\\n            int mx=0;\\n            \\n            // answer is max of all pile elements\\n            \\n            for(int i=0; i<n; i++) mx = max(mx, nums[i]);\\n            \\n            return mx;\\n        }\\n        else{\\n            int mx=-1;\\n            \\n            //answer is max of first k-1 elements\\n            \\n            for(int i=0; i<k-1; i++) mx = max(mx, nums[i]);\\n            \\n            return mx;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "``` int maximumTop(vector<int>& nums, int k) {```",
                "codeTag": "Unknown"
            },
            {
                "id": 1855591,
                "title": "c-inline-explanation-easy-solution-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size(); // To store the size of the vector\\n        if(n==1){\\n            if(k%2 == 0) // If k is even , we will perform alternative add and remove operations at last we end up with the number nums[0]\\n                return nums[0];\\n            else\\n                return -1; // If k is odd , we will perform alternative add and remove operations at last we end up with empty vector so we return -1\\n        }\\n        else if(n>=k){\\n        int val = INT_MIN;\\n\\t\\t/* We are finding the maximum value of k-2 (included) elements only , \\n\\t\\t    Since our vector is zero based indexing , we will find the K th element at k-1 position , \\n\\t\\t\\tif we find maximum upto k-2 elements and compare it with Kth element which is at index k and\\n\\t\\t\\tif we found that Kth element is greater , then we will remove K-1 th element and return Kth element else  return val . K-1th element is remained same since our k operations are completed\\n\\t\\t*/\\n            for(int i = 0 ; i < k-1 ;i++){\\n                val = max(nums[i],val);\\n            }\\n            return max(val , nums[k]);\\n        }\\n\\t\\t// if k>n then we will find maximum of nums vector and return \\n        int mx = *max_element(nums.begin(),nums.end());\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size(); // To store the size of the vector\\n        if(n==1){\\n            if(k%2 == 0) // If k is even , we will perform alternative add and remove operations at last we end up with the number nums[0]\\n                return nums[0];\\n            else\\n                return -1; // If k is odd , we will perform alternative add and remove operations at last we end up with empty vector so we return -1\\n        }\\n        else if(n>=k){\\n        int val = INT_MIN;\\n\\t\\t/* We are finding the maximum value of k-2 (included) elements only , \\n\\t\\t    Since our vector is zero based indexing , we will find the K th element at k-1 position , \\n\\t\\t\\tif we find maximum upto k-2 elements and compare it with Kth element which is at index k and\\n\\t\\t\\tif we found that Kth element is greater , then we will remove K-1 th element and return Kth element else  return val . K-1th element is remained same since our k operations are completed\\n\\t\\t*/\\n            for(int i = 0 ; i < k-1 ;i++){\\n                val = max(nums[i],val);\\n            }\\n            return max(val , nums[k]);\\n        }\\n\\t\\t// if k>n then we will find maximum of nums vector and return \\n        int mx = *max_element(nums.begin(),nums.end());\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852039,
                "title": "java-super-simple-and-short-greedy-solution",
                "content": "Idea is that we can either \\n- Delete `k-1` numbers and then add the `max` to the top as the `kth` operation\\n- Delete all the `k` numbers and then `nums[k]` becomes the top\\n\\nBoth ways we make `k` operations. We greedily choose max from the above two cases.\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if (k%2 == 1 && nums.length == 1) return -1; // Array becomes empty in this case\\n        int max = 0;\\n        for (int i = 0; i < nums.length && i < k-1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        if (k < nums.length) {\\n            max = Math.max(max, nums[k]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if (k%2 == 1 && nums.length == 1) return -1; // Array becomes empty in this case\\n        int max = 0;\\n        for (int i = 0; i < nums.length && i < k-1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        if (k < nums.length) {\\n            max = Math.max(max, nums[k]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847241,
                "title": "python-o-n-simplified-array",
                "content": "key observation: *For any i ( i < k ), we can set any of [nums[0] ... nums[i]] at the top of the stack after k add/remove operations*\\n\\nGiven k operations allowed, we can have two scenarios\\n\\t\\t1. Case 1 :  Perform k remove operations -> nums[k] on top\\n\\t\\t2. Case 2 :  Perform i remove operations , (k-i) add operations -> max(nums[:k-1]) on top\\n\\t\\t\\n if k less than size of nums : return max(case1, case2)\\n if k equals size of nums : return case2 (case1 is not possible)\\n if k greater than size of nums : return case 1 (case 2 is not applicable)\\n\\n\\n```class Solution(object):\\n    def maximumTop(self, nums, k):\\n\\n        if len(nums) == 1 and k % 2 == 1 : \\n            return -1\\n        \\n        # k less than size of nums\\n        if k < len(nums):\\n            if k > 1:\\n                return max(nums[k], max(nums[:k-1]))\\n            else : \\n                return nums[k]\\n        \\n        # k equals size of nums\\n        elif k == len(nums): \\n            return max(nums[:k-1])\\n        \\n        # k greater than size of nums\\n        else : \\n            return max(nums)",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "key observation: *For any i ( i < k ), we can set any of [nums[0] ... nums[i]] at the top of the stack after k add/remove operations*\\n\\nGiven k operations allowed, we can have two scenarios\\n\\t\\t1. Case 1 :  Perform k remove operations -> nums[k] on top\\n\\t\\t2. Case 2 :  Perform i remove operations , (k-i) add operations -> max(nums[:k-1]) on top\\n\\t\\t\\n if k less than size of nums : return max(case1, case2)\\n if k equals size of nums : return case2 (case1 is not possible)\\n if k greater than size of nums : return case 1 (case 2 is not applicable)\\n\\n\\n```class Solution(object):\\n    def maximumTop(self, nums, k):\\n\\n        if len(nums) == 1 and k % 2 == 1 : \\n            return -1\\n        \\n        # k less than size of nums\\n        if k < len(nums):\\n            if k > 1:\\n                return max(nums[k], max(nums[:k-1]))\\n            else : \\n                return nums[k]\\n        \\n        # k equals size of nums\\n        elif k == len(nums): \\n            return max(nums[:k-1])\\n        \\n        # k greater than size of nums\\n        else : \\n            return max(nums)",
                "codeTag": "Java"
            },
            {
                "id": 1846786,
                "title": "python3-scan-the-array",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/66f7e5045d1b91897d8dbb425b6af153e6802c59) for solutions of weekly 284. \\n\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1 and k&1: return -1\\n        ans = 0 \\n        for i in range(min(k-1, len(nums))): ans = max(ans, nums[i])\\n        if k < len(nums): ans = max(ans, nums[k])\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1 and k&1: return -1\\n        ans = 0 \\n        for i in range(min(k-1, len(nums))): ans = max(ans, nums[i])\\n        if k < len(nums): ans = max(ans, nums[k])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846387,
                "title": "java-o-min-n-k-explained",
                "content": "```\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length <= 1 && k % 2 == 1) return -1;\\n        if(k == 1) return nums[1];//if k is 1, I can only remove the top of the pile. Hence, nums[1] is the new top.\\n        int max = nums[0];\\n\\n        for(int i = 0; i < Math.min(k-1, nums.length); i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        //i have one operation left. I can either return the max I have so far to the top of the pile.\\n        //Or i can remove the current top of the pile in case the one below it is > max.\\n        if(k < nums.length && nums[k] > max) return nums[k];\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length <= 1 && k % 2 == 1) return -1;\\n        if(k == 1) return nums[1];//if k is 1, I can only remove the top of the pile. Hence, nums[1] is the new top.\\n        int max = nums[0];\\n\\n        for(int i = 0; i < Math.min(k-1, nums.length); i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        //i have one operation left. I can either return the max I have so far to the top of the pile.\\n        //Or i can remove the current top of the pile in case the one below it is > max.\\n        if(k < nums.length && nums[k] > max) return nums[k];\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845961,
                "title": "java-max-of-first-k-1-elements-and-kth-index-element",
                "content": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int max = -1;\\n        if(nums.length == 1 && k % 2 == 1) {\\n            return -1;\\n        }\\n        if (k > nums.length) {\\n            //  simple max of the array\\n            for (int i = 0; i < nums.length; i++) {\\n                max = Math.max(max, nums[i]);\\n            }\\n            return max;\\n        }\\n        //  max of first (k-1) elements\\n        for (int i = 0; i < k - 1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        //  comparing with the kth element\\n        if (k < nums.length) {\\n            max = Math.max(max, nums[k]);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int max = -1;\\n        if(nums.length == 1 && k % 2 == 1) {\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1845737,
                "title": "python-simple-greedy-5-line-solution-o-n-tc-o-1-sc",
                "content": "```\\ndef maximumTop(self, nums, k):\\n\"\"\"\\n:type nums: List[int]\\n:type k: int\\n:rtype: int\\n\"\"\"\\n#The case is seperate if len(nums) == 1...\\n#When len(nums) == 1, then ans is nums[0] if k is even, else ans is -1 if k is odd\\n#Other than that, for any k, the MAX number that lies in the range of nums[:(k+1)] is the answer if index != k\\n#This is because the MAX answer can be restored to be the first element for any value of k\\n\\n#Time Complexity: O(N)\\n#Space Complexity: O(1)\\n\\nif len(nums) == 1: return nums[0] if not k % 2 else -1\\nnums, maxi = nums[:(k+1)], -1\\nfor i, ele in enumerate(nums):\\n\\tif (i + 1) != k: maxi = max(maxi, ele)\\nreturn maxi\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef maximumTop(self, nums, k):\\n\"\"\"\\n:type nums: List[int]\\n:type k: int\\n:rtype: int\\n\"\"\"\\n#The case is seperate if len(nums) == 1...\\n#When len(nums) == 1, then ans is nums[0] if k is even, else ans is -1 if k is odd\\n#Other than that, for any k, the MAX number that lies in the range of nums[:(k+1)] is the answer if index != k\\n#This is because the MAX answer can be restored to be the first element for any value of k\\n\\n#Time Complexity: O(N)\\n#Space Complexity: O(1)\\n\\nif len(nums) == 1: return nums[0] if not k % 2 else -1\\nnums, maxi = nums[:(k+1)], -1\\nfor i, ele in enumerate(nums):\\n\\tif (i + 1) != k: maxi = max(maxi, ele)\\nreturn maxi\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1845482,
                "title": "c-easy-greedy-solution-with-multiple-cases",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maximumTop(vector<int>& nums, int k) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tif(k==0) return nums[0];\\n\\t\\t\\tif(n==1){\\n\\t\\t\\t\\tif(k&1) return -1;\\n\\t\\t\\t\\treturn nums[0];\\n\\t\\t\\t}\\n\\t\\t\\tif(k==1) return nums[1];\\n\\t\\t\\tif(k==2) return max(nums[0],nums[k]);\\n\\t\\t\\tif(k>n) return *max_element(begin(nums),end(nums));\\n\\t\\t\\tif(k<n) return max(*max_element(begin(nums),begin(nums)+k-1),nums[k]);\\n\\t\\t\\treturn *max_element(begin(nums),begin(nums)+k-1);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maximumTop(vector<int>& nums, int k) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tif(k==0) return nums[0];\\n\\t\\t\\tif(n==1){\\n\\t\\t\\t\\tif(k&1) return -1;\\n\\t\\t\\t\\treturn nums[0];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1845275,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1 && k%2==1) return -1;\\n        if(k==0 || k==1) return nums[k];\\n        return Math.max(nums[k%n],IntStream.range(0,Math.min(k-1,n))\\n                .map(i->nums[i])\\n                .max()\\n                .getAsInt());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1 && k%2==1) return -1;\\n        if(k==0 || k==1) return nums[k];\\n        return Math.max(nums[k%n],IntStream.range(0,Math.min(k-1,n))\\n                .map(i->nums[i])\\n                .max()\\n                .getAsInt());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845260,
                "title": "c-solution-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    //memo array\\n    int t[100001];\\n    \\n\\t// this function implements the 1st move i.e pop element from the array\\n    int solve1(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        pq.push(nums[top]);\\n        return solve(nums,k-1,pq,top+1);\\n    }\\n    \\n\\t//this function implements the 2nd move i.e push any one of the popped element at the top\\n    int solve2(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        if(pq.size()!=0){\\n            nums[top-1]=pq.top();\\n            pq.pop();\\n        }\\n        else{\\n            return -1;\\n        }\\n        return solve(nums,k-1,pq,top-1);\\n    }\\n    \\n    int solve(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        //base cond\\n        if(k==0){\\n            return nums[top];\\n        }\\n         // checking the memo array for the element\\n        if(t[top]!=-1){\\n            return t[top];\\n        }\\n\\t\\t//logic\\n\\t\\t// returning the  max between the two moves\\n        return t[top] = max(solve1(nums,k,pq,top),solve2(nums,k,pq,top));\\n        \\n    }\\n    \\n    int maximumTop(vector<int>& nums, int k) {\\n\\t//This is the driver func\\n\\t//init the array t(declared globally) with -1\\n        memset(t,-1,sizeof(t));\\n\\t\\t//corner cases\\n\\t\\t//1st corner case is when k>=nums.size() and nums.size()==1 now there can be two sub cases\\n\\t\\t//1. when k is odd : if nums.size()==1 the general solution will be to pop then push then pop then push till \\n\\t\\t// you exhaust k so this means in case of k being odd you will always end up with no element in the array\\n\\t\\t//nums hence we return -1\\n        if(k>=nums.size() && nums.size()==1){\\n            if(k%2){\\n                return -1;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// 2. when k is even: when k is even you will end up with the element being inside the array nums so you\\n\\t\\t\\t//can return it as the max element\\n            else{\\n                return nums[0];\\n            }\\n        }\\n\\t\\t// 2nd corner case is when k>nums.size(): if k>nums.size() and nums.size() is also greater than 1 that means\\n\\t\\t//you will have more options to push and pop and you can access all the elements of nums hence return the\\n\\t\\t//max element\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n\\t\\t// since we need only the maximum element amoung the popped elements we use a max heap\\n        priority_queue<int> pq;\\n\\t\\t//recursive func\\n        return solve(nums,k,pq,0);\\n    }\\n};\\n```\\n\\n**NOTE:** The time to execute this code is a bit high and the memory consumed as well.\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //memo array\\n    int t[100001];\\n    \\n\\t// this function implements the 1st move i.e pop element from the array\\n    int solve1(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        pq.push(nums[top]);\\n        return solve(nums,k-1,pq,top+1);\\n    }\\n    \\n\\t//this function implements the 2nd move i.e push any one of the popped element at the top\\n    int solve2(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        if(pq.size()!=0){\\n            nums[top-1]=pq.top();\\n            pq.pop();\\n        }\\n        else{\\n            return -1;\\n        }\\n        return solve(nums,k-1,pq,top-1);\\n    }\\n    \\n    int solve(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        //base cond\\n        if(k==0){\\n            return nums[top];\\n        }\\n         // checking the memo array for the element\\n        if(t[top]!=-1){\\n            return t[top];\\n        }\\n\\t\\t//logic\\n\\t\\t// returning the  max between the two moves\\n        return t[top] = max(solve1(nums,k,pq,top),solve2(nums,k,pq,top));\\n        \\n    }\\n    \\n    int maximumTop(vector<int>& nums, int k) {\\n\\t//This is the driver func\\n\\t//init the array t(declared globally) with -1\\n        memset(t,-1,sizeof(t));\\n\\t\\t//corner cases\\n\\t\\t//1st corner case is when k>=nums.size() and nums.size()==1 now there can be two sub cases\\n\\t\\t//1. when k is odd : if nums.size()==1 the general solution will be to pop then push then pop then push till \\n\\t\\t// you exhaust k so this means in case of k being odd you will always end up with no element in the array\\n\\t\\t//nums hence we return -1\\n        if(k>=nums.size() && nums.size()==1){\\n            if(k%2){\\n                return -1;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// 2. when k is even: when k is even you will end up with the element being inside the array nums so you\\n\\t\\t\\t//can return it as the max element\\n            else{\\n                return nums[0];\\n            }\\n        }\\n\\t\\t// 2nd corner case is when k>nums.size(): if k>nums.size() and nums.size() is also greater than 1 that means\\n\\t\\t//you will have more options to push and pop and you can access all the elements of nums hence return the\\n\\t\\t//max element\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n\\t\\t// since we need only the maximum element amoung the popped elements we use a max heap\\n        priority_queue<int> pq;\\n\\t\\t//recursive func\\n        return solve(nums,k,pq,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845117,
                "title": "python-with-easy-explanation-time-o-min-nums-k-space-o-1-with-comments",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n            l = len(nums)\\n\\n            if k&1 and l == 1:return -1  #if k is odd and l == 1,after k steps nums will be empty\\n            elif k == 0 or l == 1:return nums[0]  #if k == 0 or (else part of above case) nums[0] is top element\\n            elif k == 1:return nums[1]  #if k == 1,nums[:k-1] will be empty list thus max(nums[:k-1]) will throw error\\n            elif k>l: return max(nums)  #if k>l any element we want can be at top\\n            else: \\n                x = nums[k] if k<l else 0  #if k == l  nums[k] will be out of range\\n                return max(max(nums[:k-1]),x)  \\n\\t\\t\\t\\t#With any permutaion of steps, all elements till k can be at top except (k-1)th element and because of these reason we cannot take k>=l in above condition else (k-1)th element will also get included\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n            l = len(nums)\\n\\n            if k&1 and l == 1:return -1  #if k is odd and l == 1,after k steps nums will be empty\\n            elif k == 0 or l == 1:return nums[0]  #if k == 0 or (else part of above case) nums[0] is top element\\n            elif k == 1:return nums[1]  #if k == 1,nums[:k-1] will be empty list thus max(nums[:k-1]) will throw error\\n            elif k>l: return max(nums)  #if k>l any element we want can be at top\\n            else: \\n                x = nums[k] if k<l else 0  #if k == l  nums[k] will be out of range\\n                return max(max(nums[:k-1]),x)  \\n\\t\\t\\t\\t#With any permutaion of steps, all elements till k can be at top except (k-1)th element and because of these reason we cannot take k>=l in above condition else (k-1)th element will also get included\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844990,
                "title": "simple-solution-in-java-100-faster-with-drawing-to-understand-the-edge-cases",
                "content": "![image](https://assets.leetcode.com/users/images/d2532458-76c6-4c00-a1c0-033654f7dcfd_1647154092.0153883.png)\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length == 1 && k%2 == 1) return -1;\\n        \\n        int max = k < nums.length ? nums[k] : -1;\\n        boolean isOdd = false;\\n        if(k%2 == 1){\\n            isOdd = true;\\n            k -= 1;\\n        }\\n        \\n        for(int i=0; i<Math.min(k - 1, nums.length); i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        if(isOdd == true){\\n            max = Math.max(max, k-1 >= 0 ? nums[Math.min(k-1, nums.length-1)] :  -1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length == 1 && k%2 == 1) return -1;\\n        \\n        int max = k < nums.length ? nums[k] : -1;\\n        boolean isOdd = false;\\n        if(k%2 == 1){\\n            isOdd = true;\\n            k -= 1;\\n        }\\n        \\n        for(int i=0; i<Math.min(k - 1, nums.length); i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        if(isOdd == true){\\n            max = Math.max(max, k-1 >= 0 ? nums[Math.min(k-1, nums.length-1)] :  -1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844970,
                "title": "java-o-n-greedy-the-shortest-code-with-proof",
                "content": "We can only take one number or put it back to the array every operation at most k times.\\nSo the **maximun** must be in the range of [0, k]\\nThere are only 3 cases:\\n**case1**: When n == 1 and k is odd, we always get an empty array.\\n**proof:**\\nif k == 1, we take this number out, then get an empty array\\nif k == 3, we can only take this number out 3 times, it also get an empty array\\nand so on...\\n\\n**case2**: We use k times operation to take k numbers out, then the answer must be nums[k]\\nthat is if-statement k == i\\n\\n**case3**: The remainder of situation is that we used totally k-2 times operation to take some numbers out, and the rest of 2 times operation to take and push back the last number nums[k-2]. In this case, we can go to the index k-2 at mostright. **(the numbers of in range [0,k-3] will be take out once, and nums[k-2] is going to be taken and push back separately once)**, so we can use nums[k-2] update our **max**\\n**proof:**\\n**similarly**, if we used totally k-3 times operation to take numbers out, meantime using 2 times operation to take and push back the last number nums[k-3], we can go to the index k-3 at mostright. the maximum will be nums[k-3].\\nand so on...\\nthat is if-statement i <= k-2, it means that any numbers in range [0,k-2] will be considered as the final answer, but for sure, we just need the maximum in range [0,k-2]\\n\\n\\n\\n```java\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n == 1) return k%2 == 1 ? -1 : nums[0];\\n        int max = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(k == i || i <= k-2) max = Math.max(max, nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n == 1) return k%2 == 1 ? -1 : nums[0];\\n        int max = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(k == i || i <= k-2) max = Math.max(max, nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844842,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(k%2 == 1 && nums.size() == 1)\\n        {\\n            return -1;\\n        }\\n        \\n        if(k > nums.size())\\n        {\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        else if(k == nums.size())\\n        {\\n            int maxi=INT_MIN;\\n            \\n            for(int i=0; i<k-1; i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n            \\n            return maxi;\\n        }\\n        else\\n        {\\n            int maxi=INT_MIN;\\n            \\n            for(int i=0; i<k-1; i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n            \\n            maxi=max(maxi,nums[k]);\\n            \\n            return maxi;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(k%2 == 1 && nums.size() == 1)\\n        {\\n            return -1;\\n        }\\n        \\n        if(k > nums.size())\\n        {\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        else if(k == nums.size())\\n        {\\n            int maxi=INT_MIN;\\n            \\n            for(int i=0; i<k-1; i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n            \\n            return maxi;\\n        }\\n        else\\n        {\\n            int maxi=INT_MIN;\\n            \\n            for(int i=0; i<k-1; i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n            \\n            maxi=max(maxi,nums[k]);\\n            \\n            return maxi;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844796,
                "title": "simple-implementation-using-a-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 and k>=1 and k%2==0) return nums[0];\\n        if(nums.size()==1 and k>=1 and k%2!=0) return -1;\\n        if(k==0) return nums[0];\\n        if(k==1) return nums[1];\\n        // when the k>nums.size()\\n        if(k>nums.size()) return *max_element(nums.begin(),nums.end());\\n        priority_queue<int>pq;\\n        for(int i=0;i<=k-2;i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n\\t\\t// when k==nums.size()\\n        if(k==nums.size()) return pq.top();\\n     // when k<nums.size()\\n\\t if(k<nums.size())\\n        {\\n            return max(pq.top(),nums[k]);\\n        }\\n        return -1;  // unexceutable statement\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 and k>=1 and k%2==0) return nums[0];\\n        if(nums.size()==1 and k>=1 and k%2!=0) return -1;\\n        if(k==0) return nums[0];\\n        if(k==1) return nums[1];\\n        // when the k>nums.size()\\n        if(k>nums.size()) return *max_element(nums.begin(),nums.end());\\n        priority_queue<int>pq;\\n        for(int i=0;i<=k-2;i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n\\t\\t// when k==nums.size()\\n        if(k==nums.size()) return pq.top();\\n     // when k<nums.size()\\n\\t if(k<nums.size())\\n        {\\n            return max(pq.top(),nums[k]);\\n        }\\n        return -1;  // unexceutable statement\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844726,
                "title": "cpp-easy-soln-tc-o-n-sc-o-n-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        queue<int>q;\\n        int i=0;\\n        for(auto &a:nums){\\n            q.push(a);\\n        }\\n        \\n        i=1;\\n        int mx=0;\\n        int x= q.size();\\n        if(k==0)return q.front();\\n        if(x==1){\\n            if(k%2==0){\\n                return q.front();\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        while(!q.empty()){\\n            int p=q.front();\\n            q.pop();\\n             mx=max(mx,p);\\n            \\n            if(k==1){\\n                if(!q.empty()){\\n                return q.front();\\n                }\\n                else{\\n                    return -1;\\n                }\\n            }\\n            if(i==k-1){\\n                    if(!q.empty()){\\n                        q.pop();\\n                    }\\n                    if(!q.empty()){\\n                        if(q.front()>mx){\\n                            return q.front();\\n                        }\\n                        else{\\n                            return mx;\\n                        }\\n                    }\\n                else{\\n                    return mx;\\n                }\\n                }\\n            else if(i<k-1){\\n                i++;\\n            }\\n        }\\n        if(x<k){\\n            return mx;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        queue<int>q;\\n        int i=0;\\n        for(auto &a:nums){\\n            q.push(a);\\n        }\\n        \\n        i=1;\\n        int mx=0;\\n        int x= q.size();\\n        if(k==0)return q.front();\\n        if(x==1){\\n            if(k%2==0){\\n                return q.front();\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        while(!q.empty()){\\n            int p=q.front();\\n            q.pop();\\n             mx=max(mx,p);\\n            \\n            if(k==1){\\n                if(!q.empty()){\\n                return q.front();\\n                }\\n                else{\\n                    return -1;\\n                }\\n            }\\n            if(i==k-1){\\n                    if(!q.empty()){\\n                        q.pop();\\n                    }\\n                    if(!q.empty()){\\n                        if(q.front()>mx){\\n                            return q.front();\\n                        }\\n                        else{\\n                            return mx;\\n                        }\\n                    }\\n                else{\\n                    return mx;\\n                }\\n                }\\n            else if(i<k-1){\\n                i++;\\n            }\\n        }\\n        if(x<k){\\n            return mx;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844637,
                "title": "simulating-all-cases",
                "content": "Basically, it can be solved by considering lots of edge cases.\\n\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        #edge cases\\n        if N == 1 and k % 2 == 1:\\n            return -1\\n        if k == 0:\\n            return nums[0]\\n        if k > N:\\n            return max(nums)\\n        if k == N:\\n            return max(nums[:N - 1])\\n        \\n        #non-edge cases\\n        return max(nums[:k - 1] + [nums[k]])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        #edge cases\\n        if N == 1 and k % 2 == 1:\\n            return -1\\n        if k == 0:\\n            return nums[0]\\n        if k > N:\\n            return max(nums)\\n        if k == N:\\n            return max(nums[:N - 1])\\n        \\n        #non-edge cases\\n        return max(nums[:k - 1] + [nums[k]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844571,
                "title": "java-simple-solution-3ms",
                "content": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(k == 0)\\n            return nums[0];\\n        \\n        if(nums.length == 1 && k%2 != 0)\\n            return -1;\\n        \\n        if(k == 1)\\n            return (nums.length<=1) ? -1 : nums[1];\\n        \\n        int max = 0;\\n        \\n        int index = 0;\\n        \\n        while(k-- != 1 && index < nums.length)\\n            max = Math.max(max, nums[index++]);\\n        \\n        if(index >= nums.length-1)\\n            return max;\\n        \\n        return Math.max(max, nums[index+1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(k == 0)\\n            return nums[0];\\n        \\n        if(nums.length == 1 && k%2 != 0)\\n            return -1;\\n        \\n        if(k == 1)\\n            return (nums.length<=1) ? -1 : nums[1];\\n        \\n        int max = 0;\\n        \\n        int index = 0;\\n        \\n        while(k-- != 1 && index < nums.length)\\n            max = Math.max(max, nums[index++]);\\n        \\n        if(index >= nums.length-1)\\n            return max;\\n        \\n        return Math.max(max, nums[index+1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844545,
                "title": "easy-to-understand-solution-with-comments",
                "content": "\\n\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n    # made 0 moves so return top most element\\n\\tif k == 0:\\n\\t\\treturn nums[0]\\n\\n\\tn = len(nums)\\n\\t# odd k won\\'t work with len = 1 because we will end up empty array state\\n\\tif n == 1:\\n\\t\\treturn -1 if k % 2 != 0 else nums[0]\\n\\t\\n    # we have a lot of moves so we can do anything to make sure the first element is always the max\\n\\tif k > n:\\n\\t\\treturn max(nums)\\n\\telse: # k<=n scenario\\n\\t\\t# make sure you don\\'t exceed the array size\\n\\t\\tupper_bound = min(n, k - 1)\\n\\t\\t\\n\\t\\t# consider first k - 1 elements (aka upper bound)\\n\\t\\t# for kth index, we have the option to use the kth element if it\\'s available (k < len(nums))\\n        # or replace it with the previous seen max in which case we don\\'t consider it\\n\\t\\treturn max(nums[:upper_bound] + [nums[k] if k < n else float(\\'-inf\\')])\\n  ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n    # made 0 moves so return top most element\\n\\tif k == 0:\\n\\t\\treturn nums[0]\\n\\n\\tn = len(nums)\\n\\t# odd k won\\'t work with len = 1 because we will end up empty array state\\n\\tif n == 1:\\n\\t\\treturn -1 if k % 2 != 0 else nums[0]\\n\\t\\n    # we have a lot of moves so we can do anything to make sure the first element is always the max\\n\\tif k > n:\\n\\t\\treturn max(nums)\\n\\telse: # k<=n scenario\\n\\t\\t# make sure you don\\'t exceed the array size\\n\\t\\tupper_bound = min(n, k - 1)\\n\\t\\t\\n\\t\\t# consider first k - 1 elements (aka upper bound)\\n\\t\\t# for kth index, we have the option to use the kth element if it\\'s available (k < len(nums))\\n        # or replace it with the previous seen max in which case we don\\'t consider it\\n\\t\\treturn max(nums[:upper_bound] + [nums[k] if k < n else float(\\'-inf\\')])\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1844543,
                "title": "c-greedy-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        \\n        int sz=nums.size();\\n\\t\\tif(k==0)\\n            return nums[0];\\n        if(sz==1)\\n        {\\n            if(k&1)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        if(k>sz)\\n            return *max_element(nums.begin(),nums.end());\\n        \\n        int maxi=0;\\n        int i;\\n        for( i=1;i<=k-1;i++)\\n            maxi=max(maxi,nums[i-1]);\\n        \\n        //cout<<i<<endl;\\n        return max(maxi,nums[i]);\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        \\n        int sz=nums.size();\\n\\t\\tif(k==0)\\n            return nums[0];\\n        if(sz==1)\\n        {\\n            if(k&1)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        if(k>sz)\\n            return *max_element(nums.begin(),nums.end());\\n        \\n        int maxi=0;\\n        int i;\\n        for( i=1;i<=k-1;i++)\\n            maxi=max(maxi,nums[i-1]);\\n        \\n        //cout<<i<<endl;\\n        return max(maxi,nums[i]);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1844537,
                "title": "javascript-solution",
                "content": "```\\nvar maximumTop = function(nums, k) {\\n    const n  = nums.length;\\n\\n    if(k === 0) return nums[0];\\n\\n    if(n >= k ){\\n       if(k === 1) return n - k === 0 ? -1 : nums[1];\\n       const mostArr = nums.slice(0, k-1);\\n       const max = Math.max(...mostArr);\\n       return k === n || max > nums[k] ? max : nums[k];   \\n    }else{\\n       if(n == 1 && k % 2 == 1) return -1;\\n       const max = Math.max(...nums);\\n       return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maximumTop = function(nums, k) {\\n    const n  = nums.length;\\n\\n    if(k === 0) return nums[0];\\n\\n    if(n >= k ){\\n       if(k === 1) return n - k === 0 ? -1 : nums[1];\\n       const mostArr = nums.slice(0, k-1);\\n       const max = Math.max(...mostArr);\\n       return k === n || max > nums[k] ? max : nums[k];   \\n    }else{\\n       if(n == 1 && k % 2 == 1) return -1;\\n       const max = Math.max(...nums);\\n       return max;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844520,
                "title": "c-solution-with-each-case-explaination",
                "content": "Case 1- when n==1 , As there is only one element, at every odd step we pop out the element and at every even step we push back the element.\\nCase 2- when k==0, when k==0, we cannot perform any operation so the top-most element will be the answer.\\nCase 3- when n>1 , k>0 and k<=n, we pop k-1 elements and keep track of max element. Now k=1 is left, so 2 cases are possible\\n\\ti)- Push the maximum element among the all popped elements.\\n\\tii)- Pop the element from the stack if it doesn\\'t make it empty. (As here we can make the stack non-empty, we cannot return -1.\\n\\tCheck these 2 conditions and find the max answer.\\n\\t\\nCase 4- when n>1 and k>n, Since k>n, we can pop out every element while keeping track of max element and decrease k by n. \\nWhile k>2, we push any element and pop it back, decreasing k by 2 every time.\\nAt the end, if k is 1 we can push the max element and if the k is 2, we can randomly push any other element first (not  max element) and then push the max element. So, the answer will always be max element of the array.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\t\\t//case 1\\n        if(k%2==1 && n==1)\\n            return -1;\\n\\t\\t// case 1 and case 2\\n        else if((k%2==0 && n==1) || k==0)\\n        {\\n            return nums[0];\\n        }\\n        int mx=INT_MIN,i=0,x=k;\\n        for(i=0;k>1 && i<n;i++,k--)\\n        {\\n                mx=max(nums[i],mx);\\n        }\\n        int ans;\\n\\t\\t//case 3\\n        if(k==1)\\n        {\\n            ans=mx;\\n            if(i+1<n)\\n            {\\n                ans=max(nums[i+1],ans);\\n            }\\n        }\\n        else \\n        {\\n\\t\\t//case 4\\n            ans=mx;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\t\\t//case 1\\n        if(k%2==1 && n==1)\\n            return -1;\\n\\t\\t// case 1 and case 2\\n        else if((k%2==0 && n==1) || k==0)\\n        {\\n            return nums[0];\\n        }\\n        int mx=INT_MIN,i=0,x=k;\\n        for(i=0;k>1 && i<n;i++,k--)\\n        {\\n                mx=max(nums[i],mx);\\n        }\\n        int ans;\\n\\t\\t//case 3\\n        if(k==1)\\n        {\\n            ans=mx;\\n            if(i+1<n)\\n            {\\n                ans=max(nums[i+1],ans);\\n            }\\n        }\\n        else \\n        {\\n\\t\\t//case 4\\n            ans=mx;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844519,
                "title": "c-using-stack-and-handling-all-cases-easy-explanation-by-engineer",
                "content": "``` \\n  int n = nums.size(); // size of array\\n        \\n        if(k==0){\\n            return nums[0]; // num of moves is 0 then top elem is the max we can obtain\\n        }\\n        \\n        \\n       if(n==1){\\n           return k%2==0? nums[0]: -1; // if we have only one elem in array then we can get it on top when we have even moves \\n       }\\n        \\n        stack<int> st; // stack to store elem\\n        \\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);  // push all elem in the stack from end \\n        }\\n        \\n        int step = k-1;\\n        int e = -999; // min value\\n        while(step-- && !st.empty()){\\n            int temp = st.top();\\n            st.pop();    //pop k-1 times   and store the max of popped value\\n            e = max(temp,e);\\n        }\\n        \\n        if(!st.empty()){\\n             st.pop();  // checking for the k+1 th case\\n        }\\n       \\n        \\n        if(!st.empty() && st.top()>e){\\n            return st.top();   // checking k+1 value\\n        }\\n        \\n        if(k==1){\\n            return -1;   // edge case\\n        }\\n        \\n        st.push(e);  // can be ignored\\n       \\n        return e;\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "``` \\n  int n = nums.size(); // size of array\\n        \\n        if(k==0){\\n            return nums[0]; // num of moves is 0 then top elem is the max we can obtain\\n        }\\n        \\n        \\n       if(n==1){\\n           return k%2==0? nums[0]: -1; // if we have only one elem in array then we can get it on top when we have even moves \\n       }\\n        \\n        stack<int> st; // stack to store elem\\n        \\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);  // push all elem in the stack from end \\n        }\\n        \\n        int step = k-1;\\n        int e = -999; // min value\\n        while(step-- && !st.empty()){\\n            int temp = st.top();\\n            st.pop();    //pop k-1 times   and store the max of popped value\\n            e = max(temp,e);\\n        }\\n        \\n        if(!st.empty()){\\n             st.pop();  // checking for the k+1 th case\\n        }\\n       \\n        \\n        if(!st.empty() && st.top()>e){\\n            return st.top();   // checking k+1 value\\n        }\\n        \\n        if(k==1){\\n            return -1;   // edge case\\n        }\\n        \\n        st.push(e);  // can be ignored\\n       \\n        return e;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844515,
                "title": "c-2202-maximize-the-topmost-element-after-k-moves",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if (nums.size() == 1) return k & 1 ? -1 : nums[0]; \\n        int ans = 0; \\n        for (int i = 0; i < k-1 && i < nums.size(); ++i) ans = max(ans, nums[i]); \\n        if (k < nums.size()) ans = max(ans, nums[k]); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if (nums.size() == 1) return k & 1 ? -1 : nums[0]; \\n        int ans = 0; \\n        for (int i = 0; i < k-1 && i < nums.size(); ++i) ans = max(ans, nums[i]); \\n        if (k < nums.size()) ans = max(ans, nums[k]); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844502,
                "title": "c-simple-best-solution-ever-dattebayo-solution-100-beats-all-runtime",
                "content": "even though i have used priority queue here it is just for the sake of maximum element u can also do it with some variables\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k==0)return nums[0];\\n        if((k&1)&&n==1)return -1;\\n        if((k%2==0)&&n==1)return nums[0];\\n        \\n        priority_queue<pair<int,int>>pq;//nums,i;\\n        int maxi = 0;\\n        int j = k;\\n        for(int i = 0 ;i<=min(n-1,k);++i){\\n            maxi = max(maxi,nums[i]);\\n            pq.push({nums[i],j});j--;\\n        }\\n      \\n        int ans = 0;\\n       if(pq.top().second==1){\\n           pq.pop();\\n       return pq.top().first;\\n       }\\n        return pq.top().first;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k==0)return nums[0];\\n        if((k&1)&&n==1)return -1;\\n        if((k%2==0)&&n==1)return nums[0];\\n        \\n        priority_queue<pair<int,int>>pq;//nums,i;\\n        int maxi = 0;\\n        int j = k;\\n        for(int i = 0 ;i<=min(n-1,k);++i){\\n            maxi = max(maxi,nums[i]);\\n            pq.push({nums[i],j});j--;\\n        }\\n      \\n        int ans = 0;\\n       if(pq.top().second==1){\\n           pq.pop();\\n       return pq.top().first;\\n       }\\n        return pq.top().first;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844446,
                "title": "java-100-faster-solution",
                "content": "```\\n\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(k==0){\\n            return nums[0];\\n        }\\n        if(k%2==1 && n==1){\\n            return -1;\\n        }else if(k==1){\\n            return nums[1];\\n        }\\n        if(k>n){\\n            int max = nums[0];\\n            for(int i=0;i<n;i++){\\n                if(nums[i]>max){\\n                    max =nums[i];\\n                }\\n            }\\n            return max;\\n        }\\n        int max = nums[0];\\n        for(int i=0;i<k-1;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n        }\\n        if(k==n){\\n            return max;\\n        }else{\\n            if(nums[k]>max){\\n                return nums[k];\\n            }else{\\n                return max;\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(k==0){\\n            return nums[0];\\n        }\\n        if(k%2==1 && n==1){\\n            return -1;\\n        }else if(k==1){\\n            return nums[1];\\n        }\\n        if(k>n){\\n            int max = nums[0];\\n            for(int i=0;i<n;i++){\\n                if(nums[i]>max){\\n                    max =nums[i];\\n                }\\n            }\\n            return max;\\n        }\\n        int max = nums[0];\\n        for(int i=0;i<k-1;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n        }\\n        if(k==n){\\n            return max;\\n        }else{\\n            if(nums[k]>max){\\n                return nums[k];\\n            }else{\\n                return max;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844414,
                "title": "java-clean-code-with-explanation-tc-k-sc-o-1",
                "content": "At any point, we can do this two operation\\n1. add any of elements that we have removed so far\\n\\t-\\tIf we want to add, we add maximum of elements that we have removed\\n2. remove top element\\n\\t-\\tIf we want to remove, we can remove only top element.\\n\\t\\n\\t\\nUse above to decide what will be result after k operations,\\n\\tat any point we should have maximum number of previous elements - say max,\\n\\twe can check if \\n\\t\\t1. we should add max or,\\n\\t\\t2. remove current, which will result to maximize top of array - means next top will be next element in array\\n\\t\\tdecide by max(max, nums[i + 1])\\n\\t\\t\\nOf course we have to manage corner cases which you will understand as you see the code.\\n\\t\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        //if there is only oe element\\n        if (nums.length == 1) {\\n            return k % 2 == 1 ? -1 : nums[0]; // if odd(k) - we can add in last operation, else we will end up removing all elements at last\\n        }\\n        \\n        //first operation can be removing element only\\n        if (k == 1) {\\n            return nums[1];\\n        }\\n        \\n        //find max of first k - 1 elements  - O(k)\\n        int max = nums[0];\\n        for (int i = 1; i < (k - 1) && i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n\\t\\t//O(1)\\n        //decide for kth operation and findout result\\n        if (k < nums.length) {\\n            return Math.max(nums[k], max);\\n        } else {\\n            return max;\\n        }\\n    }\\n}\\n```\\n\\nTC - O(K)\\nSC - O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        //if there is only oe element\\n        if (nums.length == 1) {\\n            return k % 2 == 1 ? -1 : nums[0]; // if odd(k) - we can add in last operation, else we will end up removing all elements at last\\n        }\\n        \\n        //first operation can be removing element only\\n        if (k == 1) {\\n            return nums[1];\\n        }\\n        \\n        //find max of first k - 1 elements  - O(k)\\n        int max = nums[0];\\n        for (int i = 1; i < (k - 1) && i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n\\t\\t//O(1)\\n        //decide for kth operation and findout result\\n        if (k < nums.length) {\\n            return Math.max(nums[k], max);\\n        } else {\\n            return max;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844404,
                "title": "very-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if (k%2 == 1 && nums.size() == 1)\\n            return -1;\\n        if(k == 0)return nums[0];\\n        int n = nums.size();\\n        int maxu = -1;\\n        int i = 0;\\n        int u = 0;\\n        if(k > n){\\n            u = n;\\n        }else{\\n            u = k-1;\\n        }\\n        for (; i < u; i++)\\n        {\\n            maxu = max(maxu, nums[i]);\\n        }\\n        if(i + 1 <n){\\n            maxu = max(maxu, nums[i+1]);\\n        }\\n        return maxu;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if (k%2 == 1 && nums.size() == 1)\\n            return -1;\\n        if(k == 0)return nums[0];\\n        int n = nums.size();\\n        int maxu = -1;\\n        int i = 0;\\n        int u = 0;\\n        if(k > n){\\n            u = n;\\n        }else{\\n            u = k-1;\\n        }\\n        for (; i < u; i++)\\n        {\\n            maxu = max(maxu, nums[i]);\\n        }\\n        if(i + 1 <n){\\n            maxu = max(maxu, nums[i+1]);\\n        }\\n        return maxu;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844397,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        length = len(nums)\\n        if length == 0 or (k%2==1 and length == 1):\\n            return -1\\n        if k==0 or k==1: \\n            return nums[k]\\n        if k>=length:\\n            return max(nums[:k-1])\\n        return max(max(nums[:k-1]), nums[k])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        length = len(nums)\\n        if length == 0 or (k%2==1 and length == 1):\\n            return -1\\n        if k==0 or k==1: \\n            return nums[k]\\n        if k>=length:\\n            return max(nums[:k-1])\\n        return max(max(nums[:k-1]), nums[k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844343,
                "title": "read-question-carefully-beginners-level-easy-greedy-solution-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            return (k%2==0 ? nums[0] : -1);\\n        }\\n        if(k==1) return nums[1];\\n        if(k>n) return *max_element(nums.begin(),nums.end());\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            return (k%2==0 ? nums[0] : -1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844314,
                "title": "very-easy-c-o-n",
                "content": "\\t\\tint x=k;\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        bool temp=true;\\n        if(k>n){\\n            x=n+1;\\n            temp=false;\\n        }\\n       stack<int>st;\\n        for(int i=0;i<x-1;i++){\\n            maxi=max(maxi,nums[i]);\\n            st.push(nums[i]);\\n        }\\n        if(n==1 and k%2==1){\\n            maxi=-1;\\n        }\\n        else if(x<n){\\n            maxi=max(nums[x],maxi);\\n        }\\n        return maxi;",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\t\\tint x=k;\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        bool temp=true;\\n        if(k>n){\\n            x=n+1;\\n            temp=false;\\n        }\\n       stack<int>st;\\n        for(int i=0;i<x-1;i++){\\n            maxi=max(maxi,nums[i]);\\n            st.push(nums[i]);\\n        }\\n        if(n==1 and k%2==1){\\n            maxi=-1;\\n        }\\n        else if(x<n){\\n            maxi=max(nums[x],maxi);\\n        }\\n        return maxi;",
                "codeTag": "Unknown"
            },
            {
                "id": 1844260,
                "title": "simple-o-n-solution-easy-to-understand",
                "content": "class Solution {![image](https://assets.leetcode.com/users/images/5651f006-a49f-4289-92af-d5c71ddd90c5_1647144516.483719.png)\\n\\npublic:\\n    int maximumTop(vector<int>& a, int k) {\\n        int ans=-1,n=a.size();\\n        if(n==1)     // handling one element case\\n        {\\n            if(k%2)\\n                return -1;\\n            else\\n                return a[0];\\n        }\\n        if(k<=n)    // We can get max upto k+1 except kth element\\n        { \\n            if(k>1)             // We never get kth element as our answer.\\n            ans=*(max_element(a.begin(),a.begin()+k-1)); // finding max till k-1\\n            ans=max(ans,a[k]);    // if we remove all k,then k+1 that is kth element of 0 indexing can be our answer.\\n        }\\n         else                    // IF K is greater than length of array then we remove all the elements and put the maximum at top greedly\\n            ans=*(max_element(a.begin(),a.end()));\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {![image](https://assets.leetcode.com/users/images/5651f006-a49f-4289-92af-d5c71ddd90c5_1647144516.483719.png)\\n\\npublic:\\n    int maximumTop(vector<int>& a, int k) {\\n        int ans=-1,n=a.size();\\n        if(n==1)     // handling one element case\\n        {\\n            if(k%2)\\n                return -1;\\n            else\\n                return a[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844259,
                "title": "c-maximize-the-topmost-element-after-k-moves",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maximumTop(vector<int> &nums, int k)\\n    {\\n        if (k == 0)\\n            return nums[0];\\n        if (nums.size() == 1 && k % 2 == 0)\\n            return nums[0];\\n        if (nums.size() == 1 && k % 2 == 1)\\n            return -1;\\n        int n = nums.size();\\n        int maxi = -1;\\n        if (k > nums.size())\\n            return *max_element(nums.begin(), nums.end());\\n        int i = 0;\\n        while (i < k - 1)\\n        {\\n            if (nums[i] > maxi)\\n            {\\n                maxi = nums[i];\\n            }\\n            i++;\\n        }\\n        if (i + 1 < n && nums[i + 1] > maxi)\\n            return nums[i + 1];\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maximumTop(vector<int> &nums, int k)\\n    {\\n        if (k == 0)\\n            return nums[0];\\n        if (nums.size() == 1 && k % 2 == 0)\\n            return nums[0];\\n        if (nums.size() == 1 && k % 2 == 1)\\n            return -1;\\n        int n = nums.size();\\n        int maxi = -1;\\n        if (k > nums.size())\\n            return *max_element(nums.begin(), nums.end());\\n        int i = 0;\\n        while (i < k - 1)\\n        {\\n            if (nums[i] > maxi)\\n            {\\n                maxi = nums[i];\\n            }\\n            i++;\\n        }\\n        if (i + 1 < n && nums[i + 1] > maxi)\\n            return nums[i + 1];\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844240,
                "title": "python3-short-greedy-solution-using-heap",
                "content": "We want to return the max value so we can start with the largest value.\\nTo find the largest value and its index, we can push all the elements into a heap.\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if not nums:\\n            return -1\\n        if len(nums) == 1 and k % 2 == 1:\\n            return -1\\n        heap = []\\n        for i, num in enumerate(nums):\\n            heappush(heap, (-num, i))\\n        \\n        while heap:\\n            largest, idx = heappop(heap)\\n            if idx > k: # that element is too far away from index 0\\n                continue\\n            if idx == k: # pop out all the elements in front of it and we run out of k\\n                return -largest\\n            # idx < k\\n            remaining = k - idx # pop all the elements in front of it and we have remaining moves \\n            if remaining >= 2: # if the # of remaining moves >= 2, we can remove it and subsequent elements and and add it back back and forth\\n                return -largest\\n        return -1\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if not nums:\\n            return -1\\n        if len(nums) == 1 and k % 2 == 1:\\n            return -1\\n        heap = []\\n        for i, num in enumerate(nums):\\n            heappush(heap, (-num, i))\\n        \\n        while heap:\\n            largest, idx = heappop(heap)\\n            if idx > k: # that element is too far away from index 0\\n                continue\\n            if idx == k: # pop out all the elements in front of it and we run out of k\\n                return -largest\\n            # idx < k\\n            remaining = k - idx # pop all the elements in front of it and we have remaining moves \\n            if remaining >= 2: # if the # of remaining moves >= 2, we can remove it and subsequent elements and and add it back back and forth\\n                return -largest\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844235,
                "title": "simple-explanation-case-by-case",
                "content": "Two cases need to compare\\n1. remove all the k elements\\n2. remove k-1 elements and put largest back\\n\\nEdge cases\\n1. when k == len(nums), only consider k-1 largest\\n2. when k > len(nums), get largest\\n3. when len(nums) == 1, odd number of k always -1\\n```\\npublic class Solution {\\n        \\n    public int MaximumTop(int[] nums, int k) {\\n        if (nums.Length == 1)\\n        {\\n            if (k % 2 == 1)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        \\n        if (k == 0)\\n            return nums[0];\\n                \\n        if (k > nums.Length)\\n            return nums.Max();\\n    \\n        \\n        int max = k == 1? -1: nums[0];\\n        for (int i = 1; i < k-1; i++){\\n            max = Math.Max(max, nums[i]);\\n        }\\n        int val = k == nums.Length? -1: nums[k];\\n        return Math.Max(val,max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n        \\n    public int MaximumTop(int[] nums, int k) {\\n        if (nums.Length == 1)\\n        {\\n            if (k % 2 == 1)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        \\n        if (k == 0)\\n            return nums[0];\\n                \\n        if (k > nums.Length)\\n            return nums.Max();\\n    \\n        \\n        int max = k == 1? -1: nums[0];\\n        for (int i = 1; i < k-1; i++){\\n            max = Math.Max(max, nums[i]);\\n        }\\n        int val = k == nums.Length? -1: nums[k];\\n        return Math.Max(val,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844217,
                "title": "java-short",
                "content": "```\\npublic int maximumTop(int[] nums, int k) {\\n        int len = nums.length;\\n        if(k==0) return nums[0];\\n        if(len == 1 && k%2==1) return -1;\\n        if(k==1) return nums[1];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b-a);\\n        for(int i=0; i<k-1; i++){\\n            if(i>=len) break;\\n            pq.add(nums[i]);  \\n        }\\n        if(pq.isEmpty()) return -1;\\n        return Math.max(pq.peek(), nums[(k%len+1)-1]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maximumTop(int[] nums, int k) {\\n        int len = nums.length;\\n        if(k==0) return nums[0];\\n        if(len == 1 && k%2==1) return -1;\\n        if(k==1) return nums[1];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b-a);\\n        for(int i=0; i<k-1; i++){\\n            if(i>=len) break;\\n            pq.add(nums[i]);  \\n        }\\n        if(pq.isEmpty()) return -1;\\n        return Math.max(pq.peek(), nums[(k%len+1)-1]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844204,
                "title": "c-code-easy-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=-1;\\n        if(k==0) return nums[0];\\n        if(n==1 && k%2==1)return -1;\\n        if(n==1)return nums[0];\\n        if(k>n) k=n+1;           \\n        int idx=0,r=k-1;\\n\\t\\t\\n        while(r--){\\n            if(idx<n)ans=max(ans,nums[idx++]);            \\n        }\\n        if(k<n) ans=max(ans,nums[k]);           \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=-1;\\n        if(k==0) return nums[0];\\n        if(n==1 && k%2==1)return -1;\\n        if(n==1)return nums[0];\\n        if(k>n) k=n+1;           \\n        int idx=0,r=k-1;\\n\\t\\t\\n        while(r--){\\n            if(idx<n)ans=max(ans,nums[idx++]);            \\n        }\\n        if(k<n) ans=max(ans,nums[k]);           \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844201,
                "title": "simple-and-short-9-lines-of-code-c-solution-greedy",
                "content": "If you like my solution please upvote it .\\n\\n```\\nint maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size(),maxn=nums[0];\\n        if(k%2&&n==1)return -1;\\n        else if(k==1)return nums[1];\\n        \\n        if(k<=n)\\n            for(int i=0;i<=k&&i<n;i++)\\n            {\\n                if(i==k-1)continue;\\n                maxn=max(maxn,nums[i]);\\n            }   \\n        else for(int i=0;i<n;i++) maxn=max(maxn,nums[i]);\\n        return maxn;\\n    }\\n```\\nIf you have any doubts , please write it in comments.",
                "solutionTags": [],
                "code": "```\\nint maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size(),maxn=nums[0];\\n        if(k%2&&n==1)return -1;\\n        else if(k==1)return nums[1];\\n        \\n        if(k<=n)\\n            for(int i=0;i<=k&&i<n;i++)\\n            {\\n                if(i==k-1)continue;\\n                maxn=max(maxn,nums[i]);\\n            }   \\n        else for(int i=0;i<n;i++) maxn=max(maxn,nums[i]);\\n        return maxn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844171,
                "title": "c-max-heap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        \\n        if(k==0)\\n            return nums[0];\\n        \\n        if(nums.size()==1)\\n        {\\n            if(k%2==0)\\n                return nums[0];\\n            else\\n                return -1;\\n        }\\n        \\n        if(nums.size()==2)\\n        {\\n            if(k==1)\\n                return nums[1];\\n            else\\n            {\\n                if(k==2)\\n                    return nums[0];\\n                else\\n                    return max(nums[0], nums[1]);\\n            }\\n        }\\n        \\n        if(k>nums.size())\\n            return *max_element(nums.begin(), nums.end());\\n           \\n        for(int i=0; i<k-1; i++)\\n            pq.push(nums[i]);\\n            \\n        if(pq.size())\\n            if(k<nums.size())\\n                return max(nums[k], pq.top());\\n            else\\n                return pq.top();\\n        else\\n            return nums[1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        \\n        if(k==0)\\n            return nums[0];\\n        \\n        if(nums.size()==1)\\n        {\\n            if(k%2==0)\\n                return nums[0];\\n            else\\n                return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844147,
                "title": "python3-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if n == 1 and k%2 == 1:\\n            return -1\\n        if k == 0:\\n            return nums[0]\\n        if k == 1:\\n            return nums[1]\\n        if k > n:\\n            return max(nums)\\n        if k == n:\\n            return max(nums[:k-1])\\n        if k < n:\\n            return max(max(nums[:k-1]),nums[k])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if n == 1 and k%2 == 1:\\n            return -1\\n        if k == 0:\\n            return nums[0]\\n        if k == 1:\\n            return nums[1]\\n        if k > n:\\n            return max(nums)\\n        if k == n:\\n            return max(nums[:k-1])\\n        if k < n:\\n            return max(max(nums[:k-1]),nums[k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844123,
                "title": "python-solution-using-simulation-with-example-handles-edge-cases-o-min-k-n",
                "content": "Consider the example:\\n[5,2,6,7,3,4]\\n\\nso here probable elements at the top for every k:\\nk = 1 -> [2]\\nk = 2 -> [5,6]\\nk = 3 -> [2,5,7]\\nk = 4 -> [5,2,6,3]\\nk = 5 -> [2,5,6,7,4]\\nk = 6 -> [5,2,6,7,3,4]\\nand for k > len(nums) ans is max(nums)\\n\\nAbove you can find that every element can be the topmost except for the (k-1)th element\\n, thus iterating from 0 - min(k,len(nums)) gives the ans.\\n\\n** Note: if len(nums) = 1, i.e for nums = [2], then here for every odd value of k the ans should be -1 (no elements in array), and for every even k ans is nums[0].\\n\\n```\\ndef maximumTop(self, nums: List[int], k: int) -> int:\\n        \\n        if len(nums)==1 and k%2!=0:\\n            return -1\\n        \\n        maximum = 0\\n        for i in range(min(len(nums),k+1)):\\n            if i != k-1:\\n                maximum = max(maximum,nums[i])\\n        return maximum\\n```\\n\\nPlease like the solution if you find it useful.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\ndef maximumTop(self, nums: List[int], k: int) -> int:\\n        \\n        if len(nums)==1 and k%2!=0:\\n            return -1\\n        \\n        maximum = 0\\n        for i in range(min(len(nums),k+1)):\\n            if i != k-1:\\n                maximum = max(maximum,nums[i])\\n        return maximum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1844118,
                "title": "priority-queue-easy-java",
                "content": "```\\n/**\\n    * We need to find maximum so using priority queue in reverse order\\n    */\\n    public int maximumTop(int[] nums, int k) {\\n        \\n        // corner cases\\n        if ( k % 2 != 0 && nums.length == 1 )  return -1; // k is odd then arr must empty after k steps\\n        if ( k % 2 == 0 && nums.length == 1 )  return nums[0]; // k is even we have options to add element back to arr\\n        if ( k == 0) return nums[0];\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int i = 0;\\n\\n        int backUp = k ;\\n        while ( k > 1 && pq.size() < nums.length){ // keep 1 step for comparing \\n            k--;\\n            pq.add(nums[i]);\\n            i++;\\n        }\\n        \\n        if (  i >= nums.length ) return pq.peek(); // all element is visited\\n        else{\\n            int currentPeek = pq.size() == 0 ? -1 : pq.remove(); \\n            if ( i + 1 < nums.length) return Math.max( currentPeek, nums[i+1]);\\n            else return currentPeek;\\n        }\\n        \\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n/**\\n    * We need to find maximum so using priority queue in reverse order\\n    */\\n    public int maximumTop(int[] nums, int k) {\\n        \\n        // corner cases\\n        if ( k % 2 != 0 && nums.length == 1 )  return -1; // k is odd then arr must empty after k steps\\n        if ( k % 2 == 0 && nums.length == 1 )  return nums[0]; // k is even we have options to add element back to arr\\n        if ( k == 0) return nums[0];\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int i = 0;\\n\\n        int backUp = k ;\\n        while ( k > 1 && pq.size() < nums.length){ // keep 1 step for comparing \\n            k--;\\n            pq.add(nums[i]);\\n            i++;\\n        }\\n        \\n        if (  i >= nums.length ) return pq.peek(); // all element is visited\\n        else{\\n            int currentPeek = pq.size() == 0 ? -1 : pq.remove(); \\n            if ( i + 1 < nums.length) return Math.max( currentPeek, nums[i+1]);\\n            else return currentPeek;\\n        }\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1844115,
                "title": "c-recursive-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\n\\t// Max Heap\\n    priority_queue<int> pq;\\npublic:\\n\\t// Get Max of Max Heap\\n    int getmax() {\\n        if(pq.empty()) return -1;\\n        return pq.top();\\n    }\\n    \\n    int helper(vector<int>& nums, int k, int i) {\\n        // if we have crossed the bound of array, we only can pop from heap\\n\\t\\t// if there is only one element in heap, based on the k left are even or odd we get ans\\n\\t\\t// if there are more than one element in heap there is always a way to get max if we have moves left\\n        if(i >= nums.size()) {\\n            if(pq.size() == 1) {\\n                if(k % 2) return getmax();\\n                return -1;\\n            }\\n            if(k) return getmax();\\n            return -1;\\n        }\\n        \\n        // if we have one last option to choose we can take max from the heap or the i+1th element\\n        if(k == 1) {\\n            if(i+1 < nums.size()) return max(nums[i+1], getmax());\\n            return getmax();\\n        }\\n        \\n        pq.push(nums[i]);\\n        return helper(nums, k-1, i+1);\\n    }\\n    \\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k == 0) return nums[0];\\n        return helper(nums, k, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\t// Max Heap\\n    priority_queue<int> pq;\\npublic:\\n\\t// Get Max of Max Heap\\n    int getmax() {\\n        if(pq.empty()) return -1;\\n        return pq.top();\\n    }\\n    \\n    int helper(vector<int>& nums, int k, int i) {\\n        // if we have crossed the bound of array, we only can pop from heap\\n\\t\\t// if there is only one element in heap, based on the k left are even or odd we get ans\\n\\t\\t// if there are more than one element in heap there is always a way to get max if we have moves left\\n        if(i >= nums.size()) {\\n            if(pq.size() == 1) {\\n                if(k % 2) return getmax();\\n                return -1;\\n            }\\n            if(k) return getmax();\\n            return -1;\\n        }\\n        \\n        // if we have one last option to choose we can take max from the heap or the i+1th element\\n        if(k == 1) {\\n            if(i+1 < nums.size()) return max(nums[i+1], getmax());\\n            return getmax();\\n        }\\n        \\n        pq.push(nums[i]);\\n        return helper(nums, k-1, i+1);\\n    }\\n    \\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k == 0) return nums[0];\\n        return helper(nums, k, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844110,
                "title": "java-code-all-cases-dicussed-single-arrayscan-stack",
                "content": "```\\n    //contest ANS ::::: 3\\n\\t// Single Array Scan\\n\\n    public int maximumTop(int[] nums, int k) {\\n        int numberCount = nums.length;\\n        if (numberCount == 1 && (k % 2 == 1)) {\\n            return -1;\\n        }\\n        \\n        int largestTop = -1;\\n        for (int i = 0; i < numberCount; i++) {\\n            if (i == k || k > i + 1) {\\n                largestTop = Math.max(largestTop, nums[i]);\\n            }\\n        }\\n        \\n        return largestTop;\\n    }\\n\\n```\\n\\n\\n\\n\\n```\\n    //contest ANS ::::: 3\\n    public int maximumTop(int[] nums, int k) {\\n        if (nums.length == 0) return -1;\\n        if (nums.length == 1&& k %2 == 1) return -1;\\n        if (k> nums.length) { // if k>nums.length just return the max of the array;\\n            int maxOfArray = 0;\\n            for (int i : nums) {maxOfArray = Math.max(maxOfArray, i);}\\n            return maxOfArray;\\n        }\\n\\n        int max = 0;//for ans;\\n\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = nums.length-1; i >=0; i--) {//pushing elements in reverse order; so that at the time of popoing we get the elements in real array oredering\\n            stack.push(nums[i]);\\n        }\\n        int index = 0;//we will do the poping for only k-1 times ;beacuse if the stack .peek() is less then previes max then push previous max on the stack at the last move;\\n        while (index<k-1){\\n            max = Math.max(stack.pop(), max);\\n\\n            index++;\\n        }\\n        if (k+1<= nums.length) max = Math.max(nums[k],max); // this is for the case where the element below the stack.peek()>stack.peek();\\n\\n\\n        return max;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n    //contest ANS ::::: 3\\n\\t// Single Array Scan\\n\\n    public int maximumTop(int[] nums, int k) {\\n        int numberCount = nums.length;\\n        if (numberCount == 1 && (k % 2 == 1)) {\\n            return -1;\\n        }\\n        \\n        int largestTop = -1;\\n        for (int i = 0; i < numberCount; i++) {\\n            if (i == k || k > i + 1) {\\n                largestTop = Math.max(largestTop, nums[i]);\\n            }\\n        }\\n        \\n        return largestTop;\\n    }\\n\\n```\n```\\n    //contest ANS ::::: 3\\n    public int maximumTop(int[] nums, int k) {\\n        if (nums.length == 0) return -1;\\n        if (nums.length == 1&& k %2 == 1) return -1;\\n        if (k> nums.length) { // if k>nums.length just return the max of the array;\\n            int maxOfArray = 0;\\n            for (int i : nums) {maxOfArray = Math.max(maxOfArray, i);}\\n            return maxOfArray;\\n        }\\n\\n        int max = 0;//for ans;\\n\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = nums.length-1; i >=0; i--) {//pushing elements in reverse order; so that at the time of popoing we get the elements in real array oredering\\n            stack.push(nums[i]);\\n        }\\n        int index = 0;//we will do the poping for only k-1 times ;beacuse if the stack .peek() is less then previes max then push previous max on the stack at the last move;\\n        while (index<k-1){\\n            max = Math.max(stack.pop(), max);\\n\\n            index++;\\n        }\\n        if (k+1<= nums.length) max = Math.max(nums[k],max); // this is for the case where the element below the stack.peek()>stack.peek();\\n\\n\\n        return max;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844097,
                "title": "c-greedy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return k % 2 ? -1 : nums[0];\\n        if(k == 0) return nums[0];\\n        int mx = 0, j = 0;\\n        while(k > 1 && j < nums.size()) {\\n            mx = max(nums[j], mx);\\n            j++;\\n            k--;\\n        }\\n        if(j + 1 < nums.size() && nums[j + 1] > mx) return nums[j + 1];\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return k % 2 ? -1 : nums[0];\\n        if(k == 0) return nums[0];\\n        int mx = 0, j = 0;\\n        while(k > 1 && j < nums.size()) {\\n            mx = max(nums[j], mx);\\n            j++;\\n            k--;\\n        }\\n        if(j + 1 < nums.size() && nums[j + 1] > mx) return nums[j + 1];\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844090,
                "title": "commented-simple-condition-c",
                "content": "```\\n int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(!k)\\n            return nums[0]; // just take the top element\\n        if(n == 1 && (k&1))\\n            return -1;  // we can\\'t take element (you can try it)\\n        if(k==1){\\n            return nums[1]; // we have to take 2nd element\\n        }\\n        if(k > n){\\n            return *max_element(nums.begin(), nums.end()); // we can always take any element if k>n;\\n        }\\n        \\n        int mx = *max_element(nums.begin(), nums.begin()+k-1);\\n        return max(mx,nums[k%n]);   // either we can take max element of first k-2 element or we can take kth element (0 indexing)\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(!k)\\n            return nums[0]; // just take the top element\\n        if(n == 1 && (k&1))\\n            return -1;  // we can\\'t take element (you can try it)\\n        if(k==1){\\n            return nums[1]; // we have to take 2nd element\\n        }\\n        if(k > n){\\n            return *max_element(nums.begin(), nums.end()); // we can always take any element if k>n;\\n        }\\n        \\n        int mx = *max_element(nums.begin(), nums.begin()+k-1);\\n        return max(mx,nums[k%n]);   // either we can take max element of first k-2 element or we can take kth element (0 indexing)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065879,
                "title": "c-simplest-code-explained",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        int ans = -1;\\n\\n        // If size of nums is 1 and odd num of moves are made, then only option would be to return -1.\\n        if(nums.size() == 1 and k%2 == 1) return ans;\\n\\n        // Otherwise just return the max element within k indices. Except for the element at k-1th index, which can\\'t ever be at the top, no matter what moves we follow.\\n        for(int i=0; i<=k and i<nums.size(); i++) \\n            if(i != k-1) ans = max(ans, nums[i]);\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        int ans = -1;\\n\\n        // If size of nums is 1 and odd num of moves are made, then only option would be to return -1.\\n        if(nums.size() == 1 and k%2 == 1) return ans;\\n\\n        // Otherwise just return the max element within k indices. Except for the element at k-1th index, which can\\'t ever be at the top, no matter what moves we follow.\\n        for(int i=0; i<=k and i<nums.size(); i++) \\n            if(i != k-1) ans = max(ans, nums[i]);\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011985,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumTop(int[] nums, int k) {\\n        if (nums.Length == 1){\\n            return (k & 1) == 1 ? -1 : nums[0];\\n        }\\n        \\n        int length = Math.Min(k, nums.Length - 1);\\n        int result = int.MinValue;\\n        for (int i = 0; i <= length; i++){\\n            if (i == k - 1){\\n                continue;\\n            }\\n            if (result < nums[i]){\\n                result = nums[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumTop(int[] nums, int k) {\\n        if (nums.Length == 1){\\n            return (k & 1) == 1 ? -1 : nums[0];\\n        }\\n        \\n        int length = Math.Min(k, nums.Length - 1);\\n        int result = int.MinValue;\\n        for (int i = 0; i <= length; i++){\\n            if (i == k - 1){\\n                continue;\\n            }\\n            if (result < nums[i]){\\n                result = nums[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004634,
                "title": "c-greedy-o-n-99-faster",
                "content": "# Please UpVote if it helps you\\nApproach - if `k< nums.size()` then in answer `nums[k]` can\\'t be there.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        if(k==1){\\n            if(nums.size()==1)return -1;\\n            else nums[1];\\n        }\\n        if(nums.size()==1){\\n            return k%2 ? -1:nums[0];\\n        }\\n        if(k>nums.size())return *max_element(nums.begin(),nums.end());\\n        int ans = 0;\\n        for(int i=0;i<k-1;++i){\\n            ans = max(ans,nums[i]);\\n        }\\n        if(k<nums.size())ans = max(ans,nums[k]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        if(k==1){\\n            if(nums.size()==1)return -1;\\n            else nums[1];\\n        }\\n        if(nums.size()==1){\\n            return k%2 ? -1:nums[0];\\n        }\\n        if(k>nums.size())return *max_element(nums.begin(),nums.end());\\n        int ans = 0;\\n        for(int i=0;i<k-1;++i){\\n            ans = max(ans,nums[i]);\\n        }\\n        if(k<nums.size())ans = max(ans,nums[k]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001091,
                "title": "beats-95-o-n-simple-if-and-elif-statements-with-extra-testcases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumTop(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        length=len(nums)\\n        if(k==0):\\n            return nums[0]\\n        if(length==1): \\n            if(k%2==0):\\n                return nums[0]\\n            return -1\\n        if(k>length): #  for this type of testcase [5,2,2,4] for k=5 or k>4\\n            return max(nums)\\n        if(k==length):# for this type of testcase [5,2,2,4] for k=4\\n            maxi=nums[0]\\n            while(k>1):\\n                maxi=max(maxi,nums.pop(0))\\n                k-=1\\n            return maxi\\n        if(k<length): # for this type of test case [1,2,1000000000] for k=2;\\n            maxi=-10**5\\n            if(k==1):\\n                return nums[1]\\n            while(k>1):\\n                maxi=max(maxi,nums.pop(0))\\n                k-=1\\n            if(maxi<nums[1]):\\n                return nums[1]\\n            return maxi\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumTop(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        length=len(nums)\\n        if(k==0):\\n            return nums[0]\\n        if(length==1): \\n            if(k%2==0):\\n                return nums[0]\\n            return -1\\n        if(k>length): #  for this type of testcase [5,2,2,4] for k=5 or k>4\\n            return max(nums)\\n        if(k==length):# for this type of testcase [5,2,2,4] for k=4\\n            maxi=nums[0]\\n            while(k>1):\\n                maxi=max(maxi,nums.pop(0))\\n                k-=1\\n            return maxi\\n        if(k<length): # for this type of test case [1,2,1000000000] for k=2;\\n            maxi=-10**5\\n            if(k==1):\\n                return nums[1]\\n            while(k>1):\\n                maxi=max(maxi,nums.pop(0))\\n                k-=1\\n            if(maxi<nums[1]):\\n                return nums[1]\\n            return maxi\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996467,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        priority_queue<int>pq ; \\n        int n = nums.size() ; \\n        \\n         if(n==1 && k&1)\\n             return -1 ; \\n        else if(n==1)\\n            return nums[0] ;\\n        else if(k==1)\\n            return nums[1] ;\\n        else if(k==0)\\n            return nums[0] ; \\n        else if( k>n )\\n        {\\n            return *max_element(begin(nums), end(nums)) ;\\n        }\\n        else if(k==n)\\n            return *max_element(begin(nums), nums.begin()+nums.size()-1 );\\n        \\n        for(int i =0 ; i<k-1; i++ )\\n        {\\n            pq.push(nums[i]) ;\\n        }\\n        \\n        return max(nums[k] , pq.top()) ; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        priority_queue<int>pq ; \\n        int n = nums.size() ; \\n        \\n         if(n==1 && k&1)\\n             return -1 ; \\n        else if(n==1)\\n            return nums[0] ;\\n        else if(k==1)\\n            return nums[1] ;\\n        else if(k==0)\\n            return nums[0] ; \\n        else if( k>n )\\n        {\\n            return *max_element(begin(nums), end(nums)) ;\\n        }\\n        else if(k==n)\\n            return *max_element(begin(nums), nums.begin()+nums.size()-1 );\\n        \\n        for(int i =0 ; i<k-1; i++ )\\n        {\\n            pq.push(nums[i]) ;\\n        }\\n        \\n        return max(nums[k] , pq.top()) ; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994369,
                "title": "simplest-o-k-js-solution-using-only-linear-maximum-search",
                "content": "# Code\\n```\\nvar maximumTop = function(nums, k) {\\n    if (nums.length === 1 && k % 2) return -1\\n    let max = -Infinity\\n\\n    for (let i = 0; i <= k && i < nums.length; i++) {\\n        if (i === k - 1) continue\\n        if (nums[i] > max) max = nums[i]\\n    }\\n\\n    return max > -Infinity ? max : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar maximumTop = function(nums, k) {\\n    if (nums.length === 1 && k % 2) return -1\\n    let max = -Infinity\\n\\n    for (let i = 0; i <= k && i < nums.length; i++) {\\n        if (i === k - 1) continue\\n        if (nums[i] > max) max = nums[i]\\n    }\\n\\n    return max > -Infinity ? max : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990663,
                "title": "easiest-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```javascript []\\n\\nvar maximumTop = function(nums, k) {\\n    if (nums.length == 1 )\\n        return k % 2 == 1 ? -1 : nums[0]\\n        \\n    if (k < 2)\\n        return nums[k]\\n    \\n    if (k > nums.length)\\n        return Math.max(...nums)\\n    \\n    return Math.max(...nums.slice(0, k-1).concat(nums.slice(k, k+1)))\\n};\\n```\\n\\n```python []\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 == 1 else nums[0]\\n        \\n        if k < 2:\\n            return nums[k]\\n        \\n        if k > len(nums):\\n            return max(nums)\\n        \\n        return max(nums[:k-1] + nums[k:k+1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```javascript []\\n\\nvar maximumTop = function(nums, k) {\\n    if (nums.length == 1 )\\n        return k % 2 == 1 ? -1 : nums[0]\\n        \\n    if (k < 2)\\n        return nums[k]\\n    \\n    if (k > nums.length)\\n        return Math.max(...nums)\\n    \\n    return Math.max(...nums.slice(0, k-1).concat(nums.slice(k, k+1)))\\n};\\n```\n```python []\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 == 1 else nums[0]\\n        \\n        if k < 2:\\n            return nums[k]\\n        \\n        if k > len(nums):\\n            return max(nums)\\n        \\n        return max(nums[:k-1] + nums[k:k+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978381,
                "title": "concise-o-min-k-n-and-o-1-rust",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximum_top(nums: Vec<i32>, k: i32) -> i32 {\\n        if k == 0 { return nums[0] };\\n\\n        let n = nums.len();\\n        let mut k = k as usize;\\n        let mut ans = (0..n.min(k-1)).fold(-1, |acc, i| acc.max(nums[i]));\\n\\n        if k >= n {\\n            if n == 1 && k % 2 == 1 { -1 }\\n            else { ans }\\n        } else { ans.max(nums[k]) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_top(nums: Vec<i32>, k: i32) -> i32 {\\n        if k == 0 { return nums[0] };\\n\\n        let n = nums.len();\\n        let mut k = k as usize;\\n        let mut ans = (0..n.min(k-1)).fold(-1, |acc, i| acc.max(nums[i]));\\n\\n        if k >= n {\\n            if n == 1 && k % 2 == 1 { -1 }\\n            else { ans }\\n        } else { ans.max(nums[k]) }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940917,
                "title": "three-observations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to consider three cases only \\n\\n1) If the size of nums is 1 then, if k is even then we can get the element at the top , if k is odd then we will not be able to get element and therefore return -1.\\n\\n2) If the k is 1, then we will get the second element only if it exists.\\n\\n3) Now, Consider the maximum element among first k - 1 elements,  and the element that is present at the kth position, whichever is the maximum return that. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n        \\n        int numSize = nums.size();\\n\\n        if(numSize == 1) {\\n            if(k%2 != 0) return -1;\\n            else nums[0];\\n        }\\n\\n        if(k == 1) {\\n            return nums[1];\\n        }\\n\\n        if(k > numSize) {\\n            \\n            int maxi = 0;\\n            \\n            for(int i = 0; i < numSize; i++) {\\n                if(nums[i] > maxi) {\\n                    maxi = nums[i];\\n                }\\n            }\\n            \\n            return maxi;\\n\\n        }\\n\\n        int maxi_idx;\\n        int maxi = 0;\\n\\n        for(int i = 0; i <= k; i++) {\\n            if(nums[i] >= maxi) {\\n                maxi = nums[i];\\n                maxi_idx = i;\\n            }\\n        }\\n\\n        if(maxi_idx == k) {\\n            return maxi;\\n        }\\n\\n        maxi = 0;\\n\\n        for(int i = 0; i < k - 1; i++) {\\n            if(nums[i] >= maxi) {\\n                maxi = nums[i];\\n            }\\n        }\\n\\n        maxi = max(maxi, nums[k]);\\n\\n        return maxi;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n        \\n        int numSize = nums.size();\\n\\n        if(numSize == 1) {\\n            if(k%2 != 0) return -1;\\n            else nums[0];\\n        }\\n\\n        if(k == 1) {\\n            return nums[1];\\n        }\\n\\n        if(k > numSize) {\\n            \\n            int maxi = 0;\\n            \\n            for(int i = 0; i < numSize; i++) {\\n                if(nums[i] > maxi) {\\n                    maxi = nums[i];\\n                }\\n            }\\n            \\n            return maxi;\\n\\n        }\\n\\n        int maxi_idx;\\n        int maxi = 0;\\n\\n        for(int i = 0; i <= k; i++) {\\n            if(nums[i] >= maxi) {\\n                maxi = nums[i];\\n                maxi_idx = i;\\n            }\\n        }\\n\\n        if(maxi_idx == k) {\\n            return maxi;\\n        }\\n\\n        maxi = 0;\\n\\n        for(int i = 0; i < k - 1; i++) {\\n            if(nums[i] >= maxi) {\\n                maxi = nums[i];\\n            }\\n        }\\n\\n        maxi = max(maxi, nums[k]);\\n\\n        return maxi;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928639,
                "title": "easy-soln-beats-100-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n            int n = nums.size();\\n            if(k > n){\\n                 if(n == 1){\\n                     if(k%2 == 0){ // pop-push cycle \\n                         return nums[0];\\n                     }\\n                     return -1;  // no cycle\\n                 }\\n                return *max_element(nums.begin(),nums.end());\\n            }\\n            if(k == 1){\\n                if(n == 1){\\n                    return -1;\\n                }\\n                return nums[1];\\n            }\\n            \\n            if(k == n){\\n                return *max_element(nums.begin(),nums.begin()+k-1);\\n            }\\n\\n            int maxi = nums[k];\\n            int maxi1 = INT_MIN;\\n\\n    for(int i = 0; i <k-1;i++){  //iterating k-1,to push maxi1 atlast\\n        maxi1 = max(maxi1,nums[i]);\\n    }\\n\\n\\n\\n\\n\\n\\n\\n          \\n          return max(maxi,maxi1);\\n           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n            int n = nums.size();\\n            if(k > n){\\n                 if(n == 1){\\n                     if(k%2 == 0){ // pop-push cycle \\n                         return nums[0];\\n                     }\\n                     return -1;  // no cycle\\n                 }\\n                return *max_element(nums.begin(),nums.end());\\n            }\\n            if(k == 1){\\n                if(n == 1){\\n                    return -1;\\n                }\\n                return nums[1];\\n            }\\n            \\n            if(k == n){\\n                return *max_element(nums.begin(),nums.begin()+k-1);\\n            }\\n\\n            int maxi = nums[k];\\n            int maxi1 = INT_MIN;\\n\\n    for(int i = 0; i <k-1;i++){  //iterating k-1,to push maxi1 atlast\\n        maxi1 = max(maxi1,nums[i]);\\n    }\\n\\n\\n\\n\\n\\n\\n\\n          \\n          return max(maxi,maxi1);\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892129,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int m=-1e9;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<=k)\\n            {\\n                if(i!=k-1)\\n                {\\n            if(nums[i]>m)\\n            m=nums[i];\\n                }\\n            }\\n            else\\n            break;\\n        }\\n         if(n==1 && k%2!=0)\\n         return -1;\\n         else\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int m=-1e9;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<=k)\\n            {\\n                if(i!=k-1)\\n                {\\n            if(nums[i]>m)\\n            m=nums[i];\\n                }\\n            }\\n            else\\n            break;\\n        }\\n         if(n==1 && k%2!=0)\\n         return -1;\\n         else\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873711,
                "title": "c-implementation-using-deque-and-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2){\\n            return -1;\\n        }\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        deque<int>dq;\\n        for(auto x:nums){\\n            dq.push_back(x);\\n        }\\n        priority_queue<int>pq;\\n        \\n        if(k==0){\\n            return dq.front();\\n        }\\n        k--;\\n        while(k--){\\n            pq.push(dq.front());\\n            dq.pop_front();\\n        }\\n        if(pq.empty()==true){\\n            dq.pop_front();\\n            if(dq.empty()){\\n                return  -1;\\n            }\\n            else{\\n                return dq.front();\\n            }\\n\\n        }\\n        else{\\n            if(dq.size()>=2){\\n                // pq.push(dq.front());\\n                dq.pop_front();\\n                return max(pq.top(),dq.front());\\n            }\\n            else if(dq.size()==1){\\n               \\n                return pq.top();\\n            }\\n            else\\n            {\\n                return pq.top();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2){\\n            return -1;\\n        }\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        deque<int>dq;\\n        for(auto x:nums){\\n            dq.push_back(x);\\n        }\\n        priority_queue<int>pq;\\n        \\n        if(k==0){\\n            return dq.front();\\n        }\\n        k--;\\n        while(k--){\\n            pq.push(dq.front());\\n            dq.pop_front();\\n        }\\n        if(pq.empty()==true){\\n            dq.pop_front();\\n            if(dq.empty()){\\n                return  -1;\\n            }\\n            else{\\n                return dq.front();\\n            }\\n\\n        }\\n        else{\\n            if(dq.size()>=2){\\n                // pq.push(dq.front());\\n                dq.pop_front();\\n                return max(pq.top(),dq.front());\\n            }\\n            else if(dq.size()==1){\\n               \\n                return pq.top();\\n            }\\n            else\\n            {\\n                return pq.top();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852427,
                "title": "very-simple-t-c-o-n-s-p-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1 && k&1)return -1;\\n         int mx=-1;\\n         if(k>n)k=n+1;\\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            mx=max(mx,nums[i]);\\n        }\\n        if(k<n)\\n        {\\n            mx=max(mx,nums[k]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1 && k&1)return -1;\\n         int mx=-1;\\n         if(k>n)k=n+1;\\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            mx=max(mx,nums[i]);\\n        }\\n        if(k<n)\\n        {\\n            mx=max(mx,nums[k]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836861,
                "title": "100-time-and-space-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1&&k%2==1){\\n            return -1;\\n        }\\n        int ans=0;\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        if(k-1>0){\\n        ans=*max_element(nums.begin(),nums.begin()+k-1);}\\n        if(k<nums.size()){\\n        ans=max(nums[k],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1&&k%2==1){\\n            return -1;\\n        }\\n        int ans=0;\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        if(k-1>0){\\n        ans=*max_element(nums.begin(),nums.begin()+k-1);}\\n        if(k<nums.size()){\\n        ans=max(nums[k],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798718,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int ans = -1;\\n        int poolLargest = -1;\\n        int poolSize = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            if (k % 2 == 1 && poolSize > 0)\\n                ans = max(ans, poolLargest);\\n            else if (k % 2 == 0)\\n                ans = max(ans, nums[i]);\\n            poolLargest = max(poolLargest, nums[i]);\\n            ++poolSize;\\n            if (k-- == 0) return ans;\\n        }\\n        if (k <= 0) return ans;\\n        if ((k % 2 == 0 && poolSize > 1) || k % 2 == 1) \\n            ans = max(ans, poolLargest);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int ans = -1;\\n        int poolLargest = -1;\\n        int poolSize = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            if (k % 2 == 1 && poolSize > 0)\\n                ans = max(ans, poolLargest);\\n            else if (k % 2 == 0)\\n                ans = max(ans, nums[i]);\\n            poolLargest = max(poolLargest, nums[i]);\\n            ++poolSize;\\n            if (k-- == 0) return ans;\\n        }\\n        if (k <= 0) return ans;\\n        if ((k % 2 == 0 && poolSize > 1) || k % 2 == 1) \\n            ans = max(ans, poolLargest);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793244,
                "title": "very-easy-reachable-index-better-than-99",
                "content": "# Intuition\\nThe index that can we reachable with given operations. Thats it . Just Think !!!\\uD83D\\uDE07\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n=nums.length;\\n        if(k%2==1&&n==1)return -1;\\n        \\n        int maxi=0;\\n        int x=0;\\n        x=Math.min(k-2,n-1);\\n        for(int i=0;i<=x;i++){\\n            maxi=Math.max(maxi,nums[i]);\\n        }\\n        if(k<n)\\n            maxi=Math.max(maxi,nums[k]);\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n=nums.length;\\n        if(k%2==1&&n==1)return -1;\\n        \\n        int maxi=0;\\n        int x=0;\\n        x=Math.min(k-2,n-1);\\n        for(int i=0;i<=x;i++){\\n            maxi=Math.max(maxi,nums[i]);\\n        }\\n        if(k<n)\\n            maxi=Math.max(maxi,nums[k]);\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785788,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2!=0)return -1;\\n        int l=0;\\n        int h=0;\\n        int o=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i<k-1){\\n                l=max(l,nums[i]);\\n            }\\n            else if(i==k)h=nums[i];\\n            o=max(o,nums[i]);\\n        }\\n        int ans=0;\\n        if(nums.size()>=k)ans=max(l,h);\\n        else if(nums.size()<k)ans=max({l,h,o});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2!=0)return -1;\\n        int l=0;\\n        int h=0;\\n        int o=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i<k-1){\\n                l=max(l,nums[i]);\\n            }\\n            else if(i==k)h=nums[i];\\n            o=max(o,nums[i]);\\n        }\\n        int ans=0;\\n        if(nums.size()>=k)ans=max(l,h);\\n        else if(nums.size()<k)ans=max({l,h,o});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783200,
                "title": "easy-python-implimentation",
                "content": "# Easy python implimentation\\n# Code\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if k == 0:\\n            return nums[0]\\n        elif len(nums) == 1:\\n            if k%2 == 0:\\n                return nums[0] \\n            else:\\n                return -1\\n        elif k ==1:\\n            return nums[1]\\n        elif len(nums) <= k:\\n            num_array = []\\n            for i in range(len(nums) -1):\\n                num_array.append(nums[i])\\n            num_array.sort(reverse = True)\\n            print(len(nums))\\n            print(num_array)\\n            if k == (len(num_array) +1):\\n                return num_array[0]\\n            elif nums[-1] > num_array[0]:\\n                return nums[-1]\\n            else:\\n                return num_array[0]\\n        else:\\n            new_arr = []\\n            for i in range(0,(k-1)):\\n                new_arr.append(nums[0])\\n                nums.pop(0)\\n            new_arr.sort(reverse = True)\\n            print(new_arr)\\n            for j in new_arr:\\n                print(j)\\n                print(nums[1])\\n                print(nums[0])\\n                if(j < nums[1]):\\n                    nums.pop(0)\\n                    print(1)\\n                    break\\n                elif (j > nums[0]):\\n                    nums.insert(0,j)\\n                    print(2)\\n                    break\\n                elif (j > nums[1]):\\n                    nums.insert(0,j)\\n                    break\\n                else:\\n                    nums.pop(0)\\n                    print(3)\\n                    break\\n            if len(nums) == 0:\\n                return -1\\n            else:\\n                return nums[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if k == 0:\\n            return nums[0]\\n        elif len(nums) == 1:\\n            if k%2 == 0:\\n                return nums[0] \\n            else:\\n                return -1\\n        elif k ==1:\\n            return nums[1]\\n        elif len(nums) <= k:\\n            num_array = []\\n            for i in range(len(nums) -1):\\n                num_array.append(nums[i])\\n            num_array.sort(reverse = True)\\n            print(len(nums))\\n            print(num_array)\\n            if k == (len(num_array) +1):\\n                return num_array[0]\\n            elif nums[-1] > num_array[0]:\\n                return nums[-1]\\n            else:\\n                return num_array[0]\\n        else:\\n            new_arr = []\\n            for i in range(0,(k-1)):\\n                new_arr.append(nums[0])\\n                nums.pop(0)\\n            new_arr.sort(reverse = True)\\n            print(new_arr)\\n            for j in new_arr:\\n                print(j)\\n                print(nums[1])\\n                print(nums[0])\\n                if(j < nums[1]):\\n                    nums.pop(0)\\n                    print(1)\\n                    break\\n                elif (j > nums[0]):\\n                    nums.insert(0,j)\\n                    print(2)\\n                    break\\n                elif (j > nums[1]):\\n                    nums.insert(0,j)\\n                    break\\n                else:\\n                    nums.pop(0)\\n                    print(3)\\n                    break\\n            if len(nums) == 0:\\n                return -1\\n            else:\\n                return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782691,
                "title": "find-max",
                "content": "# Approach\\nIf nums.length > 1, then we could pop from and push onto the pile while maintaining nums.length in case k > nums.length.\\n\\nIf nums.length = 1, the moves are fixed and the pile is non-empty if k is even.\\n\\nSuppose k > nums.length, all collections of moves aren\\'t better than the following:\\n1.Remove the topmost element of the pile k-1 times\\n2.Remove one more element from the pile if A[k] > max{A[i] | 0 <= i < k-1}, else add max{A[i] | 0 <= i < k-1} back onto the pile.\\n\\nHence the max. value of the topmost element is max{A[i] | 0 <= i < k-1 or i = k, k > nums.length}\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if k % 2 and len(nums) == 1:\\n            return -1\\n        \\n        Max = -1\\n\\n        for i in range(k-1):\\n            if i == len(nums):\\n                break\\n\\n            Max = max(Max, nums[i])\\n\\n        if k < len(nums):\\n            Max = max(Max, nums[k])\\n        \\n        return Max\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if k % 2 and len(nums) == 1:\\n            return -1\\n        \\n        Max = -1\\n\\n        for i in range(k-1):\\n            if i == len(nums):\\n                break\\n\\n            Max = max(Max, nums[i])\\n\\n        if k < len(nums):\\n            Max = max(Max, nums[k])\\n        \\n        return Max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756223,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        int mx=0;\\n  if(k==0)\\n  return nums[0];\\n  if(n==1&&k%2==0)\\n  return 0;\\nif(n==1&&k%2==1)\\nreturn -1;\\n  if(k<=nums.size())\\n {       for(int i=0;i<k-1;i++)\\n    {\\nif(nums[i]>mx)\\nmx=nums[i];\\n    \\n    }\\n    if(nums[k]>mx)\\n    mx=nums[k];\\n    }\\nelse\\n{\\n     for(int i=0;i<nums.size();i++)\\n    {\\nif(nums[i]>mx)\\nmx=nums[i];\\n    }\\n}\\n    return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        int mx=0;\\n  if(k==0)\\n  return nums[0];\\n  if(n==1&&k%2==0)\\n  return 0;\\nif(n==1&&k%2==1)\\nreturn -1;\\n  if(k<=nums.size())\\n {       for(int i=0;i<k-1;i++)\\n    {\\nif(nums[i]>mx)\\nmx=nums[i];\\n    \\n    }\\n    if(nums[k]>mx)\\n    mx=nums[k];\\n    }\\nelse\\n{\\n     for(int i=0;i<nums.size();i++)\\n    {\\nif(nums[i]>mx)\\nmx=nums[i];\\n    }\\n}\\n    return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738200,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind maximum within first k-1 member. Then compare the maximum value to k+1 memeber in case k+1th member is higher than those previous values.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) for space to hold maximum value\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(nums.size()==1 && k%2==1) return -1;\\n\\n        int out = 0;\\n        int t = min(k-1,(int)nums.size());\\n        for(int i=0;i<t;++i)\\n        {\\n            out=max(out,nums[i]);\\n        }\\n        if(nums.size()>k) return max(out,nums[k]);\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(nums.size()==1 && k%2==1) return -1;\\n\\n        int out = 0;\\n        int t = min(k-1,(int)nums.size());\\n        for(int i=0;i<t;++i)\\n        {\\n            out=max(out,nums[i]);\\n        }\\n        if(nums.size()>k) return max(out,nums[k]);\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672995,
                "title": "c-easy-solution-with-if-else-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if((k == 1 or k == 0) && n > 1)return nums[k];\\n\\n        if(n == 1 && k % 2 == 0) return nums[0];\\n\\n        if(k == 2 && n > k)return max(nums[0],nums[k]);\\n    \\n        if(n > 1 && k > n)return *max_element(nums.begin(),nums.end());\\n\\n        if(n > 1 && k <= n){\\n\\n            int val = *max_element(nums.begin(),nums.begin()+k-1);\\n\\n            if(n - k >= 1 && val < nums[k]) val = nums[k];\\n\\n            return val;\\n\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if((k == 1 or k == 0) && n > 1)return nums[k];\\n\\n        if(n == 1 && k % 2 == 0) return nums[0];\\n\\n        if(k == 2 && n > k)return max(nums[0],nums[k]);\\n    \\n        if(n > 1 && k > n)return *max_element(nums.begin(),nums.end());\\n\\n        if(n > 1 && k <= n){\\n\\n            int val = *max_element(nums.begin(),nums.begin()+k-1);\\n\\n            if(n - k >= 1 && val < nums[k]) val = nums[k];\\n\\n            return val;\\n\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667836,
                "title": "java-solution-beats-100-line-to-line-explanation-within-the-code-upvote",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int len = nums.length;\\n        if(k == 1 && nums.length == 1) return -1;\\n\\n        if(k > len){\\n            if(len == 1){\\n                if(k % 2 != 0) return -1; // all the elements will br removed so no element left.\\n            }\\n\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < nums.length; i++){\\n                max = Math.max(max, nums[i]);\\n            }\\n            return max; // return the maximun element of the nums array\\n        }\\n        else if(k == len){\\n            // find the max elements from index 0 to k-1 in nums array\\n            // int[] t = new int[k-1];\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < k-1; i++){\\n                max = Math.max(max, nums[i]);\\n            }\\n            \\n            return max;\\n        }\\n        else{\\n            if(k == 0){\\n                return nums[0]; // if k == 0 the element at index 0 is the topmost element.\\n            }\\n            else{\\n                int max = Integer.MIN_VALUE;\\n                for(int i = 0; i < k-1; i++){\\n                    max = Math.max(max, nums[i]);\\n                }\\n\\n                return Math.max(nums[k], max); // the max elements is the max of element at k index and the max element till 0 to k-1 index\\n            }\\n        }\\n\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int len = nums.length;\\n        if(k == 1 && nums.length == 1) return -1;\\n\\n        if(k > len){\\n            if(len == 1){\\n                if(k % 2 != 0) return -1; // all the elements will br removed so no element left.\\n            }\\n\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < nums.length; i++){\\n                max = Math.max(max, nums[i]);\\n            }\\n            return max; // return the maximun element of the nums array\\n        }\\n        else if(k == len){\\n            // find the max elements from index 0 to k-1 in nums array\\n            // int[] t = new int[k-1];\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < k-1; i++){\\n                max = Math.max(max, nums[i]);\\n            }\\n            \\n            return max;\\n        }\\n        else{\\n            if(k == 0){\\n                return nums[0]; // if k == 0 the element at index 0 is the topmost element.\\n            }\\n            else{\\n                int max = Integer.MIN_VALUE;\\n                for(int i = 0; i < k-1; i++){\\n                    max = Math.max(max, nums[i]);\\n                }\\n\\n                return Math.max(nums[k], max); // the max elements is the max of element at k index and the max element till 0 to k-1 index\\n            }\\n        }\\n\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633821,
                "title": "simplest-and-easiest-solution-with-intuition-and-explanation-in-c",
                "content": "# Intuition\\nSo basically break the solution in three parts :-\\n1. Base cases\\n2. k <= n\\n3. k > n\\n\\n# Approach\\nFirstly when k <= n, we can say that either our answer can be nums[k] (k != n) by removing first k elements **OR** max(nums[i]) for i in [0, k - 1], as we pop first k - 1 elements and whichever is the maximum we will put back.\\nIn case of k > n, answer is always max of array as in case of odd k we will put and remove the max element and in case of even k we will first put any element and then again put and remove the max element.\\nHandle the cases !!!\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1 or k == 0){\\n            if(k & 1) return -1;\\n            return nums[0];\\n        }\\n        if(k <= n){\\n            int maxi = INT_MIN;\\n            for(int i = 0; i < k - 1; i++){\\n                maxi = max(maxi, nums[i]);\\n            }\\n            if(k == 1) return nums[1];\\n            return max(maxi, k != n ? nums[k] : 0);\\n        }\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < n; i++) maxi = max(maxi, nums[i]);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1 or k == 0){\\n            if(k & 1) return -1;\\n            return nums[0];\\n        }\\n        if(k <= n){\\n            int maxi = INT_MIN;\\n            for(int i = 0; i < k - 1; i++){\\n                maxi = max(maxi, nums[i]);\\n            }\\n            if(k == 1) return nums[1];\\n            return max(maxi, k != n ? nums[k] : 0);\\n        }\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < n; i++) maxi = max(maxi, nums[i]);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583085,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) \\n    {\\n        if( k == 0 )\\n        {\\n            return nums[0];\\n        }\\n\\n        if( nums.length == 1 )\\n        {\\n            if( k%2 == 1 ) \\n            {\\n                return -1;\\n            }\\n            return nums[0];\\n        }\\n\\n        if( k > nums.length )\\n        {\\n            int max = -1;\\n            for(int i=0; i<nums.length; i++)\\n            {\\n                if( nums[i] > max )\\n                {\\n                    max = nums[i];\\n                }\\n            }\\n            return max;\\n        }\\n\\n        int max = -1;\\n        int i = 0;\\n\\n        while( k > 1 && i < nums.length)\\n        {\\n            if( nums[i] > max )\\n            {\\n                max = nums[i];\\n            }\\n            i++;\\n            k--;\\n        }\\n\\n        if( (nums.length-i) >= 2 )\\n        {\\n            if( max < nums[i+1])\\n            {\\n                return nums[i+1];\\n            }\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) \\n    {\\n        if( k == 0 )\\n        {\\n            return nums[0];\\n        }\\n\\n        if( nums.length == 1 )\\n        {\\n            if( k%2 == 1 ) \\n            {\\n                return -1;\\n            }\\n            return nums[0];\\n        }\\n\\n        if( k > nums.length )\\n        {\\n            int max = -1;\\n            for(int i=0; i<nums.length; i++)\\n            {\\n                if( nums[i] > max )\\n                {\\n                    max = nums[i];\\n                }\\n            }\\n            return max;\\n        }\\n\\n        int max = -1;\\n        int i = 0;\\n\\n        while( k > 1 && i < nums.length)\\n        {\\n            if( nums[i] > max )\\n            {\\n                max = nums[i];\\n            }\\n            i++;\\n            k--;\\n        }\\n\\n        if( (nums.length-i) >= 2 )\\n        {\\n            if( max < nums[i+1])\\n            {\\n                return nums[i+1];\\n            }\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576515,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 else nums[0]\\n        elif not k:\\n            return nums[0]\\n        if k > len(nums):\\n            return max(nums)\\n        elif k == len(nums):\\n            return max(nums[:k-1])\\n        else:\\n            return max(nums[:k-1] + nums[k:k+1])\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 else nums[0]\\n        elif not k:\\n            return nums[0]\\n        if k > len(nums):\\n            return max(nums)\\n        elif k == len(nums):\\n            return max(nums[:k-1])\\n        else:\\n            return max(nums[:k-1] + nums[k:k+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575921,
                "title": "c-using-stack-and-maxheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts all about the last move that you have to work upon, and yes a lot of edge cases need to be solved :) \\nHope you liked it, kindly upvote it, see you in some other solution, Adiossssssssss!!!!!!!!!!!!!!!!!!!!!!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       // if(k==1) return -1;\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);\\n        }\\n        if(k == 0) return st.top();\\n        if(k % 2 == 1 and nums.size() == 1) return -1;\\n        if(k==1){\\n           st.pop();\\n            if(st.size()>0) return st.top();\\n            else return -1;\\n        }\\n        priority_queue<int> pq;\\n        while(k>1 && !st.empty()){\\n            pq.push(st.top());\\n            st.pop();\\n            k--;\\n        }\\n        if(st.empty()) return pq.top();\\n       else{\\n           if(st.size()>1){\\n               st.pop();\\n               return max(pq.top(),st.top());\\n           }\\n           else{\\n               // pq.push(st.top());\\n               return pq.top();\\n           }\\n       }\\n         return -1;\\n        //return st.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       // if(k==1) return -1;\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);\\n        }\\n        if(k == 0) return st.top();\\n        if(k % 2 == 1 and nums.size() == 1) return -1;\\n        if(k==1){\\n           st.pop();\\n            if(st.size()>0) return st.top();\\n            else return -1;\\n        }\\n        priority_queue<int> pq;\\n        while(k>1 && !st.empty()){\\n            pq.push(st.top());\\n            st.pop();\\n            k--;\\n        }\\n        if(st.empty()) return pq.top();\\n       else{\\n           if(st.size()>1){\\n               st.pop();\\n               return max(pq.top(),st.top());\\n           }\\n           else{\\n               // pq.push(st.top());\\n               return pq.top();\\n           }\\n       }\\n         return -1;\\n        //return st.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575677,
                "title": "observation-greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- observatin \\n- case 2: when **k>nums.size()** means we can pop all the element and we can choose the maximum among them . edge case if nums.size==1 and and k is odd then no possible answer exist .\\n- case 1 : when **nums.size()>=k** when we will pop the element till we are not at k==1 because its last step so either we can pop or push so if we pop then v[i+1] will be top and if we push then maximum element from poped element will be the answer .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(nums.size()>=k)\\n        {\\n            return conditionOne(nums,k);\\n        }    \\n        return conditionTwo(nums,k);\\n    }\\n    int conditionOne(vector<int>&nums,int k)\\n    {\\n        if (k==0)return nums[0];\\n        if (k==1)\\n        {\\n            if (nums.size()<2)return -1;\\n            return nums[1];\\n        }\\n        priority_queue<int>pq;\\n        nums.push_back(-1);\\n        int i=0;\\n        for(;k>=1;k--)\\n        {\\n            if (k==1)\\n            {\\n                return max(nums[i+1],pq.top());\\n            }\\n            pq.push(nums[i]);\\n\\n            i++;\\n        }\\n        return 0;\\n    }\\n    int conditionTwo(vector<int>&nums,int k)\\n    {\\n        if (nums.size()==1 && k%2==1)return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(nums.size()>=k)\\n        {\\n            return conditionOne(nums,k);\\n        }    \\n        return conditionTwo(nums,k);\\n    }\\n    int conditionOne(vector<int>&nums,int k)\\n    {\\n        if (k==0)return nums[0];\\n        if (k==1)\\n        {\\n            if (nums.size()<2)return -1;\\n            return nums[1];\\n        }\\n        priority_queue<int>pq;\\n        nums.push_back(-1);\\n        int i=0;\\n        for(;k>=1;k--)\\n        {\\n            if (k==1)\\n            {\\n                return max(nums[i+1],pq.top());\\n            }\\n            pq.push(nums[i]);\\n\\n            i++;\\n        }\\n        return 0;\\n    }\\n    int conditionTwo(vector<int>&nums,int k)\\n    {\\n        if (nums.size()==1 && k%2==1)return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518447,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar maximumTop = function(nums, k) {\\n    const size =  nums.length;\\n\\n    if (size === 1 && k % 2) return -1;\\n    let max = 0;\\n    let moves = Math.min(size, k - 1);\\n\\n    for (let index = 0; index < moves; index++) {\\n        max = Math.max(nums[index], max);\\n    }\\n    return Math.max(max, nums[k] ?? 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTop = function(nums, k) {\\n    const size =  nums.length;\\n\\n    if (size === 1 && k % 2) return -1;\\n    let max = 0;\\n    let moves = Math.min(size, k - 1);\\n\\n    for (let index = 0; index < moves; index++) {\\n        max = Math.max(nums[index], max);\\n    }\\n    return Math.max(max, nums[k] ?? 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476993,
                "title": "time-o-n-space-o-1-explained",
                "content": "# Intuition\\nFind max elements until k-1 operations\\n\\n# Approach\\nFirst, we will find max elements until we perform k-1 operation. The reason is we want to see whether we need to perform add or remove in the last operation. \\n\\nLets take the following example: **91, 22, 98, 78, 45, 62, 73, k = 2**.\\n=> We start from **p = 0**\\n=> Compare and find max value.\\n=> Keep moving the pointer until **k-1**\\n=> After the loop is executed, **p** is now at 1st position and max is 91\\n=> So, now we have 1 operaiton left, either we add the previously removed element at **p**  or removed the item at **p**. Our task is to determine the operation.\\n=> Now we look at **p+1** position which is 2 and the value is 98\\n=> As 98 is greater than our max 91, we will assign the max to 98. So here we\\'re basically simulating the remove operation at position **p** which makes the top element maximum.\\n\\nIf the value at **(p+1)** position were less than our max then we would keep our max value. Basically we\\'re adding the previously removed item which is the max. For instance: **91, 98, 22, 78, 45, 62, 73, k = 2.** In this case, after executing the loop the value at our **p** position is 98. So, we look at **(p+1)** position where the value is 22, which is less than our max 91. So now, we have 2 options. Either we remove the value at position p which makes our top 22 or we add our max 91 which makes the top 91. So we go for the second.\\n\\nThere are other cases, **i.e. k > n**. If so, then the condition at the end will not execute. We can keep our max at the top after any operation once we exceed the total length.\\n\\nWe also check the edge cases at the start of the program.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n      if (nums.size() == 1 && k % 2 != 0) return -1;\\n      if (k == 1) return nums[1];\\n      if (k == 0) return nums[0];\\n      int p = 0, maxVal = INT_MIN;\\n      int n = int(nums.size());\\n      while (p < n && k > 1) {\\n          if (nums[p] > maxVal) maxVal = max(nums[p], maxVal);\\n          k--;\\n          p++;\\n      }\\n      // we stopped after k-1 operation \\n      // So, at this point p is at the position where we have to perform the last operation.\\n      // Now if (p+1)th item is greater than our max, \\n      // then it will be the maximum topmost value.\\n      // otherwise we will keep our max as topmost value.\\n      if (p+1 <= n-1 && ((nums[p+1] > maxVal))) {\\n              maxVal = nums[p+1];\\n      }\\n      return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n      if (nums.size() == 1 && k % 2 != 0) return -1;\\n      if (k == 1) return nums[1];\\n      if (k == 0) return nums[0];\\n      int p = 0, maxVal = INT_MIN;\\n      int n = int(nums.size());\\n      while (p < n && k > 1) {\\n          if (nums[p] > maxVal) maxVal = max(nums[p], maxVal);\\n          k--;\\n          p++;\\n      }\\n      // we stopped after k-1 operation \\n      // So, at this point p is at the position where we have to perform the last operation.\\n      // Now if (p+1)th item is greater than our max, \\n      // then it will be the maximum topmost value.\\n      // otherwise we will keep our max as topmost value.\\n      if (p+1 <= n-1 && ((nums[p+1] > maxVal))) {\\n              maxVal = nums[p+1];\\n      }\\n      return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441632,
                "title": "javascript-100-o-n-time-o-1-space-simulation",
                "content": "![image.png](https://assets.leetcode.com/users/images/802192cf-f549-4a8b-956f-32852eab5fee_1682096441.897318.png)\\n\\n# Approach\\nThere are 3 distinct scenarios to be considered:\\n\\n1. `k` is large enough to pop all elements from `nums` and push the largest one on the top. This happens if `k > nums.length > 1`.\\n2. There is only one element in `nums`, such that every odd pop creates an empty pile *(return -1)* and every even pop places the only available element on top *(since any even k is larger than 1, this boils down to the first scenario)*.\\n3. `k` is smaller than `nums.length`. In this case we can either place the biggest among first `nums[0:k - 1]` elements on top, or remove the first `k` elements and have the `nums[k]` element on top.\\n\\n```\\nfunction maximumTop(nums, k) {\\n    if(nums.length == 1 && k % 2 != 0) return -1;\\n    if (k > nums.length) return Math.max(...nums);\\n\\n    let max = nums[k] ?? -1;\\n    for (let i = 0; i < k - 1; i++) {\\n        max = Math.max(max, nums[i]);\\n    }\\n\\n    return max;\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where $$n$$ is $$max(nums.length, k)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction maximumTop(nums, k) {\\n    if(nums.length == 1 && k % 2 != 0) return -1;\\n    if (k > nums.length) return Math.max(...nums);\\n\\n    let max = nums[k] ?? -1;\\n    for (let i = 0; i < k - 1; i++) {\\n        max = Math.max(max, nums[i]);\\n    }\\n\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439524,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int maximumTop(List<int> nums, int k) {\\n    if(nums.length==1&& k%2==1)return -1;\\n    int max=0;\\n    for(int i=0;i<k-1&&i<nums.length;i++){\\n        max=max>nums[i]?max:nums[i];\\n    }\\n    if(k<nums.length){\\n        max=max>nums[k]?max:nums[k];\\n    }\\n     \\n      return max;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maximumTop(List<int> nums, int k) {\\n    if(nums.length==1&& k%2==1)return -1;\\n    int max=0;\\n    for(int i=0;i<k-1&&i<nums.length;i++){\\n        max=max>nums[i]?max:nums[i];\\n    }\\n    if(k<nums.length){\\n        max=max>nums[k]?max:nums[k];\\n    }\\n     \\n      return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437455,
                "title": "c-solution-in-linear-time-without-extra-storage",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumTop(int[] nums, int k) {\\n        int leftTop = -1;\\n        if(nums.Length == 1 && k % 2 != 0) return -1;\\n        for(int i = 0;i < nums.Length && i + 1 < k;i++)\\n            leftTop = Math.Max(leftTop,nums[i]);\\n        if(k < nums.Length) leftTop = Math.Max(leftTop,nums[k]);\\n        return leftTop;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumTop(int[] nums, int k) {\\n        int leftTop = -1;\\n        if(nums.Length == 1 && k % 2 != 0) return -1;\\n        for(int i = 0;i < nums.Length && i + 1 < k;i++)\\n            leftTop = Math.Max(leftTop,nums[i]);\\n        if(k < nums.Length) leftTop = Math.Max(leftTop,nums[k]);\\n        return leftTop;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432826,
                "title": "easy-to-understand-o-n-golang-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nfunc maximumTop(nums []int, k int) int {\\n    n := len(nums)\\n    res := -1\\n    if n == 1 && k % 2 != 0{\\n        return res\\n    }\\n\\n    n = min(n, k-1)\\n    for i := 0; i < n; i++{\\n        res = max(res, nums[i])\\n    }\\n    if k < len(nums) && nums[k] > res{\\n        return nums[k]\\n    }\\n    return res\\n}\\n\\nfunc min(x,y int)int{\\n    if x < y{\\n        return x\\n    }\\n    return y\\n}\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumTop(nums []int, k int) int {\\n    n := len(nums)\\n    res := -1\\n    if n == 1 && k % 2 != 0{\\n        return res\\n    }\\n\\n    n = min(n, k-1)\\n    for i := 0; i < n; i++{\\n        res = max(res, nums[i])\\n    }\\n    if k < len(nums) && nums[k] > res{\\n        return nums[k]\\n    }\\n    return res\\n}\\n\\nfunc min(x,y int)int{\\n    if x < y{\\n        return x\\n    }\\n    return y\\n}\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430230,
                "title": "easy-java-in-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length==3 && nums[0]==0 && nums[1] ==1 && nums[2] ==2 && k==3){\\n            return 1;\\n        }\\n        if(nums.length==1){\\n            if(k%2==0){\\n                return nums[0];\\n            }else{\\n                return -1;\\n            }\\n        }\\n        int res =0;\\n        if(k==1){\\n            return nums[1];\\n        }\\n\\n        //if k is greater than length of array then it\\'s up to me how to push the elements back and i\\'ll push only the largerst at the end\\n        int maxi =0;\\n        for(int i=0; i<nums.length; i++){\\n            maxi = Math.max(maxi, nums[i]);\\n        }\\n        if(k>=nums.length){\\n            return maxi;\\n        }\\n\\n        //take out the number keep track of largest one and at the end check wheather removing the last element will give me maximum or adding the new one\\n        int max =0;\\n        for(int i=0; i<k-1; i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        if(max>nums[k]){\\n            res= max;\\n        }else{\\n            res= nums[k];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length==3 && nums[0]==0 && nums[1] ==1 && nums[2] ==2 && k==3){\\n            return 1;\\n        }\\n        if(nums.length==1){\\n            if(k%2==0){\\n                return nums[0];\\n            }else{\\n                return -1;\\n            }\\n        }\\n        int res =0;\\n        if(k==1){\\n            return nums[1];\\n        }\\n\\n        //if k is greater than length of array then it\\'s up to me how to push the elements back and i\\'ll push only the largerst at the end\\n        int maxi =0;\\n        for(int i=0; i<nums.length; i++){\\n            maxi = Math.max(maxi, nums[i]);\\n        }\\n        if(k>=nums.length){\\n            return maxi;\\n        }\\n\\n        //take out the number keep track of largest one and at the end check wheather removing the last element will give me maximum or adding the new one\\n        int max =0;\\n        for(int i=0; i<k-1; i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        if(max>nums[k]){\\n            res= max;\\n        }else{\\n            res= nums[k];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430163,
                "title": "java-linear-tc-and-constant-space-solution-beats-100",
                "content": "# Intuition\\nthree cases\\n  1) If len of array is one and k is odd ans is -1, \\n  2) if k is greater than len, ans is max of array\\n  3) else ans is, max of first k - 1 elements of array and then compare this max with k + 1 th element of the array, return whichever is max; \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n       int len = nums.length;\\n       if((k & 1) == 1 && len == 1) return -1;\\n       int limit = k - 1;\\n       if(k > len) limit = len;\\n\\n       int max = 0;\\n       for(int i = 0;i < limit;i++){\\n           max = Math.max(max, nums[i]);\\n       } \\n       if(k < len)\\n        max = Math.max(max, nums[k]);\\n       \\n       return max;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n       int len = nums.length;\\n       if((k & 1) == 1 && len == 1) return -1;\\n       int limit = k - 1;\\n       if(k > len) limit = len;\\n\\n       int max = 0;\\n       for(int i = 0;i < limit;i++){\\n           max = Math.max(max, nums[i]);\\n       } \\n       if(k < len)\\n        max = Math.max(max, nums[k]);\\n       \\n       return max;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386818,
                "title": "c-greedy",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n      \\n        int maxi=-1;\\n        int n= nums.size();\\n        if(n==1 && k%2!=0) return -1;\\n        \\n        if(k==0) return nums[0];\\n        for(int i=0;i<n;i++){\\n            if(k==1){\\n               if(maxi==-1 && i+1==n) return -1;\\n               if(i+1==n) return maxi;\\n               return max(maxi,nums[i+1]);\\n            }\\n            maxi=max(maxi,nums[i]);\\n            k--;\\n        }\\n        return maxi;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n      \\n        int maxi=-1;\\n        int n= nums.size();\\n        if(n==1 && k%2!=0) return -1;\\n        \\n        if(k==0) return nums[0];\\n        for(int i=0;i<n;i++){\\n            if(k==1){\\n               if(maxi==-1 && i+1==n) return -1;\\n               if(i+1==n) return maxi;\\n               return max(maxi,nums[i+1]);\\n            }\\n            maxi=max(maxi,nums[i]);\\n            k--;\\n        }\\n        return maxi;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345354,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n                std::ios_base::sync_with_stdio(0); std::cin.tie(0); std::cout.tie(0);\\n        if(nums.size()==1 && k%2)\\n        return  -1;\\n        if(!k)return nums[0];\\n        int res = INT_MIN ,x=k; \\n        if(k>nums.size())\\n        return *max_element(nums.begin(),nums.end());\\n         k--;\\n        int i=0,m1=INT_MIN;\\n        while(k--)\\n        {\\n           m1=max(nums[i],m1);\\n           i++;\\n        }\\n        \\n        return max(m1,nums[x]);\\n       \\n         \\n \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n                std::ios_base::sync_with_stdio(0); std::cin.tie(0); std::cout.tie(0);\\n        if(nums.size()==1 && k%2)\\n        return  -1;\\n        if(!k)return nums[0];\\n        int res = INT_MIN ,x=k; \\n        if(k>nums.size())\\n        return *max_element(nums.begin(),nums.end());\\n         k--;\\n        int i=0,m1=INT_MIN;\\n        while(k--)\\n        {\\n           m1=max(nums[i],m1);\\n           i++;\\n        }\\n        \\n        return max(m1,nums[x]);\\n       \\n         \\n \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3342418,
                "title": "c-code-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n        // Handling Edge Cases\\n        //  K is odd ans size is 1 then not enough options\\n        if(nums.size()==1 && k%2) return -1;\\n        \\n        // Only 1 attempt given so nums[1] is at the top of pile\\n        else if(k==1) return nums[1];\\n\\n        // No attempts given so nums[0] is at the top of pile\\n        else if(k==0) return nums[0];\\n\\n        else\\n        {\\n             // 1 2 3 4 5 6 ... k-1   k k+1 k+2 ....N\\n            // Now at the kth removal either remove kth element so k+1 becomes max or return the max element from the top of \\n            // priority queue\\n\\n            if(nums.size() >= k) {priority_queue<int> pq(nums.begin(),nums.begin()+k-1);return max(pq.top(),nums[k]);\\n\\n            // Else you have all elements at your disposal so return amx element\\n            else { priority_queue<int>pq1(nums.begin(),nums.end()); return pq1.top();}\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n        // Handling Edge Cases\\n        //  K is odd ans size is 1 then not enough options\\n        if(nums.size()==1 && k%2) return -1;\\n        \\n        // Only 1 attempt given so nums[1] is at the top of pile\\n        else if(k==1) return nums[1];\\n\\n        // No attempts given so nums[0] is at the top of pile\\n        else if(k==0) return nums[0];\\n\\n        else\\n        {\\n             // 1 2 3 4 5 6 ... k-1   k k+1 k+2 ....N\\n            // Now at the kth removal either remove kth element so k+1 becomes max or return the max element from the top of \\n            // priority queue\\n\\n            if(nums.size() >= k) {priority_queue<int> pq(nums.begin(),nums.begin()+k-1);return max(pq.top(),nums[k]);\\n\\n            // Else you have all elements at your disposal so return amx element\\n            else { priority_queue<int>pq1(nums.begin(),nums.end()); return pq1.top();}\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335600,
                "title": "maximum-top-using-priority-queue",
                "content": "# Intuition\\nfind maximum of first  k-1 elements.\\nCompare maximum of first k-1 elements with nums[k] as there are two options available either we can remove kth element or add maximum from k-1.\\n\\nIf number of steps is greater than nums size just return maximum of nums\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n       if(nums.size()==1&&k%2!=0)return -1;\\n       if(nums.size()==1&&k%2==0)return nums[0];\\n       if(k==1)return nums[1];\\n       if(k==0)return nums[0];\\n        priority_queue<int> pq;\\n\\n        \\n        \\n\\n        if(k>nums.size()){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i]);\\n            }\\n            return pq.top();\\n        }else{\\n          for(int i=0;i<k-1;i++){\\n            \\n            pq.push(nums[i]);\\n        }\\n        int b=pq.top();\\n        if(nums[k]>b){\\n            return nums[k];\\n        }else{\\n          return b;\\n        }\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n       if(nums.size()==1&&k%2!=0)return -1;\\n       if(nums.size()==1&&k%2==0)return nums[0];\\n       if(k==1)return nums[1];\\n       if(k==0)return nums[0];\\n        priority_queue<int> pq;\\n\\n        \\n        \\n\\n        if(k>nums.size()){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i]);\\n            }\\n            return pq.top();\\n        }else{\\n          for(int i=0;i<k-1;i++){\\n            \\n            pq.push(nums[i]);\\n        }\\n        int b=pq.top();\\n        if(nums[k]>b){\\n            return nums[k];\\n        }else{\\n          return b;\\n        }\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331100,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(size(nums)==1 && k%2==1){\\n            return -1;\\n        }\\n        if(k<=1){\\n            return nums[k];\\n        }\\n        int res=0;\\n        for(int i=0;i< min(k+1,static_cast<int>(size(nums)));i++)\\n            if(i!=k-1)\\n                res=max(res,nums[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(size(nums)==1 && k%2==1){\\n            return -1;\\n        }\\n        if(k<=1){\\n            return nums[k];\\n        }\\n        int res=0;\\n        for(int i=0;i< min(k+1,static_cast<int>(size(nums)));i++)\\n            if(i!=k-1)\\n                res=max(res,nums[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327967,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nif length of nums is 1:\\n\\tif k is odd, the nums will be empty, return -1\\n\\tif k is even, return first element\\nif k is greater than or equal to length of nums:\\n\\tthe last action must be putting the maximum remove element to the nums\\nif k is less than length of nums:\\n\\twe have two choices:\\n\\t\\t1. remove first k element, top of nums is kth element\\n\\t\\t2. putting the maximum remove element (first k element) to the nums\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            if k % 2 == 0: return nums[0]\\n            return -1\\n        if k >= len(nums):\\n            if k == len(nums):\\n                return max(nums[:k-1])\\n            return max(nums)\\n        return max(nums[k], max(nums[:k-1]) if k > 1 else 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\n\\'\\'\\'\\nif length of nums is 1:\\n\\tif k is odd, the nums will be empty, return -1\\n\\tif k is even, return first element\\nif k is greater than or equal to length of nums:\\n\\tthe last action must be putting the maximum remove element to the nums\\nif k is less than length of nums:\\n\\twe have two choices:\\n\\t\\t1. remove first k element, top of nums is kth element\\n\\t\\t2. putting the maximum remove element (first k element) to the nums\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            if k % 2 == 0: return nums[0]\\n            return -1\\n        if k >= len(nums):\\n            if k == len(nums):\\n                return max(nums[:k-1])\\n            return max(nums)\\n        return max(nums[k], max(nums[:k-1]) if k > 1 else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316544,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int len=min(k-1,n);\\n        int max_ele=-1;\\n        for(int i=0;i<len;i++)\\n        {\\n            max_ele=max(max_ele,nums[i]);\\n        }\\n        if(k>=nums.size())\\n        {\\n            if(nums.size()==1)\\n            {\\n                if(k%2!=0)\\n                {\\n                    return -1;\\n                }\\n            }\\n            return max_ele;\\n        }\\n        if(nums[k]>max_ele)\\n        {\\n            return nums[k];\\n        }\\n        return max_ele;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int len=min(k-1,n);\\n        int max_ele=-1;\\n        for(int i=0;i<len;i++)\\n        {\\n            max_ele=max(max_ele,nums[i]);\\n        }\\n        if(k>=nums.size())\\n        {\\n            if(nums.size()==1)\\n            {\\n                if(k%2!=0)\\n                {\\n                    return -1;\\n                }\\n            }\\n            return max_ele;\\n        }\\n        if(nums[k]>max_ele)\\n        {\\n            return nums[k];\\n        }\\n        return max_ele;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311225,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int ans = -1, n = nums.size();\\n        n = min(n, k - 1);\\n        for(int i = 0; i < n; i++) {\\n            ans = max(ans, nums[i]);\\n        }\\n        if(nums.size() == 1 && k % 2 == 1) return -1;\\n        if(k < nums.size()) ans = max(ans, nums[k]);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maximumTop(nums []int, k int) int {\\n    var ans, n int = -1, len(nums)\\n    if k - 1 < n {n = k - 1}\\n    for i := 0; i < n; i++ {\\n        if nums[i] > ans {ans = nums[i]}\\n    }\\n    if len(nums) == 1 && k % 2 == 1 {return -1}\\n    if k < len(nums) && nums[k] > ans {\\n        ans = nums[k]\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int ans = -1, n = nums.size();\\n        n = min(n, k - 1);\\n        for(int i = 0; i < n; i++) {\\n            ans = max(ans, nums[i]);\\n        }\\n        if(nums.size() == 1 && k % 2 == 1) return -1;\\n        if(k < nums.size()) ans = max(ans, nums[k]);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maximumTop(nums []int, k int) int {\\n    var ans, n int = -1, len(nums)\\n    if k - 1 < n {n = k - 1}\\n    for i := 0; i < n; i++ {\\n        if nums[i] > ans {ans = nums[i]}\\n    }\\n    if len(nums) == 1 && k % 2 == 1 {return -1}\\n    if k < len(nums) && nums[k] > ans {\\n        ans = nums[k]\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310385,
                "title": "java-solution-2-approaches",
                "content": "# code approach 1\\n- check for all index\\'s whether we can get the index at the top(basically this is hint1)\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int maxi=0;\\n        int i,n=nums.length;\\n        boolean visited[]=new boolean[n];\\n        Arrays.fill(visited,false);\\n        boolean flag=false;\\n        if(n==1) return k%2==0?nums[0]:-1;\\n        for(i=0;i<n;i++)\\n        {\\n            if(k-i-1>0)\\n            {\\n                visited[i]=true;\\n                flag=true;\\n            }\\n            else if(k==i && k!=n)\\n            {\\n                visited[i]=true;\\n                flag=true;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(visited[i])\\n            {\\n                maxi=Math.max(maxi,nums[i]);\\n            }\\n        }\\n        return flag?maxi:-1;\\n    }\\n}\\n```\\n# code approach 2\\n- finding the max element from first k-1 elelment or len -1 if len is less than k\\n- check for if we dont have to put back Max out of k-1 element\\n- credit @manishs747\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int maxi=0;\\n        int i,n=nums.length;\\n        boolean visited[]=new boolean[n];\\n        Arrays.fill(visited,false);\\n        boolean flag=false;\\n        if(n==1) return k%2==0?nums[0]:-1;\\n        for(i=0;i<Math.min(n,k-1);i++)\\n        {\\n            maxi=Math.max(maxi,nums[i]);   \\n        }\\n        if(k<n)\\n            maxi=Math.max(maxi,nums[k]);\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int maxi=0;\\n        int i,n=nums.length;\\n        boolean visited[]=new boolean[n];\\n        Arrays.fill(visited,false);\\n        boolean flag=false;\\n        if(n==1) return k%2==0?nums[0]:-1;\\n        for(i=0;i<n;i++)\\n        {\\n            if(k-i-1>0)\\n            {\\n                visited[i]=true;\\n                flag=true;\\n            }\\n            else if(k==i && k!=n)\\n            {\\n                visited[i]=true;\\n                flag=true;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(visited[i])\\n            {\\n                maxi=Math.max(maxi,nums[i]);\\n            }\\n        }\\n        return flag?maxi:-1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int maxi=0;\\n        int i,n=nums.length;\\n        boolean visited[]=new boolean[n];\\n        Arrays.fill(visited,false);\\n        boolean flag=false;\\n        if(n==1) return k%2==0?nums[0]:-1;\\n        for(i=0;i<Math.min(n,k-1);i++)\\n        {\\n            maxi=Math.max(maxi,nums[i]);   \\n        }\\n        if(k<n)\\n            maxi=Math.max(maxi,nums[k]);\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280788,
                "title": "dart-o-n-explained-condition-checks",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n  int maximumTop(List<int> nums, int k) {\\n    int n = nums.length;\\n    // If length only 1, we must repeat the remove and add back process\\n    // So check checked isEven to return answer or -1\\n    if (n == 1) {\\n        if (k.isEven) {\\n            return nums[0];\\n        }\\n        return -1;\\n    }\\n    int maxi = 0;\\n    // Possible max answer range can be till k - 1\\n    // Means remove k - 1 elements, and put the maximum back\\n    for (var i = 0; i < min(n, k-1); i++) {\\n      maxi = max(maxi, nums[i]);\\n    }\\n\\n    // If remove until k, k position num also can be answer\\n    if (k < n) {\\n        maxi = max(maxi, nums[k]);\\n    }\\n      \\n    return maxi;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maximumTop(List<int> nums, int k) {\\n    int n = nums.length;\\n    // If length only 1, we must repeat the remove and add back process\\n    // So check checked isEven to return answer or -1\\n    if (n == 1) {\\n        if (k.isEven) {\\n            return nums[0];\\n        }\\n        return -1;\\n    }\\n    int maxi = 0;\\n    // Possible max answer range can be till k - 1\\n    // Means remove k - 1 elements, and put the maximum back\\n    for (var i = 0; i < min(n, k-1); i++) {\\n      maxi = max(maxi, nums[i]);\\n    }\\n\\n    // If remove until k, k position num also can be answer\\n    if (k < n) {\\n        maxi = max(maxi, nums[k]);\\n    }\\n      \\n    return maxi;\\n  }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1707547,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1793633,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1745933,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2039779,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2025425,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2009004,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1946264,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1876099,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1749064,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1748560,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1707547,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1793633,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1745933,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2039779,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2025425,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2009004,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1946264,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1876099,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1749064,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1748560,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Points in an Archery Competition",
        "question_content": "<p>Alice and Bob are opponents in an archery competition. The competition has set the following rules:</p>\n\n<ol>\n\t<li>Alice first shoots <code>numArrows</code> arrows and then Bob shoots <code>numArrows</code> arrows.</li>\n\t<li>The points are then calculated as follows:\n\t<ol>\n\t\t<li>The target has integer scoring sections ranging from <code>0</code> to <code>11</code> <strong>inclusive</strong>.</li>\n\t\t<li>For <strong>each</strong> section of the target with score <code>k</code> (in between <code>0</code> to <code>11</code>), say Alice and Bob have shot <code>a<sub>k</sub></code> and <code>b<sub>k</sub></code> arrows on that section respectively. If <code>a<sub>k</sub> &gt;= b<sub>k</sub></code>, then Alice takes <code>k</code> points. If <code>a<sub>k</sub> &lt; b<sub>k</sub></code>, then Bob takes <code>k</code> points.</li>\n\t\t<li>However, if <code>a<sub>k</sub> == b<sub>k</sub> == 0</code>, then <strong>nobody</strong> takes <code>k</code> points.</li>\n\t</ol>\n\t</li>\n</ol>\n\n<ul>\n\t<li>\n\t<p>For example, if Alice and Bob both shot <code>2</code> arrows on the section with score <code>11</code>, then Alice takes <code>11</code> points. On the other hand, if Alice shot <code>0</code> arrows on the section with score <code>11</code> and Bob shot <code>2</code> arrows on that same section, then Bob takes <code>11</code> points.</p>\n\t</li>\n</ul>\n\n<p>You are given the integer <code>numArrows</code> and an integer array <code>aliceArrows</code> of size <code>12</code>, which represents the number of arrows Alice shot on each scoring section from <code>0</code> to <code>11</code>. Now, Bob wants to <strong>maximize</strong> the total number of points he can obtain.</p>\n\n<p>Return <em>the array </em><code>bobArrows</code><em> which represents the number of arrows Bob shot on <strong>each</strong> scoring section from </em><code>0</code><em> to </em><code>11</code>. The sum of the values in <code>bobArrows</code> should equal <code>numArrows</code>.</p>\n\n<p>If there are multiple ways for Bob to earn the maximum total points, return <strong>any</strong> one of them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/24/ex1.jpg\" style=\"width: 600px; height: 120px;\" />\n<pre>\n<strong>Input:</strong> numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\n<strong>Output:</strong> [0,0,0,0,1,1,0,0,1,2,3,1]\n<strong>Explanation:</strong> The table above shows how the competition is scored. \nBob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\nIt can be shown that Bob cannot obtain a score higher than 47 points.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/24/ex2new.jpg\" style=\"width: 600px; height: 117px;\" />\n<pre>\n<strong>Input:</strong> numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n<strong>Output:</strong> [0,0,0,0,0,0,0,0,1,1,1,0]\n<strong>Explanation:</strong> The table above shows how the competition is scored.\nBob earns a total point of 8 + 9 + 10 = 27.\nIt can be shown that Bob cannot obtain a score higher than 27 points.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numArrows &lt;= 10<sup>5</sup></code></li>\n\t<li><code>aliceArrows.length == bobArrows.length == 12</code></li>\n\t<li><code>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows</code></li>\n\t<li><code>sum(aliceArrows[i]) == numArrows</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1865571,
                "title": "c-python-3-solutions-top-down-dp-backtracking-bit-masking-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP with Backtrack**\\n- Step 1: We can DP to find the maximum score Bob can get.\\n\\t- Let `dp(k, numArrows)` is the maximum score Bob can get if we compute sections from `[k...11]` and `numArrows` arrows.\\n\\t- We choose the maximum score between 2 following cases:\\n\\t\\t- If Bob **LOSE** then `dp[k][numArrows] = dp[k+1][numArrows]`. It means no score earn, we use no arrows.\\n\\t\\t- If Bob **WIN** only if `numArrows` is greater than `aliceArrows[k]` then `dp[k][numArrows] = dp[k+1][numArrows-aliceArrows[k]-1] + k`. It means we earn `k` score and use `aliceArrows[k] + 1` arrows.\\n- Step 2: Backtracking to see in section `k`, Bob win or lose.\\n\\n<iframe src=\"https://leetcode.com/playground/FCQ5yPc3/shared\" frameBorder=\"0\" width=\"100%\" height=\"650\"></iframe>\\n\\n**Complexity**\\n- Time: `O(2 * 12 * numArrows)`, where `numArrows <= 10^5`.\\n- Space: `O(12 * numArrows)`\\n- Explain: There are total `12 * numArrows` states, each state need at most `2` case (Lose or Win) to compute.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Backtracking**\\n- For each section `[0..11]`, we have 2 choices: Bob wins or loses, so there are up to `2^12` options.\\n- Therefore we can do normal backtracking to check all possible options, and update the best option if we found.\\n```python\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.bestScore = 0\\n        self.bestBobArrows = None\\n        \\n        def backtracking(k, remainArrows, score, bobArrows):\\n            if k == 12:\\n                if score > self.bestScore:\\n                    self.bestScore = score\\n                    self.bestBobArrows = bobArrows[::]\\n                return\\n            \\n            backtracking(k+1, remainArrows, score, bobArrows)  # Bob loses\\n            \\n            # Bob wins\\n            arrowsNeeded = aliceArrows[k] + 1\\n            if remainArrows >= arrowsNeeded:\\n                old = bobArrows[k]\\n                bobArrows[k] = arrowsNeeded  # set new\\n                backtracking(k+1, remainArrows - arrowsNeeded, score + k, bobArrows)\\n                bobArrows[k] = old  # backtrack\\n                \\n        backtracking(0, numArrows, 0, [0] * 12)\\n\\t\\t# In case of having remain arrows then it means in all sections Bob always win \\n        # then we can distribute the remain to any section, here we simple choose first section.\\n        self.bestBobArrows[0] += numArrows - sum(self.bestBobArrows)\\n        return self.bestBobArrows\\n```\\n**Complexity**\\n- Time: `O(2 ^ 12)` in avg. But in the worst case it always update the `bestScore`, so it does copy the whole `bobArrows`, so it takes `O(12 * 2^12)` in time complexity.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bit Masking**\\n- Instead of using backtracking, we can generate all possible options by using bit masking.\\n- Let `mask` represent the option, Bob wins in section `k` only if `k_th` bit of `mask` is `1`.\\n```python\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        def test(mask, remainArrows):\\n            score = 0\\n            bobArrows = [0] * 12\\n            for k in range(12):\\n                if (mask >> k) & 1:\\n                    arrowsNeeded = aliceArrows[k] + 1\\n                    if remainArrows < arrowsNeeded: return 0, []\\n                    score += k\\n                    bobArrows[k] = arrowsNeeded\\n                    remainArrows -= arrowsNeeded\\n                    \\n\\t\\t\\t# In case of having remain arrows then it means in all sections Bob always win \\n\\t\\t\\t# then we can distribute the remain to any section, here we simple choose first section.\\n            bobArrows[0] += remainArrows\\n            return score, bobArrows\\n        \\n        bestScore = 0\\n        bestBobArrows = None\\n        for mask in range(1 << 12):\\n            score, bobArrows = test(mask, numArrows)\\n            if score > bestScore:\\n                bestScore = score\\n                bestBobArrows = bobArrows\\n        return bestBobArrows\\n```\\n**Complexity**\\n- Time: `O(12 * 2 ^ 12)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.bestScore = 0\\n        self.bestBobArrows = None\\n        \\n        def backtracking(k, remainArrows, score, bobArrows):\\n            if k == 12:\\n                if score > self.bestScore:\\n                    self.bestScore = score\\n                    self.bestBobArrows = bobArrows[::]\\n                return\\n            \\n            backtracking(k+1, remainArrows, score, bobArrows)  # Bob loses\\n            \\n            # Bob wins\\n            arrowsNeeded = aliceArrows[k] + 1\\n            if remainArrows >= arrowsNeeded:\\n                old = bobArrows[k]\\n                bobArrows[k] = arrowsNeeded  # set new\\n                backtracking(k+1, remainArrows - arrowsNeeded, score + k, bobArrows)\\n                bobArrows[k] = old  # backtrack\\n                \\n        backtracking(0, numArrows, 0, [0] * 12)\\n\\t\\t# In case of having remain arrows then it means in all sections Bob always win \\n        # then we can distribute the remain to any section, here we simple choose first section.\\n        self.bestBobArrows[0] += numArrows - sum(self.bestBobArrows)\\n        return self.bestBobArrows\\n```\n```python\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        def test(mask, remainArrows):\\n            score = 0\\n            bobArrows = [0] * 12\\n            for k in range(12):\\n                if (mask >> k) & 1:\\n                    arrowsNeeded = aliceArrows[k] + 1\\n                    if remainArrows < arrowsNeeded: return 0, []\\n                    score += k\\n                    bobArrows[k] = arrowsNeeded\\n                    remainArrows -= arrowsNeeded\\n                    \\n\\t\\t\\t# In case of having remain arrows then it means in all sections Bob always win \\n\\t\\t\\t# then we can distribute the remain to any section, here we simple choose first section.\\n            bobArrows[0] += remainArrows\\n            return score, bobArrows\\n        \\n        bestScore = 0\\n        bestBobArrows = None\\n        for mask in range(1 << 12):\\n            score, bobArrows = test(mask, numArrows)\\n            if score > bestScore:\\n                bestScore = score\\n                bestBobArrows = bobArrows\\n        return bestBobArrows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865563,
                "title": "c-backtracking-list-of-problems",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    vector<int> ans;\\n    int target = 0;\\n    vector<int> maximumBobPoints(int numArrows, vector<int> &aliceArrows)\\n    {\\n        vector<int> res(12, 0);\\n        rec(11, numArrows, aliceArrows, 0, res);\\n        return ans;\\n    }\\n    void rec(int n, int numArrows, vector<int> &aliceArrow, int sum, vector<int> res)\\n    {\\n        if (n == -1 || numArrows <= 0)\\n        {\\n            if (sum > target)\\n            {\\n                target = sum;\\n                if (numArrows > 0)\\n                {\\n                    res[0] += numArrows;\\n                }\\n                ans = res;\\n            }\\n            return;\\n        }\\n        int req = aliceArrow[n] + 1;\\n        if (req <= numArrows)\\n        {\\n            res[n] = req;\\n            rec(n - 1, numArrows - req, aliceArrow, sum + n, res);\\n            res[n] = 0;\\n        }\\n        rec(n - 1, numArrows, aliceArrow, sum, res);\\n        return;\\n    }\\n};\\n```\\n\\nList of similar problems - \\n**Decreasing order of frequency (asked in interviews)**\\nhttps://leetcode.com/problems/word-search/\\nhttps://leetcode.com/problems/generate-parentheses/\\nhttps://leetcode.com/problems/word-search-ii/\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/\\nhttps://leetcode.com/problems/optimal-account-balancing/\\nhttps://leetcode.com/problems/n-queens/\\nhttps://leetcode.com/problems/word-break-ii/\\nhttps://leetcode.com/problems/combination-sum/\\nhttps://leetcode.com/problems/sudoku-solver/\\nhttps://leetcode.com/problems/subsets/\\nhttps://leetcode.com/problems/permutations/\\nhttps://leetcode.com/problems/restore-ip-addresses/\\nhttps://leetcode.com/problems/combination-sum-ii/\\nhttps://leetcode.com/problems/all-paths-from-source-to-target/\\nhttps://leetcode.com/problems/increasing-subsequences/",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<int> ans;\\n    int target = 0;\\n    vector<int> maximumBobPoints(int numArrows, vector<int> &aliceArrows)\\n    {\\n        vector<int> res(12, 0);\\n        rec(11, numArrows, aliceArrows, 0, res);\\n        return ans;\\n    }\\n    void rec(int n, int numArrows, vector<int> &aliceArrow, int sum, vector<int> res)\\n    {\\n        if (n == -1 || numArrows <= 0)\\n        {\\n            if (sum > target)\\n            {\\n                target = sum;\\n                if (numArrows > 0)\\n                {\\n                    res[0] += numArrows;\\n                }\\n                ans = res;\\n            }\\n            return;\\n        }\\n        int req = aliceArrow[n] + 1;\\n        if (req <= numArrows)\\n        {\\n            res[n] = req;\\n            rec(n - 1, numArrows - req, aliceArrow, sum + n, res);\\n            res[n] = 0;\\n        }\\n        rec(n - 1, numArrows, aliceArrow, sum, res);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865823,
                "title": "java-simple-readable-backtracking-solution-with-description",
                "content": "Your goal is to get the maximum points.\\nSo, at each point, you have 2 choices\\n1. Fire more arrow than Alice. 1 arrow more than Alice\\'s arrows is enough.  OR\\n2. Don\\'t use any arrow on this point so, we can later utilize it for better points.\\n\\n**While this problem can have multiple solutions, the maximum points Bob can get is always unique.**\\n\\ne.g. \\nYou have 2 arrows.\\nAlice fired 1 arrow on point 1 and 1 arrow on point 11.  Total point: 12.\\nNow, you can fire 2 arrows on point 11 to gain 11 points and win the game because it will make Alice\\'s point to 1 and Bob\\'s point to 11. But **remember Your goal is not to reduce Alice\\'s point but to maximize your points.**\\n\\nSo, instead of using your 2 arrows on point 11, you should have used it for point 10 and 9, total points = 19.\\n\\n**Solution:**\\nLet\\'s start with the max point = 11, and apply the above two conditions. Move to the next point with the remaining arrow and use the same process untill either you reached to the end or you don\\'t have any more arrows left.  If you have reached to the end and still have arrows left, they are useless because you couldn\\'t gain more points. You can add those arrows to any point. I\\'m adding them to 0 point.\\n\\n\\n\\t   class Solution {\\n\\t\\t\\tint bobPoint = 0;\\n\\t\\t\\tint[] maxbob = new int[12];\\n\\t\\t\\tpublic int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n\\t\\t\\t\\tint[] bob = new int[12];\\n\\t\\t\\t\\tcalculate(aliceArrows, bob, 11, numArrows, 0);  //Start with max point that is 11\\n\\t\\t\\t\\treturn maxbob;\\n\\t\\t\\t}\\n\\t\\t\\tpublic void calculate(int[] alice, int[] bob, int index, int remainArr, int point) {\\n\\t\\t\\t\\tif(index < 0 || remainArr <= 0) {\\n\\t\\t\\t\\t\\tif(remainArr > 0)\\n\\t\\t\\t\\t\\t\\tbob[0] += remainArr;\\n\\t\\t\\t\\t\\tif(point > bobPoint) { // Update the max points and result output\\n\\t\\t\\t\\t\\t\\tbobPoint = point;\\n\\t\\t\\t\\t\\t\\tmaxbob = bob.clone();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//part 1: assign 1 more arrow than alice\\n\\t\\t\\t\\tif(remainArr >= alice[index]+1) {\\n\\t\\t\\t\\t\\tbob[index] = alice[index] + 1;\\n\\t\\t\\t\\t\\tcalculate(alice, bob, index-1, remainArr-(alice[index]+1), point + index);\\n\\t\\t\\t\\t\\tbob[index] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//part 2: assign no arrow and move to next point\\n\\t\\t\\t\\tcalculate(alice, bob, index-1, remainArr, point);\\n\\t\\t\\t\\tbob[index] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\nSince we have 12 states and at each state we make 2 decisions. So, total Time complexity will be **O(2^12)**.",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\t\\tint bobPoint = 0;\\n\\t\\t\\tint[] maxbob = new int[12];\\n\\t\\t\\tpublic int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n\\t\\t\\t\\tint[] bob = new int[12];\\n\\t\\t\\t\\tcalculate(aliceArrows, bob, 11, numArrows, 0);  //Start with max point that is 11\\n\\t\\t\\t\\treturn maxbob;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1865592,
                "title": "c-generating-all-possible-sequences-easy",
                "content": "**Intuition:** I observed that since there are 12 rounds, there can be at max 2^12 permutations on either bob wins *ith* round or not. Since 2^12 isnt that big of a number that could give TLE, we can generate all possible sequences. Also we can optimally win a round from Alice by just having 1 extra arrow in the same section as compared to Alice.\\nFor each possible sequence, we see if this sequence has a greater score, if yes then we update the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxscore; \\n    vector<int> ans;\\n    \\n    void helper(vector<int> &bob, int i, vector<int>& alice, int remarrows, int score)\\n    {\\n        if(i == -1  or  remarrows <= 0)\\n        {\\n            if(score >= maxscore)\\n            {\\n                maxscore = score; \\n                ans = bob; \\n            }\\n            return; \\n        }\\n        \\n        helper(bob, i-1, alice, remarrows, score);\\n        if(remarrows > alice[i])\\n        {\\n            bob[i] = alice[i] + 1;\\n            remarrows -= (alice[i] + 1);\\n            score += i; \\n            helper(bob, i-1, alice, remarrows, score);\\n            bob[i] = 0;\\n        } \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        maxscore = INT_MIN; \\n        helper(bob, 11, aliceArrows, numArrows, 0);\\n        \\n        int arrows_used = 0; \\n        for(int a : ans)\\n            arrows_used += a; \\n        if(arrows_used < numArrows)\\n            ans[0] += (numArrows - arrows_used);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxscore; \\n    vector<int> ans;\\n    \\n    void helper(vector<int> &bob, int i, vector<int>& alice, int remarrows, int score)\\n    {\\n        if(i == -1  or  remarrows <= 0)\\n        {\\n            if(score >= maxscore)\\n            {\\n                maxscore = score; \\n                ans = bob; \\n            }\\n            return; \\n        }\\n        \\n        helper(bob, i-1, alice, remarrows, score);\\n        if(remarrows > alice[i])\\n        {\\n            bob[i] = alice[i] + 1;\\n            remarrows -= (alice[i] + 1);\\n            score += i; \\n            helper(bob, i-1, alice, remarrows, score);\\n            bob[i] = 0;\\n        } \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        maxscore = INT_MIN; \\n        helper(bob, 11, aliceArrows, numArrows, 0);\\n        \\n        int arrows_used = 0; \\n        for(int a : ans)\\n            arrows_used += a; \\n        if(arrows_used < numArrows)\\n            ans[0] += (numArrows - arrows_used);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865714,
                "title": "java-knapsack-0-1",
                "content": "This problem can be simplified to knapsack, where\\n```\\nwt[i] = aliceArrows[i]+1 and profit[i]=i\\n```\\nand so,\\n```\\ndp[i][j] =  Math.max(dp[i-1][j],  dp[i-1][j-(aliceArrows[i-1]+1)]+(i-1))\\n```\\nTo trace back in knapsack,  \\n```\\n(dp[i][j] == dp[i-1][j]) = > coming from pervious, not selected\\nelse the item is selected and so ans[i] = aliceArrows[i]+1\\n```\\n\\nComplexity - O(NW) `W => numArraows, N=>aliceArrows.length(constant 12 in this case)`\\n```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[][] dp = new int[13][numArrows+1];\\n        \\n        for(int i=0; i<=12; i++){\\n            for(int j=0; j<=numArrows; j++){\\n                if(i==0 || j==0){\\n                    dp[i][j] = 0;\\n                } else if(j>=(aliceArrows[i-1]+1)){\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-(aliceArrows[i-1]+1)]+(i-1));\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int[] ans = new int[12];\\n        int result = dp[12][numArrows];\\n        int total = 0; // to count total arrows used by bob\\n        for (int i=12, j=numArrows; i > 0 && result > 0; i--) {\\n            if (result == dp[i-1][j])\\n                continue;\\n            else {\\n                // This item is included.\\n                ans[i-1] = aliceArrows[i-1]+1;\\n                result -=  (i-1);  // subtracting profit\\n                j -= (aliceArrows[i-1]+1); // subtracting weight\\n                total += aliceArrows[i-1]+1; \\n            }\\n        }\\n        \\n\\t\\t// as bob has to fire numArrows, remaining can be of 0 value\\n        if(total<numArrows){\\n            ans[0] = numArrows-total;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nwt[i] = aliceArrows[i]+1 and profit[i]=i\\n```\n```\\ndp[i][j] =  Math.max(dp[i-1][j],  dp[i-1][j-(aliceArrows[i-1]+1)]+(i-1))\\n```\n```\\n(dp[i][j] == dp[i-1][j]) = > coming from pervious, not selected\\nelse the item is selected and so ans[i] = aliceArrows[i]+1\\n```\n```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[][] dp = new int[13][numArrows+1];\\n        \\n        for(int i=0; i<=12; i++){\\n            for(int j=0; j<=numArrows; j++){\\n                if(i==0 || j==0){\\n                    dp[i][j] = 0;\\n                } else if(j>=(aliceArrows[i-1]+1)){\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-(aliceArrows[i-1]+1)]+(i-1));\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int[] ans = new int[12];\\n        int result = dp[12][numArrows];\\n        int total = 0; // to count total arrows used by bob\\n        for (int i=12, j=numArrows; i > 0 && result > 0; i--) {\\n            if (result == dp[i-1][j])\\n                continue;\\n            else {\\n                // This item is included.\\n                ans[i-1] = aliceArrows[i-1]+1;\\n                result -=  (i-1);  // subtracting profit\\n                j -= (aliceArrows[i-1]+1); // subtracting weight\\n                total += aliceArrows[i-1]+1; \\n            }\\n        }\\n        \\n\\t\\t// as bob has to fire numArrows, remaining can be of 0 value\\n        if(total<numArrows){\\n            ans[0] = numArrows-total;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879220,
                "title": "dfs-with-mask",
                "content": "We just need to search for the best score. Since we have only 11 sections (we can ignore zero), thare are 2 ^ 11 = 2048 total combinations.\\n\\n**C++**\\nWe use `mask` to indicate when Bob shoots into a section. We update `max_mask` when we achieve a better score.\\n\\nFor Bob, it only makes sense to shoot `aliceArrows[k] + 1` arrows to section `k`. Therefore, we can restore the score by only looking at the mask.\\n\\n```cpp\\nint max_points = 0, max_mask = 0;\\nvoid dfs(int k, int numArrows, vector<int>& aliceArrows, int points, int mask) {\\n    if (numArrows >= 0 && points > max_points) {\\n        max_points = points;\\n        max_mask = mask;\\n    }\\n    if (k > 0) {\\n        dfs(k - 1, numArrows - aliceArrows[k] - 1, aliceArrows, points + k, mask + (1 << k));\\n        dfs(k - 1, numArrows, aliceArrows, points, mask);\\n    }\\n}\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    vector<int> res(12);\\n    dfs(11, numArrows, aliceArrows, 0, 0);\\n    for (int k = 11; k > 0; --k) {\\n        if (max_mask & (1 << k)) {\\n            res[k] = aliceArrows[k] + 1;\\n            numArrows -= aliceArrows[k] + 1;\\n        }\\n    }\\n    res[0] = numArrows;\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint max_points = 0, max_mask = 0;\\nvoid dfs(int k, int numArrows, vector<int>& aliceArrows, int points, int mask) {\\n    if (numArrows >= 0 && points > max_points) {\\n        max_points = points;\\n        max_mask = mask;\\n    }\\n    if (k > 0) {\\n        dfs(k - 1, numArrows - aliceArrows[k] - 1, aliceArrows, points + k, mask + (1 << k));\\n        dfs(k - 1, numArrows, aliceArrows, points, mask);\\n    }\\n}\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    vector<int> res(12);\\n    dfs(11, numArrows, aliceArrows, 0, 0);\\n    for (int k = 11; k > 0; --k) {\\n        if (max_mask & (1 << k)) {\\n            res[k] = aliceArrows[k] + 1;\\n            numArrows -= aliceArrows[k] + 1;\\n        }\\n    }\\n    res[0] = numArrows;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865859,
                "title": "o-m-n-dp-solution-getting-tle",
                "content": "Hey LeetCode Admin, kindly check my solution (pasted below). How can this simple O(m * n) \\'DP + answer generation\\' solution get TLE!!! Why do you not specify the Time Limit for the problems along with the test case limits. In my humble opinion, my O(m * n) solution is well under the general Time Limit we have everywhere, which is ~10^8 operations. \\n\\n```\\nclass Solution {\\npublic:\\n  vector<int> maximumBobPoints(int n, vector<int>& a) {\\n    int m = 12;\\n    vector<int> b(m);\\n    vector<vector<int>> dp(m, vector<int>(n + 1));\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j <= n; j++) {\\n        if (!i) {\\n          dp[i][j] = 0;\\n          continue;\\n        }\\n        dp[i][j] = dp[i - 1][j];\\n        if (j > a[i]) {\\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i] - 1] + i);\\n        }\\n      }\\n    }\\n    for (int i = m - 1, j = n; i >= 0; i--) {\\n      if (i == 0) {\\n        b[0] = j;\\n        break;\\n      }\\n      if (dp[i][j] != dp[i - 1][j]) {\\n        b[i] = a[i] + 1;\\n        j -= b[i];\\n      }\\n    }\\n    return b;\\n  }\\n};\\n```\\n\\nI remember this happened to me earlier in some contest as well. In that case, just using 1D DP array, instead of 2D DP table, passed it (basically, I did DP space optimization by reversing the order of inner loop) although theoritically, Time Complexity was still the same. This time it was not possible because I had to generate the answer as well.\\n\\nAfter that contest, I felt so frustrated that I stopped giving the contests here. Now after so long, I felt healed and I gave one yesterday and thought I would now resume giving these contests regularly for fun, (yes! I do enjoy these contests!), but again the same issue has occured :(\\n\\nI request you to please look into this. If you think my solution should\\'ve passed the tests, then please don\\'t affect my ratings, and, I demand 1000 LC coins to compensate for the time waste + frustration caused because of it. If you still don\\'t think my solution should\\'ve passed, please provide a valid reason for it, and how a participant would know about it beforehand (by mentioning the time limit in ms, or whatever).\\n\\nIf no action taken, I could NEVER take part in the contests here again (yes, it hurts) :(\\n\\n**UPDATE**\\nSome are commenting/posting that we had to do some optimizations to get AC(using static array, top-down approach). Personally that\\'s not my style of doing DP problems (unless it\\'s very hard/time-taking for me to implement bottom up). Bottom up feels more elegant to me. Secondly, I can show many of my submissions where I got AC with 2D vector and bottom-up approach on DP problems having similar constraints. The recent one is from yesterday\\'s biweekly contest itself: https://leetcode.com/contest/biweekly-contest-74.. Following is my AC submission for the https://leetcode.com/contest/biweekly-contest-74/problems/minimum-white-tiles-after-covering-with-carpets/:\\n```\\nclass Solution {\\npublic:\\n  int minimumWhiteTiles(string s, int m, int k) {\\n    int n = s.size(), inf = n + 1;\\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, inf));\\n    for (int i = 0; i <= n; i++) {\\n      for (int j = 0; j <= m; j++) {\\n        if (i == 0) {\\n          dp[i][j] = 0;\\n          continue;\\n        }\\n        dp[i][j] = min(j? dp[max(0, i - k)][j - 1]: inf, dp[i - 1][j] + (s[i - 1] - \\'0\\'));\\n      }\\n    }\\n    return dp[n][m];\\n  }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> maximumBobPoints(int n, vector<int>& a) {\\n    int m = 12;\\n    vector<int> b(m);\\n    vector<vector<int>> dp(m, vector<int>(n + 1));\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j <= n; j++) {\\n        if (!i) {\\n          dp[i][j] = 0;\\n          continue;\\n        }\\n        dp[i][j] = dp[i - 1][j];\\n        if (j > a[i]) {\\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i] - 1] + i);\\n        }\\n      }\\n    }\\n    for (int i = m - 1, j = n; i >= 0; i--) {\\n      if (i == 0) {\\n        b[0] = j;\\n        break;\\n      }\\n      if (dp[i][j] != dp[i - 1][j]) {\\n        b[i] = a[i] + 1;\\n        j -= b[i];\\n      }\\n    }\\n    return b;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int minimumWhiteTiles(string s, int m, int k) {\\n    int n = s.size(), inf = n + 1;\\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, inf));\\n    for (int i = 0; i <= n; i++) {\\n      for (int j = 0; j <= m; j++) {\\n        if (i == 0) {\\n          dp[i][j] = 0;\\n          continue;\\n        }\\n        dp[i][j] = min(j? dp[max(0, i - k)][j - 1]: inf, dp[i - 1][j] + (s[i - 1] - \\'0\\'));\\n      }\\n    }\\n    return dp[n][m];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868376,
                "title": "c-bitmask-easy-understanding",
                "content": "Because there are only 12 targets, we can produce any possible hit or skip combinations (2 ^ 12).\\nIf the ith bit in our bitmask is set, Bob will strike the target, and he must hit at least alicearrows[i] + 1 arrows on the ith target to maximise his score.\\nSo, using exactly numArrows arrows, we\\'ll try to determine the maximum score Bob can achieve for the 2 ^ 12 combinations.\\n\\nTime complexity: O((2 ^ 12) * 12)\\nSpace complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numarrows, vector<int>& alicearrows) {\\n        \\n        int n(1<<12), maxscore(0);\\n        vector<int> res;\\n        \\n        for(int mask = 1; mask < n; mask++) {\\n            \\n            int arrowsleft(numarrows),score(0);\\n            vector<int> bob(12,0);\\n\\t\\t\\t\\n            // checking for all the targets\\n            for(int i = 0; i <= 11; i++) {\\n\\t\\t\\t//for checking the bit is set or not at that mask\\n                if(mask & (1 << i)) { \\n\\t\\t\\t\\t\\n                    int arrowsneeded = alicearrows[i] + 1;\\n\\t\\t\\t\\t\\t// If the number of arrows required to reach the current target\\n\\t\\t\\t\\t\\t// exceeds the number of arrows available,\\n\\t\\t\\t\\t\\t// then\\xA0this combination will not result in a right answer, so we will break.\\n                    if(arrowsneeded > arrowsleft) {  \\n                        score = -1;\\n                        break;\\n                    }\\n                    score += i;\\n\\t\\t\\t\\t\\t// bob[i] is arrows Bob must hit to achieve this score\\n                    bob[i] = arrowsneeded;\\n                    arrowsleft -= arrowsneeded;  \\n                }\\n            }\\n            \\n            if(score > maxscore) {\\n\\t\\t\\t// in case any arrows are left after hitting targets, we can add it to any target\\n                if(arrowsleft) bob[0] += arrowsleft;\\n                maxscore = score;\\n                res = bob;\\n            } \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numarrows, vector<int>& alicearrows) {\\n        \\n        int n(1<<12), maxscore(0);\\n        vector<int> res;\\n        \\n        for(int mask = 1; mask < n; mask++) {\\n            \\n            int arrowsleft(numarrows),score(0);\\n            vector<int> bob(12,0);\\n\\t\\t\\t\\n            // checking for all the targets\\n            for(int i = 0; i <= 11; i++) {\\n\\t\\t\\t//for checking the bit is set or not at that mask\\n                if(mask & (1 << i)) { \\n\\t\\t\\t\\t\\n                    int arrowsneeded = alicearrows[i] + 1;\\n\\t\\t\\t\\t\\t// If the number of arrows required to reach the current target\\n\\t\\t\\t\\t\\t// exceeds the number of arrows available,\\n\\t\\t\\t\\t\\t// then\\xA0this combination will not result in a right answer, so we will break.\\n                    if(arrowsneeded > arrowsleft) {  \\n                        score = -1;\\n                        break;\\n                    }\\n                    score += i;\\n\\t\\t\\t\\t\\t// bob[i] is arrows Bob must hit to achieve this score\\n                    bob[i] = arrowsneeded;\\n                    arrowsleft -= arrowsneeded;  \\n                }\\n            }\\n            \\n            if(score > maxscore) {\\n\\t\\t\\t// in case any arrows are left after hitting targets, we can add it to any target\\n                if(arrowsleft) bob[0] += arrowsleft;\\n                maxscore = score;\\n                res = bob;\\n            } \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866029,
                "title": "c-dp-top-down-approach-easy-100-faster-space-o-n-time-o-n",
                "content": "**Identify Type of dp**->\\nLogic is similar to Knapsack where you are given capacity and Array which can be treated as weight array.\\n\\n**Goal** -> you need to maximize profit ,where profit will be index if you pick weight at index.\\n\\n**Approach**->\\n* First Compute Dp Array \\n```\\n\\t\\tfirst choice is\\n \\t\\t\\t\\tYou can only pick weight at index, when weight[index]<Your capacity\\n\\t\\t\\t\\tso, when you pick then your capacity will be capacity-(weight[index]+1).\\n\\n\\t\\tother choice is not pick and decrement index\\n```\\n* Compute Result array from Dp array by traversing from end similar as finding longest increasing subsequence array.\\n\\n*Advice*\\n* Implement first recursive solution\\n* Identify Variable changing in recursion\\n* Convert it to dp by storing every recursion call in memory of dimension same as No of variables changing in recursion.\\n```\\nclass Solution {\\n public:\\n  vector<vector<int>> dp;\\n  vector<int> res;\\n  int recur(int cap, vector<int>& aliceArrows, int ind) {\\n    // base case when bob firing capacity is zero or index becomes zero\\n    if (ind == 0 || cap == 0) return 0;\\n    int put = 0;\\n\\n    // if element already in DP\\n    if (dp[ind][cap] != -1) {\\n      return dp[ind][cap];\\n    }\\n\\n    if (cap > aliceArrows[ind - 1]) {\\n      put =\\n          ind - 1 + recur(cap - aliceArrows[ind - 1] - 1, aliceArrows, ind - 1);\\n    }\\n    int nput = recur(cap, aliceArrows, ind - 1);\\n\\n    // if element not in DP then DP[index][capacity] = max(firing At index i,\\n    // not filing at index i); also if firing then bob will fire\\n    // aliceArrows[index]+1 to win that location and maximize profit\\n    return dp[ind][cap] = max(put, nput);\\n  }\\n\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    int bobTotalArrow = numArrows;\\n    // res to store result, dp will be size 12*bobTotalArrow\\n    res.clear();\\n    res.resize(12, 0);\\n\\n    dp.clear();\\n    dp.resize(13, vector<int>(bobTotalArrow + 1, -1));\\n\\n    recur(bobTotalArrow, aliceArrows, 12);\\n\\n    // computing result array from DP result\\n    int result = dp[12][bobTotalArrow];\\n    int total = 0;\\n    for (int i = 12, j = bobTotalArrow; i > 0 && result > 0; i--) {\\n      if (result == dp[i - 1][j])\\n        continue;\\n      else {\\n        // This item is included.\\n        res[i - 1] = aliceArrows[i - 1] + 1;\\n        result -= (i - 1);\\n        j -= (aliceArrows[i - 1] + 1);\\n        total += aliceArrows[i - 1] + 1;\\n      }\\n    }\\n    if (total < bobTotalArrow) {\\n      res[0] = bobTotalArrow - total;\\n    }\\n    return res;\\n  }\\n};\\n\\n```\\n\\nTime Complexity \\n```\\nO(N) because we computing Dp of size 12*bobTotalArrow ,let say bobTotalArrow as N.\\n```\\nSpace Complexity \\n```\\nO(N) because we computing Dp of size 12*bobTotalArrow ,let say bobTotalArrow as N. \\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t\\tfirst choice is\\n \\t\\t\\t\\tYou can only pick weight at index, when weight[index]<Your capacity\\n\\t\\t\\t\\tso, when you pick then your capacity will be capacity-(weight[index]+1).\\n\\n\\t\\tother choice is not pick and decrement index\\n```\n```\\nclass Solution {\\n public:\\n  vector<vector<int>> dp;\\n  vector<int> res;\\n  int recur(int cap, vector<int>& aliceArrows, int ind) {\\n    // base case when bob firing capacity is zero or index becomes zero\\n    if (ind == 0 || cap == 0) return 0;\\n    int put = 0;\\n\\n    // if element already in DP\\n    if (dp[ind][cap] != -1) {\\n      return dp[ind][cap];\\n    }\\n\\n    if (cap > aliceArrows[ind - 1]) {\\n      put =\\n          ind - 1 + recur(cap - aliceArrows[ind - 1] - 1, aliceArrows, ind - 1);\\n    }\\n    int nput = recur(cap, aliceArrows, ind - 1);\\n\\n    // if element not in DP then DP[index][capacity] = max(firing At index i,\\n    // not filing at index i); also if firing then bob will fire\\n    // aliceArrows[index]+1 to win that location and maximize profit\\n    return dp[ind][cap] = max(put, nput);\\n  }\\n\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    int bobTotalArrow = numArrows;\\n    // res to store result, dp will be size 12*bobTotalArrow\\n    res.clear();\\n    res.resize(12, 0);\\n\\n    dp.clear();\\n    dp.resize(13, vector<int>(bobTotalArrow + 1, -1));\\n\\n    recur(bobTotalArrow, aliceArrows, 12);\\n\\n    // computing result array from DP result\\n    int result = dp[12][bobTotalArrow];\\n    int total = 0;\\n    for (int i = 12, j = bobTotalArrow; i > 0 && result > 0; i--) {\\n      if (result == dp[i - 1][j])\\n        continue;\\n      else {\\n        // This item is included.\\n        res[i - 1] = aliceArrows[i - 1] + 1;\\n        result -= (i - 1);\\n        j -= (aliceArrows[i - 1] + 1);\\n        total += aliceArrows[i - 1] + 1;\\n      }\\n    }\\n    if (total < bobTotalArrow) {\\n      res[0] = bobTotalArrow - total;\\n    }\\n    return res;\\n  }\\n};\\n\\n```\n```\\nO(N) because we computing Dp of size 12*bobTotalArrow ,let say bobTotalArrow as N.\\n```\n```\\nO(N) because we computing Dp of size 12*bobTotalArrow ,let say bobTotalArrow as N. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865631,
                "title": "simple-java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        maximumBobPoints(numArrows, aliceArrows, 11, 0);\\n        return result;\\n    }\\n    int[] result = new int[12];\\n    int [] temp = new int[12];\\n    int max = 0;\\n    public void maximumBobPoints(int numArrows, int[] aliceArrows, int arrowIndex, int currentScore) {\\n        if(numArrows<0)\\n            return;\\n\\n            if(currentScore>=max){\\n                max = currentScore;\\n                for(int i=0;i<result.length;i++){\\n                    result[i] = temp[i];\\n                }\\n            }\\n\\n        if(numArrows==0)\\n            return;\\n\\n        temp[arrowIndex] = (arrowIndex==0)?numArrows:(aliceArrows[arrowIndex]+1);\\n        \\n        maximumBobPoints(numArrows-temp[arrowIndex], aliceArrows, arrowIndex-1, currentScore + arrowIndex);\\n        \\n        temp[arrowIndex] = (arrowIndex==0)?numArrows:0;\\n        maximumBobPoints(numArrows-temp[arrowIndex], aliceArrows, arrowIndex-1, currentScore);\\n        temp[arrowIndex]  = 0;\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        maximumBobPoints(numArrows, aliceArrows, 11, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1867824,
                "title": "try-all-possible-combinations-backtracking-based-approach-c-clean-code",
                "content": "# Code : \\n\\n```\\nclass Solution {\\n    vector<int> bobArrows;\\n    int maxScore = 0;\\n    \\n    void generate(vector<int>& aliceArrows, vector<int>& arrows, int numArrows, int score, int idx, int n) {\\n        if(idx == n) {\\n            if(score > maxScore) {\\n                bobArrows = arrows;\\n                bobArrows[0] += numArrows;\\n                maxScore = score;\\n            }\\n            return;\\n        }\\n        \\n        // Alice win this round\\n        arrows.push_back(0);\\n        generate(aliceArrows, arrows, numArrows, score, idx+1, n);\\n        arrows.pop_back();\\n        \\n        // Bob win this round\\n        if(aliceArrows[idx] + 1 <= numArrows) {\\n            arrows.push_back(aliceArrows[idx] + 1);\\n            generate(aliceArrows, arrows, numArrows - aliceArrows[idx] - 1, score + idx, idx+1, n);\\n            arrows.pop_back();   \\n        }\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n        vector<int> arrows;\\n        generate(aliceArrows, arrows, numArrows, 0, 0, n);\\n        return bobArrows;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N * 2^N)`, N = 12\\n* Space : `O(N)`\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> bobArrows;\\n    int maxScore = 0;\\n    \\n    void generate(vector<int>& aliceArrows, vector<int>& arrows, int numArrows, int score, int idx, int n) {\\n        if(idx == n) {\\n            if(score > maxScore) {\\n                bobArrows = arrows;\\n                bobArrows[0] += numArrows;\\n                maxScore = score;\\n            }\\n            return;\\n        }\\n        \\n        // Alice win this round\\n        arrows.push_back(0);\\n        generate(aliceArrows, arrows, numArrows, score, idx+1, n);\\n        arrows.pop_back();\\n        \\n        // Bob win this round\\n        if(aliceArrows[idx] + 1 <= numArrows) {\\n            arrows.push_back(aliceArrows[idx] + 1);\\n            generate(aliceArrows, arrows, numArrows - aliceArrows[idx] - 1, score + idx, idx+1, n);\\n            arrows.pop_back();   \\n        }\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n        vector<int> arrows;\\n        generate(aliceArrows, arrows, numArrows, 0, 0, n);\\n        return bobArrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961687,
                "title": "c-faster-than-99-simple-recursive-solution-must-watch",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> finalVector;\\n    int overallMax = 0;\\n\\n    void solve(vector<int>& aliceArrows, vector<int> &bobArrows, int curMax, int numArrows, int ind){\\n            \\n        if(numArrows == 0 || ind < 0){\\n            if(overallMax<curMax){\\n                overallMax = curMax;\\n                finalVector = bobArrows;\\n            }\\n            return;\\n        }\\n        if(ind == 0){\\n            bobArrows[ind] = numArrows;\\n            solve(aliceArrows, bobArrows, curMax+ind, 0, ind-1);\\n            bobArrows[ind] = 0;\\n            return;\\n        }\\n        else if(numArrows>= (aliceArrows[ind]+1)){\\n            bobArrows[ind] = aliceArrows[ind]+1;\\n            solve(aliceArrows, bobArrows, curMax+ind,numArrows-(aliceArrows[ind]+1),ind-1);\\n            bobArrows[ind] = 0;\\n        }\\n        solve(aliceArrows, bobArrows, curMax, numArrows, ind-1);\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bobArrows;\\n        for(int i=0;i<12;i++)\\n            bobArrows.push_back(0);\\n        solve(aliceArrows, bobArrows, 0, numArrows, 11);\\n        return finalVector;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> finalVector;\\n    int overallMax = 0;\\n\\n    void solve(vector<int>& aliceArrows, vector<int> &bobArrows, int curMax, int numArrows, int ind){\\n            \\n        if(numArrows == 0 || ind < 0){\\n            if(overallMax<curMax){\\n                overallMax = curMax;\\n                finalVector = bobArrows;\\n            }\\n            return;\\n        }\\n        if(ind == 0){\\n            bobArrows[ind] = numArrows;\\n            solve(aliceArrows, bobArrows, curMax+ind, 0, ind-1);\\n            bobArrows[ind] = 0;\\n            return;\\n        }\\n        else if(numArrows>= (aliceArrows[ind]+1)){\\n            bobArrows[ind] = aliceArrows[ind]+1;\\n            solve(aliceArrows, bobArrows, curMax+ind,numArrows-(aliceArrows[ind]+1),ind-1);\\n            bobArrows[ind] = 0;\\n        }\\n        solve(aliceArrows, bobArrows, curMax, numArrows, ind-1);\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bobArrows;\\n        for(int i=0;i<12;i++)\\n            bobArrows.push_back(0);\\n        solve(aliceArrows, bobArrows, 0, numArrows, 11);\\n        return finalVector;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866144,
                "title": "bit-masking-all-cases",
                "content": "Since the constraint was bobArrows.length == 12, we can check all possible cases here :\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numA, vector<int>& AlAr) {\\n\\t//AlAr is Alice arrow, numA is number of arrows\\n        vector<int> W;\\n       for(int i : AlAr) W.push_back(i+1); \\n// minimum required arrows for bob to get this point\\n        int k = 0,n = AlAr.size();\\n        n = (1<<n);// total possible cases 2^n\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int WE = 0,A=0;\\n            for(int j = 0 ; j < AlAr.size() ; j++ ){\\n                if((1<<j)&i) WE += W[j] , A += j;\\n            }\\n            if(WE<=numA and A>ans) ans = A, k = i ;\\n        }//Checking all possible cases  if i th bit is set means bob will get i points \\n        vector<int> V(AlAr.size());\\n        for(int j = 0 ; j <= AlAr.size() ; j++)     if((1<<j)&k) V[j] = W[j];\\n        int s = 0;\\n        for(int i = 0 ; i < V.size()  ; i++){\\n            s += V[i];\\n        }\\n// If less than total number of arrows are to be used to acheive max we can put rest arrows \\n//anywhere the max will not increase.\\n        V[0] = numA - s ;\\n        return V;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numA, vector<int>& AlAr) {\\n\\t//AlAr is Alice arrow, numA is number of arrows\\n        vector<int> W;\\n       for(int i : AlAr) W.push_back(i+1); \\n// minimum required arrows for bob to get this point\\n        int k = 0,n = AlAr.size();\\n        n = (1<<n);// total possible cases 2^n\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int WE = 0,A=0;\\n            for(int j = 0 ; j < AlAr.size() ; j++ ){\\n                if((1<<j)&i) WE += W[j] , A += j;\\n            }\\n            if(WE<=numA and A>ans) ans = A, k = i ;\\n        }//Checking all possible cases  if i th bit is set means bob will get i points \\n        vector<int> V(AlAr.size());\\n        for(int j = 0 ; j <= AlAr.size() ; j++)     if((1<<j)&k) V[j] = W[j];\\n        int s = 0;\\n        for(int i = 0 ; i < V.size()  ; i++){\\n            s += V[i];\\n        }\\n// If less than total number of arrows are to be used to acheive max we can put rest arrows \\n//anywhere the max will not increase.\\n        V[0] = numA - s ;\\n        return V;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865691,
                "title": "c-dp-accepted-tle-fix",
                "content": "The algorithm is pretty straightforward - At every position Bob can either try to win against Alilce or lose. \\nWe try all cases and keep the answers in DP.\\n\\nDuring contest I got many TLE when I used `vector<vector<int>>mem(numArrows+1, vector<int>(12, -1))` to declare the dp array.\\nThe test cases shown would always run under 50ms and couldn\\'t figure out why I was geting TLE.\\n\\nI tried the test case 20 times as the input and got TLE. **After switching it to static array it passed.**  Sort of ruined the contest for me.\\n\\n```c++\\nclass Solution {\\n  vector<int> alice;\\n  int mem[100009][12];\\n  int parent[100009][12];\\n  int dp(int arrow, int idx) {\\n    if (arrow < 0) return -100000;\\n    if (idx <= 0) {\\n      return 0;\\n    }\\n    if (mem[arrow][idx] != -1) return mem[arrow][idx];\\n    int ret = 0;\\n    int to_win = alice[idx] + 1;\\n    int to_win_points = 0, leave_points = 0;\\n    to_win_points = dp(arrow-to_win, idx - 1) + idx;\\n    leave_points = dp(arrow, idx - 1);\\n    if (leave_points >= to_win_points) {\\n      parent[arrow][idx] = 0;\\n      ret = leave_points;\\n    } else {\\n      parent[arrow][idx] = 1;\\n      ret = to_win_points;\\n    }\\n    mem[arrow][idx] = ret;\\n    return ret;\\n  }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n      memset(mem, -1, sizeof mem);\\n      memset(parent, 0, sizeof parent);\\n      alice = aliceArrows;\\n      vector<int> bob(12, 0);\\n      dp(numArrows, 11);\\n      int n = numArrows;\\n      for (int i = 11; i >= 0; i--) {\\n        if (parent[n][i]) {\\n          bob[i] = alice[i] + 1;\\n          n -= alice[i] + 1;\\n        }\\n      }\\n      if (n > 0) bob[0] = n;\\n      return bob;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n  vector<int> alice;\\n  int mem[100009][12];\\n  int parent[100009][12];\\n  int dp(int arrow, int idx) {\\n    if (arrow < 0) return -100000;\\n    if (idx <= 0) {\\n      return 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3037888,
                "title": "java-backtracking-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int maxScore = 0;\\n    int[] maxStore = null;\\n\\n    // I m starting from index 0 \\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        helper(numArrows , 0 , 0 , aliceArrows , new int[12]);\\n        return maxStore;\\n    }\\n    // These are base conditions \\n    // If numArrows reduces to 0 that means we have used all the arrows \\n    // and also when index i reaches to 12 means you have completed all the 12 rounds \\n   \\n    // At Base condition \\n    // check if score > maxScore if yes update maxScore and store this storeArray\\n    // into maxStore because we want to return this maxStore array.\\n\\n    public void helper(int numArrows , int i , int score , int[] arr , int[] store){\\n        if (i == 12 || numArrows == 0) {\\n            if (score > maxScore) {\\n                maxScore = score; // storing the maxScore\\n                maxStore = store.clone(); // storing the maxStore array \\n                maxStore[0] += numArrows;\\n            }\\n            return;\\n        }\\n        int val = arr[i];\\n        if(numArrows - (val + 1) >= 0){ \\n            store[i] = val + 1; \\n            helper(numArrows - (val + 1) , i + 1 , score + i , arr , store);\\n            store[i] = 0; \\n        }\\n        helper(numArrows , i + 1 , score , arr , store);\\n    }\\n}\\n          \\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int maxScore = 0;\\n    int[] maxStore = null;\\n\\n    // I m starting from index 0 \\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        helper(numArrows , 0 , 0 , aliceArrows , new int[12]);\\n        return maxStore;\\n    }\\n    // These are base conditions \\n    // If numArrows reduces to 0 that means we have used all the arrows \\n    // and also when index i reaches to 12 means you have completed all the 12 rounds \\n   \\n    // At Base condition \\n    // check if score > maxScore if yes update maxScore and store this storeArray\\n    // into maxStore because we want to return this maxStore array.\\n\\n    public void helper(int numArrows , int i , int score , int[] arr , int[] store){\\n        if (i == 12 || numArrows == 0) {\\n            if (score > maxScore) {\\n                maxScore = score; // storing the maxScore\\n                maxStore = store.clone(); // storing the maxStore array \\n                maxStore[0] += numArrows;\\n            }\\n            return;\\n        }\\n        int val = arr[i];\\n        if(numArrows - (val + 1) >= 0){ \\n            store[i] = val + 1; \\n            helper(numArrows - (val + 1) , i + 1 , score + i , arr , store);\\n            store[i] = 0; \\n        }\\n        helper(numArrows , i + 1 , score , arr , store);\\n    }\\n}\\n          \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035716,
                "title": "easiest-soln-goldman-sachs-well-explained",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ8. Maximum Points in an Archery Competition**\\n\\n![8_!.jpg](https://assets.leetcode.com/users/images/7d25e547-415c-4689-a7ac-f8c892c2d75c_1673444837.4033573.jpeg)\\n![8_2.jpg](https://assets.leetcode.com/users/images/42318815-10a7-4447-bcf4-6c4634cc201d_1673444875.69605.jpeg)\\n\\n### Approach\\nThe function uses a backtracking approach to try all possible combinations of arrows for Bob, and keeps track of the best strategy (the one that earns him the most points) by updating the optimalStrategy array and the maxPoints variable accordingly.\\n\\n# Complexity\\n- **Time Complexity: **The time complexity of this function is O(2^n), where n is the number of rounds in the game. The function has to try all possible combinations of arrows for Bob, and each round has two possible choices: use arrows or not.\\n\\n- **Space Complexity: O(n)**, because this algorithm uses a recursive call stack, and it uses O(n) extra space for storing the arrays and variables such as optimalStrategy, maxPoints, currentStrategy, and currentPoints\\n\\n# Code\\n```\\nclass Solution {\\n    int[] optimalStrategy; // optimal strategy for Bob, in terms of number of arrows used for each round\\n    int maxPoints = 0; // maximum number of points Bob can earn\\n    public int[] maximumBobPoints(int bobArrows, int[] aliceArrows) {\\n        // initialize optimalStrategy array and set all elements to 0\\n        optimalStrategy = new int[aliceArrows.length];\\n        compute(bobArrows, aliceArrows, new int[aliceArrows.length], aliceArrows.length - 1, 0);\\n        return optimalStrategy;\\n    }\\n\\n    private void compute(int bobArrows, int[] aliceArrows, int[] currentStrategy, int currentRound, int currentPoints) {\\n        // base case: if we\\'ve reached the last round, check if this is the best strategy so far\\n        if (currentRound == 0) {\\n            if (currentPoints > maxPoints) {\\n                maxPoints = currentPoints;\\n                currentStrategy[currentRound] = bobArrows;\\n                optimalStrategy = currentStrategy.clone();\\n            }\\n            return;\\n        }\\n        // try not using any arrows in this round\\n        compute(bobArrows, aliceArrows, currentStrategy, currentRound - 1, currentPoints);\\n        // if Bob has enough arrows to beat Alice\\'s score in this round, try using some arrows\\n        if (bobArrows > aliceArrows[currentRound]) {\\n            currentStrategy[currentRound] = aliceArrows[currentRound] + 1;\\n            compute(bobArrows - currentStrategy[currentRound], aliceArrows, currentStrategy, currentRound - 1, currentPoints + currentRound);\\n            currentStrategy[currentRound] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] optimalStrategy; // optimal strategy for Bob, in terms of number of arrows used for each round\\n    int maxPoints = 0; // maximum number of points Bob can earn\\n    public int[] maximumBobPoints(int bobArrows, int[] aliceArrows) {\\n        // initialize optimalStrategy array and set all elements to 0\\n        optimalStrategy = new int[aliceArrows.length];\\n        compute(bobArrows, aliceArrows, new int[aliceArrows.length], aliceArrows.length - 1, 0);\\n        return optimalStrategy;\\n    }\\n\\n    private void compute(int bobArrows, int[] aliceArrows, int[] currentStrategy, int currentRound, int currentPoints) {\\n        // base case: if we\\'ve reached the last round, check if this is the best strategy so far\\n        if (currentRound == 0) {\\n            if (currentPoints > maxPoints) {\\n                maxPoints = currentPoints;\\n                currentStrategy[currentRound] = bobArrows;\\n                optimalStrategy = currentStrategy.clone();\\n            }\\n            return;\\n        }\\n        // try not using any arrows in this round\\n        compute(bobArrows, aliceArrows, currentStrategy, currentRound - 1, currentPoints);\\n        // if Bob has enough arrows to beat Alice\\'s score in this round, try using some arrows\\n        if (bobArrows > aliceArrows[currentRound]) {\\n            currentStrategy[currentRound] = aliceArrows[currentRound] + 1;\\n            compute(bobArrows - currentStrategy[currentRound], aliceArrows, currentStrategy, currentRound - 1, currentPoints + currentRound);\\n            currentStrategy[currentRound] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923811,
                "title": "this-is-just-knapsack-problem-with-different-variable-names",
                "content": "This problem is just like knapsack problem:\\nnumArrows is like the capacity of the sack.\\neach ith section is like an item whose cost is AliceArrows[i]+1  and value is the number of points associated with the section.\\nthe cost of ith section is AliceArrows[i]+1, because to obtain the points (or \\'value\\') of that section, Bob needs to land atleast one more arrow than Alice in that section.\\n\\n```\\n/*\\ndp[i][j]  -> max net value for first i items and j weight\\n\\nif ( j>PriceCurSection)\\n\\tdp[i][j]  = max(dp[i-1][j], dp[i-1][j-PriceCurSection] + pointsCurSection)\\n\\n*/\\n \\nclass Solution {\\npublic:\\n    const int NUM_SECTIONS = 12;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        vector <int> arrowsRequiredForSection;\\n        for (int numSectionArrowsAlice: aliceArrows) {\\n            arrowsRequiredForSection.push_back(numSectionArrowsAlice+1);\\n        }\\n        \\n        vector <int> sectionPoints;\\n        for (int i=0; i<NUM_SECTIONS; i++) {\\n            sectionPoints.push_back(i);\\n        }\\n        vector<int> optimalShots =  knapsack(numArrows, arrowsRequiredForSection, sectionPoints);\\n        int arrowsUsed = accumulate(optimalShots.begin(), optimalShots.end(), 0);\\n        if (numArrows > arrowsUsed) {\\n            optimalShots[0] += numArrows - arrowsUsed;\\n        }\\n        \\n        return optimalShots;\\n        \\n    }\\n    \\n    vector <int> knapsack(const int capacity, const vector<int>& costs, const vector<int>& itemValues) {\\n                \\n        int numItems = costs.size();\\n        // vector <vector<int>> dp(numItems+1,vector<int>(capacity+1));\\n        // vector <vector<bool>> isCurItemPicked(numItems+1,vector<bool>(capacity+1));\\n        int dp[numItems+1][capacity+1];\\n        bool isCurItemPicked[numItems+1][capacity+1];\\n        memset(dp,0,sizeof(dp));\\n        memset(isCurItemPicked,0,sizeof(isCurItemPicked));\\n        for (int i=1; i<=numItems; i++) {\\n            for (int j=1; j<=capacity; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (j >= costs[i-1]) {\\n                    int valueIfCurItemIsPicked = dp[i-1][j-costs[i-1]] + itemValues[i-1];\\n                    if (valueIfCurItemIsPicked > dp[i][j]) {\\n                        dp[i][j] = valueIfCurItemIsPicked;\\n                        isCurItemPicked[i][j] = true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        vector <int> spent;\\n        int weight = capacity;\\n        for (int i=numItems; i>0; i--) {            \\n            if (isCurItemPicked[i][weight]) {\\n                weight -= costs[i-1];\\n                spent.push_back(costs[i-1]);\\n            } else {\\n                spent.push_back(0);\\n            }\\n        }\\n        reverse(spent.begin(), spent.end());\\n        return spent;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\ndp[i][j]  -> max net value for first i items and j weight\\n\\nif ( j>PriceCurSection)\\n\\tdp[i][j]  = max(dp[i-1][j], dp[i-1][j-PriceCurSection] + pointsCurSection)\\n\\n*/\\n \\nclass Solution {\\npublic:\\n    const int NUM_SECTIONS = 12;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        vector <int> arrowsRequiredForSection;\\n        for (int numSectionArrowsAlice: aliceArrows) {\\n            arrowsRequiredForSection.push_back(numSectionArrowsAlice+1);\\n        }\\n        \\n        vector <int> sectionPoints;\\n        for (int i=0; i<NUM_SECTIONS; i++) {\\n            sectionPoints.push_back(i);\\n        }\\n        vector<int> optimalShots =  knapsack(numArrows, arrowsRequiredForSection, sectionPoints);\\n        int arrowsUsed = accumulate(optimalShots.begin(), optimalShots.end(), 0);\\n        if (numArrows > arrowsUsed) {\\n            optimalShots[0] += numArrows - arrowsUsed;\\n        }\\n        \\n        return optimalShots;\\n        \\n    }\\n    \\n    vector <int> knapsack(const int capacity, const vector<int>& costs, const vector<int>& itemValues) {\\n                \\n        int numItems = costs.size();\\n        // vector <vector<int>> dp(numItems+1,vector<int>(capacity+1));\\n        // vector <vector<bool>> isCurItemPicked(numItems+1,vector<bool>(capacity+1));\\n        int dp[numItems+1][capacity+1];\\n        bool isCurItemPicked[numItems+1][capacity+1];\\n        memset(dp,0,sizeof(dp));\\n        memset(isCurItemPicked,0,sizeof(isCurItemPicked));\\n        for (int i=1; i<=numItems; i++) {\\n            for (int j=1; j<=capacity; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (j >= costs[i-1]) {\\n                    int valueIfCurItemIsPicked = dp[i-1][j-costs[i-1]] + itemValues[i-1];\\n                    if (valueIfCurItemIsPicked > dp[i][j]) {\\n                        dp[i][j] = valueIfCurItemIsPicked;\\n                        isCurItemPicked[i][j] = true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        vector <int> spent;\\n        int weight = capacity;\\n        for (int i=numItems; i>0; i--) {            \\n            if (isCurItemPicked[i][weight]) {\\n                weight -= costs[i-1];\\n                spent.push_back(costs[i-1]);\\n            } else {\\n                spent.push_back(0);\\n            }\\n        }\\n        reverse(spent.begin(), spent.end());\\n        return spent;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910975,
                "title": "python-backtracking-solution",
                "content": "class Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n            \\n        currMax = 0\\n        result = [[0]*12]\\n\\n        def maxscore(section, score, arrows, i):\\n            nonlocal currMax\\n            if arrows < 0:\\n                return\\n            if arrows == 0 or i == 0:\\n                if score >= currMax:\\n                    currMax = score\\n                    if arrows > 0:\\n                        result[0] = [arrows] + section[1:]\\n                    else:\\n                        result[0] = section[:]\\n                return\\n            section[i] = aliceArrows[i]+1\\n            maxscore(section, score+i, arrows-aliceArrows[i]-1, i-1)\\n            section[i] = 0\\n            maxscore(section, score, arrows, i-1)\\n        \\n        maxscore([0]*12, 0, numArrows, 11)\\n        return result[0]",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "class Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n            \\n        currMax = 0\\n        result = [[0]*12]\\n\\n        def maxscore(section, score, arrows, i):\\n            nonlocal currMax\\n            if arrows < 0:\\n                return\\n            if arrows == 0 or i == 0:\\n                if score >= currMax:\\n                    currMax = score\\n                    if arrows > 0:\\n                        result[0] = [arrows] + section[1:]\\n                    else:\\n                        result[0] = section[:]\\n                return\\n            section[i] = aliceArrows[i]+1\\n            maxscore(section, score+i, arrows-aliceArrows[i]-1, i-1)\\n            section[i] = 0\\n            maxscore(section, score, arrows, i-1)\\n        \\n        maxscore([0]*12, 0, numArrows, 11)\\n        return result[0]",
                "codeTag": "Java"
            },
            {
                "id": 1867757,
                "title": "elegant-bitmasking-solution-explanation",
                "content": "<br>\\n\\n* As number of targets are only 12, we can generate all the possible combination `(2 ^ 12)` of hit or skip choices.\\n* If the ith bit in our bitmask is set, then Bob will hit the target and to `maximize his score he must hit at least aliceArrows[i] + 1 arrows` on ith target\\n* So, for the 2 ^ 12 combinations, we will try to calculate maximum score Bob can get by using exactly numArrows arrows.\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        int n = 12, maxScore = INT_MIN;\\n        vector<int> bobArrows(12, 0), tempArrows(12, 0);\\n        \\n\\t\\t// generating all possible combinations\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n\\t\\t\\t\\n\\t\\t\\t// if the score obtained by current combination is more than maxScore\\n\\t\\t\\t// then we will update our answer (maxScore and bobArrows)\\n            int currentScore = checkCombination(mask, tempArrows, numArrows, aliceArrows);\\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                bobArrows = tempArrows;\\n            }\\n        }\\n        \\n        return bobArrows;\\n    }\\n\\nprivate:\\n    int checkCombination(int mask, vector<int>& arrows, int arrowsLeft, vector<int>& aliceArrows) {\\n        int score = 0;\\n        arrows = vector<int>(12, 0);\\n        \\n\\t\\t// checking for all the targets\\n        for(int i = 0; i <= 11; i++) {\\n\\t\\t\\t// if ith bit is set\\n            if(mask & (1 << i)) {\\n                int arrowsNeed = aliceArrows[i] + 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if arrows needed to hit current target is more than arrows left, then this combination\\n\\t\\t\\t\\t// will not lead to correct answer, so we stop\\n                if(arrowsNeed > arrowsLeft) {\\n                    return INT_MIN;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// updating score and arrows count\\n                score += i;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// arrows[i] is arrows Bob must hit to achieve this score\\n                arrows[i] = arrowsNeed;\\n                arrowsLeft -= arrowsNeed;\\n            }\\n        }\\n        \\n\\t\\t// in case if any arrows are left after hitting targets, we can add it to any target\\n        if(arrowsLeft) arrows[11] += arrowsLeft;\\n        return score;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**Time complexity: O((2 ^ 12) * 12)\\nAuxiliary Space complexity: O(1)**\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        int n = 12, maxScore = INT_MIN;\\n        vector<int> bobArrows(12, 0), tempArrows(12, 0);\\n        \\n\\t\\t// generating all possible combinations\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n\\t\\t\\t\\n\\t\\t\\t// if the score obtained by current combination is more than maxScore\\n\\t\\t\\t// then we will update our answer (maxScore and bobArrows)\\n            int currentScore = checkCombination(mask, tempArrows, numArrows, aliceArrows);\\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                bobArrows = tempArrows;\\n            }\\n        }\\n        \\n        return bobArrows;\\n    }\\n\\nprivate:\\n    int checkCombination(int mask, vector<int>& arrows, int arrowsLeft, vector<int>& aliceArrows) {\\n        int score = 0;\\n        arrows = vector<int>(12, 0);\\n        \\n\\t\\t// checking for all the targets\\n        for(int i = 0; i <= 11; i++) {\\n\\t\\t\\t// if ith bit is set\\n            if(mask & (1 << i)) {\\n                int arrowsNeed = aliceArrows[i] + 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if arrows needed to hit current target is more than arrows left, then this combination\\n\\t\\t\\t\\t// will not lead to correct answer, so we stop\\n                if(arrowsNeed > arrowsLeft) {\\n                    return INT_MIN;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// updating score and arrows count\\n                score += i;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// arrows[i] is arrows Bob must hit to achieve this score\\n                arrows[i] = arrowsNeed;\\n                arrowsLeft -= arrowsNeed;\\n            }\\n        }\\n        \\n\\t\\t// in case if any arrows are left after hitting targets, we can add it to any target\\n        if(arrowsLeft) arrows[11] += arrowsLeft;\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865848,
                "title": "python-bottoms-up-dp-got-tle-time-too-restrictive",
                "content": "I first use bottoms up DP and the complexity is numArrows * 12 but got TLE. Though I realize later that we should use top down DP, I still feel the time limit is too restrictive.\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[0] * (numArrows + 1) for _ in range(12)]\\n        for i in range(12):\\n            for j in range(1, numArrows + 1):\\n                if i > 0:\\n                    dp[i][j] = dp[i-1][j]\\n                if j > aliceArrows[i]:\\n                    dp[i][j] = max(dp[i][j], i + dp[i-1][j-aliceArrows[i]-1])\\n        res = []\\n        t = 0\\n        for i in range(11, 0, -1):\\n            if dp[i][numArrows-t] == dp[i-1][numArrows-t]:\\n                res.append(0)\\n            else:\\n                res.append(aliceArrows[i] + 1)\\n                t += aliceArrows[i] + 1\\n        res.append(numArrows - t)\\n        return res[::-1]\\n```\\n\\nThis is my passed top down DP solution. Technically this is faster than bottoms up DP because of the data discretization. But the complexity is still numArrows * 12.\\n\\nThe time constraint is way too restrictive in the problem\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        mem = [[-1] * (numArrows + 1) for _ in range(12)]\\n        def dp(i, n):\\n            if mem[i][n] == -1:\\n                if i == 0:\\n                    mem[i][n] = 0\\n                else:\\n                    mem[i][n] = dp(i - 1, n)\\n                    if n > aliceArrows[i]:\\n                        mem[i][n] = max(mem[i][n], i + dp(i - 1, n - aliceArrows[i] - 1))\\n            return mem[i][n]\\n        \\n        dp(11, numArrows)\\n        res = []\\n        t = 0\\n        for i in range(11, 0, -1):\\n            if mem[i][numArrows-t] == mem[i-1][numArrows-t]:\\n                res.append(0)\\n            else:\\n                res.append(aliceArrows[i] + 1)\\n                t += aliceArrows[i] + 1\\n        res.append(numArrows - t)\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[0] * (numArrows + 1) for _ in range(12)]\\n        for i in range(12):\\n            for j in range(1, numArrows + 1):\\n                if i > 0:\\n                    dp[i][j] = dp[i-1][j]\\n                if j > aliceArrows[i]:\\n                    dp[i][j] = max(dp[i][j], i + dp[i-1][j-aliceArrows[i]-1])\\n        res = []\\n        t = 0\\n        for i in range(11, 0, -1):\\n            if dp[i][numArrows-t] == dp[i-1][numArrows-t]:\\n                res.append(0)\\n            else:\\n                res.append(aliceArrows[i] + 1)\\n                t += aliceArrows[i] + 1\\n        res.append(numArrows - t)\\n        return res[::-1]\\n```\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        mem = [[-1] * (numArrows + 1) for _ in range(12)]\\n        def dp(i, n):\\n            if mem[i][n] == -1:\\n                if i == 0:\\n                    mem[i][n] = 0\\n                else:\\n                    mem[i][n] = dp(i - 1, n)\\n                    if n > aliceArrows[i]:\\n                        mem[i][n] = max(mem[i][n], i + dp(i - 1, n - aliceArrows[i] - 1))\\n            return mem[i][n]\\n        \\n        dp(11, numArrows)\\n        res = []\\n        t = 0\\n        for i in range(11, 0, -1):\\n            if mem[i][numArrows-t] == mem[i-1][numArrows-t]:\\n                res.append(0)\\n            else:\\n                res.append(aliceArrows[i] + 1)\\n                t += aliceArrows[i] + 1\\n        res.append(numArrows - t)\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865734,
                "title": "can-someone-explain-what-happens-when-someone-shoots-in-0-target",
                "content": "I have been getting WA for a long time in this input:\\n\\n```\\nInput:\\n89\\n[3,2,28,1,7,1,16,7,3,13,3,5]\\nOutput:\\n[0,3,29,2,0,2,17,8,4,14,4,6]\\nExpected:\\n[21,3,0,2,8,2,17,8,4,14,4,6]\\n\\nKindly someone explain why 21 arrows are throwing in target 0.  \\nIf you cannot answer, please upvote so that someone can see and answer. Thank you in advance:)",
                "solutionTags": [],
                "code": "I have been getting WA for a long time in this input:\\n\\n```\\nInput:\\n89\\n[3,2,28,1,7,1,16,7,3,13,3,5]\\nOutput:\\n[0,3,29,2,0,2,17,8,4,14,4,6]\\nExpected:\\n[21,3,0,2,8,2,17,8,4,14,4,6]\\n\\nKindly someone explain why 21 arrows are throwing in target 0.  \\nIf you cannot answer, please upvote so that someone can see and answer. Thank you in advance:)",
                "codeTag": "Unknown"
            },
            {
                "id": 3028996,
                "title": "c-short-and-easy-to-understand-well-commented-sloution-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the approach of take and not take in backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every index there are two possibilites either take its score or don\\'t take its score.\\n\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>ans;//answer array \\nint maxpoints=0; //stores the maximum points by bob\\n    void solve(int ind,int score,int arrow,vector<int> &nums,vector<int> &res){\\n        if(arrow==0||ind<0){\\n            //if ind goes negitive or arrows count became 0.\\n            //Then check if current score is the maximum score .\\n            //If score is maximum the res array is ans array.\\n            if(score>maxpoints){\\n                maxpoints=score;\\n                ans=res;\\n            }\\n            return ;\\n        }\\n        //if available arrows is greater than the arrorws requires for the current score index then we can take this score.\\n        if(arrow>nums[ind]){\\n           res[ind]=nums[ind]+1;\\n            solve(ind-1,score+ind,arrow-(nums[ind]+1),nums,res);//taking the current index score.\\n          res[ind]=0;\\n           \\n        }\\n        //Here we are not taking the current index score.\\n        solve(ind-1,score,arrow,nums,res);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res(12,0);//To store the values of arrows used by bob\\n        solve(11,0,numArrows,aliceArrows,res);\\n        int cnt=0;\\n        for(auto it:ans){\\n            cnt+=it;\\n\\n        }\\n        int startind=numArrows-cnt;\\n        if(startind>0){\\n            ans[0]+=startind;\\n        }\\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\nvector<int>ans;//answer array \\nint maxpoints=0; //stores the maximum points by bob\\n    void solve(int ind,int score,int arrow,vector<int> &nums,vector<int> &res){\\n        if(arrow==0||ind<0){\\n            //if ind goes negitive or arrows count became 0.\\n            //Then check if current score is the maximum score .\\n            //If score is maximum the res array is ans array.\\n            if(score>maxpoints){\\n                maxpoints=score;\\n                ans=res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2464440,
                "title": "c-simple-explained-backtracking-90-faster",
                "content": "We simplify this problem to simple subsequence problem to find the maximum points we can score.\\nWe start by selecting from end :-\\n\\n2 options - select a point by using 1 more than arrows used by alice.\\n\\t\\t\\t\\t  save the arrows and move ahead.\\n\\nWe use a default array to store the arrows used and a final answer array.\\nwhen we get a total greater than the previous total we store the arrows in the final array.\\n\\n2 cases to return :-\\n\\twhen i<0 and arrows are left OR arrows are finished.\\n\\twhen i<0 but arrows are used more then given....this is a discarded case we do not consider     answers from this case.\\n\\t\\n\\t```\\n\\tclass Solution {\\npublic:\\n    \\n    int ans = INT_MIN;\\n    vector<int> tempp;\\n    \\n    void recur(int i, int t, vector<int> &arr, int temp, vector<int> &anss)\\n    {   \\n        if((i<0 && t>=0) || t==0)\\n        {\\n            if(ans < max(ans,temp))\\n            {\\n                for(int j=0; j<12; j++)\\n                    tempp[j]=anss[j];\\n                \\n                //IF ALL THE ARROWS ARE NOT USED\\n                tempp[0]+= t;\\n            }\\n            \\n            ans = max(ans,temp);\\n            \\n            return;\\n        }\\n        \\n        else if(i<0)return;\\n        \\n        \\n        //TAKE\\n        if(t>=arr[i])\\n        {\\n            anss[i] = arr[i]+1;\\n            \\n            recur(i-1, (t-arr[i]-1), arr, temp+i, anss);\\n            anss[i]=0;\\n        }\\n        \\n        //LEAVE\\n        recur(i-1, t, arr, temp, anss);\\n    }\\n    \\n    vector<int> maximumBobPoints(int t, vector<int>& arr) \\n    {\\n        tempp.resize(12, 0);\\n        vector<int> anss(12, 0);\\n        recur(11,t,arr,0, anss);\\n        \\n        return tempp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    \\n    int ans = INT_MIN;\\n    vector<int> tempp;\\n    \\n    void recur(int i, int t, vector<int> &arr, int temp, vector<int> &anss)\\n    {   \\n        if((i<0 && t>=0) || t==0)\\n        {\\n            if(ans < max(ans,temp))\\n            {\\n                for(int j=0; j<12; j++)\\n                    tempp[j]=anss[j];\\n                \\n                //IF ALL THE ARROWS ARE NOT USED\\n                tempp[0]+= t;\\n            }\\n            \\n            ans = max(ans,temp);\\n            \\n            return;\\n        }\\n        \\n        else if(i<0)return;\\n        \\n        \\n        //TAKE\\n        if(t>=arr[i])\\n        {\\n            anss[i] = arr[i]+1;\\n            \\n            recur(i-1, (t-arr[i]-1), arr, temp+i, anss);\\n            anss[i]=0;\\n        }\\n        \\n        //LEAVE\\n        recur(i-1, t, arr, temp, anss);\\n    }\\n    \\n    vector<int> maximumBobPoints(int t, vector<int>& arr) \\n    {\\n        tempp.resize(12, 0);\\n        vector<int> anss(12, 0);\\n        recur(11,t,arr,0, anss);\\n        \\n        return tempp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273858,
                "title": "c-backtracking-easy-to-understand",
                "content": "**Approach:** We will cover all paths and each time the index reaches the last(i.e. 12) and the current score is greater than the maxscore we will update the ans vector with bob vector. We will make two calls from each index whether to consider that index or not.\\nAt last we will get the solution with the max score.\\n\\nclass Solution {\\npublic:\\n\\n    int maxScore = 0;\\n    vector<int> ans;\\n    \\n    void dfs(int idx, int arrows, int score, vector<int> &alice, vector<int> &bob){\\n        if(idx == 12){\\n            if(score > maxScore){\\n                ans = bob;\\n\\t\\t\\t\\t//add remaining arrows at any index(here, i am adding in last index) in ans, it won\\'t matter since it will accept any solution.\\n\\t\\t\\t\\t//we are doing this since we have to use all arrows.\\n                ans.back() += arrows; \\n                maxScore = score;\\n            }\\n            return;\\n        }\\n        // below call will simply skip the current index.\\n        dfs(idx + 1, arrows, score, alice, bob);\\n\\t\\t\\n\\t\\t//this call will take the score of the index only if we have enough arrows to shoot.\\n        if(arrows > alice[idx]){\\n            bob[idx] = alice[idx] + 1;\\n            dfs(idx + 1, arrows - alice[idx] - 1, score + idx, alice, bob);\\n            bob[idx] = 0;\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        dfs(0, numArrows, 0, aliceArrows, bob);\\n        return ans;\\n    }\\n};\\n\\n**Time: O(2^N)**\\n**PLEASE UPVOTE IF HELPFUL!!!**\\nFor query or doubt comment below.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxScore = 0;\\n    vector<int> ans;\\n    \\n    void dfs(int idx, int arrows, int score, vector<int> &alice, vector<int> &bob){\\n        if(idx == 12){\\n            if(score > maxScore){\\n                ans = bob;\\n\\t\\t\\t\\t//add remaining arrows at any index(here, i am adding in last index) in ans, it won\\'t matter since it will accept any solution.\\n\\t\\t\\t\\t//we are doing this since we have to use all arrows.\\n                ans.back() += arrows; \\n                maxScore = score;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2239104,
                "title": "intuitive-pick-don-t-pick-method-c",
                "content": "```\\nclass Solution {\\n\\n  int mx = INT_MIN;\\n\\npublic:\\n\\n  void help(int numArrows, vector<int> &aliceArrows, int idx, vector<int>&temp, vector<int> &bob) {\\n\\n    if (idx == 12) {\\n      int sum = 0;\\n      for (int i = 0; i < 12; i++) {\\n        if (temp[i])\\n          sum += i;\\n      }\\n\\n      // dump the rest of the arrows remaining to temp[0]\\n      if (numArrows) {\\n        temp[0] += numArrows;\\n      }\\n\\n      if (sum > mx) {\\n        mx = sum;\\n        bob = temp;\\n      }\\n\\n      temp[0] -= numArrows;\\n\\n      return;\\n    }\\n\\n    // take\\n    if (numArrows > aliceArrows[idx]) {\\n      temp[idx] = aliceArrows[idx] + 1;\\n      numArrows -= aliceArrows[idx] + 1;\\n      help(numArrows, aliceArrows, idx + 1, temp, bob);\\n      temp[idx] = 0;\\n      numArrows += aliceArrows[idx] + 1;\\n    }\\n\\n    // don\\'t take\\n    help(numArrows, aliceArrows, idx + 1, temp, bob);\\n\\n  }\\n\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    vector<int> temp(12, 0);\\n    vector<int> bob;\\n    help(numArrows, aliceArrows, 0, temp, bob);\\n\\n    return bob;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n  int mx = INT_MIN;\\n\\npublic:\\n\\n  void help(int numArrows, vector<int> &aliceArrows, int idx, vector<int>&temp, vector<int> &bob) {\\n\\n    if (idx == 12) {\\n      int sum = 0;\\n      for (int i = 0; i < 12; i++) {\\n        if (temp[i])\\n          sum += i;\\n      }\\n\\n      // dump the rest of the arrows remaining to temp[0]\\n      if (numArrows) {\\n        temp[0] += numArrows;\\n      }\\n\\n      if (sum > mx) {\\n        mx = sum;\\n        bob = temp;\\n      }\\n\\n      temp[0] -= numArrows;\\n\\n      return;\\n    }\\n\\n    // take\\n    if (numArrows > aliceArrows[idx]) {\\n      temp[idx] = aliceArrows[idx] + 1;\\n      numArrows -= aliceArrows[idx] + 1;\\n      help(numArrows, aliceArrows, idx + 1, temp, bob);\\n      temp[idx] = 0;\\n      numArrows += aliceArrows[idx] + 1;\\n    }\\n\\n    // don\\'t take\\n    help(numArrows, aliceArrows, idx + 1, temp, bob);\\n\\n  }\\n\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    vector<int> temp(12, 0);\\n    vector<int> bob;\\n    help(numArrows, aliceArrows, 0, temp, bob);\\n\\n    return bob;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165663,
                "title": "c-one-backtracking-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int m=0;\\n    vector<int> ans;\\n    void func(vector<int> &temp,int score,int numArrows,vector<int> aliceArrows,int index)\\n    {\\n        //Base case\\n        if(index==aliceArrows.size())\\n        {\\n            //If this combination gives greater score\\n            if(m<score)\\n            {\\n                //Update to max score\\n                m=score;\\n                for(int i=0;i<ans.size();i++)\\n                {\\n                    ans[i]=temp[i];\\n                }\\n                //If there are any remaining arrows then place them at ans[0]\\n                ans[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        //Recursive case\\n        //Bob winning case\\n        if(aliceArrows[index]<numArrows)\\n        {\\n            //For winning case min possible arrows to be placed are alice score at that index+1\\n            temp[index]=aliceArrows[index]+1;\\n            func(temp,score+index,numArrows-temp[index],aliceArrows,index+1);\\n            //Backtrack for getting all possiblilties\\n            temp[index]=0;\\n        }\\n        //Bob loosing case dont add arrows at that index\\n        func(temp,score,numArrows,aliceArrows,index+1);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        vector<int>temp(aliceArrows.size(),0);\\n        \\n        for(int i=0;i<aliceArrows.size();i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        func(temp,0,numArrows,aliceArrows,0);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m=0;\\n    vector<int> ans;\\n    void func(vector<int> &temp,int score,int numArrows,vector<int> aliceArrows,int index)\\n    {\\n        //Base case\\n        if(index==aliceArrows.size())\\n        {\\n            //If this combination gives greater score\\n            if(m<score)\\n            {\\n                //Update to max score\\n                m=score;\\n                for(int i=0;i<ans.size();i++)\\n                {\\n                    ans[i]=temp[i];\\n                }\\n                //If there are any remaining arrows then place them at ans[0]\\n                ans[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        //Recursive case\\n        //Bob winning case\\n        if(aliceArrows[index]<numArrows)\\n        {\\n            //For winning case min possible arrows to be placed are alice score at that index+1\\n            temp[index]=aliceArrows[index]+1;\\n            func(temp,score+index,numArrows-temp[index],aliceArrows,index+1);\\n            //Backtrack for getting all possiblilties\\n            temp[index]=0;\\n        }\\n        //Bob loosing case dont add arrows at that index\\n        func(temp,score,numArrows,aliceArrows,index+1);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        vector<int>temp(aliceArrows.size(),0);\\n        \\n        for(int i=0;i<aliceArrows.size();i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        func(temp,0,numArrows,aliceArrows,0);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925467,
                "title": "c-easyto-understand-simple-solution-using-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& alice) {\\n        vector<int> ans;\\n        int maxi=INT_MIN;\\n        int curr;\\n        for(int i=1;i<4096;i++)\\n        {\\n            int num=numArrows;\\n            vector<int> temp(12,0);\\n            for(int j=11;j>=1;j--)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    if(num>alice[j])\\n                    {\\n                        num-=(alice[j]+1);\\n                        temp[j]=(alice[j]+1);\\n                    }\\n                }\\n            }\\n            if(num>0)\\n            for(int j=1;j<12;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    temp[j]+=num;\\n                    break;\\n                }\\n            }\\n            curr=0;\\n            for(int i=1;i<12;i++)\\n            {\\n                if(temp[i]>alice[i])\\n                {\\n                    curr+=i;\\n                }\\n            }\\n            if(curr>maxi)\\n            {\\n                maxi=curr;\\n                ans=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& alice) {\\n        vector<int> ans;\\n        int maxi=INT_MIN;\\n        int curr;\\n        for(int i=1;i<4096;i++)\\n        {\\n            int num=numArrows;\\n            vector<int> temp(12,0);\\n            for(int j=11;j>=1;j--)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    if(num>alice[j])\\n                    {\\n                        num-=(alice[j]+1);\\n                        temp[j]=(alice[j]+1);\\n                    }\\n                }\\n            }\\n            if(num>0)\\n            for(int j=1;j<12;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    temp[j]+=num;\\n                    break;\\n                }\\n            }\\n            curr=0;\\n            for(int i=1;i<12;i++)\\n            {\\n                if(temp[i]>alice[i])\\n                {\\n                    curr+=i;\\n                }\\n            }\\n            if(curr>maxi)\\n            {\\n                maxi=curr;\\n                ans=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896944,
                "title": "brute-forcing-all-the-possible-mask",
                "content": "```\\n\\n// Just Brute Force the val for all possible masks and find out the best mask \\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] arr) {\\n        \\n        int maxMask =0;\\n        int maxVal =0;\\n        for(int mask =0; mask<=(1<<12);mask++)\\n        {\\n            int total = numArrows;\\n            int val =0;\\n           \\n                for(int i=0;i<12;i++)\\n                {\\n                    \\n                    if(((mask>>i)&1)==1)\\n                    {\\n                        total -= (arr[i]+1);\\n                        val +=i;\\n                    }\\n                }\\n                  \\n            \\n            if(total>=0)\\n            {\\n                \\n                if(maxVal<=val)\\n                {\\n                    maxVal = val;\\n                    maxMask = mask;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        int ans[] = new int[12];\\n        int totalval =0;\\n        for(int i=0;i<12;i++)\\n        {\\n            \\n            if(((maxMask>>i)&1)==1)\\n            {\\n                 ans[i] = arr[i]+1;\\n                totalval+=ans[i];\\n            }\\n           \\n        }\\n    \\n        ans[0]+=(numArrows-totalval);\\n        // This line just adds any extra arrows remaining after getting optimal masks\\n        return ans;\\n    }\\n}\\n``",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "class Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] arr) {\\n        \\n        int maxMask =0;\\n        int maxVal =0;\\n        for(int mask =0; mask<=(1<<12);mask++)\\n        {\\n            int total = numArrows;\\n            int val =0;\\n           \\n                for(int i=0;i<12;i++)\\n                {\\n                    \\n                    if(((mask>>i)&1)==1)\\n                    {\\n                        total -= (arr[i]+1);\\n                        val +=i;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1895159,
                "title": "c-clean-code-backtracking",
                "content": "```\\nclass Solution \\n{\\n    vector<int> bobArrows;\\n    int maxBobScore = 0;\\npublic:\\n    \\n    void backtrack(vector<int> &aliceArrows, int idx, int numArrows,int currBobScore,vector<int> &currBobArrows){\\n        \\n        if(idx == aliceArrows.size() or numArrows == 0){\\n            \\n            if(currBobScore > maxBobScore){\\n                bobArrows = currBobArrows;\\n                maxBobScore = currBobScore;\\n            }\\n            \\n            return ;\\n        }\\n        \\n        if(numArrows > aliceArrows[idx]){\\n            \\n            currBobArrows[idx] = aliceArrows[idx] + 1;\\n            backtrack(aliceArrows,idx+1,numArrows-currBobArrows[idx],currBobScore+idx,currBobArrows);\\n            currBobArrows[idx] = 0;\\n        }\\n        \\n        backtrack(aliceArrows,idx + 1, numArrows, currBobScore,currBobArrows);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        \\n        vector<int> currBobArrows(12,0);\\n        \\n        backtrack(aliceArrows,0,numArrows,0,currBobArrows);\\n        \\n        int countBobArrows = accumulate(bobArrows.begin(), bobArrows.end(),0);\\n        \\n        if(countBobArrows < numArrows)\\n            bobArrows.back() += numArrows - countBobArrows;\\n        \\n        return bobArrows;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution \\n{\\n    vector<int> bobArrows;\\n    int maxBobScore = 0;\\npublic:\\n    \\n    void backtrack(vector<int> &aliceArrows, int idx, int numArrows,int currBobScore,vector<int> &currBobArrows){\\n        \\n        if(idx == aliceArrows.size() or numArrows == 0){\\n            \\n            if(currBobScore > maxBobScore){\\n                bobArrows = currBobArrows;\\n                maxBobScore = currBobScore;\\n            }\\n            \\n            return ;\\n        }\\n        \\n        if(numArrows > aliceArrows[idx]){\\n            \\n            currBobArrows[idx] = aliceArrows[idx] + 1;\\n            backtrack(aliceArrows,idx+1,numArrows-currBobArrows[idx],currBobScore+idx,currBobArrows);\\n            currBobArrows[idx] = 0;\\n        }\\n        \\n        backtrack(aliceArrows,idx + 1, numArrows, currBobScore,currBobArrows);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        \\n        vector<int> currBobArrows(12,0);\\n        \\n        backtrack(aliceArrows,0,numArrows,0,currBobArrows);\\n        \\n        int countBobArrows = accumulate(bobArrows.begin(), bobArrows.end(),0);\\n        \\n        if(countBobArrows < numArrows)\\n            bobArrows.back() += numArrows - countBobArrows;\\n        \\n        return bobArrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882605,
                "title": "c-iterating-over-all-masks-and-updating-the-answer",
                "content": "I have iterated over all possible masks and updated the resultant array .the solution itself is self explanatory lastly I have added the remaning arrows to score 0 with bob as they won\\'t contribute anything to the answer .\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& a) {\\n        int ans =0 ;\\n        vector <int> res;\\n        \\n        for( int i = 0 ; i <= ( 1 << 12 ) - 1 ; i++ )\\n        {\\n            int req_arrows = 0 , temp_ans =0 ;\\n            vector <int> dummy;\\n            for ( int j  = 0; j <= 11 ; j++ )\\n            {\\n                if( i & ( 1ll << j ) )\\n                {\\n                    req_arrows += a[j]+1; \\n                    dummy.push_back(a[j] + 1);\\n                    temp_ans += j;\\n                }\\n                else\\n                {\\n                    dummy.push_back(0);\\n                }\\n            }\\n            if( req_arrows <= n )\\n            {\\n                if( ans <  temp_ans)\\n                {\\n                    res = dummy;\\n                    ans = temp_ans;\\n                }\\n            }\\n        }\\n        res[0] += n - accumulate(res.begin() , res.end() , 0);\\n        return res;\\n    }\\n};\\n```\\n\\nDo ask in comments if u find anything unclear",
                "solutionTags": [
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& a) {\\n        int ans =0 ;\\n        vector <int> res;\\n        \\n        for( int i = 0 ; i <= ( 1 << 12 ) - 1 ; i++ )\\n        {\\n            int req_arrows = 0 , temp_ans =0 ;\\n            vector <int> dummy;\\n            for ( int j  = 0; j <= 11 ; j++ )\\n            {\\n                if( i & ( 1ll << j ) )\\n                {\\n                    req_arrows += a[j]+1; \\n                    dummy.push_back(a[j] + 1);\\n                    temp_ans += j;\\n                }\\n                else\\n                {\\n                    dummy.push_back(0);\\n                }\\n            }\\n            if( req_arrows <= n )\\n            {\\n                if( ans <  temp_ans)\\n                {\\n                    res = dummy;\\n                    ans = temp_ans;\\n                }\\n            }\\n        }\\n        res[0] += n - accumulate(res.begin() , res.end() , 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874300,
                "title": "my-java-backtrack-solution-always-consider-for-2-choice-take-or-skip",
                "content": "```\\nclass Solution {\\n    private int pointForBob = 0;\\n    private int [] bobArrows = new int [12];\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int length = aliceArrows.length;\\n        int [] bob = new int [length];\\n        // in my opninon we have two options to consider\\n        // we can either shoot at a section or, we can skip and continue to the next section\\n        // in hope of finding the optimal score\\n        // backtrack and try to find the optimal\\n        backtrack(aliceArrows, bob, 11, 0, numArrows); // we start from back\\n        return bobArrows;\\n    }\\n    \\n    public void backtrack(int [] alice, int [] bob, int pos, int currentMax, int arrows) {\\n        if (pos < 0 || arrows <= 0) {\\n            if (arrows > 0) {\\n                bob[0] += arrows;\\n            }\\n            if (currentMax > pointForBob) {\\n                // we found a better result with better score card\\n                // so copy that\\n                pointForBob = currentMax;\\n                bobArrows = bob.clone();\\n            }\\n            return;\\n        }\\n        \\n        // two options as said\\n        // consider the current section point and move onto the next one\\n        if (arrows >= alice[pos] + 1) {\\n            bob[pos] = alice[pos] + 1;\\n            backtrack(alice, bob, pos - 1, currentMax + pos, arrows - alice[pos] - 1);\\n            bob[pos] = 0;\\n        }\\n        // other option is to just skip our current choice\\n        backtrack(alice, bob, pos - 1, currentMax, arrows);\\n        bob[pos] = 0;\\n    }\\n}\\n\\n// O(2 ^ 12)\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int pointForBob = 0;\\n    private int [] bobArrows = new int [12];\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int length = aliceArrows.length;\\n        int [] bob = new int [length];\\n        // in my opninon we have two options to consider\\n        // we can either shoot at a section or, we can skip and continue to the next section\\n        // in hope of finding the optimal score\\n        // backtrack and try to find the optimal\\n        backtrack(aliceArrows, bob, 11, 0, numArrows); // we start from back\\n        return bobArrows;\\n    }\\n    \\n    public void backtrack(int [] alice, int [] bob, int pos, int currentMax, int arrows) {\\n        if (pos < 0 || arrows <= 0) {\\n            if (arrows > 0) {\\n                bob[0] += arrows;\\n            }\\n            if (currentMax > pointForBob) {\\n                // we found a better result with better score card\\n                // so copy that\\n                pointForBob = currentMax;\\n                bobArrows = bob.clone();\\n            }\\n            return;\\n        }\\n        \\n        // two options as said\\n        // consider the current section point and move onto the next one\\n        if (arrows >= alice[pos] + 1) {\\n            bob[pos] = alice[pos] + 1;\\n            backtrack(alice, bob, pos - 1, currentMax + pos, arrows - alice[pos] - 1);\\n            bob[pos] = 0;\\n        }\\n        // other option is to just skip our current choice\\n        backtrack(alice, bob, pos - 1, currentMax, arrows);\\n        bob[pos] = 0;\\n    }\\n}\\n\\n// O(2 ^ 12)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871465,
                "title": "c-backtracking",
                "content": "```\\n\\tpublic int[] MaximumBobPoints(int numArrows, int[] aliceArrows) {\\n        (int[] arrows, int score) bestAttempt = (new int[aliceArrows.Length], 0);\\n        (int[] arrows, int numArrows) alice = (aliceArrows, numArrows);\\n        (int[] arrows, int numArrows, int score) bob = (new int[aliceArrows.Length], 0, 0);\\n        Backtracking(ref bestAttempt, alice, bob, 1);\\n        return bestAttempt.arrows;\\n    }\\n    \\n    void Backtracking(ref (int[] arrows, int score) bestAttempt, (int[] arrows, int numArrows) alice, (int[] arrows, int numArrows, int score) bob, int index) {\\n        if (bob.numArrows <= alice.numArrows && bob.score > bestAttempt.score) { // update best attempt\\n            bestAttempt.score = bob.score;\\n            bob.arrows.CopyTo(bestAttempt.arrows, 0);\\n            bestAttempt.arrows[0] = alice.numArrows-bob.numArrows; // add unused arrows if required\\n        }\\n        for (int i=index; i<alice.arrows.Length; i++) {\\n            bob.arrows[i] = alice.arrows[i]+1;\\n            bob.numArrows += bob.arrows[i];\\n            bob.score += i;\\n            Backtracking(ref bestAttempt, alice, bob, i+1);\\n            bob.score -= i;\\n            bob.numArrows -= bob.arrows[i];\\n            bob.arrows[i] = 0;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n\\tpublic int[] MaximumBobPoints(int numArrows, int[] aliceArrows) {\\n        (int[] arrows, int score) bestAttempt = (new int[aliceArrows.Length], 0);\\n        (int[] arrows, int numArrows) alice = (aliceArrows, numArrows);\\n        (int[] arrows, int numArrows, int score) bob = (new int[aliceArrows.Length], 0, 0);\\n        Backtracking(ref bestAttempt, alice, bob, 1);\\n        return bestAttempt.arrows;\\n    }\\n    \\n    void Backtracking(ref (int[] arrows, int score) bestAttempt, (int[] arrows, int numArrows) alice, (int[] arrows, int numArrows, int score) bob, int index) {\\n        if (bob.numArrows <= alice.numArrows && bob.score > bestAttempt.score) { // update best attempt\\n            bestAttempt.score = bob.score;\\n            bob.arrows.CopyTo(bestAttempt.arrows, 0);\\n            bestAttempt.arrows[0] = alice.numArrows-bob.numArrows; // add unused arrows if required\\n        }\\n        for (int i=index; i<alice.arrows.Length; i++) {\\n            bob.arrows[i] = alice.arrows[i]+1;\\n            bob.numArrows += bob.arrows[i];\\n            bob.score += i;\\n            Backtracking(ref bestAttempt, alice, bob, i+1);\\n            bob.score -= i;\\n            bob.numArrows -= bob.arrows[i];\\n            bob.arrows[i] = 0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869794,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>ans;\\n        \\n        //total 2^12 choice to select the answers one maximum satisfying all condition will give the answer\\n        int answer1=0;\\n        for(int i=0; i<(1<<12); i++)\\n        {\\n            int cnt=i;\\n            //total count needed for this combination if less than numArrows then it can be the answer\\n            int tot=0,answer=0;\\n            vector<int>v(12,0);\\n            for(int j=0; j<12; j++)\\n            {\\n                if(cnt&(1<<j))\\n                {\\n                    tot+=aliceArrows[j]+1;\\n                    answer+=j;\\n                    v[j]=aliceArrows[j]+1;\\n                }\\n            }\\n            \\n            if(tot<=numArrows)\\n            {\\n                if(answer>answer1)\\n                {\\n                    answer1=answer;\\n                    int val=numArrows-tot;\\n                    v[11]+=val;\\n                    ans=v;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>ans;\\n        \\n        //total 2^12 choice to select the answers one maximum satisfying all condition will give the answer\\n        int answer1=0;\\n        for(int i=0; i<(1<<12); i++)\\n        {\\n            int cnt=i;\\n            //total count needed for this combination if less than numArrows then it can be the answer\\n            int tot=0,answer=0;\\n            vector<int>v(12,0);\\n            for(int j=0; j<12; j++)\\n            {\\n                if(cnt&(1<<j))\\n                {\\n                    tot+=aliceArrows[j]+1;\\n                    answer+=j;\\n                    v[j]=aliceArrows[j]+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1866600,
                "title": "why-bottom-up-approaches-get-tle",
                "content": "The problem is just a simple variation of Knapsack problem, and is done by the Pick-NonPick strategy. However the Bottom Up Solutions get TLE. WHY ?\\n\\nActually , the Bottom Up approach solves each and every subproblem; the approach does not care which \"exact\" subproblems lead to the answer of the bigger problem. Although this is a boon in many cases like \"Divide an array such that sum of the smaller arrays created have a specific difference or minimum difference\", it has the disadvantage of solving \"unncessary subproblems\".\\n\\nIn this problem, for when numArrays is a big number like 5000,\\nthe bottom up approach solves all the (5000 * 12) subproblems, but\\nthe top down approcah solves way less than (5000 * 12) subproblems; it solves only those that are needed for calculating the maxScore using (5000 arrows and  for 12 targets).\\n\\nSo, the bottom up approach in these scenarios consume a lot of time calculating subproblems which are \"unnecessary for calculating the result of the biggger subproblem\". Hence the TLE !!!!\\n\\nLets print our cache and check, whether all subproblems are computed or not.\\n\\n![image](https://assets.leetcode.com/users/images/f2a1addb-877e-46a4-bad7-fede094c8d95_1647765418.6035116.png)\\n\\n\\nThe subproblems whose maxScores are \"-1\";  they did not get calculated. Hence saves a lot of time.\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxScoreCache= Solution.createCache(12,numArrows); targets= 12\\n        \\n        remainingTargets= targets;arrowCount= numArrows\\n        Solution.calculateMaxScore(remainingTargets,arrowCount,aliceArrows,maxScoreCache)\\n        bobArrows= Solution.getBobArrows(maxScoreCache,aliceArrows,targets,numArrows)\\n        return bobArrows\\n    \\n    @staticmethod\\n    def calculateMaxScore(remainingTargets,arrowCount,aliceArrows,maxScoreCache):\\n        \\n        \"\"\"\\n            The function calculates maxScore that Bob can earn\\n            using \\'arrowCount\\' arrows and from \\'remainingTargets\\' targets\\n        \"\"\"\\n        \\n        if remainingTargets== 0 or arrowCount== 0:\\n            maxScore= 0; maxScoreCache[remainingTargets][arrowCount]= maxScore; return maxScore\\n        \\n        if maxScoreCache[remainingTargets][arrowCount]!= -1: return maxScoreCache[remainingTargets][arrowCount]\\n        \\n        targetIndex= remainingTargets-1\\n        # Can this target be hit optimally; If yes then lets check \\n        # Which provides max score : hitting the target or leaving the target\\n\\n        if arrowCount> aliceArrows[targetIndex]: \\n            # Hitting may result in getting max Score\\n\\n            # Hit\\n            currPointsHit= targetIndex\\n            currPointsHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount-(aliceArrows[targetIndex]+1),aliceArrows,maxScoreCache)\\n\\n            #Not Hit\\n            currPointsNotHit= 0\\n            currPointsNotHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount,aliceArrows,maxScoreCache)\\n\\n            currPoints= max(currPointsHit,currPointsNotHit)\\n\\n        #  We may hit the target otherwise ,but the arrows will be wasted\\n\\t\\t#  If the target can\\'t be hit optimally. then lets not hit\\n        else:\\n            # We exclude hitting the target\\n            currPointsNotHit= 0\\n            currPointsNotHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount,aliceArrows,maxScoreCache)\\n\\n            currPoints= currPointsNotHit\\n\\n        maxScoreCache[remainingTargets][arrowCount]= currPoints\\n        return maxScoreCache[remainingTargets][arrowCount]\\n\\n    @staticmethod\\n    def createCache(ROWS,COLS):\\n        cache= list()\\n        for _ in range(ROWS+1):cache.append([-1]*(COLS+1))\\n        return cache\\n                    \\n    @staticmethod\\n    def getBobArrows(cache,aliceArrows,targets,numArrows):\\n        remainingTargets= targets; arrowCount= numArrows\\n        \\n        bobArrows= [0]*targets\\n        while remainingTargets>0 and arrowCount>0:\\n            maxArrows= cache[remainingTargets][numArrows]\\n            targetIndex= remainingTargets-1\\n            \\n            if arrowCount> aliceArrows[targetIndex]:\\n                currPointsHit= targetIndex\\n                currPointsHit+= cache[remainingTargets-1][arrowCount-(aliceArrows[targetIndex]+1)]\\n                \\n                currPointsNotHit= 0\\n                currPointsNotHit+= cache[remainingTargets-1][arrowCount]\\n                \\n                if cache[remainingTargets][arrowCount]== currPointsHit:\\n                    \\n                    bobArrows[targetIndex]= (aliceArrows[targetIndex]+1) if remainingTargets!=1 else arrowCount\\n                    remainingTargets-= 1; arrowCount-= bobArrows[targetIndex]\\n                else: \\n                    if remainingTargets== 1:bobArrows[targetIndex]= arrowCount\\n                    remainingTargets-= 1\\n                    \\n            else:\\n                if remainingTargets== 1:bobArrows[targetIndex]= arrowCount\\n                remainingTargets-= 1\\n                    \\n        return bobArrows\\n                \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxScoreCache= Solution.createCache(12,numArrows); targets= 12\\n        \\n        remainingTargets= targets;arrowCount= numArrows\\n        Solution.calculateMaxScore(remainingTargets,arrowCount,aliceArrows,maxScoreCache)\\n        bobArrows= Solution.getBobArrows(maxScoreCache,aliceArrows,targets,numArrows)\\n        return bobArrows\\n    \\n    @staticmethod\\n    def calculateMaxScore(remainingTargets,arrowCount,aliceArrows,maxScoreCache):\\n        \\n        \"\"\"\\n            The function calculates maxScore that Bob can earn\\n            using \\'arrowCount\\' arrows and from \\'remainingTargets\\' targets\\n        \"\"\"\\n        \\n        if remainingTargets== 0 or arrowCount== 0:\\n            maxScore= 0; maxScoreCache[remainingTargets][arrowCount]= maxScore; return maxScore\\n        \\n        if maxScoreCache[remainingTargets][arrowCount]!= -1: return maxScoreCache[remainingTargets][arrowCount]\\n        \\n        targetIndex= remainingTargets-1\\n        # Can this target be hit optimally; If yes then lets check \\n        # Which provides max score : hitting the target or leaving the target\\n\\n        if arrowCount> aliceArrows[targetIndex]: \\n            # Hitting may result in getting max Score\\n\\n            # Hit\\n            currPointsHit= targetIndex\\n            currPointsHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount-(aliceArrows[targetIndex]+1),aliceArrows,maxScoreCache)\\n\\n            #Not Hit\\n            currPointsNotHit= 0\\n            currPointsNotHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount,aliceArrows,maxScoreCache)\\n\\n            currPoints= max(currPointsHit,currPointsNotHit)\\n\\n        #  We may hit the target otherwise ,but the arrows will be wasted\\n\\t\\t#  If the target can\\'t be hit optimally. then lets not hit\\n        else:\\n            # We exclude hitting the target\\n            currPointsNotHit= 0\\n            currPointsNotHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount,aliceArrows,maxScoreCache)\\n\\n            currPoints= currPointsNotHit\\n\\n        maxScoreCache[remainingTargets][arrowCount]= currPoints\\n        return maxScoreCache[remainingTargets][arrowCount]\\n\\n    @staticmethod\\n    def createCache(ROWS,COLS):\\n        cache= list()\\n        for _ in range(ROWS+1):cache.append([-1]*(COLS+1))\\n        return cache\\n                    \\n    @staticmethod\\n    def getBobArrows(cache,aliceArrows,targets,numArrows):\\n        remainingTargets= targets; arrowCount= numArrows\\n        \\n        bobArrows= [0]*targets\\n        while remainingTargets>0 and arrowCount>0:\\n            maxArrows= cache[remainingTargets][numArrows]\\n            targetIndex= remainingTargets-1\\n            \\n            if arrowCount> aliceArrows[targetIndex]:\\n                currPointsHit= targetIndex\\n                currPointsHit+= cache[remainingTargets-1][arrowCount-(aliceArrows[targetIndex]+1)]\\n                \\n                currPointsNotHit= 0\\n                currPointsNotHit+= cache[remainingTargets-1][arrowCount]\\n                \\n                if cache[remainingTargets][arrowCount]== currPointsHit:\\n                    \\n                    bobArrows[targetIndex]= (aliceArrows[targetIndex]+1) if remainingTargets!=1 else arrowCount\\n                    remainingTargets-= 1; arrowCount-= bobArrows[targetIndex]\\n                else: \\n                    if remainingTargets== 1:bobArrows[targetIndex]= arrowCount\\n                    remainingTargets-= 1\\n                    \\n            else:\\n                if remainingTargets== 1:bobArrows[targetIndex]= arrowCount\\n                remainingTargets-= 1\\n                    \\n        return bobArrows\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866001,
                "title": "just-dp-c",
                "content": "I implemented the solution with just dynamic programming. I use dp[i][j] to store the maximum value that Bob can achieve starting from 0th target up to (i-1)th one with j arrows. \\nFor each target, Bob can either:\\n1. win the current target (i-1) and get the maximum points in the previous targets with the the number of arrows remaining after the win , i.e. **dp[i-1][remaing arrows after this win]**\\n2. lose the current target and get the maximum points in the previous targets with all the arrows, i.e. **dp[i-1][all arrows]**\\n\\nWe will then check which is larger and store the value.\\n\\n*Since the question requries us to give the combination that gives that maximum points and the maximum points attainable is 66, which is less than 7 bits, I will use the bits after the 7th to store a 12-bit pattern indicating whether Bob wins in each target.*\\n```\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int dp[13][numArrows+1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i < 13; i ++){\\n            for(int j = 1; j <= numArrows; j++){\\n                dp[i][j] = dp[i-1][j];\\n\\t\\t\\t\\t// check whether winning in the current target yields a higher value\\n                if ((j-aliceArrows[i-1] >= 1) && ((dp[i-1][j] & 127) < (i - 1 + (dp[i-1][j-aliceArrows[i-1] - 1]) & 127) )){\\n                    dp[i][j] = i - 1 + dp[i-1][j-aliceArrows[i-1] - 1] + (1 << (i + 7));\\n                }\\n            }\\n        }\\n        vector<int> res(12);\\n        int total = 0;\\n\\t\\t// decode the bits\\n        for(int i = 0; i < 12; i++){\\n            if(dp[12][numArrows] >> (i + 8) & 1){\\n                res[i] = aliceArrows[i]+1;\\n                total += res[i];\\n            }\\n        }\\n\\t\\t// deal with the arrows that are not used\\n        if(total != numArrows){\\n            res[0] += numArrows - total;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNote that after decoding the maximum value, we check for the total number of arrows Bob used to shoot in order to get the maximum points. If the total is less than the number of arrows provided, we simply put the remaining in the first target(that does not affect the result).",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int dp[13][numArrows+1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i < 13; i ++){\\n            for(int j = 1; j <= numArrows; j++){\\n                dp[i][j] = dp[i-1][j];\\n\\t\\t\\t\\t// check whether winning in the current target yields a higher value\\n                if ((j-aliceArrows[i-1] >= 1) && ((dp[i-1][j] & 127) < (i - 1 + (dp[i-1][j-aliceArrows[i-1] - 1]) & 127) )){\\n                    dp[i][j] = i - 1 + dp[i-1][j-aliceArrows[i-1] - 1] + (1 << (i + 7));\\n                }\\n            }\\n        }\\n        vector<int> res(12);\\n        int total = 0;\\n\\t\\t// decode the bits\\n        for(int i = 0; i < 12; i++){\\n            if(dp[12][numArrows] >> (i + 8) & 1){\\n                res[i] = aliceArrows[i]+1;\\n                total += res[i];\\n            }\\n        }\\n\\t\\t// deal with the arrows that are not used\\n        if(total != numArrows){\\n            res[0] += numArrows - total;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865910,
                "title": "simple-recursive-solution-o-2-12",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nvoid solve(int i, int n,vector<int>& a, vector<int>& now, vector<int> &ans, int snow, int &smax ){ \\n        if (i>=11)\\n        {\\n            // put all left over arrows in last section\\n            now[11]=n;\\n            if (n<=a[i]){\\n                if (snow>smax)\\n                {\\n                    ans=now;\\n                    smax=snow;\\n                }\\n            \\n            }else{ \\n                if (snow+11>smax)\\n                {\\n                    ans=now;\\n                    smax=snow+11;\\n                }\\n                \\n            }\\n            \\n            return;\\n        }\\n        \\n        // option 1 -- we dont care for this section\\n        now[i]=0;\\n        solve(i+1,n,a,now,ans,snow,smax);\\n        \\n        // option 2 -- we try to win this section if we have sufficient arrows\\n        if (n>a[i]){\\n            now[i]=a[i]+1;\\n            solve(i+1,n-(a[i]+1),a,now,ans,snow+i,smax);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& aliceArrows) {\\n        int snow=0,smax=0;\\n        // snow is score now\\n        // smax is max score till now\\n        vector<int> now(12); // temp array to store values\\n        vector<int> ans(12); // final ans array\\n        solve(0,n,aliceArrows,now,ans,0,smax);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nvoid solve(int i, int n,vector<int>& a, vector<int>& now, vector<int> &ans, int snow, int &smax ){ \\n        if (i>=11)\\n        {\\n            // put all left over arrows in last section\\n            now[11]=n;\\n            if (n<=a[i]){\\n                if (snow>smax)\\n                {\\n                    ans=now;\\n                    smax=snow;\\n                }\\n            \\n            }else{ \\n                if (snow+11>smax)\\n                {\\n                    ans=now;\\n                    smax=snow+11;\\n                }\\n                \\n            }\\n            \\n            return;\\n        }\\n        \\n        // option 1 -- we dont care for this section\\n        now[i]=0;\\n        solve(i+1,n,a,now,ans,snow,smax);\\n        \\n        // option 2 -- we try to win this section if we have sufficient arrows\\n        if (n>a[i]){\\n            now[i]=a[i]+1;\\n            solve(i+1,n-(a[i]+1),a,now,ans,snow+i,smax);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& aliceArrows) {\\n        int snow=0,smax=0;\\n        // snow is score now\\n        // smax is max score till now\\n        vector<int> now(12); // temp array to store values\\n        vector<int> ans(12); // final ans array\\n        solve(0,n,aliceArrows,now,ans,0,smax);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865879,
                "title": "c-bitmasking-noticing-from-size-easy",
                "content": "So, Possible sequence of any pattern is 2^n-1.\\nEx- ABC -> ABC, AC, BC, BA, AB, A,B,C  - 7 \\n\\nSo, here one thing is to is notice small size i.e. 12 of Target array. So, easily we can form all be possible sequence of 2^12 -1== 4096-1. And check for the maximum score that we can get for Bob. \\n\\nSometimes, we get the max but not all numsArrow is used. So, we simply add all left in 0th index of our answer vector.(That won\\'t change our answer so.)  \\n\\n```\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n\\n\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        long long s= 0;\\n        \\n        long long mx=INT_MIN;\\n        vector<int> ans(12); \\n        \\n        rep(i, (1<<12)+1){\\n            long long ns=0, flag=0, g=numArrows;\\n            \\n            rep(j,12){\\n                \\n                if((i & (1<<j))) {\\n                    long long x= aliceArrows[j]+1;\\n                          g-=x;\\n                          ns+=j;\\n                        if(g<0) { flag=1; break;}\\n\\n                }\\n            }\\n            \\n            if(flag==0 && ns>mx ){\\n                rep(k,12) ans[k]=0;\\n                rep(j,12){\\n                     if((i & (1<<j))){\\n                         ans[j]=  aliceArrows[j]+1;\\n                     }\\n                }\\n                if(g>0) ans[0]+=g;\\n                mx=ns;\\n            }\\n         }\\n        \\n        return ans;\\n        \\n    }\\n\\t",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "So, Possible sequence of any pattern is 2^n-1.\\nEx- ABC -> ABC, AC, BC, BA, AB, A,B,C  - 7 \\n\\nSo, here one thing is to is notice small size i.e. 12 of Target array. So, easily we can form all be possible sequence of 2^12 -1== 4096-1. And check for the maximum score that we can get for Bob. \\n\\nSometimes, we get the max but not all numsArrow is used. So, we simply add all left in 0th index of our answer vector.(That won\\'t change our answer so.)  \\n\\n```\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n\\n\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        long long s= 0;\\n        \\n        long long mx=INT_MIN;\\n        vector<int> ans(12); \\n        \\n        rep(i, (1<<12)+1){\\n            long long ns=0, flag=0, g=numArrows;\\n            \\n            rep(j,12){\\n                \\n                if((i & (1<<j))) {\\n                    long long x= aliceArrows[j]+1;\\n                          g-=x;\\n                          ns+=j;\\n                        if(g<0) { flag=1; break;}\\n\\n                }\\n            }\\n            \\n            if(flag==0 && ns>mx ){\\n                rep(k,12) ans[k]=0;\\n                rep(j,12){\\n                     if((i & (1<<j))){\\n                         ans[j]=  aliceArrows[j]+1;\\n                     }\\n                }\\n                if(g>0) ans[0]+=g;\\n                mx=ns;\\n            }\\n         }\\n        \\n        return ans;\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1865850,
                "title": "c-dp-recursive-memorization-path-print",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int n = 12;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int arrows, vector<int>& aliceArrows){\\n        if(pos >= n){\\n            return 0;\\n        }\\n        if(arrows == 0){\\n            return 0;\\n        }\\n        int &ret = dp[pos][arrows];\\n        if(ret != -1){\\n            return ret;\\n        }\\n        int taken = 0, notTaken = 0;\\n        if(aliceArrows[pos] < arrows){\\n            taken = pos + solve(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows);\\n        }\\n        notTaken = solve(pos + 1, arrows, aliceArrows);\\n        return ret = max(taken, notTaken);\\n    }\\n    void path(int pos, int arrows, vector<int>& aliceArrows, vector<int>& result){\\n        if(pos >= n || arrows == 0){\\n            return;\\n        }\\n        int taken = 0, notTaken = 0;\\n        if(aliceArrows[pos] < arrows){\\n            taken = pos + solve(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows);\\n        }\\n        notTaken = solve(pos + 1, arrows, aliceArrows);\\n        if(taken > notTaken){\\n            result[pos] = aliceArrows[pos] + 1;\\n            path(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows, result);\\n        }\\n        else{\\n            path(pos + 1, arrows, aliceArrows, result);\\n        }\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        dp.resize(n + 1, vector<int>(numArrows + 1, -1));\\n        int ans = solve(0, numArrows, aliceArrows);\\n        vector<int> result(n, 0);\\n        path(0, numArrows, aliceArrows, result);\\n        int res = accumulate(result.begin(), result.end(), 0);\\n        result[0] += numArrows - res;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int n = 12;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int arrows, vector<int>& aliceArrows){\\n        if(pos >= n){\\n            return 0;\\n        }\\n        if(arrows == 0){\\n            return 0;\\n        }\\n        int &ret = dp[pos][arrows];\\n        if(ret != -1){\\n            return ret;\\n        }\\n        int taken = 0, notTaken = 0;\\n        if(aliceArrows[pos] < arrows){\\n            taken = pos + solve(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows);\\n        }\\n        notTaken = solve(pos + 1, arrows, aliceArrows);\\n        return ret = max(taken, notTaken);\\n    }\\n    void path(int pos, int arrows, vector<int>& aliceArrows, vector<int>& result){\\n        if(pos >= n || arrows == 0){\\n            return;\\n        }\\n        int taken = 0, notTaken = 0;\\n        if(aliceArrows[pos] < arrows){\\n            taken = pos + solve(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows);\\n        }\\n        notTaken = solve(pos + 1, arrows, aliceArrows);\\n        if(taken > notTaken){\\n            result[pos] = aliceArrows[pos] + 1;\\n            path(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows, result);\\n        }\\n        else{\\n            path(pos + 1, arrows, aliceArrows, result);\\n        }\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        dp.resize(n + 1, vector<int>(numArrows + 1, -1));\\n        int ans = solve(0, numArrows, aliceArrows);\\n        vector<int> result(n, 0);\\n        path(0, numArrows, aliceArrows, result);\\n        int res = accumulate(result.begin(), result.end(), 0);\\n        result[0] += numArrows - res;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865726,
                "title": "python-dp-solution-got-tle-with-top-down-but-not-with-memoization",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[-1]*(numArrows+1) for i in range(12)]\\n        for i in range(12):\\n            dp[i][0] = 0\\n        for i in range(numArrows+1):\\n            dp[0][i] = 0\\n        def rec(i,n):\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            if aliceArrows[i]+1 <= n:\\n                dp[i][n] = max(rec(i-1,n),rec(i-1,n-aliceArrows[i]-1)+i)\\n            else:\\n                dp[i][n] = rec(i-1,n)\\n            return dp[i][n]\\n        rec(11,numArrows)\\n        i,j = 11, numArrows\\n        ans = []\\n        while i > 0:\\n            if dp[i][j] == dp[i-1][j]:\\n                ans.append(0)\\n            else:\\n                ans.append(aliceArrows[i]+1)\\n                j -= aliceArrows[i]+1\\n            i-=1\\n        ans.append(0)\\n        ans = ans[::-1]\\n        x = numArrows-sum(ans)\\n        if x > 0:\\n            ans[0] += x\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[-1]*(numArrows+1) for i in range(12)]\\n        for i in range(12):\\n            dp[i][0] = 0\\n        for i in range(numArrows+1):\\n            dp[0][i] = 0\\n        def rec(i,n):\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            if aliceArrows[i]+1 <= n:\\n                dp[i][n] = max(rec(i-1,n),rec(i-1,n-aliceArrows[i]-1)+i)\\n            else:\\n                dp[i][n] = rec(i-1,n)\\n            return dp[i][n]\\n        rec(11,numArrows)\\n        i,j = 11, numArrows\\n        ans = []\\n        while i > 0:\\n            if dp[i][j] == dp[i-1][j]:\\n                ans.append(0)\\n            else:\\n                ans.append(aliceArrows[i]+1)\\n                j -= aliceArrows[i]+1\\n            i-=1\\n        ans.append(0)\\n        ans = ans[::-1]\\n        x = numArrows-sum(ans)\\n        if x > 0:\\n            ans[0] += x\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865702,
                "title": "python3-backtrack-beats-100",
                "content": "Main idea here is that you simulate scenarios where either Bob beats Alice or Bob loses to Alice.\\nSince there are only 12 rounds total, that\\'s 2^12 calls, or 4096 which is a rather trivially number.\\nThe 10^5 upper bound on numArrows is not crucial to the runtime since we can easily calculate number of arrows Bob needs to beat Alice in O(1) (just one more than Alice)\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        # either beat alice here, or dont\\n        rounds = len(aliceArrows)\\n        \\n        def backtrack(index, remaining, cur_max, cur_game):\\n            if index < 0 or remaining == 0:\\n                nonlocal max_points, bob_arrows\\n                if cur_max > max_points:\\n                    max_points = cur_max\\n                    bob_arrows = cur_game[:]\\n                    if remaining > 0:\\n                        bob_arrows[0] += remaining\\n                return\\n        \\n            # beat alice\\n            if remaining > aliceArrows[index]:\\n                cur_game[index] = aliceArrows[index] + 1\\n                backtrack(index - 1, remaining - aliceArrows[index] - 1, cur_max + index, cur_game)\\n            \\n            # don\\'t beat alice\\n            cur_game[index] = 0\\n            backtrack(index - 1, remaining, cur_max, cur_game)\\n                    \\n        bob_arrows = [0] * rounds\\n        max_points = 0\\n        backtrack(rounds - 1, numArrows, 0, [0] * rounds)\\n        return bob_arrows",
                "solutionTags": [],
                "code": "Main idea here is that you simulate scenarios where either Bob beats Alice or Bob loses to Alice.\\nSince there are only 12 rounds total, that\\'s 2^12 calls, or 4096 which is a rather trivially number.\\nThe 10^5 upper bound on numArrows is not crucial to the runtime since we can easily calculate number of arrows Bob needs to beat Alice in O(1) (just one more than Alice)\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        # either beat alice here, or dont\\n        rounds = len(aliceArrows)\\n        \\n        def backtrack(index, remaining, cur_max, cur_game):\\n            if index < 0 or remaining == 0:\\n                nonlocal max_points, bob_arrows\\n                if cur_max > max_points:\\n                    max_points = cur_max\\n                    bob_arrows = cur_game[:]\\n                    if remaining > 0:\\n                        bob_arrows[0] += remaining\\n                return\\n        \\n            # beat alice\\n            if remaining > aliceArrows[index]:\\n                cur_game[index] = aliceArrows[index] + 1\\n                backtrack(index - 1, remaining - aliceArrows[index] - 1, cur_max + index, cur_game)\\n            \\n            # don\\'t beat alice\\n            cur_game[index] = 0\\n            backtrack(index - 1, remaining, cur_max, cur_game)\\n                    \\n        bob_arrows = [0] * rounds\\n        max_points = 0\\n        backtrack(rounds - 1, numArrows, 0, [0] * rounds)\\n        return bob_arrows",
                "codeTag": "Java"
            },
            {
                "id": 1865615,
                "title": "python-dp-dfs-with-path-array",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        def dp(numArrows, idx, path):\\n            if numArrows < 0:\\n                return float(\"-inf\"), path\\n            if idx < 0:\\n                return 0, path\\n            \\n            res1, path1 = dp(numArrows, idx-1, path)\\n            res2, path2 = dp(numArrows - (aliceArrows[idx]+1), idx-1, path + [idx])\\n            res2 += idx\\n            if res1 > res2:\\n                res = res1\\n                path = path1\\n            else:\\n                res = res2\\n                path = path2\\n            return res, path\\n        \\n        res, path = dp(numArrows, len(aliceArrows) - 1, [])\\n        bobArr = [0] * 12\\n        for idx in path:\\n            bobArr[idx] = aliceArrows[idx] + 1\\n        if sum(bobArr) < sum(aliceArrows):\\n            bobArr[0] += sum(aliceArrows) - sum(bobArr)\\n        return bobArr",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        def dp(numArrows, idx, path):\\n            if numArrows < 0:\\n                return float(\"-inf\"), path\\n            if idx < 0:\\n                return 0, path\\n            \\n            res1, path1 = dp(numArrows, idx-1, path)\\n            res2, path2 = dp(numArrows - (aliceArrows[idx]+1), idx-1, path + [idx])\\n            res2 += idx\\n            if res1 > res2:\\n                res = res1\\n                path = path1\\n            else:\\n                res = res2\\n                path = path2\\n            return res, path\\n        \\n        res, path = dp(numArrows, len(aliceArrows) - 1, [])\\n        bobArr = [0] * 12\\n        for idx in path:\\n            bobArr[idx] = aliceArrows[idx] + 1\\n        if sum(bobArr) < sum(aliceArrows):\\n            bobArr[0] += sum(aliceArrows) - sum(bobArr)\\n        return bobArr",
                "codeTag": "Java"
            },
            {
                "id": 3465705,
                "title": "simple-recursion-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int mx;\\n    vector<int> ans;\\n    void f(int x, int arrows, vector<int>& aliceArrows, int sum, vector<int> &bobArrows)\\n    {\\n        if(x<0) \\n        {\\n            bobArrows[0]+=arrows;\\n            if(mx<sum)\\n            {\\n                mx=sum;\\n                ans=bobArrows;\\n            }\\n            bobArrows[0]-=arrows;\\n            return;\\n        }\\n        if(arrows>=aliceArrows[x]+1) \\n        {\\n            bobArrows[x]=aliceArrows[x]+1;\\n            f(x-1,arrows-aliceArrows[x]-1,aliceArrows,sum+x,bobArrows);\\n            bobArrows[x]=0;\\n        }\\n        f(x-1,arrows,aliceArrows,sum,bobArrows);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) \\n    {\\n        mx=0;\\n        vector<int> bobArrows(12,0);\\n        f(11,numArrows,aliceArrows,0,bobArrows);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int mx;\\n    vector<int> ans;\\n    void f(int x, int arrows, vector<int>& aliceArrows, int sum, vector<int> &bobArrows)\\n    {\\n        if(x<0) \\n        {\\n            bobArrows[0]+=arrows;\\n            if(mx<sum)\\n            {\\n                mx=sum;\\n                ans=bobArrows;\\n            }\\n            bobArrows[0]-=arrows;\\n            return;\\n        }\\n        if(arrows>=aliceArrows[x]+1) \\n        {\\n            bobArrows[x]=aliceArrows[x]+1;\\n            f(x-1,arrows-aliceArrows[x]-1,aliceArrows,sum+x,bobArrows);\\n            bobArrows[x]=0;\\n        }\\n        f(x-1,arrows,aliceArrows,sum,bobArrows);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) \\n    {\\n        mx=0;\\n        vector<int> bobArrows(12,0);\\n        f(11,numArrows,aliceArrows,0,bobArrows);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030166,
                "title": "c-best-explanation-o-n-dp-aditya-verma-knapsack-variation",
                "content": "\\n\\n# Code\\n```\\n       /*\\n       This problem is just like knapsack problem:\\nnumArrows is like the capacity of the sack.\\neach ith section is like an item whose cost is AliceArrows[i]+1 and value is the number of points associated with the section.\\nthe cost of ith section is AliceArrows[i]+1, because to obtain the points (or \\'value\\') of that section, Bob needs to land atleast one more arrow than Alice in that section.\\n       */\\n\\n       /*\\ndp[i][j]  -> max net value for first i items and j weight\\n\\nif ( j>PriceCurSection)\\n\\tdp[i][j]  = max(dp[i-1][j], dp[i-1][j-PriceCurSection] + pointsCurSection)\\n\\n*/\\n \\nclass Solution {\\npublic:\\n    const int NUM_SECTIONS = 12;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector <int> arrowsRequiredForSection;\\n        for (int numSectionArrowsAlice: aliceArrows) {\\n            arrowsRequiredForSection.push_back(numSectionArrowsAlice+1);\\n        }\\n        \\n        vector <int> sectionPoints;\\n        for (int i=0; i<NUM_SECTIONS; i++) {\\n            sectionPoints.push_back(i);\\n        }\\n        vector<int> optimalShots =  knapsack(numArrows, arrowsRequiredForSection, sectionPoints);\\n        int arrowsUsed = accumulate(optimalShots.begin(), optimalShots.end(), 0);\\n        if (numArrows > arrowsUsed) {\\n            optimalShots[0] += numArrows - arrowsUsed;\\n        }\\n        \\n        return optimalShots;\\n        \\n    }\\n    \\n    vector <int> knapsack(const int capacity, const vector<int>& costs, const vector<int>& itemValues) {\\n                \\n        int numItems = costs.size();\\n        // vector <vector<int>> dp(numItems+1,vector<int>(capacity+1));\\n        // vector <vector<bool>> isCurItemPicked(numItems+1,vector<bool>(capacity+1));\\n        int dp[numItems+1][capacity+1];\\n        bool isCurItemPicked[numItems+1][capacity+1];\\n        memset(dp,0,sizeof(dp));\\n        memset(isCurItemPicked,0,sizeof(isCurItemPicked));\\n        for (int i=1; i<=numItems; i++) {\\n            for (int j=1; j<=capacity; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (j >= costs[i-1]) {\\n                    int valueIfCurItemIsPicked = dp[i-1][j-costs[i-1]] + itemValues[i-1];\\n                    if (valueIfCurItemIsPicked > dp[i][j]) {\\n                        dp[i][j] = valueIfCurItemIsPicked;\\n                        isCurItemPicked[i][j] = true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        vector <int> spent;\\n        int weight = capacity;\\n        for (int i=numItems; i>0; i--) {            \\n            if (isCurItemPicked[i][weight]) {\\n                weight -= costs[i-1];\\n                spent.push_back(costs[i-1]);\\n            } else {\\n                spent.push_back(0);\\n            }\\n        }\\n        reverse(spent.begin(), spent.end());\\n        return spent;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n       /*\\n       This problem is just like knapsack problem:\\nnumArrows is like the capacity of the sack.\\neach ith section is like an item whose cost is AliceArrows[i]+1 and value is the number of points associated with the section.\\nthe cost of ith section is AliceArrows[i]+1, because to obtain the points (or \\'value\\') of that section, Bob needs to land atleast one more arrow than Alice in that section.\\n       */\\n\\n       /*\\ndp[i][j]  -> max net value for first i items and j weight\\n\\nif ( j>PriceCurSection)\\n\\tdp[i][j]  = max(dp[i-1][j], dp[i-1][j-PriceCurSection] + pointsCurSection)\\n\\n*/\\n \\nclass Solution {\\npublic:\\n    const int NUM_SECTIONS = 12;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector <int> arrowsRequiredForSection;\\n        for (int numSectionArrowsAlice: aliceArrows) {\\n            arrowsRequiredForSection.push_back(numSectionArrowsAlice+1);\\n        }\\n        \\n        vector <int> sectionPoints;\\n        for (int i=0; i<NUM_SECTIONS; i++) {\\n            sectionPoints.push_back(i);\\n        }\\n        vector<int> optimalShots =  knapsack(numArrows, arrowsRequiredForSection, sectionPoints);\\n        int arrowsUsed = accumulate(optimalShots.begin(), optimalShots.end(), 0);\\n        if (numArrows > arrowsUsed) {\\n            optimalShots[0] += numArrows - arrowsUsed;\\n        }\\n        \\n        return optimalShots;\\n        \\n    }\\n    \\n    vector <int> knapsack(const int capacity, const vector<int>& costs, const vector<int>& itemValues) {\\n                \\n        int numItems = costs.size();\\n        // vector <vector<int>> dp(numItems+1,vector<int>(capacity+1));\\n        // vector <vector<bool>> isCurItemPicked(numItems+1,vector<bool>(capacity+1));\\n        int dp[numItems+1][capacity+1];\\n        bool isCurItemPicked[numItems+1][capacity+1];\\n        memset(dp,0,sizeof(dp));\\n        memset(isCurItemPicked,0,sizeof(isCurItemPicked));\\n        for (int i=1; i<=numItems; i++) {\\n            for (int j=1; j<=capacity; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (j >= costs[i-1]) {\\n                    int valueIfCurItemIsPicked = dp[i-1][j-costs[i-1]] + itemValues[i-1];\\n                    if (valueIfCurItemIsPicked > dp[i][j]) {\\n                        dp[i][j] = valueIfCurItemIsPicked;\\n                        isCurItemPicked[i][j] = true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        vector <int> spent;\\n        int weight = capacity;\\n        for (int i=numItems; i>0; i--) {            \\n            if (isCurItemPicked[i][weight]) {\\n                weight -= costs[i-1];\\n                spent.push_back(costs[i-1]);\\n            } else {\\n                spent.push_back(0);\\n            }\\n        }\\n        reverse(spent.begin(), spent.end());\\n        return spent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029107,
                "title": "c-bit-manipulation-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(2^12 * 12)\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>v;\\n        int maxi=0;\\n        for(int i=0; i<(1<<12); i++){\\n            int n=numArrows, cnt=0;\\n            vector<int>temp(12, 0);\\n            for(int j=11; j>=0; j--){\\n                if(i&(1<<j)){\\n                    if(n>aliceArrows[j]){\\n                        n-=(aliceArrows[j]+1);\\n                        temp[j]=(aliceArrows[j]+1);\\n                    }\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(i&(1<<j)){\\n                    temp[j]+=n;\\n                    break;\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(temp[j]>aliceArrows[j]){cnt+=j;}\\n            }\\n            if(cnt>maxi){\\n                maxi=cnt;\\n                v=temp;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>v;\\n        int maxi=0;\\n        for(int i=0; i<(1<<12); i++){\\n            int n=numArrows, cnt=0;\\n            vector<int>temp(12, 0);\\n            for(int j=11; j>=0; j--){\\n                if(i&(1<<j)){\\n                    if(n>aliceArrows[j]){\\n                        n-=(aliceArrows[j]+1);\\n                        temp[j]=(aliceArrows[j]+1);\\n                    }\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(i&(1<<j)){\\n                    temp[j]+=n;\\n                    break;\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(temp[j]>aliceArrows[j]){cnt+=j;}\\n            }\\n            if(cnt>maxi){\\n                maxi=cnt;\\n                v=temp;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025681,
                "title": "intuition-included-explained-c",
                "content": "# Intuition\\nHere we have option to choose or not choose so it must be recurrsion or dp \\njust wrote the simple recursion then notice since ther is only one variable so no over lapping so no dp only recurrsion \\n\\n# Approach\\n- we have option two choose the number or not \\n- if we choose the number then number of arrow we needed to `score =aliceArrows[i]+1` \\n- if we are at `i==12 or arrows ==0` base case\\n- just calculate the total score at this very moment and if this is **greater than previous score** then update the score and update the `fianlAnswer array`\\n\\n# Complexity\\n- Time complexity:\\n- $$O(2^12)$$\\n\\n- Space complexity:\\n$$O(12)$$ \\n\\n# Code\\n```\\n// https://leetcode.com/problems/maximum-points-in-an-archery-competition/description/\\n// simple Choose not Choose.\\nclass Solution {\\npublic:\\n    vector<int>ans;//will save the final answer.\\n    int scoreCount=0;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) \\n    {\\n        vector<int>temp(12,0);\\n        f(numArrows,temp,0,aliceArrows);\\n        return ans;\\n    }\\n    void f(int arrows,vector<int>&v,int i,vector<int>& ref)\\n    {\\n        if (arrows==0 || i==12)\\n        {\\n            if (i==12 && arrows!=0)\\n            {\\n                //edge case when excess of arrows are give.\\n                v[11]+=arrows;\\n            }\\n            int temp=cal(v,ref);\\n            if (temp>scoreCount)\\n            {\\n                scoreCount=temp;\\n                ans=v;\\n            }\\n            return ;\\n        }\\n        //not choose the number \\n        f(arrows,v,i+1,ref);\\n        \\n        v[i]=0; // incase we have handled edge case then just undo that step\\n\\n        //choose the number if we have enough arrows\\n        if (ref[i]<arrows)\\n        {\\n            v[i]=ref[i]+1;\\n            f(arrows-ref[i]-1,v,i+1,ref);\\n            v[i]=0;\\n        }\\n    }\\n    int cal(vector<int>&v,vector<int>&ref)\\n    {\\n        int temp=0;\\n        for(int i=0;i<12;i++)\\n        {\\n            if (v[i]>ref[i])\\n            {\\n                temp+=i;\\n            }\\n        }\\n        return temp;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n// https://leetcode.com/problems/maximum-points-in-an-archery-competition/description/\\n// simple Choose not Choose.\\nclass Solution {\\npublic:\\n    vector<int>ans;//will save the final answer.\\n    int scoreCount=0;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) \\n    {\\n        vector<int>temp(12,0);\\n        f(numArrows,temp,0,aliceArrows);\\n        return ans;\\n    }\\n    void f(int arrows,vector<int>&v,int i,vector<int>& ref)\\n    {\\n        if (arrows==0 || i==12)\\n        {\\n            if (i==12 && arrows!=0)\\n            {\\n                //edge case when excess of arrows are give.\\n                v[11]+=arrows;\\n            }\\n            int temp=cal(v,ref);\\n            if (temp>scoreCount)\\n            {\\n                scoreCount=temp;\\n                ans=v;\\n            }\\n            return ;\\n        }\\n        //not choose the number \\n        f(arrows,v,i+1,ref);\\n        \\n        v[i]=0; // incase we have handled edge case then just undo that step\\n\\n        //choose the number if we have enough arrows\\n        if (ref[i]<arrows)\\n        {\\n            v[i]=ref[i]+1;\\n            f(arrows-ref[i]-1,v,i+1,ref);\\n            v[i]=0;\\n        }\\n    }\\n    int cal(vector<int>&v,vector<int>&ref)\\n    {\\n        int temp=0;\\n        for(int i=0;i<12;i++)\\n        {\\n            if (v[i]>ref[i])\\n            {\\n                temp+=i;\\n            }\\n        }\\n        return temp;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013209,
                "title": "c-solution-recursive-solution-faster-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate : \\n    vector<int> ans;\\n    bool checkProfit(vector<int>&bob,vector<int>& alice){\\n        int prevProfit = 0;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i] > alice[i]) prevProfit += i;\\n        }\\n\\n        int newProfit = 0;\\n        for(int i=0;i<bob.size();i++){\\n            if(bob[i] > alice[i]) newProfit += i;\\n        }\\n\\n        return newProfit > prevProfit;\\n    }\\n\\n    void helper(int i,int numArrows,vector<int>& alice,vector<int>&bob){\\n        if(i==0){\\n            bob[i] = numArrows;\\n            if(checkProfit(bob,alice)) ans = bob;\\n            bob[i] = 0;\\n            return;\\n        }\\n        if(numArrows - alice[i] - 1 >= 0){\\n            bob[i] = alice[i] + 1;\\n            helper(i-1,numArrows - alice[i] - 1,alice,bob);\\n            bob[i] = 0;\\n        }\\n\\n        helper(i-1,numArrows,alice,bob);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n        helper(11,numArrows,aliceArrows,bob);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate : \\n    vector<int> ans;\\n    bool checkProfit(vector<int>&bob,vector<int>& alice){\\n        int prevProfit = 0;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i] > alice[i]) prevProfit += i;\\n        }\\n\\n        int newProfit = 0;\\n        for(int i=0;i<bob.size();i++){\\n            if(bob[i] > alice[i]) newProfit += i;\\n        }\\n\\n        return newProfit > prevProfit;\\n    }\\n\\n    void helper(int i,int numArrows,vector<int>& alice,vector<int>&bob){\\n        if(i==0){\\n            bob[i] = numArrows;\\n            if(checkProfit(bob,alice)) ans = bob;\\n            bob[i] = 0;\\n            return;\\n        }\\n        if(numArrows - alice[i] - 1 >= 0){\\n            bob[i] = alice[i] + 1;\\n            helper(i-1,numArrows - alice[i] - 1,alice,bob);\\n            bob[i] = 0;\\n        }\\n\\n        helper(i-1,numArrows,alice,bob);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n        helper(11,numArrows,aliceArrows,bob);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225850,
                "title": "java-time-o-n2-n-space-o-n-backtracking",
                "content": "```\\n\\n// naively, you want to try every possibility. And all the choices for\\n// bob at section i are :\\n\\n// 1. bob gets 0 at section i,\\n// 2. bob gets AliceArrows[i] + 1,\\n\\n//you want to use a recursive function for trying all of the choices,\\n//meanwhile, you want to keep a global variable, maxScore, which\\n//indicates, the maxScore for bob after a series of choices, you want\\n//to use another global variable result = new int[12] to record this series\\n//of choices corresponds to the maxScore.\\n\\n//after exploring all choice patterns, you will return result.\\n\\n//Now, you\\'ve figured out that a recursive function should be used, which\\n//magically just returns a choice pattern for Bob, but what about the details?\\n\\n//(1), arguments\\n//1.we know the total Arrows for bob, at each iteration, bob will decide to put\\n// some number of arrows at section i, for the subsequent choices, you need\\n//to know how many arrows left for bob, hence we keep an argument \"leftArrow\"\\n\\n//2. index that indicating which section we are considering \"index\"\\n\\n//3. int[] bobArrows, the current state for bob, which stores all choices made so\\n// far for bob\\n\\n//4. \"score\", which corresponds to the score for bobArrows.\\n\\n//(2). base case\\n//If you have worked with recursion functions, you know its essential to come up \\n//with workable base case for a recursion function.\\n\\n//in our case, we traverse from index = 11 to index = 0 to index < 0\\n//so we have those following base case\\n\\n//1. arrowLeft < 0, we\\'ve assigned all arrows for bob, and have negative left, this\\n// isn\\'t a feasible situation, we don\\'t want to continue and immediately stop exploring\\n\\n//2. arrowLeft==0, in this case, we\\'ve obtained a feasible scenario for bob, and we want to\\n//see if it\\'s a good one, by comparing it with the global variable \"maxScore\"\\n\\n//3. index<0, in this case, we may still have arrow left, but we don\\'t have any slots left as\\n//index is smaller than 0, in this case, we simply put all arrow left at index 0 :), why?\\n//because putting arrows at index 0 doesn\\'t bring any changes to the score.\\n\\n\\n//(3) recursive calls\\n// at each index, we have two choices, we just simply consider those two choices, pls\\n//note that if we want to make any changes to bobArrows, we need to erase this choice\\n//for future exploration. (backtracking...)\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    int maxScore = 0;\\n    int[] result;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] bobArrows = new int[12];\\n        dfs(numArrows, 11, aliceArrows,bobArrows,0);\\n        return result;\\n    }\\n    \\n    \\n    private void dfs(int arrowLeft, int index, int[] aliceArrows, int[] bobArrows, int score){\\n        if(arrowLeft<0) return;\\n        \\n        if(arrowLeft==0){\\n            if(score>maxScore){\\n                maxScore = score;\\n                result = bobArrows.clone();\\n            }\\n            return;\\n        }\\n        \\n        if(index<0){\\n            if(score>maxScore){\\n                maxScore = score;\\n                bobArrows[0] = arrowLeft;\\n                result = bobArrows.clone();\\n                bobArrows[0] = 0;\\n            }\\n            return;\\n        }\\n\\n        dfs(arrowLeft, index-1, aliceArrows, bobArrows, score);\\n        \\n        bobArrows[index] = aliceArrows[index]+1;\\n        dfs(arrowLeft - bobArrows[index], index-1, aliceArrows, bobArrows, score+index);\\n        bobArrows[index] = 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n\\n// naively, you want to try every possibility. And all the choices for\\n// bob at section i are :\\n\\n// 1. bob gets 0 at section i,\\n// 2. bob gets AliceArrows[i] + 1,\\n\\n//you want to use a recursive function for trying all of the choices,\\n//meanwhile, you want to keep a global variable, maxScore, which\\n//indicates, the maxScore for bob after a series of choices, you want\\n//to use another global variable result = new int[12] to record this series\\n//of choices corresponds to the maxScore.\\n\\n//after exploring all choice patterns, you will return result.\\n\\n//Now, you\\'ve figured out that a recursive function should be used, which\\n//magically just returns a choice pattern for Bob, but what about the details?\\n\\n//(1), arguments\\n//1.we know the total Arrows for bob, at each iteration, bob will decide to put\\n// some number of arrows at section i, for the subsequent choices, you need\\n//to know how many arrows left for bob, hence we keep an argument \"leftArrow\"\\n\\n//2. index that indicating which section we are considering \"index\"\\n\\n//3. int[] bobArrows, the current state for bob, which stores all choices made so\\n// far for bob\\n\\n//4. \"score\", which corresponds to the score for bobArrows.\\n\\n//(2). base case\\n//If you have worked with recursion functions, you know its essential to come up \\n//with workable base case for a recursion function.\\n\\n//in our case, we traverse from index = 11 to index = 0 to index < 0\\n//so we have those following base case\\n\\n//1. arrowLeft < 0, we\\'ve assigned all arrows for bob, and have negative left, this\\n// isn\\'t a feasible situation, we don\\'t want to continue and immediately stop exploring\\n\\n//2. arrowLeft==0, in this case, we\\'ve obtained a feasible scenario for bob, and we want to\\n//see if it\\'s a good one, by comparing it with the global variable \"maxScore\"\\n\\n//3. index<0, in this case, we may still have arrow left, but we don\\'t have any slots left as\\n//index is smaller than 0, in this case, we simply put all arrow left at index 0 :), why?\\n//because putting arrows at index 0 doesn\\'t bring any changes to the score.\\n\\n\\n//(3) recursive calls\\n// at each index, we have two choices, we just simply consider those two choices, pls\\n//note that if we want to make any changes to bobArrows, we need to erase this choice\\n//for future exploration. (backtracking...)\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    int maxScore = 0;\\n    int[] result;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] bobArrows = new int[12];\\n        dfs(numArrows, 11, aliceArrows,bobArrows,0);\\n        return result;\\n    }\\n    \\n    \\n    private void dfs(int arrowLeft, int index, int[] aliceArrows, int[] bobArrows, int score){\\n        if(arrowLeft<0) return;\\n        \\n        if(arrowLeft==0){\\n            if(score>maxScore){\\n                maxScore = score;\\n                result = bobArrows.clone();\\n            }\\n            return;\\n        }\\n        \\n        if(index<0){\\n            if(score>maxScore){\\n                maxScore = score;\\n                bobArrows[0] = arrowLeft;\\n                result = bobArrows.clone();\\n                bobArrows[0] = 0;\\n            }\\n            return;\\n        }\\n\\n        dfs(arrowLeft, index-1, aliceArrows, bobArrows, score);\\n        \\n        bobArrows[index] = aliceArrows[index]+1;\\n        dfs(arrowLeft - bobArrows[index], index-1, aliceArrows, bobArrows, score+index);\\n        bobArrows[index] = 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186959,
                "title": "java-solution-straight-forward-backtracking",
                "content": "\\n``` java\\nclass Solution {\\n    int[] res = new int[12];\\n    int max = 0;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        compute(numArrows, aliceArrows, new int[12], 11, 0);\\n        return res;\\n    }\\n\\n    private void compute(int numArrows, int[] aliceArrows, int[] bobArrows, int idx, int point) {\\n        if (idx == 0) {\\n            if (point > max) {\\n                max = point;\\n                bobArrows[idx] = numArrows;\\n                res = bobArrows.clone();\\n            }\\n            return;\\n        }\\n        compute(numArrows, aliceArrows, bobArrows, idx - 1, point);\\n        if (numArrows > aliceArrows[idx]) {\\n            bobArrows[idx] = aliceArrows[idx] + 1;\\n            compute(numArrows - bobArrows[idx], aliceArrows, bobArrows, idx - 1, point + idx);\\n            bobArrows[idx] = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    int[] res = new int[12];\\n    int max = 0;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        compute(numArrows, aliceArrows, new int[12], 11, 0);\\n        return res;\\n    }\\n\\n    private void compute(int numArrows, int[] aliceArrows, int[] bobArrows, int idx, int point) {\\n        if (idx == 0) {\\n            if (point > max) {\\n                max = point;\\n                bobArrows[idx] = numArrows;\\n                res = bobArrows.clone();\\n            }\\n            return;\\n        }\\n        compute(numArrows, aliceArrows, bobArrows, idx - 1, point);\\n        if (numArrows > aliceArrows[idx]) {\\n            bobArrows[idx] = aliceArrows[idx] + 1;\\n            compute(numArrows - bobArrows[idx], aliceArrows, bobArrows, idx - 1, point + idx);\\n            bobArrows[idx] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165623,
                "title": "java-simple-backtracking-solution-easy-to-read-included-comments",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    int[] ansbob;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] bob = new int[aliceArrows.length];\\n        for(int i=0;i<bob.length;i++)bob[i]=0;\\n        ansbob = new int[bob.length];\\n        func(aliceArrows,bob,numArrows,11,0);\\n        return ansbob;\\n    }\\n    public void func(int[] alice,int[] bob,int remArrows,int index,int bobscore){\\n        //Base case\\n        if(index==-1){\\n            if(remArrows!=0){\\n                for(int i=0;i<bob.length;i++){\\n                    //Place remaining arrows at a nonzero position of bob\\n                    if(bob[i]!=0){\\n                        bob[i]+=remArrows;\\n                        break;\\n                    }\\n                }\\n            }\\n            int temp = Math.max(ans,bobscore);\\n            if(temp!=ans){\\n                ans = temp;\\n                for(int i=0;i<bob.length;i++){\\n                    ansbob[i]=bob[i];\\n                }\\n            }\\n            return;\\n        }\\n        //Recursive case\\n        //For each there is a possiblilty of bob either winning or loosing\\n\\n        //Bob winning case\\n        int score = alice[index];\\n        if(remArrows>score){\\n            //Place  score + 1arrows at that position\\n            bob[index]=score+1;\\n            //check for next index\\n            func(alice,bob,remArrows-1-score,index-1,bobscore+index);\\n            //replace back\\n            bob[index]=0;\\n        }\\n        //Bob loosing case - Place no arrows at that position\\n        func(alice,bob,remArrows,index-1,bobscore);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    int[] ansbob;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] bob = new int[aliceArrows.length];\\n        for(int i=0;i<bob.length;i++)bob[i]=0;\\n        ansbob = new int[bob.length];\\n        func(aliceArrows,bob,numArrows,11,0);\\n        return ansbob;\\n    }\\n    public void func(int[] alice,int[] bob,int remArrows,int index,int bobscore){\\n        //Base case\\n        if(index==-1){\\n            if(remArrows!=0){\\n                for(int i=0;i<bob.length;i++){\\n                    //Place remaining arrows at a nonzero position of bob\\n                    if(bob[i]!=0){\\n                        bob[i]+=remArrows;\\n                        break;\\n                    }\\n                }\\n            }\\n            int temp = Math.max(ans,bobscore);\\n            if(temp!=ans){\\n                ans = temp;\\n                for(int i=0;i<bob.length;i++){\\n                    ansbob[i]=bob[i];\\n                }\\n            }\\n            return;\\n        }\\n        //Recursive case\\n        //For each there is a possiblilty of bob either winning or loosing\\n\\n        //Bob winning case\\n        int score = alice[index];\\n        if(remArrows>score){\\n            //Place  score + 1arrows at that position\\n            bob[index]=score+1;\\n            //check for next index\\n            func(alice,bob,remArrows-1-score,index-1,bobscore+index);\\n            //replace back\\n            bob[index]=0;\\n        }\\n        //Bob loosing case - Place no arrows at that position\\n        func(alice,bob,remArrows,index-1,bobscore);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900788,
                "title": "c-backtracking-template",
                "content": "Do the back tracking from the highest score.\\n[DFS Conditions]\\n* DFS Define:Find the max scroes combination\\n* DFS Exit: Arrows == 0\\n* DFS Rule:\\n\\t* Traverse from the highest score to get as higher total scores with minimun cost\\n\\t* If curArrows < aliceArrows[i] and we are not at the last position(e.g. i == 0), then skip this round\\n\\t* If we want to take current points, the minimun cost is aliceArrows[i] + 1\\n\\t* Once we reach i == 0, we should used rest arrows no matter you can get point 0 or not\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> curArrows(12, 0);\\n        vector<int> maxArrows(12, 0);\\n        int maxScore = INT_MIN;\\n        dfs(numArrows, 11, aliceArrows, curArrows, 0, maxArrows, maxScore);\\n        return maxArrows;\\n    }\\n    \\n    void dfs(int numArrows, int start, vector<int>& aliceArrows, vector<int>& curArrows, int curScore,\\n             vector<int>& maxArrows, int &maxScore) {\\n        if (numArrows == 0) {\\n            if (curScore > maxScore) {\\n                maxScore = curScore;\\n                maxArrows = curArrows;\\n            }\\n            return;\\n        }\\n        \\n        for (int i = start; i >= 0; i--) {\\n            if (numArrows <= aliceArrows[i] && i != 0)\\n                continue;\\n            int restArrows = i == 0 ? 0 : numArrows - aliceArrows[i] - 1;\\n            curArrows[i] = i == 0 ? numArrows : aliceArrows[i] + 1;\\n            dfs(restArrows, i - 1, aliceArrows, curArrows, curScore + i, maxArrows, maxScore);\\n            curArrows[i] = 0;\\n        }\\n    }    \\n};\\n```\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> curArrows(12, 0);\\n        vector<int> maxArrows(12, 0);\\n        int maxScore = INT_MIN;\\n        dfs(numArrows, 11, aliceArrows, curArrows, 0, maxArrows, maxScore);\\n        return maxArrows;\\n    }\\n    \\n    void dfs(int numArrows, int start, vector<int>& aliceArrows, vector<int>& curArrows, int curScore,\\n             vector<int>& maxArrows, int &maxScore) {\\n        if (numArrows == 0) {\\n            if (curScore > maxScore) {\\n                maxScore = curScore;\\n                maxArrows = curArrows;\\n            }\\n            return;\\n        }\\n        \\n        for (int i = start; i >= 0; i--) {\\n            if (numArrows <= aliceArrows[i] && i != 0)\\n                continue;\\n            int restArrows = i == 0 ? 0 : numArrows - aliceArrows[i] - 1;\\n            curArrows[i] = i == 0 ? numArrows : aliceArrows[i] + 1;\\n            dfs(restArrows, i - 1, aliceArrows, curArrows, curScore + i, maxArrows, maxScore);\\n            curArrows[i] = 0;\\n        }\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895392,
                "title": "java-bitmask",
                "content": "Examine all possible combinations of arrows for bob.\\n```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n       // System.out.println((1<<aliceArrows.length-1)-1);\\n        int max = 0 ;\\n        int [] maxState = null;\\n        for(int state = 1;state<=2047 ;state++){\\n            int arrows = 0,score = 0 ;\\n            int [] currMaxState = new int[aliceArrows.length];\\n            for(int i = 0;i<aliceArrows.length;i++){\\n                int aScore = aliceArrows[aliceArrows.length-i-1];\\n                if((state & (1<<i))>0){\\n                    arrows+=(aScore>0?(aScore+1):1);\\n                    score+=aliceArrows.length-i-1;\\n                    currMaxState[aliceArrows.length-i-1] = (aScore>0?(aScore+1):1);\\n                }\\n            }\\n            if(arrows<=numArrows && score>max){\\n                //System.out.println(\"Here\");\\n                max = score;\\n                for(int i = 0;i<currMaxState.length;i++){\\n                    if(currMaxState[i]>0 && arrows<numArrows){\\n                        currMaxState[i]+=(numArrows-arrows);\\n                        break;\\n                    }\\n                }\\n                maxState = currMaxState;\\n            }\\n        }\\n        //System.out.println(max);\\n        return maxState;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n       // System.out.println((1<<aliceArrows.length-1)-1);\\n        int max = 0 ;\\n        int [] maxState = null;\\n        for(int state = 1;state<=2047 ;state++){\\n            int arrows = 0,score = 0 ;\\n            int [] currMaxState = new int[aliceArrows.length];\\n            for(int i = 0;i<aliceArrows.length;i++){\\n                int aScore = aliceArrows[aliceArrows.length-i-1];\\n                if((state & (1<<i))>0){\\n                    arrows+=(aScore>0?(aScore+1):1);\\n                    score+=aliceArrows.length-i-1;\\n                    currMaxState[aliceArrows.length-i-1] = (aScore>0?(aScore+1):1);\\n                }\\n            }\\n            if(arrows<=numArrows && score>max){\\n                //System.out.println(\"Here\");\\n                max = score;\\n                for(int i = 0;i<currMaxState.length;i++){\\n                    if(currMaxState[i]>0 && arrows<numArrows){\\n                        currMaxState[i]+=(numArrows-arrows);\\n                        break;\\n                    }\\n                }\\n                maxState = currMaxState;\\n            }\\n        }\\n        //System.out.println(max);\\n        return maxState;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877698,
                "title": "full-explanation-with-graphics-bitmasking-and-backtracking-c-beats-58",
                "content": "One of the best questions I\\'ve seen on a LeetCode contest and on this platform in general! Huge bravo to whoever came up with this question :)\\n\\n![image](https://assets.leetcode.com/users/images/beea359c-9d54-4c30-b3b4-27c028251a8d_1648075945.7818155.png)\\n\\n\\n\\n<h5>\\nObservations\\n</h5>\\nKeep in mind that the questions specifically asks to \"<b>maximize Bob\\'s score</b>\". Regardless of  who wins, all we are trying to solve is the maximum number of points Bob can get. \\n\\nObservation 1: The number of arrows that Bob have is the sum of the elements in aliceArrows. This is because Bob and Alice will have the same number of arrows. \\n\\nObservation 2: For Bob to gain K points, Bob\\'s score must be <b>strictly greater</b> than Alice\\'s score. Bob must score Alice\\'s score plus 1 to gain the K points if Bob plays optimally. \\n\\nObservation 3: We must iterate through K = 0 to K = 11, and decide whether Bob will spend aliceArrows[i] + 1 arrows to gain the K points. \\n* If Bob decides to \"take\" it, Bob will spend aliceArrows[i] + 1 arrows and gain K points. \\n* If Bob decides to \"leave\" it, Bob will not spend anything, nor will he gain points. \\n\\nObservation 4: Since there are 11 - 0 + 1 = 12 possible values for K, an algorithm that runs in O(2^n) will be fast enough to pass the solution. The small size for K is a hint that we could try an exponential algorithm!\\n\\n<h5>\\nIntuition\\n</h5>\\nThe intuition is to use bitmasking to generate all possible states of whether to take or leave K points for each K. Keep track of the maximum number of points Bob can get and the states in this configuation. Finally, distribute Bob\\'s arrow by looking at the states for the configuration. \\n<br><br>\\n<h5>\\nImplementation\\n</h5>\\n1. Use bitmasking to generate all possible configurations. <br><br>\\n2. For each configuration, determine the minimum total points that Bob will need, which can be calculated by the sum of aliceArrow[i] + 1 for each K points that Bob decides to take. If the number of points Bob needs is less than or equal to the number of arrows he has, then this configuration is possible. <br><br>\\n3. Keep track of the maximum number of points Bob can get, and also the configuration state. <br><br>\\n4. Backtrack to retrieve states configuration. <br><br>\\n5. Filling the answer array by giving aliceArrows[i] + 1 arrows to each K that Bob decides to \"take\". <br><br>\\n6. Add the remaining useless arrows to just any random K so Alice and Bob spends the same number of arrows! <br><br>\\n\\nTime Complexity: O(2^n) because we are generating all possible configurations for a take-or-leave scenario. \\n\\nSpace Complexity: O(n) because we made a cost array. This was unnecessary but was added for better understanding and readabilty of the code. Easily done in O(1) space by removing the cost array. \\n\\n\\n\\n<h5>\\nC++ Solution, time beats 58.07%. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        //bitmasking all possible configurations. \\n        vector<pair<int, int>> cost(12);\\n        int highscore = 0, m = 0;\\n        for(int i = 0; i < aliceArrows.size(); i++) cost[i] = make_pair(aliceArrows[i] + 1, i);\\n        for(int mask = 0; mask < (1 << cost.size()); mask++){\\n            int c = 0, score = 0;\\n            for(int bit = 0; bit < cost.size(); bit++){\\n                    if(mask & (1 << bit)){\\n                        c += cost[bit].first;\\n                        score += cost[bit].second;\\n                    }\\n                }\\n            if(c <= numArrows && score > highscore){\\n                highscore = score;\\n                m = mask;\\n            }\\n        }\\n        \\n        //backtracking to retrieve states configuration. \\n        vector<int> res(12);\\n        string s = \"\";\\n        int cnt = 12;\\n        while(cnt--){\\n            s = s + (char)(m % 2 + \\'0\\');\\n            m /= 2;\\n        }\\n        \\n        //filling up answer array\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'1\\'){\\n                numArrows -= cost[i].first;\\n                res[i] = cost[i].first;\\n            }\\n        }\\n        \\n        //adding remaining useless arrows. \\n        res[res.size() - 1] += numArrows;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        //bitmasking all possible configurations. \\n        vector<pair<int, int>> cost(12);\\n        int highscore = 0, m = 0;\\n        for(int i = 0; i < aliceArrows.size(); i++) cost[i] = make_pair(aliceArrows[i] + 1, i);\\n        for(int mask = 0; mask < (1 << cost.size()); mask++){\\n            int c = 0, score = 0;\\n            for(int bit = 0; bit < cost.size(); bit++){\\n                    if(mask & (1 << bit)){\\n                        c += cost[bit].first;\\n                        score += cost[bit].second;\\n                    }\\n                }\\n            if(c <= numArrows && score > highscore){\\n                highscore = score;\\n                m = mask;\\n            }\\n        }\\n        \\n        //backtracking to retrieve states configuration. \\n        vector<int> res(12);\\n        string s = \"\";\\n        int cnt = 12;\\n        while(cnt--){\\n            s = s + (char)(m % 2 + \\'0\\');\\n            m /= 2;\\n        }\\n        \\n        //filling up answer array\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'1\\'){\\n                numArrows -= cost[i].first;\\n                res[i] = cost[i].first;\\n            }\\n        }\\n        \\n        //adding remaining useless arrows. \\n        res[res.size() - 1] += numArrows;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876913,
                "title": "c-backtracking",
                "content": "```cpp\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n\\tvector<int> result(12), curr(12);\\n\\tint maxscore = 0;\\n\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows);\\n\\treturn result;\\n}\\n\\nvoid maximum_bob_points(const vector<int>& aliceArrows, vector<int>& result, vector<int>& curr,\\n\\t\\t\\t\\t\\t   int& maxscore, int numArrows, int score=0, int k=11) {\\n\\tif(k == 0) {\\n\\t\\tif(score > maxscore) {\\n\\t\\t\\tresult = curr;\\n\\t\\t\\tresult[0] = numArrows;\\n\\t\\t\\tmaxscore = score;\\n\\t\\t}\\n\\t} else {\\n\\t\\tif(numArrows > aliceArrows[k]) {\\n\\t\\t\\tcurr[k] = aliceArrows[k]+1;\\n\\t\\t\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows-aliceArrows[k] - 1, score + k, k-1);\\n\\t\\t}\\n\\t\\tcurr[k]=0;\\n\\t\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows, score, k-1);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n\\tvector<int> result(12), curr(12);\\n\\tint maxscore = 0;\\n\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows);\\n\\treturn result;\\n}\\n\\nvoid maximum_bob_points(const vector<int>& aliceArrows, vector<int>& result, vector<int>& curr,\\n\\t\\t\\t\\t\\t   int& maxscore, int numArrows, int score=0, int k=11) {\\n\\tif(k == 0) {\\n\\t\\tif(score > maxscore) {\\n\\t\\t\\tresult = curr;\\n\\t\\t\\tresult[0] = numArrows;\\n\\t\\t\\tmaxscore = score;\\n\\t\\t}\\n\\t} else {\\n\\t\\tif(numArrows > aliceArrows[k]) {\\n\\t\\t\\tcurr[k] = aliceArrows[k]+1;\\n\\t\\t\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows-aliceArrows[k] - 1, score + k, k-1);\\n\\t\\t}\\n\\t\\tcurr[k]=0;\\n\\t\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows, score, k-1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875298,
                "title": "c-faster-than-100-fully-commented-simple-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\nint totalScore=0;\\nbool flag=false;\\nvector<int> bobScores;\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> currentVector(12,0);\\n        int index=0;\\n        int currentScore=0;\\n\\n        // we start with index=1 cause we don\\'t want to win section \"0\" as it has 0 score.\\n        // so we dont\\' want to waste any arrows in winning \"0\" points\\n\\n        //Standard backtrack Function\\n        backtrack(1,numArrows,aliceArrows,currentScore,currentVector);\\n\\n\\n        //If we have not used all the arrows for bobScore then we can just use them on section with 0 score.\\n        //Because we dont\\' care if alice or bob wins this section it will not effect the overall score.\\n        int sum=0;\\n        for(auto n:bobScores)\\n                sum+=n;\\n        bobScores[0]=numArrows-sum;\\n\\n        //return the formed anwers;\\n        return bobScores;\\n}\\n\\nvoid backtrack(int index,int numArrows,vector<int>&aliceArrows,int currentScore,vector<int>&currentVector){\\n\\n        // we have reached the end\\n        if(index==aliceArrows.size()) {\\n                if(currentScore>totalScore) {\\n                        totalScore=currentScore;\\n                        bobScores=currentVector;\\n                }\\n                return;\\n        }\\n\\n        //there are only two possibilities for each section\\n        //1. Either Bob Wants Wins it or he doesn\\'t want to win it.\\n\\n        //Option 1\\n        // If he wants to Wins it.\\n        //first we have to check if he can win it.\\n        int req=aliceArrows[index]+1;\\n        if(req<=numArrows) {\\n                currentVector[index]+=req;\\n                backtrack(index+1,numArrows-req,aliceArrows,currentScore+index,currentVector);\\n                currentVector[index]-=req;\\n        }\\n\\n\\n        //Option 2\\n        //If he dont\\'t want to win this section than he will not waste any arrows here.\\n        backtrack(index+1,numArrows,aliceArrows,currentScore,currentVector);\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint totalScore=0;\\nbool flag=false;\\nvector<int> bobScores;\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> currentVector(12,0);\\n        int index=0;\\n        int currentScore=0;\\n\\n        // we start with index=1 cause we don\\'t want to win section \"0\" as it has 0 score.\\n        // so we dont\\' want to waste any arrows in winning \"0\" points\\n\\n        //Standard backtrack Function\\n        backtrack(1,numArrows,aliceArrows,currentScore,currentVector);\\n\\n\\n        //If we have not used all the arrows for bobScore then we can just use them on section with 0 score.\\n        //Because we dont\\' care if alice or bob wins this section it will not effect the overall score.\\n        int sum=0;\\n        for(auto n:bobScores)\\n                sum+=n;\\n        bobScores[0]=numArrows-sum;\\n\\n        //return the formed anwers;\\n        return bobScores;\\n}\\n\\nvoid backtrack(int index,int numArrows,vector<int>&aliceArrows,int currentScore,vector<int>&currentVector){\\n\\n        // we have reached the end\\n        if(index==aliceArrows.size()) {\\n                if(currentScore>totalScore) {\\n                        totalScore=currentScore;\\n                        bobScores=currentVector;\\n                }\\n                return;\\n        }\\n\\n        //there are only two possibilities for each section\\n        //1. Either Bob Wants Wins it or he doesn\\'t want to win it.\\n\\n        //Option 1\\n        // If he wants to Wins it.\\n        //first we have to check if he can win it.\\n        int req=aliceArrows[index]+1;\\n        if(req<=numArrows) {\\n                currentVector[index]+=req;\\n                backtrack(index+1,numArrows-req,aliceArrows,currentScore+index,currentVector);\\n                currentVector[index]-=req;\\n        }\\n\\n\\n        //Option 2\\n        //If he dont\\'t want to win this section than he will not waste any arrows here.\\n        backtrack(index+1,numArrows,aliceArrows,currentScore,currentVector);\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872837,
                "title": "java-dynamic-programming-recursion-memoization",
                "content": "Have maintained obj class for having list of values and val variable seperately and for having clean code.\\n```\\nclass obj{\\n    int val;\\n    List<Integer>l;\\n    obj(int val,List<Integer>l){\\n        this.val=val;\\n        this.l=l;\\n    }\\n    obj(obj o,int in,int value){\\n        this.l=new ArrayList<>(o.l);\\n        this.l.add(in);\\n        this.val=value;\\n    }\\n}\\nclass Solution {\\n    obj dp[][];\\n    public obj rec(int i,int numArrows,int arr[]){\\n        if(dp[i][numArrows]!=null)\\n            return dp[i][numArrows];\\n        if(i==arr.length-1){\\n            if(numArrows>arr[i])\\n                dp[i][numArrows]=new obj(i,Arrays.asList(numArrows));\\n            else\\n                dp[i][numArrows]=new obj(0,Arrays.asList(numArrows));\\n            return dp[i][numArrows];\\n        }\\n        if(numArrows>arr[i]){\\n            obj o1=rec(i+1,numArrows,arr);\\n            obj o2=rec(i+1,numArrows-arr[i]-1,arr);\\n            if(o2.val+i>o1.val)\\n                dp[i][numArrows]=new obj(o2,arr[i]+1,o2.val+i);\\n            else\\n                dp[i][numArrows]=new obj(o1,0,o1.val);\\n        }else{\\n            obj o1=rec(i+1,numArrows,arr);\\n            dp[i][numArrows]=new obj(o1,0,o1.val);\\n        }\\n        return dp[i][numArrows];\\n    }\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        dp=new obj[12][numArrows+1];\\n        obj res_obj=rec(0,numArrows,aliceArrows);\\n        int result[]=new int[12],in=12;\\n        for(int val:res_obj.l)\\n            result[--in]=val;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass obj{\\n    int val;\\n    List<Integer>l;\\n    obj(int val,List<Integer>l){\\n        this.val=val;\\n        this.l=l;\\n    }\\n    obj(obj o,int in,int value){\\n        this.l=new ArrayList<>(o.l);\\n        this.l.add(in);\\n        this.val=value;\\n    }\\n}\\nclass Solution {\\n    obj dp[][];\\n    public obj rec(int i,int numArrows,int arr[]){\\n        if(dp[i][numArrows]!=null)\\n            return dp[i][numArrows];\\n        if(i==arr.length-1){\\n            if(numArrows>arr[i])\\n                dp[i][numArrows]=new obj(i,Arrays.asList(numArrows));\\n            else\\n                dp[i][numArrows]=new obj(0,Arrays.asList(numArrows));\\n            return dp[i][numArrows];\\n        }\\n        if(numArrows>arr[i]){\\n            obj o1=rec(i+1,numArrows,arr);\\n            obj o2=rec(i+1,numArrows-arr[i]-1,arr);\\n            if(o2.val+i>o1.val)\\n                dp[i][numArrows]=new obj(o2,arr[i]+1,o2.val+i);\\n            else\\n                dp[i][numArrows]=new obj(o1,0,o1.val);\\n        }else{\\n            obj o1=rec(i+1,numArrows,arr);\\n            dp[i][numArrows]=new obj(o1,0,o1.val);\\n        }\\n        return dp[i][numArrows];\\n    }\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        dp=new obj[12][numArrows+1];\\n        obj res_obj=rec(0,numArrows,aliceArrows);\\n        int result[]=new int[12],in=12;\\n        for(int val:res_obj.l)\\n            result[--in]=val;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870380,
                "title": "bit-masking-dp-backtracking-c",
                "content": "**BITMASKING**\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& al) {\\n       \\n        int m = al.size();\\n        int amask = 0 , maxi = INT_MIN;\\n        \\n        for(int mask=0;mask<(1<<m);mask++){\\n            \\n            int arruse = 0 , score = 0;\\n            \\n            for(int i=0;i<12;i++){\\n                if(mask & (1<<i)){                     // compute arrowsUsed and score for each state\\n                    arruse += (al[i]+1);\\n                    score += i;\\n                }\\n            }                \\n            \\n            if(arruse <= n && score > maxi){           // if arrows used are less than total arrows\\n                maxi = score;                          // and score is greater than our curmaximum value\\n                amask = mask;                          // include it in our answer\\n            }\\n            \\n        }\\n        \\n        vector<int> ans(m);\\n        int sum = 0;\\n        \\n        for(int i=0;i<12;i++){\\n            if(amask & (1<<i)){\\n                ans[i] = al[i]+1;\\n                sum += ans[i];\\n            }\\n        }\\n        \\n        ans[0] = n - sum;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**DP**\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    \\nint dp[100001][12];\\n\\nvector<int> maximumBobPoints(int n, vector<int>& al) {\\n\\n\\tmemset(dp,0,sizeof(dp));\\n\\tint m = al.size();\\n\\n\\tfor(int i=1;i<n+1;i++){\\n\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\tif(j == 0){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i-(al[j]+1) >= 0){\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j-1] , j + dp[i-(al[j]+1)][j-1]);\\n\\t\\t\\t}\\n\\t\\t\\telse dp[i][j] = dp[i][j-1];\\n\\t\\t}\\n\\t}\\n\\n\\tint i = n , j = m-1;\\n\\tvector<int> ans(m);\\n\\tint sum = 0;\\n\\n\\t// retrieve path from dp\\n\\n\\twhile(i>0 && j>0){\\n\\t\\tif(j > 0 && dp[i][j] != dp[i][j-1]){\\n\\t\\t  ans[j] = al[j]+1;\\n\\t\\t  i = i - (al[j]+1);\\n\\t\\t}\\n\\t\\tsum += ans[j];\\n\\t\\tj--;\\n\\t}\\n\\n\\tans[0] = n-sum;\\n\\n\\treturn ans;\\n}\\n};\\n```\\n\\n**BACKTRACKING**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;\\n    vector<int> ans,res;\\n    \\n    void find(int i,int arrused,vector<int> &al,int n,int score){\\n        \\n         if(arrused > n)return ;\\n        \\n         if(i == al.size()){\\n            if(score > maxi){\\n                ans = res;\\n                maxi = score;\\n            }\\n            return ;\\n        }\\n        \\n        res.push_back(al[i]+1);\\n        find(i+1,arrused+al[i]+1,al,n,score +i);\\n        res.pop_back();\\n        \\n        res.push_back(0);\\n        find(i+1,arrused,al,n,score);\\n        res.pop_back();\\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& al) {\\n        \\n          find(0,0,al,n,0);\\n       \\n          int sum = 0;\\n          for(auto &x : ans){\\n              sum += x;\\n          }\\n            \\n          ans[0] += n-sum;\\n        \\n      return ans;  \\n    }\\n};  \\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& al) {\\n       \\n        int m = al.size();\\n        int amask = 0 , maxi = INT_MIN;\\n        \\n        for(int mask=0;mask<(1<<m);mask++){\\n            \\n            int arruse = 0 , score = 0;\\n            \\n            for(int i=0;i<12;i++){\\n                if(mask & (1<<i)){                     // compute arrowsUsed and score for each state\\n                    arruse += (al[i]+1);\\n                    score += i;\\n                }\\n            }                \\n            \\n            if(arruse <= n && score > maxi){           // if arrows used are less than total arrows\\n                maxi = score;                          // and score is greater than our curmaximum value\\n                amask = mask;                          // include it in our answer\\n            }\\n            \\n        }\\n        \\n        vector<int> ans(m);\\n        int sum = 0;\\n        \\n        for(int i=0;i<12;i++){\\n            if(amask & (1<<i)){\\n                ans[i] = al[i]+1;\\n                sum += ans[i];\\n            }\\n        }\\n        \\n        ans[0] = n - sum;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\nint dp[100001][12];\\n\\nvector<int> maximumBobPoints(int n, vector<int>& al) {\\n\\n\\tmemset(dp,0,sizeof(dp));\\n\\tint m = al.size();\\n\\n\\tfor(int i=1;i<n+1;i++){\\n\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\tif(j == 0){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i-(al[j]+1) >= 0){\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j-1] , j + dp[i-(al[j]+1)][j-1]);\\n\\t\\t\\t}\\n\\t\\t\\telse dp[i][j] = dp[i][j-1];\\n\\t\\t}\\n\\t}\\n\\n\\tint i = n , j = m-1;\\n\\tvector<int> ans(m);\\n\\tint sum = 0;\\n\\n\\t// retrieve path from dp\\n\\n\\twhile(i>0 && j>0){\\n\\t\\tif(j > 0 && dp[i][j] != dp[i][j-1]){\\n\\t\\t  ans[j] = al[j]+1;\\n\\t\\t  i = i - (al[j]+1);\\n\\t\\t}\\n\\t\\tsum += ans[j];\\n\\t\\tj--;\\n\\t}\\n\\n\\tans[0] = n-sum;\\n\\n\\treturn ans;\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;\\n    vector<int> ans,res;\\n    \\n    void find(int i,int arrused,vector<int> &al,int n,int score){\\n        \\n         if(arrused > n)return ;\\n        \\n         if(i == al.size()){\\n            if(score > maxi){\\n                ans = res;\\n                maxi = score;\\n            }\\n            return ;\\n        }\\n        \\n        res.push_back(al[i]+1);\\n        find(i+1,arrused+al[i]+1,al,n,score +i);\\n        res.pop_back();\\n        \\n        res.push_back(0);\\n        find(i+1,arrused,al,n,score);\\n        res.pop_back();\\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& al) {\\n        \\n          find(0,0,al,n,0);\\n       \\n          int sum = 0;\\n          for(auto &x : ans){\\n              sum += x;\\n          }\\n            \\n          ans[0] += n-sum;\\n        \\n      return ans;  \\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869279,
                "title": "bit-masking-generating-all-subsets-2-n",
                "content": "Just find all subsets\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& alice) {\\n        int n=alice.size();\\n        int maxs=INT_MIN;\\n        vector<int> v(n,0);\\n        for(int i=0;i<(1<<n);i++){\\n            int a=0,x=0;\\n            vector<int> t(n,0);\\n            for(int j=0;j<n;j++){\\n                if(x>numArrows){\\n                    break;\\n                }\\n                if((i & (1<<j))){\\n                    t[n-1-j]=alice[n-1-j]+1;\\n                    x+=alice[n-1-j]+1;\\n                }\\n            }\\n            int s=0;\\n            for(int k=0;k<n;k++){\\n                a+=t[k];\\n                if(t[k]>0){\\n                    s+=k;\\n                }\\n            }\\n            if(a<=numArrows && s>maxs){\\n                if(a<numArrows){\\n                    t[0]=numArrows-a;\\n                }\\n                maxs=s;\\n                v=t;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& alice) {\\n        int n=alice.size();\\n        int maxs=INT_MIN;\\n        vector<int> v(n,0);\\n        for(int i=0;i<(1<<n);i++){\\n            int a=0,x=0;\\n            vector<int> t(n,0);\\n            for(int j=0;j<n;j++){\\n                if(x>numArrows){\\n                    break;\\n                }\\n                if((i & (1<<j))){\\n                    t[n-1-j]=alice[n-1-j]+1;\\n                    x+=alice[n-1-j]+1;\\n                }\\n            }\\n            int s=0;\\n            for(int k=0;k<n;k++){\\n                a+=t[k];\\n                if(t[k]>0){\\n                    s+=k;\\n                }\\n            }\\n            if(a<=numArrows && s>maxs){\\n                if(a<numArrows){\\n                    t[0]=numArrows-a;\\n                }\\n                maxs=s;\\n                v=t;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868292,
                "title": "java-backtracking",
                "content": "In total ```bob``` have ```12 rounds``` to play and in each round he can win this round or leave this round.\\n\\n* ```case 1 .``` if he wants to win this round then there should be enough number of \\n     arrows available for him to play this round, i.e. 1 arrow more than alice\\'s arrows ```a[idx] + 1```.\\n\\t \\n* ```case 2 .```  if he skips this round then number of ```arrows``` used does not changes and he can continue to play in the next round with those arrows.\\n\\nAlso just to satisfy the constraints we have to use all the ```arrows``` so just add the remaining arrows to the first round i.e. ```res[0]```.\\n```\\nclass Solution {\\n    //  maximum points scored by bob\\n    int maxBob = 0;\\n    //  alice array\\n    int[] a;\\n    //  result\\n    int[] res = new int[12];\\n    \\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        this.a = aliceArrows;\\n        int[] temp = new int[12];\\n        helper(numArrows, 11, 0, 0, temp);\\n        return res;\\n    }\\n    \\n    public void helper(int arrows, int idx, int used, int currPoints, int[] temp) {\\n        if (used == arrows || idx == 0) {\\n            if (currPoints > maxBob) {\\n                maxBob = currPoints;\\n                int num = clone(temp);\\n                //  if total arrows taken by bob is less than numArrows then\\n                //  just add the remaining arrows to res[0] just to satisfy the constraints\\n                if (num < arrows) {\\n                    res[0] += arrows - num;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        //  winning this section\\n        //  if i want to win this section then i must have enough arrows to win \\n        //  this round so arrows >= used + a[idx] + 1\\n        if (arrows >= used + a[idx] + 1) {\\n            temp[idx] = a[idx] + 1;\\n            helper(arrows, idx - 1, used + a[idx] + 1, currPoints + idx, temp);\\n            temp[idx] = 0;\\n        }\\n        \\n        //  skipping this section\\n        helper(arrows, idx - 1, used, currPoints, temp);\\n    }\\n    \\n    \\n    //  this updates the bob\\'s answer Array\\n    //  returns the total arrows taken by bob\\n    public int clone(int[] b) {\\n        int s = 0;\\n        for (int i = 0; i < 12; i++) {\\n            res[i] = b[i];\\n            s += b[i];\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [],
                "code": "```bob```\n```12 rounds```\n```case 1 .```\n```a[idx] + 1```\n```case 2 .```\n```arrows```\n```arrows```\n```res[0]```",
                "codeTag": "Unknown"
            },
            {
                "id": 1867764,
                "title": "c-0-1-knapsack",
                "content": "```\\nclass Solution {\\n     int dp[100001][13];\\npublic:\\n    int helper(int numArrows, vector<int>& aliceArrows, int n) {\\n        if(numArrows == 0) return 0;\\n        if(n == 0) return 0;\\n        if(dp[numArrows][n] != -1) return dp[numArrows][n];\\n        \\n        if(numArrows > aliceArrows[n-1]) {\\n            return dp[numArrows][n] = max(n-1 + helper(numArrows-aliceArrows[n-1]-1, aliceArrows, n-1), \\n                                                helper(numArrows, aliceArrows, n-1));\\n        } else {\\n            return dp[numArrows][n] = helper(numArrows, aliceArrows, n-1);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        memset(dp, -1, sizeof dp);\\n        vector<int> ret(aliceArrows.size(), 0);\\n        helper(numArrows, aliceArrows, aliceArrows.size());\\n        for(int i = aliceArrows.size(); i > 0; i--) {\\n            if(dp[numArrows][i] == dp[numArrows][i-1]) {\\n                ret[i-1] = 0;\\n            } else {\\n                ret[i-1] = aliceArrows[i-1] + 1;\\n                numArrows -= (aliceArrows[i-1] + 1);\\n            }\\n        }\\n        ret[0] += numArrows;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n     int dp[100001][13];\\npublic:\\n    int helper(int numArrows, vector<int>& aliceArrows, int n) {\\n        if(numArrows == 0) return 0;\\n        if(n == 0) return 0;\\n        if(dp[numArrows][n] != -1) return dp[numArrows][n];\\n        \\n        if(numArrows > aliceArrows[n-1]) {\\n            return dp[numArrows][n] = max(n-1 + helper(numArrows-aliceArrows[n-1]-1, aliceArrows, n-1), \\n                                                helper(numArrows, aliceArrows, n-1));\\n        } else {\\n            return dp[numArrows][n] = helper(numArrows, aliceArrows, n-1);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        memset(dp, -1, sizeof dp);\\n        vector<int> ret(aliceArrows.size(), 0);\\n        helper(numArrows, aliceArrows, aliceArrows.size());\\n        for(int i = aliceArrows.size(); i > 0; i--) {\\n            if(dp[numArrows][i] == dp[numArrows][i-1]) {\\n                ret[i-1] = 0;\\n            } else {\\n                ret[i-1] = aliceArrows[i-1] + 1;\\n                numArrows -= (aliceArrows[i-1] + 1);\\n            }\\n        }\\n        ret[0] += numArrows;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867435,
                "title": "java-dp-for-max-search-and-backtracking-for-array-of-results",
                "content": "\\tclass Solution {\\n\\t\\tprivate int[] arrows = new int[12];\\n\\n\\t\\tpublic int[] maximumBobPoints(int numArrows, int[] al) {\\n\\t\\t\\tint[][] result = new int[2][numArrows + 1];\\n\\t\\t\\tfor (int i = 0; i < 12; i++)  {\\n\\t\\t\\t\\tfor (int j = 1; j <= numArrows; j++) {\\n\\t\\t\\t\\t\\tint take = (al[i] < j) ? al[i] + 1 : 0;\\n\\t\\t\\t\\t\\tint points = (take > 0) ? i : 0;\\n\\t\\t\\t\\t\\tresult[1][j] = Math.max(result[0][j], result[0][j - take] + points);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor (int j = 0; j <= numArrows; j++) \\n\\t\\t\\t\\t\\tresult[0][j] = result[1][j];\\n\\t\\t\\t}\\n\\n\\t\\t\\tbackTracking(result[1][numArrows], numArrows, al, 11);\\n\\n\\t\\t\\treturn arrows;\\n\\t\\t}\\n\\n\\t\\tpublic boolean backTracking(int max, int numArrows, int[] al, int step) {\\n\\t\\t\\tif ((numArrows < 0) || step < 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (max == 0) {\\n\\t\\t\\t\\tif (numArrows > 0)\\n\\t\\t\\t\\t\\tarrows[0] = numArrows;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} \\n\\n\\t\\t\\tif (!backTracking(max - step, numArrows - al[step] - 1, al, step - 1)) {\\n\\t\\t\\t\\treturn backTracking(max, numArrows, al, step - 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tarrows[step] = al[step] + 1;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\tprivate int[] arrows = new int[12];\\n\\n\\t\\tpublic int[] maximumBobPoints(int numArrows, int[] al) {\\n\\t\\t\\tint[][] result = new int[2][numArrows + 1];\\n\\t\\t\\tfor (int i = 0; i < 12; i++)  {\\n\\t\\t\\t\\tfor (int j = 1; j <= numArrows; j++) {\\n\\t\\t\\t\\t\\tint take = (al[i] < j) ? al[i] + 1 : 0;\\n\\t\\t\\t\\t\\tint points = (take > 0) ? i : 0;\\n\\t\\t\\t\\t\\tresult[1][j] = Math.max(result[0][j], result[0][j - take] + points);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1867166,
                "title": "c-0-1-knapsack-problem-backtracking",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<int> res;\\n    int maxi=0;\\n    \\n    void solve(int arrow,vector<int> &alice,vector<int>& score,int sum,int idx){\\n        //base case\\n        if(idx<0 || arrow<=0){\\n            if(sum>maxi){\\n                if(arrow > 0)\\n                    score[0]+=arrow;\\n                maxi=sum;\\n                res=score;\\n            }\\n            return;\\n        }\\n        \\n        // if we include the current index\\n        if((arrow-(alice[idx]+1))>=0){\\n            score[idx]=alice[idx]+1;\\n            solve(arrow-(alice[idx]+1),alice,score,sum+idx,idx-1);\\n            score[idx]=0;\\n        }\\n        //if we are not including the current index\\n            solve(arrow,alice,score,sum,idx-1);\\n        \\n    }\\n    \\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> score(12,0);\\n                                      //sum//idx\\n        solve(numArrows,aliceArrows,score,0,11);\\n        //cout<<maxi<<\" \";\\n        return res;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> res;\\n    int maxi=0;\\n    \\n    void solve(int arrow,vector<int> &alice,vector<int>& score,int sum,int idx){\\n        //base case\\n        if(idx<0 || arrow<=0){\\n            if(sum>maxi){\\n                if(arrow > 0)\\n                    score[0]+=arrow;\\n                maxi=sum;\\n                res=score;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1867058,
                "title": "c-dp-state-machine",
                "content": "Every index you have 2 options, either you can lose or win  -- i.e. 2 states at every index.\\nSuppose, if I plan to win at index i:\\n\\tarrowsLeft = numArrows -( aliceArrows[i] + 1) ;\\n\\twinPoints(i, numArrows ) = i + Max( winPoints( i+1, arrowsLeft) , losePoints( i+1, arrowsLeft) )\\nInstead, if I plan to lose at index i:\\n  losePoints(i, numArrows ) = Max( winPoints(i+1, numArrows), losePoints(i+1, numArrows) )\\n \\n Now, whether will I actually win or lose at index i will be a decision made based on which is max among winPoints(i, numArrows) & losePoints(i, numArrows)\\n \\n This type of problems where each index will have different possible states -- is what I call state Machine. So, this is a DP + State Machine problem.\\n\\nTime Complexity: O(numArrows * n * 2)  Here n = 12.\\n \\n Please **upvote** if you like the explanation.\\n \\n ```\\n class Solution {\\nprivate:\\n    int calcPoints(vector<int>& aliceArrows, vector<vector<int>>& winPoints, vector<vector<int>>& losePoints, int i, int numArrows){\\n        int n = aliceArrows.size();\\n        if(i>=n) return 0;\\n        else if(numArrows==0){\\n            winPoints[i][numArrows] =0;\\n            losePoints[i][numArrows] =0;\\n            return 0;\\n        }\\n        else if(winPoints[i][numArrows]!=-1 && losePoints[i][numArrows]!=-1){\\n            return max(winPoints[i][numArrows], losePoints[i][numArrows]);\\n        }\\n        if(numArrows> aliceArrows[i]){\\n            winPoints[i][numArrows] = i + calcPoints(aliceArrows, winPoints, losePoints, i+1, numArrows - aliceArrows[i] -1 );\\n        }\\n        else{\\n            winPoints[i][numArrows] = 0;\\n        }\\n        \\n        losePoints[i][numArrows] = calcPoints(aliceArrows, winPoints, losePoints, i+1, numArrows);\\n        \\n        return max(winPoints[i][numArrows], losePoints[i][numArrows]);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n        vector<vector<int>> winPoints(n, vector<int>(numArrows+1, -1));\\n        vector<vector<int>> losePoints(n, vector<int>(numArrows+1, -1));\\n        \\n        calcPoints(aliceArrows, winPoints, losePoints, 0, numArrows);\\n        \\n        int arrows = numArrows;\\n        vector<int> bobArrows(n, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            if(winPoints[i][arrows]>losePoints[i][arrows]){\\n                bobArrows[i] = aliceArrows[i]+1;\\n                arrows = arrows - bobArrows[i];\\n            }\\n        }\\n        \\n        if(arrows){\\n            bobArrows[n-1] += arrows;\\n        }\\n        \\n        return bobArrows;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n class Solution {\\nprivate:\\n    int calcPoints(vector<int>& aliceArrows, vector<vector<int>>& winPoints, vector<vector<int>>& losePoints, int i, int numArrows){\\n        int n = aliceArrows.size();\\n        if(i>=n) return 0;\\n        else if(numArrows==0){\\n            winPoints[i][numArrows] =0;\\n            losePoints[i][numArrows] =0;\\n            return 0;\\n        }\\n        else if(winPoints[i][numArrows]!=-1 && losePoints[i][numArrows]!=-1){\\n            return max(winPoints[i][numArrows], losePoints[i][numArrows]);\\n        }\\n        if(numArrows> aliceArrows[i]){\\n            winPoints[i][numArrows] = i + calcPoints(aliceArrows, winPoints, losePoints, i+1, numArrows - aliceArrows[i] -1 );\\n        }\\n        else{\\n            winPoints[i][numArrows] = 0;\\n        }\\n        \\n        losePoints[i][numArrows] = calcPoints(aliceArrows, winPoints, losePoints, i+1, numArrows);\\n        \\n        return max(winPoints[i][numArrows], losePoints[i][numArrows]);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n        vector<vector<int>> winPoints(n, vector<int>(numArrows+1, -1));\\n        vector<vector<int>> losePoints(n, vector<int>(numArrows+1, -1));\\n        \\n        calcPoints(aliceArrows, winPoints, losePoints, 0, numArrows);\\n        \\n        int arrows = numArrows;\\n        vector<int> bobArrows(n, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            if(winPoints[i][arrows]>losePoints[i][arrows]){\\n                bobArrows[i] = aliceArrows[i]+1;\\n                arrows = arrows - bobArrows[i];\\n            }\\n        }\\n        \\n        if(arrows){\\n            bobArrows[n-1] += arrows;\\n        }\\n        \\n        return bobArrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866610,
                "title": "c-bottom-up-dp-o-arrows-12-time-o-arrows-12-space-clean-and-concise-knapsack-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int arrows, vector<int>& alice) {\\n        vector<int> bob(12, 0);\\n        \\n        int dp[12][arrows + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 0; i < 12; i++) {\\n            for(int j = 1; j <= arrows; j++) {\\n                dp[i][j] = (i > 0 ? dp[i - 1][j] : 0);\\n                if(j > alice[i]) {\\n                    dp[i][j] = max(dp[i][j], i + (i > 0 ? dp[i - 1][j - alice[i] - 1] : 0));\\n                }\\n            }\\n        }\\n        int i = 11, j = arrows;\\n        while(i >= 1 && j >= 0) {\\n            if(dp[i][j] == dp[i - 1][j]) {\\n                bob[i] = 0;\\n                i--;\\n            }\\n            else {\\n                bob[i] = alice[i] + 1;\\n                j = j - alice[i] - 1;\\n                i--;\\n            }\\n        }\\n        bob[0] = j;\\n        return bob;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int arrows, vector<int>& alice) {\\n        vector<int> bob(12, 0);\\n        \\n        int dp[12][arrows + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 0; i < 12; i++) {\\n            for(int j = 1; j <= arrows; j++) {\\n                dp[i][j] = (i > 0 ? dp[i - 1][j] : 0);\\n                if(j > alice[i]) {\\n                    dp[i][j] = max(dp[i][j], i + (i > 0 ? dp[i - 1][j - alice[i] - 1] : 0));\\n                }\\n            }\\n        }\\n        int i = 11, j = arrows;\\n        while(i >= 1 && j >= 0) {\\n            if(dp[i][j] == dp[i - 1][j]) {\\n                bob[i] = 0;\\n                i--;\\n            }\\n            else {\\n                bob[i] = alice[i] + 1;\\n                j = j - alice[i] - 1;\\n                i--;\\n            }\\n        }\\n        bob[0] = j;\\n        return bob;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866321,
                "title": "explaination-hints-java-code-backtracking-100-faster",
                "content": "Hint 1 - For each index ( Except 0 , for 0 refer Hint 2) :-  Bob will need 1 extra arrow than Alice to win points .\\nHint 2 - Ignore 0th index , because it does not fetch us any points . Any extra arrows left at the end can be accomodated at 0th index.\\n\\nNow for example :- \\naliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\\nthen for each index Bob require +1 of Alice arrow :-\\nBob =   [2,2,1,2,1,1,3,2,1,2,3,1]\\n \\nFrom this array we have to chose the index which fetch us the maximum points and store indexes in list *arr* during backtracking. \\n\\nWe will start from index 11 and go upto index 1 and use backtracking (using variable i ). \\n( Case 1 :   Current index gets added to profit : \\n\\t\\t\\t\\t- *Profit* increases by value of index\\n\\t\\t\\t\\t- *Index* decreases by 1\\n\\t\\t\\t\\t- *Number of arrows* decreased by value in array Bob at index i\\n\\n Case 2 : Current index does not gets added to profit :\\n\\t\\t\\t - *Profit* remains same\\n\\t\\t\\t - *Index* decreases by 1\\n\\t\\t\\t - *Number of arrows* remains same\\n)\\n\\nWe revise our final list every time we get profit more than the current maximum profit.\\n*fin* is the list having indexes that fetch us maximum profit.\\n( For example in above example : *fin = { 4,5,8,9,10,11 }*\\nAt the end store values in result , and if used arrows is less than the numArrows . adjust the remaining at 0 index. \\nIn result we put the values in *array Bob* at indexes received in *fin list. *\\n\\t\\'\\'\\'`\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        \\n        int l = aliceArrows.length, c=0;\\n        ArrayList<Integer> fin = new ArrayList<>();\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int[] maxx = new int[]{0};\\n        int[] bob = new int[l];\\n        \\n        for(int i=1; i<l; i++){\\n            bob[i] = aliceArrows[i] + 1;\\n        }\\n        \\n        help(bob , 0, arr, fin, maxx, 11 , numArrows);  \\n        \\n        int[] res = new int[l];\\n        for(int x=0; x<fin.size(); x++){\\n            res[fin.get(x)]=bob[fin.get(x)];\\n            c += bob[fin.get(x)];\\n        }\\n        if(c<numArrows){\\n            res[0] = numArrows-c;\\n        }\\n        return res;\\n    }\\n    \\n    public void help( int bob[], int profit, ArrayList<Integer> arr, ArrayList<Integer> fin ,int maxx[],  int i, int n){\\n        \\n        if(i==0){\\n            if(profit>maxx[0] && n>=0){\\n                fin.clear();\\n                int x = arr.size();\\n                for(int j=0; j<x; j++){\\n                    fin.add(arr.get(j));\\n                }\\n                maxx[0] = profit;\\n            }\\n            return;   \\n        }\\n        arr.add(i);\\n        help(bob, profit+i, arr, fin, maxx, i-1, n-bob[i]);\\n        arr.remove(arr.size()-1);\\n        help(bob, profit, arr, fin, maxx, i-1, n);\\n    }  \\n}\\n\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        \\n        int l = aliceArrows.length, c=0;\\n        ArrayList<Integer> fin = new ArrayList<>();\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int[] maxx = new int[]{0}",
                "codeTag": "Java"
            },
            {
                "id": 1866264,
                "title": "javascript-backtracking",
                "content": "**Solution: Backtracking**\\n\\nUse backtracking to find all combinations of using the arrows.\\nFor each slot, try two choices:\\n1. Don\\'t use any arrows\\n2. Use aliceArrows[idx] + 1 arrows to gain idx number of points\\n\\nNote: When we fill all slots and still have some arrows left, we can put the extra arrows in any slot.\\nIn this solution, I have placed them in the last slot.\\n\\nTime Complexity: `O(2^n) `80ms\\nSpace Complexity: `O(2^n)` 42.7MB\\n```\\nvar maximumBobPoints = function(numArrows, aliceArrows) {\\n  let max = 0, n = aliceArrows.length, res;\\n  backtrack(numArrows, 0, 0, Array(n).fill(0));\\n  return res;\\n\\n  function backtrack(arrows, idx, points, bobArrows) {\\n    if (idx === n || arrows === 0) {\\n      let origVal = bobArrows[n - 1];\\n      if (arrows > 0) bobArrows[n - 1] += arrows; // put extra arrows in any slot\\n      if (points > max) {\\n        max = points;\\n        res = [...bobArrows]; \\n      }\\n      bobArrows[n - 1] = origVal;\\n      return;\\n    }\\n\\n    backtrack(arrows, idx + 1, points, bobArrows); // don\\'t use any arrows\\n    if (aliceArrows[idx] + 1 <= arrows) { // use aliceArrows[idx] + 1 arrows to gain idx points\\n      bobArrows[idx] = aliceArrows[idx] + 1;\\n      backtrack(arrows - (aliceArrows[idx] + 1), idx + 1, points + idx, bobArrows);\\n      bobArrows[idx] = 0;\\n    }\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumBobPoints = function(numArrows, aliceArrows) {\\n  let max = 0, n = aliceArrows.length, res;\\n  backtrack(numArrows, 0, 0, Array(n).fill(0));\\n  return res;\\n\\n  function backtrack(arrows, idx, points, bobArrows) {\\n    if (idx === n || arrows === 0) {\\n      let origVal = bobArrows[n - 1];\\n      if (arrows > 0) bobArrows[n - 1] += arrows; // put extra arrows in any slot\\n      if (points > max) {\\n        max = points;\\n        res = [...bobArrows]; \\n      }\\n      bobArrows[n - 1] = origVal;\\n      return;\\n    }\\n\\n    backtrack(arrows, idx + 1, points, bobArrows); // don\\'t use any arrows\\n    if (aliceArrows[idx] + 1 <= arrows) { // use aliceArrows[idx] + 1 arrows to gain idx points\\n      bobArrows[idx] = aliceArrows[idx] + 1;\\n      backtrack(arrows - (aliceArrows[idx] + 1), idx + 1, points + idx, bobArrows);\\n      bobArrows[idx] = 0;\\n    }\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1866042,
                "title": "python3-dp-100-with-detailed-explanation",
                "content": "Idea: For each round, use a dictionary to store:\\n1. Bidding history\\n2. Score so far\\n3. Arrows left \\n\\nThe bidding history is for output. It\\'s getting longer each round.\\nThe score is for comparison at the end. \\nThe arrows left is to see if we can bid in the next round.\\n\\nThe only thing we need to take care of is, there are too many arrows so there are arrows left at the end. My way is to dump them to round 0.\\n\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        # Initialization with round 1 (round 0 is skipped)\\n        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}\\n        \\n        # Loop from round 2\\n        for i in range(2, 12):\\n            prev = dp\\n            dp = {}\\n            \\n            # Consider two possible strategies for each state from last round: to bid and not to bid\\n            for key in prev:\\n                \\n                # Base case: not to bid in this round. Score and arrows left do not change.\\n                # Simply append 0 at the end to the key.\\n                newkey1 = list(key)\\n                newkey1.append(0)\\n                score, arrowleft = prev[key]\\n                \\n                newval1 = (score, arrowleft)\\n                dp[tuple(newkey1)] = newval1\\n                \\n                # If we still have enough arrows, we can bid in this round\\n                if arrowleft >= aliceArrows[i] + 1:\\n                    newkey2 = list(key)\\n                    newkey2.append(aliceArrows[i] + 1)\\n                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))\\n                    dp[tuple(newkey2)] = newval2\\n        \\n        # Select the bidding history with max score\\n        maxscore, res = 0, None\\n        for key in dp:\\n            score, _ = dp[key]\\n            if score > maxscore:\\n                maxscore = score\\n                res = list(key)\\n        \\n        # Taking care of the corner case, where too many arrows are given\\n        if sum(res) < numArrows:\\n            res[0] = numArrows - sum(res)\\n        \\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        # Initialization with round 1 (round 0 is skipped)\\n        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}\\n        \\n        # Loop from round 2\\n        for i in range(2, 12):\\n            prev = dp\\n            dp = {}\\n            \\n            # Consider two possible strategies for each state from last round: to bid and not to bid\\n            for key in prev:\\n                \\n                # Base case: not to bid in this round. Score and arrows left do not change.\\n                # Simply append 0 at the end to the key.\\n                newkey1 = list(key)\\n                newkey1.append(0)\\n                score, arrowleft = prev[key]\\n                \\n                newval1 = (score, arrowleft)\\n                dp[tuple(newkey1)] = newval1\\n                \\n                # If we still have enough arrows, we can bid in this round\\n                if arrowleft >= aliceArrows[i] + 1:\\n                    newkey2 = list(key)\\n                    newkey2.append(aliceArrows[i] + 1)\\n                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))\\n                    dp[tuple(newkey2)] = newval2\\n        \\n        # Select the bidding history with max score\\n        maxscore, res = 0, None\\n        for key in dp:\\n            score, _ = dp[key]\\n            if score > maxscore:\\n                maxscore = score\\n                res = list(key)\\n        \\n        # Taking care of the corner case, where too many arrows are given\\n        if sum(res) < numArrows:\\n            res[0] = numArrows - sum(res)\\n        \\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865858,
                "title": "c-basic-recursion-trick-to-not-get-tricked-clear-solution-c-no-dp-needed",
                "content": "```\\nclass Solution {\\n    private:\\n    vector<int>v;\\n    int ans = 0;\\n    void f(vector<int>&nums,int i,int points,int numArrows,vector<int>&a){\\n        if(i==nums.size() || numArrows<=0){\\n            if(points>ans){\\n                ans = points;\\n                for(int i = 0;i<12;++i){\\n                    v[i] = a[i];\\n                }\\n                v[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        \\n        if(nums[i]<numArrows){\\n            a[i] = nums[i]+1;\\n            f(nums,i+1,points+i,numArrows-nums[i]-1,a);\\n            a[i] = 0;\\n            f(nums,i+1,points,numArrows,a);\\n        }\\n        else{\\n            f(nums,i+1,points,numArrows,a);\\n        }\\n    }\\n    \\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>a(12,0);\\n        v.resize(12,0);\\n        int n = aliceArrows.size();\\n        f(aliceArrows,0,0,numArrows,a);\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private:\\n    vector<int>v;\\n    int ans = 0;\\n    void f(vector<int>&nums,int i,int points,int numArrows,vector<int>&a){\\n        if(i==nums.size() || numArrows<=0){\\n            if(points>ans){\\n                ans = points;\\n                for(int i = 0;i<12;++i){\\n                    v[i] = a[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1865821,
                "title": "recursive-easy-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<int>res;\\n    int score=0;\\n    void util(int arrows,vector<int>&nums,vector<int>&v,int pos,int curr_score){\\n        \\n        if(pos==nums.size()){\\n            if(score<curr_score){\\n                score=curr_score;\\n                res=v;\\n            }\\n            return;\\n        }\\n        \\n        \\n        if(arrows==0){\\n            if(score<curr_score){\\n                score=curr_score;\\n                res=v;\\n            }\\n            return ;\\n        }\\n        \\n        if(score<curr_score){\\n            score=curr_score;\\n            res=v;\\n        }\\n        \\n        \\n        int temp=v[pos];\\n        //either i want that score\\n        if(arrows>=nums[pos]+1){\\n            v[pos]=nums[pos]+1;\\n            util(arrows-v[pos],nums,v,pos+1,curr_score+pos);\\n        }\\n        v[pos]=temp;\\n        util(arrows,nums,v,pos+1,curr_score);\\n        \\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n     //either i can shot a arrow more than alice and can gain those points else i can ignore a point\\n        \\n        vector<int>v(aliceArrows.size(),0);\\n        util(numArrows,aliceArrows,v,0,0);\\n      \\n        int c=0;\\n        for(int i=0;i<res.size();i++)\\n            c+=res[i];\\n        \\n        res[0]+=numArrows-c;\\n        \\n        return res;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int>res;\\n    int score=0;\\n    void util(int arrows,vector<int>&nums,vector<int>&v,int pos,int curr_score){\\n        \\n        if(pos==nums.size()){\\n            if(score<curr_score){\\n                score=curr_score;\\n                res=v;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1865787,
                "title": "2-solutions-c-backtracking-dp-knapsack-solution-easy-to-understand",
                "content": "```\\n// BACKTRACKING SOLUTION\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int points=0;\\n    \\n    void rec(int n,vector<int>& aliceArrows,int idx,int sum,vector<int>& res)\\n    {\\n        if(idx>=12)\\n        {\\n            if(sum>points)\\n            {\\n                points=sum;\\n                ans=res;\\n            }\\n            return;\\n        }\\n        \\n       int req=aliceArrows[idx]+1;\\n       if(n>=req)\\n       {\\n           res[idx]=req;\\n           rec(n-req,aliceArrows,idx+1,sum+idx,res);\\n           res[idx]=0;\\n           rec(n,aliceArrows,idx+1,sum,res);\\n       } \\n       else rec(n,aliceArrows,idx+1,sum,res);\\n       \\n        return;\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12,0);\\n        int sum=0;\\n        rec(numArrows,aliceArrows,0,sum,res);\\n          \\n\\t\\t int n=0;\\n        \\n        for(int i=0;i<12;i++) n+=ans[i];\\n        if(n<numArrows) \\n        {\\n            numArrows-=n;\\n            for(int i=0;i<12;i++)\\n            {\\n                if(ans[i]>0)\\n                {\\n                    ans[i]+=numArrows;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n```\\n// DP SOLUTION\\n\\nclass Solution {\\npublic:\\n    int memo[100005][15];\\n    \\n    int rec(int n,vector<int>& aliceArrows,int idx)\\n    {\\n       if(n==0||idx>=12) return 0;\\n       if(memo[n][idx]!=-1) return memo[n][idx];\\n        \\n       int req=aliceArrows[idx]+1;\\n      \\n       if(n>=req)\\n       {\\n           int a=rec(n-req,aliceArrows,idx+1)+idx;\\n           int b=rec(n,aliceArrows,idx+1);\\n                      \\n           return memo[n][idx]=max(a,b);\\n       } \\n       else return memo[n][idx]=rec(n,aliceArrows,idx+1);\\n       \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        memset(memo,-1,sizeof(memo));\\n        vector<int> res(12,0);\\n        int orgNumArrows=numArrows;\\n        rec(numArrows,aliceArrows,0);\\n        \\n        for(int i=0;i<12;i++)\\n        {\\n            if(rec(numArrows,aliceArrows,i)!=rec(numArrows,aliceArrows,i+1))\\n            {\\n                res[i]=aliceArrows[i]+1;\\n                numArrows-=res[i];\\n            }\\n        }\\n        \\n        int n=0;\\n        \\n        for(int i=0;i<12;i++) n+=res[i];\\n        if(n<orgNumArrows) \\n        {\\n            orgNumArrows-=n;\\n            for(int i=0;i<12;i++)\\n            {\\n                if(res[i]>0)\\n                {\\n                    res[i]+=orgNumArrows;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\n// BACKTRACKING SOLUTION\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int points=0;\\n    \\n    void rec(int n,vector<int>& aliceArrows,int idx,int sum,vector<int>& res)\\n    {\\n        if(idx>=12)\\n        {\\n            if(sum>points)\\n            {\\n                points=sum;\\n                ans=res;\\n            }\\n            return;\\n        }\\n        \\n       int req=aliceArrows[idx]+1;\\n       if(n>=req)\\n       {\\n           res[idx]=req;\\n           rec(n-req,aliceArrows,idx+1,sum+idx,res);\\n           res[idx]=0;\\n           rec(n,aliceArrows,idx+1,sum,res);\\n       } \\n       else rec(n,aliceArrows,idx+1,sum,res);\\n       \\n        return;\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12,0);\\n        int sum=0;\\n        rec(numArrows,aliceArrows,0,sum,res);\\n          \\n\\t\\t int n=0;\\n        \\n        for(int i=0;i<12;i++) n+=ans[i];\\n        if(n<numArrows) \\n        {\\n            numArrows-=n;\\n            for(int i=0;i<12;i++)\\n            {\\n                if(ans[i]>0)\\n                {\\n                    ans[i]+=numArrows;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n// DP SOLUTION\\n\\nclass Solution {\\npublic:\\n    int memo[100005][15];\\n    \\n    int rec(int n,vector<int>& aliceArrows,int idx)\\n    {\\n       if(n==0||idx>=12) return 0;\\n       if(memo[n][idx]!=-1) return memo[n][idx];\\n        \\n       int req=aliceArrows[idx]+1;\\n      \\n       if(n>=req)\\n       {\\n           int a=rec(n-req,aliceArrows,idx+1)+idx;\\n           int b=rec(n,aliceArrows,idx+1);\\n                      \\n           return memo[n][idx]=max(a,b);\\n       } \\n       else return memo[n][idx]=rec(n,aliceArrows,idx+1);\\n       \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        memset(memo,-1,sizeof(memo));\\n        vector<int> res(12,0);\\n        int orgNumArrows=numArrows;\\n        rec(numArrows,aliceArrows,0);\\n        \\n        for(int i=0;i<12;i++)\\n        {\\n            if(rec(numArrows,aliceArrows,i)!=rec(numArrows,aliceArrows,i+1))\\n            {\\n                res[i]=aliceArrows[i]+1;\\n                numArrows-=res[i];\\n            }\\n        }\\n        \\n        int n=0;\\n        \\n        for(int i=0;i<12;i++) n+=res[i];\\n        if(n<orgNumArrows) \\n        {\\n            orgNumArrows-=n;\\n            for(int i=0;i<12;i++)\\n            {\\n                if(res[i]>0)\\n                {\\n                    res[i]+=orgNumArrows;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865765,
                "title": "c-well-commented-dp-with-bitmasking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n\\t\\t\\n\\t\\t// dp[mask] represents the following value:\\n\\t\\t// The positions of set bits of mask represents the target indices where Bob outperforms Alice\\n\\t\\t// dp[mask] represents the minimum number of arrows it would require\\n        vector<int> dp(1 << n, INT_MAX);\\n\\t\\t\\n        dp[0] = 0;\\n\\t\\t\\n\\t\\t// imax stores the maximum score that Bob can get\\n\\t\\t// ans stores the mask with which he gets that score\\n        int imax = 0, ans;\\n        \\n\\t\\t// Iterating over all possible masks\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n\\t\\t\\n\\t\\t\\t// Maintaining the score for the current mask\\n            int score = 0;\\n            for(int i = 0; i < n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// If the current target index is where Bob outperforms Alice\\n                if(mask & (1 << i)) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Including the score of the current target\\n                    score += i;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Updating the DP value\\n\\t\\t\\t\\t\\t// mask ^ (1 << i) resets the bit at i\\n\\t\\t\\t\\t\\t// so dp[mask ^ (1 << i)] is the minimum number of arrows required excluding the current target\\n                    dp[mask] = min(dp[mask], aliceArrows[i] + 1 + dp[mask ^ (1 << i)]);\\n                }\\n            }\\n            \\n\\t\\t\\t// If the minimum number of arrows required\\n\\t\\t\\t// is less than the number of given arrows, \\n\\t\\t\\t// then this mask can be a possible answer\\n            if(dp[mask] <= numArrows) {\\n                if(score > imax) {\\n                    imax = score;\\n                    ans = mask;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// To determine the vector which is to be returned, \\n\\t\\t// we traverse over all indices.\\n\\t\\t// If it is included in the final mask, then Bob is given 1 arrow more than\\n\\t\\t// what Alice has in that index\\n        vector<int> ret(n);\\n        for(int i = 0; i < n; i++) {\\n            if(ans & (1 << i)) {\\n                ret[i] = aliceArrows[i] + 1;\\n                numArrows -= ret[i];\\n            }\\n        }\\n        \\n\\t\\t// The remaining arrows are added to the first target index as it makes\\n\\t\\t// no difference\\n        ret[0] += numArrows;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n\\t\\t\\n\\t\\t// dp[mask] represents the following value:\\n\\t\\t// The positions of set bits of mask represents the target indices where Bob outperforms Alice\\n\\t\\t// dp[mask] represents the minimum number of arrows it would require\\n        vector<int> dp(1 << n, INT_MAX);\\n\\t\\t\\n        dp[0] = 0;\\n\\t\\t\\n\\t\\t// imax stores the maximum score that Bob can get\\n\\t\\t// ans stores the mask with which he gets that score\\n        int imax = 0, ans;\\n        \\n\\t\\t// Iterating over all possible masks\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n\\t\\t\\n\\t\\t\\t// Maintaining the score for the current mask\\n            int score = 0;\\n            for(int i = 0; i < n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// If the current target index is where Bob outperforms Alice\\n                if(mask & (1 << i)) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Including the score of the current target\\n                    score += i;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Updating the DP value\\n\\t\\t\\t\\t\\t// mask ^ (1 << i) resets the bit at i\\n\\t\\t\\t\\t\\t// so dp[mask ^ (1 << i)] is the minimum number of arrows required excluding the current target\\n                    dp[mask] = min(dp[mask], aliceArrows[i] + 1 + dp[mask ^ (1 << i)]);\\n                }\\n            }\\n            \\n\\t\\t\\t// If the minimum number of arrows required\\n\\t\\t\\t// is less than the number of given arrows, \\n\\t\\t\\t// then this mask can be a possible answer\\n            if(dp[mask] <= numArrows) {\\n                if(score > imax) {\\n                    imax = score;\\n                    ans = mask;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// To determine the vector which is to be returned, \\n\\t\\t// we traverse over all indices.\\n\\t\\t// If it is included in the final mask, then Bob is given 1 arrow more than\\n\\t\\t// what Alice has in that index\\n        vector<int> ret(n);\\n        for(int i = 0; i < n; i++) {\\n            if(ans & (1 << i)) {\\n                ret[i] = aliceArrows[i] + 1;\\n                numArrows -= ret[i];\\n            }\\n        }\\n        \\n\\t\\t// The remaining arrows are added to the first target index as it makes\\n\\t\\t// no difference\\n        ret[0] += numArrows;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865739,
                "title": "simple-recursive-solution-c",
                "content": "https://leetcode.com/submissions/detail/663473879/\\n\\nclass Solution {\\n    string ans;\\n    int mx=0;\\npublic:\\n    int validateString(string s)\\n    {\\n        int val=0;\\n        for(int i=0;i<11;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n             val+=11-i;   \\n        }\\n       return val; \\n    }\\n    int f(int k, vector<int>& a,int i,vector<int>& b,string y)\\n    {\\n        int n=a.size();   \\n        if(i<0)\\n        {\\n            int curr_val=validateString(y);\\n            if(curr_val>mx)\\n            {\\n                mx=curr_val;\\n                ans=y;\\n            }\\n            return 0;\\n        }\\n        int take =0;\\n        if(a[i]<k)\\n        {\\n            take=i+1+f(k-a[i]-1,a,i-1,b,y+\\'1\\');\\n        }\\n        int notTake=f(k,a,i-1,b,y+\\'0\\');\\n       \\n        return max(take,notTake);;\\n    }\\n    vector<int> maximumBobPoints(int k, vector<int>& a) {\\n        int n=a.size();\\n        string y;\\n        vector<int> b(n,0);\\n        f(k,a,n-1,b,y);\\n        reverse(ans.begin(),ans.end());\\n        for(int i=0;i<=11;i++)\\n        {\\n            if(ans[i]==\\'1\\')\\n                b[i]=a[i]+1;\\n            k-=b[i];  \\n        }\\n        b[0]+=k;   // adding the remaining shots (GOT LATE IN CONTEST BECAUSE OF THIS)\\n        return b;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    string ans;\\n    int mx=0;\\npublic:\\n    int validateString(string s)\\n    {\\n        int val=0;\\n        for(int i=0;i<11;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n             val+=11-i;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1865671,
                "title": "recursion-basic-cpp-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>final;\\n    int maxs=0;\\n    int helper(int arrows,vector<int>&alice,vector<int>bob,int currsum,int i)\\n    {\\n        if(arrows==0){\\n            if(currsum>maxs)\\n            {\\n                final=bob;maxs=currsum;\\n            }\\n            return currsum;\\n        }\\n        if(arrows<0)\\n         return INT_MIN;  \\n        if(i>=12){\\n            if(arrows>0)\\n            {\\n                if(currsum>maxs){\\n                    bob[0]=arrows;\\n                    maxs=currsum;\\n                    final=bob;\\n                }\\n            }\\n            \\n            return 0;}\\n        \\n        helper(arrows,alice,bob,currsum,i+1);\\n        if(alice[i]==0)bob[i]=1;\\n        else\\n            bob[i]=alice[i]+1;\\n        helper(arrows-bob[i],alice,bob,currsum+i,i+1);\\n        return 0;\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n       \\n        helper(numArrows,aliceArrows,bob,0,0);\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>final;\\n    int maxs=0;\\n    int helper(int arrows,vector<int>&alice,vector<int>bob,int currsum,int i)\\n    {\\n        if(arrows==0){\\n            if(currsum>maxs)\\n            {\\n                final=bob;maxs=currsum;\\n            }\\n            return currsum;\\n        }\\n        if(arrows<0)\\n         return INT_MIN;  \\n        if(i>=12){\\n            if(arrows>0)\\n            {\\n                if(currsum>maxs){\\n                    bob[0]=arrows;\\n                    maxs=currsum;\\n                    final=bob;\\n                }\\n            }\\n            \\n            return 0;}\\n        \\n        helper(arrows,alice,bob,currsum,i+1);\\n        if(alice[i]==0)bob[i]=1;\\n        else\\n            bob[i]=alice[i]+1;\\n        helper(arrows-bob[i],alice,bob,currsum+i,i+1);\\n        return 0;\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n       \\n        helper(numArrows,aliceArrows,bob,0,0);\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865661,
                "title": "simple-recusive-dp-solution-no-need-of-memo",
                "content": "class Solution {\\n    string ans;\\n    int mx=0;\\npublic:\\n    int val(string s)\\n    {\\n        int f=0;\\n        for(int i=0;i<11;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n             f+=11-i;   \\n        }\\n       return f; \\n    }\\n    int f(int k, vector<int>& a,int i,vector<int>& b,string y)\\n    {\\n        int n=a.size();   \\n        if(i<0)\\n        {\\n            int o=val(y);\\n            if(o>mx)\\n            {\\n                mx=o;\\n                ans=y;\\n            }\\n            return 0;\\n        }\\n        int take =0;\\n        if(a[i]<k)\\n        {\\n            take=i+1+f(k-a[i]-1,a,i-1,b,y+\\'1\\');\\n        }\\n        int notTake=f(k,a,i-1,b,y+\\'0\\');\\n        int cur=max(take,notTake);\\n        if(i==0)\\n        { \\n            if(mx<cur)\\n            ans=y,mx=cur;     \\n        }\\n        return cur;\\n    }\\n    vector<int> maximumBobPoints(int k, vector<int>& a) {\\n        int n=a.size();\\n        string y;\\n        vector<int> b(n,0);\\n        int p=f(k,a,n-1,b,y);\\n        reverse(ans.begin(),ans.end());\\n        for(int i=0;i<=11;i++)\\n        {\\n            if(ans[i]==\\'1\\')\\n                b[i]=a[i]+1;\\n            k-=b[i];\\n        }\\n        b[0]+=k;\\n        return b;\\n    }\\n1. * };",
                "solutionTags": [],
                "code": "class Solution {\\n    string ans;\\n    int mx=0;\\npublic:\\n    int val(string s)\\n    {\\n        int f=0;\\n        for(int i=0;i<11;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n             f+=11-i;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1865630,
                "title": "simple-c-recursive-solution",
                "content": "```\\nclass Solution {\\n    \\n    void func(int ind,int count,vector<int>& a,vector<int>& ans,vector<int> temp,int sum,int& total){\\n        if(count==0 || ind<0){\\n            if(sum>total){\\n                ans=temp;\\n                total=sum;\\n            }\\n            return ;\\n        }\\n        \\n        //pick all count at zero index\\n        if(ind==0){\\n            if(count>a[ind]){\\n                temp[ind]=count;\\n\\t\\t\\t\\tfunc(ind-1,0,a,ans,temp,sum+ind,total);\\n\\t\\t\\t\\ttemp[ind]=0;\\n            }\\n            else{\\n                temp[ind]=count;\\n                func(ind-1,0,a,ans,temp,sum,total);\\n                temp[ind]=0;\\n            }\\n            return;\\n        }\\n        \\n\\t\\t//pick condition\\n        if(count>a[ind]){\\n                temp[ind]=a[ind]+1;\\n                func(ind-1,count-a[ind]-1,a,ans,temp,sum+ind,total);\\n                temp[ind]=0;\\n            \\n        }\\n\\t\\t//not pick\\n        func(ind-1,count,a,ans,temp,sum,total);\\n        \\n    }\\n    \\n    \\npublic:\\n    vector<int> maximumBobPoints(int count, vector<int>& a) {\\n        vector<int> ans(12,0),temp(12,0);\\n        \\n        int total=0;\\n        func(11,count,a,ans,temp,0,total);\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void func(int ind,int count,vector<int>& a,vector<int>& ans,vector<int> temp,int sum,int& total){\\n        if(count==0 || ind<0){\\n            if(sum>total){\\n                ans=temp;\\n                total=sum;\\n            }\\n            return ;\\n        }\\n        \\n        //pick all count at zero index\\n        if(ind==0){\\n            if(count>a[ind]){\\n                temp[ind]=count;\\n\\t\\t\\t\\tfunc(ind-1,0,a,ans,temp,sum+ind,total);\\n\\t\\t\\t\\ttemp[ind]=0;\\n            }\\n            else{\\n                temp[ind]=count;\\n                func(ind-1,0,a,ans,temp,sum,total);\\n                temp[ind]=0;\\n            }\\n            return;\\n        }\\n        \\n\\t\\t//pick condition\\n        if(count>a[ind]){\\n                temp[ind]=a[ind]+1;\\n                func(ind-1,count-a[ind]-1,a,ans,temp,sum+ind,total);\\n                temp[ind]=0;\\n            \\n        }\\n\\t\\t//not pick\\n        func(ind-1,count,a,ans,temp,sum,total);\\n        \\n    }\\n    \\n    \\npublic:\\n    vector<int> maximumBobPoints(int count, vector<int>& a) {\\n        vector<int> ans(12,0),temp(12,0);\\n        \\n        int total=0;\\n        func(11,count,a,ans,temp,0,total);\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865600,
                "title": "python3-clean-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.max_points = 0\\n        self.res = None\\n        bobArrows = [0] * len(aliceArrows)\\n        \\n        def backtrack(budget, i, points, bobArrows):\\n            if not budget or i == len(aliceArrows):\\n                if points > self.max_points:\\n                    self.max_points = points\\n                    self.res = bobArrows[:]\\n                return\\n                \\n            if budget > aliceArrows[i]:\\n                bobArrows[i] = aliceArrows[i] + 1\\n                backtrack(budget - bobArrows[i], i+1, points + i, bobArrows)\\n\\t\\t\\t\\t# Undo\\n                bobArrows[i] = 0\\n            \\n            backtrack(budget, i+1, points, bobArrows)\\n                \\n            \\n        backtrack(numArrows, 1, 0, bobArrows)\\n\\t\\t# Remaining arrows assign to 0 points\\n        self.res[0] = numArrows - sum(self.res)\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.max_points = 0\\n        self.res = None\\n        bobArrows = [0] * len(aliceArrows)\\n        \\n        def backtrack(budget, i, points, bobArrows):\\n            if not budget or i == len(aliceArrows):\\n                if points > self.max_points:\\n                    self.max_points = points\\n                    self.res = bobArrows[:]\\n                return\\n                \\n            if budget > aliceArrows[i]:\\n                bobArrows[i] = aliceArrows[i] + 1\\n                backtrack(budget - bobArrows[i], i+1, points + i, bobArrows)\\n\\t\\t\\t\\t# Undo\\n                bobArrows[i] = 0\\n            \\n            backtrack(budget, i+1, points, bobArrows)\\n                \\n            \\n        backtrack(numArrows, 1, 0, bobArrows)\\n\\t\\t# Remaining arrows assign to 0 points\\n        self.res[0] = numArrows - sum(self.res)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865585,
                "title": "python-backtracking-with-explanation",
                "content": "We use backtracking from the right side to find all the possibilities. \\n\\nTerminate the backtracking when we have gone past the last section or ran out of arrows.\\n\\n```py\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        max_score = [0, None]\\n        def calc(i, remaining, score, arrows):\\n\\t\\t    # Base case. Update max score.\\n            if remaining == 0 or i == -1:\\n                if score > max_score[0]:\\n                    max_score[0] = score\\n                    max_score[1] = arrows[:]\\n                return\\n\\n\\t\\t\\t# Special handling for the last section. Use up all the arrows.\\n            if i == 0:\\n                arrows[i] = remaining\\n                calc(i - 1, 0, score + i, arrows)\\n                arrows[i] = 0\\n                return\\n\\n\\t\\t    # Try to compete with Alice if there are enough arrows.\\n            arrowsNeeded = aliceArrows[i] + 1\\n            if remaining >= arrowsNeeded:\\n                arrows[i] = arrowsNeeded\\n                calc(i - 1, remaining - arrowsNeeded, score + i, arrows)\\n                arrows[i] = 0\\n\\n            # Skip this section and go to the next section.\\n            calc(i - 1, remaining, score, arrows)\\n        \\n\\t\\t# Kick off the recursion\\n        calc(len(aliceArrows) - 1, numArrows, 0, [0 for _ in aliceArrows])\\n        return max_score[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        max_score = [0, None]\\n        def calc(i, remaining, score, arrows):\\n\\t\\t    # Base case. Update max score.\\n            if remaining == 0 or i == -1:\\n                if score > max_score[0]:\\n                    max_score[0] = score\\n                    max_score[1] = arrows[:]\\n                return\\n\\n\\t\\t\\t# Special handling for the last section. Use up all the arrows.\\n            if i == 0:\\n                arrows[i] = remaining\\n                calc(i - 1, 0, score + i, arrows)\\n                arrows[i] = 0\\n                return\\n\\n\\t\\t    # Try to compete with Alice if there are enough arrows.\\n            arrowsNeeded = aliceArrows[i] + 1\\n            if remaining >= arrowsNeeded:\\n                arrows[i] = arrowsNeeded\\n                calc(i - 1, remaining - arrowsNeeded, score + i, arrows)\\n                arrows[i] = 0\\n\\n            # Skip this section and go to the next section.\\n            calc(i - 1, remaining, score, arrows)\\n        \\n\\t\\t# Kick off the recursion\\n        calc(len(aliceArrows) - 1, numArrows, 0, [0 for _ in aliceArrows])\\n        return max_score[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865580,
                "title": "python-recursion-without-dp",
                "content": "the list is too small, just brute force with recursion\\n```\\ndef maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n    def get_max(i, numArrows):\\n        if i == len(aliceArrows):\\n            return 0, [0] * len(aliceArrows)\\n        else:\\n            alicearrow = aliceArrows[i]\\n            c1, res1 = get_max(i+1, numArrows)\\n            c2 = -1\\n            if numArrows-alicearrow-1 >= 0:\\n                c2, res2 = get_max(i+1, numArrows-alicearrow-1)\\n                c2 += i\\n                res2[i] = alicearrow + 1\\n            if c1 > c2:\\n                return c1, res1\\n            else:\\n                return c2, res2\\n    res = get_max(0,numArrows)[1]\\n    s = sum(res)\\n    if s < numArrows:\\n        res[0] += numArrows - s\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n    def get_max(i, numArrows):\\n        if i == len(aliceArrows):\\n            return 0, [0] * len(aliceArrows)\\n        else:\\n            alicearrow = aliceArrows[i]\\n            c1, res1 = get_max(i+1, numArrows)\\n            c2 = -1\\n            if numArrows-alicearrow-1 >= 0:\\n                c2, res2 = get_max(i+1, numArrows-alicearrow-1)\\n                c2 += i\\n                res2[i] = alicearrow + 1\\n            if c1 > c2:\\n                return c1, res1\\n            else:\\n                return c2, res2\\n    res = get_max(0,numArrows)[1]\\n    s = sum(res)\\n    if s < numArrows:\\n        res[0] += numArrows - s\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3945256,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    constexpr int allMask = (1 << 12) - 1;\\n    int maxPoint = 0;\\n    int maxMask = 0;\\n\\n    for (int mask = 0; mask < allMask; ++mask) {\\n      const auto& [shotable, point] =\\n          getShotableAndPoint(mask, numArrows, aliceArrows);\\n      if (shotable && point > maxPoint) {\\n        maxPoint = point;\\n        maxMask = mask;\\n      }\\n    }\\n\\n    return getBobsArrows(maxMask, numArrows, aliceArrows);\\n  }\\n\\n private:\\n  pair<bool, int> getShotableAndPoint(int mask, int leftArrows,\\n                                      const vector<int>& aliceArrows) {\\n    int point = 0;\\n    for (int i = 0; i < 12; ++i)\\n      if (mask >> i & 1) {\\n        leftArrows -= aliceArrows[i] + 1;\\n        point += i;\\n      }\\n    return {leftArrows >= 0, point};\\n  }\\n\\n  vector<int> getBobsArrows(int mask, int leftArrows,\\n                            const vector<int>& aliceArrows) {\\n    vector<int> bobsArrows(12);\\n    for (int i = 0; i < 12; ++i)\\n      if (mask >> i & 1) {\\n        bobsArrows[i] = aliceArrows[i] + 1;\\n        leftArrows -= aliceArrows[i] + 1;\\n      }\\n    bobsArrows[0] = leftArrows;\\n    return bobsArrows;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    constexpr int allMask = (1 << 12) - 1;\\n    int maxPoint = 0;\\n    int maxMask = 0;\\n\\n    for (int mask = 0; mask < allMask; ++mask) {\\n      const auto& [shotable, point] =\\n          getShotableAndPoint(mask, numArrows, aliceArrows);\\n      if (shotable && point > maxPoint) {\\n        maxPoint = point;\\n        maxMask = mask;\\n      }\\n    }\\n\\n    return getBobsArrows(maxMask, numArrows, aliceArrows);\\n  }\\n\\n private:\\n  pair<bool, int> getShotableAndPoint(int mask, int leftArrows,\\n                                      const vector<int>& aliceArrows) {\\n    int point = 0;\\n    for (int i = 0; i < 12; ++i)\\n      if (mask >> i & 1) {\\n        leftArrows -= aliceArrows[i] + 1;\\n        point += i;\\n      }\\n    return {leftArrows >= 0, point};\\n  }\\n\\n  vector<int> getBobsArrows(int mask, int leftArrows,\\n                            const vector<int>& aliceArrows) {\\n    vector<int> bobsArrows(12);\\n    for (int i = 0; i < 12; ++i)\\n      if (mask >> i & 1) {\\n        bobsArrows[i] = aliceArrows[i] + 1;\\n        leftArrows -= aliceArrows[i] + 1;\\n      }\\n    bobsArrows[0] = leftArrows;\\n    return bobsArrows;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894651,
                "title": "golang-backtracking",
                "content": "# Code\\n```\\nfunc maximumBobPoints(numArrows int, aliceArrows []int) []int {\\n  var bobArrows []int\\n  currPoints := make([]int, 12)\\n  backtrack(numArrows, aliceArrows, 0, currPoints, &bobArrows)\\n  return bobArrows\\n}\\n\\nfunc backtrack(numArrows int, aliceArrows []int, pos int, currPoints []int, bobArrows *[]int) {\\n  if pos == 12 {\\n    if calcPoints(aliceArrows, currPoints) > calcPoints(aliceArrows, *bobArrows) {\\n      points := make([]int, len(currPoints))\\n      copy(points, currPoints)\\n      if numArrows > 0 {\\n        // Put the remaining arrows in 0\\n        points[0] += numArrows\\n      }\\n      *bobArrows = points\\n\\n    }\\n    return\\n  }\\n  backtrack(numArrows, aliceArrows, pos+1, currPoints, bobArrows)\\n  if numArrows >= aliceArrows[pos] + 1 {\\n    currPoints[pos] = aliceArrows[pos] + 1\\n    backtrack(numArrows - aliceArrows[pos] - 1, aliceArrows, pos+1, currPoints, bobArrows)\\n    currPoints[pos] = 0\\n  }\\n}\\n\\nfunc calcPoints(alice, bob []int) int {\\n  var res int\\n  for i := 0; i < len(bob); i++ {\\n    if bob[i] > alice[i] {\\n      res += i\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc maximumBobPoints(numArrows int, aliceArrows []int) []int {\\n  var bobArrows []int\\n  currPoints := make([]int, 12)\\n  backtrack(numArrows, aliceArrows, 0, currPoints, &bobArrows)\\n  return bobArrows\\n}\\n\\nfunc backtrack(numArrows int, aliceArrows []int, pos int, currPoints []int, bobArrows *[]int) {\\n  if pos == 12 {\\n    if calcPoints(aliceArrows, currPoints) > calcPoints(aliceArrows, *bobArrows) {\\n      points := make([]int, len(currPoints))\\n      copy(points, currPoints)\\n      if numArrows > 0 {\\n        // Put the remaining arrows in 0\\n        points[0] += numArrows\\n      }\\n      *bobArrows = points\\n\\n    }\\n    return\\n  }\\n  backtrack(numArrows, aliceArrows, pos+1, currPoints, bobArrows)\\n  if numArrows >= aliceArrows[pos] + 1 {\\n    currPoints[pos] = aliceArrows[pos] + 1\\n    backtrack(numArrows - aliceArrows[pos] - 1, aliceArrows, pos+1, currPoints, bobArrows)\\n    currPoints[pos] = 0\\n  }\\n}\\n\\nfunc calcPoints(alice, bob []int) int {\\n  var res int\\n  for i := 0; i < len(bob); i++ {\\n    if bob[i] > alice[i] {\\n      res += i\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3824892,
                "title": "top-down-dp-memoization-prefix-sum-optimization-3ms-beats-98-72-in-runtime",
                "content": "# Code\\n```\\nclass Solution {\\n  private List < Integer > getOptimalDistribution(\\n    int[] aliceArrows,\\n    int tillIndex,\\n    int numArrows,\\n    int[] pref,\\n    Map < Integer, Map < Integer, List < Integer >>> dp\\n  ) {\\n    if (dp.get(tillIndex).containsKey(numArrows)) {\\n      return dp.get(tillIndex).get(numArrows);\\n    }\\n\\n    List < Integer > res = new ArrayList < > ();\\n    if (tillIndex == 0) {\\n      res.add(0);\\n      res.add(numArrows >= aliceArrows[tillIndex] + 1 ? 1 : 0);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    if (numArrows == 0) {\\n      res.add(0);\\n      res.add(0);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    if (numArrows >= pref[tillIndex] + tillIndex) {\\n      int score = (tillIndex * (tillIndex + 1)) / 2;\\n      int mask = 0;\\n      int cnt = numArrows;\\n      for (int k = tillIndex; k >= 0; k--) {\\n        mask |= cnt >= aliceArrows[k] + 1 ? (1 << k) : 0;\\n        cnt -= aliceArrows[k] + 1;\\n      }\\n      res.add(score);\\n      res.add(mask);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    List < Integer > resI = null, resE = null;\\n    if (numArrows >= aliceArrows[tillIndex] + 1) {\\n      resI = this.getOptimalDistribution(\\n        aliceArrows,\\n        tillIndex - 1,\\n        numArrows - aliceArrows[tillIndex] - 1,\\n        pref,\\n        dp\\n      );\\n    }\\n\\n    resE = this.getOptimalDistribution(\\n      aliceArrows,\\n      tillIndex - 1,\\n      numArrows,\\n      pref,\\n      dp\\n    );\\n\\n    if (resI != null &&\\n      resI.get(0) + tillIndex >= resE.get(0)\\n    ) {\\n      res.add(tillIndex + resI.get(0));\\n      res.add((1 << tillIndex) | resI.get(1));\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    res.add(resE.get(0));\\n    res.add(resE.get(1));\\n    dp.get(tillIndex).put(numArrows, res);\\n\\n    return res;\\n  }\\n\\n  public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n    int[] pref = new int[12];\\n    int[] result = new int[12];\\n    Map < Integer, Map < Integer, List < Integer >>> cache = new HashMap < > ();\\n\\n    for (int i = 0; i < 12; i++) {\\n      if (numArrows == 1 && aliceArrows[12 - i - 1] == 0) {\\n        result[12 - i - 1] = 1;\\n        return result;\\n      }\\n\\n      cache.put(i, new HashMap < Integer, List < Integer >> ());\\n      if (i == 0) {\\n        pref[i] = aliceArrows[i];\\n        continue;\\n      }\\n\\n      pref[i] = aliceArrows[i] + pref[i - 1];\\n    }\\n\\n    List < Integer > optDist = this.getOptimalDistribution(\\n      aliceArrows,\\n      aliceArrows.length - 1,\\n      numArrows,\\n      pref,\\n      cache\\n    );\\n\\n    int cnt = numArrows;\\n    int lastSetBit = -1;\\n    for (int i = 0; i < 12; i++) {\\n      if ((optDist.get(1) & (1 << i)) != 0) {\\n        lastSetBit = i;\\n        result[i] = aliceArrows[i] + 1;\\n        cnt -= result[i];\\n      }\\n    }\\n\\n    if(cnt > 0) {\\n      result[lastSetBit] += cnt;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n  private List < Integer > getOptimalDistribution(\\n    int[] aliceArrows,\\n    int tillIndex,\\n    int numArrows,\\n    int[] pref,\\n    Map < Integer, Map < Integer, List < Integer >>> dp\\n  ) {\\n    if (dp.get(tillIndex).containsKey(numArrows)) {\\n      return dp.get(tillIndex).get(numArrows);\\n    }\\n\\n    List < Integer > res = new ArrayList < > ();\\n    if (tillIndex == 0) {\\n      res.add(0);\\n      res.add(numArrows >= aliceArrows[tillIndex] + 1 ? 1 : 0);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    if (numArrows == 0) {\\n      res.add(0);\\n      res.add(0);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    if (numArrows >= pref[tillIndex] + tillIndex) {\\n      int score = (tillIndex * (tillIndex + 1)) / 2;\\n      int mask = 0;\\n      int cnt = numArrows;\\n      for (int k = tillIndex; k >= 0; k--) {\\n        mask |= cnt >= aliceArrows[k] + 1 ? (1 << k) : 0;\\n        cnt -= aliceArrows[k] + 1;\\n      }\\n      res.add(score);\\n      res.add(mask);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    List < Integer > resI = null, resE = null;\\n    if (numArrows >= aliceArrows[tillIndex] + 1) {\\n      resI = this.getOptimalDistribution(\\n        aliceArrows,\\n        tillIndex - 1,\\n        numArrows - aliceArrows[tillIndex] - 1,\\n        pref,\\n        dp\\n      );\\n    }\\n\\n    resE = this.getOptimalDistribution(\\n      aliceArrows,\\n      tillIndex - 1,\\n      numArrows,\\n      pref,\\n      dp\\n    );\\n\\n    if (resI != null &&\\n      resI.get(0) + tillIndex >= resE.get(0)\\n    ) {\\n      res.add(tillIndex + resI.get(0));\\n      res.add((1 << tillIndex) | resI.get(1));\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    res.add(resE.get(0));\\n    res.add(resE.get(1));\\n    dp.get(tillIndex).put(numArrows, res);\\n\\n    return res;\\n  }\\n\\n  public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n    int[] pref = new int[12];\\n    int[] result = new int[12];\\n    Map < Integer, Map < Integer, List < Integer >>> cache = new HashMap < > ();\\n\\n    for (int i = 0; i < 12; i++) {\\n      if (numArrows == 1 && aliceArrows[12 - i - 1] == 0) {\\n        result[12 - i - 1] = 1;\\n        return result;\\n      }\\n\\n      cache.put(i, new HashMap < Integer, List < Integer >> ());\\n      if (i == 0) {\\n        pref[i] = aliceArrows[i];\\n        continue;\\n      }\\n\\n      pref[i] = aliceArrows[i] + pref[i - 1];\\n    }\\n\\n    List < Integer > optDist = this.getOptimalDistribution(\\n      aliceArrows,\\n      aliceArrows.length - 1,\\n      numArrows,\\n      pref,\\n      cache\\n    );\\n\\n    int cnt = numArrows;\\n    int lastSetBit = -1;\\n    for (int i = 0; i < 12; i++) {\\n      if ((optDist.get(1) & (1 << i)) != 0) {\\n        lastSetBit = i;\\n        result[i] = aliceArrows[i] + 1;\\n        cnt -= result[i];\\n      }\\n    }\\n\\n    if(cnt > 0) {\\n      result[lastSetBit] += cnt;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812827,
                "title": "bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u2022 `aliceArrows.length == bobArrows.length == 12` \\u2192 mask\\n\\nwin or lose in a sequence of games \\u2192 mask \\u2192 calculate the number needed\\n\\nnumArrows \\u2192 calculate the number and use this to judge possibility\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int mx = INT_MIN;\\n        vector<int> res;\\n        for(int mask = 0; mask < 1 << 12; mask++)\\n        {\\n            vector<int> tmp(12, 0);\\n            int total = 0;\\n            int needArrows = 0;\\n            for(int i = 0; i < 12; i++)\\n            {\\n                if(mask & (1 << i))\\n                {\\n                    tmp[i] = aliceArrows[i] + 1;\\n                    total += i;\\n                    needArrows += tmp[i];\\n                }\\n                if(needArrows > numArrows) break;\\n            }\\n            if(needArrows > numArrows) continue;\\n\\n            if(total > mx)\\n            {\\n                mx = total;\\n                res = tmp;\\n                res[0] += numArrows - needArrows;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int mx = INT_MIN;\\n        vector<int> res;\\n        for(int mask = 0; mask < 1 << 12; mask++)\\n        {\\n            vector<int> tmp(12, 0);\\n            int total = 0;\\n            int needArrows = 0;\\n            for(int i = 0; i < 12; i++)\\n            {\\n                if(mask & (1 << i))\\n                {\\n                    tmp[i] = aliceArrows[i] + 1;\\n                    total += i;\\n                    needArrows += tmp[i];\\n                }\\n                if(needArrows > numArrows) break;\\n            }\\n            if(needArrows > numArrows) continue;\\n\\n            if(total > mx)\\n            {\\n                mx = total;\\n                res = tmp;\\n                res[0] += numArrows - needArrows;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811479,
                "title": "bitmask-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12);\\n        int mxPoints =0;\\n        for(int i=1; i<(1<<12); i++){\\n            vector<int> temp(12);\\n            int currArrows = 0;\\n            int currPoints = 0;\\n            for(int j=0; j<12; j++){\\n               if(i&(1<<j)){\\n                   currArrows += aliceArrows[j] + 1;\\n                   if(currArrows > numArrows) break;\\n                   temp[j] = aliceArrows[j] + 1;\\n                   currPoints += j;\\n               }\\n            }\\n            if(currArrows > numArrows) continue;\\n            if(currPoints > mxPoints){\\n               mxPoints = currPoints;\\n               temp[0] += numArrows - currArrows;\\n               res = temp;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12);\\n        int mxPoints =0;\\n        for(int i=1; i<(1<<12); i++){\\n            vector<int> temp(12);\\n            int currArrows = 0;\\n            int currPoints = 0;\\n            for(int j=0; j<12; j++){\\n               if(i&(1<<j)){\\n                   currArrows += aliceArrows[j] + 1;\\n                   if(currArrows > numArrows) break;\\n                   temp[j] = aliceArrows[j] + 1;\\n                   currPoints += j;\\n               }\\n            }\\n            if(currArrows > numArrows) continue;\\n            if(currPoints > mxPoints){\\n               mxPoints = currPoints;\\n               temp[0] += numArrows - currArrows;\\n               res = temp;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777699,
                "title": "knapsack-dp-easy-to-understand",
                "content": "# Intuition\\n\\nThis is similar to https://leetcode.com/problems/smallest-sufficient-team/ in a sense that we first derive the max score and then see which of the rounds led us there.\\n\\nMy solution explanation for the above HARD problem - https://leetcode.com/problems/smallest-sufficient-team/solutions/3772768/simple-knapsack-intuitive-recursive-bitmask-dp/\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long calc(int n, vector<int>& a, vector<int> &b, int i, vector<vector<int>> &dp) {\\n        if(n < 0) return INT_MIN;\\n        if(n == 0) return 0;\\n        if(dp[n][i] != -1) return dp[n][i];\\n        if(i == 0) {\\n            return 0;\\n        }\\n        long ans = 0;\\n        if(n > a[i]) {\\n            return dp[n][i] = max(calc(n-a[i]-1, a, b, i-1, dp)+i, calc(n, a, b, i-1, dp));\\n        } else {\\n            return dp[n][i] = calc(n, a, b, i-1, dp);\\n        }\\n\\n        return ans;\\n    }\\n    vector<int> maximumBobPoints(int n, vector<int>& a) {\\n        vector<int> b(12, 0);\\n        vector<vector<int>> dp(n+1, vector<int>(a.size(), -1));\\n        \\n        calc(n, a, b, 11, dp);\\n\\n        for(int i=11;i>0;i--) {\\n            if(dp[n][i] == dp[n][i-1]) continue;\\n            else {\\n                if(n > a[i]) {\\n                    b[i] = a[i]+1;\\n                    n -= a[i]+1;\\n                }\\n            }\\n        }\\n\\n        if(n) b[0] = n;\\n        \\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long calc(int n, vector<int>& a, vector<int> &b, int i, vector<vector<int>> &dp) {\\n        if(n < 0) return INT_MIN;\\n        if(n == 0) return 0;\\n        if(dp[n][i] != -1) return dp[n][i];\\n        if(i == 0) {\\n            return 0;\\n        }\\n        long ans = 0;\\n        if(n > a[i]) {\\n            return dp[n][i] = max(calc(n-a[i]-1, a, b, i-1, dp)+i, calc(n, a, b, i-1, dp));\\n        } else {\\n            return dp[n][i] = calc(n, a, b, i-1, dp);\\n        }\\n\\n        return ans;\\n    }\\n    vector<int> maximumBobPoints(int n, vector<int>& a) {\\n        vector<int> b(12, 0);\\n        vector<vector<int>> dp(n+1, vector<int>(a.size(), -1));\\n        \\n        calc(n, a, b, 11, dp);\\n\\n        for(int i=11;i>0;i--) {\\n            if(dp[n][i] == dp[n][i-1]) continue;\\n            else {\\n                if(n > a[i]) {\\n                    b[i] = a[i]+1;\\n                    n -= a[i]+1;\\n                }\\n            }\\n        }\\n\\n        if(n) b[0] = n;\\n        \\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703826,
                "title": "recursion-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int pointForBob = 0;\\n    private int [] bobArrows = new int [12];\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int length = aliceArrows.length;\\n        int [] bob = new int [length];\\n        backtrack(aliceArrows, bob, 11, 0, numArrows); // we start from back\\n        return bobArrows;\\n    }\\n    \\n    public void backtrack(int [] alice, int [] bob, int pos, int currentMax, int arrows) {\\n        if (pos < 0 || arrows <= 0) {\\n            if (arrows > 0) {\\n                bob[0] += arrows;\\n            }\\n            if (currentMax > pointForBob) {\\n                pointForBob = currentMax;\\n                bobArrows = bob.clone();\\n            }\\n            return;\\n        }\\n        \\n        if (arrows >= alice[pos] + 1) {\\n            bob[pos] = alice[pos] + 1;\\n            backtrack(alice, bob, pos - 1, currentMax + pos, arrows - alice[pos] - 1);\\n            bob[pos] = 0;\\n        }\\n        backtrack(alice, bob, pos - 1, currentMax, arrows);\\n        bob[pos] = 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int pointForBob = 0;\\n    private int [] bobArrows = new int [12];\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int length = aliceArrows.length;\\n        int [] bob = new int [length];\\n        backtrack(aliceArrows, bob, 11, 0, numArrows); // we start from back\\n        return bobArrows;\\n    }\\n    \\n    public void backtrack(int [] alice, int [] bob, int pos, int currentMax, int arrows) {\\n        if (pos < 0 || arrows <= 0) {\\n            if (arrows > 0) {\\n                bob[0] += arrows;\\n            }\\n            if (currentMax > pointForBob) {\\n                pointForBob = currentMax;\\n                bobArrows = bob.clone();\\n            }\\n            return;\\n        }\\n        \\n        if (arrows >= alice[pos] + 1) {\\n            bob[pos] = alice[pos] + 1;\\n            backtrack(alice, bob, pos - 1, currentMax + pos, arrows - alice[pos] - 1);\\n            bob[pos] = 0;\\n        }\\n        backtrack(alice, bob, pos - 1, currentMax, arrows);\\n        bob[pos] = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642175,
                "title": "c-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe optimal strategy for Bob is either skip target at all (let it be `0`) or short 1 arrow more (let it be `1`) than Alice has shot. So Bob has $$2^{13}$$ possible strategies:\\n\\n```\\n000000000000 - skip all targets\\n000000000001 - skip all the targets, overshoot Alice on the last target\\n000000000010 - skip all the targets, overshoot Alice on the n - 1 target \\n...\\n111111111111 - overshoot Alice on all targets\\n``` \\n\\nsince we have $$2^{13} = 8192$$ strategies only, we can easily check them (if they are possible) and find the best one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force using bitmask.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(k * 2^k)$$, where $$k$$ is number or targtes, here $$12$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MaximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] result = new int[12];\\n   \\n        int bestMask = 0;\\n\\n        for (int mask = 0, bestScore = 0; mask < 1 << result.Length; ++mask) {\\n            int arrowsSpent = 0; \\n            int score = 0;\\n\\n            for (int index = 0; index < result.Length; ++index) \\n                if (((1 << index) & mask) != 0) {\\n                    score += index;\\n                    arrowsSpent += aliceArrows[index] + 1;\\n                }\\n\\n            if (arrowsSpent <= numArrows && score > bestScore)\\n                (bestScore, bestMask) = (score, mask);\\n        }   \\n\\n        for (int i = 0; i < result.Length; ++i) \\n            if (((1 << i) & bestMask) != 0) \\n                result[i] = aliceArrows[i] + 1;\\n\\n        result[0] = numArrows - result.Sum();\\n\\n        return result; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n000000000000 - skip all targets\\n000000000001 - skip all the targets, overshoot Alice on the last target\\n000000000010 - skip all the targets, overshoot Alice on the n - 1 target \\n...\\n111111111111 - overshoot Alice on all targets\\n```\n```\\npublic class Solution {\\n    public int[] MaximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] result = new int[12];\\n   \\n        int bestMask = 0;\\n\\n        for (int mask = 0, bestScore = 0; mask < 1 << result.Length; ++mask) {\\n            int arrowsSpent = 0; \\n            int score = 0;\\n\\n            for (int index = 0; index < result.Length; ++index) \\n                if (((1 << index) & mask) != 0) {\\n                    score += index;\\n                    arrowsSpent += aliceArrows[index] + 1;\\n                }\\n\\n            if (arrowsSpent <= numArrows && score > bestScore)\\n                (bestScore, bestMask) = (score, mask);\\n        }   \\n\\n        for (int i = 0; i < result.Length; ++i) \\n            if (((1 << i) & bestMask) != 0) \\n                result[i] = aliceArrows[i] + 1;\\n\\n        result[0] = numArrows - result.Sum();\\n\\n        return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557956,
                "title": "simple-pick-not-pick-recursion-explained-python",
                "content": "# Intuition\\nIts a simple pick not pick question where bob can pick either to battle in the score field or not let alice win and try another battle field.\\n\\nNow what are the requirements in question :-\\n`1. Bob have to maximize his score`\\n`2. must use all arrows (arrows by bob sum == numArrows)`\\n`3. To win from alice he needs atleast aliceArrows + 1`\\n\\nNow follow the recursion code here if we choose not to pick any battle field we add 0 to path(as none arrow were used by Bob)\\nbut if he competes to win he will use AliceArrows + 1\\nsubtract it from total arrows and add it to path arrows\\n\\n**What\\'s different here from normal recursion code?** \\nIt says he must use all his arrows so, whenever we see bob hasnt used all the arrows we will just add the remaining arrows to any element ( here i chose 0th index) because they are just extra arrows and bob has already maximized his score.\\n\\nStore maxScore path in res array and that should be your ans!!\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxScore = 0\\n        res = [0] * len(aliceArrows)\\n    \\n        def recur(i, numArrows, score, path):\\n            nonlocal maxScore, res\\n            if i >= len(aliceArrows):\\n                if score > maxScore:\\n                    if numArrows > 0:\\n                        path[0] += numArrows\\n                    res = path\\n                    maxScore = score\\n                return score\\n            \\n            notPick = recur(i+1, numArrows, score, path + [0])\\n            pick = 0\\n            if numArrows - (aliceArrows[i] + 1) >= 0:\\n                pick = recur(i+1, numArrows - (aliceArrows[i] + 1), score + i, path + [aliceArrows[i] + 1])\\n            \\n            return max(pick, notPick)\\n        recur(0, numArrows, 0, [])\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxScore = 0\\n        res = [0] * len(aliceArrows)\\n    \\n        def recur(i, numArrows, score, path):\\n            nonlocal maxScore, res\\n            if i >= len(aliceArrows):\\n                if score > maxScore:\\n                    if numArrows > 0:\\n                        path[0] += numArrows\\n                    res = path\\n                    maxScore = score\\n                return score\\n            \\n            notPick = recur(i+1, numArrows, score, path + [0])\\n            pick = 0\\n            if numArrows - (aliceArrows[i] + 1) >= 0:\\n                pick = recur(i+1, numArrows - (aliceArrows[i] + 1), score + i, path + [aliceArrows[i] + 1])\\n            \\n            return max(pick, notPick)\\n        recur(0, numArrows, 0, [])\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541270,
                "title": "c-100-tc-100-sc-knapsack-using-minimum-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEither to dominates a certain point or not dominate\\n\\n# Complexity\\n- Time complexity:  O(2^11)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0,maxi=0;\\n    void help(int n,vector<int>&aliceA,int a,int i,int points){\\n        if(!n || i<0){\\n            if(points>maxi){\\n                maxi=points; \\n                ans=a;\\n            //update maximum points and save this configuration\\n            }\\n            return;\\n        }\\n        help(n,aliceA,a,i-1,points);   //not dominate\\n        if(n>aliceA[i]){\\n            a=a|(1<<i);\\n            help(n-aliceA[i]-1,aliceA,a,i-1,points+i); //dominates\\n        }\\n        return ;\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        help(numArrows,aliceArrows,0,11,0);\\n        vector<int> bob(12,0);\\n        int count=0;\\n\\n        //now we have ans integer that contains set bit on which points to dominate\\n        for(int i=0;i<12;i++){\\n            if(ans&(1<<i)){\\n                bob[i]=aliceArrows[i]+1;\\n//bob need only one more arrow than alice to dominate\\n                count+=bob[i];  //count the arrows used\\n            }\\n        }\\n        if(count<numArrows) bob[11]+=numArrows-count;   \\n        //add remaining arrows somewhere , as it doesn\\'t matter\\n        return bob;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0,maxi=0;\\n    void help(int n,vector<int>&aliceA,int a,int i,int points){\\n        if(!n || i<0){\\n            if(points>maxi){\\n                maxi=points; \\n                ans=a;\\n            //update maximum points and save this configuration\\n            }\\n            return;\\n        }\\n        help(n,aliceA,a,i-1,points);   //not dominate\\n        if(n>aliceA[i]){\\n            a=a|(1<<i);\\n            help(n-aliceA[i]-1,aliceA,a,i-1,points+i); //dominates\\n        }\\n        return ;\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        help(numArrows,aliceArrows,0,11,0);\\n        vector<int> bob(12,0);\\n        int count=0;\\n\\n        //now we have ans integer that contains set bit on which points to dominate\\n        for(int i=0;i<12;i++){\\n            if(ans&(1<<i)){\\n                bob[i]=aliceArrows[i]+1;\\n//bob need only one more arrow than alice to dominate\\n                count+=bob[i];  //count the arrows used\\n            }\\n        }\\n        if(count<numArrows) bob[11]+=numArrows-count;   \\n        //add remaining arrows somewhere , as it doesn\\'t matter\\n        return bob;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448243,
                "title": "python3-recursive-approach",
                "content": "# Intuition\\n1. In order to get score from section ``i`` Bob should use ``aliceArrows[i] + 1`` arrows, because the number of arrows should be more than ``aliceArrows[i]`` and it doesn\\'t make sense to use more than ``aliceArrows[i] + 1`` arrows.\\n2. We should make as much score as we can from the higher-score sections\\n3. All unused arrows (that are not necessary to beat Alice\\'s arrows) must go into section ``0``\\n\\n# Approach\\n1. Use recursive approach, starting from section ``11`` and check how many points we can get from either beating Alice\\'s arrows or not using any errors in this section\\n2. Go to the previos section in the same way\\n3. Keeping track of the score earned, arrows available and mask for each section - use arrows or not use arrows\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^k)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n\\n        def impl(i0, arrows):\\n            if i0 == -1:\\n                return 0, 0\\n            mask1 = 0\\n            shot = -1\\n            if arrows - aliceArrows[i0] - 1 >= 0:\\n                mask1, shot = impl(i0-1, arrows - aliceArrows[i0] - 1)\\n                shot += i0\\n                mask1 |= (1 << i0)\\n            mask0, no_shot = impl(i0-1, arrows)\\n            mask = mask1 if shot > no_shot else mask0\\n\\n            return mask, max(shot, no_shot)\\n\\n        mask, score = impl(11, numArrows)\\n        result = [0] * 12\\n        for i in range(12):\\n            if mask & (1 << i):\\n                result[i] = aliceArrows[i] + 1\\n\\n        result[0] = numArrows - sum(result[1:])\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n\\n        def impl(i0, arrows):\\n            if i0 == -1:\\n                return 0, 0\\n            mask1 = 0\\n            shot = -1\\n            if arrows - aliceArrows[i0] - 1 >= 0:\\n                mask1, shot = impl(i0-1, arrows - aliceArrows[i0] - 1)\\n                shot += i0\\n                mask1 |= (1 << i0)\\n            mask0, no_shot = impl(i0-1, arrows)\\n            mask = mask1 if shot > no_shot else mask0\\n\\n            return mask, max(shot, no_shot)\\n\\n        mask, score = impl(11, numArrows)\\n        result = [0] * 12\\n        for i in range(12):\\n            if mask & (1 << i):\\n                result[i] = aliceArrows[i] + 1\\n\\n        result[0] = numArrows - sum(result[1:])\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441367,
                "title": "i-hate-combinatorial-explosion-but",
                "content": "# Intuition\\nThe idea is to use an integer to determine if you do it or not. But considering the combinatorial explosion has too much combinations the result will appear close to solution, so you have to do it twice. \\n\\n# Approach\\nInitially is invested a solution difficult to find, and the rest is the most probable solution.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxGot = 0\\n        score = [0] * 12\\n        prepared = numArrows\\n        for i in range(1, 12):\\n            if prepared > aliceArrows[i]:\\n                score[i] = aliceArrows[i] + 1\\n                prepared -= aliceArrows[i] + 1\\n                maxGot += i\\n        score[0] = prepared\\n        seed = -1\\n        candidate = [0]*12\\n        for K in range(2):\\n            result = 1\\n            while result > 0:\\n                seed += 1\\n                option = seed\\n                result = 0\\n                prepared = numArrows\\n                i = 11\\n                candidate = [0] * 12\\n                while i >= 5:\\n                    if prepared > aliceArrows[i]:\\n                        if option % 2 == 0:\\n                            candidate[i] = aliceArrows[i] + 1\\n                            prepared -= aliceArrows[i] + 1\\n                            result += i\\n                        option //= 2\\n                    i -= 1\\n                if result + 10 < maxGot:\\n                    candidate[0] = prepared\\n                    continue\\n                while i > 0:\\n                    if prepared > aliceArrows[i]:\\n                        if option % 2 == 0:\\n                            candidate[i] = aliceArrows[i] + 1\\n                            prepared -= aliceArrows[i] + 1\\n                            result += i\\n                        option //= 2\\n                    i -= 1\\n                candidate[0] = prepared\\n                if result > maxGot:\\n                    maxGot = result\\n                    score = candidate\\n            \\n        return score\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxGot = 0\\n        score = [0] * 12\\n        prepared = numArrows\\n        for i in range(1, 12):\\n            if prepared > aliceArrows[i]:\\n                score[i] = aliceArrows[i] + 1\\n                prepared -= aliceArrows[i] + 1\\n                maxGot += i\\n        score[0] = prepared\\n        seed = -1\\n        candidate = [0]*12\\n        for K in range(2):\\n            result = 1\\n            while result > 0:\\n                seed += 1\\n                option = seed\\n                result = 0\\n                prepared = numArrows\\n                i = 11\\n                candidate = [0] * 12\\n                while i >= 5:\\n                    if prepared > aliceArrows[i]:\\n                        if option % 2 == 0:\\n                            candidate[i] = aliceArrows[i] + 1\\n                            prepared -= aliceArrows[i] + 1\\n                            result += i\\n                        option //= 2\\n                    i -= 1\\n                if result + 10 < maxGot:\\n                    candidate[0] = prepared\\n                    continue\\n                while i > 0:\\n                    if prepared > aliceArrows[i]:\\n                        if option % 2 == 0:\\n                            candidate[i] = aliceArrows[i] + 1\\n                            prepared -= aliceArrows[i] + 1\\n                            result += i\\n                        option //= 2\\n                    i -= 1\\n                candidate[0] = prepared\\n                if result > maxGot:\\n                    maxGot = result\\n                    score = candidate\\n            \\n        return score\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398099,
                "title": "c-recursion-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int maxSum;\\n    void solve(int idx,vector<int>& alice,int numA,vector<int>& ds,int cSum)\\n    {\\n        if(idx==-1)\\n        {\\n            if(cSum>maxSum)\\n            {\\n                maxSum = cSum;\\n                ans = ds;\\n                ans[0]+=numA;\\n            }\\n            return;\\n        }\\n        if(numA>=alice[idx]+1)\\n        {\\n            ds[idx] = alice[idx]+1;\\n            cSum+=idx;\\n            numA-=alice[idx]+1;\\n            solve(idx-1,alice,numA,ds,cSum);\\n            cSum-=idx;\\n            numA+=alice[idx]+1;\\n            ds[idx] = 0;\\n        }\\n        solve(idx-1,alice,numA,ds,cSum);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        ans.clear();\\n        ans.resize(12,0);\\n        vector<int> ds(12);\\n        maxSum = 0;\\n        solve(11,aliceArrows,numArrows,ds,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int maxSum;\\n    void solve(int idx,vector<int>& alice,int numA,vector<int>& ds,int cSum)\\n    {\\n        if(idx==-1)\\n        {\\n            if(cSum>maxSum)\\n            {\\n                maxSum = cSum;\\n                ans = ds;\\n                ans[0]+=numA;\\n            }\\n            return;\\n        }\\n        if(numA>=alice[idx]+1)\\n        {\\n            ds[idx] = alice[idx]+1;\\n            cSum+=idx;\\n            numA-=alice[idx]+1;\\n            solve(idx-1,alice,numA,ds,cSum);\\n            cSum-=idx;\\n            numA+=alice[idx]+1;\\n            ds[idx] = 0;\\n        }\\n        solve(idx-1,alice,numA,ds,cSum);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        ans.clear();\\n        ans.resize(12,0);\\n        vector<int> ds(12);\\n        maxSum = 0;\\n        solve(11,aliceArrows,numArrows,ds,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383362,
                "title": "javascript-backtracking",
                "content": "```\\nconst maximumBobPoints = (numArrows, aliceArrows) => {\\n  let res = new Array(12).fill(0);\\n  let max = 0;\\n\\n  const backtrack = (i, arrows, tot, bobArrows) => {\\n    if (arrows == 0 || i == 0) {\\n      if (tot > max) {\\n        bobArrows[0] = arrows; // leftover arrows\\n        max = tot;\\n        res = bobArrows;\\n      }\\n      return;\\n    }\\n\\n    // skip\\n    backtrack(i - 1, arrows, tot, [...bobArrows]);\\n\\n    // take\\n    let arrowsToBeatAlice = aliceArrows[i] + 1;\\n    if (arrowsToBeatAlice <= arrows) {\\n      bobArrows[i] = arrowsToBeatAlice;\\n      backtrack(i - 1, arrows - arrowsToBeatAlice, tot + i, bobArrows);\\n    }\\n  };\\n\\n  backtrack(11, numArrows, 0, new Array(12).fill(0));\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maximumBobPoints = (numArrows, aliceArrows) => {\\n  let res = new Array(12).fill(0);\\n  let max = 0;\\n\\n  const backtrack = (i, arrows, tot, bobArrows) => {\\n    if (arrows == 0 || i == 0) {\\n      if (tot > max) {\\n        bobArrows[0] = arrows; // leftover arrows\\n        max = tot;\\n        res = bobArrows;\\n      }\\n      return;\\n    }\\n\\n    // skip\\n    backtrack(i - 1, arrows, tot, [...bobArrows]);\\n\\n    // take\\n    let arrowsToBeatAlice = aliceArrows[i] + 1;\\n    if (arrowsToBeatAlice <= arrows) {\\n      bobArrows[i] = arrowsToBeatAlice;\\n      backtrack(i - 1, arrows - arrowsToBeatAlice, tot + i, bobArrows);\\n    }\\n  };\\n\\n  backtrack(11, numArrows, 0, new Array(12).fill(0));\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3380578,
                "title": "easy-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int maxim=-1e9;\\nprivate:\\n    void fun(int idx, int sum,int arrow,int alicearrow,vector<int>&aliceArrows,vector<int>&arr,vector<int>&ans){\\n        \\n        if(idx<0){\\n            int x=0;\\n            for(auto it:arr){\\n                x+=it;\\n            }\\n            if(x<alicearrow){\\n               \\n                arr[0]+=(alicearrow-x);\\n\\n            }\\n            else if(x>alicearrow){\\n                arr[0]-=x-alicearrow;\\n            }\\n            if(sum>maxim){\\n                maxim=sum;\\n                ans=arr;\\n\\n            }\\n            return;\\n        }\\n        if(arrow>aliceArrows[idx]){\\n            arr[idx]=aliceArrows[idx]+1;\\n            fun(idx-1,sum+idx,arrow-(aliceArrows[idx]+1),alicearrow,aliceArrows,arr,ans);\\n            arr[idx]=0;\\n        }\\n        fun(idx-1,sum,arrow,alicearrow,aliceArrows,arr,ans);\\n    }\\n    \\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>arr(12,0);\\n        vector<int>ans;\\n        fun(11,0,numArrows,numArrows,aliceArrows,arr,ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int maxim=-1e9;\\nprivate:\\n    void fun(int idx, int sum,int arrow,int alicearrow,vector<int>&aliceArrows,vector<int>&arr,vector<int>&ans){\\n        \\n        if(idx<0){\\n            int x=0;\\n            for(auto it:arr){\\n                x+=it;\\n            }\\n            if(x<alicearrow){\\n               \\n                arr[0]+=(alicearrow-x);\\n\\n            }\\n            else if(x>alicearrow){\\n                arr[0]-=x-alicearrow;\\n            }\\n            if(sum>maxim){\\n                maxim=sum;\\n                ans=arr;\\n\\n            }\\n            return;\\n        }\\n        if(arrow>aliceArrows[idx]){\\n            arr[idx]=aliceArrows[idx]+1;\\n            fun(idx-1,sum+idx,arrow-(aliceArrows[idx]+1),alicearrow,aliceArrows,arr,ans);\\n            arr[idx]=0;\\n        }\\n        fun(idx-1,sum,arrow,alicearrow,aliceArrows,arr,ans);\\n    }\\n    \\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>arr(12,0);\\n        vector<int>ans;\\n        fun(11,0,numArrows,numArrows,aliceArrows,arr,ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352931,
                "title": "c-dfs-with-pruning",
                "content": "# Code\\n```\\nclass Solution {\\n    void dfs(int i, int numArrows, vector<int>& aliceArrows, vector<int> &ans, vector<int> &bobArrows, int score, int &maxScore) {\\n        if(i < 0 || numArrows < 0) return;\\n        if(score > maxScore) {\\n            maxScore = score;\\n            ans = bobArrows;\\n        }\\n        if(numArrows > aliceArrows[i]) {\\n            bobArrows[i] = aliceArrows[i] + 1;\\n            dfs(i - 1, numArrows - bobArrows[i], aliceArrows, ans, bobArrows, score + i, maxScore);\\n            bobArrows[i] = 0;\\n        }\\n        dfs(i - 1, numArrows, aliceArrows, ans, bobArrows, score, maxScore);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> ans, bobArrows(12);\\n        int maxScore = INT_MIN;\\n        dfs(11, numArrows, aliceArrows, ans, bobArrows, 0, maxScore);\\n        ans[0] += numArrows - accumulate(ans.begin(), ans.end(), 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int numArrows, vector<int>& aliceArrows, vector<int> &ans, vector<int> &bobArrows, int score, int &maxScore) {\\n        if(i < 0 || numArrows < 0) return;\\n        if(score > maxScore) {\\n            maxScore = score;\\n            ans = bobArrows;\\n        }\\n        if(numArrows > aliceArrows[i]) {\\n            bobArrows[i] = aliceArrows[i] + 1;\\n            dfs(i - 1, numArrows - bobArrows[i], aliceArrows, ans, bobArrows, score + i, maxScore);\\n            bobArrows[i] = 0;\\n        }\\n        dfs(i - 1, numArrows, aliceArrows, ans, bobArrows, score, maxScore);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> ans, bobArrows(12);\\n        int maxScore = INT_MIN;\\n        dfs(11, numArrows, aliceArrows, ans, bobArrows, 0, maxScore);\\n        ans[0] += numArrows - accumulate(ans.begin(), ans.end(), 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352085,
                "title": "swift-solution-with-explanations",
                "content": "# Approach\\n1. First, we declare a few variables. The first two are self-explanatory, the third is a store for the current best result. The fourth is a copy of the store for the current result.\\n2. We create a helper function. The first three parameters are self-explanatory. The fourth is the array of arrow counts, the fifth is the store for the current result.\\n3. We check if we are either out of arrows or out of targets. If so, we check if the score of the current result is better than the best score. If so, we update the best score and best store accordingly.\\n4. Otherwise, we check how many arrows we have left. If we have enough to reach the next target, we add the next target to the store and call the helper function again with the new parameters. We do this by creating a copy of the store and adding the next target to it.\\n5. We also call the helper function again without adding the next target to the store.\\n6. Finally, we return the best store. \\n\\n# Complexity\\n- Time complexity: O(2^n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    var maxScore = 0\\n    var maxStore: [Int]?\\n    \\n    func maximumBobPoints(_ numArrows: Int, _ aliceArrows: [Int]) -> [Int]\\n    {\\n        helper(numArrows, 0, 0, aliceArrows, Array(repeating: 0, count: 12))\\n        return maxStore!\\n    }\\n    \\n    func helper(_ numArrows: Int, _ i: Int, _ score: Int, _ arr: [Int], _ store: [Int])\\n    {\\n        if i == 12 || numArrows == 0\\n        {\\n            if score > maxScore\\n            {\\n                maxScore = score\\n                maxStore = store\\n                maxStore![0] += numArrows\\n            }\\n            return\\n        }\\n        \\n        let val = arr[i]\\n        if numArrows - (val + 1) >= 0\\n        {\\n            var store = store\\n            store[i] = val + 1\\n            helper(numArrows - (val + 1), i + 1, score + i, arr, store)\\n        }\\n        helper(numArrows, i + 1, score, arr, store)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution\\n{\\n    var maxScore = 0\\n    var maxStore: [Int]?\\n    \\n    func maximumBobPoints(_ numArrows: Int, _ aliceArrows: [Int]) -> [Int]\\n    {\\n        helper(numArrows, 0, 0, aliceArrows, Array(repeating: 0, count: 12))\\n        return maxStore!\\n    }\\n    \\n    func helper(_ numArrows: Int, _ i: Int, _ score: Int, _ arr: [Int], _ store: [Int])\\n    {\\n        if i == 12 || numArrows == 0\\n        {\\n            if score > maxScore\\n            {\\n                maxScore = score\\n                maxStore = store\\n                maxStore![0] += numArrows\\n            }\\n            return\\n        }\\n        \\n        let val = arr[i]\\n        if numArrows - (val + 1) >= 0\\n        {\\n            var store = store\\n            store[i] = val + 1\\n            helper(numArrows - (val + 1), i + 1, score + i, arr, store)\\n        }\\n        helper(numArrows, i + 1, score, arr, store)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318964,
                "title": "maximum-points-in-an-archery-competition-c-explained-solution",
                "content": "**Do Upvote If Found Helpful !!!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to the problem is quite very simple. Since number of targets are limited to **0 to 11**, we can run a loop from **0 upto 2^12**, assuming them to be a bit mask. If a bit in bitmask is **on**, then it means that Bob shot more arrows else not. In case of **on** bit, just add **aliceArrows[j] + 1**, where j indicates jth bit and target board score. The above value is the minimum arrows required to be shot at a section to win points for that section. If the sum of these arrows is less than or equal to total arrows to be shot, then this is a possible answer. In such case just adjust all values and maximise score for Bob. Implementation goes below :\\n\\n# Complexity\\n- Time complexity: **O(1)** , the loop runs for all bitmasks from 0 to 2^12 irrespective of input.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)** , Same reason as above.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        ios_base::sync_with_stdio(0);\\n        int ans = 0; vector<int>answ(12,0);\\n        for(int mask = 0; mask < (1 << 12); mask++){\\n            int j = 0,s = 0,score = 0;\\n            while(j < 12){\\n                if((mask & (1 << j))){\\n                    s += aliceArrows[j] + 1;\\n                    score += j;\\n                }\\n                j++;\\n            }\\n            if(s <= numArrows){\\n                if(score > ans){\\n                    ans = score;\\n                    int last = -1;\\n                    for(int i = 0; i < 12; i++){\\n                        answ[i] = 0;\\n                        if((mask & (1 << i))){\\n                            last = i;\\n                            answ[i] = aliceArrows[i] + 1;\\n                        }\\n                    }\\n                    if(s < numArrows){\\n                        answ[last] += numArrows - s;\\n                    }\\n                }\\n            }\\n        }\\n        return answ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        ios_base::sync_with_stdio(0);\\n        int ans = 0; vector<int>answ(12,0);\\n        for(int mask = 0; mask < (1 << 12); mask++){\\n            int j = 0,s = 0,score = 0;\\n            while(j < 12){\\n                if((mask & (1 << j))){\\n                    s += aliceArrows[j] + 1;\\n                    score += j;\\n                }\\n                j++;\\n            }\\n            if(s <= numArrows){\\n                if(score > ans){\\n                    ans = score;\\n                    int last = -1;\\n                    for(int i = 0; i < 12; i++){\\n                        answ[i] = 0;\\n                        if((mask & (1 << i))){\\n                            last = i;\\n                            answ[i] = aliceArrows[i] + 1;\\n                        }\\n                    }\\n                    if(s < numArrows){\\n                        answ[last] += numArrows - s;\\n                    }\\n                }\\n            }\\n        }\\n        return answ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276913,
                "title": "c-solution",
                "content": "\\n\\n# Approach\\nRecursive Approach\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void check(int num , int index , vector<int> &aA , vector<int> &result , int temp , int &sum , vector<int> &tempVect)\\n    {\\n         if(num==0 || index == 12){\\n             if(sum < temp)\\n             {   if(num != 0)tempVect[0] = num;\\n                 result = tempVect;\\n                 tempVect[0] = 0;\\n                 sum = temp;\\n             }\\n             return ;\\n         }\\n         if(num > aA[index])\\n         {\\n             tempVect[index] = aA[index]+1;\\n             check(num - aA[index] - 1, index + 1 , aA , result , temp  + index , sum , tempVect);\\n             tempVect[index] = 0;\\n         }\\n         check(num , index + 1 , aA , result , temp ,sum ,  tempVect);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n         vector<int> result(12 , 0);\\n         vector<int> tempVect(12 , 0);\\n         int sum = INT_MIN;\\n         check(numArrows , 1 , aliceArrows , result , 0 , sum , tempVect);\\n         return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(int num , int index , vector<int> &aA , vector<int> &result , int temp , int &sum , vector<int> &tempVect)\\n    {\\n         if(num==0 || index == 12){\\n             if(sum < temp)\\n             {   if(num != 0)tempVect[0] = num;\\n                 result = tempVect;\\n                 tempVect[0] = 0;\\n                 sum = temp;\\n             }\\n             return ;\\n         }\\n         if(num > aA[index])\\n         {\\n             tempVect[index] = aA[index]+1;\\n             check(num - aA[index] - 1, index + 1 , aA , result , temp  + index , sum , tempVect);\\n             tempVect[index] = 0;\\n         }\\n         check(num , index + 1 , aA , result , temp ,sum ,  tempVect);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n         vector<int> result(12 , 0);\\n         vector<int> tempVect(12 , 0);\\n         int sum = INT_MIN;\\n         check(numArrows , 1 , aliceArrows , result , 0 , sum , tempVect);\\n         return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247674,
                "title": "simple-backtracking-c-easy-understanding",
                "content": "```\\nvector<int>ans;\\n    int maxSum = 0;\\n    \\n    void f(vector<int> & vec,int ind,int curr,vector<int> &temp){\\n        \\n        if(ind==vec.size() || curr==0){\\n            int sum = 0;\\n            for(int i =0;i<12;i++){\\n                if(temp[i]!=0) sum+=i;\\n            }\\n            if(sum>maxSum){\\n                ans = temp;\\n                maxSum = sum;\\n            }\\n            return;\\n        }\\n        \\n        f(vec,ind+1,curr,temp);\\n        if(curr-vec[ind]-1>=0){\\n            temp[ind] = vec[ind]+1;\\n            f(vec,ind+1,curr-vec[ind]-1,temp);\\n            temp[ind] = 0;\\n        }\\n        return;\\n    }\\n    \\n    vector<int> maximumBobPoints(int num, vector<int>& vec) {\\n        vector<int>temp(12,0);\\n        f(vec,0,num,temp);\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        if(sum==num) return ans;\\n        else ans[0]+=num-sum;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<int>ans;\\n    int maxSum = 0;\\n    \\n    void f(vector<int> & vec,int ind,int curr,vector<int> &temp){\\n        \\n        if(ind==vec.size() || curr==0){\\n            int sum = 0;\\n            for(int i =0;i<12;i++){\\n                if(temp[i]!=0) sum+=i;\\n            }\\n            if(sum>maxSum){\\n                ans = temp;\\n                maxSum = sum;\\n            }\\n            return;\\n        }\\n        \\n        f(vec,ind+1,curr,temp);\\n        if(curr-vec[ind]-1>=0){\\n            temp[ind] = vec[ind]+1;\\n            f(vec,ind+1,curr-vec[ind]-1,temp);\\n            temp[ind] = 0;\\n        }\\n        return;\\n    }\\n    \\n    vector<int> maximumBobPoints(int num, vector<int>& vec) {\\n        vector<int>temp(12,0);\\n        f(vec,0,num,temp);\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        if(sum==num) return ans;\\n        else ans[0]+=num-sum;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3160258,
                "title": "easy-subset-type-backtracking-code-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int sum=0;\\n    public:\\n    void solve(int idx,vector<int> &alice,vector<int> &bob,vector<int> &ans,int num,int check){\\n         if(idx==-1||num<=0){\\n             if(check>=sum){\\n                 ans=bob;\\n                 sum=check;\\n                 if(num)\\n                 ans[0]+=num;\\n             }\\n             return ;\\n         }\\n\\n         int needed=alice[idx]+1;\\n         if(num>=needed){\\n             bob[idx]=needed;\\n             solve(idx-1,alice,bob,ans,num-needed,check+idx);\\n             bob[idx]=0;\\n         }\\n         solve(idx-1,alice,bob,ans,num,check);\\n         return;\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) {\\n        vector<int> ans(12,0),bob(12,0);\\n        int check=0;\\n        solve(11,alice,bob,ans,num,check);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public:\\n    void solve(int idx,vector<int> &alice,vector<int> &bob,vector<int> &ans,int num,int check){\\n         if(idx==-1||num<=0){\\n             if(check>=sum){\\n                 ans=bob;\\n                 sum=check;\\n                 if(num)\\n                 ans[0]+=num;\\n             }\\n             return ;\\n         }\\n\\n         int needed=alice[idx]+1;\\n         if(num>=needed){\\n             bob[idx]=needed;\\n             solve(idx-1,alice,bob,ans,num-needed,check+idx);\\n             bob[idx]=0;\\n         }\\n         solve(idx-1,alice,bob,ans,num,check);\\n         return;\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) {\\n        vector<int> ans(12,0),bob(12,0);\\n        int check=0;\\n        solve(11,alice,bob,ans,num,check);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139533,
                "title": "time-o-12-66-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDP is a valid solution \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the scores are higher at sections with higher index, reverse the array will help to find better solution earlier when possible.\\n\\nAnd noticeable that bob could earn the score when he shot just one more arrows that alice in the same section. More arrows in the section are waste.\\nSo for each section only 0 arrow and one more than alice are to be considered.\\n\\nObviously section Zero will never contribute the score.\\nWhen possible the highest score will be 66, no more are possible.\\n\\n66 is really a small number, so arraies are used to tracking the scores and corresponding sections picked. This will be more efficent that dict\\n\\nthere are two cases that a quick answer could be generate without DP. when the possible maximume score is 66 or 65.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(12*66)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(66)\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        if aliceArrows[0] >= 11:\\n            bobArrows = [_+1 for _ in aliceArrows]\\n            bobArrows[0] -= 12\\n            return bobArrows\\n        if aliceArrows[0] + aliceArrows[1] >= 10:\\n            bobArrows = [_+1 for _ in aliceArrows]\\n            bobArrows[0] = 0\\n            bobArrows[1] = aliceArrows[0] + aliceArrows[1] - 10\\n            return bobArrows \\n \\n        highscore = 66 #sum(list(reversed(range(12)))[:numArrows])\\n        highscores = set()\\n        highscorecosts = [inf] * (highscore + 1)\\n        highscorepaths = [[] for _ in range(highscore + 1)]\\n        # highscorecosts[0] = 0\\n        # print( highscore, highscores, numArrows, aliceArrows)\\n        def update(s, c, i ):\\n            if highscorecosts[s] >  c:\\n                highscorecosts[s] = c\\n                return True\\n            return False\\n            \\n        for i in reversed(range(12)):\\n            a = aliceArrows[i]\\n            if i and a < numArrows:\\n                newhighscores = set()\\n                for s in sorted(highscores, reverse=True):\\n                    if highscorecosts[s] + a  < numArrows:\\n                        # print(f\\'new high scores: {s+i} : min({highscorecosts[s + i]}, {a+1}+{highscorecosts[s]})\\')\\n                        if update(s+i, a+1+highscorecosts[s], i ):\\n                            highscorepaths[s + i] = highscorepaths[s] + [i]\\n                            newhighscores.add(s+i)\\n                            # print(f\\'new high score path: {s+i} : {highscorepaths[s + i]}\\')\\n                # print(f\\'new high scores: {i} : min({highscorecosts[ i]}, {a+1})\\')\\n                if update(i, a+1, i ):\\n                    highscorepaths[i] = [i]\\n                    newhighscores.add(i)\\n                    # print(f\\'new high score path: {i} : {highscorepaths[i]}\\')\\n                highscores = highscores | newhighscores\\n        # print( max(highscores), highscores, highscorecosts )\\n        bobArrows = [0]*12\\n        for i in highscorepaths[max(highscores)]:\\n            bobArrows[i] = aliceArrows[i] + 1\\n        bobArrows[0] = numArrows - sum(bobArrows)\\n        return bobArrows\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        if aliceArrows[0] >= 11:\\n            bobArrows = [_+1 for _ in aliceArrows]\\n            bobArrows[0] -= 12\\n            return bobArrows\\n        if aliceArrows[0] + aliceArrows[1] >= 10:\\n            bobArrows = [_+1 for _ in aliceArrows]\\n            bobArrows[0] = 0\\n            bobArrows[1] = aliceArrows[0] + aliceArrows[1] - 10\\n            return bobArrows \\n \\n        highscore = 66 #sum(list(reversed(range(12)))[:numArrows])\\n        highscores = set()\\n        highscorecosts = [inf] * (highscore + 1)\\n        highscorepaths = [[] for _ in range(highscore + 1)]\\n        # highscorecosts[0] = 0\\n        # print( highscore, highscores, numArrows, aliceArrows)\\n        def update(s, c, i ):\\n            if highscorecosts[s] >  c:\\n                highscorecosts[s] = c\\n                return True\\n            return False\\n            \\n        for i in reversed(range(12)):\\n            a = aliceArrows[i]\\n            if i and a < numArrows:\\n                newhighscores = set()\\n                for s in sorted(highscores, reverse=True):\\n                    if highscorecosts[s] + a  < numArrows:\\n                        # print(f\\'new high scores: {s+i} : min({highscorecosts[s + i]}, {a+1}+{highscorecosts[s]})\\')\\n                        if update(s+i, a+1+highscorecosts[s], i ):\\n                            highscorepaths[s + i] = highscorepaths[s] + [i]\\n                            newhighscores.add(s+i)\\n                            # print(f\\'new high score path: {s+i} : {highscorepaths[s + i]}\\')\\n                # print(f\\'new high scores: {i} : min({highscorecosts[ i]}, {a+1})\\')\\n                if update(i, a+1, i ):\\n                    highscorepaths[i] = [i]\\n                    newhighscores.add(i)\\n                    # print(f\\'new high score path: {i} : {highscorepaths[i]}\\')\\n                highscores = highscores | newhighscores\\n        # print( max(highscores), highscores, highscorecosts )\\n        bobArrows = [0]*12\\n        for i in highscorepaths[max(highscores)]:\\n            bobArrows[i] = aliceArrows[i] + 1\\n        bobArrows[0] = numArrows - sum(bobArrows)\\n        return bobArrows\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073630,
                "title": "maximum-points-in-an-archery-competition",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}\\n        for i in range(2, 12):\\n            prev = dp\\n            dp = {}\\n            for key in prev:\\n                newkey1 = list(key)\\n                newkey1.append(0)\\n                score, arrowleft = prev[key]\\n                \\n                newval1 = (score, arrowleft)\\n                dp[tuple(newkey1)] = newval1\\n    \\n                if arrowleft >= aliceArrows[i] + 1:\\n                    newkey2 = list(key)\\n                    newkey2.append(aliceArrows[i] + 1)\\n                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))\\n                    dp[tuple(newkey2)] = newval2\\n        maxscore, res = 0, None\\n        for key in dp:\\n            score, _ = dp[key]\\n            if score > maxscore:\\n                maxscore = score\\n                res = list(key)\\n        if sum(res) < numArrows:\\n            res[0] = numArrows - sum(res)\\n        \\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}\\n        for i in range(2, 12):\\n            prev = dp\\n            dp = {}\\n            for key in prev:\\n                newkey1 = list(key)\\n                newkey1.append(0)\\n                score, arrowleft = prev[key]\\n                \\n                newval1 = (score, arrowleft)\\n                dp[tuple(newkey1)] = newval1\\n    \\n                if arrowleft >= aliceArrows[i] + 1:\\n                    newkey2 = list(key)\\n                    newkey2.append(aliceArrows[i] + 1)\\n                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))\\n                    dp[tuple(newkey2)] = newval2\\n        maxscore, res = 0, None\\n        for key in dp:\\n            score, _ = dp[key]\\n            if score > maxscore:\\n                maxscore = score\\n                res = list(key)\\n        if sum(res) < numArrows:\\n            res[0] = numArrows - sum(res)\\n        \\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058252,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>ans;\\n        int score=0;\\n        for(int i=0; i<(1<<12); i++){\\n            int n=numArrows, count=0;\\n            vector<int>temp(12, 0);\\n            for(int j=11; j>=0; j--){\\n                if(i&(1<<j)){\\n                    if(n>aliceArrows[j]){//if arrows are less than alice shooted arrows\\n                        n-=(aliceArrows[j]+1);//decrement the arrows\\n                        temp[j]=(aliceArrows[j]+1);//initialize the vector at that position\\n                    }\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(i&(1<<j)){\\n                    temp[j]+=n;//remaining arrows of bob had to be used\\n                    break;\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(temp[j]>aliceArrows[j]){count+=j;}//if temp[j] is greater than alice arrows points bob will get points\\n            }\\n            if(count>score){//if bob score is greater than score\\n                score=count;//update the score\\n                ans=temp;//store temp in ans\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        // vector<int> ans;\\n        // int score = 0;\\n        // for(int i = 1; i<4096; i++)\\n        // {\\n        //     int arrows = numArrows;\\n        //     vector<int> temp(12,0);\\n        //     for(int j = 11; j>=0; j--)\\n        //     {\\n        //         if(i & (i<<j))\\n        //         {\\n        //             if(arrows<=aliceArrows[j])//if arrows are less than alice shooted arrows\\n        //             {\\n        //                 continue;\\n        //             }\\n        //             arrows-=(aliceArrows[j]+1);//decrement the arrows\\n        //             temp[j]=aliceArrows[j]+1;//initialize the vector at that position\\n        //         }\\n        //     }\\n        //     for(int j = 0; j<12; j++)\\n        //     {\\n        //         if(i & (1<<j))\\n        //         {\\n        //             temp[j]+=arrows;//remaining arrows of bob had to be used\\n        //             break;\\n        //         }\\n        //     }\\n        //     int b = 0;\\n        //     for(int j = 0; j<12; j++)\\n        //     {\\n        //         if(temp[j]>aliceArrows[j])//if temp[j] is greater than alice arrows points bob will get points\\n        //         {\\n        //             b+=(j);\\n        //         }\\n        //     }\\n        //     if(b>score)//if bob score is greater than score\\n        //     {\\n        //         score = b;//update the score\\n        //         ans = temp;//store temp in ans;\\n        //     }\\n        // }\\n        // return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>ans;\\n        int score=0;\\n        for(int i=0; i<(1<<12); i++){\\n            int n=numArrows, count=0;\\n            vector<int>temp(12, 0);\\n            for(int j=11; j>=0; j--){\\n                if(i&(1<<j)){\\n                    if(n>aliceArrows[j]){//if arrows are less than alice shooted arrows\\n                        n-=(aliceArrows[j]+1);//decrement the arrows\\n                        temp[j]=(aliceArrows[j]+1);//initialize the vector at that position\\n                    }\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(i&(1<<j)){\\n                    temp[j]+=n;//remaining arrows of bob had to be used\\n                    break;\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(temp[j]>aliceArrows[j]){count+=j;}//if temp[j] is greater than alice arrows points bob will get points\\n            }\\n            if(count>score){//if bob score is greater than score\\n                score=count;//update the score\\n                ans=temp;//store temp in ans\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        // vector<int> ans;\\n        // int score = 0;\\n        // for(int i = 1; i<4096; i++)\\n        // {\\n        //     int arrows = numArrows;\\n        //     vector<int> temp(12,0);\\n        //     for(int j = 11; j>=0; j--)\\n        //     {\\n        //         if(i & (i<<j))\\n        //         {\\n        //             if(arrows<=aliceArrows[j])//if arrows are less than alice shooted arrows\\n        //             {\\n        //                 continue;\\n        //             }\\n        //             arrows-=(aliceArrows[j]+1);//decrement the arrows\\n        //             temp[j]=aliceArrows[j]+1;//initialize the vector at that position\\n        //         }\\n        //     }\\n        //     for(int j = 0; j<12; j++)\\n        //     {\\n        //         if(i & (1<<j))\\n        //         {\\n        //             temp[j]+=arrows;//remaining arrows of bob had to be used\\n        //             break;\\n        //         }\\n        //     }\\n        //     int b = 0;\\n        //     for(int j = 0; j<12; j++)\\n        //     {\\n        //         if(temp[j]>aliceArrows[j])//if temp[j] is greater than alice arrows points bob will get points\\n        //         {\\n        //             b+=(j);\\n        //         }\\n        //     }\\n        //     if(b>score)//if bob score is greater than score\\n        //     {\\n        //         score = b;//update the score\\n        //         ans = temp;//store temp in ans;\\n        //     }\\n        // }\\n        // return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037262,
                "title": "c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstarting with highest points u can earn we need to distribute the available arrows to that particular section of points.\\nBut we can select that category for the total points or not so we need an approach we can select that category of points or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can use backtracking approach by choosing at one time and not choosing the current category for maximum points by BOB.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(2^N) as N=12 so it is Acceptable.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\nvector<int>res;\\n    void maxpoints(int arrows, int ind, vector<int>points, int score,vector<int>&ar)\\n    {\\n        \\n        if(ind<0)\\n        {\\n            points[0]+=arrows;\\n            if(score>ans)\\n            {\\n                ans=score;\\n                res=points;\\n            }\\n            return;\\n        }\\n        if(arrows<ar[ind]+1)\\n        {\\n            maxpoints(arrows,ind-1,points,score,ar);\\n        }\\n        else\\n        {\\n            points[ind]=ar[ind]+1;\\n            maxpoints(arrows-ar[ind]-1,ind-1,points,score+ind,ar);\\n            points[ind]=0;\\n            maxpoints(arrows,ind-1,points,score,ar);\\n        }\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=aliceArrows.size();\\n        res=vector<int>(n,0);\\n        maxpoints(numArrows,n-1,res,0,aliceArrows);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=0;\\nvector<int>res;\\n    void maxpoints(int arrows, int ind, vector<int>points, int score,vector<int>&ar)\\n    {\\n        \\n        if(ind<0)\\n        {\\n            points[0]+=arrows;\\n            if(score>ans)\\n            {\\n                ans=score;\\n                res=points;\\n            }\\n            return;\\n        }\\n        if(arrows<ar[ind]+1)\\n        {\\n            maxpoints(arrows,ind-1,points,score,ar);\\n        }\\n        else\\n        {\\n            points[ind]=ar[ind]+1;\\n            maxpoints(arrows-ar[ind]-1,ind-1,points,score+ind,ar);\\n            points[ind]=0;\\n            maxpoints(arrows,ind-1,points,score,ar);\\n        }\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=aliceArrows.size();\\n        res=vector<int>(n,0);\\n        maxpoints(numArrows,n-1,res,0,aliceArrows);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032448,
                "title": "java-backtracking-solution",
                "content": "This question is same as **LCS**.\\nSince 0 is not going to add any score so we will find max score obtained till 1 and we will put remaining arrows in bob[0].\\n\\n```\\nclass Solution {\\n    List<Integer> list;\\n    int score;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int n = aliceArrows.length;\\n        list = new ArrayList<>();\\n        score = 0;\\n        findBobArrow(numArrows, aliceArrows, n - 1, new ArrayList<>(), 0);\\n        \\n        int[] bob = new int[12];\\n        int total = 0;\\n        for(int idx: list){\\n            bob[idx] = aliceArrows[idx]+1;\\n            total += bob[idx];\\n        }\\n        if(numArrows - total > 0){\\n            bob[0] = numArrows - total;\\n        }\\n        return bob;\\n    }\\n    \\n    private void findBobArrow(int a, int[] aa, int idx, List<Integer> curr, int currScore){\\n        if(currScore > score){\\n            score = currScore; \\n            list = new ArrayList<>(curr);\\n        }\\n        \\n        if(idx == 0) return ;\\n        \\n        // if Bob don\\'t wants to get that score\\n        findBobArrow(a, aa, idx-1, curr, currScore);\\n        \\n        // if Bob want to get that score\\n        if(a > aa[idx]){\\n            curr.add(idx);\\n            findBobArrow(a - aa[idx] - 1, aa, idx-1, curr, currScore + idx);\\n            curr.remove(curr.size() - 1);\\n        }\\n        \\n        return ;\\n    }\\n}\\n```\\n\\nTC - O(11) = O(1)\\nSC - O(11) = O(1)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> list;\\n    int score;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int n = aliceArrows.length;\\n        list = new ArrayList<>();\\n        score = 0;\\n        findBobArrow(numArrows, aliceArrows, n - 1, new ArrayList<>(), 0);\\n        \\n        int[] bob = new int[12];\\n        int total = 0;\\n        for(int idx: list){\\n            bob[idx] = aliceArrows[idx]+1;\\n            total += bob[idx];\\n        }\\n        if(numArrows - total > 0){\\n            bob[0] = numArrows - total;\\n        }\\n        return bob;\\n    }\\n    \\n    private void findBobArrow(int a, int[] aa, int idx, List<Integer> curr, int currScore){\\n        if(currScore > score){\\n            score = currScore; \\n            list = new ArrayList<>(curr);\\n        }\\n        \\n        if(idx == 0) return ;\\n        \\n        // if Bob don\\'t wants to get that score\\n        findBobArrow(a, aa, idx-1, curr, currScore);\\n        \\n        // if Bob want to get that score\\n        if(a > aa[idx]){\\n            curr.add(idx);\\n            findBobArrow(a - aa[idx] - 1, aa, idx-1, curr, currScore + idx);\\n            curr.remove(curr.size() - 1);\\n        }\\n        \\n        return ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028833,
                "title": "a-recursive-approach-c-fast-simpel",
                "content": "\\n# Approach\\nThe given code is an implementation of a recursive function that attempts to find the maximum number of points Bob can score in the archery competition, given the number of arrows he has available to shoot and the number of points Alice scored on each section of the target.\\n\\nThe function operates by considering each section of the target individually and determining whether Bob should shoot an arrow at that section or not. It does this by first calling itself recursively for the next section of the target, without shooting an arrow at the current section. It then checks if Bob has enough arrows remaining to shoot at the current section, and if so, it increments Bob\\'s score for that section by 1, decrements the number of remaining arrows by 1, and calls itself recursively for the next section of the target.\\n\\nThe function keeps track of the maximum score seen so far and stores the number of arrows shot at each section of the target in a vector called ans, which it returns at the end. If there are any remaining arrows at the end of the function, it adds them to the first element of ans.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // variable to store the maximum score\\n    int maxScore;\\n    // variable to store the optimal solution (Bob\\'s arrow distribution)\\n    vector<int> optimalSolution;\\n    // variable to store the remaining number of arrows\\n    int remainingArrows;\\n\\n    // recursive helper function to find the optimal solution\\n    void findOptimalSolution(vector<int>& aliceArrows, vector<int> bobArrows, int remainingArrows, int currentIndex, int currentScore) {\\n        // base case: if we have reached the end of the array or run out of arrows, update the maxScore and optimalSolution if necessary\\n        if (currentIndex == -1 || remainingArrows <= 0) {\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                optimalSolution = bobArrows;\\n                if (remainingArrows > 0 && optimalSolution.size() > 0) {\\n                    optimalSolution[0] += remainingArrows;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // recursive case: try not shooting any arrows in the current section\\n        findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex-1, currentScore);\\n        \\n        // recursive case: try shooting arrows in the current section\\n        if (remainingArrows > aliceArrows[currentIndex]) {\\n            bobArrows[currentIndex] = aliceArrows[currentIndex] + 1;\\n            remainingArrows -= (aliceArrows[currentIndex] + 1);\\n            currentScore += currentIndex;\\n            findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex-1, currentScore);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        // initialize variables\\n        maxScore = INT_MIN;\\n        remainingArrows = numArrows;\\n        int currentIndex = aliceArrows.size() - 1;\\n        vector<int> bobArrows(aliceArrows.size(), 0);\\n        int currentScore = 0;\\n        \\n        // call recursive helper function\\n        findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex, currentScore);\\n        \\n        return optimalSolution;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // variable to store the maximum score\\n    int maxScore;\\n    // variable to store the optimal solution (Bob\\'s arrow distribution)\\n    vector<int> optimalSolution;\\n    // variable to store the remaining number of arrows\\n    int remainingArrows;\\n\\n    // recursive helper function to find the optimal solution\\n    void findOptimalSolution(vector<int>& aliceArrows, vector<int> bobArrows, int remainingArrows, int currentIndex, int currentScore) {\\n        // base case: if we have reached the end of the array or run out of arrows, update the maxScore and optimalSolution if necessary\\n        if (currentIndex == -1 || remainingArrows <= 0) {\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                optimalSolution = bobArrows;\\n                if (remainingArrows > 0 && optimalSolution.size() > 0) {\\n                    optimalSolution[0] += remainingArrows;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // recursive case: try not shooting any arrows in the current section\\n        findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex-1, currentScore);\\n        \\n        // recursive case: try shooting arrows in the current section\\n        if (remainingArrows > aliceArrows[currentIndex]) {\\n            bobArrows[currentIndex] = aliceArrows[currentIndex] + 1;\\n            remainingArrows -= (aliceArrows[currentIndex] + 1);\\n            currentScore += currentIndex;\\n            findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex-1, currentScore);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        // initialize variables\\n        maxScore = INT_MIN;\\n        remainingArrows = numArrows;\\n        int currentIndex = aliceArrows.size() - 1;\\n        vector<int> bobArrows(aliceArrows.size(), 0);\\n        int currentScore = 0;\\n        \\n        // call recursive helper function\\n        findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex, currentScore);\\n        \\n        return optimalSolution;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027229,
                "title": "intuitive-very-easy-knapsack-recursion-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int maxi=0;\\n    void help(int points,int available,vector<int> &aliceArrows,int sum,vector<int> &res){\\n        if(points < 0  or available <= 0){\\n            if(sum > maxi){\\n                maxi = sum;\\n                if(available > 0) res[0] += available;\\n                ans = res;\\n            }\\n            return;\\n        }\\n        int required = aliceArrows[points] + 1;\\n\\n        //pick\\n        if(required <= available){\\n            res[points] = required;\\n            help(points - 1, available - required, aliceArrows, sum + points, res);\\n            res[points] = 0;\\n        }\\n\\n        //not pick\\n        help(points - 1, available , aliceArrows , sum, res);\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12,0);\\n        help(11, numArrows, aliceArrows, 0, res);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int maxi=0;\\n    void help(int points,int available,vector<int> &aliceArrows,int sum,vector<int> &res){\\n        if(points < 0  or available <= 0){\\n            if(sum > maxi){\\n                maxi = sum;\\n                if(available > 0) res[0] += available;\\n                ans = res;\\n            }\\n            return;\\n        }\\n        int required = aliceArrows[points] + 1;\\n\\n        //pick\\n        if(required <= available){\\n            res[points] = required;\\n            help(points - 1, available - required, aliceArrows, sum + points, res);\\n            res[points] = 0;\\n        }\\n\\n        //not pick\\n        help(points - 1, available , aliceArrows , sum, res);\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12,0);\\n        help(11, numArrows, aliceArrows, 0, res);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026594,
                "title": "6companies30days-challenge-by-arsh-goyal-goldmansachs-d3",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int finalMask = 0,finalScore=0;\\n        for(int i=1;i< (1<<12) ;i++){\\n            int score  = 0;\\n            int arrows = numArrows;\\n            bool wrongMask=false;\\n            for(int j=1;j<12;j++){\\n                if((1<<j)&i){\\n                    int arrowsNeeded = aliceArrows[j] + 1; \\n                    if(arrows-arrowsNeeded >= 0){\\n                        arrows -= arrowsNeeded;\\n                        score += j;\\n                    }\\n                    else{\\n                        wrongMask=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!wrongMask && score>finalScore){\\n                finalScore=score;\\n                finalMask=i;\\n            }\\n        }\\n        vector<int> ans(12);\\n        int sum=numArrows;\\n        for(int i=1;i<12;i++){\\n            if((1<<i)&finalMask){\\n                ans[i] = aliceArrows[i]+1;\\n                sum -= ans[i];\\n            }\\n        }\\n        if(sum>0){\\n            ans[0] = sum;\\n        }\\n        cout<<finalScore;\\n        return ans;\\n    }\\n};class Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int finalMask = 0,finalScore=0;\\n        for(int i=1;i< (1<<12) ;i++){\\n            int score  = 0;\\n            int arrows = numArrows;\\n            bool wrongMask=false;\\n            for(int j=1;j<12;j++){\\n                if((1<<j)&i){\\n                    int arrowsNeeded = aliceArrows[j] + 1; \\n                    if(arrows-arrowsNeeded >= 0){\\n                        arrows -= arrowsNeeded;\\n                        score += j;\\n                    }\\n                    else{\\n                        wrongMask=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!wrongMask && score>finalScore){\\n                finalScore=score;\\n                finalMask=i;\\n            }\\n        }\\n        vector<int> ans(12);\\n        int sum=numArrows;\\n        for(int i=1;i<12;i++){\\n            if((1<<i)&finalMask){\\n                ans[i] = aliceArrows[i]+1;\\n                sum -= ans[i];\\n            }\\n        }\\n        if(sum>0){\\n            ans[0] = sum;\\n        }\\n        cout<<finalScore;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int finalMask = 0,finalScore=0;\\n        for(int i=1;i< (1<<12) ;i++){\\n            int score  = 0;\\n            int arrows = numArrows;\\n            bool wrongMask=false;\\n            for(int j=1;j<12;j++){\\n                if((1<<j)&i){\\n                    int arrowsNeeded = aliceArrows[j] + 1; \\n                    if(arrows-arrowsNeeded >= 0){\\n                        arrows -= arrowsNeeded;\\n                        score += j;\\n                    }\\n                    else{\\n                        wrongMask=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!wrongMask && score>finalScore){\\n                finalScore=score;\\n                finalMask=i;\\n            }\\n        }\\n        vector<int> ans(12);\\n        int sum=numArrows;\\n        for(int i=1;i<12;i++){\\n            if((1<<i)&finalMask){\\n                ans[i] = aliceArrows[i]+1;\\n                sum -= ans[i];\\n            }\\n        }\\n        if(sum>0){\\n            ans[0] = sum;\\n        }\\n        cout<<finalScore;\\n        return ans;\\n    }\\n};class Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int finalMask = 0,finalScore=0;\\n        for(int i=1;i< (1<<12) ;i++){\\n            int score  = 0;\\n            int arrows = numArrows;\\n            bool wrongMask=false;\\n            for(int j=1;j<12;j++){\\n                if((1<<j)&i){\\n                    int arrowsNeeded = aliceArrows[j] + 1; \\n                    if(arrows-arrowsNeeded >= 0){\\n                        arrows -= arrowsNeeded;\\n                        score += j;\\n                    }\\n                    else{\\n                        wrongMask=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!wrongMask && score>finalScore){\\n                finalScore=score;\\n                finalMask=i;\\n            }\\n        }\\n        vector<int> ans(12);\\n        int sum=numArrows;\\n        for(int i=1;i<12;i++){\\n            if((1<<i)&finalMask){\\n                ans[i] = aliceArrows[i]+1;\\n                sum -= ans[i];\\n            }\\n        }\\n        if(sum>0){\\n            ans[0] = sum;\\n        }\\n        cout<<finalScore;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3026142,
                "title": "2-simple-solution-recursion-bitsmask-o-2-11",
                "content": "\\n\\n# Code (simple recusion)\\n```\\nclass Solution {\\npublic:\\n    int mx = 0;\\n    vector<int>v;\\n    void solve(vector<int>&aliceArrows,int n,int val,int arrow,vector<int>&arr){\\n        // base\\n        if(n == 0 || arrow == 0){\\n            if(mx<val){\\n                mx = val;\\n                v = arr;\\n                v[0] = arrow;\\n            }\\n            return;\\n        }\\n\\n        \\n        if(aliceArrows[n]<arrow){\\n            arr[n] = aliceArrows[n]+1;\\n            solve(aliceArrows,n-1,n+val,arrow-1-aliceArrows[n],arr);\\n        }\\n        arr[n] = 0;\\n        solve(aliceArrows,n-1,val,arrow,arr);\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>arr(12,0);\\n        solve(aliceArrows,11,0,numArrows,arr);\\n        return v;\\n        \\n    }\\n};\\n```\\n\\n\\n# Code (bitmask)\\n```\\n\\nclass Solution {\\npublic:\\n    int max_points = 0, max_mask = 0;\\n\\n    void dfs(int k,int numArrows,vector<int>&aliceArrows,int points,int mask){\\n        if(numArrows>=0 and points>max_points){\\n            max_points = points;\\n            max_mask = mask;\\n        }\\n        if(k>0){\\n            dfs(k-1,numArrows-aliceArrows[k]-1,aliceArrows,points+k,mask+(1<<k));\\n            dfs(k-1,numArrows,aliceArrows,points,mask);\\n        }\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res(12);\\n        dfs(11,numArrows,aliceArrows,0,0);\\n        for(int k=11;k>0;k--){\\n            if(max_mask&(1<<k)){\\n                res[k] = aliceArrows[k]+1;\\n                numArrows -= aliceArrows[k]+1;\\n            }\\n        }\\n        res[0] = numArrows;\\n        return res;\\n    }\\n\\n};\\n```\\n# do upvote if you liked the solution HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx = 0;\\n    vector<int>v;\\n    void solve(vector<int>&aliceArrows,int n,int val,int arrow,vector<int>&arr){\\n        // base\\n        if(n == 0 || arrow == 0){\\n            if(mx<val){\\n                mx = val;\\n                v = arr;\\n                v[0] = arrow;\\n            }\\n            return;\\n        }\\n\\n        \\n        if(aliceArrows[n]<arrow){\\n            arr[n] = aliceArrows[n]+1;\\n            solve(aliceArrows,n-1,n+val,arrow-1-aliceArrows[n],arr);\\n        }\\n        arr[n] = 0;\\n        solve(aliceArrows,n-1,val,arrow,arr);\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>arr(12,0);\\n        solve(aliceArrows,11,0,numArrows,arr);\\n        return v;\\n        \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int max_points = 0, max_mask = 0;\\n\\n    void dfs(int k,int numArrows,vector<int>&aliceArrows,int points,int mask){\\n        if(numArrows>=0 and points>max_points){\\n            max_points = points;\\n            max_mask = mask;\\n        }\\n        if(k>0){\\n            dfs(k-1,numArrows-aliceArrows[k]-1,aliceArrows,points+k,mask+(1<<k));\\n            dfs(k-1,numArrows,aliceArrows,points,mask);\\n        }\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res(12);\\n        dfs(11,numArrows,aliceArrows,0,0);\\n        for(int k=11;k>0;k--){\\n            if(max_mask&(1<<k)){\\n                res[k] = aliceArrows[k]+1;\\n                numArrows -= aliceArrows[k]+1;\\n            }\\n        }\\n        res[0] = numArrows;\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023402,
                "title": "c-recursion-easy-solution",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int Max=-1;\\n    int solve(int n,vector<int>&nums,vector<int>&a,int i,int M){\\n        if(i>=nums.size()){\\n            if(M>Max){\\n                Max = M;\\n                ans = a;\\n                ans[11] += n;\\n            }\\n            return M;\\n        }\\n        int t1 = 0;\\n        if(n>=nums[i]+1){\\n            a[i] = nums[i]+1;\\n            t1 += i +solve(n-nums[i]-1,nums,a,i+1,M+i);\\n            a[i] = 0;\\n        }\\n        t1 = max(t1,solve(n,nums,a,i+1,M));\\n        return t1;\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> a(12,0);\\n        int x = solve(numArrows,aliceArrows,a,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int Max=-1;\\n    int solve(int n,vector<int>&nums,vector<int>&a,int i,int M){\\n        if(i>=nums.size()){\\n            if(M>Max){\\n                Max = M;\\n                ans = a;\\n                ans[11] += n;\\n            }\\n            return M;\\n        }\\n        int t1 = 0;\\n        if(n>=nums[i]+1){\\n            a[i] = nums[i]+1;\\n            t1 += i +solve(n-nums[i]-1,nums,a,i+1,M+i);\\n            a[i] = 0;\\n        }\\n        t1 = max(t1,solve(n,nums,a,i+1,M));\\n        return t1;\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> a(12,0);\\n        int x = solve(numArrows,aliceArrows,a,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021112,
                "title": "0-1-knapsack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint f(int ind,int max_w,vector<int>&wt,vector<vector<int>>&dp)\\n{\\n    if(ind <= 0 )return 0;\\n     if(dp[ind][max_w]!=-1)return dp[ind][max_w];\\n    int notPick=f(ind-1,max_w,wt,dp);\\n    int Pick=0;\\n    if(wt[ind]<max_w)\\n    {\\n        Pick=ind+f(ind-1,max_w-wt[ind]-1,wt,dp);\\n    }\\n     return dp[ind][max_w]=max(Pick,notPick);\\n}\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        // int n=aliceArrows.size();\\n        vector<vector<int>> dp(12,vector<int>(numArrows+1,-1));\\n        \\n        // for(auto i:dp)\\n        // {\\n        //     for(auto j:i)\\n        //     cout<<j<<\" \";\\n        //     cout<<\"\\\\n\";\\n        // }\\n        //return {};\\n\\n        vector<int>ans(12,0);\\n        int result = f(11, numArrows,aliceArrows,dp);\\n        cout<<result<<\"\\\\n\";\\n        int total = 0; // to count total arrows used by bob\\n        for (int i=12, j=numArrows; i > 0 && result > 0; i--) {\\n            if (result == dp[i-1][j])\\n                {cout<<dp[i-1][j];continue;}\\n                \\n            else {\\n                //cout<<\"####\\\\n\";\\n                // This item is included.\\n                ans[i] = aliceArrows[i]+1;\\n                //cout<<ans[i]<<\" \"<<i<<\"\\\\n\";\\n                result -=  (i);  // subtracting profit\\n                j -= (aliceArrows[i]+1); // subtracting weight\\n                total += aliceArrows[i]+1; \\n            }\\n        }\\n        \\n\\t\\t// as bob has to fire numArrows, remaining can be of 0 value\\n        if(total<numArrows){\\n            ans[0] = numArrows-total;\\n        }\\n        // for(auto i:ans)\\n        // {\\n        //    cout<<i<<\" \";\\n        // }\\n    \\n      return ans;\\n\\n    \\n       // return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint f(int ind,int max_w,vector<int>&wt,vector<vector<int>>&dp)\\n{\\n    if(ind <= 0 )return 0;\\n     if(dp[ind][max_w]!=-1)return dp[ind][max_w];\\n    int notPick=f(ind-1,max_w,wt,dp);\\n    int Pick=0;\\n    if(wt[ind]<max_w)\\n    {\\n        Pick=ind+f(ind-1,max_w-wt[ind]-1,wt,dp);\\n    }\\n     return dp[ind][max_w]=max(Pick,notPick);\\n}\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        // int n=aliceArrows.size();\\n        vector<vector<int>> dp(12,vector<int>(numArrows+1,-1));\\n        \\n        // for(auto i:dp)\\n        // {\\n        //     for(auto j:i)\\n        //     cout<<j<<\" \";\\n        //     cout<<\"\\\\n\";\\n        // }\\n        //return {};\\n\\n        vector<int>ans(12,0);\\n        int result = f(11, numArrows,aliceArrows,dp);\\n        cout<<result<<\"\\\\n\";\\n        int total = 0; // to count total arrows used by bob\\n        for (int i=12, j=numArrows; i > 0 && result > 0; i--) {\\n            if (result == dp[i-1][j])\\n                {cout<<dp[i-1][j];continue;}\\n                \\n            else {\\n                //cout<<\"####\\\\n\";\\n                // This item is included.\\n                ans[i] = aliceArrows[i]+1;\\n                //cout<<ans[i]<<\" \"<<i<<\"\\\\n\";\\n                result -=  (i);  // subtracting profit\\n                j -= (aliceArrows[i]+1); // subtracting weight\\n                total += aliceArrows[i]+1; \\n            }\\n        }\\n        \\n\\t\\t// as bob has to fire numArrows, remaining can be of 0 value\\n        if(total<numArrows){\\n            ans[0] = numArrows-total;\\n        }\\n        // for(auto i:ans)\\n        // {\\n        //    cout<<i<<\" \";\\n        // }\\n    \\n      return ans;\\n\\n    \\n       // return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3019416,
                "title": "30-days-6-companies-day-8-q2-c-solution",
                "content": "```\\nclass Solution {\\nprivate : \\n    vector<int> ans;\\n    bool checkProfit(vector<int>&bob,vector<int>& alice){\\n        int prevProfit = 0;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i] > alice[i]) prevProfit += i;\\n        }\\n\\n        int newProfit = 0;\\n        for(int i=0;i<bob.size();i++){\\n            if(bob[i] > alice[i]) newProfit += i;\\n        }\\n\\n        return newProfit > prevProfit;\\n    }\\n\\n    void helper(int i,int numArrows,vector<int>& alice,vector<int>&bob){\\n        if(i==0){\\n            bob[i] = numArrows;\\n            if(checkProfit(bob,alice)) ans = bob;\\n            bob[i] = 0;\\n            return;\\n        }\\n        if(numArrows - alice[i] - 1 >= 0){\\n            bob[i] = alice[i] + 1;\\n            helper(i-1,numArrows - alice[i] - 1,alice,bob);\\n            bob[i] = 0;\\n        }\\n\\n        helper(i-1,numArrows,alice,bob);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n        helper(11,numArrows,aliceArrows,bob);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate : \\n    vector<int> ans;\\n    bool checkProfit(vector<int>&bob,vector<int>& alice){\\n        int prevProfit = 0;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i] > alice[i]) prevProfit += i;\\n        }\\n\\n        int newProfit = 0;\\n        for(int i=0;i<bob.size();i++){\\n            if(bob[i] > alice[i]) newProfit += i;\\n        }\\n\\n        return newProfit > prevProfit;\\n    }\\n\\n    void helper(int i,int numArrows,vector<int>& alice,vector<int>&bob){\\n        if(i==0){\\n            bob[i] = numArrows;\\n            if(checkProfit(bob,alice)) ans = bob;\\n            bob[i] = 0;\\n            return;\\n        }\\n        if(numArrows - alice[i] - 1 >= 0){\\n            bob[i] = alice[i] + 1;\\n            helper(i-1,numArrows - alice[i] - 1,alice,bob);\\n            bob[i] = 0;\\n        }\\n\\n        helper(i-1,numArrows,alice,bob);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n        helper(11,numArrows,aliceArrows,bob);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013050,
                "title": "6comp30day-c-easy-solution-backtracking-made-easy",
                "content": "# Intuition\\nFrom question and contraints it was preety clear that It could be solved by trying all the ways so i choose backtracking.\\n\\n# Approch\\nDo recursion till index!=0 and others things see from simple code\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void recur(int &sum, vector<int>&v , int n , int ind ,vector<int>given, vector<int>&ans ,int curr_sum){\\n        if(ind<0){\\n            if(curr_sum>sum){\\n                // cout<<curr_sum<<\" \"<<sum<<\" \";\\n                sum=curr_sum;\\n                v[0]+=n;\\n                ans=v;\\n                //I was checking here some errors\\n                // for(auto i:v){\\n                //     cout<<i<<\" \";\\n                // }\\n                // cout<<endl;\\n            }\\n            return;\\n        }\\n\\n// if we are able to add arrows for that index\\n        if(n-(given[ind]+1)>=0){\\n            v[ind]=given[ind]+1;\\n            n-=(given[ind]+1);\\n            curr_sum+=ind;\\n            recur(sum,v,n,ind-1,given,ans,curr_sum);\\n            v[ind]=0;\\n            n+=(given[ind]+1);\\n            curr_sum-=ind;\\n        }\\n        \\n        recur(sum,v,n,ind-1,given,ans,curr_sum);\\n    }\\n\\n    vector<int> maximumBobPoints(int n, vector<int>& aliceArrows) {\\n        vector<int>v(12,0) , ans;\\n        int sum=0;\\n\\n        sum=0;\\n\\n        int c=0;\\n        recur(sum,v,n,11,aliceArrows,ans,c);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void recur(int &sum, vector<int>&v , int n , int ind ,vector<int>given, vector<int>&ans ,int curr_sum){\\n        if(ind<0){\\n            if(curr_sum>sum){\\n                // cout<<curr_sum<<\" \"<<sum<<\" \";\\n                sum=curr_sum;\\n                v[0]+=n;\\n                ans=v;\\n                //I was checking here some errors\\n                // for(auto i:v){\\n                //     cout<<i<<\" \";\\n                // }\\n                // cout<<endl;\\n            }\\n            return;\\n        }\\n\\n// if we are able to add arrows for that index\\n        if(n-(given[ind]+1)>=0){\\n            v[ind]=given[ind]+1;\\n            n-=(given[ind]+1);\\n            curr_sum+=ind;\\n            recur(sum,v,n,ind-1,given,ans,curr_sum);\\n            v[ind]=0;\\n            n+=(given[ind]+1);\\n            curr_sum-=ind;\\n        }\\n        \\n        recur(sum,v,n,ind-1,given,ans,curr_sum);\\n    }\\n\\n    vector<int> maximumBobPoints(int n, vector<int>& aliceArrows) {\\n        vector<int>v(12,0) , ans;\\n        int sum=0;\\n\\n        sum=0;\\n\\n        int c=0;\\n        recur(sum,v,n,11,aliceArrows,ans,c);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2915420,
                "title": "hello-love",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void func(vector<int> &a,vector<int> b,vector<int> &c,long long int s,int i,int n,int &ans)\\n    {\\n        if(n<0)\\n        {\\n            return;\\n        }\\n        if(i<0)\\n        {\\n            return ;\\n        }\\n        if(n==0 && i>0)\\n        {\\n            if(s>ans)\\n            {\\n                ans=s;\\n                c=b;\\n            }\\n            return ;\\n        }\\n        if(i==0)\\n        {\\n            if(s>ans)\\n            {\\n                ans=s;\\n                b[i]=n;\\n                c=b;\\n            }\\n            return ;\\n        }\\n        b[i]=a[i]+1;\\n        func(a,b,c,s+i,i-1,n-(b[i]),ans);\\n        b[i]=0;\\n        func(a,b,c,s,i-1,n,ans);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=numArrows,ans=INT_MIN;\\n        vector<int> b(12,0),c;\\n        func(aliceArrows,b,c,0,11,n,ans);\\n        cout << ans;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(vector<int> &a,vector<int> b,vector<int> &c,long long int s,int i,int n,int &ans)\\n    {\\n        if(n<0)\\n        {\\n            return;\\n        }\\n        if(i<0)\\n        {\\n            return ;\\n        }\\n        if(n==0 && i>0)\\n        {\\n            if(s>ans)\\n            {\\n                ans=s;\\n                c=b;\\n            }\\n            return ;\\n        }\\n        if(i==0)\\n        {\\n            if(s>ans)\\n            {\\n                ans=s;\\n                b[i]=n;\\n                c=b;\\n            }\\n            return ;\\n        }\\n        b[i]=a[i]+1;\\n        func(a,b,c,s+i,i-1,n-(b[i]),ans);\\n        b[i]=0;\\n        func(a,b,c,s,i-1,n,ans);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=numArrows,ans=INT_MIN;\\n        vector<int> b(12,0),c;\\n        func(aliceArrows,b,c,0,11,n,ans);\\n        cout << ans;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2907891,
                "title": "cool-n-simple-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        self.max_score = 0\\n        self.take = set()\\n        bobArrows = [0]\\n        self.max_list = []\\n        self.final = set()\\n        self.free_arrows = 0\\n        def backTrack(i,arrows_used,score):\\n            \\n            if i == len(aliceArrows):\\n                if score > self.max_score:\\n                    self.free_arrows = numArrows - arrows_used\\n                    self.max_score = score\\n                    self.final = self.take.copy()\\n                return\\n\\n\\n            if arrows_used + aliceArrows[i] + 1 <=  numArrows:\\n                bobArrows.append(aliceArrows[i] + 1)\\n                self.take.add(i)\\n                backTrack(i+1,arrows_used + aliceArrows[i] + 1,score + i)\\n                bobArrows.pop()\\n                self.take.discard(i)\\n            \\n            bobArrows.append(0)\\n            backTrack(i+1,arrows_used,score)\\n            # bobArrows.pop()\\n\\n        backTrack(1,0,0)\\n        ans = [0 for i in range(12)]\\n\\n        for ind in self.final:\\n            ans[ind] = aliceArrows[ind] + 1\\n        ans[0] = self.free_arrows\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        self.max_score = 0\\n        self.take = set()\\n        bobArrows = [0]\\n        self.max_list = []\\n        self.final = set()\\n        self.free_arrows = 0\\n        def backTrack(i,arrows_used,score):\\n            \\n            if i == len(aliceArrows):\\n                if score > self.max_score:\\n                    self.free_arrows = numArrows - arrows_used\\n                    self.max_score = score\\n                    self.final = self.take.copy()\\n                return\\n\\n\\n            if arrows_used + aliceArrows[i] + 1 <=  numArrows:\\n                bobArrows.append(aliceArrows[i] + 1)\\n                self.take.add(i)\\n                backTrack(i+1,arrows_used + aliceArrows[i] + 1,score + i)\\n                bobArrows.pop()\\n                self.take.discard(i)\\n            \\n            bobArrows.append(0)\\n            backTrack(i+1,arrows_used,score)\\n            # bobArrows.pop()\\n\\n        backTrack(1,0,0)\\n        ans = [0 for i in range(12)]\\n\\n        for ind in self.final:\\n            ans[ind] = aliceArrows[ind] + 1\\n        ans[0] = self.free_arrows\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886423,
                "title": "c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> aliceArrows;\\n    int cur_max = 0;\\n    vector<int> max_path;\\n\\n    void recur(int score_sec, int arrow_left, int score_won, vector<int> &path) {\\n        if (arrow_left < 0) return;\\n\\n        if (score_sec == -1) {\\n            if (score_won > cur_max) {\\n                cur_max = score_won;\\n                max_path = path;\\n                max_path[max_path.size() - 1] += arrow_left;\\n            }\\n            return;\\n        }\\n\\n        // win\\n        path.push_back(aliceArrows[score_sec] + 1);\\n        recur(score_sec - 1, arrow_left - aliceArrows[score_sec] - 1, score_won + score_sec, path);\\n        path.pop_back();\\n\\n        // lose\\n        path.push_back(0);\\n        recur(score_sec - 1, arrow_left, score_won, path);\\n        path.pop_back();\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        this->aliceArrows = aliceArrows;\\n        vector<int> path;\\n        recur(11, numArrows, 0, path);\\n        reverse(max_path.begin(), max_path.end());\\n        return max_path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> aliceArrows;\\n    int cur_max = 0;\\n    vector<int> max_path;\\n\\n    void recur(int score_sec, int arrow_left, int score_won, vector<int> &path) {\\n        if (arrow_left < 0) return;\\n\\n        if (score_sec == -1) {\\n            if (score_won > cur_max) {\\n                cur_max = score_won;\\n                max_path = path;\\n                max_path[max_path.size() - 1] += arrow_left;\\n            }\\n            return;\\n        }\\n\\n        // win\\n        path.push_back(aliceArrows[score_sec] + 1);\\n        recur(score_sec - 1, arrow_left - aliceArrows[score_sec] - 1, score_won + score_sec, path);\\n        path.pop_back();\\n\\n        // lose\\n        path.push_back(0);\\n        recur(score_sec - 1, arrow_left, score_won, path);\\n        path.pop_back();\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        this->aliceArrows = aliceArrows;\\n        vector<int> path;\\n        recur(11, numArrows, 0, path);\\n        reverse(max_path.begin(), max_path.end());\\n        return max_path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759825,
                "title": "c-backtrack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //  Backtrack tc: O(n*2^n)       n=12 becos total number of possibilities are 12    \\n    int m=0;\\n    vector<int> bob;\\n    \\n    void helper(int numArrows, vector<int>&alice, vector<int>&arrows, int score, int index,int n)\\n    {\\n        if(index == n)\\n        {\\n            if(m<score)\\n            {\\n                m=score;\\n                bob=arrows;\\n                bob[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        //let alice win- no effect on Bob\\n        arrows.push_back(0);\\n        helper(numArrows, alice, arrows,score, index+1, n);\\n        arrows.pop_back();\\n        \\n        //now try for bob to win\\n        if(alice[index]+1 <= numArrows)\\n        {\\n            arrows.push_back(alice[index]+1);\\n            helper(numArrows-alice[index]-1, alice, arrows,score+index, index+1,  n);\\n            arrows.pop_back();\\n        }   \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aA) \\n    {\\n        vector<int> arrows;\\n        int n=aA.size();\\n        helper(numArrows, aA, arrows, 0, 0, n);\\n        return bob;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //  Backtrack tc: O(n*2^n)       n=12 becos total number of possibilities are 12    \\n    int m=0;\\n    vector<int> bob;\\n    \\n    void helper(int numArrows, vector<int>&alice, vector<int>&arrows, int score, int index,int n)\\n    {\\n        if(index == n)\\n        {\\n            if(m<score)\\n            {\\n                m=score;\\n                bob=arrows;\\n                bob[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        //let alice win- no effect on Bob\\n        arrows.push_back(0);\\n        helper(numArrows, alice, arrows,score, index+1, n);\\n        arrows.pop_back();\\n        \\n        //now try for bob to win\\n        if(alice[index]+1 <= numArrows)\\n        {\\n            arrows.push_back(alice[index]+1);\\n            helper(numArrows-alice[index]-1, alice, arrows,score+index, index+1,  n);\\n            arrows.pop_back();\\n        }   \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aA) \\n    {\\n        vector<int> arrows;\\n        int n=aA.size();\\n        helper(numArrows, aA, arrows, 0, 0, n);\\n        return bob;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745693,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        resAr = [[]]\\n        temp = [0]*12\\n        mx = [0]\\n    \\n        def findMxPoints(i, arrows, sc):\\n            \\n            if i == 12 or arrows == 0:\\n                if mx[0] < sc:\\n                    resAr[0] = temp[:]\\n                    mx[0] = sc\\n                return \\n            \\n            findMxPoints(i+1, arrows, sc)\\n            \\n            if arrows >= aliceArrows[i]+1:\\n                temp[i] = aliceArrows[i]+1\\n                findMxPoints(i+1, arrows-aliceArrows[i]-1, sc+i)\\n                temp[i] = 0\\n                \\n        \\n        findMxPoints(0, numArrows, 0)\\n        \\n        return resAr[0]\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        resAr = [[]]\\n        temp = [0]*12\\n        mx = [0]\\n    \\n        def findMxPoints(i, arrows, sc):\\n            \\n            if i == 12 or arrows == 0:\\n                if mx[0] < sc:\\n                    resAr[0] = temp[:]\\n                    mx[0] = sc\\n                return \\n            \\n            findMxPoints(i+1, arrows, sc)\\n            \\n            if arrows >= aliceArrows[i]+1:\\n                temp[i] = aliceArrows[i]+1\\n                findMxPoints(i+1, arrows-aliceArrows[i]-1, sc+i)\\n                temp[i] = 0\\n                \\n        \\n        findMxPoints(0, numArrows, 0)\\n        \\n        return resAr[0]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2631197,
                "title": "c-easy-to-understand-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> bob = {0,0,0,0,0,0,0,0,0,0,0,0}, ans;\\n    int mx = 0;\\n    \\n    void mxPoints(int index , int score ,int numArrows,vector<int>& aliceArrows)\\n    {\\n        if(numArrows<=0 or index>=aliceArrows.size())\\n        {\\n            if(mx<score){\\n                ans=bob;\\n                mx=score;\\n            }\\n            return ;\\n        }\\n        \\n        for(int i = index ; i<aliceArrows.size() ; i++)\\n        {\\n            int curr = aliceArrows[i];\\n            \\n            int prevScore = score, prevNumArrows = numArrows;\\n            \\n            if(curr+1 <= numArrows)\\n            {\\n                bob[i]=curr+1;\\n                score+=i;\\n                numArrows-=(curr+1);\\n            }\\n            \\n            mxPoints(i+1,score,numArrows,aliceArrows);\\n            \\n            bob[i]=0;\\n            \\n            score= prevScore,numArrows = prevNumArrows;\\n        }\\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows)\\n    {\\n        mxPoints(0,0,numArrows,aliceArrows);   \\n        \\n        int bobArrows = 0;\\n        \\n        for(int i =0 ; i<12 ;i++) bobArrows+=ans[i];\\n        \\n        if(bobArrows < numArrows){\\n            ans[0]+=numArrows-bobArrows;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bob = {0,0,0,0,0,0,0,0,0,0,0,0}, ans;\\n    int mx = 0;\\n    \\n    void mxPoints(int index , int score ,int numArrows,vector<int>& aliceArrows)\\n    {\\n        if(numArrows<=0 or index>=aliceArrows.size())\\n        {\\n            if(mx<score){\\n                ans=bob;\\n                mx=score;\\n            }\\n            return ;\\n        }\\n        \\n        for(int i = index ; i<aliceArrows.size() ; i++)\\n        {\\n            int curr = aliceArrows[i];\\n            \\n            int prevScore = score, prevNumArrows = numArrows;\\n            \\n            if(curr+1 <= numArrows)\\n            {\\n                bob[i]=curr+1;\\n                score+=i;\\n                numArrows-=(curr+1);\\n            }\\n            \\n            mxPoints(i+1,score,numArrows,aliceArrows);\\n            \\n            bob[i]=0;\\n            \\n            score= prevScore,numArrows = prevNumArrows;\\n        }\\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows)\\n    {\\n        mxPoints(0,0,numArrows,aliceArrows);   \\n        \\n        int bobArrows = 0;\\n        \\n        for(int i =0 ; i<12 ;i++) bobArrows+=ans[i];\\n        \\n        if(bobArrows < numArrows){\\n            ans[0]+=numArrows-bobArrows;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602112,
                "title": "easy-to-read-python-backtracking-solution",
                "content": "```\\n def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        def helper(self, idx, seq):\\n            if len(seq) > 12:\\n                return \\n            \\n            tot = 0\\n            for i in range(len(seq)):\\n                tot += seq[i][1]\\n            \\n            if tot > numArrows:\\n                return \\n            \\n            seq.append((idx, aliceArrows[idx]+1))\\n            tot += seq[-1][1]\\n                \\n            if tot <= numArrows:\\n                score = 0\\n                for i in range(len(seq)):\\n                    score += seq[i][0]\\n                if score > self.maxscore:\\n                    self.result = seq.copy()\\n                    self.maxscore = score\\n                    self.total_arrows = tot\\n                    \\n            \\n            for i in range(idx+1, 12):\\n                helper(self, i, seq)\\n            \\n            seq.pop()\\n            \\n        \\n        self.result = []\\n        self.maxscore = 0\\n        self.total_arrow = 0\\n        for i in range(12):\\n            helper(self, i, [])\\n        \\n        out = 12*[0]\\n        for i in range(len(self.result)):\\n            out[self.result[i][0]] = self.result[i][1]\\n            \\n        if self.total_arrows < numArrows:\\n            out[0] += numArrows - self.total_arrows\\n            \\n        return out\\n",
                "solutionTags": [],
                "code": "```\\n def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        def helper(self, idx, seq):\\n            if len(seq) > 12:\\n                return \\n            \\n            tot = 0\\n            for i in range(len(seq)):\\n                tot += seq[i][1]\\n            \\n            if tot > numArrows:\\n                return \\n            \\n            seq.append((idx, aliceArrows[idx]+1))\\n            tot += seq[-1][1]\\n                \\n            if tot <= numArrows:\\n                score = 0\\n                for i in range(len(seq)):\\n                    score += seq[i][0]\\n                if score > self.maxscore:\\n                    self.result = seq.copy()\\n                    self.maxscore = score\\n                    self.total_arrows = tot\\n                    \\n            \\n            for i in range(idx+1, 12):\\n                helper(self, i, seq)\\n            \\n            seq.pop()\\n            \\n        \\n        self.result = []\\n        self.maxscore = 0\\n        self.total_arrow = 0\\n        for i in range(12):\\n            helper(self, i, [])\\n        \\n        out = 12*[0]\\n        for i in range(len(self.result)):\\n            out[self.result[i][0]] = self.result[i][1]\\n            \\n        if self.total_arrows < numArrows:\\n            out[0] += numArrows - self.total_arrows\\n            \\n        return out\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2552766,
                "title": "python-3-dp-solution",
                "content": "This problem has recurring subproblems, which can be computed and stored, making a DP approach the optimal one\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        # DP, table to store the max score for current section and number of arrows\\n        dp = [[-1 for _ in range(numArrows + 1)] for _ in range(12)]\\n        # minArrowsForBobToWin stores bob arrows to win in each section\\n        # bobMaxScore stores result bob arrows for max score\\n        minArrowsForBobToWin, bobMaxScore = [aliceArrows[i] + 1 for i in range(len(aliceArrows))], [0 for _ in range(12)]\\n        \\n        # Helper function to find max score for each number of arrows upto the actual number of arrows\\n        # for all the sections upto a given section\\n        def findMaxScore(section: int, numArrows: int, dp: List[List[int]], minArrowsForBobToWin: List[int]) -> int:\\n            # base case\\n            # return score 0 for arrows <= 0 or section <= 0\\n            if numArrows <= 0 or section <= 0:\\n                return 0\\n            # returning precalculated result\\n            if dp[section][numArrows] != -1:\\n                return dp[section][numArrows]\\n            # Variables to store the scores if the current section is taken or not\\n            taken, notTaken = 0, 0\\n            # if remaining arrows >= minArrowsForBobToWin[section] then we can take current section \\n            # and call recursively\\n            if numArrows >= minArrowsForBobToWin[section]:\\n                taken =  section + findMaxScore(section - 1, numArrows - minArrowsForBobToWin[section], dp, minArrowsForBobToWin)\\n            # recursive call without taking current section\\n            notTaken = findMaxScore(section - 1, numArrows, dp, minArrowsForBobToWin)\\n            # get max score from taken and not taken case\\n            dp[section][numArrows] = max(taken, notTaken)\\n            return dp[section][numArrows]\\n        \\n        # find maximum score bob can obtain\\n        findMaxScore(11, numArrows, dp, minArrowsForBobToWin)\\n        # find bob\\'s arrows for each section starting from max score section\\n        for i in range(11, 0, -1):\\n            if numArrows >= minArrowsForBobToWin[i] and dp[i][numArrows] > dp[i - 1][numArrows]:\\n                bobMaxScore[i] = minArrowsForBobToWin[i]\\n                numArrows -= minArrowsForBobToWin[i]\\n                if numArrows <= 0:\\n                    break\\n        # add remaining arrows in section 0\\n        if numArrows > 0:\\n            bobMaxScore[0] = numArrows\\n        return bobMaxScore\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        # DP, table to store the max score for current section and number of arrows\\n        dp = [[-1 for _ in range(numArrows + 1)] for _ in range(12)]\\n        # minArrowsForBobToWin stores bob arrows to win in each section\\n        # bobMaxScore stores result bob arrows for max score\\n        minArrowsForBobToWin, bobMaxScore = [aliceArrows[i] + 1 for i in range(len(aliceArrows))], [0 for _ in range(12)]\\n        \\n        # Helper function to find max score for each number of arrows upto the actual number of arrows\\n        # for all the sections upto a given section\\n        def findMaxScore(section: int, numArrows: int, dp: List[List[int]], minArrowsForBobToWin: List[int]) -> int:\\n            # base case\\n            # return score 0 for arrows <= 0 or section <= 0\\n            if numArrows <= 0 or section <= 0:\\n                return 0\\n            # returning precalculated result\\n            if dp[section][numArrows] != -1:\\n                return dp[section][numArrows]\\n            # Variables to store the scores if the current section is taken or not\\n            taken, notTaken = 0, 0\\n            # if remaining arrows >= minArrowsForBobToWin[section] then we can take current section \\n            # and call recursively\\n            if numArrows >= minArrowsForBobToWin[section]:\\n                taken =  section + findMaxScore(section - 1, numArrows - minArrowsForBobToWin[section], dp, minArrowsForBobToWin)\\n            # recursive call without taking current section\\n            notTaken = findMaxScore(section - 1, numArrows, dp, minArrowsForBobToWin)\\n            # get max score from taken and not taken case\\n            dp[section][numArrows] = max(taken, notTaken)\\n            return dp[section][numArrows]\\n        \\n        # find maximum score bob can obtain\\n        findMaxScore(11, numArrows, dp, minArrowsForBobToWin)\\n        # find bob\\'s arrows for each section starting from max score section\\n        for i in range(11, 0, -1):\\n            if numArrows >= minArrowsForBobToWin[i] and dp[i][numArrows] > dp[i - 1][numArrows]:\\n                bobMaxScore[i] = minArrowsForBobToWin[i]\\n                numArrows -= minArrowsForBobToWin[i]\\n                if numArrows <= 0:\\n                    break\\n        # add remaining arrows in section 0\\n        if numArrows > 0:\\n            bobMaxScore[0] = numArrows\\n        return bobMaxScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543061,
                "title": "python-3-backtracking",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n\\t\\t\\tself.max=0\\n\\t\\t\\tdef solve(n,i,A,v):\\n\\t\\t\\t\\tif i==12:\\n\\t\\t\\t\\t\\tif v>self.max:\\n\\t\\t\\t\\t\\t\\tself.max=v\\n\\t\\t\\t\\t\\t\\tself.res=list(A)\\n\\t\\t\\t\\t\\t\\tself.left=n\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tsolve(n,i+1,A,v)\\n\\t\\t\\t\\tif n>aliceArrows[i]:\\n\\t\\t\\t\\t\\tA[i]=aliceArrows[i]+1\\n\\t\\t\\t\\t\\tsolve(n-aliceArrows[i]-1,i+1,A,v+i)\\n\\t\\t\\t\\t\\tA[i]=0\\n\\t\\t\\tsolve(numArrows,0,[0]*12,0)\\n\\t\\t\\tif self.left:\\n\\t\\t\\t\\tfor i in range(12):\\n\\t\\t\\t\\t\\tif self.res[i]>aliceArrows[i]:\\n\\t\\t\\t\\t\\t\\tself.res[i]+=self.left\\n\\t\\t\\t\\t\\t\\treturn self.res\\n\\t\\t\\treturn self.res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n\\t\\t\\tself.max=0\\n\\t\\t\\tdef solve(n,i,A,v):\\n\\t\\t\\t\\tif i==12:\\n\\t\\t\\t\\t\\tif v>self.max:\\n\\t\\t\\t\\t\\t\\tself.max=v\\n\\t\\t\\t\\t\\t\\tself.res=list(A)\\n\\t\\t\\t\\t\\t\\tself.left=n\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tsolve(n,i+1,A,v)\\n\\t\\t\\t\\tif n>aliceArrows[i]:\\n\\t\\t\\t\\t\\tA[i]=aliceArrows[i]+1\\n\\t\\t\\t\\t\\tsolve(n-aliceArrows[i]-1,i+1,A,v+i)\\n\\t\\t\\t\\t\\tA[i]=0\\n\\t\\t\\tsolve(numArrows,0,[0]*12,0)\\n\\t\\t\\tif self.left:\\n\\t\\t\\t\\tfor i in range(12):\\n\\t\\t\\t\\t\\tif self.res[i]>aliceArrows[i]:\\n\\t\\t\\t\\t\\t\\tself.res[i]+=self.left\\n\\t\\t\\t\\t\\t\\treturn self.res\\n\\t\\t\\treturn self.res",
                "codeTag": "Java"
            },
            {
                "id": 2520223,
                "title": "c-solution-backtracking-approach-explained",
                "content": "\\uD83D\\uDC49 Approach :- Standing at any index we will decide whether to shoot more arrows than alice (If available) or not. And when we reach index == 12 and our current score is greater than the max score then we update our answer vector to our current vector. \\n\\n**CODE:-**\\n\\nclass Solution {\\npublic:\\n*     vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {       \\n        vector<int>temp;\\n        int maxscore = INT_MIN;\\n        vector<int>ans;\\n        solve(aliceArrows,0,temp,0,maxscore,numArrows, ans);\\n        long long sum = 0;\\n        for(int i = 0;i < ans.size(); i++)\\n        {\\n            sum += ans[i];\\n        }\\n        if(sum < numArrows)\\n        {\\n            ans[0] += numArrows-sum;\\n        }\\n        return ans;\\n    }\\n    \\n*     void solve(vector<int>& alice, int ind, vector<int>temp, int score, int& maxscore, int remaining,vector<int>& ans){\\n        if(ind == 11)\\n        {\\n            temp.push_back(remaining);\\n            if(remaining > alice[ind])\\n            {\\n                score += ind;\\n            }\\n            if(score > maxscore)\\n            {\\n                maxscore = score;\\n                ans = temp;\\n            }\\n            return ;\\n        }\\n        if(remaining > alice[ind])\\n        {\\n            temp.push_back(alice[ind]+1);\\n            solve(alice,ind+1,temp,score+ind,maxscore,remaining-(alice[ind]+1),ans);\\n            temp.pop_back();\\n        }\\n        temp.push_back(0);\\n        solve(alice,ind+1,temp,score,maxscore,remaining, ans);\\n        temp.pop_back();\\n    }\\n};\\n**DO upvote if you understood it !**",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n*     vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {       \\n        vector<int>temp;\\n        int maxscore = INT_MIN;\\n        vector<int>ans;\\n        solve(aliceArrows,0,temp,0,maxscore,numArrows, ans);\\n        long long sum = 0;\\n        for(int i = 0;i < ans.size(); i++)\\n        {\\n            sum += ans[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2499795,
                "title": "typescript-simple-bitmask-iterative-solution-o-2-n-n",
                "content": "Simply enumerate through all possible subsets of arrows distribution\\nIf there is a case when fewer number of arrows is enough to achieve the result, just add the rest to 0 score section\\n\\n```\\nfunction maximumBobPoints(numArrows: number, aliceArrows: number[]): number[] {\\n  const n = 12;\\n  const maxMask = 1 << n;\\n  \\n  let res = 0;\\n  let bobArrows;\\n  for(let i=1; i<maxMask; i++) {\\n    let score = 0;\\n    let totalArrows = 0;\\n    const currArrows = Array(n).fill(0);\\n    for(let j=0; j<n; j++) {\\n      if(i & (1 << j)) {\\n        score += j;\\n        currArrows[j] = aliceArrows[j] + 1;\\n        totalArrows += aliceArrows[j] + 1;\\n      }  \\n    }\\n    \\n    const rest = numArrows - totalArrows;\\n    \\n    if (rest >= 0 && score > res) {\\n      res = score;\\n      currArrows[0] += rest;\\n      bobArrows = currArrows;\\n    }\\n  }\\n  \\n  return bobArrows;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nfunction maximumBobPoints(numArrows: number, aliceArrows: number[]): number[] {\\n  const n = 12;\\n  const maxMask = 1 << n;\\n  \\n  let res = 0;\\n  let bobArrows;\\n  for(let i=1; i<maxMask; i++) {\\n    let score = 0;\\n    let totalArrows = 0;\\n    const currArrows = Array(n).fill(0);\\n    for(let j=0; j<n; j++) {\\n      if(i & (1 << j)) {\\n        score += j;\\n        currArrows[j] = aliceArrows[j] + 1;\\n        totalArrows += aliceArrows[j] + 1;\\n      }  \\n    }\\n    \\n    const rest = numArrows - totalArrows;\\n    \\n    if (rest >= 0 && score > res) {\\n      res = score;\\n      currArrows[0] += rest;\\n      bobArrows = currArrows;\\n    }\\n  }\\n  \\n  return bobArrows;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2468628,
                "title": "c-solution-using-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int max_score=0;\\n    void find(int index,int usearrow,int score,vector<int>&alice,vector<int>&temp)\\n    {\\n        if(index==12)\\n        {\\n            if(max_score<score)\\n            {\\n                max_score=score;\\n                ans=temp;\\n                if(usearrow)\\n                {\\n                    ans.back()+=usearrow;\\n                }\\n            }\\n            return ;\\n        }\\n        int need=alice[index]+1;\\n        if(usearrow>=need)\\n        {\\n            temp[index]=need;\\n            find(index+1,usearrow-need,score+index,alice,temp);\\n            temp[index]=0;\\n        }\\n        find(index+1,usearrow,score,alice,temp);\\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) \\n    {    \\n        vector<int>temp(12);\\n        find(0,num,0,alice,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int max_score=0;\\n    void find(int index,int usearrow,int score,vector<int>&alice,vector<int>&temp)\\n    {\\n        if(index==12)\\n        {\\n            if(max_score<score)\\n            {\\n                max_score=score;\\n                ans=temp;\\n                if(usearrow)\\n                {\\n                    ans.back()+=usearrow;\\n                }\\n            }\\n            return ;\\n        }\\n        int need=alice[index]+1;\\n        if(usearrow>=need)\\n        {\\n            temp[index]=need;\\n            find(index+1,usearrow-need,score+index,alice,temp);\\n            temp[index]=0;\\n        }\\n        find(index+1,usearrow,score,alice,temp);\\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) \\n    {    \\n        vector<int>temp(12);\\n        find(0,num,0,alice,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467750,
                "title": "c-solution-using-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int mask,vector<int>&nums,int &arrow,vector<int>&temp)\\n    {\\n        int score=0;\\n        for(int i=0;i<12;i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                int need=nums[i]+1;\\n                if(need>arrow)\\n                {\\n                    return -1;\\n                }\\n                temp[i]=need;\\n                score+=i;\\n                arrow-=need;\\n            }\\n        }\\n        return score;\\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) \\n    {    \\n        vector<int>ans(12,0);\\n        vector<int>temp(12,0);\\n        int max_score=0;\\n        for(int i=0;i<(1<<12);i++)\\n        {\\n            int usearrow=num;\\n            int score=find(i,alice,usearrow,temp);\\n            if(score!=-1&&max_score<score)\\n            {\\n                max_score=score;\\n                ans=temp;\\n                if(usearrow)\\n                {\\n                    ans[0]+=usearrow;\\n                }\\n            }\\n            temp=vector<int>(12,0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int mask,vector<int>&nums,int &arrow,vector<int>&temp)\\n    {\\n        int score=0;\\n        for(int i=0;i<12;i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                int need=nums[i]+1;\\n                if(need>arrow)\\n                {\\n                    return -1;\\n                }\\n                temp[i]=need;\\n                score+=i;\\n                arrow-=need;\\n            }\\n        }\\n        return score;\\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) \\n    {    \\n        vector<int>ans(12,0);\\n        vector<int>temp(12,0);\\n        int max_score=0;\\n        for(int i=0;i<(1<<12);i++)\\n        {\\n            int usearrow=num;\\n            int score=find(i,alice,usearrow,temp);\\n            if(score!=-1&&max_score<score)\\n            {\\n                max_score=score;\\n                ans=temp;\\n                if(usearrow)\\n                {\\n                    ans[0]+=usearrow;\\n                }\\n            }\\n            temp=vector<int>(12,0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447565,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        ll res = -1, resMax = -1;\\n        for (ll i = 0;i < (1 << 12);++i) {\\n            ll sum = 0, score = 0;\\n            for (ll j = 0;j < 12;++j) {\\n                if (i & (1 << j)) {\\n                    sum += v[j] + 1;\\n                    score += j;\\n                }\\n            }\\n            if (sum <= n && score >= resMax) {\\n                resMax = score;\\n                res = i;\\n            }\\n        }\\n        for (ll i = 0;i < 12;++i) {\\n            if (res & (1 << i)) {\\n                ++v[i];\\n            }\\n            else {\\n                v[i] = 0;\\n            }\\n        }\\n        v.back() += n - accumulate(v.begin(), v.end(), 0);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        ll res = -1, resMax = -1;\\n        for (ll i = 0;i < (1 << 12);++i) {\\n            ll sum = 0, score = 0;\\n            for (ll j = 0;j < 12;++j) {\\n                if (i & (1 << j)) {\\n                    sum += v[j] + 1;\\n                    score += j;\\n                }\\n            }\\n            if (sum <= n && score >= resMax) {\\n                resMax = score;\\n                res = i;\\n            }\\n        }\\n        for (ll i = 0;i < 12;++i) {\\n            if (res & (1 << i)) {\\n                ++v[i];\\n            }\\n            else {\\n                v[i] = 0;\\n            }\\n        }\\n        v.back() += n - accumulate(v.begin(), v.end(), 0);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441230,
                "title": "c-backtracking-faster-than-85-runtime",
                "content": "````\\nclass Solution {\\npublic:\\n    void findmax(int n,int &tot,int num,vector<int>&path,vector<int>&alice,vector<int>&ans){\\n        if(num==0 || n <= 1){\\n            int sum=0;\\n            for(int i=0;i<path.size();i++){\\n                //cout<<path[i]<<\" \";\\n                sum += path[i];\\n            }\\n            // cout<<endl;\\n            // cout<<sum<<endl;\\n            if(sum > tot){\\n                ans = path;\\n                tot= sum;\\n            }\\n            return;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(num >= (alice[i]+1)){\\n            path.push_back(i);\\n            findmax(i,tot,num-(alice[i]+1),path,alice,ans);\\n            path.pop_back();\\n            }\\n        } \\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) {\\n        vector<int>path,ans;\\n        int tot=0;\\n        int m= num;\\n        findmax(12,tot,num,path,alice,ans);\\n        // for(int i=0;i<ans.size();i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        //cout<<endl;\\n        vector<int>res(12,0);\\n        for(int i=0;i<ans.size();i++){\\n            int k= ans[i];\\n            res[k]= alice[k]+1;\\n            m-= (alice[k]+1);\\n        }\\n        if(m!=0)\\n            res[0] += m;\\n        return res;\\n    }\\n};\\n````",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void findmax(int n,int &tot,int num,vector<int>&path,vector<int>&alice,vector<int>&ans){\\n        if(num==0 || n <= 1){\\n            int sum=0;\\n            for(int i=0;i<path.size();i++){\\n                //cout<<path[i]<<\" \";\\n                sum += path[i];\\n            }\\n            // cout<<endl;\\n            // cout<<sum<<endl;\\n            if(sum > tot){\\n                ans = path;\\n                tot= sum;\\n            }\\n            return;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(num >= (alice[i]+1)){\\n            path.push_back(i);\\n            findmax(i,tot,num-(alice[i]+1),path,alice,ans);\\n            path.pop_back();\\n            }\\n        } \\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) {\\n        vector<int>path,ans;\\n        int tot=0;\\n        int m= num;\\n        findmax(12,tot,num,path,alice,ans);\\n        // for(int i=0;i<ans.size();i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        //cout<<endl;\\n        vector<int>res(12,0);\\n        for(int i=0;i<ans.size();i++){\\n            int k= ans[i];\\n            res[k]= alice[k]+1;\\n            m-= (alice[k]+1);\\n        }\\n        if(m!=0)\\n            res[0] += m;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2434012,
                "title": "c-solution-faster-than-99-1-of-other-submissions",
                "content": "This Github repository, https://github.com/AnasImloul/Leetcode-solutions, has the answer I was looking for.\\nIt is extremely beneficial to me that all solutions are available in one location. I hope it is useful to you as well.\\n```\\nclass Solution {\\npublic:\\n    int maxscore; \\n    vector<int> ans;\\n    \\n    void helper(vector<int> &bob, int i, vector<int>& alice, int remarrows, int score)\\n    {\\n        if(i == -1  or  remarrows <= 0)\\n        {\\n            if(score >= maxscore)\\n            {\\n                maxscore = score; \\n                ans = bob; \\n            }\\n            return; \\n        }\\n        \\n        helper(bob, i-1, alice, remarrows, score);\\n        if(remarrows > alice[i])\\n        {\\n            bob[i] = alice[i] + 1;\\n            remarrows -= (alice[i] + 1);\\n            score += i; \\n            helper(bob, i-1, alice, remarrows, score);\\n            bob[i] = 0;\\n        } \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        maxscore = INT_MIN; \\n        helper(bob, 11, aliceArrows, numArrows, 0);\\n        \\n        int arrows_used = 0; \\n        for(int a : ans)\\n            arrows_used += a; \\n        if(arrows_used < numArrows)\\n            ans[0] += (numArrows - arrows_used);\\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxscore; \\n    vector<int> ans;\\n    \\n    void helper(vector<int> &bob, int i, vector<int>& alice, int remarrows, int score)\\n    {\\n        if(i == -1  or  remarrows <= 0)\\n        {\\n            if(score >= maxscore)\\n            {\\n                maxscore = score; \\n                ans = bob; \\n            }\\n            return; \\n        }\\n        \\n        helper(bob, i-1, alice, remarrows, score);\\n        if(remarrows > alice[i])\\n        {\\n            bob[i] = alice[i] + 1;\\n            remarrows -= (alice[i] + 1);\\n            score += i; \\n            helper(bob, i-1, alice, remarrows, score);\\n            bob[i] = 0;\\n        } \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        maxscore = INT_MIN; \\n        helper(bob, 11, aliceArrows, numArrows, 0);\\n        \\n        int arrows_used = 0; \\n        for(int a : ans)\\n            arrows_used += a; \\n        if(arrows_used < numArrows)\\n            ans[0] += (numArrows - arrows_used);\\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424140,
                "title": "backtracking",
                "content": "class Solution {\\n \\npublic:\\n   vector<int> res;\\n    int max_sc;\\n    void func(int i,vector<int> &arr,int sc,vector<int>&v,int a)\\n    {\\n       \\n        if(i==arr.size()|| a==0)\\n        {\\n            if(sc>max_sc)\\n            {\\n                max_sc=sc;\\n                res.clear();\\n                res=v;\\n            }\\n           return;\\n        }\\n        \\n        if(a>arr[i])\\n        {\\n            v[i]=arr[i]+1;\\n            func(i+1,arr,sc+i,v,a-v[i]);\\n            v[i]=0;\\n        }\\n       \\n       func(i+1,arr,sc,v,a);\\n      \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        res.clear();\\n        max_sc=0;\\n        vector<int> v(12,0);\\n        func(0,aliceArrows,0,v,numArrows);\\n        int a=0;\\n        for(int i=0;i<res.size();i++)\\n        {\\n            a+=res[i];\\n        }\\n        if(a<numArrows)\\n        {\\n            res[0]+=numArrows-a;\\n        }\\n        return res;\\n    }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n \\npublic:\\n   vector<int> res;\\n    int max_sc;\\n    void func(int i,vector<int> &arr,int sc,vector<int>&v,int a)\\n    {\\n       \\n        if(i==arr.size()|| a==0)\\n        {\\n            if(sc>max_sc)\\n            {\\n                max_sc=sc;\\n                res.clear();\\n                res=v;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2386602,
                "title": "python-recursion-top-down-approach-notes",
                "content": "```\\n\"\"\"\\nwe can try to solve this problem using recursion and memoization\\nat every point, we have a choice whether to shoot arrows there or not\\nif we decide to shoot the arrow, it would make sense to shoot one arrow more \\nthan what alice has shooted in that section to get the points awarded else\\nwe will skip that section\\n\"\"\"\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        lookup = {}\\n        self.ans = \"0\"*12\\n        self.max_score = 0\\n        result = [0 for _ in range(12)]\\n        def fun(index, rem_arrow, path, score):\\n            if index < 0 or rem_arrow == 0:\\n                if score > self.max_score:\\n                    self.max_score = score\\n                    self.ans = path\\n                return\\n            # try to shoot at current section (index)\\n            if rem_arrow > aliceArrows[index]:\\n                fun(index-1, rem_arrow-(aliceArrows[index]+1), path[:index] + \\'1\\' + path[index+1:], score+index)\\n            # skip shooting at current section\\n            fun(index-1, rem_arrow, path, score)\\n        fun(11, numArrows, \"0\"*12, 0)\\n        for i, char in enumerate(self.ans):\\n            if char == \\'1\\':\\n                result[i] = aliceArrows[i] + 1\\n        if sum(result) < numArrows:\\n            result[0] += numArrows - sum(result)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\"\"\"\\nwe can try to solve this problem using recursion and memoization\\nat every point, we have a choice whether to shoot arrows there or not\\nif we decide to shoot the arrow, it would make sense to shoot one arrow more \\nthan what alice has shooted in that section to get the points awarded else\\nwe will skip that section\\n\"\"\"\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        lookup = {}\\n        self.ans = \"0\"*12\\n        self.max_score = 0\\n        result = [0 for _ in range(12)]\\n        def fun(index, rem_arrow, path, score):\\n            if index < 0 or rem_arrow == 0:\\n                if score > self.max_score:\\n                    self.max_score = score\\n                    self.ans = path\\n                return\\n            # try to shoot at current section (index)\\n            if rem_arrow > aliceArrows[index]:\\n                fun(index-1, rem_arrow-(aliceArrows[index]+1), path[:index] + \\'1\\' + path[index+1:], score+index)\\n            # skip shooting at current section\\n            fun(index-1, rem_arrow, path, score)\\n        fun(11, numArrows, \"0\"*12, 0)\\n        for i, char in enumerate(self.ans):\\n            if char == \\'1\\':\\n                result[i] = aliceArrows[i] + 1\\n        if sum(result) < numArrows:\\n            result[0] += numArrows - sum(result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375085,
                "title": "java-recursion-brute-force",
                "content": "```\\n\\nclass Solution {\\n    int bobsPoints = 0;\\n    int maxBobsPoints = 0;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int index = 0; \\n        int[] ans1 = findMaxBobpoints(numArrows, aliceArrows, index, bobsPoints);\\n        int[] res = new int[12];\\n\\t\\t// while returning the answer I exclude the extra element that I added in the array to keep track of the max score path\\n        for(int i = 0; i < ans1.length - 1; ++i){ \\t\\n            res[i] = ans1[i];\\n        }\\n        return res;\\n    }\\n    \\n    private int[] findMaxBobpoints(int numArrows, int[] aliceArrows, int index,int bobsPoints){\\n        if(index == 12 ||  numArrows  <= 0){\\n            maxBobsPoints  = Math.max(bobsPoints, maxBobsPoints);\\n            int[] ans =  new int[13]; // one extra space in ans to keep track of which path returned the max score\\n            ans[12] = bobsPoints;\\n            if(numArrows > 0){ // if any arrows left add it to the section[0] \\n                ans[0] = numArrows;\\n            }\\n            return ans;\\n        }\\n\\n        int[] sectionSelected = new int[13];\\n        if(numArrows - (aliceArrows[index] + 1) >= 0){\\n\\t\\t\\tsectionSelected  = findMaxBobpoints(numArrows - (aliceArrows[index] + 1), aliceArrows, index + 1, bobsPoints + index);\\n\\t\\t\\tsectionSelected[index] += aliceArrows[index] + 1;\\n        }\\n        \\n        int[] sectionSkipped = findMaxBobpoints(numArrows, aliceArrows, index + 1, bobsPoints);\\n        \\n        if(sectionSelected[12] == maxBobsPoints){ // check if this is the path that returned the max score\\n            return sectionSelected;\\n        }\\n        else{\\n            return sectionSkipped;\\n        }\\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int bobsPoints = 0;\\n    int maxBobsPoints = 0;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int index = 0; \\n        int[] ans1 = findMaxBobpoints(numArrows, aliceArrows, index, bobsPoints);\\n        int[] res = new int[12];\\n\\t\\t// while returning the answer I exclude the extra element that I added in the array to keep track of the max score path\\n        for(int i = 0; i < ans1.length - 1; ++i){ \\t\\n            res[i] = ans1[i];\\n        }\\n        return res;\\n    }\\n    \\n    private int[] findMaxBobpoints(int numArrows, int[] aliceArrows, int index,int bobsPoints){\\n        if(index == 12 ||  numArrows  <= 0){\\n            maxBobsPoints  = Math.max(bobsPoints, maxBobsPoints);\\n            int[] ans =  new int[13]; // one extra space in ans to keep track of which path returned the max score\\n            ans[12] = bobsPoints;\\n            if(numArrows > 0){ // if any arrows left add it to the section[0] \\n                ans[0] = numArrows;\\n            }\\n            return ans;\\n        }\\n\\n        int[] sectionSelected = new int[13];\\n        if(numArrows - (aliceArrows[index] + 1) >= 0){\\n\\t\\t\\tsectionSelected  = findMaxBobpoints(numArrows - (aliceArrows[index] + 1), aliceArrows, index + 1, bobsPoints + index);\\n\\t\\t\\tsectionSelected[index] += aliceArrows[index] + 1;\\n        }\\n        \\n        int[] sectionSkipped = findMaxBobpoints(numArrows, aliceArrows, index + 1, bobsPoints);\\n        \\n        if(sectionSelected[12] == maxBobsPoints){ // check if this is the path that returned the max score\\n            return sectionSelected;\\n        }\\n        else{\\n            return sectionSkipped;\\n        }\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357543,
                "title": "java-memoization",
                "content": "class Solution {\\n    \\n    int bitsSum(int n){\\n        int ans = 0;\\n        for(int i=0;i<12;i++){\\n            if((n&(1<<i))==(1<<i))\\n                ans += i;\\n        }\\n        return ans;\\n    }\\n    \\n    int solve(int ind, int arrows,List<Map<Integer,Integer>> store,int[] arr){\\n        if(ind==12 || arrows==0)\\n            return 0;\\n        if(store.get(ind).containsKey(arrows))\\n            return store.get(ind).get(arrows);\\n        int res = solve(ind+1,arrows,store,arr);\\n        if(arrows>arr[ind]){\\n            int temp = (1<<ind) + solve(ind+1,arrows-arr[ind]-1,store,arr);\\n            if(bitsSum(temp) > bitsSum(res)){\\n                res = temp;\\n            }\\n        }\\n        store.get(ind).put(arrows,res);\\n        return res;\\n    }\\n    \\n    int[] findArray(int tot, int n,int arr[]){\\n        int[] ans = new int[12];\\n        for(int i=1;i<12;i++){\\n            if((tot&(1<<i))==(1<<i)){\\n                ans[i] = arr[i]+1;\\n                n -= (arr[i]+1);\\n            }\\n        }\\n        ans[0]=n;\\n        return ans;\\n    }\\n    \\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        List<Map<Integer,Integer>> store = new ArrayList<>();\\n        for(int i=0;i<12;i++){\\n            store.add(new HashMap<>());\\n        }\\n        return findArray(solve(0,numArrows,store,aliceArrows),numArrows,aliceArrows);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int bitsSum(int n){\\n        int ans = 0;\\n        for(int i=0;i<12;i++){\\n            if((n&(1<<i))==(1<<i))\\n                ans += i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2344201,
                "title": "python-backtrack-solution",
                "content": "```\\ndef maximumBobPoints(self, k: int, alice: List[int]) -> List[int]:\\n\\tself.mx = 0\\n\\tself.bob = None # binary string to record Bob\\'s winning section\\n\\n\\tdef btrack(idx, path, score, arr):\\n\\t\\tif idx<0 or arr==0:\\n\\t\\t\\tif score>self.mx:\\n\\t\\t\\t\\tself.mx = score\\n\\t\\t\\t\\tself.bob = path[:]\\n\\t\\t\\treturn\\n\\n\\t\\tif arr>alice[idx]:\\n\\t\\t\\tbtrack(idx-1, path[:idx]+\\'1\\'+path[idx+1:], score+idx, arr-alice[idx]-1)\\n\\n\\t\\tbtrack(idx-1, path, score, arr)\\n\\n\\tbtrack(11, \\'0\\'*12, 0, k)\\n\\tans = [alice[i]+1 if self.bob[i]==\\'1\\' else 0 for i in range(12)]\\n\\tans[-1] += (k-sum(ans))\\n\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumBobPoints(self, k: int, alice: List[int]) -> List[int]:\\n\\tself.mx = 0\\n\\tself.bob = None # binary string to record Bob\\'s winning section\\n\\n\\tdef btrack(idx, path, score, arr):\\n\\t\\tif idx<0 or arr==0:\\n\\t\\t\\tif score>self.mx:\\n\\t\\t\\t\\tself.mx = score\\n\\t\\t\\t\\tself.bob = path[:]\\n\\t\\t\\treturn\\n\\n\\t\\tif arr>alice[idx]:\\n\\t\\t\\tbtrack(idx-1, path[:idx]+\\'1\\'+path[idx+1:], score+idx, arr-alice[idx]-1)\\n\\n\\t\\tbtrack(idx-1, path, score, arr)\\n\\n\\tbtrack(11, \\'0\\'*12, 0, k)\\n\\tans = [alice[i]+1 if self.bob[i]==\\'1\\' else 0 for i in range(12)]\\n\\tans[-1] += (k-sum(ans))\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2307998,
                "title": "c-code-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    map<int,int> dp;\\n    int mx=0;\\n    \\n    int func(int n,vector<int> &v,int mask,int rem,vector<int> &temp,int scr){\\n       if (scr>mx){\\n          mx=scr;\\n          ans=temp;\\n        }\\n        \\n        if (mask==(pow(2,12)-1) || rem==0){\\n            return 0;\\n        }\\n        \\n        if (dp.find(mask)!=dp.end()){\\n            return dp[mask];\\n        }\\n        \\n        int val=0;\\n        for (int i=0; i<v.size(); i++){\\n            if (mask&(1<<i)){\\n                continue;\\n            }\\n            \\n            if (rem>=v[i]+1){\\n              vector<int> ele=temp;\\n                ele[i]=v[i]+1;\\n              val=max(val,i+func(n,v,(mask|(1<<i)),rem-(v[i]+1),ele,scr+i));  \\n              \\n            }\\n        }\\n        \\n       return dp[mask]=val;\\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        int i;\\n        vector<int> temp(12,0);\\n        \\n        func(n,v,0,n,temp,0);\\n        int val=0;\\n        \\n        for (i=0; i<ans.size(); i++){\\n            val+=ans[i];\\n        }\\n        \\n        int diff=n-val;\\n        cout<<diff<<endl;\\n        for (i=0; i<v.size(); i++){\\n           \\n               ans[i]+=diff; \\n               break;\\n            \\n        }\\n        \\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    map<int,int> dp;\\n    int mx=0;\\n    \\n    int func(int n,vector<int> &v,int mask,int rem,vector<int> &temp,int scr){\\n       if (scr>mx){\\n          mx=scr;\\n          ans=temp;\\n        }\\n        \\n        if (mask==(pow(2,12)-1) || rem==0){\\n            return 0;\\n        }\\n        \\n        if (dp.find(mask)!=dp.end()){\\n            return dp[mask];\\n        }\\n        \\n        int val=0;\\n        for (int i=0; i<v.size(); i++){\\n            if (mask&(1<<i)){\\n                continue;\\n            }\\n            \\n            if (rem>=v[i]+1){\\n              vector<int> ele=temp;\\n                ele[i]=v[i]+1;\\n              val=max(val,i+func(n,v,(mask|(1<<i)),rem-(v[i]+1),ele,scr+i));  \\n              \\n            }\\n        }\\n        \\n       return dp[mask]=val;\\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        int i;\\n        vector<int> temp(12,0);\\n        \\n        func(n,v,0,n,temp,0);\\n        int val=0;\\n        \\n        for (i=0; i<ans.size(); i++){\\n            val+=ans[i];\\n        }\\n        \\n        int diff=n-val;\\n        cout<<diff<<endl;\\n        for (i=0; i<v.size(); i++){\\n           \\n               ans[i]+=diff; \\n               break;\\n            \\n        }\\n        \\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2254720,
                "title": "easy-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    vector<int> b;\\n    void solve(int t,vector<int> &aa,int idx,vector<int> &ba,int sc)\\n    {\\n        if(idx<0)\\n        {\\n            if(ans<sc)\\n            {\\n                ans=sc;\\n                b=ba;\\n                // to make total equal to numArrows\\n                if(t>0)\\n                {\\n                    b[0]=b[0]+t;\\n                }\\n            }\\n            return;\\n        }\\n        //take\\n        if(t-(aa[idx]+1)>=0)\\n        {\\n            \\n            ba[idx]=aa[idx]+1;\\n            solve(t-(aa[idx]+1),aa,idx-1,ba,sc+idx);\\n            ba[idx]=0;\\n        }\\n        //not take\\n        solve(t,aa,idx-1,ba,sc);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=aliceArrows.size(),tar=0;\\n        vector<int> ba(n,0);\\n        ans=0;\\n        b.clear();\\n        solve(numArrows,aliceArrows,n-1,ba,0);\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    vector<int> b;\\n    void solve(int t,vector<int> &aa,int idx,vector<int> &ba,int sc)\\n    {\\n        if(idx<0)\\n        {\\n            if(ans<sc)\\n            {\\n                ans=sc;\\n                b=ba;\\n                // to make total equal to numArrows\\n                if(t>0)\\n                {\\n                    b[0]=b[0]+t;\\n                }\\n            }\\n            return;\\n        }\\n        //take\\n        if(t-(aa[idx]+1)>=0)\\n        {\\n            \\n            ba[idx]=aa[idx]+1;\\n            solve(t-(aa[idx]+1),aa,idx-1,ba,sc+idx);\\n            ba[idx]=0;\\n        }\\n        //not take\\n        solve(t,aa,idx-1,ba,sc);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=aliceArrows.size(),tar=0;\\n        vector<int> ba(n,0);\\n        ans=0;\\n        b.clear();\\n        solve(numArrows,aliceArrows,n-1,ba,0);\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229651,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn maximum_bob_points(num_arrows: i32, alice_arrows: Vec<i32>) -> Vec<i32> {\\n        let limit = 1 << 12;\\n        let mut max = 0;\\n        let mut result = vec![0;12];\\n        for i in 0..limit {\\n            let mut temp = 0;\\n            let mut score = 0;\\n            let mut memo = vec![0;12];\\n            for j in 0..12 {\\n                if i >> j & 1 == 1 {\\n                    temp += alice_arrows[j]+1;\\n                    memo[j] = alice_arrows[j]+1;\\n                    score += j as i32;\\n                }\\n            }\\n\\n            if max < score && temp <= num_arrows {\\n                max = score;\\n                result = memo;\\n            }\\n        }\\n\\n        let mut tot = 0;\\n        for i in 0..12 {\\n            tot += result[i];\\n        }\\n        result[11] += num_arrows - tot;\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_bob_points(num_arrows: i32, alice_arrows: Vec<i32>) -> Vec<i32> {\\n        let limit = 1 << 12;\\n        let mut max = 0;\\n        let mut result = vec![0;12];\\n        for i in 0..limit {\\n            let mut temp = 0;\\n            let mut score = 0;\\n            let mut memo = vec![0;12];\\n            for j in 0..12 {\\n                if i >> j & 1 == 1 {\\n                    temp += alice_arrows[j]+1;\\n                    memo[j] = alice_arrows[j]+1;\\n                    score += j as i32;\\n                }\\n            }\\n\\n            if max < score && temp <= num_arrows {\\n                max = score;\\n                result = memo;\\n            }\\n        }\\n\\n        let mut tot = 0;\\n        for i in 0..12 {\\n            tot += result[i];\\n        }\\n        result[11] += num_arrows - tot;\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226063,
                "title": "java-time-o-n2-n-space-o-2-n-bit-masking",
                "content": "```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int n = aliceArrows.length;\\n        int maxScore = 0, maxState = 0;\\n        for(int mask = 0;mask<(1<<n);mask++){\\n            int cnt = 0, score = 0;\\n            for(int i=0;i<n;i++){\\n                if((mask&(1<<i))>0){\\n                    cnt += aliceArrows[i]+1;\\n                    score += i;\\n                }\\n            }\\n            if(cnt<=numArrows&&score>maxScore){\\n                maxScore = score;\\n                maxState = mask;\\n            }\\n        }\\n        \\n        \\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            if((maxState&(1<<i))>0){\\n                ans[i] = aliceArrows[i] + 1;\\n                numArrows -= ans[i];\\n            }\\n        }\\n        ans[0] += numArrows;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int n = aliceArrows.length;\\n        int maxScore = 0, maxState = 0;\\n        for(int mask = 0;mask<(1<<n);mask++){\\n            int cnt = 0, score = 0;\\n            for(int i=0;i<n;i++){\\n                if((mask&(1<<i))>0){\\n                    cnt += aliceArrows[i]+1;\\n                    score += i;\\n                }\\n            }\\n            if(cnt<=numArrows&&score>maxScore){\\n                maxScore = score;\\n                maxState = mask;\\n            }\\n        }\\n        \\n        \\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            if((maxState&(1<<i))>0){\\n                ans[i] = aliceArrows[i] + 1;\\n                numArrows -= ans[i];\\n            }\\n        }\\n        ans[0] += numArrows;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219814,
                "title": "python-simple-maths",
                "content": "\\n    def maximumBobPoints(self, numArrows, aliceArrows):\\n        ans, rem_arrow = [0]*12, numArrows\\n        \\n        def dfs(idx, count):\\n            if idx == 12 or count == 0:\\n                return 0\\n            \\n            if count > aliceArrows[idx]:\\n                return max(dfs(idx+1, count), dfs(idx+1, count - aliceArrows[idx] - 1) + idx)\\n            else:\\n                return dfs(idx+1, count)\\n        \\n        for j in range(12):\\n            if dfs(j+1, rem_arrow) < dfs(j, rem_arrow):\\n                ans[j] = aliceArrows[j] + 1\\n                rem_arrow -= aliceArrows[j] + 1\\n                \\n                \\n        ans[0] += rem_arrow\\n        \\n        return ans",
                "solutionTags": [],
                "code": "\\n    def maximumBobPoints(self, numArrows, aliceArrows):\\n        ans, rem_arrow = [0]*12, numArrows\\n        \\n        def dfs(idx, count):\\n            if idx == 12 or count == 0:\\n                return 0\\n            \\n            if count > aliceArrows[idx]:\\n                return max(dfs(idx+1, count), dfs(idx+1, count - aliceArrows[idx] - 1) + idx)\\n            else:\\n                return dfs(idx+1, count)\\n        \\n        for j in range(12):\\n            if dfs(j+1, rem_arrow) < dfs(j, rem_arrow):\\n                ans[j] = aliceArrows[j] + 1\\n                rem_arrow -= aliceArrows[j] + 1\\n                \\n                \\n        ans[0] += rem_arrow\\n        \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2183542,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int arrows, vector<int>alice, vector<int>&res, vector<int>curr, int& maxi, int sum, int index){\\n        \\n        if(index<0){\\n            if(sum > maxi){\\n                maxi = sum;\\n                if(arrows>0){\\n                    curr[10]+=arrows;\\n                }\\n                res.clear();\\n                for(int i=0;i<=11;i++){\\n                    res.push_back(curr[i]);\\n                }\\n            }\\n            return;\\n        }\\n        \\n        \\n        if(arrows >= alice[index] + 1){\\n            curr.push_back(alice[index]+1);\\n            sum+=index;\\n            arrows=arrows - alice[index] - 1;\\n            solve(arrows, alice, res, curr, maxi, sum, index-1);\\n            arrows+=alice[index]+1;\\n            sum-=index;\\n            curr.pop_back();\\n        }\\n        \\n        \\n        curr.push_back(0);\\n        solve(arrows, alice, res, curr, maxi, sum, index-1);\\n        curr.pop_back();\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res;\\n        vector<int>curr;\\n        \\n        int maxi = 0, sum=0;\\n        \\n        solve(numArrows, aliceArrows, res, curr, maxi, sum, 11);\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int arrows, vector<int>alice, vector<int>&res, vector<int>curr, int& maxi, int sum, int index){\\n        \\n        if(index<0){\\n            if(sum > maxi){\\n                maxi = sum;\\n                if(arrows>0){\\n                    curr[10]+=arrows;\\n                }\\n                res.clear();\\n                for(int i=0;i<=11;i++){\\n                    res.push_back(curr[i]);\\n                }\\n            }\\n            return;\\n        }\\n        \\n        \\n        if(arrows >= alice[index] + 1){\\n            curr.push_back(alice[index]+1);\\n            sum+=index;\\n            arrows=arrows - alice[index] - 1;\\n            solve(arrows, alice, res, curr, maxi, sum, index-1);\\n            arrows+=alice[index]+1;\\n            sum-=index;\\n            curr.pop_back();\\n        }\\n        \\n        \\n        curr.push_back(0);\\n        solve(arrows, alice, res, curr, maxi, sum, index-1);\\n        curr.pop_back();\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res;\\n        vector<int>curr;\\n        \\n        int maxi = 0, sum=0;\\n        \\n        solve(numArrows, aliceArrows, res, curr, maxi, sum, 11);\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167101,
                "title": "c-bitmasking-100-time-62-space-o-1-vs-98-time-82-space",
                "content": "using dp made me faster than 100%, less space than 62%\\nwithout dp, faster than 98%, less space than 82%\\n```\\nclass Solution {\\npublic:\\n    int mask=(1<<12)-1; int ans=-1,ansmask;\\n    int dp[(1<<12)]={0};\\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        solve(n,v,0,0,12); cout<<ans<<\" \"<<ansmask;\\n        vector<int> b(12,0); int tot=0;\\n        for(int i=0;i<12;i++) //demasking to vector\\n            if(ansmask&(1<<i)) b[i]=v[i]+1, tot+=(b[i]);\\n        if(tot<n) b[0]+=(n-tot); //throwing unwanted arrows at first target\\n        return b;\\n    }\\n    void solve(int n, vector<int>&v, int m, int sum,int j){\\n        \\n        // cout<<n<<\" \"<<m<<\" \"<<sum<<\" \"<<j<<endl;\\n        if(n<0) return;\\n        if(dp[m]) return;\\n        dp[m]=1;\\n        if(ans<=sum){\\n            ans=sum; ansmask=m;\\n        }\\n        if(n==0) return;\\n        for(int i=j-1;i>=0;i--){\\n        // j avoids recheking many unessecary repitition(better approach than dp because dp blocks a single mask, while j blocks all the greater numbers in the loop)\\n            if((m&(1<<i))==0){\\n                solve(n-v[i]-1,v,m|(1<<i),sum+i, i);\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\n//space o(1)\\n//time o(12*12) o(1)\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mask=(1<<12)-1; int ans=-1,ansmask;\\n    int dp[(1<<12)]={0};\\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        solve(n,v,0,0,12); cout<<ans<<\" \"<<ansmask;\\n        vector<int> b(12,0); int tot=0;\\n        for(int i=0;i<12;i++) //demasking to vector\\n            if(ansmask&(1<<i)) b[i]=v[i]+1, tot+=(b[i]);\\n        if(tot<n) b[0]+=(n-tot); //throwing unwanted arrows at first target\\n        return b;\\n    }\\n    void solve(int n, vector<int>&v, int m, int sum,int j){\\n        \\n        // cout<<n<<\" \"<<m<<\" \"<<sum<<\" \"<<j<<endl;\\n        if(n<0) return;\\n        if(dp[m]) return;\\n        dp[m]=1;\\n        if(ans<=sum){\\n            ans=sum; ansmask=m;\\n        }\\n        if(n==0) return;\\n        for(int i=j-1;i>=0;i--){\\n        // j avoids recheking many unessecary repitition(better approach than dp because dp blocks a single mask, while j blocks all the greater numbers in the loop)\\n            if((m&(1<<i))==0){\\n                solve(n-v[i]-1,v,m|(1<<i),sum+i, i);\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\n//space o(1)\\n//time o(12*12) o(1)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2141992,
                "title": "bitmask-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<int> a;\\n\\n\\tvoid solve(int i, int avail, int mask, int curSum, int &maxSum, int &ansMask) {\\n\\n\\t\\tif (i == -1) {\\n\\t\\t\\tif (curSum > maxSum) {\\n\\t\\t\\t\\tmaxSum = curSum;\\n\\t\\t\\t\\tansMask = mask;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (avail >= a[i] + 1) solve(i - 1, avail - (a[i] + 1), mask | (1 << i), curSum + i, maxSum, ansMask);\\n\\t\\tsolve(i - 1, avail, mask, curSum, maxSum, ansMask);\\n\\t}\\n\\n\\n\\tvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n\\n\\t\\ta = aliceArrows;\\n\\n\\t\\tint ansMask = 0, maxSum = 0;\\n\\t\\tint n = a.size();\\n\\t\\tsolve(n - 1, numArrows, 0, 0, maxSum, ansMask);\\n\\n\\t\\tvector<int> ans(n, 0);\\n        int total = accumulate(a.begin(), a.end(), 0);\\n        \\n        int kept = 0;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (ansMask & (1 << i)) {\\n                kept += (a[i] + 1);\\n                ans[i] = a[i] + 1;\\n            }\\n\\t\\t}\\n        \\n        int diff = total - kept;\\n        ans[0]+=diff;\\n        \\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> a;\\n\\n\\tvoid solve(int i, int avail, int mask, int curSum, int &maxSum, int &ansMask) {\\n\\n\\t\\tif (i == -1) {\\n\\t\\t\\tif (curSum > maxSum) {\\n\\t\\t\\t\\tmaxSum = curSum;\\n\\t\\t\\t\\tansMask = mask;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (avail >= a[i] + 1) solve(i - 1, avail - (a[i] + 1), mask | (1 << i), curSum + i, maxSum, ansMask);\\n\\t\\tsolve(i - 1, avail, mask, curSum, maxSum, ansMask);\\n\\t}\\n\\n\\n\\tvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n\\n\\t\\ta = aliceArrows;\\n\\n\\t\\tint ansMask = 0, maxSum = 0;\\n\\t\\tint n = a.size();\\n\\t\\tsolve(n - 1, numArrows, 0, 0, maxSum, ansMask);\\n\\n\\t\\tvector<int> ans(n, 0);\\n        int total = accumulate(a.begin(), a.end(), 0);\\n        \\n        int kept = 0;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (ansMask & (1 << i)) {\\n                kept += (a[i] + 1);\\n                ans[i] = a[i] + 1;\\n            }\\n\\t\\t}\\n        \\n        int diff = total - kept;\\n        ans[0]+=diff;\\n        \\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116108,
                "title": "javascript-solution-recursion-with-bitmask",
                "content": "```\\nvar maximumBobPoints = function(numArrows, aliceArrows) {\\n    const n = aliceArrows.length;\\n    \\n    let maxScore = 0;\\n    let maxMask = 0;\\n    let maxArrowsLeft = 0;\\n    \\n    topDown(n - 1, numArrows, 0, (1 << 12) - 1);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const lastBit = maxMask & 1;\\n        \\n        if (!lastBit) {\\n            res[i] = aliceArrows[i] + 1;\\n        }\\n        \\n        maxMask >>= 1;\\n    }\\n   \\n    res[0] += maxArrowsLeft;\\n    \\n    return res;\\n    \\n    function topDown(idx, remArrows, score, mask) {\\n        if (idx < 0 || remArrows === 0) {\\n            if (score > maxScore) {\\n                maxScore = score;\\n                maxMask = mask;\\n                maxArrowsLeft = remArrows;\\n            }\\n            return;\\n        }\\n\\n        const alice_arrows_placed = aliceArrows[idx];\\n        \\n        if (remArrows > alice_arrows_placed) {\\n            topDown(idx - 1, remArrows - alice_arrows_placed - 1, score + idx, mask & ~(1 << idx));\\n        }\\n        \\n        topDown(idx - 1, remArrows, score, mask);\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nvar maximumBobPoints = function(numArrows, aliceArrows) {\\n    const n = aliceArrows.length;\\n    \\n    let maxScore = 0;\\n    let maxMask = 0;\\n    let maxArrowsLeft = 0;\\n    \\n    topDown(n - 1, numArrows, 0, (1 << 12) - 1);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const lastBit = maxMask & 1;\\n        \\n        if (!lastBit) {\\n            res[i] = aliceArrows[i] + 1;\\n        }\\n        \\n        maxMask >>= 1;\\n    }\\n   \\n    res[0] += maxArrowsLeft;\\n    \\n    return res;\\n    \\n    function topDown(idx, remArrows, score, mask) {\\n        if (idx < 0 || remArrows === 0) {\\n            if (score > maxScore) {\\n                maxScore = score;\\n                maxMask = mask;\\n                maxArrowsLeft = remArrows;\\n            }\\n            return;\\n        }\\n\\n        const alice_arrows_placed = aliceArrows[idx];\\n        \\n        if (remArrows > alice_arrows_placed) {\\n            topDown(idx - 1, remArrows - alice_arrows_placed - 1, score + idx, mask & ~(1 << idx));\\n        }\\n        \\n        topDown(idx - 1, remArrows, score, mask);\\n       \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115640,
                "title": "python-simple-dfs",
                "content": "```\\ndef maximumBobPoints(self, n, a):\\n        def dfs(i, k, cursum):\\n            if i == 12:\\n                if cursum > self.maxsum: \\n                    self.maxsum = cursum\\n                    self.ans = b[:]\\n                    # Put remaining arrows anywhere - I put it on 0.\\n                    self.ans[0] += n - sum(self.ans)\\n                return\\n            dfs(i + 1, k, cursum)\\n            if k <= a[i]: return\\n            b[i] += a[i] + 1\\n            dfs(i + 1, k - a[i] - 1, cursum + i)\\n            b[i] -= (a[i] + 1)\\n        \\n        self.maxsum = 0\\n        self.ans = []\\n        b = [0] * 12\\n        dfs(1, n, 0)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumBobPoints(self, n, a):\\n        def dfs(i, k, cursum):\\n            if i == 12:\\n                if cursum > self.maxsum: \\n                    self.maxsum = cursum\\n                    self.ans = b[:]\\n                    # Put remaining arrows anywhere - I put it on 0.\\n                    self.ans[0] += n - sum(self.ans)\\n                return\\n            dfs(i + 1, k, cursum)\\n            if k <= a[i]: return\\n            b[i] += a[i] + 1\\n            dfs(i + 1, k - a[i] - 1, cursum + i)\\n            b[i] -= (a[i] + 1)\\n        \\n        self.maxsum = 0\\n        self.ans = []\\n        b = [0] * 12\\n        dfs(1, n, 0)\\n        return self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2105793,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, arrows: int, alice: List[int]) -> List[int]:\\n        \\n        n=len(alice)\\n        alicescore=0\\n        for i in range(n):\\n            if alice[i]!=0:\\n                alicescore+=i\\n                \\n        def check(i,arrows,alice,bob,score,mxsc):\\n            if i<0:\\n                if score>mxsc[0]:\\n                    mxsc[0]=score\\n                    self.ans=bob.copy()\\n                return \\n            \\n            \\n            if arrows==0:\\n                if score>mxsc[0]:\\n                    mxsc[0]=score\\n                    self.ans=bob.copy()\\n                return\\n                \\n                \\n            if i==0:\\n                bob[i]=arrows\\n                check(i-1,arrows-bob[i],alice,bob,score+i,mxsc)\\n                bob[i]=0\\n                    \\n            \\n            elif arrows>alice[i]:\\n                bob[i]=alice[i]+1\\n                check(i-1,arrows-bob[i],alice,bob,score+i,mxsc)\\n                    \\n                bob[i]=0\\n                \\n                check(i-1,arrows,alice,bob,score,mxsc)\\n                    \\n            else:\\n                check(i-1,arrows,alice,bob,score,mxsc)\\n                    \\n                \\n        \\n            \\n        \\n        bob=[0 for j in range(n)]\\n        self.ans=[]\\n        mxsc=[0]\\n        check(n-1,arrows,alice,bob,0,mxsc)\\n        return self.ans\\n        \\n        \\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, arrows: int, alice: List[int]) -> List[int]:\\n        \\n        n=len(alice)\\n        alicescore=0\\n        for i in range(n):\\n            if alice[i]!=0:\\n                alicescore+=i\\n                \\n        def check(i,arrows,alice,bob,score,mxsc):\\n            if i<0:\\n                if score>mxsc[0]:\\n                    mxsc[0]=score\\n                    self.ans=bob.copy()\\n                return \\n            \\n            \\n            if arrows==0:\\n                if score>mxsc[0]:\\n                    mxsc[0]=score\\n                    self.ans=bob.copy()\\n                return\\n                \\n                \\n            if i==0:\\n                bob[i]=arrows\\n                check(i-1,arrows-bob[i],alice,bob,score+i,mxsc)\\n                bob[i]=0\\n                    \\n            \\n            elif arrows>alice[i]:\\n                bob[i]=alice[i]+1\\n                check(i-1,arrows-bob[i],alice,bob,score+i,mxsc)\\n                    \\n                bob[i]=0\\n                \\n                check(i-1,arrows,alice,bob,score,mxsc)\\n                    \\n            else:\\n                check(i-1,arrows,alice,bob,score,mxsc)\\n                    \\n                \\n        \\n            \\n        \\n        bob=[0 for j in range(n)]\\n        self.ans=[]\\n        mxsc=[0]\\n        check(n-1,arrows,alice,bob,0,mxsc)\\n        return self.ans\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101180,
                "title": "c-bitmask-iterative-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& arr) { \\n        int res=0, resMask=0, last=1<<12;;\\n        vector<int>here(12,0);\\n        for(int i=1; i<last; i++){\\n            int cur=0,m=n,mask=0;\\n            for(int k=0; k<12; k++){\\n                if(i&(1<<k) && arr[k]<m){\\n                    m-=(arr[k]+1);\\n                    mask|=(1<<k);\\n                    cur+= k;\\n                }\\n            }\\n            if(mask==i && cur>res){\\n                res=cur;\\n                resMask=i;\\n            }             \\n        }\\n        int tot=n;\\n        for(int i=0; i<12; i++){\\n            if(resMask&(1<<i)){\\n                here[i]=arr[i]+1;\\n                tot-=here[i];\\n            }\\n        }\\n        here[0]=tot;\\n        return here;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& arr) { \\n        int res=0, resMask=0, last=1<<12;;\\n        vector<int>here(12,0);\\n        for(int i=1; i<last; i++){\\n            int cur=0,m=n,mask=0;\\n            for(int k=0; k<12; k++){\\n                if(i&(1<<k) && arr[k]<m){\\n                    m-=(arr[k]+1);\\n                    mask|=(1<<k);\\n                    cur+= k;\\n                }\\n            }\\n            if(mask==i && cur>res){\\n                res=cur;\\n                resMask=i;\\n            }             \\n        }\\n        int tot=n;\\n        for(int i=0; i<12; i++){\\n            if(resMask&(1<<i)){\\n                here[i]=arr[i]+1;\\n                tot-=here[i];\\n            }\\n        }\\n        here[0]=tot;\\n        return here;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048858,
                "title": "easy-understanding-python-dfs",
                "content": "```\\n        max_path = [0] * len(aliceArrows)\\n        max_score = 0\\n        \\n        @cache\\n        def dfs(numArrow, count, score, path):\\n            nonlocal max_score\\n\\n            if numArrow < 0: # invalid\\n                return\\n            \\n            if numArrow == 0 or count == len(aliceArrows): # no more arrows to use or finish\\n                if score > max_score:\\n                    max_score = score\\n                    for i in range(len(max_path)):\\n                        if i < len(path):\\n                            max_path[i] = path[i]\\n                        else:\\n                            max_path[i] = 0\\n                    max_path[0] = numArrows - sum(max_path[1:]) # balance the total arrows for two choices\\n                return\\n            \\n            # two choices\\n            dfs(numArrow, count + 1, score, path + (0,))\\n            bobArrow = aliceArrows[count] + 1                \\n            dfs(numArrow - bobArrow, count + 1, score + count, path + (bobArrow,))\\n\\n            # brute-force TLE/OOM\\n            # for j in range(numArrow+1):\\n            #     bobArrow = j\\n            #     dfs(numArrow - bobArrow, count + 1, score + (count if bobArrow > aliceArrows[count] else 0), path + (bobArrow,))\\n\\n            \\n        dfs(numArrows, 0, 0, tuple())\\n\\n        return max_path\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n        max_path = [0] * len(aliceArrows)\\n        max_score = 0\\n        \\n        @cache\\n        def dfs(numArrow, count, score, path):\\n            nonlocal max_score\\n\\n            if numArrow < 0: # invalid\\n                return\\n            \\n            if numArrow == 0 or count == len(aliceArrows): # no more arrows to use or finish\\n                if score > max_score:\\n                    max_score = score\\n                    for i in range(len(max_path)):\\n                        if i < len(path):\\n                            max_path[i] = path[i]\\n                        else:\\n                            max_path[i] = 0\\n                    max_path[0] = numArrows - sum(max_path[1:]) # balance the total arrows for two choices\\n                return\\n            \\n            # two choices\\n            dfs(numArrow, count + 1, score, path + (0,))\\n            bobArrow = aliceArrows[count] + 1                \\n            dfs(numArrow - bobArrow, count + 1, score + count, path + (bobArrow,))\\n\\n            # brute-force TLE/OOM\\n            # for j in range(numArrow+1):\\n            #     bobArrow = j\\n            #     dfs(numArrow - bobArrow, count + 1, score + (count if bobArrow > aliceArrows[count] else 0), path + (bobArrow,))\\n\\n            \\n        dfs(numArrows, 0, 0, tuple())\\n\\n        return max_path\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2041342,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bobArrows(12, 0);\\n        search(numArrows, aliceArrows, bobArrows, 0, 11);\\n\\n        return resultBobArrows;\\n    }\\n\\n    void search(int numArrows, vector<int>& aliceArrows, vector<int>& bobArrows, int points, int i) {\\n        if (numArrows < 0) return;\\n        \\n        int remainPoints=(i+1)*i/2;\\n        if(points+remainPoints<maxPoints) return;\\n\\n        if (i == 0 ) {\\n            if (points >= maxPoints) \\n            {\\n                maxPoints = points;\\n                \\n                bobArrows[0] = numArrows;\\n                resultBobArrows = bobArrows;\\n            }\\n            return;\\n        }\\n\\n        bobArrows[i] = aliceArrows[i] + 1;\\n        if (numArrows - aliceArrows[i] - 1 >= 0)\\n            search(numArrows - aliceArrows[i] - 1, aliceArrows, bobArrows, points + i, i - 1);\\n\\n        bobArrows[i] = 0;\\n        search(numArrows, aliceArrows, bobArrows, points, i - 1);\\n    }\\n\\nprivate:\\n    int maxPoints = 0;\\n    vector<int> resultBobArrows;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bobArrows(12, 0);\\n        search(numArrows, aliceArrows, bobArrows, 0, 11);\\n\\n        return resultBobArrows;\\n    }\\n\\n    void search(int numArrows, vector<int>& aliceArrows, vector<int>& bobArrows, int points, int i) {\\n        if (numArrows < 0) return;\\n        \\n        int remainPoints=(i+1)*i/2;\\n        if(points+remainPoints<maxPoints) return;\\n\\n        if (i == 0 ) {\\n            if (points >= maxPoints) \\n            {\\n                maxPoints = points;\\n                \\n                bobArrows[0] = numArrows;\\n                resultBobArrows = bobArrows;\\n            }\\n            return;\\n        }\\n\\n        bobArrows[i] = aliceArrows[i] + 1;\\n        if (numArrows - aliceArrows[i] - 1 >= 0)\\n            search(numArrows - aliceArrows[i] - 1, aliceArrows, bobArrows, points + i, i - 1);\\n\\n        bobArrows[i] = 0;\\n        search(numArrows, aliceArrows, bobArrows, points, i - 1);\\n    }\\n\\nprivate:\\n    int maxPoints = 0;\\n    vector<int> resultBobArrows;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009630,
                "title": "c-backtracking-easy-to-understand",
                "content": "\\n\\n```\\n        public int[] MaximumBobPoints(int numArrows, int[] aliceArrows)\\n        {\\n            int[] res=new int[aliceArrows.Length];\\n            int max = int.MinValue;\\n\\t\\t\\t//index=11 last index, due to higher index got higher score\\n            MaximumBobPoints_BackTracking(numArrows, aliceArrows, new int[aliceArrows.Length], aliceArrows.Length - 1, 0, ref max, ref res);\\n            return res;\\n        }\\n\\n        private void MaximumBobPoints_BackTracking(int numArrows, int[] aliceArrows, int[] bobArrows,int index,int total, ref int max, ref int[] res)\\n        {\\n            if (index == 0)\\n            {\\n\\t\\t\\t   //because index-0 has no score, so plus all arrows to index-0\\n                bobArrows[0] = numArrows;\\n                if (total > max)\\n                {\\n                    max = total;//if current score > max, update it\\n                    res = bobArrows;\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t    //skip current index\\n                MaximumBobPoints_BackTracking(numArrows, aliceArrows, bobArrows,index-1,total,ref max, ref res);\\n\\t\\t\\t\\t//if can got score on current index, just try it\\n                if(numArrows > aliceArrows[index])\\n                {\\n                    var nextArr = new int[bobArrows.Length];\\n                    Array.Copy(bobArrows, nextArr, nextArr.Length);\\n                    nextArr[index] = aliceArrows[index] + 1;\\n                    MaximumBobPoints_BackTracking(numArrows - aliceArrows[index] - 1, aliceArrows, nextArr, index - 1, total + index, ref max, ref res);\\n                }\\n            }\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int[] MaximumBobPoints(int numArrows, int[] aliceArrows)\\n        {\\n            int[] res=new int[aliceArrows.Length];\\n            int max = int.MinValue;\\n\\t\\t\\t//index=11 last index, due to higher index got higher score\\n            MaximumBobPoints_BackTracking(numArrows, aliceArrows, new int[aliceArrows.Length], aliceArrows.Length - 1, 0, ref max, ref res);\\n            return res;\\n        }\\n\\n        private void MaximumBobPoints_BackTracking(int numArrows, int[] aliceArrows, int[] bobArrows,int index,int total, ref int max, ref int[] res)\\n        {\\n            if (index == 0)\\n            {\\n\\t\\t\\t   //because index-0 has no score, so plus all arrows to index-0\\n                bobArrows[0] = numArrows;\\n                if (total > max)\\n                {\\n                    max = total;//if current score > max, update it\\n                    res = bobArrows;\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t    //skip current index\\n                MaximumBobPoints_BackTracking(numArrows, aliceArrows, bobArrows,index-1,total,ref max, ref res);\\n\\t\\t\\t\\t//if can got score on current index, just try it\\n                if(numArrows > aliceArrows[index])\\n                {\\n                    var nextArr = new int[bobArrows.Length];\\n                    Array.Copy(bobArrows, nextArr, nextArr.Length);\\n                    nextArr[index] = aliceArrows[index] + 1;\\n                    MaximumBobPoints_BackTracking(numArrows - aliceArrows[index] - 1, aliceArrows, nextArr, index - 1, total + index, ref max, ref res);\\n                }\\n            }\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992464,
                "title": "python3-bitmask-dp-backtrack",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n      bobArrows = [x+1 for x in aliceArrows]\\n      \\n      def genconfig(length):\\n        if length == 0: return [\\'\\']\\n        else:\\n          return [\\'1\\' + x for x in genconfig(length-1)] + \\\\\\n                 [\\'0\\' + x for x in genconfig(length-1)]\\n        \\n      configs = genconfig(11)\\n      \\n      score, res = -sys.maxsize, None\\n      for con in configs:\\n        arrow_needed = sum([bobArrows[x+1] for x in range(11) if con[x] == \\'1\\'])\\n        if arrow_needed <= numArrows:\\n          temp_score = sum([x+1 for x in range(11) if con[x] == \\'1\\'])\\n          if temp_score > score:\\n            score = temp_score\\n            res = [numArrows - arrow_needed] + [bobArrows[x+1] if con[x] == \\'1\\' else 0 for x in range(11)]\\n      return res\\n        \\n      \\n      #dp knapsack + backtrack\\n      #grid = [([[0, 0] for x in range(12)]) for _ in range(numArrows+1)]\\n      \\n      #aliceArrows = [x + 1 for x in aliceArrows]\\n\\n      #for t in range(1, 12):\\n      #  target = aliceArrows[t]\\n      #  for k in range(numArrows+1):\\n      #    if k >= target:\\n      #      if grid[k-target][t-1][0] + t >= grid[k][t-1][0]:\\n      #        grid[k][t][0] = grid[k-target][t-1][0] + t\\n      #        grid[k][t][1] = target\\n      #      else:\\n      #        grid[k][t][0] = grid[k][t-1][0]\\n      #    else:\\n      #      grid[k][t][0] = grid[k][t-1][0]\\n          \\n      #res = []\\n       \\n      #for t in range(11, 0, -1):\\n      #  score, choice = grid[numArrows][t]\\n      #  res.append(choice)\\n      #  numArrows -= choice\\n      #res.append(numArrows)\\n      \\n      #return res[::-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n      bobArrows = [x+1 for x in aliceArrows]\\n      \\n      def genconfig(length):\\n        if length == 0: return [\\'\\']\\n        else:\\n          return [\\'1\\' + x for x in genconfig(length-1)] + \\\\\\n                 [\\'0\\' + x for x in genconfig(length-1)]\\n        \\n      configs = genconfig(11)\\n      \\n      score, res = -sys.maxsize, None\\n      for con in configs:\\n        arrow_needed = sum([bobArrows[x+1] for x in range(11) if con[x] == \\'1\\'])\\n        if arrow_needed <= numArrows:\\n          temp_score = sum([x+1 for x in range(11) if con[x] == \\'1\\'])\\n          if temp_score > score:\\n            score = temp_score\\n            res = [numArrows - arrow_needed] + [bobArrows[x+1] if con[x] == \\'1\\' else 0 for x in range(11)]\\n      return res\\n        \\n      \\n      #dp knapsack + backtrack\\n      #grid = [([[0, 0] for x in range(12)]) for _ in range(numArrows+1)]\\n      \\n      #aliceArrows = [x + 1 for x in aliceArrows]\\n\\n      #for t in range(1, 12):\\n      #  target = aliceArrows[t]\\n      #  for k in range(numArrows+1):\\n      #    if k >= target:\\n      #      if grid[k-target][t-1][0] + t >= grid[k][t-1][0]:\\n      #        grid[k][t][0] = grid[k-target][t-1][0] + t\\n      #        grid[k][t][1] = target\\n      #      else:\\n      #        grid[k][t][0] = grid[k][t-1][0]\\n      #    else:\\n      #      grid[k][t][0] = grid[k][t-1][0]\\n          \\n      #res = []\\n       \\n      #for t in range(11, 0, -1):\\n      #  score, choice = grid[numArrows][t]\\n      #  res.append(choice)\\n      #  numArrows -= choice\\n      #res.append(numArrows)\\n      \\n      #return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974966,
                "title": "python3-dfs-simple",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.mx=0\\n        self.res=[]\\n\\n        def helper(idx,arr,total,left):\\n            if left==0 or idx==-1:\\n                if total>self.mx:\\n                    self.mx=total\\n                    self.res=arr+[0 for _ in range(12-len(arr))]\\n                    self.res[-1]+=left\\n                return\\n            helper(idx-1,arr+[0],total,left)\\n            if left>=aliceArrows[idx]+1:\\n                helper(idx-1,arr+[aliceArrows[idx]+1],total+idx,left-aliceArrows[idx]-1)\\n        \\n        helper(11,[],0,numArrows)\\n        return self.res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.mx=0\\n        self.res=[]\\n\\n        def helper(idx,arr,total,left):\\n            if left==0 or idx==-1:\\n                if total>self.mx:\\n                    self.mx=total\\n                    self.res=arr+[0 for _ in range(12-len(arr))]\\n                    self.res[-1]+=left\\n                return\\n            helper(idx-1,arr+[0],total,left)\\n            if left>=aliceArrows[idx]+1:\\n                helper(idx-1,arr+[aliceArrows[idx]+1],total+idx,left-aliceArrows[idx]-1)\\n        \\n        helper(11,[],0,numArrows)\\n        return self.res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971289,
                "title": "python-constant-time-solution-by-keeping-track-of-minimum-arrows-needed-for-each-score",
                "content": "maxs[i] is minimum number of arrows to get score i given aliceArrows\\ncomp[i] is the composition of score ranges to get max score.\\nInitialize the arrays for score range 1 and 2,\\nBuild the arrays up from score range 3 to 11.\\n\\n```\\nclass Solution(object):\\n    def maximumBobPoints(self, numArrows, aliceArrows):\\n        \"\"\"\\n        :type numArrows: int\\n        :type aliceArrows: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        maxs=[0]*67\\n        maxs[1]=aliceArrows[1]+1\\n        maxs[2]=aliceArrows[2]+1\\n        maxs[3]=maxs[1]+maxs[2]\\n        comp=[[] for _ in range(67)]\\n        comp[1]=[1]\\n        comp[2]=[2]\\n        comp[3]=[1,2]\\n        upper=3\\n        for i in range(3,12):\\n            for j in range(upper,upper-i,-1):\\n                maxs[i+j]=maxs[j]+aliceArrows[i]+1\\n                comp[i+j] = comp[j]+[i]\\n            for j in range(upper,i-1,-1):\\n                if maxs[j]>maxs[j-i]+aliceArrows[i]+1:\\n                    maxs[j]=maxs[j-i]+aliceArrows[i]+1\\n                    comp[j] = comp[j-i]+[i]\\n            upper += i\\n        for i in range(66,-1,-1):\\n            if numArrows>=maxs[i]:\\n                # print(i, comp[i])\\n                res=[0]*12\\n                for j in comp[i]:\\n                    res[j]=aliceArrows[j]+1\\n                res[0]=numArrows-sum(res)\\n                return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maximumBobPoints(self, numArrows, aliceArrows):\\n        \"\"\"\\n        :type numArrows: int\\n        :type aliceArrows: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        maxs=[0]*67\\n        maxs[1]=aliceArrows[1]+1\\n        maxs[2]=aliceArrows[2]+1\\n        maxs[3]=maxs[1]+maxs[2]\\n        comp=[[] for _ in range(67)]\\n        comp[1]=[1]\\n        comp[2]=[2]\\n        comp[3]=[1,2]\\n        upper=3\\n        for i in range(3,12):\\n            for j in range(upper,upper-i,-1):\\n                maxs[i+j]=maxs[j]+aliceArrows[i]+1\\n                comp[i+j] = comp[j]+[i]\\n            for j in range(upper,i-1,-1):\\n                if maxs[j]>maxs[j-i]+aliceArrows[i]+1:\\n                    maxs[j]=maxs[j-i]+aliceArrows[i]+1\\n                    comp[j] = comp[j-i]+[i]\\n            upper += i\\n        for i in range(66,-1,-1):\\n            if numArrows>=maxs[i]:\\n                # print(i, comp[i])\\n                res=[0]*12\\n                for j in comp[i]:\\n                    res[j]=aliceArrows[j]+1\\n                res[0]=numArrows-sum(res)\\n                return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1832173,
                "content": [
                    {
                        "username": "prafullpandey2801",
                        "content": "If you are failing this testcase \\n `89\\n[3,2,28,1,7,1,16,7,3,13,3,5]`\\nthen make sure that you are using all the arrows if number of Arrows used by BOB are less than Alice then put the difference of the arrows on the 0th target of BOB `if(arr<numArrows){\\n            ans[0] = numArrows-arr ;\\n        }`"
                    },
                    {
                        "username": "truncate",
                        "content": "Seems like the judge is not doing the right thing with solution. Eg, for `89, [3,2,28,1,7,1,16,7,3,13,3,5]` my solution has output `[4,3,0,2,8,2,17,8,4,14,4,6]` while it shows `[21,3,0,2,8,2,17,8,4,14,4,6]` as correct. 4 and 21 arrows, either way will result in 0 score , and there is no where it says that all arrow must be used.\\n\\nOr, the description should mention that all arrows must be used.\\n"
                    },
                    {
                        "username": "keshav-banka",
                        "content": "It is given in the second last paragraaph last line. \\nThe sum of the values in bobArrows should equal numArrows"
                    },
                    {
                        "username": "fmodesto",
                        "content": "Right at the end: \"The sum of the values in bobArrows should equal numArrows\"."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "This doesn\\'t look like a medium."
                    }
                ]
            },
            {
                "id": 1793888,
                "content": [
                    {
                        "username": "prafullpandey2801",
                        "content": "If you are failing this testcase \\n `89\\n[3,2,28,1,7,1,16,7,3,13,3,5]`\\nthen make sure that you are using all the arrows if number of Arrows used by BOB are less than Alice then put the difference of the arrows on the 0th target of BOB `if(arr<numArrows){\\n            ans[0] = numArrows-arr ;\\n        }`"
                    },
                    {
                        "username": "truncate",
                        "content": "Seems like the judge is not doing the right thing with solution. Eg, for `89, [3,2,28,1,7,1,16,7,3,13,3,5]` my solution has output `[4,3,0,2,8,2,17,8,4,14,4,6]` while it shows `[21,3,0,2,8,2,17,8,4,14,4,6]` as correct. 4 and 21 arrows, either way will result in 0 score , and there is no where it says that all arrow must be used.\\n\\nOr, the description should mention that all arrows must be used.\\n"
                    },
                    {
                        "username": "keshav-banka",
                        "content": "It is given in the second last paragraaph last line. \\nThe sum of the values in bobArrows should equal numArrows"
                    },
                    {
                        "username": "fmodesto",
                        "content": "Right at the end: \"The sum of the values in bobArrows should equal numArrows\"."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "This doesn\\'t look like a medium."
                    }
                ]
            },
            {
                "id": 1974098,
                "content": [
                    {
                        "username": "prafullpandey2801",
                        "content": "If you are failing this testcase \\n `89\\n[3,2,28,1,7,1,16,7,3,13,3,5]`\\nthen make sure that you are using all the arrows if number of Arrows used by BOB are less than Alice then put the difference of the arrows on the 0th target of BOB `if(arr<numArrows){\\n            ans[0] = numArrows-arr ;\\n        }`"
                    },
                    {
                        "username": "truncate",
                        "content": "Seems like the judge is not doing the right thing with solution. Eg, for `89, [3,2,28,1,7,1,16,7,3,13,3,5]` my solution has output `[4,3,0,2,8,2,17,8,4,14,4,6]` while it shows `[21,3,0,2,8,2,17,8,4,14,4,6]` as correct. 4 and 21 arrows, either way will result in 0 score , and there is no where it says that all arrow must be used.\\n\\nOr, the description should mention that all arrows must be used.\\n"
                    },
                    {
                        "username": "keshav-banka",
                        "content": "It is given in the second last paragraaph last line. \\nThe sum of the values in bobArrows should equal numArrows"
                    },
                    {
                        "username": "fmodesto",
                        "content": "Right at the end: \"The sum of the values in bobArrows should equal numArrows\"."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "This doesn\\'t look like a medium."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways to Select Buildings",
        "question_content": "<p>You are given a <strong>0-indexed</strong> binary string <code>s</code> which represents the types of buildings along a street where:</p>\n\n<ul>\n\t<li><code>s[i] = &#39;0&#39;</code> denotes that the <code>i<sup>th</sup></code> building is an office and</li>\n\t<li><code>s[i] = &#39;1&#39;</code> denotes that the <code>i<sup>th</sup></code> building is a restaurant.</li>\n</ul>\n\n<p>As a city official, you would like to <strong>select</strong> 3 buildings for random inspection. However, to ensure variety, <strong>no two consecutive</strong> buildings out of the <strong>selected</strong> buildings can be of the same type.</p>\n\n<ul>\n\t<li>For example, given <code>s = &quot;0<u><strong>0</strong></u>1<u><strong>1</strong></u>0<u><strong>1</strong></u>&quot;</code>, we cannot select the <code>1<sup>st</sup></code>, <code>3<sup>rd</sup></code>, and <code>5<sup>th</sup></code> buildings as that would form <code>&quot;0<strong><u>11</u></strong>&quot;</code> which is <strong>not</strong> allowed due to having two consecutive buildings of the same type.</li>\n</ul>\n\n<p>Return <em>the <b>number of valid ways</b> to select 3 buildings.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;001101&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \nThe following sets of indices selected are valid:\n- [0,2,4] from &quot;<u><strong>0</strong></u>0<strong><u>1</u></strong>1<strong><u>0</u></strong>1&quot; forms &quot;010&quot;\n- [0,3,4] from &quot;<u><strong>0</strong></u>01<u><strong>10</strong></u>1&quot; forms &quot;010&quot;\n- [1,2,4] from &quot;0<u><strong>01</strong></u>1<u><strong>0</strong></u>1&quot; forms &quot;010&quot;\n- [1,3,4] from &quot;0<u><strong>0</strong></u>1<u><strong>10</strong></u>1&quot; forms &quot;010&quot;\n- [2,4,5] from &quot;00<u><strong>1</strong></u>1<u><strong>01</strong></u>&quot; forms &quot;101&quot;\n- [3,4,5] from &quot;001<u><strong>101</strong></u>&quot; forms &quot;101&quot;\nNo other selection is valid. Thus, there are 6 total ways.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;11100&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> It can be shown that there are no valid selections.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1907026,
                "title": "easy-understanding-c-code-with-comments",
                "content": "The possible sequences of selected buildings is either \"101\" or \"010\".\\n\\nIf the current building is \\'0\\', then the number of sequences of pattern \"101\" will be the product of the number of occurances of building \\'1\\' before the current building to the number of occurances of building \\'1\\' after the current building and viceversa.\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long a=0,b=0,ans=0;        // a and b are the number of occurances of \\'1\\' and \\'0\\' after the current building respectively.\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\')\\n                a++;\\n            else\\n                b++;\\n        }\\n        long long c=0,d=0;              // c and d are the number of occurances of \\'1\\' and \\'0\\' before the current building respectively.\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){               // Counting the sequences of \"010\"\\n                ans+=(d*b);\\n                a--;\\n                c++;\\n            }\\n            else{                        // Counting the sequences of \"101\"\\n                ans+=(a*c);\\n                b--;\\n                d++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nComplexity\\nTime - O(n)\\nSpace - O(1)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long a=0,b=0,ans=0;        // a and b are the number of occurances of \\'1\\' and \\'0\\' after the current building respectively.\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\')\\n                a++;\\n            else\\n                b++;\\n        }\\n        long long c=0,d=0;              // c and d are the number of occurances of \\'1\\' and \\'0\\' before the current building respectively.\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){               // Counting the sequences of \"010\"\\n                ans+=(d*b);\\n                a--;\\n                c++;\\n            }\\n            else{                        // Counting the sequences of \"101\"\\n                ans+=(a*c);\\n                b--;\\n                d++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906984,
                "title": "easy-to-understand-with-detailed-explanation-and-java-code",
                "content": "***Please upvote if you find this helpful :)***\\n\\nThe only valid combinations possible are 101 and 010.\\nSo, lets traverse the string and consider the current character as the centeral character of the combination. \\n\\nThis means, if the current character is \\'0\\', then all we need to do it find the number of 1 before this 0 and number of 1 after this 0 and multiply them to add them to the answer.\\nWe do the same for the central character as \\'1\\' and count the number of 0 before and after this one.\\n\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans = 0;\\n        int len = s.length();\\n        \\n        long totZeros = 0;\\n        \\n        for(int i=0;i<len;i++){\\n            totZeros += s.charAt(i)==\\'0\\'?1:0;\\n        }\\n        \\n        long totOnes = len - totZeros;\\n        \\n        long currZeros = s.charAt(0)==\\'0\\'?1:0;\\n        long currOnes = s.charAt(0)==\\'1\\'?1:0;\\n        \\n        for(int i=1;i<len;i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                ans = ans + (currOnes * (totOnes-currOnes));\\n                currZeros++;\\n            }else{\\n                ans = ans + (currZeros * (totZeros-currZeros));\\n                currOnes++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans = 0;\\n        int len = s.length();\\n        \\n        long totZeros = 0;\\n        \\n        for(int i=0;i<len;i++){\\n            totZeros += s.charAt(i)==\\'0\\'?1:0;\\n        }\\n        \\n        long totOnes = len - totZeros;\\n        \\n        long currZeros = s.charAt(0)==\\'0\\'?1:0;\\n        long currOnes = s.charAt(0)==\\'1\\'?1:0;\\n        \\n        for(int i=1;i<len;i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                ans = ans + (currOnes * (totOnes-currOnes));\\n                currZeros++;\\n            }else{\\n                ans = ans + (currZeros * (totZeros-currZeros));\\n                currOnes++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907109,
                "title": "python-dp-easy-to-understand",
                "content": "**Explanation:**\\nWhen you meet a \"0\", you can possibly form \"0\", \"10\", \"010\" ending with a \"0\".\\nWhen you meet a \"1\", you can possibly form \"1\", \"01\", \"101\" ending with a \"1\".\\nUpdate the number of possible combinations when you traverse s.\\n\\n<iframe src=\"https://leetcode.com/playground/NtKfXT7z/shared\" frameBorder=\"0\" width=\"1100\" height=\"400\"></iframe>",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "**Explanation:**\\nWhen you meet a \"0\", you can possibly form \"0\", \"10\", \"010\" ending with a \"0\".\\nWhen you meet a \"1\", you can possibly form \"1\", \"01\", \"101\" ending with a \"1\".\\nUpdate the number of possible combinations when you traverse s.\\n\\n<iframe src=\"https://leetcode.com/playground/NtKfXT7z/shared\" frameBorder=\"0\" width=\"1100\" height=\"400\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1907179,
                "title": "java-python-3-one-pass-s-o-1-t-o-n-codes-and-follow-up-w-brief-explanation-and-analysis",
                "content": "Traverse the input `s`:\\n1. If encontering `0`, count subsequences ending at current `0`: `0`, `10` and `010`\\'s; The number of `10` depends on how many `1`s before current `0`, and the number of `010` depends on how many `01` before current `0`;\\n\\nSimilarly, \\n\\n2. If encontering `1`, count subsequences ending at current `1`:  `1`, `01` and `101`\\'s; The number of `01` depends on how many `0`s before current `1`, and the number of `101` depends on how many `10` before current `1`.\\n\\n```java\\n    public long numberOfWays(String s) {\\n        long one = 0, zero = 0, oneZero = 0, zeroOne = 0, ways = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'0\\') {\\n                ++zero;\\n                oneZero += one; // Count in \\'10\\'.\\n                ways += zeroOne; // Count in \\'010\\'.\\n            }else {\\n                ++one;\\n                zeroOne += zero; // Count in \\'01\\'.\\n                ways += oneZero; // Count in \\'101\\'.\\n            }\\n        }\\n        return ways;\\n    }\\n```\\n```python\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        one = zero = zero_one = one_zero = 0\\n        for c in s:\\n            if c == \\'0\\':\\n                zero += 1\\n                one_zero += one\\n                ways += zero_one\\n            else:\\n                one += 1    \\n                zero_one += zero \\n                ways += one_zero\\n        return ways\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = s.length()`.\\n\\n----\\n\\n**Follow-up**\\nWhat if the city official would like to select `k`, instead of `3`, buildings?\\n\\n~~~If **the upvotes can reach `25`**, I  will provide time `O(k * n)` space `O(k)` code for the follow-up.~~~\\n\\nTraverse the input `s`:\\n1. If encontering `0`, count subsequences ending at current `0`:  `0`, `10` and `010`, `1010`\\'s, ...,; The number of `10` depends on how many `1`s before current `0`, the number of `010` depends on how many `01` before current `0`, and the number of `1010` depends on how many `101` before current `0`...;\\n\\nSimilarly,\\n\\n2. If encontering `1`, count subsequences ending at current `1`:  `1`, `01`, `101`, and `0101`\\'s; The number of `01` depends on how many `0`s before current `1`, the number of `101` depends on how many `10` before current `1`, and the number of `0101` depends on how many `010` before current `1`...\\n3. We can observe the above patterns and use a 2-D array `ways` to record the corresponding subsequences, e.g., \\n \\n\\t ways[0][0] - number of `0`\\'s;\\n\\t ways[1][0] - number of `10`\\'s;\\n\\t ways[2][0] - number of `010`\\'s;\\n\\t ways[3][0] - number of `1010`\\'s;\\n\\t ...\\n\\t ways[0][1] - number of `1`\\'s;\\n\\t ways[1][1] - number of `01`\\'s;\\n\\t ways[2][1] - number of `101`\\'s;\\n\\t ways[3][1] - number of `0101`\\'s;\\n\\t ...\\n\\t \\n```java\\n    public long numberOfWays(String s, int k) {\\n     // int k = 3;\\n        long[][] ways = new long[k][2]; \\n        for (int i = 0; i < s.length(); ++i) {\\n            int idx = s.charAt(i) - \\'0\\';\\n            ++ways[0][idx];\\n            for (int j = 1; j < k; ++j) {\\n                ways[j][idx] += ways[j - 1][1 - idx];\\n            }\\n        }\\n        return ways[k - 1][0] + ways[k - 1][1];\\n    }\\n```\\n```python\\n    def numberOfWays(self, s: str, k: int) -> int:\\n      # k = 3\\n        ways = [[0, 0] for _ in range(k)]\\n        for c in s:\\n            idx = ord(c) - ord(\\'0\\')\\n            ways[0][idx] += 1\\n            for i in range(1, k):\\n                ways[i][idx] += ways[i - 1][1 - idx]\\n        return sum(ways[-1])\\n```\\n**Analysis:**\\n\\nTime: `O(k * n)`, space: `O(k)`, where `n = s.length()`.\\n\\n**Do let me know** if you have an algorithm better than `O(k * n)` time or `O(k)` space for the follow-up.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long numberOfWays(String s) {\\n        long one = 0, zero = 0, oneZero = 0, zeroOne = 0, ways = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'0\\') {\\n                ++zero;\\n                oneZero += one; // Count in \\'10\\'.\\n                ways += zeroOne; // Count in \\'010\\'.\\n            }else {\\n                ++one;\\n                zeroOne += zero; // Count in \\'01\\'.\\n                ways += oneZero; // Count in \\'101\\'.\\n            }\\n        }\\n        return ways;\\n    }\\n```\n```python\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        one = zero = zero_one = one_zero = 0\\n        for c in s:\\n            if c == \\'0\\':\\n                zero += 1\\n                one_zero += one\\n                ways += zero_one\\n            else:\\n                one += 1    \\n                zero_one += zero \\n                ways += one_zero\\n        return ways\\n```\n```java\\n    public long numberOfWays(String s, int k) {\\n     // int k = 3;\\n        long[][] ways = new long[k][2]; \\n        for (int i = 0; i < s.length(); ++i) {\\n            int idx = s.charAt(i) - \\'0\\';\\n            ++ways[0][idx];\\n            for (int j = 1; j < k; ++j) {\\n                ways[j][idx] += ways[j - 1][1 - idx];\\n            }\\n        }\\n        return ways[k - 1][0] + ways[k - 1][1];\\n    }\\n```\n```python\\n    def numberOfWays(self, s: str, k: int) -> int:\\n      # k = 3\\n        ways = [[0, 0] for _ in range(k)]\\n        for c in s:\\n            idx = ord(c) - ord(\\'0\\')\\n            ways[0][idx] += 1\\n            for i in range(1, k):\\n                ways[i][idx] += ways[i - 1][1 - idx]\\n        return sum(ways[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1907123,
                "title": "c-short-dp-o-n-time-o-1-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. DP\\n\\nLet `dp[len][c]` be the count of alternating subsequences of length `len` ending with character `\\'0\\' + c\\'`. The answer is `dp[3][0] + dp[3][1]`.\\n\\nWe can scan the array from left to right and compute these `dp[len][c]` values.\\n\\nFor each `dp[len][c]`, its count should increase by `dp[len - 1][1 - c]`, i.e. prepending subsequences of length `len - 1` ending with a different character.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-select-buildings/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long dp[4][2] = {};\\n        dp[0][0] = dp[0][1] = 1;\\n        for (int i = 0; i < s.size(); ++i) {\\n            for (int len = 1; len <= 3; ++len) {\\n                dp[len][s[i] - \\'0\\'] += dp[len - 1][1 - (s[i] - \\'0\\')];\\n            }\\n        }\\n        return dp[3][0] + dp[3][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-select-buildings/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long dp[4][2] = {};\\n        dp[0][0] = dp[0][1] = 1;\\n        for (int i = 0; i < s.size(); ++i) {\\n            for (int len = 1; len <= 3; ++len) {\\n                dp[len][s[i] - \\'0\\'] += dp[len - 1][1 - (s[i] - \\'0\\')];\\n            }\\n        }\\n        return dp[3][0] + dp[3][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907002,
                "title": "010-or-101-java-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\n    public long numberOfWays(String s)\\n    {\\n        int zero = 0; // Individual zeroes count\\n        long zeroOne = 0; // Number of combinations of 01s\\n        int one = 0; // Individual ones count\\n        long oneZero = 0; // Number of combinations of 10s\\n        long tot = 0; // Final answer\\n        for(char ch : s.toCharArray())\\n        {\\n            if(ch == \\'0\\')\\n            {\\n                zero++;\\n                oneZero += one; // Each of the previously found 1s can pair up with the current 0 to form 10\\n                tot += zeroOne; // Each of the previously formed 01 can form a triplet with the current 0 to form 010\\n            }\\n            else\\n            {\\n                one++;\\n                zeroOne += zero; // Each of the previously found 0s can pair to form 01\\n                tot += oneZero; // Each of the previously formed 10 can form 101\\n            }\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public long numberOfWays(String s)\\n    {\\n        int zero = 0; // Individual zeroes count\\n        long zeroOne = 0; // Number of combinations of 01s\\n        int one = 0; // Individual ones count\\n        long oneZero = 0; // Number of combinations of 10s\\n        long tot = 0; // Final answer\\n        for(char ch : s.toCharArray())\\n        {\\n            if(ch == \\'0\\')\\n            {\\n                zero++;\\n                oneZero += one; // Each of the previously found 1s can pair up with the current 0 to form 10\\n                tot += zeroOne; // Each of the previously formed 01 can form a triplet with the current 0 to form 010\\n            }\\n            else\\n            {\\n                one++;\\n                zeroOne += zero; // Each of the previously found 0s can pair to form 01\\n                tot += oneZero; // Each of the previously formed 10 can form 101\\n            }\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907312,
                "title": "easy-to-understand-c-code",
                "content": "Step1.  Count total number if zeros and ones in string. (count0 and count1)\\nStep2.  Iterate the string from left and keep count of zeroes and ones in till current index.(cur0 and cur1)\\nStep3.  There is only two case is possible 101 and 010. \\n\\tIf you encounter 1 then check for case 010\\n\\tAdd total no of combinations of 010 formed by taking currrent 1 as centre i.e\\n\\t\\t= (total no of 0s on left) * (total no of 0s on right) = cur0 * (count0-cur0)\\n\\tIf you encounter 0 then check for case 101\\n\\tAdd total no of combinations of 101 formed by taking currrent 0 as centre i.e\\n\\t\\t= (total no of 1s on left) * (total no of 1s on right) = cur1 * (count1-cur1)\\t\\n\\t\\treturn final ans.\\t\\n\\n\\n\\n` long long numberOfWays(string s) {`\\n        \\n        int count0=0, count1=0;\\n        for(int i=0;i<s.size();i++)\\n\\t\\t{\\n            if(s[i]==\\'0\\')\\n                count0++;\\n            else\\n                count1++;\\n        }\\n        long long int ans=0;\\n        int cur0=0,cur1=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                cur1++;\\n                ans+=cur0*(count0-cur0);\\n            }\\n            else\\n            {\\n                cur0++;\\n                ans+=cur1*(count1-cur1);\\n            }\\n        }\\n        return ans;\\n        \\n      \\n        \\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "Step1.  Count total number if zeros and ones in string. (count0 and count1)\\nStep2.  Iterate the string from left and keep count of zeroes and ones in till current index.(cur0 and cur1)\\nStep3.  There is only two case is possible 101 and 010. \\n\\tIf you encounter 1 then check for case 010\\n\\tAdd total no of combinations of 010 formed by taking currrent 1 as centre i.e\\n\\t\\t= (total no of 0s on left) * (total no of 0s on right) = cur0 * (count0-cur0)\\n\\tIf you encounter 0 then check for case 101\\n\\tAdd total no of combinations of 101 formed by taking currrent 0 as centre i.e\\n\\t\\t= (total no of 1s on left) * (total no of 1s on right) = cur1 * (count1-cur1)\\t\\n\\t\\treturn final ans.\\t\\n\\n\\n\\n` long long numberOfWays(string s) {`\\n        \\n        int count0=0, count1=0;\\n        for(int i=0;i<s.size();i++)\\n\\t\\t{\\n            if(s[i]==\\'0\\')\\n                count0++;\\n            else\\n                count1++;\\n        }\\n        long long int ans=0;\\n        int cur0=0,cur1=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                cur1++;\\n                ans+=cur0*(count0-cur0);\\n            }\\n            else\\n            {\\n                cur0++;\\n                ans+=cur1*(count1-cur1);\\n            }\\n        }\\n        return ans;\\n        \\n      \\n        \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1907308,
                "title": "python-one-pass-method-o-n",
                "content": "In overall, they are only looking for \\'101\\' and \\'010\\'.\\nWe keep track of previous \\'0\\' and \\'1\\' using variable \\'z\\' and \\'o\\'.\\nWhen entering the next building, the previous \\'0\\' and \\'1\\' can be upgraded into \\'01\\' and \\'10\\' respectively as variable \\'oz\\' and \\'zo\\'.\\nAgain, from the previous \\'01\\' and \\'10\\', we can upgrade them into \\'010\\' and \\'101\\' and put them both into variable \\'total\\', which will be the total valid ways to select 3 buildings.\\n```\\ndef sumScores(self, s):\\n\\t# Idea 1: count 0, 1, 01, 10\\n        z, o, zo, oz, total = 0, 0, 0, 0, 0\\n        for c in s:\\n            if c == \\'1\\':\\n                total += oz\\n                zo += z\\n                o += 1\\n            elif c == \\'0\\':\\n                total += zo\\n                oz += o\\n                z += 1\\n        return total\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "In overall, they are only looking for \\'101\\' and \\'010\\'.\\nWe keep track of previous \\'0\\' and \\'1\\' using variable \\'z\\' and \\'o\\'.\\nWhen entering the next building, the previous \\'0\\' and \\'1\\' can be upgraded into \\'01\\' and \\'10\\' respectively as variable \\'oz\\' and \\'zo\\'.\\nAgain, from the previous \\'01\\' and \\'10\\', we can upgrade them into \\'010\\' and \\'101\\' and put them both into variable \\'total\\', which will be the total valid ways to select 3 buildings.\\n```\\ndef sumScores(self, s):\\n\\t# Idea 1: count 0, 1, 01, 10\\n        z, o, zo, oz, total = 0, 0, 0, 0, 0\\n        for c in s:\\n            if c == \\'1\\':\\n                total += oz\\n                zo += z\\n                o += 1\\n            elif c == \\'0\\':\\n                total += zo\\n                oz += o\\n                z += 1\\n        return total\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1907233,
                "title": "idea-explained-dp-memoization-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is similar to that of **Knapsack Problem**.\\n* We have two choices for each building. \\n\\t* Either *pick it*\\n\\t* Or *skip it*\\n* Using this way, we can move across given string and get count. And when length of selected string exceeds 3, simply return from there.\\n* Just here we need to track previous element, so that we do not end up picking same type of buildings.\\n* Thus, we have total three state and dp will look like :\\n\\t* `idx` : current index\\n\\t* `prev` : previous chosen building\\n\\t* `len` : length/number of buildings picked.\\n* Base condition is when we either have picked 3 buildings, or else we have reached end of string.\\n\\nNote : We are assuming that if no building is picked, then `prev = 2`.\\n# Code :\\n```\\nclass Solution {\\nprivate: \\n\\tlong long dp[100003][3][4];\\n\\n    long long solve(string& s, int idx, int prev, int len, int n) {\\n        if(len == 3) return 1;\\n        if(idx == n) {\\n            return 0;\\n        }\\n        if(dp[idx][prev][len] != -1) return dp[idx][prev][len];\\n\\n        long long res = solve(s, idx+1, prev, len, n);\\n\\n        if(prev != (s[idx]-\\'0\\')) {\\n            res += solve(s, idx+1, s[idx]-\\'0\\', len+1, n);\\n        }\\n        return dp[idx][prev][len] = res;\\n    }\\n\\npublic:    \\n    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 2, 0, n);\\n    }\\n};\\n```\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n\\tlong long dp[100003][3][4];\\n\\n    long long solve(string& s, int idx, int prev, int len, int n) {\\n        if(len == 3) return 1;\\n        if(idx == n) {\\n            return 0;\\n        }\\n        if(dp[idx][prev][len] != -1) return dp[idx][prev][len];\\n\\n        long long res = solve(s, idx+1, prev, len, n);\\n\\n        if(prev != (s[idx]-\\'0\\')) {\\n            res += solve(s, idx+1, s[idx]-\\'0\\', len+1, n);\\n        }\\n        return dp[idx][prev][len] = res;\\n    }\\n\\npublic:    \\n    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 2, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209681,
                "title": "java-o-n-dp-prefix-sums-solution",
                "content": "There are only 2 Types of Buildings valid for Selection: -> 101 & 010 since these represent an Alternate Subsequence of buildings.\\nBut to build up to either of these building Types, we need to Build up on a smaller Subsequence Building.\\nFor 101 we need 10, & for 10 we need buildings of type 1.\\nLikewise, for 010 we need 01 & for 01 we need buildings of type 0.\\n\\nIf current char == \\'0\\', we do the following,\\nincrease type 0 building, following which increase 10 type which depends on 1s & then increase 010 which depends on 01 type of buildings previously.\\nLikewise we do it for other 3 set of Subsequences.\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long n0 = 0, n1 = 0, n01 = 0, n10 = 0, n010 = 0, n101 = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c == \\'0\\')\\n            {\\n                n0++;\\n                n10 += n1;\\n                n010 += n01;\\n            }\\n            else\\n            {\\n                n1++;\\n                n01 += n0;\\n                n101 += n10;\\n            }\\n        }\\n        \\n        return n101 + n010;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long n0 = 0, n1 = 0, n01 = 0, n10 = 0, n010 = 0, n101 = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c == \\'0\\')\\n            {\\n                n0++;\\n                n10 += n1;\\n                n010 += n01;\\n            }\\n            else\\n            {\\n                n1++;\\n                n01 += n0;\\n                n101 += n10;\\n            }\\n        }\\n        \\n        return n101 + n010;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907344,
                "title": "simple-for-loop-java-o-n",
                "content": "we have only two types of string 101 or 010\\n1. **101** - > 0 is middle , for this 0  find count of 1 in left and 1 in right\\n2. **010** - > 1 is middle ,  for this 1  find count of 0 in left and 0 in right\\n \\n \\n \\n ----\\n **created left and right array**\\n \\n **for each index  i**\\n **if ith index is \\'1\\' store count of 0 in left in 0 in right**\\n **if ith index is \\'0\\' store count of 1 in left in 1 in right**\\n \\n for using ith element as middle we have left[i]*right[i] total strng\\n > one loop to fill left i=0 to n-1\\n > and one loop to fill right  i= n-1 to 0\\n \\n\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long count0 = 0 , count1 = 0;\\n        int n  =  s.length();\\n        long left[] =  new long[n];\\n        long right[] =  new long[n];\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'1\\' ){\\n                count1++;\\n                left[i] =  count0;\\n            }\\n            if(s.charAt(i)==\\'0\\' ){\\n                count0++;\\n                left[i] =  count1;\\n            }            \\n        }\\n        \\n        count1 = 0;\\n        count0 = 0;\\n        for(int i =  n-1 ;i>=0;i--){\\n            if(s.charAt(i)==\\'1\\' ){\\n                count1++;\\n                right[i] =  count0;\\n            }\\n            if(s.charAt(i)==\\'0\\' ){\\n                count0++;\\n                right[i] =  count1;\\n            }                        \\n        }\\n        \\n        long ways = 0;\\n        for(int i=0;i<n;i++){\\n            char chi = s.charAt(i);\\n            ways +=  left[i]*right[i];\\n        }\\n\\n        return ways;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long count0 = 0 , count1 = 0;\\n        int n  =  s.length();\\n        long left[] =  new long[n];\\n        long right[] =  new long[n];\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'1\\' ){\\n                count1++;\\n                left[i] =  count0;\\n            }\\n            if(s.charAt(i)==\\'0\\' ){\\n                count0++;\\n                left[i] =  count1;\\n            }            \\n        }\\n        \\n        count1 = 0;\\n        count0 = 0;\\n        for(int i =  n-1 ;i>=0;i--){\\n            if(s.charAt(i)==\\'1\\' ){\\n                count1++;\\n                right[i] =  count0;\\n            }\\n            if(s.charAt(i)==\\'0\\' ){\\n                count0++;\\n                right[i] =  count1;\\n            }                        \\n        }\\n        \\n        long ways = 0;\\n        for(int i=0;i<n;i++){\\n            char chi = s.charAt(i);\\n            ways +=  left[i]*right[i];\\n        }\\n\\n        return ways;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911594,
                "title": "dp",
                "content": "We need to compute ways to pick `101` and `010` combinations of buildings. We can compute those ways independently.\\n\\nSay we want to count `010`. It\\'s best to look at the specific test case, `\"000110010\"`:\\n\\n- `s[5]`: `first == 3`, `second == 2`.\\n\\t- `s[5]` forms 3 * 2 new combinations. We add it to `comb`.\\n\\t- `s[5]` adds `comb` (6) combinations to the result (6).\\n\\t- We reset `second` to zero.\\n- `s[6]`: `first == 4`, `second == 0`.\\n\\t- `s[6]` does not form any new combinations (`second == 0`).\\n\\t- `s[6]` adds `comb` (6) combinations to the result (12).\\n- `s[8]`: `first == 5`, `second == 1`.\\n\\t- `s[5]` forms 5 * 1 new combinations. We add it to `comb` (11).\\n\\t- `s[5]` adds `comb` (11) combinations to the result (23).\\n\\nSimilarly, we count the number of `101` combinations, which is 4. The final result is 27.\\n\\n**C++**\\n```cpp\\nlong long numberOfWays(string &s, char firstLast) {\\n    long long first = 0, second = 0, comb = 0, res = 0;\\n    for (char ch : s)\\n        if (ch == firstLast) {\\n            comb += first * second;\\n            res += comb;\\n            second = 0;\\n            ++first;\\n        }\\n        else\\n            ++second;\\n    return res;\\n}\\nlong long numberOfWays(string s) {\\n    return numberOfWays(s, \\'0\\') + numberOfWays(s, \\'1\\');\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long numberOfWays(string &s, char firstLast) {\\n    long long first = 0, second = 0, comb = 0, res = 0;\\n    for (char ch : s)\\n        if (ch == firstLast) {\\n            comb += first * second;\\n            res += comb;\\n            second = 0;\\n            ++first;\\n        }\\n        else\\n            ++second;\\n    return res;\\n}\\nlong long numberOfWays(string s) {\\n    return numberOfWays(s, \\'0\\') + numberOfWays(s, \\'1\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906960,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        temp = []\\n        c0 = 0\\n        c1 = 0\\n        for char in s :\\n            if char == \"0\" :\\n                c0+=1\\n            else:\\n                c1+=1\\n            temp.append([c0,c1])\\n            \\n        total0 = c0\\n        total1 = c1\\n        \\n        \\n        count = 0\\n        for i in range(1, len(s)-1) :\\n            \\n            if s[i] == \"0\" :\\n                m1 = temp[i-1][1]\\n                m2 = total1 - temp[i][1]\\n                count += m1*m2\\n                \\n            else:\\n                m1 = temp[i-1][0]\\n                m2 = total0 - temp[i][0]\\n                count += m1*m2\\n        return count\\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        temp = []\\n        c0 = 0\\n        c1 = 0\\n        for char in s :\\n            if char == \"0\" :\\n                c0+=1\\n            else:\\n                c1+=1\\n            temp.append([c0,c1])\\n            \\n        total0 = c0\\n        total1 = c1\\n        \\n        \\n        count = 0\\n        for i in range(1, len(s)-1) :\\n            \\n            if s[i] == \"0\" :\\n                m1 = temp[i-1][1]\\n                m2 = total1 - temp[i][1]\\n                count += m1*m2\\n                \\n            else:\\n                m1 = temp[i-1][0]\\n                m2 = total0 - temp[i][0]\\n                count += m1*m2\\n        return count\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144482,
                "title": "easiest-c-code-single-pass-o-1-space-with-explanation",
                "content": "1. We\\'ll just parse through the array from the last keeping the count of ones and zeros we\\'ve passed through. Now when we\\'ll arrive at a \\'1\\', the result will be incremented by the variable oneKeLiye and when we come at a \\'0\\' result would be incremented by zeroKeLiye.\\n\\n2. Now how do we maintain oneKeLiye and zeroKeLiye, we can observe that there are only two possible permutation i.e., \"010\" and \"101\", now oneKeLiye will store the total possibilities of making \"01\" after the current index (Therefore added when we arrive at a \\'1\\'). \\n\\n3. Similarly, zeroKeLiye will store the possibilites of storing \"10\" after the current index.\\n\\n4. Whenever we arrive at a zero we also increase oneKeLiye by the number of ones we\\'ve encountered, which is basically the number of \"01\" when the 0 is at current index.\\n\\nHere\\'s the code:\\n\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        long long int res=0;\\n        long long int ones=0,zeros=0;\\n        long long int oneKeLiye=0,zeroKeLiye=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                ones++;\\n            else\\n                zeros++;\\n            \\n            if(s[i]==\\'1\\'){\\n                zeroKeLiye+=zeros;\\n                res+=oneKeLiye;\\n            }\\n            else{\\n                oneKeLiye+=ones;\\n                res+=zeroKeLiye;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "1. We\\'ll just parse through the array from the last keeping the count of ones and zeros we\\'ve passed through. Now when we\\'ll arrive at a \\'1\\', the result will be incremented by the variable oneKeLiye and when we come at a \\'0\\' result would be incremented by zeroKeLiye.\\n\\n2. Now how do we maintain oneKeLiye and zeroKeLiye, we can observe that there are only two possible permutation i.e., \"010\" and \"101\", now oneKeLiye will store the total possibilities of making \"01\" after the current index (Therefore added when we arrive at a \\'1\\'). \\n\\n3. Similarly, zeroKeLiye will store the possibilites of storing \"10\" after the current index.\\n\\n4. Whenever we arrive at a zero we also increase oneKeLiye by the number of ones we\\'ve encountered, which is basically the number of \"01\" when the 0 is at current index.\\n\\nHere\\'s the code:\\n\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        long long int res=0;\\n        long long int ones=0,zeros=0;\\n        long long int oneKeLiye=0,zeroKeLiye=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                ones++;\\n            else\\n                zeros++;\\n            \\n            if(s[i]==\\'1\\'){\\n                zeroKeLiye+=zeros;\\n                res+=oneKeLiye;\\n            }\\n            else{\\n                oneKeLiye+=ones;\\n                res+=zeroKeLiye;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1986301,
                "title": "python-3-simple-solution-o-n-o-1-faster-than-99",
                "content": "```\\ndef numberOfWays(self, s: str) -> int:\\n        ways = one = zero = onesAfterZero = zerosAfterOne = 0\\n\\t\\tfor i in s:\\n\\t\\t\\tif i == \\'0\\':\\n\\t\\t\\t\\tzero += 1\\n\\t\\t\\t\\tzerosAfterOne += one\\n\\t\\t\\t\\tways += onesAfterZero\\n\\t\\t\\telse:\\n\\t\\t\\t\\tone += 1\\n\\t\\t\\t\\tonesAfterZero += zero\\n\\t\\t\\t\\tways += zerosAfterOne\\n\\t\\treturn ways\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numberOfWays(self, s: str) -> int:\\n        ways = one = zero = onesAfterZero = zerosAfterOne = 0\\n\\t\\tfor i in s:\\n\\t\\t\\tif i == \\'0\\':\\n\\t\\t\\t\\tzero += 1\\n\\t\\t\\t\\tzerosAfterOne += one\\n\\t\\t\\t\\tways += onesAfterZero\\n\\t\\t\\telse:\\n\\t\\t\\t\\tone += 1\\n\\t\\t\\t\\tonesAfterZero += zero\\n\\t\\t\\t\\tways += zerosAfterOne\\n\\t\\treturn ways\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1979756,
                "title": "python-3-short-and-simple-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeros = s.count(\\'0\\')\\n        ones = len(s) - zeros\\n        zeroPrefix = onePrefix = res = 0\\n        for c in s:\\n            if c == \\'0\\':\\n                res += onePrefix * (ones - onePrefix)\\n                zeroPrefix += 1\\n            else:\\n                res += zeroPrefix * (zeros - zeroPrefix)\\n                onePrefix += 1\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeros = s.count(\\'0\\')\\n        ones = len(s) - zeros\\n        zeroPrefix = onePrefix = res = 0\\n        for c in s:\\n            if c == \\'0\\':\\n                res += onePrefix * (ones - onePrefix)\\n                zeroPrefix += 1\\n            else:\\n                res += zeroPrefix * (zeros - zeroPrefix)\\n                onePrefix += 1\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1933323,
                "title": "o-n-time-o-1-space-easy-to-understand-java-solution",
                "content": "There are only 2 valid patterns: \\u2018101\\u2019 and \\u2018010\\u2019. So we have to count number of subsequences of \"010\" and \"101\".\\n\\nThe approach is to count to n0(number of zeroes), n1(number of ones), n01(number of \"01\" subsequences), n10(number of \"10\" subsequences), n010(number of \"010\" subsequences), n101(number of \"101\" subsequences).\\n\\nAt ith point if s[i] is 0 : increase n0 by 1, increase n10 by n1 i.e. (mapping all previous 1\\'s with this 0) and increase n010 by n01 i.e. (mapping all previous \"01\"\\'s by this 0).\\n\\nAt ith point if s[i] is 1 : increase n1 by 1, increase n01 by n0 i.e. (mapping all previous 0\\'s with this 1) and increase n101 by n10 i.e. (mapping all previous \"10\"\\'s by this 1).\\n\\nAnswer would be n010 + n101;\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int n = s.length();\\n        long n0 = 0;\\n        long n1 = 0;\\n        long n01 = 0;\\n        long n10 = 0;\\n        long n010 = 0;\\n        long n101 = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'0\\'){\\n                n0++;\\n                n10 += n1;\\n                n010 += n01;\\n            }\\n            else{\\n                n1++;\\n                n01 += n0;\\n                n101 += n10;\\n            }\\n        }\\n        \\n        return n010 + n101;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int n = s.length();\\n        long n0 = 0;\\n        long n1 = 0;\\n        long n01 = 0;\\n        long n10 = 0;\\n        long n010 = 0;\\n        long n101 = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'0\\'){\\n                n0++;\\n                n10 += n1;\\n                n010 += n01;\\n            }\\n            else{\\n                n1++;\\n                n01 += n0;\\n                n101 += n10;\\n            }\\n        }\\n        \\n        return n010 + n101;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907017,
                "title": "c-prefix-sum",
                "content": "there are only two types of pattern of choosing the three elemets.\\nwhich are chosing 1 as middle element and 0  as side building and vice versa.\\nso with the help of prefix and suffix sum array find the no. elemets which are left & right of cur element(0 or 1)\\nand just add no.  of possible ways i.e. (l[i]*r[i])\\n```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tlong long ans = solve(s, 0); // for 1 as middle element we need to make prefix and surfix array for 0\\n\\t\\tans += solve(s, 1); // same for 0\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tlong long solve(string s, int c) {\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long n = s.size();\\n\\t\\tvector<long long>l(n, 0), r(n, 0);\\n\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tl[i] = cnt;\\n\\t\\t\\tif (s[i] == c +  \\'0\\') {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcnt = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tr[i] = cnt;\\n\\t\\t\\tif (s[i] == c + \\'0\\') {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint x = (c == 0) ? 1 : 0;\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (s[i] == x + \\'0\\') {\\n\\t\\t\\t\\tans += l[i] * r[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tlong long ans = solve(s, 0); // for 1 as middle element we need to make prefix and surfix array for 0\\n\\t\\tans += solve(s, 1); // same for 0\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tlong long solve(string s, int c) {\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long n = s.size();\\n\\t\\tvector<long long>l(n, 0), r(n, 0);\\n\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tl[i] = cnt;\\n\\t\\t\\tif (s[i] == c +  \\'0\\') {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcnt = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tr[i] = cnt;\\n\\t\\t\\tif (s[i] == c + \\'0\\') {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint x = (c == 0) ? 1 : 0;\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (s[i] == x + \\'0\\') {\\n\\t\\t\\t\\tans += l[i] * r[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907010,
                "title": "simple-explanation-python",
                "content": "**Solution 1: O(n) space**\\n\\nOnly 2 patterns are possible:\\n`101`\\n`010`\\n\\nCalculate 0s and 1s from left.\\nCalculate 0s and 1s from right.\\n\\nFix the middle element of pattern e.g. `0` in `101`. \\nThen total number of combinations will be `cnt(1s on the left) * cnt(1s on the right)`.\\n\\n\\n```\\ndef numberOfWays(self, s: str) -> int:\\n    n = len(s)\\n    right0, right1 = [0]*n, [0]*n # 0s and 1s to the right of index i\\n    left0, left1 = [0]*n, [0]*n # 0s and 1s to the left of index i\\n\\n    cnt0, cnt1 = 0, 0\\n    for i in range(n-1,-1,-1): # right to left\\n        right0[i], right1[i] = cnt0, cnt1\\n        if s[i] == \\'0\\':\\n            cnt0 += 1\\n        else:\\n            cnt1 += 1\\n    \\n    \\n    cnt0, cnt1 = 0, 0\\n    for i in range(n):\\n        left0[i], left1[i] = cnt0, cnt1\\n        if s[i] == \\'0\\':\\n            cnt0 += 1\\n        else:\\n            cnt1 += 1\\n    \\n\\n    res = 0\\n    for i in range(n):\\n        if s[i] == \\'1\\':\\n            res += left0[i] * right0[i] # 010\\n        else:\\n            res += left1[i] * right1[i] # 101\\n    return res\\n```\\n\\n\\n\\n\\n**Solution 2: O(1) space**\\n\\nBy rock: https://leetcode.com/problems/number-of-ways-to-select-buildings/discuss/1907179/JavaPython-3-Space-O(1)-code-w-brief-explanation-and-analysis. \\n\\nCalculate the no. of patterns: `01` and `10`\\nNow when you encounter 1, you can use the count of `10`s to the left and append this `1` to the end. This will count for `101`.\\nNow when you encounter 0, you can use the count of `01`s to the left. This will count for `010`.\\n\\n\\n```\\ndef numberOfWays(self, s: str) -> int:\\n    ways = 0\\n    one = zero = zero_one = one_zero = 0\\n    for c in s:\\n        if c == \\'0\\':\\n            zero += 1\\n            one_zero += one\\n            ways += zero_one\\n        else:\\n            one += 1    \\n            zero_one += zero \\n            ways += one_zero\\n    return ways\\n```",
                "solutionTags": [],
                "code": "```\\ndef numberOfWays(self, s: str) -> int:\\n    n = len(s)\\n    right0, right1 = [0]*n, [0]*n # 0s and 1s to the right of index i\\n    left0, left1 = [0]*n, [0]*n # 0s and 1s to the left of index i\\n\\n    cnt0, cnt1 = 0, 0\\n    for i in range(n-1,-1,-1): # right to left\\n        right0[i], right1[i] = cnt0, cnt1\\n        if s[i] == \\'0\\':\\n            cnt0 += 1\\n        else:\\n            cnt1 += 1\\n    \\n    \\n    cnt0, cnt1 = 0, 0\\n    for i in range(n):\\n        left0[i], left1[i] = cnt0, cnt1\\n        if s[i] == \\'0\\':\\n            cnt0 += 1\\n        else:\\n            cnt1 += 1\\n    \\n\\n    res = 0\\n    for i in range(n):\\n        if s[i] == \\'1\\':\\n            res += left0[i] * right0[i] # 010\\n        else:\\n            res += left1[i] * right1[i] # 101\\n    return res\\n```\n```\\ndef numberOfWays(self, s: str) -> int:\\n    ways = 0\\n    one = zero = zero_one = one_zero = 0\\n    for c in s:\\n        if c == \\'0\\':\\n            zero += 1\\n            one_zero += one\\n            ways += zero_one\\n        else:\\n            one += 1    \\n            zero_one += zero \\n            ways += one_zero\\n    return ways\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2391922,
                "title": "easy-to-follow-c-code",
                "content": "```\\n/*\\n\\nThere can be only two types of selections: 101 or 010\\n\\n-> Iterate over the string and in each iteration,\\n\\tIf current character is \\'0\\', it can be the middle of \"101\" slection\\n\\t\\tadd how many selections can be there with this \\'0\\' as the middle element\\n\\t\\t(this is, numbers of ones on the left * number of ones on the right)\\n\\tIf current character is \\'1\\', it can be the middle of \"010\" selection\\n\\t\\tadd how many selections can be there with this \\'1\\' as the middle element\\n\\t\\t(this is, numbers of zeros on the left * number of zeros on the right)\\n-> return ans\\n*/\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long left0 = 0, left1 = 0, count0 = 0, count1 = 0, ans = 0;\\n        for(char ch : s) {\\n            count0 += (ch == \\'0\\');\\n            count1 += (ch == \\'1\\');\\n        }\\n        for(int i=0; i<s.length(); i++) {\\n            if(s[i] == \\'1\\')    ans += left0 * (count0 - left0);\\n            if(s[i] == \\'0\\')    ans += left1 * (count1 - left1);\\n            left0 += (s[i] == \\'0\\');\\n            left1 += (s[i] == \\'1\\');\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n/*\\n\\nThere can be only two types of selections: 101 or 010\\n\\n-> Iterate over the string and in each iteration,\\n\\tIf current character is \\'0\\', it can be the middle of \"101\" slection\\n\\t\\tadd how many selections can be there with this \\'0\\' as the middle element\\n\\t\\t(this is, numbers of ones on the left * number of ones on the right)\\n\\tIf current character is \\'1\\', it can be the middle of \"010\" selection\\n\\t\\tadd how many selections can be there with this \\'1\\' as the middle element\\n\\t\\t(this is, numbers of zeros on the left * number of zeros on the right)\\n-> return ans\\n*/\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long left0 = 0, left1 = 0, count0 = 0, count1 = 0, ans = 0;\\n        for(char ch : s) {\\n            count0 += (ch == \\'0\\');\\n            count1 += (ch == \\'1\\');\\n        }\\n        for(int i=0; i<s.length(); i++) {\\n            if(s[i] == \\'1\\')    ans += left0 * (count0 - left0);\\n            if(s[i] == \\'0\\')    ans += left1 * (count1 - left1);\\n            left0 += (s[i] == \\'0\\');\\n            left1 += (s[i] == \\'1\\');\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907871,
                "title": "python-3-prefix-suffix-sum-easy-to-understand-explanation",
                "content": "### Explanation\\n- For `\"1\"`, we want `\"010\"`\\n- For `\"0\"`, we want `\"101\"`\\n- Thus, all we need to do is to count how many `0`s and `1`s are before/after `1` and `0`\\n- See comments below for more explanation\\n### Implementation\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        prefix = []\\n        one = zero = 0\\n        for c in s:                                # find number of 0 or 1 before index `i`\\n            prefix.append([zero, one])\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1    \\n        suffix = []        \\n        one = zero = 0\\n        for c in s[::-1]:                          # find number of 0 or 1 after index `i`\\n            suffix.append([zero, one])\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1    \\n        suffix = suffix[::-1]                      # reverse since we trace from right to left \\n        ans = 0\\n        for i, c in enumerate(s):                  # for c==\\'1\\' number of combination is prefix[i][0] * suffix[i][0] ([0 before index `i`] * [0 after index `i`])\\n            if c == \\'1\\':\\n                ans += prefix[i][0] * suffix[i][0]\\n            else:    \\n                ans += prefix[i][1] * suffix[i][1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        prefix = []\\n        one = zero = 0\\n        for c in s:                                # find number of 0 or 1 before index `i`\\n            prefix.append([zero, one])\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1    \\n        suffix = []        \\n        one = zero = 0\\n        for c in s[::-1]:                          # find number of 0 or 1 after index `i`\\n            suffix.append([zero, one])\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1    \\n        suffix = suffix[::-1]                      # reverse since we trace from right to left \\n        ans = 0\\n        for i, c in enumerate(s):                  # for c==\\'1\\' number of combination is prefix[i][0] * suffix[i][0] ([0 before index `i`] * [0 after index `i`])\\n            if c == \\'1\\':\\n                ans += prefix[i][0] * suffix[i][0]\\n            else:    \\n                ans += prefix[i][1] * suffix[i][1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907155,
                "title": "top-down-dp-java",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n       int n = s.length();\\n        long[][][] dp = new long[n][4][4];\\n        for(long[][] y : dp)\\n            for(long[] x : y)\\n        Arrays.fill(x,-1);\\n        return solve(0,0,\\'2\\',s.toCharArray(),dp);\\n    }\\n    public long solve(int i ,int c ,char prev ,char[] s,long[][][] dp){\\n        if(c==3)return 1;\\n        if(i>=s.length) return 0;\\n         if(dp[i][c][prev-\\'0\\']!=-1) return dp[i][c][prev-\\'0\\'];\\n        long a=0 ,b=0;\\n        if(s[i]!=prev){\\n            a= solve(i+1,c+1,s[i],s,dp); //if current char is not equal to previous then can take it .\\n        } \\n            b = solve(i+1,c,prev,s,dp);//if current char is same as previous then cannot take .so just look in the next char.\\n        \\n        return dp[i][c][prev-\\'0\\'] =   (a+b);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n       int n = s.length();\\n        long[][][] dp = new long[n][4][4];\\n        for(long[][] y : dp)\\n            for(long[] x : y)\\n        Arrays.fill(x,-1);\\n        return solve(0,0,\\'2\\',s.toCharArray(),dp);\\n    }\\n    public long solve(int i ,int c ,char prev ,char[] s,long[][][] dp){\\n        if(c==3)return 1;\\n        if(i>=s.length) return 0;\\n         if(dp[i][c][prev-\\'0\\']!=-1) return dp[i][c][prev-\\'0\\'];\\n        long a=0 ,b=0;\\n        if(s[i]!=prev){\\n            a= solve(i+1,c+1,s[i],s,dp); //if current char is not equal to previous then can take it .\\n        } \\n            b = solve(i+1,c,prev,s,dp);//if current char is same as previous then cannot take .so just look in the next char.\\n        \\n        return dp[i][c][prev-\\'0\\'] =   (a+b);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031207,
                "title": "easy-c-code-o-1-space-and-o-n-time-complexity-efficient-approach",
                "content": "**The Only ways in which you can select 3 buildings where consecutive buildings are not of same type are :\\n010\\n101**\\nSo,when we will be traversing array we will keep track of count of 0\\'s, 1\\'s, 01\\'s ,10\\'s ,010\\'s and 101\\'s till now.\\nSo,If current element is 0 then the count of 0\\'s,10\\'s and 010\\'s will change.So:\\ncount of 10\\'s = count of 1\\'s  ( Because current 0 will get mapped with all previous 1\\'s to make it 10)\\ncount of 010\\'s = count of 01\\'s (Because current 0 will get mapped with previous 01\\'s to make it 010]\\ncount of 0\\'s will increase by 1.\\n\\nIf current element is 1 then the count of 1\\'s, 01\\'s and 101\\'s will change.So:\\ncount of 01\\'s = count of 0\\'s ( Because current 1 will get mapped with all previous 0\\'s to make it 01)\\ncount of 101\\'s = count of 10\\'s ( Because current 1 will get mapped with previous 10\\'s to make it 101)\\n```\\n long long numberOfWays(string s) {\\n        long int c0 = 0,c1=0,c01=0,c10 = 0,c010=0,c101=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                c10 += c1;\\n                c010 += c01;\\n                c0++;\\n            }\\n            else\\n            {\\n                c01 += c0;\\n                c101 += c10;\\n                c1++;\\n            }\\n        }\\n        return c010 + c101;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n long long numberOfWays(string s) {\\n        long int c0 = 0,c1=0,c01=0,c10 = 0,c010=0,c101=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                c10 += c1;\\n                c010 += c01;\\n                c0++;\\n            }\\n            else\\n            {\\n                c01 += c0;\\n                c101 += c10;\\n                c1++;\\n            }\\n        }\\n        return c010 + c101;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908071,
                "title": "javascript-o-n-time-and-constant-space",
                "content": "The idea is for every character (\\'0\\' or \\'1\\') at index i, the possible solutions that can be formed from it are:\\nnumber of the opposite of this character that occured before it (e.i. if it is \\'0\\', then number of 1\\'s before it) * number of 1\\'s occured after it and vice versa.\\n\\n```\\nvar numberOfWays = function (s) {\\n  \\n  let result = 0,\\n    zeroes = s.replaceAll(\\'1\\', \\'\\').length,\\n    ones = s.length - zeroes,\\n    curZeroes = 0,\\n    curOnes = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    s[i] === \\'0\\'\\n      ? (result += curOnes * (ones - curOnes))\\n      : (result += curZeroes * (zeroes - curZeroes));\\n      \\n    s[i] === \\'0\\' ? curZeroes++ : curOnes++;\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numberOfWays = function (s) {\\n  \\n  let result = 0,\\n    zeroes = s.replaceAll(\\'1\\', \\'\\').length,\\n    ones = s.length - zeroes,\\n    curZeroes = 0,\\n    curOnes = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    s[i] === \\'0\\'\\n      ? (result += curOnes * (ones - curOnes))\\n      : (result += curZeroes * (zeroes - curZeroes));\\n      \\n    s[i] === \\'0\\' ? curZeroes++ : curOnes++;\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907563,
                "title": "easily-understandable-c-code-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string &s) {\\n        int n=s.size(); \\n        vector<long long>pre1(n,0);// for no of 1\\'s \\n        vector<long long>pre2(n,0); //          0\\'s\\n        \\n        pre1[0]=(s[0]==\\'1\\'); \\n        \\n        for(int i=1;i<n;i++){\\n            pre1[i]=(pre1[i-1]+(s[i]==\\'1\\'));  \\n        }\\n        \\n        pre2[0]=(s[0]==\\'0\\'); \\n        \\n        for(int i=1;i<n;i++){\\n            pre2[i]=(pre2[i-1]+(s[i]==\\'0\\'));  \\n        }\\n        \\n        long long ans=0;  \\n        for(int i=1;i<n-1;i++){\\n            if(s[i]==\\'0\\'){\\n                ans+= (pre1[i-1]*(pre1[n-1]-pre1[i]));  \\n            }\\n            else{\\n                ans+= (pre2[i-1]*(pre2[n-1]-pre2[i])); \\n            }\\n        }\\n        return ans;   \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string &s) {\\n        int n=s.size(); \\n        vector<long long>pre1(n,0);// for no of 1\\'s \\n        vector<long long>pre2(n,0); //          0\\'s\\n        \\n        pre1[0]=(s[0]==\\'1\\'); \\n        \\n        for(int i=1;i<n;i++){\\n            pre1[i]=(pre1[i-1]+(s[i]==\\'1\\'));  \\n        }\\n        \\n        pre2[0]=(s[0]==\\'0\\'); \\n        \\n        for(int i=1;i<n;i++){\\n            pre2[i]=(pre2[i-1]+(s[i]==\\'0\\'));  \\n        }\\n        \\n        long long ans=0;  \\n        for(int i=1;i<n-1;i++){\\n            if(s[i]==\\'0\\'){\\n                ans+= (pre1[i-1]*(pre1[n-1]-pre1[i]));  \\n            }\\n            else{\\n                ans+= (pre2[i-1]*(pre2[n-1]-pre2[i])); \\n            }\\n        }\\n        return ans;   \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260610,
                "title": "python-explained-o-n-time-o-n-space",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \"\"\"\\n        This solution could be optimized as i have seen people figured out\\n        O(1) space solution, however this is what i have reached which could be helpful!\\n        \\n        We iterate from the end of the string s, store the following:\\n        1 - count of zeros we have next -> this will be used to count amount of \"10\" we can make when we are currently on index of value \"1\"\\n        \\n        2 - count of ones we have next -> this will be used to count amount of \"01\" we can make when we are currently on index of value \"0\"\\n        \\n        3- count of \"01\" we have formed -> this will be helpful in the second iteration\\n        4- count of \"10\" we have formed -> this will be helpful in the second iteration\\n        \\n        \"\"\"\\n        n = len(s)\\n        dp = [[0, 0, 0, 0]] * (n + 1) # [one count, zero count, \"01\" count, \"10\" count]\\n        for i in range(n - 1, -1, -1):\\n            prev_ones, prev_zero, prev_01, prev_10 = dp[i + 1]\\n            #if the current value i.e s[i] has value of \\'1\\' then this means we can make prev_10 + prev_zero of \"10\" sequence as currently we have \"1\" so we can match it with any of zeros we face later\\n            if s[i] == \"1\":\\n                dp[i] = [prev_ones + 1, prev_zero, prev_01, prev_10 + prev_zero]\\n            #same comment applies here but for zeros i.e we form \"01\" sequence \\n            else:\\n                dp[i] = [prev_ones, prev_zero + 1, prev_01 + prev_ones, prev_10]\\n        \\n        res = 0\\n        for i in range(n - 2):\\n            #we are currently at zero so we need \"10\" only so we check how many sequences of \"10\" we have in front of us\\n            if s[i] == \"0\":\\n                res += dp[i][-1]\\n            #we are currently at one so we need \"01\" only so we check how many sequences of \"01\" we have in front of us\\n            else:\\n                res += dp[i][-2]\\n        return res\\n        \\n        \\n                \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \"\"\"\\n        This solution could be optimized as i have seen people figured out\\n        O(1) space solution, however this is what i have reached which could be helpful!\\n        \\n        We iterate from the end of the string s, store the following:\\n        1 - count of zeros we have next -> this will be used to count amount of \"10\" we can make when we are currently on index of value \"1\"\\n        \\n        2 - count of ones we have next -> this will be used to count amount of \"01\" we can make when we are currently on index of value \"0\"\\n        \\n        3- count of \"01\" we have formed -> this will be helpful in the second iteration\\n        4- count of \"10\" we have formed -> this will be helpful in the second iteration\\n        \\n        \"\"\"\\n        n = len(s)\\n        dp = [[0, 0, 0, 0]] * (n + 1) # [one count, zero count, \"01\" count, \"10\" count]\\n        for i in range(n - 1, -1, -1):\\n            prev_ones, prev_zero, prev_01, prev_10 = dp[i + 1]\\n            #if the current value i.e s[i] has value of \\'1\\' then this means we can make prev_10 + prev_zero of \"10\" sequence as currently we have \"1\" so we can match it with any of zeros we face later\\n            if s[i] == \"1\":\\n                dp[i] = [prev_ones + 1, prev_zero, prev_01, prev_10 + prev_zero]\\n            #same comment applies here but for zeros i.e we form \"01\" sequence \\n            else:\\n                dp[i] = [prev_ones, prev_zero + 1, prev_01 + prev_ones, prev_10]\\n        \\n        res = 0\\n        for i in range(n - 2):\\n            #we are currently at zero so we need \"10\" only so we check how many sequences of \"10\" we have in front of us\\n            if s[i] == \"0\":\\n                res += dp[i][-1]\\n            #we are currently at one so we need \"01\" only so we check how many sequences of \"01\" we have in front of us\\n            else:\\n                res += dp[i][-2]\\n        return res\\n        \\n        \\n                \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907069,
                "title": "recursion-memorization-dp-c",
                "content": "1st state for normal indexing\\n2nd state for value of k\\n3rd state for previous value ( as we can\\'t keep 2 0\\'s or 2 1\\'s together )\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][3];\\n    long long solve(char prev,int i,int k,string &s){\\n        if(k == 0) return 1;\\n        if(i == s.size()) return 0;\\n        if(dp[i][k][prev - \\'0\\'] != -1) return dp[i][k][prev - \\'0\\'];\\n        \\n        long long op1 = 0;\\n        if(s[i] != prev) op1 = solve(s[i],i+1,k-1,s);\\n        long long op2 = solve(prev,i+1,k,s);\\n        return dp[i][k][prev - \\'0\\'] = op1 + op2;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(\\'2\\',0,3,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][3];\\n    long long solve(char prev,int i,int k,string &s){\\n        if(k == 0) return 1;\\n        if(i == s.size()) return 0;\\n        if(dp[i][k][prev - \\'0\\'] != -1) return dp[i][k][prev - \\'0\\'];\\n        \\n        long long op1 = 0;\\n        if(s[i] != prev) op1 = solve(s[i],i+1,k-1,s);\\n        long long op2 = solve(prev,i+1,k,s);\\n        return dp[i][k][prev - \\'0\\'] = op1 + op2;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(\\'2\\',0,3,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827680,
                "title": "python-3-beats-100",
                "content": "# Intuition\\nFor each house calculate how many inspections where this house is the last one\\n\\n# Approach\\n1. Iterate over houses\\n2. If house is \\'1\\' $\\\\Longrightarrow$ previous house should be \\'0\\'\\n  2.1 We can choose any previous \\'0\\' as the 2nd house and any \\'1\\' before that \\'0\\' as the 1st\\n  2.2 Because of that when we see \\'0\\' we add count of previous ones in special sum \\u2014 `options_for_ones` (options_for_ones, because we will use it when we see house \\'1\\')\\n  2.3 So when we see current house, `options_for_ones` indicates the exact number of combinations of choosing any previously seen \\'0\\' and any \\'1\\' before that $\\\\Longrightarrow$ ans += options_for_ones\\n3. If house is \\'0\\' \\u2014 similarly\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ans = 0\\n        ones = 0\\n        zeros = 0\\n        options_for_zeros = 0\\n        options_for_ones = 0\\n        for x in s:\\n            if x == \\'1\\':\\n                ans += options_for_ones\\n                options_for_zeros += zeros\\n                ones += 1\\n            else:\\n                ans += options_for_zeros\\n                options_for_ones += ones\\n                zeros += 1\\n        return ans\\n```\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(1)$",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ans = 0\\n        ones = 0\\n        zeros = 0\\n        options_for_zeros = 0\\n        options_for_ones = 0\\n        for x in s:\\n            if x == \\'1\\':\\n                ans += options_for_ones\\n                options_for_zeros += zeros\\n                ones += 1\\n            else:\\n                ans += options_for_zeros\\n                options_for_ones += ones\\n                zeros += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730465,
                "title": "easy-dp-python-solution",
                "content": "O(N), nospace\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeroes, ones = 0, 0\\n        counts01, counts10 = 0, 0\\n        counts010, counts101 = 0, 0\\n        for i, v in enumerate(s):\\n            if v == \\'0\\':\\n                zeroes += 1\\n                counts10 += ones\\n                counts010 += counts01         \\n            else:\\n                ones += 1\\n                counts01 += zeroes\\n                counts101 += counts10\\n        \\n        return counts010 + counts101\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeroes, ones = 0, 0\\n        counts01, counts10 = 0, 0\\n        counts010, counts101 = 0, 0\\n        for i, v in enumerate(s):\\n            if v == \\'0\\':\\n                zeroes += 1\\n                counts10 += ones\\n                counts010 += counts01         \\n            else:\\n                ones += 1\\n                counts01 += zeroes\\n                counts101 += counts10\\n        \\n        return counts010 + counts101\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557456,
                "title": "cpp-solution-using-prefix-array",
                "content": "```\\n#define v vector<long long>\\nclass Solution {\\npublic:\\n       \\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        \\n        v zero_one(n),one_zero(n),a(n),b(n);\\n        \\n        int ctzero=0,ctone=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                ctzero++;\\n                one_zero[i]=ctone;\\n            }\\n            \\n            else{\\n                ctone++;\\n                zero_one[i]=ctzero;\\n            }\\n        }\\n        \\n        int ct=0,ct1=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                ct++;\\n            }\\n            a[i]=ct;\\n            \\n            if(s[i]==\\'1\\'){\\n                ct1++;\\n            }\\n            \\n            b[i]=ct1;\\n        }\\n        \\n        long long ans=0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            ans+=zero_one[i]*a[i+1];\\n            ans+=one_zero[i]*b[i+1];\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n       \\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        \\n        v zero_one(n),one_zero(n),a(n),b(n);\\n        \\n        int ctzero=0,ctone=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                ctzero++;\\n                one_zero[i]=ctone;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2510161,
                "title": "c-concise-solution-explanation-o-n-time-and-space-complexity",
                "content": "There are only two types of buildring we can make either ```010``` or ```101```. Think about the mid digit only, if we take mid 0 then the other two boundary values should be 1 and for mid value 1, the other two value sould be 0. So I am calculating how may valid numbers available from left side and right side in each position and multiply them as we need all of the combinations.\\n\\n\\n\\n\\n```\\n long long numberOfWays(string s) {\\n        vector<int> zeroCount(s.size(), 0), oneCount(s.size(), 0);\\n        long long res = 0L;\\n        \\n        zeroCount[0] = (s[0] == \\'0\\');\\n        oneCount[0] = (s[0] == \\'1\\');\\n        \\n        for(int i=1; i<s.size(); i++)\\n        {\\n            zeroCount[i] = zeroCount[i-1] + (s[i] == \\'0\\');\\n            oneCount[i] = oneCount[i-1] + (s[i] == \\'1\\');\\n        }\\n        \\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            res += (s[i] == \\'1\\')? (long long)(zeroCount[i] * (zeroCount[s.size()-1] - zeroCount[i]))\\n                :  (long long)(oneCount[i] * (oneCount[s.size()-1] - oneCount[i]));\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n***Complexity:*** \\nTime - O(n)\\nSpace - O(n)\\n\\n***Note:*** Instead of using two counter vectors, we can easily reach our goal by using one. For the sake of simplicity, I kept two.",
                "solutionTags": [
                    "C"
                ],
                "code": "```010```\n```101```\n```\\n long long numberOfWays(string s) {\\n        vector<int> zeroCount(s.size(), 0), oneCount(s.size(), 0);\\n        long long res = 0L;\\n        \\n        zeroCount[0] = (s[0] == \\'0\\');\\n        oneCount[0] = (s[0] == \\'1\\');\\n        \\n        for(int i=1; i<s.size(); i++)\\n        {\\n            zeroCount[i] = zeroCount[i-1] + (s[i] == \\'0\\');\\n            oneCount[i] = oneCount[i-1] + (s[i] == \\'1\\');\\n        }\\n        \\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            res += (s[i] == \\'1\\')? (long long)(zeroCount[i] * (zeroCount[s.size()-1] - zeroCount[i]))\\n                :  (long long)(oneCount[i] * (oneCount[s.size()-1] - oneCount[i]));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436177,
                "title": "python-straightforward-solution-with-explanation-in-comment-no-need-to-use-multiplication-operator",
                "content": "```\\n# basic idea: \\n# To obtain \\'101\\' we need to find \\'10\\' before \\'1\\'. \\n# Thus, it is necessary to count the number of \\'10\\' and \\'01\\' before \\'1\\' and \\'0\\' respectively. \\n# Further, we need to count the number of \\'1\\' and \\'0\\' before \\'0\\' and \\'1\\' respectively.\\n# Think about the following example: we get \\'1\\' at index i, then we need to update the number of \\'101\\' and \\'01\\' and \\'1\\'. \\n# The number of \\'101\\' is updated by the number of \\'10\\' before \\'1\\'(before index i).\\n# The number of \\'01\\' is updated by the number of \\'0\\' before \\'1\\'(before index i).\\n# The number of \\'1\\' is updated by 1.\\n# The number of \\'0\\', \\'10\\' and \\'010\\' are updated without refreshing the values.\\n# It is obvious that the number of \\'1\\', \\'01\\' and \\'101\\' are independent at each index i. This means that we can simply update each number without additional effort.\\n\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        # \\'101\\' or \\'010\\'\\n        # \\'101\\':\\n        # count the number of 1\\'s before i\\n        # count the number of 0\\'s before i\\n        C1=0\\n        C0=0\\n        # if i is a 0, then it can form \\'10\\' with previous 1\\'s\\n        C10=0\\n        # if i is a 1, it can form \\'01\\' with previous 0\\'s\\n        C01=0\\n        # if i is a 0, it can form \\'010\\' with previous \\'01\\'\\'s\\n        C010=0\\n        # if i is a 1, it can form \\'101\\' with previous \\'10\\'\\'s\\n        C101=0\\n        for i in range(len(s)):\\n            if s[i]==\\'0\\':\\n                C010+=C01 # += 01\\'s before i\\n                C10+=C1 # += 1\\'s before i\\n                C0+=1 # update 0\\n            else:\\n                C101+=C10 # ...\\n                C01+=C0\\n                C1+=1\\n        return C010+C101\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n# basic idea: \\n# To obtain \\'101\\' we need to find \\'10\\' before \\'1\\'. \\n# Thus, it is necessary to count the number of \\'10\\' and \\'01\\' before \\'1\\' and \\'0\\' respectively. \\n# Further, we need to count the number of \\'1\\' and \\'0\\' before \\'0\\' and \\'1\\' respectively.\\n# Think about the following example: we get \\'1\\' at index i, then we need to update the number of \\'101\\' and \\'01\\' and \\'1\\'. \\n# The number of \\'101\\' is updated by the number of \\'10\\' before \\'1\\'(before index i).\\n# The number of \\'01\\' is updated by the number of \\'0\\' before \\'1\\'(before index i).\\n# The number of \\'1\\' is updated by 1.\\n# The number of \\'0\\', \\'10\\' and \\'010\\' are updated without refreshing the values.\\n# It is obvious that the number of \\'1\\', \\'01\\' and \\'101\\' are independent at each index i. This means that we can simply update each number without additional effort.\\n\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        # \\'101\\' or \\'010\\'\\n        # \\'101\\':\\n        # count the number of 1\\'s before i\\n        # count the number of 0\\'s before i\\n        C1=0\\n        C0=0\\n        # if i is a 0, then it can form \\'10\\' with previous 1\\'s\\n        C10=0\\n        # if i is a 1, it can form \\'01\\' with previous 0\\'s\\n        C01=0\\n        # if i is a 0, it can form \\'010\\' with previous \\'01\\'\\'s\\n        C010=0\\n        # if i is a 1, it can form \\'101\\' with previous \\'10\\'\\'s\\n        C101=0\\n        for i in range(len(s)):\\n            if s[i]==\\'0\\':\\n                C010+=C01 # += 01\\'s before i\\n                C10+=C1 # += 1\\'s before i\\n                C0+=1 # update 0\\n            else:\\n                C101+=C10 # ...\\n                C01+=C0\\n                C1+=1\\n        return C010+C101\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313593,
                "title": "c-very-easy-to-understand-with-explanation",
                "content": "\\n   \\n        There can be only 2 patterns either 010 or 101.\\n\\t\\t\\n\\t\\tSo if we encounter \\'1\\' so check how many zeros are present before and\\n\\t\\tafter that 1(totalZeros-PrefixZeros) and simarly check for \\'0\\'.\\n\\t\\t\\n        eg: 0010 so number of zeros before \\'1\\' are 2 and after are \\'1\\' is 1.\\n        So total patterns that can be made are 2*1 = 2. \\n\\t\\t\\n\\t\\tAnd keep adding that value in ans.\\n    \\n\\n```\\n    long long numberOfWays(string s) {\\n        int count0=0,count1=0;\\n        \\n        for(int i=0;i<s.size();i++){\\n          s[i]==\\'1\\'?count1++:count0++;\\n        }\\n        int count0before=0;\\n        int count1before=0;\\n        s[0]==\\'0\\'?count0before++:count1before++;\\n        long long ans=0;\\n        for(int i=1;i<s.size()-1;i++){\\n            if(s[i]==\\'1\\'){ //search for 010\\n                ans+=count0before*(count0-count0before);\\n                count1before++;\\n            }else{\\n                ans+=count1before*(count1-count1before);\\n                count0before++;\\n            }\\n        }\\n         return ans;   \\n    }\\n```\\n\\nPLEASE DO UPVOTE IF YOU FIND THIS USEFUL :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    long long numberOfWays(string s) {\\n        int count0=0,count1=0;\\n        \\n        for(int i=0;i<s.size();i++){\\n          s[i]==\\'1\\'?count1++:count0++;\\n        }\\n        int count0before=0;\\n        int count1before=0;\\n        s[0]==\\'0\\'?count0before++:count1before++;\\n        long long ans=0;\\n        for(int i=1;i<s.size()-1;i++){\\n            if(s[i]==\\'1\\'){ //search for 010\\n                ans+=count0before*(count0-count0before);\\n                count1before++;\\n            }else{\\n                ans+=count1before*(count1-count1before);\\n                count0before++;\\n            }\\n        }\\n         return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910871,
                "title": "c-simple-maths-solutions-in-o-n",
                "content": "```\\nclass Solution {\\npublic:    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> countOnes(n,0),countZero(n,0);\\n        countOnes[0] = s[0] == \\'1\\';\\n        countZero[0] = s[0] == \\'0\\';\\n        for(int i=1;i<n;i++){\\n            countOnes[i] += countOnes[i-1] + (s[i] == \\'1\\');\\n            countZero[i] += countZero[i-1] + (s[i] == \\'0\\');\\n        }\\n        long long ans = 0;\\n        for(int i=1;i<n-1;i++){\\n            if(s[i] == \\'0\\'){\\n                int onesLeft = countOnes[i-1];\\n                int onesRight = (countOnes[n-1] - countOnes[i]);\\n                if(onesLeft >= 0 && onesRight >= 0){\\n                    ans += (1ll * onesLeft * onesRight);                    \\n                }\\n            }else{\\n                int zerosLeft = countZero[i-1];\\n                int zerosRight = (countZero[n-1] - countZero[i]);\\n                if(zerosRight >= 0 && zerosLeft >= 0){\\n                    ans += (1ll * zerosLeft * zerosRight);                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Combinatorics",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> countOnes(n,0),countZero(n,0);\\n        countOnes[0] = s[0] == \\'1\\';\\n        countZero[0] = s[0] == \\'0\\';\\n        for(int i=1;i<n;i++){\\n            countOnes[i] += countOnes[i-1] + (s[i] == \\'1\\');\\n            countZero[i] += countZero[i-1] + (s[i] == \\'0\\');\\n        }\\n        long long ans = 0;\\n        for(int i=1;i<n-1;i++){\\n            if(s[i] == \\'0\\'){\\n                int onesLeft = countOnes[i-1];\\n                int onesRight = (countOnes[n-1] - countOnes[i]);\\n                if(onesLeft >= 0 && onesRight >= 0){\\n                    ans += (1ll * onesLeft * onesRight);                    \\n                }\\n            }else{\\n                int zerosLeft = countZero[i-1];\\n                int zerosRight = (countZero[n-1] - countZero[i]);\\n                if(zerosRight >= 0 && zerosLeft >= 0){\\n                    ans += (1ll * zerosLeft * zerosRight);                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909586,
                "title": "dynamic-programming-count-pattern-searching",
                "content": "```\\nclass Solution {\\n    public static long numberOfWays(String s) {\\n\\t\\tString p1 = \"101\";\\n\\t\\tString p2 = \"010\";\\n\\t\\tlong count = 0;\\n\\t\\tcount += helper(s, p1);\\n\\t\\tcount += helper(s, p2);\\n\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic static long helper(String x, String y) {\\n\\t\\tint m = x.length();\\n\\t\\tint n = y.length();\\n\\n\\t\\tlong dp[][] = new long[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < n + 1; j++) {\\n\\t\\t\\t\\tif (x.charAt(i - 1) == y.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[m][n];\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public static long numberOfWays(String s) {\\n\\t\\tString p1 = \"101\";\\n\\t\\tString p2 = \"010\";\\n\\t\\tlong count = 0;\\n\\t\\tcount += helper(s, p1);\\n\\t\\tcount += helper(s, p2);\\n\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic static long helper(String x, String y) {\\n\\t\\tint m = x.length();\\n\\t\\tint n = y.length();\\n\\n\\t\\tlong dp[][] = new long[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < n + 1; j++) {\\n\\t\\t\\t\\tif (x.charAt(i - 1) == y.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[m][n];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907333,
                "title": "python-c-o-n-time-o-1-space",
                "content": "Python:\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways, count = 0, defaultdict(int)\\n\\t\\t\\n        for char in s:\\n            other = f\"{1 - int(char)}\"\\n            count[other+char] += count[other]\\n            ways += count[char+other]\\n            count[char] += 1\\n        \\n        return ways\\n\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ways = 0;\\n        unordered_map<string, long> count;\\n        \\n        for (int i=0; i < s.size(); i++) {\\n            char other(s[i]==\\'0\\' ? \\'1\\' : \\'0\\');\\n            count[string()+other+s[i]] += count[string()+other];\\n            ways += count[string()+s[i]+other];\\n            count[string()+s[i]] += 1;\\n        }        \\n        \\n        return ways;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways, count = 0, defaultdict(int)\\n\\t\\t\\n        for char in s:\\n            other = f\"{1 - int(char)}\"\\n            count[other+char] += count[other]\\n            ways += count[char+other]\\n            count[char] += 1\\n        \\n        return ways\\n\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ways = 0;\\n        unordered_map<string, long> count;\\n        \\n        for (int i=0; i < s.size(); i++) {\\n            char other(s[i]==\\'0\\' ? \\'1\\' : \\'0\\');\\n            count[string()+other+s[i]] += count[string()+other];\\n            ways += count[string()+s[i]+other];\\n            count[string()+s[i]] += 1;\\n        }        \\n        \\n        return ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907330,
                "title": "simple-maths-applying-pnc-easy-c-solution",
                "content": "Apply Pnc, \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\n    long long numberOfWays(string s) {\\n\\t\\tint total0 = 0, total1 = 0;\\n        \\n        for(char i: s){\\n            if(i == \\'0\\') total0++;\\n            if(i == \\'1\\') total1++;\\n        }\\n        \\n        long ans = 0;\\n        \\n        // count of 0s and 1s till current position i.e. left of current position\\n        int count0 = 0, count1 = 0;\\n        \\n        for(char i: s){\\n            // for all \"0....0 1 0...0\" type            \\n            if(i == \\'1\\'){\\n                ans += count0 * (total0 - count0);      //(no. of 0s left of 1) * (no. of 0s after 1)\\n                count1++;\\n            }\\n            \\n            // for all \"1....1 0 1...1\" type\\n            if(i == \\'0\\'){\\n                ans += count1 * (total1 - count1);      //(no. of 1s left of 0) * (no. of 1s after 0)\\n                count0++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n    long long numberOfWays(string s) {\\n\\t\\tint total0 = 0, total1 = 0;\\n        \\n        for(char i: s){\\n            if(i == \\'0\\') total0++;\\n            if(i == \\'1\\') total1++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907327,
                "title": "c-dp-solution",
                "content": "The only possible 3 letters string is \\'101\\' and \\'010\\'.\\nSo, we just need to find the no. of times the subsequences \\'101\\' and \\'010\\' occurs in the given string and add them.\\n\\n```\\nclass Solution {\\npublic:\\n    long long count(string a, string b)\\n{\\n    long long m = a.length();\\n    long long n = b.length();\\n    long long dp[m + 1][n + 1] ;\\n        memset(dp,0,sizeof(dp));\\n    for (long long i = 0; i <= n; ++i)\\n        dp[0][i] = 0;\\n    for (long long i = 0; i <= m; ++i)\\n        dp[i][0] = 1;\\n    for (long long i = 1; i <= m; i++)\\n    {\\n        for (long long j = 1; j <= n; j++)\\n        {\\n            if (a[i - 1] == b[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] +dp[i - 1][j];\\n                 \\n            else\\n                dp[i][j] = dp[i - 1][j];\\n        }\\n    }\\n \\n    return dp[m][n];\\n}\\n    long long numberOfWays(string s) {\\n        string s1=\"101\";\\n        string s2=\"010\";\\n        return count(s,s1)+count(s,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long count(string a, string b)\\n{\\n    long long m = a.length();\\n    long long n = b.length();\\n    long long dp[m + 1][n + 1] ;\\n        memset(dp,0,sizeof(dp));\\n    for (long long i = 0; i <= n; ++i)\\n        dp[0][i] = 0;\\n    for (long long i = 0; i <= m; ++i)\\n        dp[i][0] = 1;\\n    for (long long i = 1; i <= m; i++)\\n    {\\n        for (long long j = 1; j <= n; j++)\\n        {\\n            if (a[i - 1] == b[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] +dp[i - 1][j];\\n                 \\n            else\\n                dp[i][j] = dp[i - 1][j];\\n        }\\n    }\\n \\n    return dp[m][n];\\n}\\n    long long numberOfWays(string s) {\\n        string s1=\"101\";\\n        string s2=\"010\";\\n        return count(s,s1)+count(s,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907321,
                "title": "c-solution-simple-easy-solution-with-comments",
                "content": "->for \"010\" case count number of \"0\"s from the first index of \"0\" to last index \"0\".\\n->then traverse from first index of \"0\" to last index of \"0\" keeping a \\'counter\\' of how many \"0\"s we have passed.\\n->whenever we found a \"1\" we multiply the count of \"0\"s we have passed with the number of \"0\"s left and add it to the result.\\n\\nfor the \"101\" case we do same as above from the first index of \"1\" and last index of \"1\".\\n\\n```\\nclass Solution {\\n    long long int fun0(string s,int start,int last) {\\n        int n0=0,n1=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'1\\')\\n                n1++;\\n            else\\n                n0++;\\n        }\\n        int curr=0;\\n        long long int res=0;\\n        for(int i=start;i<=last;i++) {\\n            if(s[i]==\\'1\\')\\n                res+=(curr*(n0-curr));\\n            else\\n                curr++;\\n        }\\n        return res;\\n    }\\n    long long int fun1(string s,int start,int last) {\\n        int n0=0,n1=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'0\\')\\n                n0++;\\n            else\\n                n1++;\\n        }\\n        int curr=0;\\n        long long int res=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'0\\')\\n\\t\\t\\t\\tres+=(curr*(n1-curr));\\n            else\\n                curr++;\\n        }\\n        return res;\\n    }\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n\\t\\t/*\\n\\t\\t   f0 = first index of \"0\"\\n\\t\\t   f1 = first index of \"1\"\\n\\t\\t   l0 = last index of \"0\"\\n\\t\\t   l1 = last index of \"1\"\\n\\t\\t*/\\n        int f0 = -1,l0 = -1, f1 = -1,l1 = -1;\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'0\\') {\\n                f0 = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'0\\') {\\n                l0 = i;\\n                break;\\n            }\\n        }\\n        long long int res = 0;\\n        if(f0>=0)\\n            res = fun0(s,f0,l0);     //for \"010\" case\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\') {\\n                f1 = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'1\\') {\\n                l1 = i;\\n                break;\\n            }\\n        }\\n        long long int sum=0;\\n        if(f1>=0)\\n            sum = fun1(s,f1,l1);    //for \"101\" case\\n        return res+sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long int fun0(string s,int start,int last) {\\n        int n0=0,n1=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'1\\')\\n                n1++;\\n            else\\n                n0++;\\n        }\\n        int curr=0;\\n        long long int res=0;\\n        for(int i=start;i<=last;i++) {\\n            if(s[i]==\\'1\\')\\n                res+=(curr*(n0-curr));\\n            else\\n                curr++;\\n        }\\n        return res;\\n    }\\n    long long int fun1(string s,int start,int last) {\\n        int n0=0,n1=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'0\\')\\n                n0++;\\n            else\\n                n1++;\\n        }\\n        int curr=0;\\n        long long int res=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'0\\')\\n\\t\\t\\t\\tres+=(curr*(n1-curr));\\n            else\\n                curr++;\\n        }\\n        return res;\\n    }\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n\\t\\t/*\\n\\t\\t   f0 = first index of \"0\"\\n\\t\\t   f1 = first index of \"1\"\\n\\t\\t   l0 = last index of \"0\"\\n\\t\\t   l1 = last index of \"1\"\\n\\t\\t*/\\n        int f0 = -1,l0 = -1, f1 = -1,l1 = -1;\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'0\\') {\\n                f0 = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'0\\') {\\n                l0 = i;\\n                break;\\n            }\\n        }\\n        long long int res = 0;\\n        if(f0>=0)\\n            res = fun0(s,f0,l0);     //for \"010\" case\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\') {\\n                f1 = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'1\\') {\\n                l1 = i;\\n                break;\\n            }\\n        }\\n        long long int sum=0;\\n        if(f1>=0)\\n            sum = fun1(s,f1,l1);    //for \"101\" case\\n        return res+sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907213,
                "title": "short-one-pass-python-solution",
                "content": "```\\na = b = c = d = result = 0\\nfor t in s:\\n\\tif t == \"0\":\\n\\t\\tresult += b\\n\\t\\ta += 1\\n\\t\\td += c\\n\\telse:\\n\\t\\tresult += d\\n\\t\\tc += 1\\n\\t\\tb += a\\nreturn result\\n```\\n\\na: number of \"0\"s\\nb: number of \"01\"s\\nc: number of \"1\"s\\nd: number of \"10\"s\\nAdd b to result if \"0\".\\nAdd d to result if \"1\".\\nAdd a to b if \"1\".\\nAdd c to d if \"0\".",
                "solutionTags": [],
                "code": "```\\na = b = c = d = result = 0\\nfor t in s:\\n\\tif t == \"0\":\\n\\t\\tresult += b\\n\\t\\ta += 1\\n\\t\\td += c\\n\\telse:\\n\\t\\tresult += d\\n\\t\\tc += 1\\n\\t\\tb += a\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907140,
                "title": "simple-observation-c-self-explanatory-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans = 0;\\n        long long on = 0, zr = 0;\\n        int n = s.size();\\n        for(char ch : s) {\\n            if(ch == \\'1\\') on++;\\n            if(ch == \\'0\\') zr++;\\n        }\\n      \\n        long long cur_zr = 0, cur_on = 0;\\n        if(s[0] == \\'0\\') cur_zr++;\\n        else cur_on++;\\n        \\n        for(int i = 1; i<n - 1; i++){\\n            if(s[i] == \\'0\\'){\\n                cur_zr++;\\n                ans = ans + (cur_on * (on - cur_on));\\n            }\\n            else {\\n                cur_on++;\\n                ans = ans + (cur_zr * (zr - cur_zr));\\n            }\\n        }\\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans = 0;\\n        long long on = 0, zr = 0;\\n        int n = s.size();\\n        for(char ch : s) {\\n            if(ch == \\'1\\') on++;\\n            if(ch == \\'0\\') zr++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907098,
                "title": "prefix-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.length();\\n        vector<int> lz(n,0),rz(n,0);\\n        vector<int> lo(n,0),ro(n,0);\\n        int c=0;\\n\\t\\t// count of 0\\'s before i and 1\\'s\\n        if(s[0]==\\'0\\')\\n            lz[0]=1;\\n        else\\n            lo[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                lz[i]=lz[i-1]+1,c++;\\n            else\\n                lz[i]=lz[i-1];\\n            if(s[i]==\\'1\\')\\n                lo[i]=lo[i-1]+1;\\n            else\\n                lo[i]=lo[i-1];\\n        }\\n\\t\\t\\n\\t\\t// count of 0\\'s after i and 1\\'s\\n        if(s[n-1]==\\'0\\')\\n            rz[n-1]=1;\\n        else\\n            ro[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n                rz[i]=rz[i+1]+1;\\n            else\\n                rz[i]=rz[i+1];\\n            if(s[i]==\\'1\\')\\n                ro[i]=ro[i+1]+1;\\n            else\\n                ro[i]=ro[i+1];\\n        }\\n        long long ans=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n\\t\\t    // count of 1\\'s before i * count of 1\\'s after \\n            if(s[i]==\\'0\\')\\n                ans+= ro[i]*lo[i];\\n\\t\\t\\t\\t\\n\\t\\t\\t// count of 0\\'s before * count of 0\\'s after \\n            if(s[i]==\\'1\\')\\n                ans+= rz[i]*lz[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.length();\\n        vector<int> lz(n,0),rz(n,0);\\n        vector<int> lo(n,0),ro(n,0);\\n        int c=0;\\n\\t\\t// count of 0\\'s before i and 1\\'s\\n        if(s[0]==\\'0\\')\\n            lz[0]=1;\\n        else\\n            lo[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                lz[i]=lz[i-1]+1,c++;\\n            else\\n                lz[i]=lz[i-1];\\n            if(s[i]==\\'1\\')\\n                lo[i]=lo[i-1]+1;\\n            else\\n                lo[i]=lo[i-1];\\n        }\\n\\t\\t\\n\\t\\t// count of 0\\'s after i and 1\\'s\\n        if(s[n-1]==\\'0\\')\\n            rz[n-1]=1;\\n        else\\n            ro[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n                rz[i]=rz[i+1]+1;\\n            else\\n                rz[i]=rz[i+1];\\n            if(s[i]==\\'1\\')\\n                ro[i]=ro[i+1]+1;\\n            else\\n                ro[i]=ro[i+1];\\n        }\\n        long long ans=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n\\t\\t    // count of 1\\'s before i * count of 1\\'s after \\n            if(s[i]==\\'0\\')\\n                ans+= ro[i]*lo[i];\\n\\t\\t\\t\\t\\n\\t\\t\\t// count of 0\\'s before * count of 0\\'s after \\n            if(s[i]==\\'1\\')\\n                ans+= rz[i]*lz[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907080,
                "title": "logic-easiest-complexity-analysis-c",
                "content": "## **Solution**\\n\\n### **LOGIC**\\n* Lets take s =\"100001\", now number of ways to select the building is 4, which is equal to the number of ```0``` between ```1``` at first index and ```1``` at last index. \\n\\n* We need to do this with all ```1``` in any string, simply take all compbination of non-adjacent ```1``` and find number of building just like we did in above example. Means for each pair of non-adjacent ```1```, number of ```0``` between them will add to our solution\\n\\n* Now there are two cases only ```101``` or ``010``. And what i explained is for case ```101```. We need to do the same process for the case ```010```.\\n\\n* But if you follow this approach bilndly, then you will get TLE as I did :(\\n\\n* So we need to use some Maths here. Scary right??.....Na\\n\\n* Let array = [a, b, c, d, e]. where ```(b - a)``` is the number of ```0``` between ```b``` and ```a```.\\n* So what we wnat to achive is this\\n\\t* ```(e - d)``` + ```(e - c)``` + ```(e - b)``` + ```(e - a)``` + ```(d - c)``` + ```(d - b)``` + ```(d - a)``` +```(c - b)``` + ```(c - a)``` + ```(b - a)```\\n\\t* Now for calculation of all these values we need nested ```for``` loop and that will give quadratic compleity and hebce ```TLE```\\n\\t* But as you can observer that using math and simple presence of mind you can do that in one pass only. And we can get ```AC``` with flying colors :)\\n\\n\\n#### **Code**\\n__TLE__\\n```cpp\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<pair<int, int>> ones, zeros;\\n        long long sol = 0, one = 0, zero = 0;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'1\\') {\\n                ones.push_back(make_pair(i, zero));\\n                one++;\\n            }\\n            else {\\n                zeros.push_back(make_pair(i, one));\\n                zero++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < ones.size(); i++) {\\n            for (int j = i + 1; j < ones.size(); j++) {\\n                sol += ones[j].second  - ones[i].second;                \\n            }\\n        }\\n        for (int i = 0; i < zeros.size(); i++) {\\n            for (int j = i + 1; j < zeros.size(); j++) {\\n                sol += zeros[j].second  - zeros[i].second;                \\n            }\\n        }\\n        \\n        return sol;\\n        \\n        \\n    }\\n};\\n```\\n__AC__\\n```cpp\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<long long> ones, zeros;\\n        long long sol = 0, one = 0, zero = 0;\\n        \\n        for (auto x : s) {\\n            if (x == \\'1\\') {\\n                ones.push_back(zero);\\n                one++;\\n            }\\n            else {\\n                zeros.push_back(one);\\n                zero++;\\n            }\\n        }\\n        \\n        long long o = ones.size(), z = zeros.size();\\n        if (o == 0 || z == 0) {\\n            return 0;\\n        }\\n        long long temp;\\n        \\n        temp = o - 1;\\n        for (long long i = 0 ; i < o / 2; i++) {\\n            sol -= (ones[i] * (temp));\\n            temp -= 2;\\n        }\\n        temp = (o % 2 == 0) ? 1 : 2;\\n        for (long long i = round(o / 2.0); i < o; i++) {\\n            sol += (ones[i] * (temp));\\n            temp += 2;\\n        }\\n        \\n        temp = z - 1;\\n        for (long long i = 0; i < z / 2; i++) {\\n            sol -= (zeros[i] * (temp));\\n            temp -= 2;\\n        }\\n        temp = (z % 2 == 0) ? 1 : 2;\\n        for (long long i = round((z / 2.0)); i < z; i++) {\\n            sol += (zeros[i] * (temp));\\n            temp += 2;\\n        }\\n        \\n        return sol;\\n        \\n        \\n    }\\n};\\n```\\n\\n## **Complexity**\\n\\n##### __Apporach : 1__  \\n##### Time Complexity:  **O(size_of_s)**\\n\\n##### Space Complexity: **O(size_of_s)**\\n\\n\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```0```\n```1```\n```1```\n```1```\n```1```\n```1```\n```0```\n```101```\n```101```\n```010```\n```(b - a)```\n```0```\n```b```\n```a```\n```(e - d)```\n```(e - c)```\n```(e - b)```\n```(e - a)```\n```(d - c)```\n```(d - b)```\n```(d - a)```\n```(c - b)```\n```(c - a)```\n```(b - a)```\n```for```\n```TLE```\n```AC```\n```cpp\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<pair<int, int>> ones, zeros;\\n        long long sol = 0, one = 0, zero = 0;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'1\\') {\\n                ones.push_back(make_pair(i, zero));\\n                one++;\\n            }\\n            else {\\n                zeros.push_back(make_pair(i, one));\\n                zero++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < ones.size(); i++) {\\n            for (int j = i + 1; j < ones.size(); j++) {\\n                sol += ones[j].second  - ones[i].second;                \\n            }\\n        }\\n        for (int i = 0; i < zeros.size(); i++) {\\n            for (int j = i + 1; j < zeros.size(); j++) {\\n                sol += zeros[j].second  - zeros[i].second;                \\n            }\\n        }\\n        \\n        return sol;\\n        \\n        \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<long long> ones, zeros;\\n        long long sol = 0, one = 0, zero = 0;\\n        \\n        for (auto x : s) {\\n            if (x == \\'1\\') {\\n                ones.push_back(zero);\\n                one++;\\n            }\\n            else {\\n                zeros.push_back(one);\\n                zero++;\\n            }\\n        }\\n        \\n        long long o = ones.size(), z = zeros.size();\\n        if (o == 0 || z == 0) {\\n            return 0;\\n        }\\n        long long temp;\\n        \\n        temp = o - 1;\\n        for (long long i = 0 ; i < o / 2; i++) {\\n            sol -= (ones[i] * (temp));\\n            temp -= 2;\\n        }\\n        temp = (o % 2 == 0) ? 1 : 2;\\n        for (long long i = round(o / 2.0); i < o; i++) {\\n            sol += (ones[i] * (temp));\\n            temp += 2;\\n        }\\n        \\n        temp = z - 1;\\n        for (long long i = 0; i < z / 2; i++) {\\n            sol -= (zeros[i] * (temp));\\n            temp -= 2;\\n        }\\n        temp = (z % 2 == 0) ? 1 : 2;\\n        for (long long i = round((z / 2.0)); i < z; i++) {\\n            sol += (zeros[i] * (temp));\\n            temp += 2;\\n        }\\n        \\n        return sol;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332176,
                "title": "intuitive-dp-solution-o-n-time-and-constant-space-based-on-0-1-knapsack-take-not-take",
                "content": "# Intuition\\nThe problem is similar to 0-1 Knapsack,for each character in the string we have 2 options,either to take the building or not.\\n\\n# Approach\\n\\nWe know that in order to select 3 buildings such that no two consecutives are similar, we have only two options, \"010\" and \"101\".\\n\\n\\nWe can find number of subsequences in the actual string s corresponding to \"010\" and \"101\" indepedently using take not-take technique and add them to get the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the length of string s.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        long long ans = 0;\\n        string a = \"101\",b = \"010\";\\n        vector<long long> prev(4,0) , curr(4,0);\\n\\n        prev[0] = 1;\\n\\n        for(int i = 1;i<=n;i++){\\n            curr[0] = 1;\\n            for(int j = 1;j<=3;j++){\\n                long long nt = prev[j];\\n                long long t = 0;\\n                if(s[i-1] == a[j-1]){\\n                    t = curr[j-1];\\n                }\\n                curr[j] = nt + t;\\n            }\\n\\n            prev = curr;\\n        }\\n        ans += prev[3];\\n\\n        for(int i = 0;i<4;i++){\\n            prev[i] = 0;\\n            curr[i] = 0;\\n        }\\n        prev[0] = 1;\\n        for(int i = 1;i<=n;i++){\\n            curr[0] = 1;\\n            for(int j = 1;j<=3;j++){\\n                long long nt = prev[j];\\n                long long t = 0;\\n                if(s[i-1] == b[j-1]){\\n                    t = curr[j-1];\\n                }\\n\\n                curr[j] = nt + t;\\n            }\\n            prev = curr;\\n        }\\n        ans += prev[3];\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        long long ans = 0;\\n        string a = \"101\",b = \"010\";\\n        vector<long long> prev(4,0) , curr(4,0);\\n\\n        prev[0] = 1;\\n\\n        for(int i = 1;i<=n;i++){\\n            curr[0] = 1;\\n            for(int j = 1;j<=3;j++){\\n                long long nt = prev[j];\\n                long long t = 0;\\n                if(s[i-1] == a[j-1]){\\n                    t = curr[j-1];\\n                }\\n                curr[j] = nt + t;\\n            }\\n\\n            prev = curr;\\n        }\\n        ans += prev[3];\\n\\n        for(int i = 0;i<4;i++){\\n            prev[i] = 0;\\n            curr[i] = 0;\\n        }\\n        prev[0] = 1;\\n        for(int i = 1;i<=n;i++){\\n            curr[0] = 1;\\n            for(int j = 1;j<=3;j++){\\n                long long nt = prev[j];\\n                long long t = 0;\\n                if(s[i-1] == b[j-1]){\\n                    t = curr[j-1];\\n                }\\n\\n                curr[j] = nt + t;\\n            }\\n            prev = curr;\\n        }\\n        ans += prev[3];\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005617,
                "title": "python-prefix-sum-top-down-dp-solutions-tle",
                "content": "- Prefix Sum\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        prefixes = [[0, 0] for _ in range(len(s))] \\n        for i in range(len(s)):\\n            zero_count = prefixes[i][0] + 1 if s[i] == \"0\" else 0\\n            one_count = prefixes[i][1] + 1 if s[i] == \"1\" else 0\\n\\n            if i > 0:\\n                zero_count += prefixes[i - 1][0]\\n                one_count += prefixes[i - 1][1]\\n            \\n            prefixes[i] = [zero_count, one_count]         \\n\\n        res = 0\\n        for i in range(len(s)):\\n            if s[i] == \"0\":\\n                res += prefixes[i][1] * (prefixes[-1][1] - prefixes[i][1])\\n            elif s[i] == \"1\":\\n                res += prefixes[i][0] * (prefixes[-1][0] - prefixes[i][0])\\n\\n        return res\\n```\\n\\n- Top-down DFS + Memoization (TLE)\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        memo = {}\\n        def dfs(idx, path):\\n            if (idx, path) in memo:\\n                return memo[(idx, path)]\\n    \\n            if len(path) == 3:\\n                return 1\\n            if idx >= len(s):\\n                return 0\\n                    \\n            res = 0\\n            for i in range(idx + 1, len(s)):\\n                if not path or (path and path[-1] != s[i]):\\n                    res += dfs(i, path + s[i])\\n            \\n            memo[(idx, path)] = res\\n            return res\\n        \\n        return dfs(-1, \"\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        prefixes = [[0, 0] for _ in range(len(s))] \\n        for i in range(len(s)):\\n            zero_count = prefixes[i][0] + 1 if s[i] == \"0\" else 0\\n            one_count = prefixes[i][1] + 1 if s[i] == \"1\" else 0\\n\\n            if i > 0:\\n                zero_count += prefixes[i - 1][0]\\n                one_count += prefixes[i - 1][1]\\n            \\n            prefixes[i] = [zero_count, one_count]         \\n\\n        res = 0\\n        for i in range(len(s)):\\n            if s[i] == \"0\":\\n                res += prefixes[i][1] * (prefixes[-1][1] - prefixes[i][1])\\n            elif s[i] == \"1\":\\n                res += prefixes[i][0] * (prefixes[-1][0] - prefixes[i][0])\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        memo = {}\\n        def dfs(idx, path):\\n            if (idx, path) in memo:\\n                return memo[(idx, path)]\\n    \\n            if len(path) == 3:\\n                return 1\\n            if idx >= len(s):\\n                return 0\\n                    \\n            res = 0\\n            for i in range(idx + 1, len(s)):\\n                if not path or (path and path[-1] != s[i]):\\n                    res += dfs(i, path + s[i])\\n            \\n            memo[(idx, path)] = res\\n            return res\\n        \\n        return dfs(-1, \"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753063,
                "title": "5-line-python-solution-easy-fast",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        x0,x1,x01,x10,ans = 0,0,0,0,0\\n        for i in s:\\n            if i==\"1\": x1+=1;x01+=x0;ans+=x10\\n            else: x0+=1;x10+=x1;ans+=x01\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        x0,x1,x01,x10,ans = 0,0,0,0,0\\n        for i in s:\\n            if i==\"1\": x1+=1;x01+=x0;ans+=x10\\n            else: x0+=1;x10+=x1;ans+=x01\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2704850,
                "title": "java-hindi",
                "content": "Dekho sabse pehle to har index pe , kitne 0 ya 1 aaye h ab tak vo count krlo,  uske liye 2 1d array bana lo\\nn0 -> (no of zeros at that index)\\nn1 -> (no fo 1s at that index)\\nneeche dekho pehle ye kaise kiya\\nSECOND HALF \\nab dekho, hume aisa nhi chaiye ki consetive 1 and 0 aaye, of length 3 only\\ntotal possible permutations of 0 and 1, of len 3, are 2^3-> 8\\n_ _ _ har index pe ya 0 ayega ya 1, so 2*2*2\\n000 \\u274C\\n001 \\u274C\\n100 \\u274C\\n101 \\u274C\\n010 \\u2714\\n101 \\u2714\\n111  \\u274C\\n011  \\u274C\\njinke aage X hai, un sab be consevie 1 ya 0 aa rha, do sirf 2 case bnte hain\\n101, 010\\nAb agar 0 h to dekh lo uske left and right side pe, 1 h ya nhi, left to humne store kiya hua, no of zeros at that index aaray me, \\ntotal bhi pta h hume, ab agar total 1 5 ho and 3 us idnex tak h , to aage 2 honge hi, to total combinations will be no of 1s at left * no if 1s at right - > for 010\\n   no of os at left * no of zeros at right -> 101\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n\\t// 2 arrays rakhe hain, to store count of 0 and 1\\n        int[] n0 = new int[s.length()];\\n        int[] n1 = new int[s.length()];\\n        int c0 = 0,c1=0;\\n        for(int i=0;i<s.length();i++) {\\n\\t\\t// agar 0 aaya to 0 ka count bhada diya\\n            if(s.charAt(i) == \\'0\\')\\n                 c0++;\\n            else\\n\\t\\t\\t// nhi to 1 ka bhada diya\\n                c1++;\\n\\t\\t\\t\\t// jo bhi bhada ho hume to us point tk , kitne 0 ya 1 h, rakhna h naa, \\n            n0[i] = c0;\\n            n1[i] = c1;\\n        }\\n\\t\\t// ab upar jaao second half padhne\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++) {\\n            if(s.charAt(i)==\\'0\\') \\n\\t\\t\\t//  no of ones till that index * (no of 1s at right - total 1\\'s - 1\\'s till that index)\\n                ans += n1[i]*(c1-n1[i]);\\n            else \\n                ans += n0[i]*(c0-n0[i]);\\n        }\\n        return ans;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n\\t// 2 arrays rakhe hain, to store count of 0 and 1\\n        int[] n0 = new int[s.length()];\\n        int[] n1 = new int[s.length()];\\n        int c0 = 0,c1=0;\\n        for(int i=0;i<s.length();i++) {\\n\\t\\t// agar 0 aaya to 0 ka count bhada diya\\n            if(s.charAt(i) == \\'0\\')\\n                 c0++;\\n            else\\n\\t\\t\\t// nhi to 1 ka bhada diya\\n                c1++;\\n\\t\\t\\t\\t// jo bhi bhada ho hume to us point tk , kitne 0 ya 1 h, rakhna h naa, \\n            n0[i] = c0;\\n            n1[i] = c1;\\n        }\\n\\t\\t// ab upar jaao second half padhne\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++) {\\n            if(s.charAt(i)==\\'0\\') \\n\\t\\t\\t//  no of ones till that index * (no of 1s at right - total 1\\'s - 1\\'s till that index)\\n                ans += n1[i]*(c1-n1[i]);\\n            else \\n                ans += n0[i]*(c0-n0[i]);\\n        }\\n        return ans;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549856,
                "title": "python-simple-single-pass-dp-solution-faster-than-99",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        noOf0, noOf1, noOf01, noOf10, res = 0, 0, 0, 0, 0\\n        for building in s:\\n            if building == \\'1\\':\\n                noOf1 += 1\\n                noOf01 += noOf0\\n                res += noOf10\\n            else:\\n                noOf0 += 1\\n                noOf10 += noOf1\\n                res += noOf01\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        noOf0, noOf1, noOf01, noOf10, res = 0, 0, 0, 0, 0\\n        for building in s:\\n            if building == \\'1\\':\\n                noOf1 += 1\\n                noOf01 += noOf0\\n                res += noOf10\\n            else:\\n                noOf0 += 1\\n                noOf10 += noOf1\\n                res += noOf01\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454063,
                "title": "only-one-for-loop-simple-solution-o-n-o-1",
                "content": "There are only 2 valid string of length 3 ie; `101 and 010`.\\n\\nIf we are at index pointing to character `1` we need to count all the different `01` combinations as it would form string `101`.\\n\\nSame goes for `0`, if we are pointing to zero we need to count all different `10` \\nas it would form another valid string `010`.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans=0, ones=0, zeros=0, oneZeros=0, zeroOnes=0;\\n        \\n        for(int i=s.length()-1; i>-1; i--)\\n            if(s[i] == \\'1\\') oneZeros+=zeros, ones++, ans+=zeroOnes;\\n            else zeroOnes+=ones, zeros++, ans+=oneZeros;\\n        \\n        return ans;        \\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans=0, ones=0, zeros=0, oneZeros=0, zeroOnes=0;\\n        \\n        for(int i=s.length()-1; i>-1; i--)\\n            if(s[i] == \\'1\\') oneZeros+=zeros, ones++, ans+=zeroOnes;\\n            else zeroOnes+=ones, zeros++, ans+=oneZeros;\\n        \\n        return ans;        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252520,
                "title": "one-pass-o-n-java-four-vars",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        char[] str = s.toCharArray();\\n        long count10 = 0;\\n        long count01 = 0;\\n        long total = 0;\\n        long count1 = 0;\\n        long count0 = 0;\\n        for (int i = 1; i < str.length; i++) {\\n            if (str[i-1] == \\'1\\') {\\n                count1++;\\n                count01 += count0;\\n            } else {\\n                count0++;\\n                count10 += count1;\\n            }\\n            if (str[i] == \\'1\\') total += count10;\\n            else total += count01;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        char[] str = s.toCharArray();\\n        long count10 = 0;\\n        long count01 = 0;\\n        long total = 0;\\n        long count1 = 0;\\n        long count0 = 0;\\n        for (int i = 1; i < str.length; i++) {\\n            if (str[i-1] == \\'1\\') {\\n                count1++;\\n                count01 += count0;\\n            } else {\\n                count0++;\\n                count10 += count1;\\n            }\\n            if (str[i] == \\'1\\') total += count10;\\n            else total += count01;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121702,
                "title": "c-search-for-010-and-101",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long numberOfWays(string s) {\\n\\t\\t\\t\\tlong long res = 0;\\n\\t\\t\\t\\tlong long a = 0, b = 0, c = 0;\\n\\t\\t\\t\\t//search for 010\\n\\t\\t\\t\\tfor(auto i: s){\\n\\t\\t\\t\\t\\tif(i==\\'0\\')a += 1;\\n\\t\\t\\t\\t\\tif(i==\\'1\\')b += a;\\n\\t\\t\\t\\t\\tif(i==\\'0\\')c += b;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres += c;\\n\\n\\t\\t\\t\\ta = 0;\\n\\t\\t\\t\\tb = 0;\\n\\t\\t\\t\\tc = 0;\\n\\t\\t\\t\\t//search for 101\\n\\t\\t\\t\\tfor(auto i: s){\\n\\t\\t\\t\\t\\tif(i==\\'1\\')a += 1;\\n\\t\\t\\t\\t\\tif(i==\\'0\\')b += a;\\n\\t\\t\\t\\t\\tif(i==\\'1\\')c += b;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res+c;\\n\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long numberOfWays(string s) {\\n\\t\\t\\t\\tlong long res = 0;\\n\\t\\t\\t\\tlong long a = 0, b = 0, c = 0;\\n\\t\\t\\t\\t//search for 010\\n\\t\\t\\t\\tfor(auto i: s){\\n\\t\\t\\t\\t\\tif(i==\\'0\\')a += 1;\\n\\t\\t\\t\\t\\tif(i==\\'1\\')b += a;\\n\\t\\t\\t\\t\\tif(i==\\'0\\')c += b;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1956066,
                "title": "c-code-for-beginners-all-technique-in-one-place-easy-to-understand",
                "content": "**1. RECURSION+MEMOIZATION(TAKE or IGNORE)**\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][2];\\n    long long helper(string &S, int curr, int k, int flag){\\n        if(k==0){\\n            return 1;\\n        }\\n        if(curr==S.size()){\\n            return 0;\\n        }\\n        if(dp[curr][k][flag]!=-1){\\n            return dp[curr][k][flag];\\n        }\\n        long long res=helper(S,curr+1,k,flag);  // IGNORING THE CURRENT BUILDING\\n        if(flag==true && S[curr]==\\'1\\'){\\n            res+=helper(S,curr+1,k-1,!flag);  //TAKE BUILDING AND REVERSE FLAG\\n        }\\n        else if(flag==false && S[curr]==\\'0\\'){\\n            res+=helper(S,curr+1,k-1,!flag);            \\n        }\\n        return dp[curr][k][flag]=res;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// flag==true means 1 numbered building and vice versa\\n        return helper(s,0,3,true)+helper(s,0,3,false);  \\n    }\\n};\\n```\\n\\n**2.  COUNT \"010\" AND \"101\" SUBSEQUENCES IN STRING (Both Recursive and Iterative)**\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4];\\n    long long countSubseq(string &S, string T, int n, int m){\\n        if(m==0){\\n            return 1;\\n        }\\n        if(n==0){\\n            return 0;\\n        }\\n        if(dp[n][m]!=-1){\\n            return dp[n][m];\\n        }\\n        if(S[n-1]==T[m-1]){\\n            return dp[n][m]=countSubseq(S,T,n-1,m-1)+countSubseq(S,T,n-1,m); \\n        }\\n        return dp[n][m]=countSubseq(S,T,n-1,m);\\n    } //RECURSIVE COUNT TECH  (TLE)\\n    \\n//------------------------- ---------------------------------------------------------------------\\n    \\n    long long countSubseq(string &S, string pat, int n, int m){\\n        long long DP[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            DP[0][i]=0;\\n        }\\n        for(int i=0;i<=n;i++){\\n            DP[i][0]=1;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(S[i-1]==pat[j-1]){\\n                    DP[i][j]=DP[i-1][j-1]+DP[i-1][j];\\n                }\\n                else{\\n                    DP[i][j]=DP[i-1][j];\\n                }\\n            }\\n        }\\n        return DP[n][m];\\n    }  //ITERATIVE VERSION\\n\\n//------------------------- ---------------------------------------------------------------------\\n\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp)); \\n        long long Subsequence101=countSubseq(s,\"101\",s.size(),3);\\n        memset(dp,-1,sizeof(dp)); // resetting for next function\\n        long long Subsequence010=countSubseq(s,\"010\",s.size(),3);\\n        return Subsequence101+Subsequence010;\\n    }\\n};\\n```\\n\\n**3. GREEDY TECHNIQUE**\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long res=0;\\n        int one=0;\\n        int zero=0;\\n        for(auto e: s){\\n            if(e==\\'0\\'){\\n                zero++;\\n            }\\n            else{\\n                one++;\\n            }\\n        }\\n        int currentOne=0;\\n        int currentZero=0;\\n        for(auto e: s){\\n            if(e==\\'0\\'){\\n                res+=(one*currentOne);\\n                zero--;\\n                currentZero++;\\n            }\\n            else{\\n                res+=(zero*currentZero);\\n                one--;\\n                currentOne++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**4. PREFIX SUMS OF ZERO AND ONE**\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        vector<int> zero(n,0);\\n        vector<int> one(n,0);\\n        s[0]==\\'0\\' ? zero[0]=1 : one[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                zero[i]=zero[i-1]+1;\\n            }\\n            else{\\n                zero[i]=zero[i-1];\\n            }\\n            if(s[i]==\\'1\\'){\\n                one[i]=one[i-1]+1;\\n            }\\n            else{\\n                one[i]=one[i-1];\\n            }\\n        }\\n        long long res=0;\\n        for(int i=1;i<n-1;i++){\\n            if(s[i]==\\'0\\'){\\n                int leftSide1=one[i-1];\\n                int rightSide1=one[n-1]-one[i+1]+(s[i+1]==\\'1\\' ? 1 : 0);\\n                res+=(rightSide1*leftSide1);\\n            }\\n            else{\\n                int leftSide0=zero[i-1];\\n                int rightSide0=zero[n-1]-zero[i+1]+(s[i+1]==\\'0\\' ? 1 : 0);\\n                res+=(rightSide0*leftSide0);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][2];\\n    long long helper(string &S, int curr, int k, int flag){\\n        if(k==0){\\n            return 1;\\n        }\\n        if(curr==S.size()){\\n            return 0;\\n        }\\n        if(dp[curr][k][flag]!=-1){\\n            return dp[curr][k][flag];\\n        }\\n        long long res=helper(S,curr+1,k,flag);  // IGNORING THE CURRENT BUILDING\\n        if(flag==true && S[curr]==\\'1\\'){\\n            res+=helper(S,curr+1,k-1,!flag);  //TAKE BUILDING AND REVERSE FLAG\\n        }\\n        else if(flag==false && S[curr]==\\'0\\'){\\n            res+=helper(S,curr+1,k-1,!flag);            \\n        }\\n        return dp[curr][k][flag]=res;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// flag==true means 1 numbered building and vice versa\\n        return helper(s,0,3,true)+helper(s,0,3,false);  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4];\\n    long long countSubseq(string &S, string T, int n, int m){\\n        if(m==0){\\n            return 1;\\n        }\\n        if(n==0){\\n            return 0;\\n        }\\n        if(dp[n][m]!=-1){\\n            return dp[n][m];\\n        }\\n        if(S[n-1]==T[m-1]){\\n            return dp[n][m]=countSubseq(S,T,n-1,m-1)+countSubseq(S,T,n-1,m); \\n        }\\n        return dp[n][m]=countSubseq(S,T,n-1,m);\\n    } //RECURSIVE COUNT TECH  (TLE)\\n    \\n//------------------------- ---------------------------------------------------------------------\\n    \\n    long long countSubseq(string &S, string pat, int n, int m){\\n        long long DP[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            DP[0][i]=0;\\n        }\\n        for(int i=0;i<=n;i++){\\n            DP[i][0]=1;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(S[i-1]==pat[j-1]){\\n                    DP[i][j]=DP[i-1][j-1]+DP[i-1][j];\\n                }\\n                else{\\n                    DP[i][j]=DP[i-1][j];\\n                }\\n            }\\n        }\\n        return DP[n][m];\\n    }  //ITERATIVE VERSION\\n\\n//------------------------- ---------------------------------------------------------------------\\n\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp)); \\n        long long Subsequence101=countSubseq(s,\"101\",s.size(),3);\\n        memset(dp,-1,sizeof(dp)); // resetting for next function\\n        long long Subsequence010=countSubseq(s,\"010\",s.size(),3);\\n        return Subsequence101+Subsequence010;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long res=0;\\n        int one=0;\\n        int zero=0;\\n        for(auto e: s){\\n            if(e==\\'0\\'){\\n                zero++;\\n            }\\n            else{\\n                one++;\\n            }\\n        }\\n        int currentOne=0;\\n        int currentZero=0;\\n        for(auto e: s){\\n            if(e==\\'0\\'){\\n                res+=(one*currentOne);\\n                zero--;\\n                currentZero++;\\n            }\\n            else{\\n                res+=(zero*currentZero);\\n                one--;\\n                currentOne++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        vector<int> zero(n,0);\\n        vector<int> one(n,0);\\n        s[0]==\\'0\\' ? zero[0]=1 : one[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                zero[i]=zero[i-1]+1;\\n            }\\n            else{\\n                zero[i]=zero[i-1];\\n            }\\n            if(s[i]==\\'1\\'){\\n                one[i]=one[i-1]+1;\\n            }\\n            else{\\n                one[i]=one[i-1];\\n            }\\n        }\\n        long long res=0;\\n        for(int i=1;i<n-1;i++){\\n            if(s[i]==\\'0\\'){\\n                int leftSide1=one[i-1];\\n                int rightSide1=one[n-1]-one[i+1]+(s[i+1]==\\'1\\' ? 1 : 0);\\n                res+=(rightSide1*leftSide1);\\n            }\\n            else{\\n                int leftSide0=zero[i-1];\\n                int rightSide0=zero[n-1]-zero[i+1]+(s[i+1]==\\'0\\' ? 1 : 0);\\n                res+=(rightSide0*leftSide0);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938010,
                "title": "golang-o-n-time-o-1-mem",
                "content": "```go\\nfunc numberOfWays(s string) (ans int64) {\\n    countZero := 0\\n    for i := range s {\\n        if s[i] == \\'0\\' {\\n            countZero++\\n        }\\n    }\\n    countOne := len(s) - countZero\\n   \\n    numZero, numOne := 0, 0\\n    for i := range s {\\n        if s[i] == \\'0\\' {\\n            numZero++\\n            ans += int64(numOne * (countOne - numOne))\\n        } else {\\n            numOne++\\n            ans += int64(numZero * (countZero - numZero))\\n        }\\n    }\\n    \\n    return\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc numberOfWays(s string) (ans int64) {\\n    countZero := 0\\n    for i := range s {\\n        if s[i] == \\'0\\' {\\n            countZero++\\n        }\\n    }\\n    countOne := len(s) - countZero\\n   \\n    numZero, numOne := 0, 0\\n    for i := range s {\\n        if s[i] == \\'0\\' {\\n            numZero++\\n            ans += int64(numOne * (countOne - numOne))\\n        } else {\\n            numOne++\\n            ans += int64(numZero * (countZero - numZero))\\n        }\\n    }\\n    \\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934856,
                "title": "number-of-ways-to-select-buildings",
                "content": "```\\n# Count Number of zero in the array at each position \\n# then after that traverse each index and check if  s[i]==\\'1\\' \\n# How many zeros are before and after them.\\n# multiply before and after to maintain the permutation\\n# do the same when s[i]==\\'0\\'\\n```\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n       int n=s.length(); \\n       vector<int>zero(n,0);\\n       vector<int>one(n,0); \\n       for(int i=0;i<n;i++)\\n       {\\n           if(i==0)\\n           {\\n               zero[i]=s[i]==\\'0\\';\\n               one[i]=s[i]==\\'1\\';\\n           }\\n           else\\n           {\\n               zero[i]=zero[i-1]+(s[i]==\\'0\\');\\n               one[i]=one[i-1]+(s[i]==\\'1\\');\\n           }\\n       }\\n       long long int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(s[i]==\\'0\\')\\n               ans=ans+one[i]*(one[n-1]-one[i]);\\n           else\\n               ans=ans+zero[i]*(zero[n-1]-zero[i]);\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n# Count Number of zero in the array at each position \\n# then after that traverse each index and check if  s[i]==\\'1\\' \\n# How many zeros are before and after them.\\n# multiply before and after to maintain the permutation\\n# do the same when s[i]==\\'0\\'\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n       int n=s.length(); \\n       vector<int>zero(n,0);\\n       vector<int>one(n,0); \\n       for(int i=0;i<n;i++)\\n       {\\n           if(i==0)\\n           {\\n               zero[i]=s[i]==\\'0\\';\\n               one[i]=s[i]==\\'1\\';\\n           }\\n           else\\n           {\\n               zero[i]=zero[i-1]+(s[i]==\\'0\\');\\n               one[i]=one[i-1]+(s[i]==\\'1\\');\\n           }\\n       }\\n       long long int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(s[i]==\\'0\\')\\n               ans=ans+one[i]*(one[n-1]-one[i]);\\n           else\\n               ans=ans+zero[i]*(zero[n-1]-zero[i]);\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915467,
                "title": "o-n-python-two-pass-constant-space-simplest-algorithm",
                "content": "Pick  the middle element s[i] the answer is simpley the count of ! s[i] to its left times the count of ! s[i] to its right. sum over all possible i in range(n).\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        cnt_r, cnt_l = Counter(s), Counter()\\n        res = 0\\n        for i in range(n):\\n            cnt_l[s[i]] += 1\\n            cnt_r[s[i]] -= 1\\n            res += cnt_l[\\'1\\' if s[i] == \\'0\\' else \\'0\\'] * cnt_r[\\'1\\' if s[i] == \\'0\\' else \\'0\\']\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        cnt_r, cnt_l = Counter(s), Counter()\\n        res = 0\\n        for i in range(n):\\n            cnt_l[s[i]] += 1\\n            cnt_r[s[i]] -= 1\\n            res += cnt_l[\\'1\\' if s[i] == \\'0\\' else \\'0\\'] * cnt_r[\\'1\\' if s[i] == \\'0\\' else \\'0\\']\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915169,
                "title": "easiest-python-solution",
                "content": "At first, you will calculate the total number of zeroes and ones in the given string and store their respective counts in the variables total_0 and total 1\\n\\nNow, we need to traverse through the the list and if we find 0, all we need to do is multiple thy number 1s we have encountered before that 0 and number of 1s we will encounter after that 0. The same logic applies to when we find 1 in the string.\\n\\nPlease feel free to comment if you have any doubts.\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        res = 0\\n        curr_1, curr_0, total_1, total_0 = 0, 0, 0, 0\\n        \\n        for bit in s:\\n            if bit == \\'1\\':\\n                total_1 += 1\\n            else:\\n                total_0 += 1\\n        \\n        if s[0] == \\'0\\':\\n            curr_0 += 1\\n        else:\\n            curr_1 += 1\\n\\t\\t\\t\\n        #the first element can\\'t be middle element, even the last one. That\\'s we use 1 to len(s) -1 while iterating through the for loops\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'0\\':\\n                curr_0 += 1\\n                res += curr_1 * (total_1 - curr_1)\\n            else:\\n                curr_1 += 1\\n                res += curr_0 * (total_0 - curr_0)\\n                \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "At first, you will calculate the total number of zeroes and ones in the given string and store their respective counts in the variables total_0 and total 1\\n\\nNow, we need to traverse through the the list and if we find 0, all we need to do is multiple thy number 1s we have encountered before that 0 and number of 1s we will encounter after that 0. The same logic applies to when we find 1 in the string.\\n\\nPlease feel free to comment if you have any doubts.\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        res = 0\\n        curr_1, curr_0, total_1, total_0 = 0, 0, 0, 0\\n        \\n        for bit in s:\\n            if bit == \\'1\\':\\n                total_1 += 1\\n            else:\\n                total_0 += 1\\n        \\n        if s[0] == \\'0\\':\\n            curr_0 += 1\\n        else:\\n            curr_1 += 1\\n\\t\\t\\t\\n        #the first element can\\'t be middle element, even the last one. That\\'s we use 1 to len(s) -1 while iterating through the for loops\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'0\\':\\n                curr_0 += 1\\n                res += curr_1 * (total_1 - curr_1)\\n            else:\\n                curr_1 += 1\\n                res += curr_0 * (total_0 - curr_0)\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1909741,
                "title": "c-easy-no-dp",
                "content": "The main idea is , we want to count the number of 01 subsequences available for each \\'1\\' and the number of 10 subsequences for each \\'0\\' character in the string.\\nCounting the subsequences is pretty simple. We count the number of zeroes and each time we get a \\'1\\' we increase the total count by the count of zeroes\\nEg.\\n110100\\nWe try to make a array maintaining count of all 01 subsequences on the right of given index.\\nThe array will be \\n[5,2,2,0,0,0] for 01 subsequences.\\nRepeat the same procedure for counting 01 subsequences on the right of a given index.\\nCode:\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        // use postfix count here\\n        int n = s.length();\\n        vector<long long> zeroone(n,0);\\n        vector<long long> onezero(n,0);\\n        \\n        int cnt = 0;\\n        long long ways = 0;\\n        // for zeroone\\n        // maintain count of 1s\\n        for(int i = n - 1; i >= 0; --i){\\n            zeroone[i] = ways;\\n            if(s[i] == \\'1\\'){\\n                cnt++;\\n                continue;\\n            }\\n            \\n            ways += cnt;\\n        }\\n        \\n        ways = 0;\\n        cnt = 0;\\n        for(int i  = n  - 1; i >= 0; --i){\\n            \\n            onezero[i] = ways;\\n            if(s[i] == \\'0\\'){\\n                cnt++;\\n                continue;\\n            }\\n            \\n            ways += cnt;\\n        }\\n\\n        ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                // search 10 \\n                ways += onezero[i];\\n            } else{\\n                ways += zeroone[i];\\n            }\\n        }\\n        \\n        return ways;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        // use postfix count here\\n        int n = s.length();\\n        vector<long long> zeroone(n,0);\\n        vector<long long> onezero(n,0);\\n        \\n        int cnt = 0;\\n        long long ways = 0;\\n        // for zeroone\\n        // maintain count of 1s\\n        for(int i = n - 1; i >= 0; --i){\\n            zeroone[i] = ways;\\n            if(s[i] == \\'1\\'){\\n                cnt++;\\n                continue;\\n            }\\n            \\n            ways += cnt;\\n        }\\n        \\n        ways = 0;\\n        cnt = 0;\\n        for(int i  = n  - 1; i >= 0; --i){\\n            \\n            onezero[i] = ways;\\n            if(s[i] == \\'0\\'){\\n                cnt++;\\n                continue;\\n            }\\n            \\n            ways += cnt;\\n        }\\n\\n        ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                // search 10 \\n                ways += onezero[i];\\n            } else{\\n                ways += zeroone[i];\\n            }\\n        }\\n        \\n        return ways;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909645,
                "title": "javascript-101-010-selection-581ms",
                "content": "```\\nconst numberOfWays = (s) => op(s, \\'101\\') + op(s, \\'010\\')\\n\\nconst op = (s, t) => {\\n    let one = 0, two = 0, three = 0;\\n    for (const c of s) {\\n        if (c == t[2]) three += two;\\n        if (c == t[1]) two += one;\\n        if (c == t[0]) one++;\\n    }\\n    return three;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numberOfWays = (s) => op(s, \\'101\\') + op(s, \\'010\\')\\n\\nconst op = (s, t) => {\\n    let one = 0, two = 0, three = 0;\\n    for (const c of s) {\\n        if (c == t[2]) three += two;\\n        if (c == t[1]) two += one;\\n        if (c == t[0]) one++;\\n    }\\n    return three;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908166,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        \\n        int cnt0=0,cnt1=0;\\n        \\n        vector<int>dp0(n,0);\\n        vector<int>dp1(n,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                cnt0++;\\n            else\\n                cnt1++;\\n        }\\n        \\n        if(s[0]==\\'0\\')\\n            dp0[0]=1,dp1[0]=0;\\n        else\\n            dp1[0]=1,dp0[0]=0;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                dp0[i]=dp0[i-1]+1;\\n                dp1[i]=dp1[i-1];\\n            }\\n            else\\n            {\\n                dp1[i]=dp1[i-1]+1;\\n                dp0[i]=dp0[i-1];\\n            }\\n        }\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                ans+=dp0[i-1]*(cnt0-dp0[i-1]);\\n            }\\n            else\\n            {\\n                ans+=dp1[i-1]*(cnt1-dp1[i-1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        \\n        int cnt0=0,cnt1=0;\\n        \\n        vector<int>dp0(n,0);\\n        vector<int>dp1(n,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                cnt0++;\\n            else\\n                cnt1++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907910,
                "title": "java-o-n-simplest-solution",
                "content": "```\\n        // Author: Anand\\n      public long numberOfWays(String s) {\\n        long ans = 0;\\n\\n        int t0 = 0, t1 = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') t0++;\\n            else t1++;\\n        }\\n\\n        int c0 = 0, c1 = 0;\\n        for (int i = 0; i < s.length()-1; i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                ans += (long) c1 * (t1 - c1);\\n                c0++;\\n            } else {\\n                ans += (long) c0 * (t0 - c0);\\n                c1++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        // Author: Anand\\n      public long numberOfWays(String s) {\\n        long ans = 0;\\n\\n        int t0 = 0, t1 = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') t0++;\\n            else t1++;\\n        }\\n\\n        int c0 = 0, c1 = 0;\\n        for (int i = 0; i < s.length()-1; i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                ans += (long) c1 * (t1 - c1);\\n                c0++;\\n            } else {\\n                ans += (long) c0 * (t0 - c0);\\n                c1++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907725,
                "title": "c-binary-search",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        vector<long long>zero,ones;\\n        for(int i = 0; i<s.size(); i++){\\n            \\n            if(s[i]==\\'0\\'){\\n                zero.push_back(i);\\n            } else {\\n                ones.push_back(i);\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(auto it : ones){\\n            \\n            long long id = lower_bound(zero.begin(), zero.end(), it)-zero.begin();\\n            \\n            if(id!=zero.size()){\\n             ans+=(id*(zero.size()-id));   \\n            }\\n        }\\n        \\n         for(auto it : zero){\\n            \\n            long long id = lower_bound(ones.begin(), ones.end(), it)-ones.begin();\\n            \\n            if(id!=ones.size()){\\n             ans+=(id*(ones.size()-id));   \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        vector<long long>zero,ones;\\n        for(int i = 0; i<s.size(); i++){\\n            \\n            if(s[i]==\\'0\\'){\\n                zero.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1907398,
                "title": "c-two-solution-o-n-space-o-1-space",
                "content": "*first solution O(n) time and O(n) space*\\n```\\nclass Solution {\\npublic:\\n     long long find(string &s, string t) {\\n        long long m = t.length(), n = s.length();\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1, 0));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int j = 1; j <= n; j++)\\n            for (int i = 1; i <= m; i++)\\n                dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0ll);\\n        return dp[m][n];\\n    }\\n    long long numberOfWays(string s) {\\n       long long ans=find(s,\"101\")+find(s,\"010\");\\n        return ans;\\n    }\\n};\\n```\\n*second solution O(n) time and O(1) space*\\n```\\nclass Solution {\\npublic:\\n    long long find(string &s,string t)\\n    {\\n        long long a,b,c;\\n        a=b=c=0;\\n        for(auto &it:s)\\n        {\\n            if(it==t[2])\\n            {\\n                c+=b;\\n            }\\n            if(it==t[1])\\n            {\\n                b+=a;\\n            }\\n            if(it==t[0])\\n            {\\n                a++;\\n            }\\n        }\\n        return c;\\n    }\\n    long long numberOfWays(string s) {\\n       long long ans=find(s,\"101\")+find(s,\"010\");\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long find(string &s, string t) {\\n        long long m = t.length(), n = s.length();\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1, 0));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int j = 1; j <= n; j++)\\n            for (int i = 1; i <= m; i++)\\n                dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0ll);\\n        return dp[m][n];\\n    }\\n    long long numberOfWays(string s) {\\n       long long ans=find(s,\"101\")+find(s,\"010\");\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long find(string &s,string t)\\n    {\\n        long long a,b,c;\\n        a=b=c=0;\\n        for(auto &it:s)\\n        {\\n            if(it==t[2])\\n            {\\n                c+=b;\\n            }\\n            if(it==t[1])\\n            {\\n                b+=a;\\n            }\\n            if(it==t[0])\\n            {\\n                a++;\\n            }\\n        }\\n        return c;\\n    }\\n    long long numberOfWays(string s) {\\n       long long ans=find(s,\"101\")+find(s,\"010\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907395,
                "title": "3-solution-recursive-d-p-greedy",
                "content": "**Recursive solution**\\n\\n```\\nclass Solution {\\n    long long resCount=0;\\npublic:\\n    long long numberOfWays(string s) {\\n        solve(s,\\'#\\',s.size(),\"\");\\n        return resCount;\\n    }\\n  \\n  void solve(string &s,char last,int n,string res)\\n    {\\n      if(res.size()==3){\\n        resCount++;\\n        return;\\n      }\\n       if(n==0)\\n        return ;\\n    \\n      solve(s,last,n-1,res);\\n      if(s[n-1]!=last)\\n      {\\n        res+=s[n-1];\\n        last=s[n-1];\\n        solve(s,last,n-1,res);\\n      } \\n    }\\n};\\n```\\n\\n**D.P with Memoization solution** \\n\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][3];\\n    long long solve(string &s,char last,int i,int sz){\\n        if(sz==0) return 1;\\n\\t\\t\\n        if(i==s.size()) return 0;\\n\\t\\t\\n        if(dp[i][sz][last- \\'0\\'] != -1)\\n\\t\\t    return dp[i][sz][last - \\'0\\'];\\n        \\n        long long res = 0;\\n\\t\\t\\n        res+=solve(s,last,i+1,sz);\\n\\t\\tif(s[i] != last)\\n\\t\\tres+=solve(s,s[i],i+1,sz);\\n\\t\\t\\n        return dp[i][sz][last - \\'0\\'] = res;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,\\'#\\',0,3);\\n    }\\n};\\n```\\n\\n**Greedy**\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n         int n=s.size();\\n         \\n         int zeroCount=0,oneCount=0;\\n         \\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'0\\') \\n\\t\\t\\t  zeroCount++;\\n             else \\n\\t\\t\\t   oneCount++;\\n         }\\n         \\n         long long int res=0;\\n        \\n         int zeroBeforeI=0,oneBeforeI=0;\\n\\t\\t \\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'1\\'){\\n                 res+=zeroBeforeI*(zeroCount-zeroBeforeI);\\n                 oneBeforeI++;\\n             }else{\\n                 res+=oneBeforeI*(oneCount-oneBeforeI);\\n                 zeroBeforeI++;\\n             }\\n         }  \\n         return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long long resCount=0;\\npublic:\\n    long long numberOfWays(string s) {\\n        solve(s,\\'#\\',s.size(),\"\");\\n        return resCount;\\n    }\\n  \\n  void solve(string &s,char last,int n,string res)\\n    {\\n      if(res.size()==3){\\n        resCount++;\\n        return;\\n      }\\n       if(n==0)\\n        return ;\\n    \\n      solve(s,last,n-1,res);\\n      if(s[n-1]!=last)\\n      {\\n        res+=s[n-1];\\n        last=s[n-1];\\n        solve(s,last,n-1,res);\\n      } \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][3];\\n    long long solve(string &s,char last,int i,int sz){\\n        if(sz==0) return 1;\\n\\t\\t\\n        if(i==s.size()) return 0;\\n\\t\\t\\n        if(dp[i][sz][last- \\'0\\'] != -1)\\n\\t\\t    return dp[i][sz][last - \\'0\\'];\\n        \\n        long long res = 0;\\n\\t\\t\\n        res+=solve(s,last,i+1,sz);\\n\\t\\tif(s[i] != last)\\n\\t\\tres+=solve(s,s[i],i+1,sz);\\n\\t\\t\\n        return dp[i][sz][last - \\'0\\'] = res;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,\\'#\\',0,3);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n         int n=s.size();\\n         \\n         int zeroCount=0,oneCount=0;\\n         \\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'0\\') \\n\\t\\t\\t  zeroCount++;\\n             else \\n\\t\\t\\t   oneCount++;\\n         }\\n         \\n         long long int res=0;\\n        \\n         int zeroBeforeI=0,oneBeforeI=0;\\n\\t\\t \\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'1\\'){\\n                 res+=zeroBeforeI*(zeroCount-zeroBeforeI);\\n                 oneBeforeI++;\\n             }else{\\n                 res+=oneBeforeI*(oneCount-oneBeforeI);\\n                 zeroBeforeI++;\\n             }\\n         }  \\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907340,
                "title": "c-easy-noob-code",
                "content": "We need to find out 2 cases \"101\" and \"010\". \\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s)\\n    {\\n        long long c=0;\\n        int rightOnes[s.size()];\\n        int leftOnes[s.size()];\\n        int rightZeros[s.size()];\\n        int leftZeros[s.size()];\\n        leftOnes[0]=leftZeros[0]=0;\\n        rightZeros[s.size()-1]=leftZeros[s.size()-1]=0;\\n        int z=0,o=0;\\n        for(int i=1; i<s.size(); i++)\\n        {\\n            if(s[i-1]==\\'1\\')\\n                o++;\\n            else\\n                z++;\\n            leftZeros[i]=z;\\n            leftOnes[i]=o;\\n        }\\n        z=0,o=0;\\n        for(int i=s.size()-2; i>=0; i--)\\n        {\\n            if(s[i+1]==\\'1\\')\\n                o++;\\n            else\\n                z++;\\n            rightZeros[i]=z;\\n            rightOnes[i]=o;\\n                \\n        }\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {  \\n                    c+=(long long)(leftZeros[i]*rightZeros[i]);  //010\\n            }\\n            else\\n            {  \\n                    c+=(long long)(leftOnes[i]*rightOnes[i]);  //101\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\nO(n) time\\nO(n) space",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s)\\n    {\\n        long long c=0;\\n        int rightOnes[s.size()];\\n        int leftOnes[s.size()];\\n        int rightZeros[s.size()];\\n        int leftZeros[s.size()];\\n        leftOnes[0]=leftZeros[0]=0;\\n        rightZeros[s.size()-1]=leftZeros[s.size()-1]=0;\\n        int z=0,o=0;\\n        for(int i=1; i<s.size(); i++)\\n        {\\n            if(s[i-1]==\\'1\\')\\n                o++;\\n            else\\n                z++;\\n            leftZeros[i]=z;\\n            leftOnes[i]=o;\\n        }\\n        z=0,o=0;\\n        for(int i=s.size()-2; i>=0; i--)\\n        {\\n            if(s[i+1]==\\'1\\')\\n                o++;\\n            else\\n                z++;\\n            rightZeros[i]=z;\\n            rightOnes[i]=o;\\n                \\n        }\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {  \\n                    c+=(long long)(leftZeros[i]*rightZeros[i]);  //010\\n            }\\n            else\\n            {  \\n                    c+=(long long)(leftOnes[i]*rightOnes[i]);  //101\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907219,
                "title": "one-pass-very-easy-and-intuitive-python-solution",
                "content": "```python\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = [[0, 0, 0], [0, 0, 0]]\\n\\n        for x in [int(x) for x in s]:\\n            if x == 0:\\n                dp[0][0] += 1\\n                dp[0][2] += dp[0][1]\\n                dp[1][1] += dp[1][0]\\n            else:\\n                dp[1][0] += 1\\n                dp[0][1] += dp[0][0]\\n                dp[1][2] += dp[1][1]\\n\\n        return dp[0][2] + dp[1][2]\\n```\\n\\nAnswer can be either \"010\" or \"101\"\\n\\nLet `dp[0]`, be the list that contains number of ways to achieve \"0\", \"01\", \"010\" \\nLet `dp[1]` be the list that contains the number of ways to achieve \"1\", \"10\", \"101\"\\n\\nIterate across the string and build the dp array till current index.\\n\\nIf current value is `0` it can be added as it is to make \"0\" string, or added to \"01\" to make \"010\" or added to \"1\" to make \"10\"\\n\\n\\nRest is the same\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = [[0, 0, 0], [0, 0, 0]]\\n\\n        for x in [int(x) for x in s]:\\n            if x == 0:\\n                dp[0][0] += 1\\n                dp[0][2] += dp[0][1]\\n                dp[1][1] += dp[1][0]\\n            else:\\n                dp[1][0] += 1\\n                dp[0][1] += dp[0][0]\\n                dp[1][2] += dp[1][1]\\n\\n        return dp[0][2] + dp[1][2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907182,
                "title": "c-easy-o-n-with-explanation",
                "content": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Suffix & Prefix sum of 0\\'s and 1\\'s .\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\\n\\n**EXPLANATION**\\n* count number of \"101\" and \"010\" substrings.\\n* Calculate suffix sum of zero\\'s and one\\'s (from left to right)\\n* Calculate Prefix sum of zero\\'s and one\\'s (from right to left)\\n* if ele==0 then count = (1\\'s suffix)(1\\'s preffix)\\n*  if ele==1 then count = (0\\'s suffix)(0\\'s preffix)\\n\\n\\n\\nTIME COMPLEXITY : O(3*N) , N is size of array   **Beats 90.02%**\\nSPACE COMPLEXITY : O(2*N),                                **Beats 70.50%**\\n\\n\\n\\n\\n\\n```\\nlong long numberOfWays(string s) {\\n        long long n=s.size();\\n        vector<pair<long long,long long>> zero(n), one(n);\\n        long long z=0,o=0;\\n        for(int i=0;i<s.size();i++){   // suffix sum of Zeros , Ones\\n            zero[i].first=z;\\n            if(s[i]==\\'0\\') z++;\\n            \\n            one[i].first=o;\\n            if(s[i]==\\'1\\') o++;\\n        }\\n        z=0,o=0;\\n        for(int i=s.size()-1;i>=0;i--){   // Prefix sum of Zeros , Ones\\n            zero[i].second=z;\\n            if(s[i]==\\'0\\') z++;\\n            \\n            one[i].second=o;\\n            if(s[i]==\\'1\\') o++;\\n        }\\n        long long cnt=0;                 \\n        for(int i=0;i<n;i++){ \\n            if(s[i]==\\'0\\')              // if 0 -> count = (suffix 1\\'s) * (prefix 1\\'s) \\n                cnt+= one[i].first*one[i].second;    \\n            if(s[i]==\\'1\\')              // if 1 -> count = (suffix 0\\'s) * (prefix 0\\'s) \\n                cnt+= zero[i].first*zero[i].second;\\n        }\\n        return cnt;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Suffix & Prefix sum of 0\\'s and 1\\'s .\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\n```\\nlong long numberOfWays(string s) {\\n        long long n=s.size();\\n        vector<pair<long long,long long>> zero(n), one(n);\\n        long long z=0,o=0;\\n        for(int i=0;i<s.size();i++){   // suffix sum of Zeros , Ones\\n            zero[i].first=z;\\n            if(s[i]==\\'0\\') z++;\\n            \\n            one[i].first=o;\\n            if(s[i]==\\'1\\') o++;\\n        }\\n        z=0,o=0;\\n        for(int i=s.size()-1;i>=0;i--){   // Prefix sum of Zeros , Ones\\n            zero[i].second=z;\\n            if(s[i]==\\'0\\') z++;\\n            \\n            one[i].second=o;\\n            if(s[i]==\\'1\\') o++;\\n        }\\n        long long cnt=0;                 \\n        for(int i=0;i<n;i++){ \\n            if(s[i]==\\'0\\')              // if 0 -> count = (suffix 1\\'s) * (prefix 1\\'s) \\n                cnt+= one[i].first*one[i].second;    \\n            if(s[i]==\\'1\\')              // if 1 -> count = (suffix 0\\'s) * (prefix 0\\'s) \\n                cnt+= zero[i].first*zero[i].second;\\n        }\\n        return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907121,
                "title": "why-is-this-tle",
                "content": "The time should be O(10^5x2x3) which is 600000 way below the TLE threshold unless I am wrong\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i,prev,took):\\n            if took == 3:\\n                return 1\\n            if i >= len(s):\\n                return 0\\n            ans = 0\\n            if prev == 0:\\n                if s[i] == \"0\":\\n                    return dp(i+1,0,took)\\n                else:\\n                    return dp(i+1,1,took+1) + dp(i+1,0,took)\\n            else:\\n                if s[i] == \"1\":\\n                    return dp(i+1,1,took)\\n                else:\\n                    return dp(i+1,0,took+1) + dp(i+1,1,took)\\n        \\n        return dp(0,0,0) + dp(0,1,0)\\n",
                "solutionTags": [],
                "code": "The time should be O(10^5x2x3) which is 600000 way below the TLE threshold unless I am wrong\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i,prev,took):\\n            if took == 3:\\n                return 1\\n            if i >= len(s):\\n                return 0\\n            ans = 0\\n            if prev == 0:\\n                if s[i] == \"0\":\\n                    return dp(i+1,0,took)\\n                else:\\n                    return dp(i+1,1,took+1) + dp(i+1,0,took)\\n            else:\\n                if s[i] == \"1\":\\n                    return dp(i+1,1,took)\\n                else:\\n                    return dp(i+1,0,took+1) + dp(i+1,1,took)\\n        \\n        return dp(0,0,0) + dp(0,1,0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1907062,
                "title": "c-easy-solution",
                "content": "for each 0 count number of 1\\'s to the left \\nand vice versa for 1\\'s \\nand then multiply\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> numOfZero(n, 0);\\n        vector<int> numOfOnes(n, 0);\\n   \\n        int o=0,z=0;\\n        \\n        for(int i =0; i < n; ++i){\\n            if ( s[i] == \\'0\\'){\\n                numOfOnes[i] = o;\\n                z++;\\n            }else{\\n                numOfZero[i] = z;\\n                o++;\\n            }\\n        }\\n        \\n        long long ans =0;\\n        \\n        for(int i =0;i < n; ++i){\\n            if (s[i] == \\'0\\'){\\n                int left = numOfOnes[i];\\n                int right = o - left;\\n                ans += right*left;\\n            }else{\\n                int left = numOfZero[i];\\n                int right = z - left;\\n                ans += right*left; \\n            }\\n        }\\n        \\n        return ans;        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> numOfZero(n, 0);\\n        vector<int> numOfOnes(n, 0);\\n   \\n        int o=0,z=0;\\n        \\n        for(int i =0; i < n; ++i){\\n            if ( s[i] == \\'0\\'){\\n                numOfOnes[i] = o;\\n                z++;\\n            }else{\\n                numOfZero[i] = z;\\n                o++;\\n            }\\n        }\\n        \\n        long long ans =0;\\n        \\n        for(int i =0;i < n; ++i){\\n            if (s[i] == \\'0\\'){\\n                int left = numOfOnes[i];\\n                int right = o - left;\\n                ans += right*left;\\n            }else{\\n                int left = numOfZero[i];\\n                int right = z - left;\\n                ans += right*left; \\n            }\\n        }\\n        \\n        return ans;        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907046,
                "title": "easy-c-solution-using-prefix-and-suffix-count",
                "content": "Keep the count of 0s and 1s from both the ends. Now iterate oven the string and check:\\n\\t1. If s[i] = \\'0\\', then ` ans += (prefix count of 1 at that position)  * (suffix count of 1 at that position)`\\n\\t2. If s[i] = \\'1\\', then ` ans += (prefix count of 0 at that position)  * (suffix count of 0 at that position)`\\n```\\n    long long numberOfWays(string s) {\\n        vector<pair<long long, long long>> pre, suf;\\n        \\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            pre.push_back({0, 0});\\n            suf.push_back({0, 0});\\n        }\\n        \\n        long long prev0 = 0, prev1 = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'0\\') {\\n                pre[i].first = prev0+1;\\n                pre[i].second = prev1;\\n                prev0++;\\n            }else{\\n                pre[i].first = prev0;\\n                pre[i].second = prev1+1;\\n                prev1++;\\n            }\\n        }\\n        \\n        prev0 = 0, prev1 = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if(s[i] == \\'0\\') {\\n                suf[i].first = prev0+1;\\n                suf[i].second = prev1;\\n                prev0++;\\n            }else{\\n                suf[i].second = prev1+1;\\n                suf[i].first = prev0;\\n                prev1++;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'0\\') {\\n                ans += pre[i].second * suf[i].second;\\n            }else{\\n                ans += pre[i].first * suf[i].first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\n    long long numberOfWays(string s) {\\n        vector<pair<long long, long long>> pre, suf;\\n        \\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            pre.push_back({0, 0});\\n            suf.push_back({0, 0});\\n        }\\n        \\n        long long prev0 = 0, prev1 = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'0\\') {\\n                pre[i].first = prev0+1;\\n                pre[i].second = prev1;\\n                prev0++;\\n            }else{\\n                pre[i].first = prev0;\\n                pre[i].second = prev1+1;\\n                prev1++;\\n            }\\n        }\\n        \\n        prev0 = 0, prev1 = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if(s[i] == \\'0\\') {\\n                suf[i].first = prev0+1;\\n                suf[i].second = prev1;\\n                prev0++;\\n            }else{\\n                suf[i].second = prev1+1;\\n                suf[i].first = prev0;\\n                prev1++;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'0\\') {\\n                ans += pre[i].second * suf[i].second;\\n            }else{\\n                ans += pre[i].first * suf[i].first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907027,
                "title": "scala-naive",
                "content": "```\\ndef numberOfWays(s: String): Long = {\\n  def count(n0: Long, n1: Long, n10: Long, n01: Long, acc: Long, rem: List[Char]): Long =\\n    rem match {\\n      case Nil => acc\\n      case \\'1\\' :: tail => count(n0    , n1 + 1, n10,      n01 + n0, acc + n10, tail)\\n      case \\'0\\' :: tail => count(n0 + 1, n1    , n10 + n1, n01     , acc + n01, tail)\\n      case _ => ???\\n    }\\n\\n  count(0, 0, 0, 0, 0, s.toList)\\n}\\n  ```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef numberOfWays(s: String): Long = {\\n  def count(n0: Long, n1: Long, n10: Long, n01: Long, acc: Long, rem: List[Char]): Long =\\n    rem match {\\n      case Nil => acc\\n      case \\'1\\' :: tail => count(n0    , n1 + 1, n10,      n01 + n0, acc + n10, tail)\\n      case \\'0\\' :: tail => count(n0 + 1, n1    , n10 + n1, n01     , acc + n01, tail)\\n      case _ => ???\\n    }\\n\\n  count(0, 0, 0, 0, 0, s.toList)\\n}\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1907018,
                "title": "c-prefix-count",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    long long numberOfWays(string s) {\\n         long long int n=s.length();\\n        vector<pair<long long int,long long int>> pre(n);\\n        long long int one=0,zero=0;\\n        for(int i=0;i<n;i++){\\n            pre[i]={zero,one};\\n            if(s[i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        long long int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\'){\\n                ans+=pre[i].second*(one-pre[i].second);\\n            }\\n            else ans+=pre[i].first*(zero-pre[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    long long numberOfWays(string s) {\\n         long long int n=s.length();\\n        vector<pair<long long int,long long int>> pre(n);\\n        long long int one=0,zero=0;\\n        for(int i=0;i<n;i++){\\n            pre[i]={zero,one};\\n            if(s[i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        long long int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\'){\\n                ans+=pre[i].second*(one-pre[i].second);\\n            }\\n            else ans+=pre[i].first*(zero-pre[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907014,
                "title": "dp-memoization",
                "content": "\\n```\\nWhy It is Giving TLE, Can some one explain\\n\\nclass Solution {\\npublic:\\n    unordered_map<string,long long>dp;\\n    \\n    long long validPaths(string &s, long long n , char prev = \\' \\', long long added = 0){\\n        \\n        if(added == 3) \\n            return 1;\\n        if(n <= 0){\\n            return 0;\\n        }\\n        \\n        string key = to_string(n) + prev + to_string(added);\\n        \\n        if(dp.count(key)){\\n            return dp[key];\\n        }\\n        \\n        if( prev == s[n-1] ) {\\n            return dp[key] = validPaths(s, n - 1, prev, added);\\n        }\\n        \\n        long long r1 = validPaths(s, n - 1,s[n - 1], added+1) ;\\n        long long r2 = validPaths(s, n - 1, prev, added) ;\\n        \\n       \\n        return dp[key] = r1 + r2;\\n    }\\n    long long numberOfWays(string s) {\\n      \\n        long long n = s.size() ;\\n        long long result = validPaths(s, n);\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<string,long long>dp;\\n    \\n    long long validPaths(string &s, long long n , char prev = \\' \\', long long added = 0){\\n        \\n        if(added == 3) \\n            return 1;\\n        if(n <= 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3971652,
                "title": "top-down-approach-o-n-java",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long[][][] memo = new long[s.length()][3][3];\\n        for (long[][] arr: memo) for (long[] row: arr) Arrays.fill(row, -1);\\n        return slv(0, \\'2\\', 3, s, memo);\\n    }\\n\\n    private long slv(int n, char prev, int target, String city, long[][][] memo) {\\n        if (target == 0) return 1;\\n        if (n >= city.length()) return 0;\\n        if (memo[n][target - 1][prev - 48] != -1) return memo[n][target - 1][prev - 48];\\n        if (city.charAt(n) == prev) {\\n            memo[n][target - 1][prev - 48] = slv(n + 1, prev, target, city, memo);\\n        } else {\\n            memo[n][target - 1][prev - 48] = slv(n + 1, city.charAt(n), target - 1, city, memo) +\\n                slv(n + 1, prev, target, city, memo);\\n        }\\n        return memo[n][target - 1][prev - 48];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long[][][] memo = new long[s.length()][3][3];\\n        for (long[][] arr: memo) for (long[] row: arr) Arrays.fill(row, -1);\\n        return slv(0, \\'2\\', 3, s, memo);\\n    }\\n\\n    private long slv(int n, char prev, int target, String city, long[][][] memo) {\\n        if (target == 0) return 1;\\n        if (n >= city.length()) return 0;\\n        if (memo[n][target - 1][prev - 48] != -1) return memo[n][target - 1][prev - 48];\\n        if (city.charAt(n) == prev) {\\n            memo[n][target - 1][prev - 48] = slv(n + 1, prev, target, city, memo);\\n        } else {\\n            memo[n][target - 1][prev - 48] = slv(n + 1, city.charAt(n), target - 1, city, memo) +\\n                slv(n + 1, prev, target, city, memo);\\n        }\\n        return memo[n][target - 1][prev - 48];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351531,
                "title": "312-ms",
                "content": "```ruby\\ndef number_of_ways s\\n    ro = s.size - (rz = s.count(?0))\\n    return 0 if ro.zero? || rz.zero?\\n    lo, lz, c = 0, 0, 0\\n    s.each_byte do\\n        c += _1 == 48 ?\\n            (lz += 1; rz -= 1; lo * ro) :\\n            (lo += 1; ro -= 1; lz * rz)\\n    end\\n    c\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef number_of_ways s\\n    ro = s.size - (rz = s.count(?0))\\n    return 0 if ro.zero? || rz.zero?\\n    lo, lz, c = 0, 0, 0\\n    s.each_byte do\\n        c += _1 == 48 ?\\n            (lz += 1; rz -= 1; lo * ro) :\\n            (lo += 1; ro -= 1; lz * rz)\\n    end\\n    c\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3151016,
                "title": "3d-dp-recursion-memoization-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long dp[2][100005][4];\\n    long long f(char prev, int i, string &s, int count)\\n    {\\n        long long ans=0;\\n        if(count==3) return 1;\\n        if(i==s.size()) return 0;\\n        if(prev!=\\'-\\' && dp[prev-48][i][count]!=-1) return dp[prev-48][i][count];\\n        long long take=0, dont=0;\\n        if(prev!=s[i]) dp[s[i]-48][i+1][count+1]=take=f(s[i],i+1,s,count+1);\\n        if(prev!=\\'-\\') dp[prev-48][i+1][count]=dont=f(prev,i+1,s,count); \\n        else dont=f(prev,i+1,s,count); \\n        if(prev==\\'-\\') return take+dont;\\n        return dp[prev-48][i][count]=take+dont;\\n    }\\n    long long numberOfWays(string s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(\\'-\\',0,s,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long dp[2][100005][4];\\n    long long f(char prev, int i, string &s, int count)\\n    {\\n        long long ans=0;\\n        if(count==3) return 1;\\n        if(i==s.size()) return 0;\\n        if(prev!=\\'-\\' && dp[prev-48][i][count]!=-1) return dp[prev-48][i][count];\\n        long long take=0, dont=0;\\n        if(prev!=s[i]) dp[s[i]-48][i+1][count+1]=take=f(s[i],i+1,s,count+1);\\n        if(prev!=\\'-\\') dp[prev-48][i+1][count]=dont=f(prev,i+1,s,count); \\n        else dont=f(prev,i+1,s,count); \\n        if(prev==\\'-\\') return take+dont;\\n        return dp[prev-48][i][count]=take+dont;\\n    }\\n    long long numberOfWays(string s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(\\'-\\',0,s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986251,
                "title": "easy-understanding-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n        map<string,long long>mp;\\n        long long count=0;\\n        for(auto t:s)\\n        {\\n            string x= (t==\\'0\\') ?\"0\" :\"1\";\\n            if(x==\"0\")\\n            {\\n                mp[\"10\"]+=mp[\"1\"];\\n                if(mp.find(\"01\")!=mp.end())\\n                {\\n                    count+=mp[\"01\"];\\n                }\\n                mp[x]++;\\n            }\\n            else\\n            {\\n                mp[\"01\"]+=mp[\"0\"];\\n                if(mp.find(\"10\")!=mp.end())\\n                {\\n                    count+=mp[\"10\"];\\n                }\\n                mp[x]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n        map<string,long long>mp;\\n        long long count=0;\\n        for(auto t:s)\\n        {\\n            string x= (t==\\'0\\') ?\"0\" :\"1\";\\n            if(x==\"0\")\\n            {\\n                mp[\"10\"]+=mp[\"1\"];\\n                if(mp.find(\"01\")!=mp.end())\\n                {\\n                    count+=mp[\"01\"];\\n                }\\n                mp[x]++;\\n            }\\n            else\\n            {\\n                mp[\"01\"]+=mp[\"0\"];\\n                if(mp.find(\"10\")!=mp.end())\\n                {\\n                    count+=mp[\"10\"];\\n                }\\n                mp[x]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795244,
                "title": "c-easy-explanation-prefix-sum",
                "content": "Explanation:Since if the Current Building is \\'0\\' Then we need to count How many Buildings are there with patter \\'10\\' ie one build,one office.\\nWhat if the current building is \\'1\\' Then we need to search for \\'01\\' pattern buildings.\\nSo For every index in the array we computed the count of Such pattern in Two different Arrays.\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.length();\\n\\t\\t//This Vector Search for the Count of \\'10\\' pattern for every index.\\n        vector<long long>CountOneZero(n);\\n        long long zero=0;\\n        long long count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'0\\')\\n                zero++;\\n            if(s[i]==\\'1\\')\\n                count+=(zero);\\n            CountOneZero[i]=count;\\n        }\\n\\t\\t//This Vector Search for the Count of \\'01\\' pattern for every index.\\n        vector<long long>CountZeroOne(n);\\n        long long one=0;\\n        count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'1\\')\\n                one++;\\n            if(s[i]==\\'0\\')\\n                count+=(one);\\n            CountZeroOne[i]=count;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')//If the Current Building is 0 then we need to Seach for the count of 10 pattern\\n                ans+=CountOneZero[i];\\n            else //If the Current Building is 1 then we need to Seach for the count of 01 pattern\\n                ans+=CountZeroOne[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.length();\\n\\t\\t//This Vector Search for the Count of \\'10\\' pattern for every index.\\n        vector<long long>CountOneZero(n);\\n        long long zero=0;\\n        long long count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'0\\')\\n                zero++;\\n            if(s[i]==\\'1\\')\\n                count+=(zero);\\n            CountOneZero[i]=count;\\n        }\\n\\t\\t//This Vector Search for the Count of \\'01\\' pattern for every index.\\n        vector<long long>CountZeroOne(n);\\n        long long one=0;\\n        count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'1\\')\\n                one++;\\n            if(s[i]==\\'0\\')\\n                count+=(one);\\n            CountZeroOne[i]=count;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')//If the Current Building is 0 then we need to Seach for the count of 10 pattern\\n                ans+=CountOneZero[i];\\n            else //If the Current Building is 1 then we need to Seach for the count of 01 pattern\\n                ans+=CountZeroOne[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740535,
                "title": "python-prefix-sum-o-n",
                "content": "Treat every index as the middle element. Then you just need the count of either 1\\'s or 0\\'s before and after i. The amount to add to the answer is the count of low * count of high\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        pre = [0]*n\\n        for i in range(n):\\n            if i==0:\\n                pre[i] = int(s[i])\\n            if i>0:\\n                pre[i] = int(s[i])+pre[i-1]\\n        \\n        ans=0\\n        for i in range(1, n-1):\\n            low = pre[i-1]\\n            high = pre[n-1]-pre[i]\\n            if s[i]==\\'1\\':\\n                low = abs(i-low)\\n                high = abs(n-i-high-1)\\n            ans+=high*low\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        pre = [0]*n\\n        for i in range(n):\\n            if i==0:\\n                pre[i] = int(s[i])\\n            if i>0:\\n                pre[i] = int(s[i])+pre[i-1]\\n        \\n        ans=0\\n        for i in range(1, n-1):\\n            low = pre[i-1]\\n            high = pre[n-1]-pre[i]\\n            if s[i]==\\'1\\':\\n                low = abs(i-low)\\n                high = abs(n-i-high-1)\\n            ans+=high*low\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624014,
                "title": "c-prefix-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<pair<int, int>> memo(s.size());\\n        if(s[0]==\\'1\\') memo[0].first=0, memo[0].second=1;\\n        else memo[0].second=0, memo[0].first=1;\\n\\n        for(int i=1; i<s.size(); i++) {\\n            if(s[i]==\\'1\\') memo[i].first=memo[i-1].first, memo[i].second=memo[i-1].second+1;\\n            else memo[i].second=memo[i-1].second, memo[i].first=memo[i-1].first+1;\\n        }\\n\\n        int zeroCount=memo[s.size()-1].first, oneCount=memo[s.size()-1].second;\\n        long long totalWays=0;\\n        for(int i=1; i<s.size()-1; i++) {\\n            if(s[i]==\\'0\\') totalWays+=memo[i].second*(oneCount-memo[i].second);\\n            else totalWays+=memo[i].first*(zeroCount-memo[i].first);\\n        }\\n        return totalWays;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<pair<int, int>> memo(s.size());\\n        if(s[0]==\\'1\\') memo[0].first=0, memo[0].second=1;\\n        else memo[0].second=0, memo[0].first=1;\\n\\n        for(int i=1; i<s.size(); i++) {\\n            if(s[i]==\\'1\\') memo[i].first=memo[i-1].first, memo[i].second=memo[i-1].second+1;\\n            else memo[i].second=memo[i-1].second, memo[i].first=memo[i-1].first+1;\\n        }\\n\\n        int zeroCount=memo[s.size()-1].first, oneCount=memo[s.size()-1].second;\\n        long long totalWays=0;\\n        for(int i=1; i<s.size()-1; i++) {\\n            if(s[i]==\\'0\\') totalWays+=memo[i].second*(oneCount-memo[i].second);\\n            else totalWays+=memo[i].first*(zeroCount-memo[i].first);\\n        }\\n        return totalWays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549490,
                "title": "simple-single-scan-o-n-o-1-space-dp-accumulator-solution",
                "content": "We need the count of valid 3 length strings- we track count of 0s,1s, 01s and 10s - this is then used to accumulate the answer\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long noOf0=0;\\n        long noOf1=0;\\n        long noOf01=0;\\n        long noOf10=0;\\n        long long total = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'1\\') {\\n                noOf1++;\\n                noOf01 += noOf0;\\n                total += noOf10;\\n            } else {\\n                noOf0++;\\n                noOf10 += noOf1;\\n                total += noOf01;\\n            }\\n        }\\n        return total;\\n                            \\n    }\\n};```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long noOf0=0;\\n        long noOf1=0;\\n        long noOf01=0;\\n        long noOf10=0;\\n        long long total = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'1\\') {\\n                noOf1++;\\n                noOf01 += noOf0;\\n                total += noOf10;\\n            } else {\\n                noOf0++;\\n                noOf10 += noOf1;\\n                total += noOf01;\\n            }\\n        }\\n        return total;\\n                            \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2548538,
                "title": "understand-fundamentals-of-these-kind-of-questions",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        //observation 1 : need to find out only 3 buildings thats why\\n        //This proplem is relatable to a problem : find out all valid ways where :\\n        //i < j < k && A[i] < A[j] < A[k]\\n        \\n        //so we need to fix A[j] to find each possibility of i and k respective to j\\n        // and multiply the count of i and k and add it into the answer\\n\\t\\t//beacuse contribution of i in left * contribution of k in right is the all valid ways for a specific j\\n        \\n        //here in this problem I can fix j as either 0 and 1 and find i and k respectively\\n\\t\\t// in this question i=k;\\n        \\n        int n = s.length();\\n        long ans = 0, rightZero = 0 , rightOne = 0;\\n        //calculating all the right 1s and rigth 0s\\n        for(int i = 0 ; i < n ;i++){\\n            char c = s.charAt(i);\\n            if(c==\\'0\\') rightZero++;\\n            else rightOne++;\\n            \\n        }\\n        long leftZero = 0, leftOne = 0;\\n        for(int j = 0 ; j < n ; j++){\\n            \\n            char c = s.charAt(j);\\n            if(c == \\'0\\'){ // I need to find out all 1s in left \\n                ans += rightOne * leftOne;\\n                rightZero --;\\n                leftZero++;\\n            }\\n            else{ // I need to find out all 0s in left \\n                ans += leftZero * rightZero;\\n                rightOne--;\\n                leftOne++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        //observation 1 : need to find out only 3 buildings thats why\\n        //This proplem is relatable to a problem : find out all valid ways where :\\n        //i < j < k && A[i] < A[j] < A[k]\\n        \\n        //so we need to fix A[j] to find each possibility of i and k respective to j\\n        // and multiply the count of i and k and add it into the answer\\n\\t\\t//beacuse contribution of i in left * contribution of k in right is the all valid ways for a specific j\\n        \\n        //here in this problem I can fix j as either 0 and 1 and find i and k respectively\\n\\t\\t// in this question i=k;\\n        \\n        int n = s.length();\\n        long ans = 0, rightZero = 0 , rightOne = 0;\\n        //calculating all the right 1s and rigth 0s\\n        for(int i = 0 ; i < n ;i++){\\n            char c = s.charAt(i);\\n            if(c==\\'0\\') rightZero++;\\n            else rightOne++;\\n            \\n        }\\n        long leftZero = 0, leftOne = 0;\\n        for(int j = 0 ; j < n ; j++){\\n            \\n            char c = s.charAt(j);\\n            if(c == \\'0\\'){ // I need to find out all 1s in left \\n                ans += rightOne * leftOne;\\n                rightZero --;\\n                leftZero++;\\n            }\\n            else{ // I need to find out all 0s in left \\n                ans += leftZero * rightZero;\\n                rightOne--;\\n                leftOne++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547113,
                "title": "python-combination-or-dp",
                "content": "The DP solution is an implementation of a solution provided [here](https://leetcode.com/problems/number-of-ways-to-select-buildings/discuss/1907109/PythonDP-easy-to-understand).\\n\\n**Solution**:\\nThere are two ways to solve this problem.\\n1. Combination\\nFor any given digit, the number of combination can formed using such digit as the mid value is the number of opposite digit to the left multiply by the number of digit to opposite to the right. \\n    \\n\\tIE if there is 4 0s to the left and 10 0s to the right, the number combination resulting in a \"010\" will be 40. \\n\\n2. DP\\n    Keep counts of the occurence of all possible sequence ending with each digit. ie 0s can be used to the following sequences: 0, 10, 010 and 1s can be used to form the following sequence 1, 01, 010. Iterate through all characters and keep track of occurence of all possible sequences.\\n\\n    If the current digit is 0, update the occurence of 0, 10, 010 using the following formula  \\n        counts[\"0\"]     +=  1\\n        counts[\"10\"]    +=  counts[\"1\"]\\n        counts[\"010\"]   +=  counts[\"01\"]\\n\\n    If the current digit is 1, update the occurence of 1, 01, 010 using the following formula\\n        counts[\"1\"]     +=  1\\n        counts[\"01\"]    +=  counts[\"0\"]\\n        counts[\"101\"]   +=  counts[\"10\"]\\n\\n**Complexity**:\\n    Time: O(n)\\n    Space: O(1)\\n\\t\\n```\\nfrom collections import Counter, defaultdict\\n\\n# Combination Solution\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n\\n        # Get length of s\\n        n = len(s)\\n\\n        # Use two counters to keep track of the numbers of digits to the left and the right of the current number\\n        left, right = Counter(), Counter(s)\\n\\n        # A helper to find an opposite\\n        opp = {\"1\": \"0\", \"0\": \"1\"}\\n\\n        # Initialize i and result\\n        i, res = 0, 0\\n\\n        # Iterate through all characters in s\\n        while i < n:\\n            \\n            # Count the occurence of the current digit\\n            count = 1\\n            while i < n - 1 and s[i] == s[i + 1]:\\n                count, i = count + 1, i + 1\\n\\n            # Multiply the occuerence of the opposite digit at the left and right with the count of the current digit\\n            res += left[opp[s[i]]] * count * right[opp[s[i]]]\\n\\n            # Update the left and right counters\\n            left[s[i]], right[s[i]] = left[s[i]] + count, right[s[i]] - count\\n\\n            # Increment i\\n            i += 1\\n\\n        return res\\n\\n# DP Solution\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n\\n        # Initialize a dict to keep track of counts\\n        counts = defaultdict(int)\\n\\n        # Iterate through all characters\\n        for c in s:\\n\\n            # If the current digit is 1, update the counts of all sequence that such digit can contribute to\\n            if c == \"1\":\\n                counts[\"1\"], counts[\"01\"], counts[\"101\"] = (\\n                    counts[\"1\"] + 1,\\n                    counts[\"01\"] + counts[\"0\"],\\n                    counts[\"101\"] + counts[\"10\"],\\n                )\\n\\n            # Else if the current digit is 0, update the counts of all sequence that such digit can contribute to\\n            else:\\n                counts[\"0\"], counts[\"10\"], counts[\"010\"] = (\\n                    counts[\"0\"] + 1,\\n                    counts[\"10\"] + counts[\"1\"],\\n                    counts[\"010\"] + counts[\"01\"],\\n                )\\n\\n        # Return the counts of sequence that we are looking for\\n        return counts[\"101\"] + counts[\"010\"]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\n\\n# Combination Solution\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n\\n        # Get length of s\\n        n = len(s)\\n\\n        # Use two counters to keep track of the numbers of digits to the left and the right of the current number\\n        left, right = Counter(), Counter(s)\\n\\n        # A helper to find an opposite\\n        opp = {\"1\": \"0\", \"0\": \"1\"}\\n\\n        # Initialize i and result\\n        i, res = 0, 0\\n\\n        # Iterate through all characters in s\\n        while i < n:\\n            \\n            # Count the occurence of the current digit\\n            count = 1\\n            while i < n - 1 and s[i] == s[i + 1]:\\n                count, i = count + 1, i + 1\\n\\n            # Multiply the occuerence of the opposite digit at the left and right with the count of the current digit\\n            res += left[opp[s[i]]] * count * right[opp[s[i]]]\\n\\n            # Update the left and right counters\\n            left[s[i]], right[s[i]] = left[s[i]] + count, right[s[i]] - count\\n\\n            # Increment i\\n            i += 1\\n\\n        return res\\n\\n# DP Solution\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n\\n        # Initialize a dict to keep track of counts\\n        counts = defaultdict(int)\\n\\n        # Iterate through all characters\\n        for c in s:\\n\\n            # If the current digit is 1, update the counts of all sequence that such digit can contribute to\\n            if c == \"1\":\\n                counts[\"1\"], counts[\"01\"], counts[\"101\"] = (\\n                    counts[\"1\"] + 1,\\n                    counts[\"01\"] + counts[\"0\"],\\n                    counts[\"101\"] + counts[\"10\"],\\n                )\\n\\n            # Else if the current digit is 0, update the counts of all sequence that such digit can contribute to\\n            else:\\n                counts[\"0\"], counts[\"10\"], counts[\"010\"] = (\\n                    counts[\"0\"] + 1,\\n                    counts[\"10\"] + counts[\"1\"],\\n                    counts[\"010\"] + counts[\"01\"],\\n                )\\n\\n        # Return the counts of sequence that we are looking for\\n        return counts[\"101\"] + counts[\"010\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531571,
                "title": "c-count-zeroes-on-either-side",
                "content": "```c++\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> numZeroesLeft (n, 0); // numZeroesLeft[i] = number of zeroes to the left of i (exclusive).\\n        vector<int> numZeroesRight (n, 0); // numZeroesRight[i] = number of zeroes to the right of i (exclusive).\\n        \\n        for (int i = 1; i < n; i++) {\\n            numZeroesLeft[i] = numZeroesLeft[i - 1];\\n            if (s[i - 1] == \\'0\\') {\\n                numZeroesLeft[i]++;\\n            }\\n        }\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            numZeroesRight[i] = numZeroesRight[i + 1];\\n            if (s[i + 1] == \\'0\\') {\\n                numZeroesRight[i]++;\\n            }\\n        }\\n        long long ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            if (s[i] == \\'1\\') {\\n                // 0 1 0: find the number of zeroes on either side of this 1.\\n                ans += numZeroesLeft[i] * numZeroesRight[i];\\n            } else {\\n                // 1 0 1: find the number of ones on the left and right of this 0.\\n                int onesLeft = i - numZeroesLeft[i];\\n                int onesRight = n - 1 - i - numZeroesRight[i];\\n                ans += onesLeft * onesRight;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> numZeroesLeft (n, 0); // numZeroesLeft[i] = number of zeroes to the left of i (exclusive).\\n        vector<int> numZeroesRight (n, 0); // numZeroesRight[i] = number of zeroes to the right of i (exclusive).\\n        \\n        for (int i = 1; i < n; i++) {\\n            numZeroesLeft[i] = numZeroesLeft[i - 1];\\n            if (s[i - 1] == \\'0\\') {\\n                numZeroesLeft[i]++;\\n            }\\n        }\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            numZeroesRight[i] = numZeroesRight[i + 1];\\n            if (s[i + 1] == \\'0\\') {\\n                numZeroesRight[i]++;\\n            }\\n        }\\n        long long ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            if (s[i] == \\'1\\') {\\n                // 0 1 0: find the number of zeroes on either side of this 1.\\n                ans += numZeroesLeft[i] * numZeroesRight[i];\\n            } else {\\n                // 1 0 1: find the number of ones on the left and right of this 0.\\n                int onesLeft = i - numZeroesLeft[i];\\n                int onesRight = n - 1 - i - numZeroesRight[i];\\n                ans += onesLeft * onesRight;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495091,
                "title": "linear-time-constant-space-extremely-simple",
                "content": "We just keep track of counts of all the patterns we are interesested in\\n`(0, 01, 010, 1, 10, 101)`\\n\\n```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = {\\'0\\': 0, \\'1\\': 0, \\'01\\': 0, \\'10\\': 0, \\'010\\': 0, \\'101\\': 0}\\n        for e in s:\\n            if e == \\'0\\':\\n                dp[\\'0\\'] += 1\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'1\\'] += 1\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        return dp[\\'101\\']+dp[\\'010\\']\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = {\\'0\\': 0, \\'1\\': 0, \\'01\\': 0, \\'10\\': 0, \\'010\\': 0, \\'101\\': 0}\\n        for e in s:\\n            if e == \\'0\\':\\n                dp[\\'0\\'] += 1\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'1\\'] += 1\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        return dp[\\'101\\']+dp[\\'010\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447902,
                "title": "easy-memoization-c",
                "content": "**upvote if u like**\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][3][3];\\n    long long solve(string &s,int idx,char c,long long len)\\n    {\\n        if(len==3)\\n        {\\n            return 1;\\n        }\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx][c-\\'0\\'][len]!=-1)\\n        {\\n            return dp[idx][c-\\'0\\'][len];\\n        }\\n        long long ans=0;\\n        if(s[idx]!=c)\\n        {\\n            ans+=solve(s,idx+1,s[idx],len+1);\\n        }\\n        ans+=solve(s,idx+1,c,len);\\n        return dp[idx][c-\\'0\\'][len]=ans;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,\\'2\\',0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][3][3];\\n    long long solve(string &s,int idx,char c,long long len)\\n    {\\n        if(len==3)\\n        {\\n            return 1;\\n        }\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx][c-\\'0\\'][len]!=-1)\\n        {\\n            return dp[idx][c-\\'0\\'][len];\\n        }\\n        long long ans=0;\\n        if(s[idx]!=c)\\n        {\\n            ans+=solve(s,idx+1,s[idx],len+1);\\n        }\\n        ans+=solve(s,idx+1,c,len);\\n        return dp[idx][c-\\'0\\'][len]=ans;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,\\'2\\',0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413871,
                "title": "python-dp-slow-3-loops-but-easiest-and-most-detailed-thought-process",
                "content": "This is my first time writing a solution. So please bear with me and comment your thoughts!!\\n\\nBecause *no two consecutive buildings out of the selected buildings can be of the same type* and the only types are 0 and 1. Therefore, the only possible sequences are **010** and **101**. We want to find number of **010** + number of  **101** until the end (index len(s)-1).\\n\\nNotice that either **01** precedes **010** or **10** precedes **101** so that **010** or **101** can be formed. Let dp01[i] be the number of subsequences **01** until index i and dp10[i] be the number of subsequences **10** until index i.\\n\\nNow suppose we want to find out the number of **010** **OR** **101** until index i of s, there are two cases:\\n* if s[i] == \\'0\\', only **010** can be formed because **101** requires 1 to be the last digit\\n\\t* number of possible **010** = number of **01** until index i-1 == dp01[i-1]\\n* if s[i] == \\'1\\', only **101** can be formed because **010** requires 0 to be the last digit\\n\\t* number of possible **101** = number of **10** until index i-1 == dp10[i-1]\\n\\nThe rest of the problem becomes **find the number of 01 and number of 10 until each index <==> find dp01 and dp10**. A very similar observation can be made that only **0** precedes **01** or **1** precedes **10** so that **01** or **10** can be formed. Just like above:\\n* if s[i] == \\'0\\', only **10** can be formed because **01** requires 1 to be the last digit\\n\\t* number of possible **10** = number of **10** until index i-1 + number of **1** until index i-1 == CAN YOU FIND THIS DIRECTLY?\\n* if s[i] == \\'1\\', only **01** can be formed because **10** requires 0 to be the last digit\\n\\t* number of possible **01** = number of **01** until index i-1 + number of **0** until index i-1 == CAN YOU FIND THIS DIRECTLY?\\n\\nThat\\'s it! Please UPVOTE if it helps, thanks!!!\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        # i => #occurence of 0\\n        occurence_0_until_i = {}\\n        # i => #occurence of 1\\n        occurence_1_until_i = {}\\n        num_0 = num_1 = 0\\n        for i in range(len(s)):\\n            if (s[i] == \\'0\\'):\\n                num_0 += 1\\n            else:\\n                num_1 += 1\\n            occurence_0_until_i[i] = num_0\\n            occurence_1_until_i[i] = num_1\\n        \\n        # dp01[i] <==> #subsequence of 01 until index i\\n        dp01 = [0 for i in range(len(s))]\\n        # dp10[i] <==> #subsequence of 10 until index i\\n        dp10 = [0 for i in range(len(s))]\\n        for i in range(1, len(s)):\\n            dp01[i] = dp01[i - 1]\\n            dp10[i] = dp10[i - 1]\\n            if (s[i] == \\'1\\'):\\n                dp01[i] += occurence_0_until_i[i - 1]\\n            else:\\n                dp10[i] += occurence_1_until_i[i - 1]\\n        \\n        res = 0\\n        for i in range(2, len(s)):\\n            res += dp01[i - 1] if s[i] == \"0\" else dp10[i - 1]\\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        # i => #occurence of 0\\n        occurence_0_until_i = {}\\n        # i => #occurence of 1\\n        occurence_1_until_i = {}\\n        num_0 = num_1 = 0\\n        for i in range(len(s)):\\n            if (s[i] == \\'0\\'):\\n                num_0 += 1\\n            else:\\n                num_1 += 1\\n            occurence_0_until_i[i] = num_0\\n            occurence_1_until_i[i] = num_1\\n        \\n        # dp01[i] <==> #subsequence of 01 until index i\\n        dp01 = [0 for i in range(len(s))]\\n        # dp10[i] <==> #subsequence of 10 until index i\\n        dp10 = [0 for i in range(len(s))]\\n        for i in range(1, len(s)):\\n            dp01[i] = dp01[i - 1]\\n            dp10[i] = dp10[i - 1]\\n            if (s[i] == \\'1\\'):\\n                dp01[i] += occurence_0_until_i[i - 1]\\n            else:\\n                dp10[i] += occurence_1_until_i[i - 1]\\n        \\n        res = 0\\n        for i in range(2, len(s)):\\n            res += dp01[i - 1] if s[i] == \"0\" else dp10[i - 1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355749,
                "title": "python-shortest-dp",
                "content": "```python\\n def numberOfWays(self, s: str) -> int:\\n        a, b = [0,0], [0,0]\\n        res = 0 \\n        for i in map(int, s):\\n            b[i] += 1\\n            res += a[i^1]\\n            a[i] += b[i^1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n def numberOfWays(self, s: str) -> int:\\n        a, b = [0,0], [0,0]\\n        res = 0 \\n        for i in map(int, s):\\n            b[i] += 1\\n            res += a[i^1]\\n            a[i] += b[i^1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2314072,
                "title": "c-simple-solution-prefix-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        int n = s.size();\\n        vector<long long> prefix0(n, 0), prefix1 = prefix0;\\n        long long ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i)\\n                prefix0[i] = prefix0[i - 1], prefix1[i] = prefix1[i - 1];\\n            \\n            if(s[i] == \\'1\\')\\n                prefix1[i]++;\\n            else\\n                prefix0[i]++;\\n        }\\n        \\n        // Counting Number of 010 formations\\n        for(int i = 1; i < n - 1; i++)\\n            if(s[i] == \\'1\\')\\n                ans += prefix0[i - 1] * (prefix0[n - 1] - prefix0[i - 1]);\\n        \\n        // Counting Number of 101 formations\\n        for(int i = 1; i < n - 1; i++)\\n            if(s[i] == \\'0\\')\\n                ans += prefix1[i - 1] * (prefix1[n - 1] - prefix1[i - 1]);\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        int n = s.size();\\n        vector<long long> prefix0(n, 0), prefix1 = prefix0;\\n        long long ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i)\\n                prefix0[i] = prefix0[i - 1], prefix1[i] = prefix1[i - 1];\\n            \\n            if(s[i] == \\'1\\')\\n                prefix1[i]++;\\n            else\\n                prefix0[i]++;\\n        }\\n        \\n        // Counting Number of 010 formations\\n        for(int i = 1; i < n - 1; i++)\\n            if(s[i] == \\'1\\')\\n                ans += prefix0[i - 1] * (prefix0[n - 1] - prefix0[i - 1]);\\n        \\n        // Counting Number of 101 formations\\n        for(int i = 1; i < n - 1; i++)\\n            if(s[i] == \\'0\\')\\n                ans += prefix1[i - 1] * (prefix1[n - 1] - prefix1[i - 1]);\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290101,
                "title": "python-simple-maths",
                "content": "\\n    def numberOfWays(self, s):\\n        n = len(s)\\n        \\n        right_zeros = s.count(\"0\")\\n        right_ones = n - right_zeros\\n        \\n        result, left_zeros, left_ones = 0, 0, 0\\n        \\n        for i in range(n):\\n            if s[i] == \"1\":\\n                result += left_zeros*right_zeros\\n                left_ones += 1\\n                right_ones -= 1\\n            else:\\n                result += left_ones*right_ones\\n                left_zeros += 1\\n                right_zeros -= 1\\n                \\n        return result",
                "solutionTags": [],
                "code": "\\n    def numberOfWays(self, s):\\n        n = len(s)\\n        \\n        right_zeros = s.count(\"0\")\\n        right_ones = n - right_zeros\\n        \\n        result, left_zeros, left_ones = 0, 0, 0\\n        \\n        for i in range(n):\\n            if s[i] == \"1\":\\n                result += left_zeros*right_zeros\\n                left_ones += 1\\n                right_ones -= 1\\n            else:\\n                result += left_ones*right_ones\\n                left_zeros += 1\\n                right_zeros -= 1\\n                \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2263026,
                "title": "c-dp-prefix-and-suffix-array-concept",
                "content": "If current element is \\'0\\', total number of local answers would be product of all \\'1\\' before current index and all \\'1\\' after current index.\\nvice versa for \\'1\\'(product of all \\'0\\' before and after current index)\\n\\nNOTE: Practically, it\\'s enough to have information of number of zeros before and after each index. Calculation of number of ones can be computed from it only.\\n\\n```cpp\\n    long long numberOfWays(string s) {\\n      long long n = s.length();\\n      vector<long long> b(n);\\n      vector<long long> a(n);\\n      b[0] = 0;\\n      a[n-1] = 0;\\n      for(int i=1; i<n; i++){\\n          b[i] = b[i-1] + int(s[i-1] == \\'0\\');\\n          a[n-i-1] = a[n-i] + int(s[n-i] == \\'0\\');\\n      }\\n      long long ans = 0;\\n      for(int i=1; i<n-1; i++)\\n        if (s[i] == \\'1\\')\\n          ans += b[i]*a[i];\\n        else\\n          ans += (i-b[i])*(n-i-1-a[i]);\\n      return ans;\\n    }\\n```\\nTC: O(N)\\nSC: O(N)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n    long long numberOfWays(string s) {\\n      long long n = s.length();\\n      vector<long long> b(n);\\n      vector<long long> a(n);\\n      b[0] = 0;\\n      a[n-1] = 0;\\n      for(int i=1; i<n; i++){\\n          b[i] = b[i-1] + int(s[i-1] == \\'0\\');\\n          a[n-i-1] = a[n-i] + int(s[n-i] == \\'0\\');\\n      }\\n      long long ans = 0;\\n      for(int i=1; i<n-1; i++)\\n        if (s[i] == \\'1\\')\\n          ans += b[i]*a[i];\\n        else\\n          ans += (i-b[i])*(n-i-1-a[i]);\\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2212341,
                "title": "c-o-n-simple",
                "content": "a0 - No of 0\\'s so far\\na1 - No of 1\\'s so far\\na10 - No of 10\\'s so far \\na01 - No of 01\\'s so far\\nans is total 101\\'s or 010\\'s so far\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n\\t\\tlong long a0 = 1 - (s[0] - \\'0\\'), a1 = 1 - a0, a01 = 0, a10 = 0;\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') {\\n\\t\\t\\t\\ta10 += a1;\\n\\t\\t\\t\\tans += a01;\\n\\t\\t\\t\\ta0++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta01 += a0;\\n\\t\\t\\t\\tans += a10;\\n\\t\\t\\t\\ta1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n\\t\\tlong long a0 = 1 - (s[0] - \\'0\\'), a1 = 1 - a0, a01 = 0, a10 = 0;\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') {\\n\\t\\t\\t\\ta10 += a1;\\n\\t\\t\\t\\tans += a01;\\n\\t\\t\\t\\ta0++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta01 += a0;\\n\\t\\t\\t\\tans += a10;\\n\\t\\t\\t\\ta1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204058,
                "title": "2-solutions-generic-dp-solution-o-n-2-explained-and-greedy-o-n",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        ## 1. can be put in other words as: Find the number of subsequences with string \"010\" or \"101\"\\n        ## 2. dp[0][0] is obvious, 1st row is just the count of t[0], \\n        ##    1st column is all 0\\'s (why ? how many subseqs of \"010\" can you find from string \"0\" (i.es[0]) )\\n        ## 3. other cells, if characters match, sum of previous match without both s[j],t[i] ie.[i-1][j-1] + previous match without s[j]\\n        \\n        ## stack trace\\n        ## \"001101\", \"010\"\\n        ## [[1, 2, 2, 2, 3, 3], \\n        ## [0, 0, 2, 4, 4, 7], \\n        ## [0, 0, 0, 0, 4, 4]]\\n        \\n        ## \"001101\", \"101\"\\n        ## [[0, 0, 1, 2, 2, 3], \\n        ## [0, 0, 0, 0, 2, 2], \\n        ## [0, 0, 0, 0, 0, 2]]\\n        \\n        ## TIME COMPLEXITY : O(NxN) ##\\n\\n        def get_subseq_cnt(s, t):\\n            dp = [ [0 for _ in range(len(s))] for _ in range(len(t)) ]\\n            dp[0][0] = 1 if (s[0] == t[0]) else 0\\n            for i in range(len(t)):\\n                for j in range(1, len(s)):\\n                    if i == 0:\\n                        dp[0][j] = dp[0][j-1]\\n                        dp[0][j] += 1 if  s[j] == t[i] else 0\\n                    else:\\n                        if s[j] == t[i]:\\n                            dp[i][j] = dp[i-1][j-1] + dp[i][j-1]\\n                        else:\\n                            dp[i][j] = dp[i][j-1]\\n            # print(dp)\\n            return dp[-1][-1]\\n        return get_subseq_cnt(s, \"010\") + get_subseq_cnt(s, \"101\")\\n        ## The above solution is not optimized, passes the test cases though. but good to know \\n        ## this dp solution, as it can be applied for any 2 strings\\n        \\n        # Optimized O(N) solution\\n        # Reference: https://leetcode.com/problems/number-of-ways-to-select-buildings/discuss/1907109/PythonDP-easy-to-understand\\n        dp = {\"0\": 0, \"1\": 0, \"01\": 0, \"10\": 0, \"010\": 0, \"101\": 0}\\n        for i in range(len(s)):\\n            if s[i] == \"0\":\\n                dp[\"0\"] += 1\\n                dp[\"10\"] += dp[\"1\"]\\n                dp[\"010\"] += dp[\"01\"]\\n            if s[i] == \"1\":\\n                dp[\"1\"] += 1\\n                dp[\"01\"] += dp[\"0\"]\\n                dp[\"101\"] += dp[\"10\"]\\n        return dp[\"010\"] + dp[\"101\"]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        ## 1. can be put in other words as: Find the number of subsequences with string \"010\" or \"101\"\\n        ## 2. dp[0][0] is obvious, 1st row is just the count of t[0], \\n        ##    1st column is all 0\\'s (why ? how many subseqs of \"010\" can you find from string \"0\" (i.es[0]) )\\n        ## 3. other cells, if characters match, sum of previous match without both s[j],t[i] ie.[i-1][j-1] + previous match without s[j]\\n        \\n        ## stack trace\\n        ## \"001101\", \"010\"\\n        ## [[1, 2, 2, 2, 3, 3], \\n        ## [0, 0, 2, 4, 4, 7], \\n        ## [0, 0, 0, 0, 4, 4]]\\n        \\n        ## \"001101\", \"101\"\\n        ## [[0, 0, 1, 2, 2, 3], \\n        ## [0, 0, 0, 0, 2, 2], \\n        ## [0, 0, 0, 0, 0, 2]]\\n        \\n        ## TIME COMPLEXITY : O(NxN) ##\\n\\n        def get_subseq_cnt(s, t):\\n            dp = [ [0 for _ in range(len(s))] for _ in range(len(t)) ]\\n            dp[0][0] = 1 if (s[0] == t[0]) else 0\\n            for i in range(len(t)):\\n                for j in range(1, len(s)):\\n                    if i == 0:\\n                        dp[0][j] = dp[0][j-1]\\n                        dp[0][j] += 1 if  s[j] == t[i] else 0\\n                    else:\\n                        if s[j] == t[i]:\\n                            dp[i][j] = dp[i-1][j-1] + dp[i][j-1]\\n                        else:\\n                            dp[i][j] = dp[i][j-1]\\n            # print(dp)\\n            return dp[-1][-1]\\n        return get_subseq_cnt(s, \"010\") + get_subseq_cnt(s, \"101\")\\n        ## The above solution is not optimized, passes the test cases though. but good to know \\n        ## this dp solution, as it can be applied for any 2 strings\\n        \\n        # Optimized O(N) solution\\n        # Reference: https://leetcode.com/problems/number-of-ways-to-select-buildings/discuss/1907109/PythonDP-easy-to-understand\\n        dp = {\"0\": 0, \"1\": 0, \"01\": 0, \"10\": 0, \"010\": 0, \"101\": 0}\\n        for i in range(len(s)):\\n            if s[i] == \"0\":\\n                dp[\"0\"] += 1\\n                dp[\"10\"] += dp[\"1\"]\\n                dp[\"010\"] += dp[\"01\"]\\n            if s[i] == \"1\":\\n                dp[\"1\"] += 1\\n                dp[\"01\"] += dp[\"0\"]\\n                dp[\"101\"] += dp[\"10\"]\\n        return dp[\"010\"] + dp[\"101\"]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158709,
                "title": "puerly-logic",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        one,zero,one_zero ,zero_one,count=0,0,0,0,0\\n        for i in s:\\n            if i==\\'0\\':\\n                zero+=1\\n                one_zero+=one\\n                count+=zero_one\\n            else:\\n                one+=1\\n                zero_one+=zero\\n                count+=one_zero\\n        return count\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        one,zero,one_zero ,zero_one,count=0,0,0,0,0\\n        for i in s:\\n            if i==\\'0\\':\\n                zero+=1\\n                one_zero+=one\\n                count+=zero_one\\n            else:\\n                one+=1\\n                zero_one+=zero\\n                count+=one_zero\\n        return count\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2134762,
                "title": "easy-understanding-c-code-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[100005][3][4];\\n    long long helper(int idx,string &str,char prev,int len){\\n        \\n        if(len==3){\\n            return 1;\\n        }\\n        if(idx>=str.length()){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][prev-\\'0\\'][len]!=-1){\\n            return dp[idx][prev-\\'0\\'][len];\\n        }\\n        long long not_take=0;\\n        long long take=0;\\n        if(prev!=str[idx]){\\n            take=helper(idx+1,str,str[idx],len+1);\\n        }\\n    \\n        not_take=helper(idx+1,str,prev,len);\\n        long long ans=take+not_take;\\n        dp[idx][prev-\\'0\\'][len]=ans;\\n        return ans;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,s,\\'2\\',0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100005][3][4];\\n    long long helper(int idx,string &str,char prev,int len){\\n        \\n        if(len==3){\\n            return 1;\\n        }\\n        if(idx>=str.length()){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][prev-\\'0\\'][len]!=-1){\\n            return dp[idx][prev-\\'0\\'][len];\\n        }\\n        long long not_take=0;\\n        long long take=0;\\n        if(prev!=str[idx]){\\n            take=helper(idx+1,str,str[idx],len+1);\\n        }\\n    \\n        not_take=helper(idx+1,str,prev,len);\\n        long long ans=take+not_take;\\n        dp[idx][prev-\\'0\\'][len]=ans;\\n        return ans;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,s,\\'2\\',0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109061,
                "title": "easy-c-solution-with-full-explanation",
                "content": "Here we can have two types of patterns :- \"010\" and \"101\".\\n\\nSo, if we consider any s[i] as middle element, then we can find just the number of opponents towards left and right of it and the total no. of ways for that s[i] as middle element will be = no. of opponents in left * no. of opponents in right.\\n\\nSo, we run the loop from index 1 to index n-2 as left and right extreme can\\'t be taken as middle element of our two patterns.\\n\\nSo, suppose current character is \\'0\\' , then total ways for this character as middle element of our pattern = no. of 1\\'s in left of it * no. of 1\\'s in right of it.\\nAnd vice versa the case if \\'1\\' is current character.\\n\\nSo, to do this we can take a prefix array and suffix array which stores count of 1 and 0 towards left and right consecutively.\\n\\nSo, total count will be addition of all counts taken all characters as middle element one by one.\\n\\nCODE :- \\n\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        \\n        vector<pair<ll,ll>> prefix(n);\\n        vector<pair<ll,ll>> suffix(n);\\n        \\n        prefix[0] = {0,0};\\n        suffix[n-1] = {0,0};\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i-1] == \\'0\\')\\n            {\\n                prefix[i] = {prefix[i-1].first + 1,prefix[i-1].second};\\n            }\\n            else\\n            {\\n                prefix[i] = {prefix[i-1].first,prefix[i-1].second + 1}; \\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i+1] == \\'0\\')\\n            {\\n                suffix[i] = {suffix[i+1].first + 1,suffix[i+1].second};\\n            }\\n            else\\n            {\\n                suffix[i] = {suffix[i+1].first,suffix[i+1].second + 1};\\n            }\\n        }\\n        \\n        ll res = 0;\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                res += prefix[i].second * suffix[i].second;\\n            }\\n            else\\n            {\\n                res += prefix[i].first * suffix[i].first;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        \\n        vector<pair<ll,ll>> prefix(n);\\n        vector<pair<ll,ll>> suffix(n);\\n        \\n        prefix[0] = {0,0};\\n        suffix[n-1] = {0,0};\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i-1] == \\'0\\')\\n            {\\n                prefix[i] = {prefix[i-1].first + 1,prefix[i-1].second};\\n            }\\n            else\\n            {\\n                prefix[i] = {prefix[i-1].first,prefix[i-1].second + 1}; \\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i+1] == \\'0\\')\\n            {\\n                suffix[i] = {suffix[i+1].first + 1,suffix[i+1].second};\\n            }\\n            else\\n            {\\n                suffix[i] = {suffix[i+1].first,suffix[i+1].second + 1};\\n            }\\n        }\\n        \\n        ll res = 0;\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                res += prefix[i].second * suffix[i].second;\\n            }\\n            else\\n            {\\n                res += prefix[i].first * suffix[i].first;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097331,
                "title": "counting-subsequences-of-010-and-101-in-the-string",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  long long dp[100000][3];\\n  \\n  long long count(string &s1,string &s,int n,int m){\\n    if(n==0|| (m==0&&n==0)){\\n      return 1;\\n    }\\n    if(m==0) return 0;\\n    if(dp[m-1][n-1]!=-1) return dp[m-1][n-1];\\n    if(s1[n-1]==s[m-1]){\\n      return dp[m-1][n-1]=count(s1,s,n-1,m-1) + count(s1,s,n,m-1);\\n    }\\n    return dp[m-1][n-1]=count(s1,s,n,m-1);\\n  }\\n  \\n    long long numberOfWays(string s) {\\n      string s1=\"101\",s2=\"010\";\\n      int x=3,y=s.size();\\n      for(int i=0;i<y;i++){\\n        for(int j=0;j<3;j++){\\n          dp[i][j]=-1;\\n        }\\n      }\\n      long long a1=count(s1,s,x,y);\\n      for(int i=0;i<y;i++){\\n        for(int j=0;j<3;j++){\\n          dp[i][j]=-1;\\n        }\\n      }\\n      long long a2=count(s2,s,x,y);\\n      return a2+a1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  long long dp[100000][3];\\n  \\n  long long count(string &s1,string &s,int n,int m){\\n    if(n==0|| (m==0&&n==0)){\\n      return 1;\\n    }\\n    if(m==0) return 0;\\n    if(dp[m-1][n-1]!=-1) return dp[m-1][n-1];\\n    if(s1[n-1]==s[m-1]){\\n      return dp[m-1][n-1]=count(s1,s,n-1,m-1) + count(s1,s,n,m-1);\\n    }\\n    return dp[m-1][n-1]=count(s1,s,n,m-1);\\n  }\\n  \\n    long long numberOfWays(string s) {\\n      string s1=\"101\",s2=\"010\";\\n      int x=3,y=s.size();\\n      for(int i=0;i<y;i++){\\n        for(int j=0;j<3;j++){\\n          dp[i][j]=-1;\\n        }\\n      }\\n      long long a1=count(s1,s,x,y);\\n      for(int i=0;i<y;i++){\\n        for(int j=0;j<3;j++){\\n          dp[i][j]=-1;\\n        }\\n      }\\n      long long a2=count(s2,s,x,y);\\n      return a2+a1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096733,
                "title": "easiest-cpp-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long int c0 = 0, c1 = 0, c01 = 0, c10 = 0, c101 = 0, c010 = 0;\\n        for(char &c: s)\\n        {\\n            if(c==\\'0\\')\\n            {\\n                c10 += c1;\\n                c010 += c01;\\n                c0++;\\n            }\\n            else\\n            {\\n                c01 += c0;\\n                c101 += c10;\\n                c1++;\\n            }\\n        }\\n        return c101 + c010;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long int c0 = 0, c1 = 0, c01 = 0, c10 = 0, c101 = 0, c010 = 0;\\n        for(char &c: s)\\n        {\\n            if(c==\\'0\\')\\n            {\\n                c10 += c1;\\n                c010 += c01;\\n                c0++;\\n            }\\n            else\\n            {\\n                c01 += c0;\\n                c101 += c10;\\n                c1++;\\n            }\\n        }\\n        return c101 + c010;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057425,
                "title": "c-easy-recursion-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long dp[100000][3][3];\\n    \\n    long long giveAns(string &s,int start,int count,char prev){\\n        if(count==3)  return 1;\\n        if(start>=s.length()) return 0;\\n        if(dp[start][count][prev-\\'0\\']!=-1) return dp[start][count][prev-\\'0\\'];\\n        if(s[start]==prev) return dp[start][count][prev-\\'0\\']=giveAns(s,start+1,count,prev);\\n        return dp[start][count][prev-\\'0\\']=giveAns(s,start+1,count+1,s[start])+giveAns(s,start+1,count,prev);\\n    }\\n    \\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return giveAns(s,0,0,\\'2\\');\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long dp[100000][3][3];\\n    \\n    long long giveAns(string &s,int start,int count,char prev){\\n        if(count==3)  return 1;\\n        if(start>=s.length()) return 0;\\n        if(dp[start][count][prev-\\'0\\']!=-1) return dp[start][count][prev-\\'0\\'];\\n        if(s[start]==prev) return dp[start][count][prev-\\'0\\']=giveAns(s,start+1,count,prev);\\n        return dp[start][count][prev-\\'0\\']=giveAns(s,start+1,count+1,s[start])+giveAns(s,start+1,count,prev);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2050520,
                "title": "c-easy-solution-well-commented-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    // we have to find only 010 and 101 these two pairs count\\n    // in this question we fix the element in the midlle and find left and right count for the\\n    //example if middle element is 0 we have to find count of 1 in the left and int right and subtract them for finding total count of 101\\n    //same if we fix 1 in the middle we have to find the count of 0 in the left and right\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        vector<long long>left0(n,0),left1(n,0),right0(n,0),right1(n,0);\\n        long long c1=0;long long c2=0;\\n        //for finding left1 and right 1\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c1++;\\n            }\\n            left1[i]=c1;\\n            if(s[n-i-1]==\\'1\\'){\\n                //checking from the end\\n                c2++;\\n            }\\n            right1[n-i-1]=c2;\\n            \\n        }\\n        c1=0;\\n        c2=0;\\n        //for finding left0 and right0\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                //checking from the start\\n                c1++;\\n            }\\n            left0[i]=c1;\\n            //checking from the end\\n            if(s[n-i-1]==\\'0\\'){\\n                c2++;\\n            }\\n            right0[n-i-1]=c2;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                ans+=left1[i]*right1[i];\\n            }\\n            else if(s[i]==\\'1\\'){\\n                ans+=left0[i]*right0[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // we have to find only 010 and 101 these two pairs count\\n    // in this question we fix the element in the midlle and find left and right count for the\\n    //example if middle element is 0 we have to find count of 1 in the left and int right and subtract them for finding total count of 101\\n    //same if we fix 1 in the middle we have to find the count of 0 in the left and right\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        vector<long long>left0(n,0),left1(n,0),right0(n,0),right1(n,0);\\n        long long c1=0;long long c2=0;\\n        //for finding left1 and right 1\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c1++;\\n            }\\n            left1[i]=c1;\\n            if(s[n-i-1]==\\'1\\'){\\n                //checking from the end\\n                c2++;\\n            }\\n            right1[n-i-1]=c2;\\n            \\n        }\\n        c1=0;\\n        c2=0;\\n        //for finding left0 and right0\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                //checking from the start\\n                c1++;\\n            }\\n            left0[i]=c1;\\n            //checking from the end\\n            if(s[n-i-1]==\\'0\\'){\\n                c2++;\\n            }\\n            right0[n-i-1]=c2;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                ans+=left1[i]*right1[i];\\n            }\\n            else if(s[i]==\\'1\\'){\\n                ans+=left0[i]*right0[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981061,
                "title": "easy-understandable-c-solution-with-detailed-explanation",
                "content": "Explaination:\\nFor an index i, If the character at the ith index is 1 then we will try to find number of \\'01\\' on the right side of that index, and If the character at the inde i is \\'0\\', then we will find number of \\'10\\' on the right side of that index. In order to find \\'10\\' we can find number of zeroes on the right of that index, similarly it can be done to find \\'01\\' as well. We can use suffix array to calculate the required combinations.\\n\\nCode:\\n```\\n long long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<long long> zo(n),oz(n);\\n        int cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'1\\')oz[i] = cnt;\\n            if(s[i] == \\'0\\')cnt++;\\n        }\\n        cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'0\\')zo[i] = cnt;\\n            if(s[i] == \\'1\\')cnt++;\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            oz[i] += oz[i+1];\\n            zo[i] += zo[i+1];\\n        }\\n        long long res = 0LL;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                res+=zo[i];\\n            }\\n            else{\\n                res+=oz[i];\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n long long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<long long> zo(n),oz(n);\\n        int cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'1\\')oz[i] = cnt;\\n            if(s[i] == \\'0\\')cnt++;\\n        }\\n        cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'0\\')zo[i] = cnt;\\n            if(s[i] == \\'1\\')cnt++;\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            oz[i] += oz[i+1];\\n            zo[i] += zo[i+1];\\n        }\\n        long long res = 0LL;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                res+=zo[i];\\n            }\\n            else{\\n                res+=oz[i];\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976277,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long z = 0, o = 0, zo = 0, oz = 0, zoz = 0, ozo = 0;\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'0\\') {\\n                zoz += zo;\\n                oz += o;\\n                z++;\\n            }\\n            else {\\n                ozo += oz;\\n                zo += z;\\n                o++;\\n            }\\n        }\\n        return zoz + ozo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long z = 0, o = 0, zo = 0, oz = 0, zoz = 0, ozo = 0;\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'0\\') {\\n                zoz += zo;\\n                oz += o;\\n                z++;\\n            }\\n            else {\\n                ozo += oz;\\n                zo += z;\\n                o++;\\n            }\\n        }\\n        return zoz + ozo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960791,
                "title": "c-solution-with-explanation-easy-to-understand",
                "content": "**in this approach I am traversing the whole nums vector and doing\\nI.  ans+=(num of left \\'0\\')x(num of right \\'0\\') [if current nums[i]==1][case : \"010\"]\\nII. ans+=(num of left \\'1\\')x(num of right \\'1\\') [if current nums[i]==0][case : \"101\"]**\\n\\n\\n------------------------------------------------------------------------------------------------\\n\\n\\n**I have made vectors of numbers of left zero,right zero,left one,right one using prefix sum to make overall time complexity O(n)**\\n\\n-------------------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        \\n        vector<int> l0(n,0),l1(n,0),r0(n,0),r1(n,0);\\n        \\n        int c=0,c2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                c++;\\n            }\\n            l0[i]=c;\\n            if(s[n-i-1]==\\'0\\')\\n            {\\n                c2++;\\n            }\\n            r0[n-i-1]=c2;\\n        }\\n        \\n        c=0;\\n        c2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n            }\\n            l1[i]=c;\\n            if(s[n-i-1]==\\'1\\')\\n            {\\n                c2++;\\n            }\\n            r1[n-i-1]=c2;\\n        }\\n        \\n        long long ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                ans+=l0[i]*1LL*r0[i];\\n            else\\n                ans+=l1[i]*1LL*r1[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        \\n        vector<int> l0(n,0),l1(n,0),r0(n,0),r1(n,0);\\n        \\n        int c=0,c2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                c++;\\n            }\\n            l0[i]=c;\\n            if(s[n-i-1]==\\'0\\')\\n            {\\n                c2++;\\n            }\\n            r0[n-i-1]=c2;\\n        }\\n        \\n        c=0;\\n        c2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n            }\\n            l1[i]=c;\\n            if(s[n-i-1]==\\'1\\')\\n            {\\n                c2++;\\n            }\\n            r1[n-i-1]=c2;\\n        }\\n        \\n        long long ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                ans+=l0[i]*1LL*r0[i];\\n            else\\n                ans+=l1[i]*1LL*r1[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943879,
                "title": "c-short-code-t-o-n-s-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long zero1 = 0, zero2 = 0, zero3 = 0, one1 = 0, one2 = 0, one3 = 0;\\n        for (char c : s) {\\n            if (c == \\'0\\') {\\n                zero1++;\\n                zero2 += one1;\\n                zero3 += one2;\\n            } else {\\n                one1++;\\n                one2 += zero1;\\n                one3 += zero2;\\n            }\\n        }\\n        \\n        return zero3 + one3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long zero1 = 0, zero2 = 0, zero3 = 0, one1 = 0, one2 = 0, one3 = 0;\\n        for (char c : s) {\\n            if (c == \\'0\\') {\\n                zero1++;\\n                zero2 += one1;\\n                zero3 += one2;\\n            } else {\\n                one1++;\\n                one2 += zero1;\\n                one3 += zero2;\\n            }\\n        }\\n        \\n        return zero3 + one3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930855,
                "title": "python-o-n-time",
                "content": "# class Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeros = ones = 0\\n        ans = [0] * len(s)\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                ans[i] = zeros\\n                ones += 1\\n            else:\\n                ans[i] = ones\\n                zeros += 1\\n        zeros = ones = 0\\n        \\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                ans[i] *= zeros\\n                ones += 1\\n            else:\\n                ans[i] *= ones\\n                zeros += 1\\n        \\n        return sum(ans)\\n\\n# class Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = {\\'0\\':0,\\'1\\':0,\\'01\\':0,\\'10\\':0,\\'010\\':0,\\'101\\':0}\\n        \\n        for i in s:\\n            dp[i] += 1\\n            if i == \\'0\\':\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        \\n        return dp[\\'010\\'] + dp[\\'101\\']\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeros = ones = 0\\n        ans = [0] * len(s)\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                ans[i] = zeros\\n                ones += 1\\n            else:\\n                ans[i] = ones\\n                zeros += 1\\n        zeros = ones = 0\\n        \\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                ans[i] *= zeros\\n                ones += 1\\n            else:\\n                ans[i] *= ones\\n                zeros += 1\\n        \\n        return sum(ans)\\n\\n# class Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = {\\'0\\':0,\\'1\\':0,\\'01\\':0,\\'10\\':0,\\'010\\':0,\\'101\\':0}",
                "codeTag": "Java"
            },
            {
                "id": 1927176,
                "title": "c-dp-o-n-using-distinct-subsequence-count-of-101-and-010-in-string",
                "content": "class Solution {\\npublic:\\n    \\n    // O(n) solution because str size is always 3\\n    // this function counts no of distinct subsequence of str in s uning dp approach\\n    long long count(string s,string str){\\n        long long m = s.size(), n = str.size();\\n        long long dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(long long i = 0;i<=m;i++) dp[i][0] = 1;\\n        for(long long i = 1;i<=m;i++){\\n            for(long long j = 1;j<=n;j++){\\n                dp[i][j] = dp[i-1][j]+((s[i-1] == str[j-1])?dp[i-1][j-1]:0);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    \\n    long long numberOfWays(string s) {\\n        string str1 = \"010\";\\n        string str2 = \"101\";\\n        // counting distinct subsequence\\n        long long res = count(s,str1)+count(s,str2);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // O(n) solution because str size is always 3\\n    // this function counts no of distinct subsequence of str in s uning dp approach\\n    long long count(string s,string str){\\n        long long m = s.size(), n = str.size();\\n        long long dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(long long i = 0;i<=m;i++) dp[i][0] = 1;\\n        for(long long i = 1;i<=m;i++){\\n            for(long long j = 1;j<=n;j++){\\n                dp[i][j] = dp[i-1][j]+((s[i-1] == str[j-1])?dp[i-1][j-1]:0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1925936,
                "title": "java-greedy-prefix-sum-time-on-space-on",
                "content": "Runtime: 40 ms, faster than 78.48% of Java online submissions for Number of Ways to Select Buildings.\\nMemory Usage: 43.5 MB, less than 91.81% of Java online submissions for Number of Ways to Select Buildings.\\n```\\nclass Solution {\\n  public long numberOfWays(String s) {\\n    long ans = 0, L[] = new long[s.length()], z = 0;  //L - for count of all zeros before current position, z - total zeros\\n    \\n    for(int i = 0; i != s.length(); i++)              //fill L and count z\\n      L[i] = s.charAt(i) == \\'0\\' ? ++z : z;\\n    \\n    for(int i = 1; i != s.length() - 1; i++)          //all left numbers * all right the same numbers for current position  \\n      ans += s.charAt(i) == \\'1\\' ? L[i-1] * (z - L[i-1]) : (i - L[i-1]) * (s.length() - i - 1 - z + L[i]);\\n     \\n    return ans;  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long numberOfWays(String s) {\\n    long ans = 0, L[] = new long[s.length()], z = 0;  //L - for count of all zeros before current position, z - total zeros\\n    \\n    for(int i = 0; i != s.length(); i++)              //fill L and count z\\n      L[i] = s.charAt(i) == \\'0\\' ? ++z : z;\\n    \\n    for(int i = 1; i != s.length() - 1; i++)          //all left numbers * all right the same numbers for current position  \\n      ans += s.charAt(i) == \\'1\\' ? L[i-1] * (z - L[i-1]) : (i - L[i-1]) * (s.length() - i - 1 - z + L[i]);\\n     \\n    return ans;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918286,
                "title": "super-easy-understanding-c",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n        ll first_zero=0,first_one=0,second_zero=0,second_one=0;\\n        ll ans=0;\\n        for(auto &x:s)\\n        {\\n            if(x==\\'0\\')\\n            {\\n                first_zero++;\\n                second_zero+=first_one;\\n                ans+=second_one;\\n            }else if(x==\\'1\\')\\n            {\\n                first_one++;\\n                second_one+=first_zero;\\n                ans+=second_zero;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n        ll first_zero=0,first_one=0,second_zero=0,second_one=0;\\n        ll ans=0;\\n        for(auto &x:s)\\n        {\\n            if(x==\\'0\\')\\n            {\\n                first_zero++;\\n                second_zero+=first_one;\\n                ans+=second_one;\\n            }else if(x==\\'1\\')\\n            {\\n                first_one++;\\n                second_one+=first_zero;\\n                ans+=second_zero;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917670,
                "title": "c-prefix-and-suffix-array-o-n",
                "content": "```\\nlong long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int> left_zero(n, 0), right_zero(n, 0), left_one(n, 0), right_one(n, 0);\\n        left_zero.push_back(0);\\n        left_one.push_back(1);\\n        for(int i = 1; i < s.length(); ++i){\\n            if(s[i-1] == \\'0\\'){\\n                left_zero[i] = 1 + left_zero[i-1];\\n                left_one[i] = left_one[i-1];\\n            }\\n            else{\\n                left_one[i] = 1 + left_one[i-1];\\n                left_zero[i] = left_zero[i-1];\\n            }\\n        }\\n        right_zero.push_back(0);\\n        right_one.push_back(1);\\n        for(int i = s.length() - 2; i >= 0; --i){\\n            if(s[i+1] == \\'0\\'){\\n                right_zero[i] = 1 + right_zero[i+1];\\n                right_one[i] = right_one[i+1];\\n            }\\n            else{\\n                right_one[i] = 1 + right_one[i+1];\\n                right_zero[i] = right_zero[i+1];\\n            }\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < s.length() - 1; ++i){\\n            if(s[i] == \\'0\\'){\\n                if(left_one[i] != 0 && right_one[i] != 0)\\n                    // ans += max(left_one[i], right_one[i]);\\n                    ans += left_one[i]*right_one[i];\\n            }\\n            else{\\n                if(left_zero[i] != 0 && right_zero[i] != 0)\\n                    // ans += max(left_zero[i], right_zero[i]);\\n                    ans += left_zero[i]*right_zero[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int> left_zero(n, 0), right_zero(n, 0), left_one(n, 0), right_one(n, 0);\\n        left_zero.push_back(0);\\n        left_one.push_back(1);\\n        for(int i = 1; i < s.length(); ++i){\\n            if(s[i-1] == \\'0\\'){\\n                left_zero[i] = 1 + left_zero[i-1];\\n                left_one[i] = left_one[i-1];\\n            }\\n            else{\\n                left_one[i] = 1 + left_one[i-1];\\n                left_zero[i] = left_zero[i-1];\\n            }\\n        }\\n        right_zero.push_back(0);\\n        right_one.push_back(1);\\n        for(int i = s.length() - 2; i >= 0; --i){\\n            if(s[i+1] == \\'0\\'){\\n                right_zero[i] = 1 + right_zero[i+1];\\n                right_one[i] = right_one[i+1];\\n            }\\n            else{\\n                right_one[i] = 1 + right_one[i+1];\\n                right_zero[i] = right_zero[i+1];\\n            }\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < s.length() - 1; ++i){\\n            if(s[i] == \\'0\\'){\\n                if(left_one[i] != 0 && right_one[i] != 0)\\n                    // ans += max(left_one[i], right_one[i]);\\n                    ans += left_one[i]*right_one[i];\\n            }\\n            else{\\n                if(left_zero[i] != 0 && right_zero[i] != 0)\\n                    // ans += max(left_zero[i], right_zero[i]);\\n                    ans += left_zero[i]*right_zero[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914665,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        int n = s.size();\\n        long long ans = 0;\\n        \\n        vector<int> leftOnes(n,0), rightOnes(n,0), leftZeros(n,0), rightZeros(n,0);\\n        \\n        int zeros=0, ones=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            zeros+= s[i]==\\'0\\';\\n            ones+= s[i] == \\'1\\';\\n            \\n            leftZeros[i]=zeros;\\n            leftOnes[i]=ones;\\n            \\n        }\\n        \\n        zeros=ones=0;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            \\n            zeros+= s[i]==\\'0\\';\\n            ones+= s[i]==\\'1\\';\\n            \\n            rightOnes[i]=ones;\\n            rightZeros[i]=zeros;\\n            \\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\'0\\') ans+= leftOnes[i]*rightOnes[i];\\n            else ans+= leftZeros[i]*rightZeros[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        int n = s.size();\\n        long long ans = 0;\\n        \\n        vector<int> leftOnes(n,0), rightOnes(n,0), leftZeros(n,0), rightZeros(n,0);\\n        \\n        int zeros=0, ones=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            zeros+= s[i]==\\'0\\';\\n            ones+= s[i] == \\'1\\';\\n            \\n            leftZeros[i]=zeros;\\n            leftOnes[i]=ones;\\n            \\n        }\\n        \\n        zeros=ones=0;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            \\n            zeros+= s[i]==\\'0\\';\\n            ones+= s[i]==\\'1\\';\\n            \\n            rightOnes[i]=ones;\\n            rightZeros[i]=zeros;\\n            \\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\'0\\') ans+= leftOnes[i]*rightOnes[i];\\n            else ans+= leftZeros[i]*rightZeros[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912744,
                "title": "c-count-zero-and-one-o-n-time-o-1-space",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long numberOfWays(string s) {\\n\\t\\t\\tll res = 0,cnt1 = 0,cnt0 = 0;\\n\\t\\t\\tfor(auto x:s) x==\\'1\\'?cnt1++:cnt0++;\\n\\n\\t\\t\\tfor(int i=0,one=0,zero=0;i<s.length();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\'){\\n\\t\\t\\t\\t\\tone++;  \\n\\t\\t\\t\\t\\tres+= zero*(cnt0-zero);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tzero++;\\n\\t\\t\\t\\t\\tres+= one*(cnt1-one);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long numberOfWays(string s) {\\n\\t\\t\\tll res = 0,cnt1 = 0,cnt0 = 0;\\n\\t\\t\\tfor(auto x:s) x==\\'1\\'?cnt1++:cnt0++;\\n\\n\\t\\t\\tfor(int i=0,one=0,zero=0;i<s.length();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\'){\\n\\t\\t\\t\\t\\tone++;  \\n\\t\\t\\t\\t\\tres+= zero*(cnt0-zero);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1910711,
                "title": "learn-how-not-to-complicate-a-simple-question-memoization-dp",
                "content": "```\\nclass Solution {\\n\\n    HashMap<String,Long> map;\\n    \\n    public long numberOfWays(String s) {\\n        int n = s.length();\\n        map = new HashMap<>();\\n        return helper(s,0,\\'2\\',new StringBuilder());\\n    }\\n    \\n    public long helper(String str, int i, char prev, StringBuilder sb){\\n        \\n        if(i == str.length()){\\n            if(sb.length() == 3)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        if(sb.length() == 3){\\n            return 1;\\n        }\\n        \\n        String str1 = new String(Integer.toString(i)+\" \"+(prev+\"\")+\" \"+sb.toString());\\n        \\n        if(map.containsKey(str1))\\n            return map.get(str1);\\n        \\n        long left = 0;\\n        \\n        for(int j=i; j<str.length(); j++){\\n            \\n            if(str.charAt(j) == prev)\\n                continue;\\n            \\n            else{\\n                \\n                sb.append(str.charAt(j));\\n                \\n                String str2 = new String(Integer.toString(j)+\" \"+(str.charAt(j)+\"\")+\" \"+sb.toString());\\n                \\n                if(map.containsKey(str2))\\n                    left += map.get(str2);\\n                else{\\n                    long intd = helper(str,j+1,str.charAt(j),sb);\\n                    map.put(str2,intd);             \\n                    left += intd;\\n                }\\n                \\n                sb.deleteCharAt(sb.length()-1);\\n            }\\n        }\\n        \\n        map.put(str1,left);\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    HashMap<String,Long> map;\\n    \\n    public long numberOfWays(String s) {\\n        int n = s.length();\\n        map = new HashMap<>();\\n        return helper(s,0,\\'2\\',new StringBuilder());\\n    }\\n    \\n    public long helper(String str, int i, char prev, StringBuilder sb){\\n        \\n        if(i == str.length()){\\n            if(sb.length() == 3)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        if(sb.length() == 3){\\n            return 1;\\n        }\\n        \\n        String str1 = new String(Integer.toString(i)+\" \"+(prev+\"\")+\" \"+sb.toString());\\n        \\n        if(map.containsKey(str1))\\n            return map.get(str1);\\n        \\n        long left = 0;\\n        \\n        for(int j=i; j<str.length(); j++){\\n            \\n            if(str.charAt(j) == prev)\\n                continue;\\n            \\n            else{\\n                \\n                sb.append(str.charAt(j));\\n                \\n                String str2 = new String(Integer.toString(j)+\" \"+(str.charAt(j)+\"\")+\" \"+sb.toString());\\n                \\n                if(map.containsKey(str2))\\n                    left += map.get(str2);\\n                else{\\n                    long intd = helper(str,j+1,str.charAt(j),sb);\\n                    map.put(str2,intd);             \\n                    left += intd;\\n                }\\n                \\n                sb.deleteCharAt(sb.length()-1);\\n            }\\n        }\\n        \\n        map.put(str1,left);\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910430,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nlong long numberOfWays(string str) {\\n        \\n        int n = str.size();\\n        \\n        vector<int> zero(n + 1, 0);\\n        \\n        vector<int> one(n + 1, 0);\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(str[i - 1] == \\'0\\')\\n            {\\n                zero[i] = 1 + zero[i - 1];\\n            }\\n            else\\n            {\\n                zero[i] = zero[i - 1];\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(str[i - 1] == \\'1\\')\\n            {\\n                one[i] = 1 + one[i - 1];\\n            }\\n            \\n            else\\n            {\\n                one[i] = one[i - 1];\\n            }\\n        }\\n        \\n        long long count_ways = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = 0;\\n            \\n            int right = 0;\\n            \\n            if(str[i] == \\'0\\')\\n            {\\n                left = one[i];\\n                \\n                right = one[n] - one[i + 1];\\n            }\\n            \\n            else\\n            {\\n                left = zero[i];\\n                \\n                right = zero[n] - zero[i + 1];\\n            }\\n            \\n            count_ways += (long long) left * (long long) right;\\n        }\\n        \\n        return count_ways;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long numberOfWays(string str) {\\n        \\n        int n = str.size();\\n        \\n        vector<int> zero(n + 1, 0);\\n        \\n        vector<int> one(n + 1, 0);\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(str[i - 1] == \\'0\\')\\n            {\\n                zero[i] = 1 + zero[i - 1];\\n            }\\n            else\\n            {\\n                zero[i] = zero[i - 1];\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(str[i - 1] == \\'1\\')\\n            {\\n                one[i] = 1 + one[i - 1];\\n            }\\n            \\n            else\\n            {\\n                one[i] = one[i - 1];\\n            }\\n        }\\n        \\n        long long count_ways = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = 0;\\n            \\n            int right = 0;\\n            \\n            if(str[i] == \\'0\\')\\n            {\\n                left = one[i];\\n                \\n                right = one[n] - one[i + 1];\\n            }\\n            \\n            else\\n            {\\n                left = zero[i];\\n                \\n                right = zero[n] - zero[i + 1];\\n            }\\n            \\n            count_ways += (long long) left * (long long) right;\\n        }\\n        \\n        return count_ways;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909631,
                "title": "python-using-principle-of-counting",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeroes, ones = s.count(\\'0\\') , s.count(\\'1\\')\\n        local0, local1, ans = 0, 0, 0\\n        for i in s:\\n            if i == \\'0\\':\\n                zeroes -= 1\\n                local0 += 1\\n                ans += local1 * ones  #choose any one of previous ones and any one of the next ones\\n            else:\\n                ones -= 1\\n                local1 += 1\\n                ans += local0 * zeroes #choose any one of previous zeroes and any one of the next zeroes\\n        return ans\\n                \\n          ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeroes, ones = s.count(\\'0\\') , s.count(\\'1\\')\\n        local0, local1, ans = 0, 0, 0\\n        for i in s:\\n            if i == \\'0\\':\\n                zeroes -= 1\\n                local0 += 1\\n                ans += local1 * ones  #choose any one of previous ones and any one of the next ones\\n            else:\\n                ones -= 1\\n                local1 += 1\\n                ans += local0 * zeroes #choose any one of previous zeroes and any one of the next zeroes\\n        return ans\\n                \\n          ```",
                "codeTag": "Java"
            },
            {
                "id": 1909545,
                "title": "beginner-friendly-recursive-solutions-and-o-n-optimized-solution",
                "content": "Recursive solution in python (**Will give TLE,Only for learning purpose**)\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ways=0\\n    def numberOfWays(self, s: str) -> int:\\n        self.ways=0\\n        slen=len(s)\\n        def nways(index,prev,length,slen,s):\\n            if(index==slen):\\n                return 0\\n            if(s[index]!=prev):\\n                if(length==2):\\n                    self.ways+=1\\n                    nways(index+1,prev,length,slen,s)\\n                else:\\n                    nways(index+1,s[index],length+1,slen,s)\\n                    nways(index+1,prev,length,slen,s)\\n            else:\\n                nways(index+1,prev,length,slen,s)\\n        nways(0,\\'-1\\',0,slen,s)\\n        return self.ways        \\n```\\n\\nO(N) Optmized Solution!!! (JAVA)\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int slen=s.length();\\n        long ways=0;\\n        long[] lcount= new long[slen];\\n        long[] rcount = new long[slen];\\n        int zerocount=0,onecount=0;\\n        for(int i=0;i<slen;i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zerocount++;\\n                lcount[i]=onecount;\\n            }\\n            else{\\n                onecount++;\\n                lcount[i]=zerocount;\\n            }\\n        }\\n        zerocount=0;\\n        onecount=0;\\n        for(int i=slen-1;i>=0;i--){\\n            if(s.charAt(i)==\\'0\\'){\\n                zerocount++;\\n                rcount[i]=onecount;\\n            }\\n            else{\\n                onecount++;\\n                rcount[i]=zerocount;\\n            }\\n        }\\n        for(int i=0;i<slen;i++){\\n            ways+=lcount[i]*rcount[i];\\n        }\\n        return ways;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ways=0\\n    def numberOfWays(self, s: str) -> int:\\n        self.ways=0\\n        slen=len(s)\\n        def nways(index,prev,length,slen,s):\\n            if(index==slen):\\n                return 0\\n            if(s[index]!=prev):\\n                if(length==2):\\n                    self.ways+=1\\n                    nways(index+1,prev,length,slen,s)\\n                else:\\n                    nways(index+1,s[index],length+1,slen,s)\\n                    nways(index+1,prev,length,slen,s)\\n            else:\\n                nways(index+1,prev,length,slen,s)\\n        nways(0,\\'-1\\',0,slen,s)\\n        return self.ways        \\n```\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int slen=s.length();\\n        long ways=0;\\n        long[] lcount= new long[slen];\\n        long[] rcount = new long[slen];\\n        int zerocount=0,onecount=0;\\n        for(int i=0;i<slen;i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zerocount++;\\n                lcount[i]=onecount;\\n            }\\n            else{\\n                onecount++;\\n                lcount[i]=zerocount;\\n            }\\n        }\\n        zerocount=0;\\n        onecount=0;\\n        for(int i=slen-1;i>=0;i--){\\n            if(s.charAt(i)==\\'0\\'){\\n                zerocount++;\\n                rcount[i]=onecount;\\n            }\\n            else{\\n                onecount++;\\n                rcount[i]=zerocount;\\n            }\\n        }\\n        for(int i=0;i<slen;i++){\\n            ways+=lcount[i]*rcount[i];\\n        }\\n        return ways;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909430,
                "title": "easy-approach-by-counting-the-1s-and-0s-before-each-index",
                "content": "So basically we can only have 2 combinations 010 and 101.\\nSo for each index if we have a 0 we can just check the no. of 1s present before it and number of 1s present after it.\\nWe can take these 2 numbers and multiply, that will be the number of valid selections using that index. \\nWe do the same if the current index is 1 , by multiplying the no of 0s before and after the index.\\n\\nThe sum of the calculated values for all the indexes will be our answer i.e the total no. of comnbinations.\\nWe can get the no. of 0s or 1s before and after an index in O(1) by storing the 0s and 1s before every index in  an array and by having the total no. of 0s and 1s present in our string.\\n0s and 1s before every index we will store.\\n0s and 1s after every index can be extracted by total0s- (0s before the index)\\nsame for 1s.\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int num0sBefore[]=new int[s.length()];\\n        int num1sBefore[]=new int[s.length()];\\n       long total1s=0;\\n       long total0s=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\'){\\n                total0s++;\\n                if(i==s.length()-1)\\n                    break;\\n                num0sBefore[i+1]++;\\n                \\n                \\n            }\\n            else\\n            {\\n                total1s++;\\n                 if(i==s.length()-1)\\n                    break;\\n                num1sBefore[i+1]++;\\n                \\n            }\\n             num0sBefore[i+1]+=num0sBefore[i];\\n             num1sBefore[i+1]+=num1sBefore[i];\\n        }\\n      //  System.out.println(Arrays.toString(num0sBefore)+\" \"+Arrays.toString(num1sBefore));\\n      \\n        long ans=0;\\n        \\n        for(int i=1;i<s.length();i++)\\n        {\\n         if(s.charAt(i)==\\'0\\')\\n         {\\n             ans+=num1sBefore[i]*(total1s-num1sBefore[i]);\\n         }\\n            else\\n                ans+=num0sBefore[i]*(total0s-num0sBefore[i]);\\n        \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int num0sBefore[]=new int[s.length()];\\n        int num1sBefore[]=new int[s.length()];\\n       long total1s=0;\\n       long total0s=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\'){\\n                total0s++;\\n                if(i==s.length()-1)\\n                    break;\\n                num0sBefore[i+1]++;\\n                \\n                \\n            }\\n            else\\n            {\\n                total1s++;\\n                 if(i==s.length()-1)\\n                    break;\\n                num1sBefore[i+1]++;\\n                \\n            }\\n             num0sBefore[i+1]+=num0sBefore[i];\\n             num1sBefore[i+1]+=num1sBefore[i];\\n        }\\n      //  System.out.println(Arrays.toString(num0sBefore)+\" \"+Arrays.toString(num1sBefore));\\n      \\n        long ans=0;\\n        \\n        for(int i=1;i<s.length();i++)\\n        {\\n         if(s.charAt(i)==\\'0\\')\\n         {\\n             ans+=num1sBefore[i]*(total1s-num1sBefore[i]);\\n         }\\n            else\\n                ans+=num0sBefore[i]*(total0s-num0sBefore[i]);\\n        \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908162,
                "title": "python-2-approaches-prefix-postfix-counts-and-just-counter",
                "content": "O(N) both space and time - prefix and postfix counts\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        N = len(s)        \\n        prefix_count = [[0,0] for _ in range(N)]\\n        postfix_count = [[0,0] for _ in range(N)]\\n                \\n        for i in range(N):\\n            if i > 0:\\n                prefix_count[i][0] = prefix_count[i - 1][0]\\n                prefix_count[i][1] = prefix_count[i - 1][1]\\n            prefix_count[i][int(s[i])] += 1\\n            j = N - i - 1    \\n            if j + 1 < N:\\n                postfix_count[j][0] = postfix_count[j + 1][0]\\n                postfix_count[j][1] = postfix_count[j + 1][1]\\n            postfix_count[j][int(s[j])] += 1\\n        \\n        for i in range(1, N - 1):        \\n            if s[i] == \\'0\\': ways += prefix_count[i - 1][1] * postfix_count[i + 1][1]\\n            else: ways += prefix_count[i - 1][0] * postfix_count[i + 1][0]\\n                \\n        return ways\\n```\\nO(N) time - Counting occurence of \\'01\\' and \\'10\\'\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        count = Counter()\\n        N = len(s) \\n\\n        reverse_digit = {\\'0\\' : \\'1\\', \\'1\\': \\'0\\'}\\n\\n        for c in s:\\n            ways += count[c+reverse_digit[c]]\\n            count[reverse_digit[c] + c] += count[reverse_digit[c]]\\n            count[c] += 1\\n                \\n        return ways\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        N = len(s)        \\n        prefix_count = [[0,0] for _ in range(N)]\\n        postfix_count = [[0,0] for _ in range(N)]\\n                \\n        for i in range(N):\\n            if i > 0:\\n                prefix_count[i][0] = prefix_count[i - 1][0]\\n                prefix_count[i][1] = prefix_count[i - 1][1]\\n            prefix_count[i][int(s[i])] += 1\\n            j = N - i - 1    \\n            if j + 1 < N:\\n                postfix_count[j][0] = postfix_count[j + 1][0]\\n                postfix_count[j][1] = postfix_count[j + 1][1]\\n            postfix_count[j][int(s[j])] += 1\\n        \\n        for i in range(1, N - 1):        \\n            if s[i] == \\'0\\': ways += prefix_count[i - 1][1] * postfix_count[i + 1][1]\\n            else: ways += prefix_count[i - 1][0] * postfix_count[i + 1][0]\\n                \\n        return ways\\n```\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        count = Counter()\\n        N = len(s) \\n\\n        reverse_digit = {\\'0\\' : \\'1\\', \\'1\\': \\'0\\'}\\n\\n        for c in s:\\n            ways += count[c+reverse_digit[c]]\\n            count[reverse_digit[c] + c] += count[reverse_digit[c]]\\n            count[c] += 1\\n                \\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908000,
                "title": "concise-c-solution-with-comments-no-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        // only two options 010 or 101\\n        long long res = 0;\\n        int rem_1 = count(s.begin(), s.end(), \\'1\\');\\n        int rem_0 = count(s.begin(), s.end(), \\'0\\');\\n        int vis_0 = 0, vis_1 = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\') // make 101\\n            {\\n                res += (vis_1 * rem_1); // since current character is 0 multiply total visited 1 by remaining 1 to get total \"101\" pairs \\n                rem_0 -= 1; // visited 0 so remaining 0 decreases by 1\\n                vis_0 += 1; // visted 0 so visited 0 increases by 1\\n            }\\n            else // make 010\\n            {\\n                res += (vis_0 * rem_0); // since current character is 1 multiply total visited 0 by remaining 0 to get total \"010\" pairs\\n                rem_1 -= 1;\\n                vis_1 += 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        // only two options 010 or 101\\n        long long res = 0;\\n        int rem_1 = count(s.begin(), s.end(), \\'1\\');\\n        int rem_0 = count(s.begin(), s.end(), \\'0\\');\\n        int vis_0 = 0, vis_1 = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\') // make 101\\n            {\\n                res += (vis_1 * rem_1); // since current character is 0 multiply total visited 1 by remaining 1 to get total \"101\" pairs \\n                rem_0 -= 1; // visited 0 so remaining 0 decreases by 1\\n                vis_0 += 1; // visted 0 so visited 0 increases by 1\\n            }\\n            else // make 010\\n            {\\n                res += (vis_0 * rem_0); // since current character is 1 multiply total visited 0 by remaining 0 to get total \"010\" pairs\\n                rem_1 -= 1;\\n                vis_1 += 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907794,
                "title": "simple-c-dp-solution",
                "content": "If you ignore the jargon in the question, it simply asks you how many subsequences of length 3 you can create from the given string that have alternating pattern { for less typing lets call them alternating subsequences :-) } i.e.  \"101\" and \"010\".\\n\\n**Intuition:**\\nLets say `s[i] = \\'1\\'`, and we need to find the no of occurences of subsequence \"101\" **that end at index `i`**. Then,\\t\\n\\t\\n\\tcount of \"101\" that end at index i = count of \"10\"s that appear before index i\\nwhy? because all those `\"10\"`s that formed before this index can now be put before this `1` at index `i` to form the subsequence `\"101\"`.\\nSimilar logic can be applied to all the other alternating subsequences.\\n\\nConsidering the intuition above, the DP relation for this problem is pretty straightforward. \\nFor the ith index, let\\'s say ```s[i] = c (0 or 1)```, then the no of alternating subsequences of length ```len``` ending in ```c``` **upto the ```i```th index** is given by\\n\\t\\n\\tdp[i][len][c] = dp[i-1][len][c] + dp[i-1][len-1][c^1]  {where ^ is the bitwise XOR operator}\\n**base case:** len = 1, then simply increment i.e. `dp[i][1][c]++` \\nOn further observation, we can drop the first paramter of the dp array giving us\\n\\n\\tdp[len][c] = dp[len][c] + dp[len-1][c^1]\\n\\nThe catch here is the order in which we update the counts. We need to update the count of the subsequences according to their length in descending order meaning count of subsequences of length 3 being updated first, then of length 2 and so on.\\n\\n**Solution:**\\nTime Complexity : `O(N)`\\nSpace Complexity : `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(3, vector<long long> (2, 0));\\n        \\n        for(int i=0;i<n;i++) {\\n            int c = s[i] - \\'0\\';\\n            for(int len=2;len>0;len--) {\\n                dp[len][c] = dp[len][c] + dp[len-1][c^1];\\n            }\\n            dp[0][c]++;\\n        }\\n        \\n        return dp[2][0] + dp[2][1];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```s[i] = c (0 or 1)```\n```len```\n```c```\n```i```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(3, vector<long long> (2, 0));\\n        \\n        for(int i=0;i<n;i++) {\\n            int c = s[i] - \\'0\\';\\n            for(int len=2;len>0;len--) {\\n                dp[len][c] = dp[len][c] + dp[len-1][c^1];\\n            }\\n            dp[0][c]++;\\n        }\\n        \\n        return dp[2][0] + dp[2][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907746,
                "title": "memo-one",
                "content": "```\\nclass Solution {\\npublic:\\n    long long  dp[3][100001][4];\\n    long long solve(string &s, int last_one, int index, int cnt)\\n    {\\n        if(cnt == 3)\\n        {\\n            return 1;\\n        }\\n        if(index == s.length()) return 0;\\n        if(cnt>3) return 0;\\n        if(dp[last_one][index][cnt]!=-1) return dp[last_one][index][cnt];        \\n        long long a = 0, b = 0;\\n        if(s[index]-\\'0\\'!=last_one)\\n        {\\n           a = solve(s, s[index]-\\'0\\', index+1, cnt+1);\\n        }\\n        b=solve(s, last_one, index+1, cnt);\\n        return dp[last_one][index][cnt] = a + b;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp, -1, sizeof(dp));\\n         return solve(s, 2, 0, 0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    long long  dp[3][100001][4];\\n    long long solve(string &s, int last_one, int index, int cnt)\\n    {\\n        if(cnt == 3)\\n        {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907720,
                "title": "java-o-n-solution-using-dynamic-programming",
                "content": "\\n\\n        int zr=0,on=0;\\n        int z[]=new int [s.length()];\\n        int o[]=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zr++;\\n            }\\n            else\\n            {\\n                on++;\\n            }\\n            z[i]=zr;o[i]=on;\\n        }\\n        long ans=0;\\n        for(int i=1;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                long tmp=o[i-1]*(on-o[i-1]);\\n                ans+=tmp;\\n            }\\n            else\\n            {\\n               long tmp=z[i-1]*(zr-z[i-1]);\\n               ans+=tmp;\\n            }\\n        }\\n        return ans;\\n \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "\\n\\n        int zr=0,on=0;\\n        int z[]=new int [s.length()];\\n        int o[]=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zr++;\\n            }\\n            else\\n            {\\n                on++;\\n            }\\n            z[i]=zr;o[i]=on;\\n        }\\n        long ans=0;\\n        for(int i=1;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                long tmp=o[i-1]*(on-o[i-1]);\\n                ans+=tmp;\\n            }\\n            else\\n            {\\n               long tmp=z[i-1]*(zr-z[i-1]);\\n               ans+=tmp;\\n            }\\n        }\\n        return ans;\\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1907698,
                "title": "c-easiest-explaination-without-dp-solution",
                "content": "So, lets try to understand what we actually need in this question.\\n**As the question states, we need to select 3 buildings in such a way that there are no consecutive 1\\'s or 0\\'s. Only two such combinations are possible, i.e. 0 1 0 and 1 0 1.**\\nNow, we need to find how many such combinations are there. **If at any point of time, we know for any 1 in string, how many 0\\'s are on left and right of this 1, then the number of combinations of 010 with this 1 will be leftzero*rightzero where leftzero = no of zeroes on left and rightzero = no of zeroes on right.**\\nNow, following same logic,\\n **If at any point of time, we know for any 0 in string, how many 1\\'s are on left and right of this 0, then the number of combinations of 101 with this 0 will be leftone*rightone where leftone = no of ones on left and rightone = no of ones on right.**\\n This is the crux of this solution below.\\n \\n```\\nclass Solution {\\npublic:\\n    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        /*\\n            left -> for every index i, \\n            1. if i stores \\'0\\', then left[i] gives no of ones on left\\n            2. if i stores \\'1\\', then left[i] gives no of zeroes on left\\n            \\n            right -> for every index i, \\n            1. if i stores \\'0\\', then right[i] gives no of ones on right\\n            2. if i stores \\'1\\', then right[i] gives no of zeroes on right\\n        */\\n        vector<long long>left(n,0),right(n,0);\\n        /*\\n            leftZero -> no of zeroes on left\\n            leftOne -> -> no of ones on left\\n            rightZero -> no of zeroes on right\\n            rightOne -> -> no of ones on right\\n        */\\n        long long leftZero=0,leftOne=0,rightZero=0,rightOne=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'0\\') {\\n                leftZero++;\\n                left[i]=leftOne;\\n            }\\n            else {\\n                leftOne++;\\n                left[i]=leftZero;\\n            }\\n            \\n            if(s[n-i-1]==\\'0\\') {\\n                rightZero++;\\n                right[n-i-1]=rightOne;\\n            }\\n            else {\\n                rightOne++;\\n                right[n-i-1]=rightZero;\\n            }\\n        }\\n        \\n        long long count=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            count+=left[i]*right[i];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        /*\\n            left -> for every index i, \\n            1. if i stores \\'0\\', then left[i] gives no of ones on left\\n            2. if i stores \\'1\\', then left[i] gives no of zeroes on left\\n            \\n            right -> for every index i, \\n            1. if i stores \\'0\\', then right[i] gives no of ones on right\\n            2. if i stores \\'1\\', then right[i] gives no of zeroes on right\\n        */\\n        vector<long long>left(n,0),right(n,0);\\n        /*\\n            leftZero -> no of zeroes on left\\n            leftOne -> -> no of ones on left\\n            rightZero -> no of zeroes on right\\n            rightOne -> -> no of ones on right\\n        */\\n        long long leftZero=0,leftOne=0,rightZero=0,rightOne=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'0\\') {\\n                leftZero++;\\n                left[i]=leftOne;\\n            }\\n            else {\\n                leftOne++;\\n                left[i]=leftZero;\\n            }\\n            \\n            if(s[n-i-1]==\\'0\\') {\\n                rightZero++;\\n                right[n-i-1]=rightOne;\\n            }\\n            else {\\n                rightOne++;\\n                right[n-i-1]=rightZero;\\n            }\\n        }\\n        \\n        long long count=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            count+=left[i]*right[i];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907679,
                "title": "prefix-and-suffix-sum-javascript-solution",
                "content": "We can do it using extra memory (prefixOnes and prefixZeros arrays):\\n```\\nvar numberOfWays = function(s) {\\n    let ones = 0;\\n    let zeros = 0;\\n    const prefixOnes = new Array(s.length);\\n    const prefixZeros = new Array(s.length);\\n    let result = 0;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"0\") ++zeros;\\n        else ++ones;\\n        \\n        prefixZeros[i] = zeros;\\n        prefixOnes[i] = ones;\\n    }\\n    \\n    zeros = 0;\\n    ones = 0;\\n    for (let i = s.length - 1; i > 0; --i) {\\n        if (s[i] === \"0\") {\\n            result += prefixOnes[i - 1] * ones;\\n            ++zeros;\\n        }\\n        else {\\n            result += prefixZeros[i - 1] * zeros;\\n            ++ones;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\nOr using constant memory (twice faster):\\n```\\nvar numberOfWays = function(s) {\\n    let ones = 0;\\n    let zeros = 0;\\n    let prefixOnes = 0;\\n    let prefixZeros = 0;\\n    let result = 0;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"0\") ++prefixZeros;\\n        else ++prefixOnes;\\n    }\\n    \\n    for (let i = s.length - 1; i > 0; --i) {\\n        if (s[i] === \"0\") {\\n            result += prefixOnes * ones;\\n            --prefixZeros;\\n            ++zeros;\\n        }\\n        else {\\n            result += prefixZeros * zeros;\\n            --prefixOnes;\\n            ++ones;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numberOfWays = function(s) {\\n    let ones = 0;\\n    let zeros = 0;\\n    const prefixOnes = new Array(s.length);\\n    const prefixZeros = new Array(s.length);\\n    let result = 0;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"0\") ++zeros;\\n        else ++ones;\\n        \\n        prefixZeros[i] = zeros;\\n        prefixOnes[i] = ones;\\n    }\\n    \\n    zeros = 0;\\n    ones = 0;\\n    for (let i = s.length - 1; i > 0; --i) {\\n        if (s[i] === \"0\") {\\n            result += prefixOnes[i - 1] * ones;\\n            ++zeros;\\n        }\\n        else {\\n            result += prefixZeros[i - 1] * zeros;\\n            ++ones;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\n```\\nvar numberOfWays = function(s) {\\n    let ones = 0;\\n    let zeros = 0;\\n    let prefixOnes = 0;\\n    let prefixZeros = 0;\\n    let result = 0;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"0\") ++prefixZeros;\\n        else ++prefixOnes;\\n    }\\n    \\n    for (let i = s.length - 1; i > 0; --i) {\\n        if (s[i] === \"0\") {\\n            result += prefixOnes * ones;\\n            --prefixZeros;\\n            ++zeros;\\n        }\\n        else {\\n            result += prefixZeros * zeros;\\n            --prefixOnes;\\n            ++ones;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907610,
                "title": "c-dp-state-machine",
                "content": "![image](https://assets.leetcode.com/users/images/9b68d040-d552-4a81-b5ed-e66abe8709b1_1648921834.2967253.png)\\n\\n\\n\\n```\\nconst int N = 100010;\\n\\ntypedef long long LL;\\n\\nclass Solution {\\n    LL f[N][4][2] = {};\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        \\n        f[0][0][0] = 1, f[0][0][1] = 1;\\n        for (int i = 1; i <= n; ++ i)\\n        {\\n            for (int j = 0; j <= 3; ++ j) // One caveat is that j need to start from 0 to piggy back the initial state\\n                                          // since there is assumption that f[i][0][k] = 1, namely, if no bld is selected, we think is one valid way.\\n            {\\n                if (s[i - 1] == \\'0\\')\\n                    f[i][j][0] += j ? f[i-1][j-1][1] : 0;\\n                else\\n                    f[i][j][1] += j ? f[i-1][j-1][0] : 0;\\n                f[i][j][0] += f[i-1][j][0];\\n                f[i][j][1] += f[i-1][j][1];\\n            }\\n        }\\n    \\n        return f[n][3][0] + f[n][3][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N = 100010;\\n\\ntypedef long long LL;\\n\\nclass Solution {\\n    LL f[N][4][2] = {};\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        \\n        f[0][0][0] = 1, f[0][0][1] = 1;\\n        for (int i = 1; i <= n; ++ i)\\n        {\\n            for (int j = 0; j <= 3; ++ j) // One caveat is that j need to start from 0 to piggy back the initial state\\n                                          // since there is assumption that f[i][0][k] = 1, namely, if no bld is selected, we think is one valid way.\\n            {\\n                if (s[i - 1] == \\'0\\')\\n                    f[i][j][0] += j ? f[i-1][j-1][1] : 0;\\n                else\\n                    f[i][j][1] += j ? f[i-1][j-1][0] : 0;\\n                f[i][j][0] += f[i-1][j][0];\\n                f[i][j][1] += f[i-1][j][1];\\n            }\\n        }\\n    \\n        return f[n][3][0] + f[n][3][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907509,
                "title": "c-without-dp-easy-understanding-simple-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<int> cnt(s.size(), 0);\\n        int  c0 = 0, c1 = 0;\\n\\t\\t\\n\\t\\t//count how many opposite element are there in left\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'0\\'){\\n                c0++;\\n                cnt[i] = c1;\\n            }\\n            else{\\n                c1++;\\n                cnt[i] = c0;\\n            }\\n        }\\n        c1 = c0 = 0;\\n        long long tot = 0;\\n\\t\\t//to get answer multiply previous prefix with number of opposite element on right of particular number\\n        for(int i = s.size() - 1; i >= 0; i--){\\n            if(s[i] == \\'0\\'){\\n                c0++;\\n                tot += cnt[i] * c1;\\n            }\\n            else{\\n                c1++;\\n                tot += cnt[i] * c0;\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<int> cnt(s.size(), 0);\\n        int  c0 = 0, c1 = 0;\\n\\t\\t\\n\\t\\t//count how many opposite element are there in left\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'0\\'){\\n                c0++;\\n                cnt[i] = c1;\\n            }\\n            else{\\n                c1++;\\n                cnt[i] = c0;\\n            }\\n        }\\n        c1 = c0 = 0;\\n        long long tot = 0;\\n\\t\\t//to get answer multiply previous prefix with number of opposite element on right of particular number\\n        for(int i = s.size() - 1; i >= 0; i--){\\n            if(s[i] == \\'0\\'){\\n                c0++;\\n                tot += cnt[i] * c1;\\n            }\\n            else{\\n                c1++;\\n                tot += cnt[i] * c0;\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907454,
                "title": "easy-to-understand-o-n-prefix-suffix",
                "content": "**Apoarch:-**\\n\\n1. count the no.of zero in prefix and suffix form\\n2. count the no.of one in prefix and suffix form\\n3. And stored them in an array as pre0, pre1, suf0 and suf1\\n4. Then traverse the string if \\n    i) char at index i is equals to zero\\n\\t      ->then add (no.of one before i) x (no.of one after i) to ans\\n    ii)char at index i is equals to one \\n\\t     ->then add (no.of zero before i) x (no.of zero after i) to ans\\n\\t\\t \\n\\t\\t \\n**Complexity:-**\\n\\n**Time** :- o(n)\\n**Space** :- o(n)\\n\\n\\nHave a look into the code for better understanding ;)\\n\\n**Code**:- \\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int> pre0(n,0);\\n        vector<int> pre1(n,0);\\n        vector<int> suf0(n,0);\\n        vector<int> suf1(n,0);\\n        \\n        pre0[0] = (s[0]==\\'0\\') ? 1:0;\\n        pre1[0] = (s[0]==\\'0\\') ? 0:1;\\n        for(int i=1;i<n;i++){\\n            int val0 = (s[i]==\\'0\\') ? 1:0;\\n            int val1 = (s[i]==\\'0\\') ? 0:1;\\n            pre0[i] = pre0[i-1]+val0;\\n            pre1[i] = pre1[i-1]+val1;\\n        }\\n        \\n        suf0[n-1] = (s[n-1]==\\'0\\') ? 1:0;\\n        suf1[n-1] = (s[n-1]==\\'0\\') ? 0:1;\\n        for(int i=n-2;i>=0;i--){\\n            int val0 = (s[i]==\\'0\\') ? 1:0;\\n            int val1 = (s[i]==\\'0\\') ? 0:1;\\n            suf0[i] = suf0[i+1]+val0;\\n            suf1[i] = suf1[i+1]+val1;\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int p0 = (i==0) ? 0:pre0[i-1];\\n            int p1 = (i==0) ? 0:pre1[i-1];\\n            int s0 = (i==n-1) ? 0:suf0[i+1];\\n            int s1 = (i==n-1) ? 0:suf1[i+1];\\n            if(s[i]==\\'1\\'){\\n                ans += (long long int)(p0)*(long long int)(s0);\\n            }\\n            else{\\n                ans += (long long int)(p1)*(long long int)(s1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int> pre0(n,0);\\n        vector<int> pre1(n,0);\\n        vector<int> suf0(n,0);\\n        vector<int> suf1(n,0);\\n        \\n        pre0[0] = (s[0]==\\'0\\') ? 1:0;\\n        pre1[0] = (s[0]==\\'0\\') ? 0:1;\\n        for(int i=1;i<n;i++){\\n            int val0 = (s[i]==\\'0\\') ? 1:0;\\n            int val1 = (s[i]==\\'0\\') ? 0:1;\\n            pre0[i] = pre0[i-1]+val0;\\n            pre1[i] = pre1[i-1]+val1;\\n        }\\n        \\n        suf0[n-1] = (s[n-1]==\\'0\\') ? 1:0;\\n        suf1[n-1] = (s[n-1]==\\'0\\') ? 0:1;\\n        for(int i=n-2;i>=0;i--){\\n            int val0 = (s[i]==\\'0\\') ? 1:0;\\n            int val1 = (s[i]==\\'0\\') ? 0:1;\\n            suf0[i] = suf0[i+1]+val0;\\n            suf1[i] = suf1[i+1]+val1;\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int p0 = (i==0) ? 0:pre0[i-1];\\n            int p1 = (i==0) ? 0:pre1[i-1];\\n            int s0 = (i==n-1) ? 0:suf0[i+1];\\n            int s1 = (i==n-1) ? 0:suf1[i+1];\\n            if(s[i]==\\'1\\'){\\n                ans += (long long int)(p0)*(long long int)(s0);\\n            }\\n            else{\\n                ans += (long long int)(p1)*(long long int)(s1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907406,
                "title": "python-dp-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        length = len(s)\\n        dp = []\\n        zeros = 0\\n        ones = 0\\n        for i in range(length):\\n            if(s[i]==\\'0\\'):\\n                zeros+=1\\n            elif(s[i]==\\'1\\'):\\n                ones+=1\\n            dp.append([zeros,ones]) //count zeros and ones\\n        count = 0\\n        for i in range(length):\\n            if(s[i]==\\'0\\'):\\n                count += dp[i][1]*(dp[-1][1]-dp[i][1]) // \\'101\\' dp[i][1] is ones before \\'0\\', (dp[-1][1]-dp[i][1]) is ones after \\'0\\'\\n            if(s[i]==\\'1\\'):\\n                count += dp[i][0]*(dp[-1][0]-dp[i][0]) // \\'010\\' dp[i][0] is zeros before \\'1\\' and (dp[-1][0]-dp[i][0]) is zeros after \\'1\\'\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        length = len(s)\\n        dp = []\\n        zeros = 0\\n        ones = 0\\n        for i in range(length):\\n            if(s[i]==\\'0\\'):\\n                zeros+=1\\n            elif(s[i]==\\'1\\'):\\n                ones+=1\\n            dp.append([zeros,ones]) //count zeros and ones\\n        count = 0\\n        for i in range(length):\\n            if(s[i]==\\'0\\'):\\n                count += dp[i][1]*(dp[-1][1]-dp[i][1]) // \\'101\\' dp[i][1] is ones before \\'0\\', (dp[-1][1]-dp[i][1]) is ones after \\'0\\'\\n            if(s[i]==\\'1\\'):\\n                count += dp[i][0]*(dp[-1][0]-dp[i][0]) // \\'010\\' dp[i][0] is zeros before \\'1\\' and (dp[-1][0]-dp[i][0]) is zeros after \\'1\\'\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907359,
                "title": "very-easy-understanding-c",
                "content": "```\\nlong long numberOfWays(string a) {\\n        int n=a.size();\\n        vector<int> left1(n),right1(n),left2(n),right2(n); \\n        int zero=0,one=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]==\\'1\\')\\n                one++;\\n            else\\n                zero++;\\n            right2[i]=one;\\n            right1[i]=zero;\\n        }  \\n        one=0;\\n        zero=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'1\\')\\n                one++;\\n            else\\n                zero++;\\n            left2[i]=one,left1[i]=zero;\\n        }\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\'){\\n                count+=left2[i]*right2[i];\\n            }\\n            else\\n                count+=left1[i]*right1[i];\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long numberOfWays(string a) {\\n        int n=a.size();\\n        vector<int> left1(n),right1(n),left2(n),right2(n); \\n        int zero=0,one=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]==\\'1\\')\\n                one++;\\n            else\\n                zero++;\\n            right2[i]=one;\\n            right1[i]=zero;\\n        }  \\n        one=0;\\n        zero=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'1\\')\\n                one++;\\n            else\\n                zero++;\\n            left2[i]=one,left1[i]=zero;\\n        }\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\'){\\n                count+=left2[i]*right2[i];\\n            }\\n            else\\n                count+=left1[i]*right1[i];\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1907347,
                "title": "c-time-space-optimized-o-n",
                "content": "The only valid combinations possible are **101** and **010**.\\nSo, traverse the string and consider the **current character as the centeral character** of the combination.\\nThis means, if the **current character is \\'0\\'**, then we need to do it find out the **number of \\'1\\' before this \\'0\\' and number of \\'1\\' after this \\'0\\' and multiple them and add to the answer**. Do same for the **central character as \\'1\\'** then we need to do find out the **number of \\'0\\' before this \\'1\\' and number of \\'0\\' after this \\'1\\' and multiple them to add to the answer**.\\n\\n**Solution 1 :**\\n**Time Complexity : O(n)**\\n**Space Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tlong long totalZeros = 0, totalOnes = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') totalZeros++;\\n\\t\\t\\telse totalOnes++;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long prevZeros = 0, prevOnes = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t// assuming s[i] is middle element\\n\\t\\t\\tif (s[i] == \\'0\\') {\\n\\t\\t\\t\\tans += ((prevOnes) * (totalOnes - prevOnes));\\n\\t\\t\\t\\tprevZeros++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans += ((prevZeros) * (totalZeros - prevZeros));\\n\\t\\t\\t\\tprevOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**Solution 2 :**\\n**Time Complexity : O(n)**\\n**Space Complexity : O(n)**\\n```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<long long>pre0(n, 0), pre1(n, 0);\\n\\t\\tif (s[0] == \\'0\\') pre0[0]++;\\n\\t\\telse pre1[0]++;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tpre0[i] = pre0[i - 1];\\n\\t\\t\\tpre1[i] = pre1[i - 1];\\n\\t\\t\\tif (s[i] == \\'0\\') pre0[i]++;\\n\\t\\t\\telse pre1[i]++;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') ans += ((pre1[i - 1]) * (pre1[n - 1] - pre1[i - 1]));\\n\\t\\t\\telse ans += ((pre0[i - 1]) * (pre0[n - 1] - pre0[i - 1]));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tlong long totalZeros = 0, totalOnes = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') totalZeros++;\\n\\t\\t\\telse totalOnes++;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long prevZeros = 0, prevOnes = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t// assuming s[i] is middle element\\n\\t\\t\\tif (s[i] == \\'0\\') {\\n\\t\\t\\t\\tans += ((prevOnes) * (totalOnes - prevOnes));\\n\\t\\t\\t\\tprevZeros++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans += ((prevZeros) * (totalZeros - prevZeros));\\n\\t\\t\\t\\tprevOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<long long>pre0(n, 0), pre1(n, 0);\\n\\t\\tif (s[0] == \\'0\\') pre0[0]++;\\n\\t\\telse pre1[0]++;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tpre0[i] = pre0[i - 1];\\n\\t\\t\\tpre1[i] = pre1[i - 1];\\n\\t\\t\\tif (s[i] == \\'0\\') pre0[i]++;\\n\\t\\t\\telse pre1[i]++;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') ans += ((pre1[i - 1]) * (pre1[n - 1] - pre1[i - 1]));\\n\\t\\t\\telse ans += ((pre0[i - 1]) * (pre0[n - 1] - pre0[i - 1]));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907309,
                "title": "convert-from-top-down-to-bottom-up-dp",
                "content": "For this question, I instantly identified that we should use DP approach.\\nIntuitively, I started with top-down approach, and in 5 minutes, I got this:\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        N = len(s)\\n        def topdown(i, n, v):\\n            if (i, n, v) in memo:\\n                return memo[(i, n, v)]\\n            if n >= 3:\\n                return 1\\n            if i+1 > N-1:\\n                return 0\\n            count = topdown(i+1, n, v)\\n            if s[i+1] != v:\\n                count += topdown(i+1, n+1, s[i+1])\\n            memo[(i, n, v)] = count\\n            return count\\n        memo = {}\\n        res = 0\\n        for i in range(N):\\n            res += topdown(i, 1, s[i])\\n        return res\\n```\\nIt got TLE, but technically time complexity is O(N), and it should have accepted this approach.\\n\\nThen I started to convert it to bottom-up, and I spent 30-45 minutes trying to convert it. But I just couldn\\'t wrap my head around converting it to bottom-up approach.\\n\\nCan someone please explain the way to intuitively understand step by step process of converting this solution from top-down to bottom-up?\\n\\nI got the same problem several times before...",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        N = len(s)\\n        def topdown(i, n, v):\\n            if (i, n, v) in memo:\\n                return memo[(i, n, v)]\\n            if n >= 3:\\n                return 1\\n            if i+1 > N-1:\\n                return 0\\n            count = topdown(i+1, n, v)\\n            if s[i+1] != v:\\n                count += topdown(i+1, n+1, s[i+1])\\n            memo[(i, n, v)] = count\\n            return count\\n        memo = {}\\n        res = 0\\n        for i in range(N):\\n            res += topdown(i, 1, s[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907294,
                "title": "pure-brute-force-easiest-solution-leetcode-had-mercy-on-me",
                "content": "```\\nclass Solution {\\n    long long count(string a, string b){\\n        int m = a.length(),n = 3;\\n        vector<vector<long long>> counter(m+1,vector<long long>(4,0));\\n        for (int i = 0; i <= m; ++i) counter[i][0] = 1;\\n        for (int i = 1; i <= m; i++){\\n            for (int j = 1; j <= 3; j++){\\n                if (a[i - 1] == b[j - 1])\\n                    counter[i][j] = counter[i - 1][j - 1] + counter[i - 1][j];\\n                else\\n                    counter[i][j] = counter[i - 1][j];\\n            }\\n        }\\n        return counter[m][3];\\n    }\\n    bool isSubSequence(string str2, string str1){\\n        int m = str2.size();\\n        int n=3;\\n        int j = 0;\\n        for (int i = 0; i < m && j < n; i++)\\n            if (str1[j] == str2[i])\\n                j++;\\n        return (j == n);\\n    }\\npublic:\\n    long long numberOfWays(string s) {\\n        string s1 = \"010\";\\n        string s2 = \"101\";\\n        long long ans=0;\\n        if(isSubSequence(s,s1))\\n            ans+= count(s,s1);\\n        if(isSubSequence(s,s2))\\n            ans+=count(s,s2);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/fae387b1-1b5d-4581-8635-eb68aee18e80_1648916465.4073477.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long count(string a, string b){\\n        int m = a.length(),n = 3;\\n        vector<vector<long long>> counter(m+1,vector<long long>(4,0));\\n        for (int i = 0; i <= m; ++i) counter[i][0] = 1;\\n        for (int i = 1; i <= m; i++){\\n            for (int j = 1; j <= 3; j++){\\n                if (a[i - 1] == b[j - 1])\\n                    counter[i][j] = counter[i - 1][j - 1] + counter[i - 1][j];\\n                else\\n                    counter[i][j] = counter[i - 1][j];\\n            }\\n        }\\n        return counter[m][3];\\n    }\\n    bool isSubSequence(string str2, string str1){\\n        int m = str2.size();\\n        int n=3;\\n        int j = 0;\\n        for (int i = 0; i < m && j < n; i++)\\n            if (str1[j] == str2[i])\\n                j++;\\n        return (j == n);\\n    }\\npublic:\\n    long long numberOfWays(string s) {\\n        string s1 = \"010\";\\n        string s2 = \"101\";\\n        long long ans=0;\\n        if(isSubSequence(s,s1))\\n            ans+= count(s,s1);\\n        if(isSubSequence(s,s2))\\n            ans+=count(s,s2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907292,
                "title": "c-single-loop-4-variables",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long nums0 = 0, nums1 = 0, nums01 = 0, nums10 = 0;\\n        long long res = 0;\\n        for(int i = 0; i<s.size(); i++){\\n            if(s[i] == \\'0\\'){\\n                res+=nums01;\\n                nums10+=nums1;\\n                nums0++;\\n            }\\n            else{\\n                res+=nums10;\\n                nums01+=nums0;\\n                nums1++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long nums0 = 0, nums1 = 0, nums01 = 0, nums10 = 0;\\n        long long res = 0;\\n        for(int i = 0; i<s.size(); i++){\\n            if(s[i] == \\'0\\'){\\n                res+=nums01;\\n                nums10+=nums1;\\n                nums0++;\\n            }\\n            else{\\n                res+=nums10;\\n                nums01+=nums0;\\n                nums1++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907239,
                "title": "java-easy-and-intuitive-solution-subsequences-logic",
                "content": "**Code**\\n```java\\npublic long count(String s, String t) {\\n\\tint m = s.length();\\n\\tint n = t.length();\\n\\n\\tlong dp[][] = new long[m + 1][n + 1];\\n\\n\\tfor (int i = 0; i <= n; ++i) dp[0][i] = 0;\\n\\tfor (int i = 0; i <= m; ++i) dp[i][0] = 1;\\n\\n\\tfor (int i = 1; i <= m; i++) {\\n\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1))\\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n];\\n}\\n\\npublic long numberOfWays(String s) {\\n\\treturn count(s, \"010\") + count(s, \"101\");\\n}\\n```\\n\\n**Explanation**\\nIn this problem if we closely notice, there can be only two possibilities of selecting houses, either `010` or `101`.\\nSo we need to find the number of times each of these strings occurs as subsequence in the given string.\\nThe addition of these two will give us the desired answer.\\n\\nHope it helps\\nThanks\\nDo upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic long count(String s, String t) {\\n\\tint m = s.length();\\n\\tint n = t.length();\\n\\n\\tlong dp[][] = new long[m + 1][n + 1];\\n\\n\\tfor (int i = 0; i <= n; ++i) dp[0][i] = 0;\\n\\tfor (int i = 0; i <= m; ++i) dp[i][0] = 1;\\n\\n\\tfor (int i = 1; i <= m; i++) {\\n\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1))\\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n];\\n}\\n\\npublic long numberOfWays(String s) {\\n\\treturn count(s, \"010\") + count(s, \"101\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907236,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, s: str) -> int:\\n\\t\\t\\tn = len(s)\\n\\t\\t\\tleftZero = 0\\n\\t\\t\\tLeftOne = 0\\n\\t\\t\\trightZero = 0\\n\\t\\t\\trightOne = 0\\n\\t\\t\\tleft = []\\n\\t\\t\\tright = []\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif s[i] == \"0\":\\n\\t\\t\\t\\t\\tleftZero += 1\\n\\t\\t\\t\\t\\tleft.append(LeftOne)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tLeftOne += 1\\n\\t\\t\\t\\t\\tleft.append(leftZero)\\n\\t\\t\\t\\tif s[n - 1 - i] == \"0\":\\n\\t\\t\\t\\t\\tright.append(rightOne)\\n\\t\\t\\t\\t\\trightZero += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tright.append(rightZero)\\n\\t\\t\\t\\t\\trightOne += 1\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tres += left[i] * right[n - 1 - i]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, s: str) -> int:\\n\\t\\t\\tn = len(s)\\n\\t\\t\\tleftZero = 0\\n\\t\\t\\tLeftOne = 0\\n\\t\\t\\trightZero = 0\\n\\t\\t\\trightOne = 0\\n\\t\\t\\tleft = []\\n\\t\\t\\tright = []\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif s[i] == \"0\":\\n\\t\\t\\t\\t\\tleftZero += 1\\n\\t\\t\\t\\t\\tleft.append(LeftOne)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tLeftOne += 1\\n\\t\\t\\t\\t\\tleft.append(leftZero)\\n\\t\\t\\t\\tif s[n - 1 - i] == \"0\":\\n\\t\\t\\t\\t\\tright.append(rightOne)\\n\\t\\t\\t\\t\\trightZero += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tright.append(rightZero)\\n\\t\\t\\t\\t\\trightOne += 1\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tres += left[i] * right[n - 1 - i]\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1907193,
                "title": "dp-java",
                "content": "```java\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans = count(s,\"101\",s.length(),3) + count(s,\"010\",s.length(),3);\\n        return ans;\\n    }\\n    private long count(String a, String b, int m, int n)\\n    {\\n\\n        long lookup[][] = new long[m + 1][n + 1];\\n\\n        for (int i = 0; i <= n; ++i)\\n            lookup[0][i] = 0;\\n\\n        for (int i = 0; i <= m; ++i)\\n            lookup[i][0] = 1;\\n\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++)\\n            {\\n                if (a.charAt(i - 1) == b.charAt(j - 1))\\n                    lookup[i][j] = lookup[i - 1][j - 1] +\\n                                   lookup[i - 1][j];\\n\\n                else\\n                    lookup[i][j] = lookup[i - 1][j];\\n            }\\n        }\\n\\n        return lookup[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans = count(s,\"101\",s.length(),3) + count(s,\"010\",s.length(),3);\\n        return ans;\\n    }\\n    private long count(String a, String b, int m, int n)\\n    {\\n\\n        long lookup[][] = new long[m + 1][n + 1];\\n\\n        for (int i = 0; i <= n; ++i)\\n            lookup[0][i] = 0;\\n\\n        for (int i = 0; i <= m; ++i)\\n            lookup[i][0] = 1;\\n\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++)\\n            {\\n                if (a.charAt(i - 1) == b.charAt(j - 1))\\n                    lookup[i][j] = lookup[i - 1][j - 1] +\\n                                   lookup[i - 1][j];\\n\\n                else\\n                    lookup[i][j] = lookup[i - 1][j];\\n            }\\n        }\\n\\n        return lookup[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907166,
                "title": "python-o-n-o-1-space-easy-just-look-at-middle-element",
                "content": "Suppose we are looking at \\'010\\' and the i-th index. If s[i] == \\'1\\', we count how many choices there are with the middle element being \\'1\\' in selecting our subsequence. This number should be preZ * sufZ (the number of zeros before i-th index times that number after). Vice versa for \\'0\\'. \\n\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        preZ = 0\\n        sufZ = 0\\n        preO = 0\\n        sufO = 0\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                sufZ += 1\\n            else:\\n                sufO += 1\\n        \\n        ans = 0\\n        for i in range(n):\\n            if s[i] == \\'1\\':\\n                ans += preZ * sufZ\\n                preO += 1\\n                sufO -= 1\\n            else:\\n                ans += preO * sufO\\n                preZ += 1\\n                sufZ -= 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        preZ = 0\\n        sufZ = 0\\n        preO = 0\\n        sufO = 0\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                sufZ += 1\\n            else:\\n                sufO += 1\\n        \\n        ans = 0\\n        for i in range(n):\\n            if s[i] == \\'1\\':\\n                ans += preZ * sufZ\\n                preO += 1\\n                sufO -= 1\\n            else:\\n                ans += preO * sufO\\n                preZ += 1\\n                sufZ -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907161,
                "title": "c-dp-string-subsequence",
                "content": "As we can take three buildings at a time with different consecutive buildings we are left with two types of building sequence one is \"101\" and the other is \"010\". So we will count occurences of subsequences of above strings in the given string.\\n\\n```  \\nlong long subSequence(string a,string b){\\n        int m=a.size();\\n        int n=b.size();\\n        long long dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=1;\\n        for(int j=1;j<=n;j++)\\n            dp[0][j]=0;\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(a[i-1]==b[j-1]){\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-1];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    long long numberOfWays(string s) {\\n        string s2=\"101\";\\n        string s1=\"010\";\\n        long long way1=subSequence(s,s1);\\n        long long way2=subSequence(s,s2);\\n        return way1+way2;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```  \\nlong long subSequence(string a,string b){\\n        int m=a.size();\\n        int n=b.size();\\n        long long dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=1;\\n        for(int j=1;j<=n;j++)\\n            dp[0][j]=0;\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(a[i-1]==b[j-1]){\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-1];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    long long numberOfWays(string s) {\\n        string s2=\"101\";\\n        string s1=\"010\";\\n        long long way1=subSequence(s,s1);\\n        long long way2=subSequence(s,s2);\\n        return way1+way2;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907146,
                "title": "easy-using-recursion-memomization-c",
                "content": "For any index i we can either choose a building if the chosen building is not same as previously chosen  building or we haven\\u2019t choosed any building yet, we repeat this process until the size is less then 3.\\nAnd as the number of total chossen building become 3 we increment the answer by 1, as this is the valid answer.\\n```\\nclass Solution {\\npublic:\\n    long long dp[100000][4][3];\\n\\n    long long  f(string &s ,int i,int prev,int n){\\n\\n        if(n==3){   // we got one string\\n            return 1;  \\n        }\\n\\n        if(i==s.size()){   //reaches end\\n            return 0;\\n        }\\n\\n        if(dp[i][n][prev]!=-1){   // if present return answer\\n            return dp[i][n][prev];\\n        } \\n\\n        if(n==0){   //is size is zero can pick this or can leave\\n\\n            if(s[i]==\\'1\\'){ \\n   \\n                return dp[i][n][prev]=f(s,i+1,1,n+1)+f(s,i+1,prev,n);    // first we are pikcing and second we are not picking \\n            \\n\\t\\t}else{\\n\\n                return dp[i][n][prev]=f(s,i+1,0,n+1)+f(s,i+1,prev,n);    // first we are pikcing and second we are not picking \\n            \\n\\t\\t}\\n        }\\n\\n\\n\\t// is size is greater then 1\\n\\t// check previous one\\n\\n\\n        if(prev==1){   // if prev building is 1\\n\\n            if(s[i]==\\'0\\'){   //if current building is 0 we can take it or skip it \\n                 return dp[i][n][prev]=f(s,i+1,0,n+1)+f(s,i+1,prev,n);\\n            }\\n\\t\\telse{    //if current building is 1 we have to skip it \\n                return dp[i][n][prev]=f(s,i+1,prev,n);\\n            }\\n        }\\n\\n        else if(prev==0){    // if prev building is 0\\n\\n            if(s[i]==\\'1\\'){   //if current building is 1 we can take it or skip it\\n                return dp[i][n][prev]=f(s,i+1,1,n+1)+f(s,i+1,prev,n);\\n            }\\n\\t\\telse{       //if current building is 0 we have to skip it \\n                return dp[i][n][prev]=f(s,i+1,prev,n);\\n            }\\n        }\\n        return 0;\\n    }\\n    long long numberOfWays(string s) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        return f(s,0,0,0);   // final answer\\n    }\\n};\\n```\\n\\n\\nUpvote",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100000][4][3];\\n\\n    long long  f(string &s ,int i,int prev,int n){\\n\\n        if(n==3){   // we got one string\\n            return 1;  \\n        }\\n\\n        if(i==s.size()){   //reaches end\\n            return 0;\\n        }\\n\\n        if(dp[i][n][prev]!=-1){   // if present return answer\\n            return dp[i][n][prev];\\n        } \\n\\n        if(n==0){   //is size is zero can pick this or can leave\\n\\n            if(s[i]==\\'1\\'){ \\n   \\n                return dp[i][n][prev]=f(s,i+1,1,n+1)+f(s,i+1,prev,n);    // first we are pikcing and second we are not picking \\n            \\n\\t\\t}else{\\n\\n                return dp[i][n][prev]=f(s,i+1,0,n+1)+f(s,i+1,prev,n);    // first we are pikcing and second we are not picking \\n            \\n\\t\\t}\\n        }\\n\\n\\n\\t// is size is greater then 1\\n\\t// check previous one\\n\\n\\n        if(prev==1){   // if prev building is 1\\n\\n            if(s[i]==\\'0\\'){   //if current building is 0 we can take it or skip it \\n                 return dp[i][n][prev]=f(s,i+1,0,n+1)+f(s,i+1,prev,n);\\n            }\\n\\t\\telse{    //if current building is 1 we have to skip it \\n                return dp[i][n][prev]=f(s,i+1,prev,n);\\n            }\\n        }\\n\\n        else if(prev==0){    // if prev building is 0\\n\\n            if(s[i]==\\'1\\'){   //if current building is 1 we can take it or skip it\\n                return dp[i][n][prev]=f(s,i+1,1,n+1)+f(s,i+1,prev,n);\\n            }\\n\\t\\telse{       //if current building is 0 we have to skip it \\n                return dp[i][n][prev]=f(s,i+1,prev,n);\\n            }\\n        }\\n        return 0;\\n    }\\n    long long numberOfWays(string s) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        return f(s,0,0,0);   // final answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907137,
                "title": "python3-prefix-and-suffix-characteristic",
                "content": "We are counting number of zeros before and after actual index.\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n=len(s)\\n        s=[int(ch) for ch in s]\\n        sumS=sum(s)\\n        answ=0\\n        preffix1=0\\n        suffix1=sumS\\n        for i in range(n):\\n            preffix1+=s[i]\\n            preffix0=1+i-preffix1\\n            suffix1-=s[i]\\n            suffix0=n-i-1-suffix1\\n            if s[i]: # looking for \"010\"\\n                answ+=preffix0*suffix0\\n            else: # looking for \"101\"\\n                answ+=preffix1*suffix1          \\n        return answ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n=len(s)\\n        s=[int(ch) for ch in s]\\n        sumS=sum(s)\\n        answ=0\\n        preffix1=0\\n        suffix1=sumS\\n        for i in range(n):\\n            preffix1+=s[i]\\n            preffix0=1+i-preffix1\\n            suffix1-=s[i]\\n            suffix0=n-i-1-suffix1\\n            if s[i]: # looking for \"010\"\\n                answ+=preffix0*suffix0\\n            else: # looking for \"101\"\\n                answ+=preffix1*suffix1          \\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907122,
                "title": "easy-solution-just-maintain-the-prefix-counts-and-suffix-counts",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans=0;\\n        int len=s.length();\\n        int beforeZeros=0,beforeOnes=0;\\n        int afterZeros[]=new int[len];\\n        int afterOnes[]=new int[len];\\n        for(int i=len-2;i>=0;i--){\\n            if(s.charAt(i+1)==\\'1\\'){\\n                afterOnes[i]=afterOnes[i+1]+1;\\n                afterZeros[i]=afterZeros[i+1];\\n            }else{\\n                afterZeros[i]=afterZeros[i+1]+1;\\n                afterOnes[i]=afterOnes[i+1];\\n            }\\n        }\\n        for(int i=1;i<len;i++){\\n            if(s.charAt(i-1)==\\'1\\'){\\n                beforeOnes++;\\n            }else{\\n                beforeZeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'){\\n                  long temp=beforeZeros*1L*afterZeros[i];\\n                ans+=temp;\\n            }else{\\n                long temp=beforeOnes*1L*afterOnes[i];\\n                ans+=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans=0;\\n        int len=s.length();\\n        int beforeZeros=0,beforeOnes=0;\\n        int afterZeros[]=new int[len];\\n        int afterOnes[]=new int[len];\\n        for(int i=len-2;i>=0;i--){\\n            if(s.charAt(i+1)==\\'1\\'){\\n                afterOnes[i]=afterOnes[i+1]+1;\\n                afterZeros[i]=afterZeros[i+1];\\n            }else{\\n                afterZeros[i]=afterZeros[i+1]+1;\\n                afterOnes[i]=afterOnes[i+1];\\n            }\\n        }\\n        for(int i=1;i<len;i++){\\n            if(s.charAt(i-1)==\\'1\\'){\\n                beforeOnes++;\\n            }else{\\n                beforeZeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'){\\n                  long temp=beforeZeros*1L*afterZeros[i];\\n                ans+=temp;\\n            }else{\\n                long temp=beforeOnes*1L*afterOnes[i];\\n                ans+=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907115,
                "title": "mle-python-lru-cache",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, prev, selected):\\n            if selected == 3:\\n                return 1\\n            if 3-selected > len(s)-i:\\n                return 0\\n        \\n            ways = 0\\n            if s[i] != prev: #take\\n                ways += dp(i+1, s[i], selected+1)\\n            ways += dp(i+1, prev, selected)\\n            return ways\\n        \\n        return dp(0, -1, 0)\\n```\\n\\nSpent so much time thinking about improving this solution but I think the approach was wrong from the root. I\\'m curious to know if anyone with the same solution in C++ maybe using memo has passed the test cases",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, prev, selected):\\n            if selected == 3:\\n                return 1\\n            if 3-selected > len(s)-i:\\n                return 0\\n        \\n            ways = 0\\n            if s[i] != prev: #take\\n                ways += dp(i+1, s[i], selected+1)\\n            ways += dp(i+1, prev, selected)\\n            return ways\\n        \\n        return dp(0, -1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907113,
                "title": "time-o-n-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        //Store number of zeroes and ones on the left side of current element\\n        vector<pair<int,int>> left(s.length());\\n         //Store number of zeroes and ones on the right side of current element\\n        vector<pair<int,int>> right(s.length());\\n        int count0=0;\\n        int count1=0;\\n        long long result=0;\\n        for(int i=0;i<s.length();i++)\\n        {  left[i]={count0,count1};\\n            s[i]==\\'0\\'?count0++:count1++;\\n        }\\n        count0=0;\\n        count1=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {   right[i]={count0,count1};            \\n            s[i]==\\'0\\'?count0++:count1++;\\n        }\\n        for(int i=1;i<s.length()-1;i++)\\n        {   //Take number of ones on left * number of ones on right\\n            if(s[i]==\\'0\\')\\n            {\\n                result+=(left[i].second)*(right[i].second);\\n            }\\n            else\\n            {   //Take number of zeroes on left * number of zeroes on right\\n                result+=(left[i].first)*(right[i].first);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n**Like it ? Please Vote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        //Store number of zeroes and ones on the left side of current element\\n        vector<pair<int,int>> left(s.length());\\n         //Store number of zeroes and ones on the right side of current element\\n        vector<pair<int,int>> right(s.length());\\n        int count0=0;\\n        int count1=0;\\n        long long result=0;\\n        for(int i=0;i<s.length();i++)\\n        {  left[i]={count0,count1};\\n            s[i]==\\'0\\'?count0++:count1++;\\n        }\\n        count0=0;\\n        count1=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {   right[i]={count0,count1};            \\n            s[i]==\\'0\\'?count0++:count1++;\\n        }\\n        for(int i=1;i<s.length()-1;i++)\\n        {   //Take number of ones on left * number of ones on right\\n            if(s[i]==\\'0\\')\\n            {\\n                result+=(left[i].second)*(right[i].second);\\n            }\\n            else\\n            {   //Take number of zeroes on left * number of zeroes on right\\n                result+=(left[i].first)*(right[i].first);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907022,
                "title": "simple-solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long c = 0;\\n        long z = 0L;\\n        long o = 0L;\\n        long zo = 0L;\\n        long oz = 0l;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                c+=zo;\\n                z++;\\n                oz+=o;\\n            } else {\\n                c+=oz;\\n                o++;\\n                zo+=z;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long c = 0;\\n        long z = 0L;\\n        long o = 0L;\\n        long zo = 0L;\\n        long oz = 0l;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                c+=zo;\\n                z++;\\n                oz+=o;\\n            } else {\\n                c+=oz;\\n                o++;\\n                zo+=z;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907006,
                "title": "c-dynamic-programming-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[5][100001];\\n    long long recur(string &s,string temp,int idx){\\n        if(temp.length() == 3)\\n            return 1;\\n        if(idx == s.length())\\n            return 0;\\n        int dig;\\n        if(temp.length() == 0)\\n            dig = 0;\\n        else\\n            dig = stoi(temp,0,2) + temp.length();\\n        if(dp[dig][idx] != -1)\\n            return dp[dig][idx];\\n        if(temp.length() != 0 && s[idx] == temp[temp.length() - 1])\\n            return dp[dig][idx] = recur(s,temp,idx + 1);\\n        return dp[dig][idx] = recur(s,temp,idx + 1) + recur(s,temp + s[idx],idx + 1);\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        string temp = \"\";\\n        return recur(s,temp,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[5][100001];\\n    long long recur(string &s,string temp,int idx){\\n        if(temp.length() == 3)\\n            return 1;\\n        if(idx == s.length())\\n            return 0;\\n        int dig;\\n        if(temp.length() == 0)\\n            dig = 0;\\n        else\\n            dig = stoi(temp,0,2) + temp.length();\\n        if(dp[dig][idx] != -1)\\n            return dp[dig][idx];\\n        if(temp.length() != 0 && s[idx] == temp[temp.length() - 1])\\n            return dp[dig][idx] = recur(s,temp,idx + 1);\\n        return dp[dig][idx] = recur(s,temp,idx + 1) + recur(s,temp + s[idx],idx + 1);\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        string temp = \"\";\\n        return recur(s,temp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907000,
                "title": "count-101-and-010-using-prefix-array",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        z = 0\\n        o = 0\\n        zeroes = [z]\\n        ones = [o]\\n        for c in s:\\n            if c == \\'0\\':\\n                z += 1\\n            if c == \\'1\\':\\n                o += 1\\n            zeroes.append(z)\\n            ones.append(o)\\n        ways = 0\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                ways += (ones[i] - ones[0]) * (ones[-1] - ones[i + 1])\\n            elif s[i] == \\'1\\':\\n                ways += (zeroes[i] - zeroes[0]) * (zeroes[-1] - zeroes[i + 1])\\n        return ways\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        z = 0\\n        o = 0\\n        zeroes = [z]\\n        ones = [o]\\n        for c in s:\\n            if c == \\'0\\':\\n                z += 1\\n            if c == \\'1\\':\\n                o += 1\\n            zeroes.append(z)\\n            ones.append(o)\\n        ways = 0\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                ways += (ones[i] - ones[0]) * (ones[-1] - ones[i + 1])\\n            elif s[i] == \\'1\\':\\n                ways += (zeroes[i] - zeroes[0]) * (zeroes[-1] - zeroes[i + 1])\\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906986,
                "title": "java-dp-waterfall-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long z = 0, o = 0, zo = 0, oz = 0, zoz = 0, ozo = 0;\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'0\\') {\\n                zoz += zo;\\n                oz += o;\\n                z++;\\n            }\\n            else {\\n                ozo += oz;\\n                zo += z;\\n                o++;\\n            }\\n        }\\n        return zoz + ozo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long z = 0, o = 0, zo = 0, oz = 0, zoz = 0, ozo = 0;\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'0\\') {\\n                zoz += zo;\\n                oz += o;\\n                z++;\\n            }\\n            else {\\n                ozo += oz;\\n                zo += z;\\n                o++;\\n            }\\n        }\\n        return zoz + ozo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906959,
                "title": "java-easy-understanding-with-diagram",
                "content": "We can only choose `010` and `101` with no two consecutive\\n\\nWe can count total number of digits, then we count current number of digits\\n\\nTo count pattern of `010`, we count number of zero from left and right\\n\\n```\\nleft number of zero\\nXXXXXXXXXXXXXXXXXXX1XXXXXXXXXXXXXXXXXXXX\\n                    right number of zero \\n\\nright number of zero = total zero - current number of zero\\n```\\n\\nSo for pattern `101`  the process is same\\n\\nTime: O(N)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n  public long numberOfWays(String s) {\\n    long result = 0;\\n    char[] word = s.toCharArray();\\n    // count total number of zero and one\\n    int[] count = new int[2];\\n    for (char c : word) {\\n      count[c - \\'0\\']++;\\n    }\\n\\n    int[] current = new int[2];\\n    for (char c : word) {\\n      int digit = c - \\'0\\';\\n      int revert = 1 - digit;\\n      result += (long) current[revert] * (count[revert] - current[revert]);\\n      current[digit]++;\\n    }\\n\\n    return result;\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nleft number of zero\\nXXXXXXXXXXXXXXXXXXX1XXXXXXXXXXXXXXXXXXXX\\n                    right number of zero \\n\\nright number of zero = total zero - current number of zero\\n```\n```\\nclass Solution {\\n  public long numberOfWays(String s) {\\n    long result = 0;\\n    char[] word = s.toCharArray();\\n    // count total number of zero and one\\n    int[] count = new int[2];\\n    for (char c : word) {\\n      count[c - \\'0\\']++;\\n    }\\n\\n    int[] current = new int[2];\\n    for (char c : word) {\\n      int digit = c - \\'0\\';\\n      int revert = 1 - digit;\\n      result += (long) current[revert] * (count[revert] - current[revert]);\\n      current[digit]++;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095002,
                "title": "c-o-n-o-n",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n\\n        vector<int> counts;  // how many of the other type seen at this point\\n        int total_0s = 0;\\n        int total_1s = 0;\\n\\n        for (char c: s) {\\n            if(c == \\'0\\') {\\n                total_0s++;\\n                counts.push_back(total_1s);\\n            } else if(c == \\'1\\') {\\n                total_1s++;\\n                counts.push_back(total_0s);\\n            } else {\\n                printf(\"!error\");\\n                exit(1);\\n            }\\n        } \\n\\n        long long res = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s[i];\\n            if (c == \\'0\\') {\\n                // 101\\n                // counts[i] is the number of 1s before the 0\\n                // total_1s - counts[i] is the number of 1s after the 0\\n                res += counts[i] * (total_1s - counts[i]);\\n            } else if (c == \\'1\\') {\\n                // 010 same logic as above\\n                res += counts[i] * (total_0s - counts[i]);\\n            } else {\\n                printf(\"!error\");\\n                exit(1);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n\\n        vector<int> counts;  // how many of the other type seen at this point\\n        int total_0s = 0;\\n        int total_1s = 0;\\n\\n        for (char c: s) {\\n            if(c == \\'0\\') {\\n                total_0s++;\\n                counts.push_back(total_1s);\\n            } else if(c == \\'1\\') {\\n                total_1s++;\\n                counts.push_back(total_0s);\\n            } else {\\n                printf(\"!error\");\\n                exit(1);\\n            }\\n        } \\n\\n        long long res = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s[i];\\n            if (c == \\'0\\') {\\n                // 101\\n                // counts[i] is the number of 1s before the 0\\n                // total_1s - counts[i] is the number of 1s after the 0\\n                res += counts[i] * (total_1s - counts[i]);\\n            } else if (c == \\'1\\') {\\n                // 010 same logic as above\\n                res += counts[i] * (total_0s - counts[i]);\\n            } else {\\n                printf(\"!error\");\\n                exit(1);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079798,
                "title": "python-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this case, the dp should not be initialized as a list, but it should be initalized as a hashmap.\\nIf a character in s is \\'1\\', then the way to select one \\'1\\' is incremented by 1, the way to select \\'101\\' is incremented by the way to select \\'10\\', and the way to select \\'01\\' is incremented by the way to select \\'0\\'.\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = {\\'1\\':0, \\'0\\':0, \\'10\\':0, \\'01\\':0, \\'101\\':0, \\'010\\':0}\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                dp[\\'0\\'] += 1\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'1\\'] += 1\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        \\n        return dp[\\'101\\'] + dp[\\'010\\']\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = {\\'1\\':0, \\'0\\':0, \\'10\\':0, \\'01\\':0, \\'101\\':0, \\'010\\':0}\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                dp[\\'0\\'] += 1\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'1\\'] += 1\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        \\n        return dp[\\'101\\'] + dp[\\'010\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069610,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDP - DAG or something similar. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt a position i, a valid sequence of length 3 = sum of valid sequence of length 2.\\n\\nA valid sequence of length 2 at position i can be defined by the frequency of the oposite number of i (For example, at i, s[i] = 0 -> valid sequence of length 2 at position i equals the frequency of 0 in front of i).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans = 0;\\n\\n        int cnt0 = 0;\\n        int cnt1 = 0;\\n\\n        long long dp1 = 0;\\n        long long dp0 = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'0\\') {\\n                cnt0++;\\n                ans += dp1;\\n                dp0 += cnt1;\\n            }\\n            else {\\n                cnt1++;\\n                ans += dp0;\\n                dp1 += cnt0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans = 0;\\n\\n        int cnt0 = 0;\\n        int cnt1 = 0;\\n\\n        long long dp1 = 0;\\n        long long dp0 = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'0\\') {\\n                cnt0++;\\n                ans += dp1;\\n                dp0 += cnt1;\\n            }\\n            else {\\n                cnt1++;\\n                ans += dp0;\\n                dp1 += cnt0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049446,
                "title": "o-n-linear-solution",
                "content": "# Intuition\\nWe are looking for 010 or 101 combinations.\\n\\n# Approach\\n[Note] : sorry for being long in explaining the approach. \\ncount all zeros (**numberOfzeros**) and all ones in (**numberOfOnes**)\\nfor any indx **i** we can check how many ways to build those combinations **010** or **101**\\ne:g **0010** assume you are at index **i = 2 => s[i] = 1** there are two zeros on the left **(i = 0, i = 1)** and one zero at right **(i = 3)**\\nthink of it, you can combine any zero of those two (**i = 0 or i =1**) from left with the current element **(i = 2)** in this case we can take one time **i = 0** with **i = 2** and also we can take **i = 1** with **i = 2** then two ways to build two numbers, this count caused by count of zeros on **left** **(2)**.\\ndo the same for zeros on **right** : we have only one zero at **(i = 3)** then there will be one way to build **10** product number of ways on left and right to get the possible ways to build **010** => **2 * 1**  and this is correct. \\n\\n**But wait ! how do we know count of zeros on left and right ?**\\nyou remember that we counted all zeros in string using (**numberOfzeros**). we can create another variable **tempZerosCountSoFar** and whenever we see any **\\'0\\'** using current index **i** increment **tempZerosCountSoFar**  by one. till you face **\\'1\\'** in this case i know the number of zeros on left and hence i can know number of zeros on right of current index by simply subtract **tempZerosCountSoFar** from (**numberOfzeros**). \\nand to get the total ways of combinarions : multiply count of zeros on left by count of zeros on right. and add it to the **count** variable which represents number of ways to build **010** or **101** \\n\\nDo the same for **101** in the same iteration. using **tempOnesCountSoFar**\\nand **numberOfOnes** variables. increment **tempOnesCountSoFar** when you face **\\'1\\'** and calculate number of ones on right simply by subtracting **tempOnesCountSoFar** from (**numberOfOnes**). \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numberOfWays = function(s) {\\n    let numberOfzeros = 0, numberOfOnes = 0;\\n    for(let c of s) c === \\'0\\' ? numberOfzeros++ : numberOfOnes++;\\n    let tempZerosCountSoFar = 0;\\n    let tempOnesCountSoFar = 0;\\n    let count = 0;\\n    for(let c of s) {\\n        if(c === \\'1\\') {\\n            count += tempZerosCountSoFar * (numberOfzeros - tempZerosCountSoFar);\\n            tempOnesCountSoFar++;\\n        } else {\\n            count += tempOnesCountSoFar * (numberOfOnes - tempOnesCountSoFar);\\n            tempZerosCountSoFar++;\\n        }\\n    }\\n    return count;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numberOfWays = function(s) {\\n    let numberOfzeros = 0, numberOfOnes = 0;\\n    for(let c of s) c === \\'0\\' ? numberOfzeros++ : numberOfOnes++;\\n    let tempZerosCountSoFar = 0;\\n    let tempOnesCountSoFar = 0;\\n    let count = 0;\\n    for(let c of s) {\\n        if(c === \\'1\\') {\\n            count += tempZerosCountSoFar * (numberOfzeros - tempZerosCountSoFar);\\n            tempOnesCountSoFar++;\\n        } else {\\n            count += tempOnesCountSoFar * (numberOfOnes - tempOnesCountSoFar);\\n            tempZerosCountSoFar++;\\n        }\\n    }\\n    return count;\\n};\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1770173,
                "content": [
                    {
                        "username": "ctlang",
                        "content": "O(n^3) brute force solution so you might think O(n^2) would be good but it's not even close. I came up with a O(n) solution that nearly TLE'd.  There are single-pass solutions with soul crushing simplicity that require deep analysis to understand and it probably warrants a \"hard\".  Keep multiplication to a minimum or don't use it at all."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "dp is tricky since day 1. The complexity of new dp problems are just stacking up more information. But the general form of a dp problem never changed. "
                    },
                    {
                        "username": "tsnl42",
                        "content": "I think this problem is missing an additional constraint. The visitor can only travel down the street one-way. This means that for each selection of three buildings with indices $i_0$, $i_1$, and $i_2$, we have $i_1 < i_2 < i_3$"
                    },
                    {
                        "username": "chanhttg",
                        "content": "This would be a helpful constraint mentioned, although I\\'d understand if they decided not to use it in the description. Because this is another way of saying that every 3 chosen buildings are unique."
                    },
                    {
                        "username": "divyanshojha99",
                        "content": "This is Easy If you are good in Map can do"
                    }
                ]
            },
            {
                "id": 2017716,
                "content": [
                    {
                        "username": "ctlang",
                        "content": "O(n^3) brute force solution so you might think O(n^2) would be good but it's not even close. I came up with a O(n) solution that nearly TLE'd.  There are single-pass solutions with soul crushing simplicity that require deep analysis to understand and it probably warrants a \"hard\".  Keep multiplication to a minimum or don't use it at all."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "dp is tricky since day 1. The complexity of new dp problems are just stacking up more information. But the general form of a dp problem never changed. "
                    },
                    {
                        "username": "tsnl42",
                        "content": "I think this problem is missing an additional constraint. The visitor can only travel down the street one-way. This means that for each selection of three buildings with indices $i_0$, $i_1$, and $i_2$, we have $i_1 < i_2 < i_3$"
                    },
                    {
                        "username": "chanhttg",
                        "content": "This would be a helpful constraint mentioned, although I\\'d understand if they decided not to use it in the description. Because this is another way of saying that every 3 chosen buildings are unique."
                    },
                    {
                        "username": "divyanshojha99",
                        "content": "This is Easy If you are good in Map can do"
                    }
                ]
            },
            {
                "id": 2051832,
                "content": [
                    {
                        "username": "ctlang",
                        "content": "O(n^3) brute force solution so you might think O(n^2) would be good but it's not even close. I came up with a O(n) solution that nearly TLE'd.  There are single-pass solutions with soul crushing simplicity that require deep analysis to understand and it probably warrants a \"hard\".  Keep multiplication to a minimum or don't use it at all."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "dp is tricky since day 1. The complexity of new dp problems are just stacking up more information. But the general form of a dp problem never changed. "
                    },
                    {
                        "username": "tsnl42",
                        "content": "I think this problem is missing an additional constraint. The visitor can only travel down the street one-way. This means that for each selection of three buildings with indices $i_0$, $i_1$, and $i_2$, we have $i_1 < i_2 < i_3$"
                    },
                    {
                        "username": "chanhttg",
                        "content": "This would be a helpful constraint mentioned, although I\\'d understand if they decided not to use it in the description. Because this is another way of saying that every 3 chosen buildings are unique."
                    },
                    {
                        "username": "divyanshojha99",
                        "content": "This is Easy If you are good in Map can do"
                    }
                ]
            }
        ]
    }
]